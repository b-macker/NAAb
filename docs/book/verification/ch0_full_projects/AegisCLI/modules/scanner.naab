// AegisCLI/modules/scanner.naab
// High-performance file scanner using Rust.
// Uses: <<rust>>, json, io

use io
use json
use file
use array
use string

// ── Rust File Scanner (High Performance) ────────────────────────

fn rust_scan(root_path, ignore_list) {
    let ignore_json = json.stringify(ignore_list)
    
    let result = <<rust[root_path, ignore_json]
    use std::fs;
    use std::path::{Path, PathBuf};
    use std::collections::HashSet;
    use std::time::SystemTime;
    use std::io::Read;

    // A simple struct for file info
    struct FileInfo {
        path: String,
        size: u64,
        is_dir: bool,
        modified: u64,
        hash: String,
    }

    fn simple_sha256(path: &Path) -> String {
        // Only hash small files for speed in this demo
        // For larger files, we might skip hashing or use a faster hash
        if let Ok(metadata) = fs::metadata(path) {
            if metadata.len() > 1024 * 1024 { return "too_large".to_string(); }
        }
        
        if let Ok(mut file) = fs::File::open(path) {
            let mut buffer = Vec::new();
            if file.read_to_end(&mut buffer).is_ok() {
                // simple hash simulation (avoiding external crate dep for this demo)
                // In real app, include sha2 crate.
                let mut h: u64 = 0xcbf29ce484222325;
                for b in buffer {
                    h ^= b as u64;
                    h = h.wrapping_mul(0x100000001b3);
                }
                return format!("{:x}", h);
            }
        }
        "error".to_string()
    }

    fn scan_dir(dir: &Path, ignores: &HashSet<String>, results: &mut Vec<FileInfo>) {
        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries {
                if let Ok(entry) = entry {
                    let path = entry.path();
                    let file_name = entry.file_name().to_string_lossy().to_string();
                    
                    // Simple ignore logic (exact match)
                    if ignores.contains(&file_name) { continue; }
                    // Also ignore hidden files/dirs starting with . except explicitly allowed ones
                    if file_name.starts_with(".") && file_name != "." && file_name != ".." { continue; }

                    if path.is_dir() {
                        scan_dir(&path, ignores, results);
                    } else {
                        let metadata = fs::metadata(&path).unwrap();
                        let modified = metadata.modified().unwrap_or(SystemTime::UNIX_EPOCH) 
                            .duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs();
                            
                        results.push(FileInfo {
                            path: path.to_string_lossy().to_string(),
                            size: metadata.len(),
                            is_dir: false,
                            modified: modified,
                            hash: simple_sha256(&path),
                        });
                    }
                }
            }
        }
    }

    // Parse ignore list from JSON string
    let ignore_str = ignore_json;
    let mut ignores = HashSet::new();
    // Manual JSON array parsing since we don't have serde here
    let trimmed = ignore_str.trim_matches(|c| c == '[' || c == ']');
    for s in trimmed.split(',') {
        let clean = s.trim().trim_matches('"');
        if !clean.is_empty() {
            ignores.insert(clean.to_string());
        }
    }

    let root = Path::new(&root_path);
    let mut files = Vec::new();
    scan_dir(root, &ignores, &mut files);

    // Manual JSON construction
    let mut json_out = String::from("[");
    for (i, f) in files.iter().enumerate() {
        if i > 0 { json_out.push(','); }
        json_out.push_str(&format!(
            "{{\"path\":\"{}\",\"size\":{},\"modified\":{},\"hash\":\" மூல{}\"}}",
            f.path.replace("\\", "/"), f.size, f.modified, f.hash
        ));
    }
    json_out.push(']');
    json_out
    >>
    
    return json.parse(result)
}

// ── Public Interface ────────────────────────────────────────────

export fn init(config) {
    io.write("  [Scanner] Initialized Rust engine.\n")
    return {
        "config": config,
        "last_scan": [],
        "context_cache": {}
    }
}

export fn scan_workspace(root_path) {
    // We need to fetch the config (usually passed in context or global via init)
    // Here we'll just assume default ignores for the demo call if not provided
    let ignores = [".git", "node_modules", "target", "dist", "build", "__pycache__"]
    
    io.write("  [Scanner] Scanning ", root_path, "...\n")
    let start = time.now()
    
    let files = rust_scan(root_path, ignores)
    
    let end = time.now()
    let elapsed = end - start
    
    io.write("  [Scanner] Found ", array.length(files), " files in ", elapsed, "ms\n")
    
    return files
}

export fn get_context() {
    // This would return the cached file list + content summaries for the LLM
    // For now, return a placeholder structure
    return {
        "files": [],
        "summary": "Workspace context not yet built."
    }
}
