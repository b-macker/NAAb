// polyglot_tower/main.naab
use io
use json
use array
use math // For random numbers (simulated)

// Import all polyglot modules
use modules.types
use modules.world
use modules.combat
use modules.inventory
use modules.system
use modules.ai
use modules.forge
use modules.engine
use modules.dungeon // New dungeon module

// Helper to simulate random choice (NAAb doesn't have native random yet)
fn simulate_random_choice(choices: list<string>) -> string {
    let seed_str = json.stringify(time.now()) // Use current time as a seed
    let choice_idx = <<javascript[seed_str, json.stringify(choices)]
        const seed = parseFloat(seed_str);
        const choices_js = JSON.parse(choices_str);
        // Simple seeded pseudo-random for demonstration
        const rand = (Math.sin(seed) * 10000) % 1;
        const index = Math.floor(rand * choices_js.length);
        return choices_js[index];
    >>
    return choice_idx
}


main {
    io.write("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
    io.write("â•‘         THE POLYGLOT TOWER: ASCENSION                â•‘\n")
    io.write("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

    // --- SETUP: PLAYER INITIALIZATION ---
    io.write("Initializing Hero...\n")
    let player_start_weapon = new types.Item { name: "Rusty Dagger", type: "weapon", value: 5, attack_bonus: 5, defense_bonus: null, effect: null, rarity: "common" }
    let player_start_armor = new types.Item { name: "Cloth Vest", type: "armor", value: 5, attack_bonus: null, defense_bonus: 2, effect: null, rarity: "common" }

    let player = new types.Player {
        name: "Code Warrior",
        hp: 100,
        max_hp: 100,
        attack: 10,
        defense: 5, // Base defense
        gold: 0,
        x: 0, // Player starts at 0,0
        y: 0,
        inventory: [],
        equipped_weapon: player_start_weapon,
        equipped_armor: player_start_armor,
        current_room: null
    }
    array.push(player.inventory, player_start_weapon)
    array.push(player.inventory, player_start_armor)

    let total_game_turns = 0
    let current_floor_number = 1
    let max_floors = 3
    let floor_size = 5 // 5x5 grid for each floor

    // --- GAME LOOP: FLOORS ---
    while current_floor_number <= max_floors {
        io.write("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
        io.write("  ENTERING FLOOR ", current_floor_number, " of ", max_floors, "\n")
        io.write("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

        // 1. Generate Dungeon Floor (Python)
        let dungeon_grid = dungeon.generate_dungeon_floor(current_floor_number, floor_size)
        // Player starts in the "start" room (0,0)
        player.x = 0
        player.y = 0
        player.current_room = dungeon_grid[player.y][player.x]
        io.write("  [Python] Dungeon layout generated for Floor ", current_floor_number, ".\n")

        let floor_completed = false
        // --- GAME LOOP: TURNS ON CURRENT FLOOR ---
        while !floor_completed && player.hp > 0 {
            total_game_turns = total_game_turns + 1

            io.write("\n--- Turn ", total_game_turns, " ---\n")
            
            // Re-calculate effective stats based on equipped items
            let effective_stats = inventory.calculate_total_stats(
                player.attack, player.defense, player.equipped_weapon, player.equipped_armor
            )
            player.attack = effective_stats["attack"]
            player.defense = effective_stats["defense"]

            // Render Map & Status (Bash)
            dungeon.render_map(dungeon_grid, player.x, player.y)
            io.write("  Player HP: ", player.hp, "/", player.max_hp, " | Attack: ", player.attack, " | Defense: ", player.defense, "\n")
            io.write("  Current Room: (", player.x, ",", player.y, ") Type: ", player.current_room.type, "\n")
            io.write(inventory.list_inventory(player.inventory))

            // Apply room effects (Bash)
            if player.current_room.effect_type != null {
                io.write("  Applying room effect: ", player.current_room.effect_type, "...\n")
                player = dungeon.apply_room_effect(player, player.current_room)
                if player.hp <= 0 {
                    io.write("\n  ğŸ’€ YOU DIED from room effect.\n")
                    break
                }
            }

            // Global Game Events (JavaScript)
            let global_event = engine.process_turn(total_game_turns)
            if global_event != null {
                io.write("\n  â— [Global Event] ", global_event.type, ": ", global_event.message, "\n")
                if global_event.type == "TRAP" {
                    player.hp = player.hp - 5
                    io.write("       You took 5 trap damage!\n")
                } else if global_event.type == "HUNGER" {
                    io.write("       You eat a snack.\n")
                }
            }
            
            // --- PLAYER ACTION (Simplified: auto-move towards stairs) ---
            io.write("  [NAAb] Player decides to move...\n")
            let next_x = player.x
            let next_y = player.y

            // Simple AI to move towards stairs (bottom-right)
            if player.x < floor_size - 1 { next_x = player.x + 1 }
            else if player.y < floor_size - 1 { next_y = player.y + 1 }
            
            // Update player position
            if dungeon_grid[next_y][next_x] != null { // Basic bounds check
                player.x = next_x
                player.y = next_y
                player.current_room = dungeon_grid[player.y][player.x]
                io.write("  Moved to (", player.x, ",", player.y, ").\n")
            } else {
                io.write("  Cannot move there. Staying put.\n")
            }


            // --- ROOM INTERACTION ---
            if player.current_room.type == "stairs" {
                io.write("\n  ğŸªœ Found the stairs to the next floor!\n")
                floor_completed = true
                continue // Break from inner loop
            } else if player.current_room.enemy != null && !player.current_room.enemy.is_dead {
                // --- COMBAT ENCOUNTER (Python AI + Rust/Ruby) ---
                io.write("\n  âš”ï¸  Combat with ", player.current_room.enemy.name, "! (HP: ", player.current_room.enemy.hp, ")\n")
                let current_enemy = player.current_room.enemy

                while !current_enemy.is_dead && player.hp > 0 {
                    // Re-calculate effective stats
                    effective_stats = inventory.calculate_total_stats(
                        player.attack, player.defense, player.equipped_weapon, player.equipped_armor
                    )
                    player.attack = effective_stats["attack"]
                    player.defense = effective_stats["defense"]

                    io.write("  Player HP: ", player.hp, " | Attack: ", player.attack, " | Defense: ", player.defense, "\n")
                    io.write("  Enemy HP: ", current_enemy.hp, " | Attack: ", current_enemy.attack, " | Defense: ", current_enemy.defense, "\n")

                    // Player Turn
                    let player_damage = combat.calculate_damage(player.attack, current_enemy.defense)
                    current_enemy.hp = current_enemy.hp - player_damage
                    io.write("  [Ruby] ", combat.describe_attack("Player", player_damage), "\n")
                    io.write("       Enemy HP: ", current_enemy.hp, "/", current_enemy.max_hp, "\n")
                    
                    if current_enemy.hp <= 0 {
                        current_enemy.is_dead = true
                        player.current_room.enemy = current_enemy // Update room state
                        io.write("  ğŸ‰ ", current_enemy.name, " defeated!\n")
                        break // Exit combat loop
                    }

                    // Enemy Turn (Python AI)
                    let enemy_json = json.stringify(current_enemy)
                    let player_json = json.stringify(player)
                    let ai_move = ai.decide_action(enemy_json, player_json)
                    io.write("  [AI] ", ai_move.message, "\n")
                    
                    if ai_move.action_type == "ATTACK" {
                        // Enemy damage calculation, considering player defense
                        let enemy_attack_value = ai_move.value
                        let effective_player_damage = 0
                        if enemy_attack_value > player.defense { 
                            effective_player_damage = enemy_attack_value - player.defense 
                        } else { 
                            effective_player_damage = 0 
                        }
                        player.hp = player.hp - effective_player_damage
                        io.write("       You take ", effective_player_damage, " damage! (HP: ", player.hp, "/", player.max_hp, ")\n")
                    } else if ai_move.action_type == "HEAL" {
                        current_enemy.hp = current_enemy.hp + ai_move.value
                        if current_enemy.hp > current_enemy.max_hp { current_enemy.hp = current_enemy.max_hp }
                        io.write("       ", current_enemy.name, " healed ", ai_move.value, " HP! (HP: ", current_enemy.hp, "/", current_enemy.max_hp, ")\n")
                    } else if ai_move.action_type == "DEFEND" {
                        io.write("       ", current_enemy.name, " defends, increasing its effective defense.\n")
                        // For simplicity, we just print, but could add temp defense buff
                    }
                    // Fleeing would be more complex to implement in this loop, so we'll skip for now.

                    if player.hp <= 0 {
                        io.write("\n  ğŸ’€ YOU DIED in combat.\n")
                        break // Exit combat loop
                    }
                } // End combat while loop

            } else if player.current_room.loot != null {
                io.write("\n  ğŸ’° Found loot: ", player.current_room.loot.name, " (Value: ", player.current_room.loot.value, ")\n")
                array.push(player.inventory, player.current_room.loot)
                player.gold = player.gold + player.current_room.loot.value
                player.current_room.loot = null // Loot taken
                io.write("       You now have ", player.gold, " gold.\n")
            }
            io.write("\n") // Newline for readability
        } // End floor turn loop

        if player.hp <= 0 {
            break // Exit floor loop if player died
        }

        current_floor_number = current_floor_number + 1
    } // End floor loop

    // --- ENDGAME ---
    io.write("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
    if player.hp > 0 {
        io.write("  ğŸ† CONGRATULATIONS, ", player.name, "! You ascended the tower!\n")
        io.write("     Final HP: ", player.hp, "/", player.max_hp, "\n")
        io.write("     Gold: ", player.gold, "\n")
        io.write("     Inventory:\n", inventory.list_inventory(player.inventory))
    } else {
        io.write("  ğŸ‘» GAME OVER, ", player.name, ".\n")
        io.write("     You fought bravely.\n")
    }
    io.write("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    
    // Final Save Game (Bash + C#)
    let save_data = json.stringify(player)
    let checksum = system.calculate_checksum(save_data)
    io.write("\n  [C#] Final Save Checksum: ", checksum, "\n")
    system.save_game("ascension_final_save.json", save_data)
    
    io.write("\nGame Over! Thanks for playing.\n")
}
