// polyglot_tower/modules/dungeon.naab
use io
use json
use array
use types

// Python generates the complex floor layout with room types and effects
export fn generate_dungeon_floor(level: int, size: int) -> list<list<types.Room>> {
    io.write("  [Python] Generating Dungeon Floor (Level ", level, ", Size ", size, ")...\n")
    
    let floor_data_json = <<python[level, size]
import random
import json

floor_level = level
grid_size = size

room_types = ["empty", "enemy", "loot"]
environmental_effects = [None, {"type": "darkness", "strength": 1}, {"type": "poison_gas", "strength": 2}]

dungeon_grid_data = []

# Generate grid
for r in range(grid_size):
    row = []
    for c in range(grid_size):
        room_type = random.choice(room_types)
        effect = random.choice(environmental_effects)
        
        # Ensure start and end are special
        if r == 0 and c == 0:
            room_type = "start"
            effect = None
        elif r == grid_size - 1 and c == grid_size - 1:
            room_type = "stairs"
            effect = None
        
        enemy_data = None
        if room_type == "enemy":
            enemy_name = f"Goblin {floor_level}.{random.randint(1,5)}"
            enemy_hp = 10 * floor_level + random.randint(0, 5)
            enemy_attack = 5 * floor_level + random.randint(0, 3)
            enemy_defense = 2 * floor_level
            enemy_ai = random.choice(["aggressive", "defensive"])
            enemy_data = {
                "name": enemy_name, 
                "hp": enemy_hp, 
                "max_hp": enemy_hp, 
                "attack": enemy_attack, 
                "defense": enemy_defense,
                "is_dead": False,
                "ai_type": enemy_ai
            }
        
        loot_data = None
        if room_type == "loot":
            loot_name = f"Gold Pile {random.randint(1,10)}"
            loot_value = random.randint(10, 50) * floor_level
            loot_data = {
                "name": loot_name, 
                "type": "currency", 
                "value": loot_value, 
                "attack_bonus": None, 
                "defense_bonus": None, 
                "effect": None,
                "rarity": "common"
            }
        
        room_obj = {
            "x": c, 
            "y": r, 
            "type": room_type,
            "enemy": enemy_data,
            "loot": loot_data,
            "effect_type": effect["type"] if effect else None,
            "effect_strength": effect["strength"] if effect else None
        }
        row.append(room_obj)
    dungeon_grid_data.append(row)

json.dumps(dungeon_grid_data)
    >>
    
    // Deserialize the JSON string back into a list of lists of Room structs
    let parsed_grid_json = json.parse(floor_data_json)
    let dungeon_grid: list<list<types.Room>> = []

    for row_data in parsed_grid_json {
        let room_row: list<types.Room> = []
        for room_data in row_data {
            let enemy: types.Enemy? = null
            if room_data["enemy"] != null {
                enemy = new types.Enemy {
                    name: room_data["enemy"]["name"],
                    hp: room_data["enemy"]["hp"],
                    max_hp: room_data["enemy"]["max_hp"],
                    attack: room_data["enemy"]["attack"],
                    defense: room_data["enemy"]["defense"],
                    is_dead: room_data["enemy"]["is_dead"],
                    ai_type: room_data["enemy"]["ai_type"]
                }
            }

            let loot: types.Item? = null
            if room_data["loot"] != null {
                loot = new types.Item {
                    name: room_data["loot"]["name"],
                    type: room_data["loot"]["type"],
                    value: room_data["loot"]["value"],
                    attack_bonus: null, defense_bonus: null, effect: null, rarity: null
                }
            }

            array.push(room_row, new types.Room {
                x: room_data["x"],
                y: room_data["y"],
                type: room_data["type"],
                enemy: enemy,
                loot: loot,
                effect_type: room_data["effect_type"],
                effect_strength: room_data["effect_strength"]
            })
        }
        array.push(dungeon_grid, room_row)
    }
    
    return dungeon_grid
}

// Bash renders the current map to the console
export fn render_map(grid: list<list<types.Room>>, player_x: int, player_y: int) {
    io.write("\n  [NAAb] Current Floor Map:\n")

    let grid_size = array.length(grid)
    let map_str = ""

    let r = 0
    while r < grid_size {
        let c = 0
        let row_str = "    " // Indent map
        while c < grid_size {
            let room = grid[r][c]
            let char_to_draw = "?" // Default unknown

            if r == player_y && c == player_x {
                char_to_draw = "@" // Player
            } else if room.type == "start" {
                char_to_draw = "S"
            } else if room.type == "stairs" {
                char_to_draw = ">"
            } else if room.type == "enemy" && room.enemy != null && !room.enemy.is_dead {
                char_to_draw = "E"
            } else if room.type == "loot" && room.loot != null {
                char_to_draw = "L"
            } else if room.effect_type == "darkness" {
                char_to_draw = "#"
            } else if room.effect_type == "poison_gas" {
                char_to_draw = "X"
            } else {
                char_to_draw = "." // Empty
            }
            row_str = row_str + char_to_draw + " "
            c = c + 1
        }
        map_str = map_str + row_str + "\n"
        r = r + 1
    }
    io.write(map_str)
}

// Bash applies environmental effects (simulated damage/healing)
export fn apply_room_effect(player: types.Player, current_room: types.Room) -> types.Player {
    if current_room.effect_type == "poison_gas" && current_room.effect_strength != null {
        let damage = current_room.effect_strength
        player.hp = player.hp - damage
        io.write("  [Bash] You're in poison gas! You take ", damage, " damage. (HP: ", player.hp, ")\n")
    } else if current_room.effect_type == "healing_mist" && current_room.effect_strength != null {
        let heal = current_room.effect_strength
        player.hp = player.hp + heal
        if player.hp > player.max_hp { player.hp = player.max_hp }
        io.write("  [Bash] Healing mist! You recover ", heal, " HP. (HP: ", player.hp, ")\n")
    }
    return player
}

