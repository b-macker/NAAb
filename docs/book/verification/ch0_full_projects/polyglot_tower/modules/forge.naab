// polyglot_tower/modules/forge.naab
use io
use json
use types

export fn forge_item(level: int, quality: int) -> types.Item {
    io.write("  [Rust] Forging item (Level ", level, ", Quality ", quality, ")...
")

    // Rust procedural generation
    let item_json = <<rust[level, quality]
    let lvl = level;
    let qual = quality;
    
    // Arrays of name parts
    let prefixes_bad = ["Broken", "Rusted", "Dull", "Cracked"];
    let prefixes_good = ["Sharp", "Polished", "Balanced", "Heavy"];
    let prefixes_epic = ["Vorpal", "Flaming", "Frozen", "Void"];
    
    let roots = ["Sword", "Axe", "Dagger", "Mace"];
    
    let suffixes = ["of Weakness", "of Power", "of Speed", "of Doom"];
    
    // Simple pseudo-random logic based on level/quality inputs to be deterministic for this demo
    // (In a real app we'd import rand crate, but stdlib only here)
    let seed = (lvl * qual) as usize;
    
    let root_idx = seed % roots.len();
    let root = roots[root_idx];
    
    let name_string;
    let val;
    
    if qual > 80 {
        let p_idx = seed % prefixes_epic.len();
        let s_idx = seed % suffixes.len();
        name_string = format!("{} {} {}", prefixes_epic[p_idx], root, suffixes[s_idx]);
        val = lvl * 50;
    } else if qual > 40 {
        let p_idx = seed % prefixes_good.len();
        name_string = format!("{} {}", prefixes_good[p_idx], root);
        val = lvl * 20;
    } else {
        let p_idx = seed % prefixes_bad.len();
        name_string = format!("{} {}", prefixes_bad[p_idx], root);
        val = lvl * 5;
    }
    
    // Construct JSON manually string formatting
    let json = format!("{{\"name\": \"{}\", \"type\": \"weapon\", \"value\": {}}}", name_string, val);
    
    // Return the JSON string
    json
    >>
    
    let parsed = json.parse(item_json)
    
    return new types.Item {
        name: parsed["name"],
        type: parsed["type"],
        value: parsed["value"]
    }
}
