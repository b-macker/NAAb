// ============================================================================ 
// Enterprise DevOps System - Complete NAAb Feature Showcase
// Real-world monitoring, alerting, and analytics platform
// Demonstrates ALL phases: Parser, Type System, Runtime, Stdlib, Performance
// ============================================================================ 

// PHASE 5: Import standard library modules
use time as time
use array as array
use json as json
use string as string
use regex as regex
use crypto as crypto

// PHASE 2.4.3: Enums for status tracking
enum ServiceStatus {
    HEALTHY,
    DEGRADED,
    CRITICAL,
    UNKNOWN
}

enum AlertLevel {
    INFO,
    WARNING,
    ERROR,
    CRITICAL
}

// PHASE 2.4.1: Generic Result type for error handling
struct Result<T> {
    success: bool,
    data: T?,
    error_msg: string?
}

// PHASE 2: Structs with nullable types (Phase 2.4.5)
struct ServerMetrics {
    hostname: string,
    cpu_usage: float,
    memory_usage: float,
    disk_usage: float,
    request_count: int,
    error_count: int,
    status: string,  // Use string for status
    last_error: string?  // PHASE 2.4.5: Nullable field
}

struct AlertRule {
    metric_name: string,
    threshold: float,
    level: AlertLevel,
    enabled: bool
}

struct MonitoringReport {
    total_servers: int,
    healthy_count: int,
    degraded_count: int,
    critical_count: int,
    avg_cpu: float,
    avg_memory: float,
    total_errors: int
}

// PHASE 2.1: Reference semantics - function with struct parameter
fn evaluate_server_health(metrics: ServerMetrics, rules: list) -> string {
    // Check critical thresholds
    if metrics.cpu_usage > 95.0 || metrics.memory_usage > 95.0 || metrics.disk_usage > 95.0 {
        return "CRITICAL"
    }

    // Check degraded thresholds
    if metrics.cpu_usage > 80.0 || metrics.memory_usage > 85.0 || metrics.error_count > 10 {
        return "DEGRADED"
    }

    return "HEALTHY"
}

// PHASE 5: Multi-language polyglot data collection
fn collect_system_metrics(server_name: string) -> ServerMetrics {
    // PHASE 5: Time module
    let timestamp = time.now()

    // CPU metrics using Python (realistic simulation)
    let cpu_val: float? = <<python
import random
random.uniform(45.0, 95.0)
    >>

    let cpu = 65.5
    if cpu_val != null {
        cpu = cpu_val
    }

    // Memory metrics using C++ for performance
    let mem_val: float? = <<cpp
85.5;
    >>

    let memory = 70.0
    if mem_val != null {
        memory = mem_val
    }

    // Disk usage - set directly (Phase 1 parser working)
    let disk_float = 78.3

    // Request counting - set directly
    let requests = 1234

    // Error simulation - set directly
    let errors = 7

    // Determine last error message
    let last_err: string? = null
    if errors > 10 {
        last_err = "High error rate detected"
    }

    return new ServerMetrics {
        hostname: server_name,
        cpu_usage: cpu,
        memory_usage: memory,
        disk_usage: disk_float,
        request_count: requests,
        error_count: errors,
        status: "UNKNOWN",  // Will be evaluated
        last_error: last_err
    }
}

// PHASE 3.1: Try/catch error handling with logging
fn store_metrics_to_file(metrics: ServerMetrics) -> Result<string> {
    try {
        // PHASE 5: File I/O (simulated - metrics saved)
        let filename = "metrics_log.json"
        print("  âœ“ Metrics saved to ", filename)

        return new Result<string> {
            success: true,
            data: filename,
            error_msg: null
        }
    } catch (err) {
        return new Result<string> {
            success: false,
            data: null,
            error_msg: string.concat("File write failed: ", err)
        }
    } finally {
        // PHASE 3.1: Finally block always executes
        print("  ğŸ“ Metrics logging complete")
    }
}

// PHASE 5: Statistical analysis using multiple languages
fn perform_analytics(all_metrics: list) -> MonitoringReport {
    let server_count = array.length(all_metrics)

    // Calculate aggregates directly in NAAb
    let total_cpu = 0.0
    let total_memory = 0.0
    let total_errors = 0

    let j = 0
    while j < server_count {
        let m = all_metrics[j]
        total_cpu = total_cpu + m.cpu_usage
        total_memory = total_memory + m.memory_usage
        total_errors = total_errors + m.error_count
        j = j + 1
    }

    let avg_cpu_val = 0.0
    let avg_mem_val = 0.0
    if server_count > 0 {
        avg_cpu_val = total_cpu / server_count
        avg_mem_val = total_memory / server_count
    }

    // Count status categories
    let healthy = 0
    let degraded = 0
    let critical = 0

    let i = 0
    while i < server_count {
        let metrics = all_metrics[i]
        if metrics.status == "HEALTHY" {
            healthy = healthy + 1
        } else if metrics.status == "DEGRADED" {
            degraded = degraded + 1
        } else if metrics.status == "CRITICAL" {
            critical = critical + 1
        }
        i = i + 1
    }

    return new MonitoringReport {
        total_servers: server_count,
        healthy_count: healthy,
        degraded_count: degraded,
        critical_count: critical,
        avg_cpu: avg_cpu_val,
        avg_memory: avg_mem_val,
        total_errors: total_errors
    }
}

// Generate executive dashboard with visual formatting
fn create_dashboard(report: MonitoringReport) -> string {
    // Print dashboard directly instead of building string
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘         ENTERPRISE MONITORING DASHBOARD v1.0                â•‘")
    print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
    print("â•‘                                                              â•‘")
    print("â•‘  ğŸ“Š FLEET STATUS                                            â•‘")
    print("â•‘     Total Servers: ", report.total_servers, "                                         â•‘")
    print("â•‘     âœ… Healthy:     ", report.healthy_count, "                                          â•‘")
    print("â•‘     âš ï¸  Degraded:    ", report.degraded_count, "                                          â•‘")
    print("â•‘     ğŸ”´ Critical:    ", report.critical_count, "                                          â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  ğŸ’» RESOURCE UTILIZATION                                    â•‘")
    print("â•‘     CPU:    ", report.avg_cpu, "%                                       â•‘")
    print("â•‘     Memory: ", report.avg_memory, "%                                       â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  âš¡ OPERATIONAL METRICS                                      â•‘")
    print("â•‘     Total Errors: ", report.total_errors, "                                      â•‘")
    print("â•‘                                                              â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

    return "Dashboard displayed above"
}

// PHASE 5: Advanced threat detection using regex
fn scan_for_threats(log_entries: list) -> list {
    let threats = []

    // PHASE 5: Regex module for pattern matching
    let i = 0
    while i < array.length(log_entries) {
        let entry = log_entries[i]

        // Detect SQL injection attempts
        let has_sql_injection = regex.matches(entry, "SELECT.*FROM|DROP TABLE|UNION SELECT")

        // Detect XSS attempts
        let has_xss = regex.matches(entry, "<script|javascript:|onerror=")

        // Detect authentication failures
        let has_auth_fail = regex.matches(entry, "authentication failed|login failed|unauthorized")

        if has_sql_injection || has_xss || has_auth_fail {
            array.push(threats, entry)
        }

        i = i + 1
    }

    return threats
}

// PHASE 5: Cryptographic signing for alerts
fn sign_alert(message: string) -> string {
    // PHASE 5: Crypto module
    let signature = crypto.sha256(message)
    let short_sig = string.substring(signature, 0, 16)

    let signed_msg: string = <<javascript[message, short_sig]
`[SIGNED] ${message}
Signature: ${short_sig}...`;
    >>

    return signed_msg
}

// Main enterprise monitoring workflow
main {
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘      NAAb Enterprise DevOps Monitoring Platform             â•‘")
    print("â•‘      Complete Feature Demonstration                         â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    // PHASE 3.1: Comprehensive error handling
    try {
        print("ğŸš€ Initializing monitoring system...\n")

        // Define production server fleet
        let servers = [
            "web-prod-01",
            "web-prod-02",
            "web-prod-03",
            "api-gateway-01",
            "api-gateway-02",
            "db-primary-01",
            "db-replica-01",
            "cache-redis-01",
            "queue-rabbitmq-01",
            "search-elastic-01"
        ]

        print("ğŸ“¡ Monitoring ", array.length(servers), " production servers")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

        // Collect metrics from all servers
        let all_metrics = []
        let alert_rules = []

        // PHASE 2.4.6: Array element assignment
        let idx = 0
        while idx < array.length(servers) {
            let server = servers[idx]
            print("â†’ Scanning ", server, "...")

            // Collect metrics using polyglot execution
            let metrics = collect_system_metrics(server)

            // Evaluate health status
            metrics.status = evaluate_server_health(metrics, alert_rules)

            // Display real-time metrics
            let status_icon = "âœ…"
            if metrics.status == "DEGRADED" {
                status_icon = "âš ï¸ "
            } else if metrics.status == "CRITICAL" {
                status_icon = "ğŸ”´"
            }

            print("  ", status_icon, " CPU: ", metrics.cpu_usage, "% | Mem: ",
                  metrics.memory_usage, "% | Disk: ", metrics.disk_usage, "%")
            print("  ğŸ“Š Requests: ", metrics.request_count, " | Errors: ", metrics.error_count)

            // Store metrics
            array.push(all_metrics, metrics)

            // Store to file with error handling
            let store_result: Result<string>? = store_metrics_to_file(metrics)
            if store_result != null {
                if !store_result.success {
                    print("  âš ï¸  Warning: ", store_result.error_msg)
                }
            }

            print("")
            idx = idx + 1
        }

        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

        // Perform analytics
        print("ğŸ“Š Generating analytics report...\n")
        let report = perform_analytics(all_metrics)

        // Display dashboard
        let dashboard = create_dashboard(report)

        // Security threat scanning
        print("\nğŸ”’ Security Analysis:")
        let sample_logs = [
            "2026-01-23 User login successful",
            "2026-01-23 SELECT * FROM users WHERE id=1; DROP TABLE users--",
            "2026-01-23 Normal API request",
            "2026-01-23 <script>alert('XSS')</script>",
            "2026-01-23 authentication failed for user admin"
        ]

        let threats = scan_for_threats(sample_logs)
        print("  Scanned ", array.length(sample_logs), " log entries")
        print("  âš ï¸  Detected ", array.length(threats), " potential threats")

        if array.length(threats) > 0 {
            print("\n  Threat Details:")
            let t = 0
            while t < array.length(threats) {
                print("    â€¢ ", threats[t])
                t = t + 1
            }
        }

        // Critical alert signing
        if report.critical_count > 0 {
            print("\nğŸš¨ CRITICAL ALERT DETECTED!")
            let alert_msg = string.concat(
                "Critical servers: ",
                string.concat(report.critical_count, " out of ", report.total_servers)
            )
            let signed_alert = sign_alert(alert_msg)
            print(signed_alert)
        }

        // PHASE 3.3: Performance benchmarking
        print("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("âš¡ Performance Metrics:")

        let end_time = time.now()
        print("  Processing completed at: ", end_time)
        print("  Servers processed: ", array.length(servers))
        print("  Metrics collected: ", array.length(all_metrics))
        print("  Average health: ", (report.healthy_count * 100) / report.total_servers, "% ")

        print("\nâœ… MONITORING CYCLE COMPLETED SUCCESSFULLY")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

    } catch (error) {
        // PHASE 3.1: Catch any runtime errors
        print("\nâŒ CRITICAL ERROR:")
        print("   ", error)
        print("\n   System will attempt recovery...")
    } finally {
        // PHASE 3.1: Cleanup always executes
        print("\nğŸ—‘ï¸  Running system cleanup...")

        // PHASE 3.2: Trigger garbage collection
        gc_collect()

        print("âœ“ Cleanup complete - All resources released")
        print("ğŸ“Š Session terminated gracefully\n")
    }
}