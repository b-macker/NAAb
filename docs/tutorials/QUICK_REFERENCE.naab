# NAAb Quick Reference - Syntax and Blocks Cheat Sheet

# ═══════════════════════════════════════════════════════════════
# GLOBAL DECLARATIONS
# ═══════════════════════════════════════════════════════════════

use io
use array
use string
use math
use json

fn add(a: int, b: int) -> int {
    return a + b
}

struct Person {
    name: string,
    age: int
}



# ═══════════════════════════════════════════════════════════════
# BASIC SYNTAX
# ═══════════════════════════════════════════════════════════════

main {
    io.write("=== BASIC SYNTAX QUICK REFERENCE ===\n")

    # Variables (type inference)
    let name = "Alice"      # string
    let age = 30            # int
    let price = 99.99       # float
    let active = true       # bool
    let items = [1, 2, 3]   # list
    let data = {"key": "value"}  # dict
    io.write("Name: ", name, ", Age: ", age, ", Price: ", price, ", Active: ", active, "\n")
    io.write("Items: ", json.stringify(items), ", Data: ", json.stringify(data), "\n")

    # Array assignment (NEW!)
    items[0] = 100
    data["new_key"] = "new_value"
    io.write("Modified items: ", json.stringify(items), ", Modified data: ", json.stringify(data), "\n")

    # Control flow
    if age > 18 {
        io.write("Adult\n")
    } else {
        io.write("Minor\n")
    }

    let loop_age = 98 # Use a different var to avoid redefinition
    while loop_age < 100 {
        loop_age = loop_age + 1
    }
    io.write("Loop age: ", loop_age, "\n")

    for item in items {
        io.write("Item: ", item, "\n")
    }

    # Structs usage within main
    let person_struct = new Person { name: "Bob", age: 25 }
    io.write("Struct person name: ", person_struct.name, "\n")

    io.write("Add function: ", add(10, 5), "\n")
}

# ═══════════════════════════════════════════════════════════════
# POLYGLOT BLOCKS - Quick Examples
# ═══════════════════════════════════════════════════════════════

main {
    io.write("=== POLYGLOT BLOCKS QUICK REFERENCE ===\n")
    io.write("\n")

    # ─────────────────────────────────────────────────────────
    # 1. BASIC BLOCKS (no variables)
    # ─────────────────────────────────────────────────────────

    <<python
    print("Hello from Python!")
 # Return value to avoid warning
    >>

    <<javascript
    console.log("Hello from JavaScript!")
    _ = true; // Return value
    >>

    <<bash
    echo "Hello from Bash!"
 # Return value
    >>

    # C++ (compiled at runtime)
    let cpp_res = <<cpp
    std::cout << "Hello from C++!" << std::endl;

    >>
    io.write("C++ Result: ", cpp_res, "\n")


    # ─────────────────────────────────────────────────────────
    # 2. VARIABLE BINDING (pass NAAb vars to blocks)
    # ─────────────────────────────────────────────────────────

    let x_bind = 42 // Renamed to avoid conflicts
    let y_bind = "hello"

    # Syntax: <<language[var1, var2, ...] code >>
    <<python[x_bind, y_bind]
    print(f"x={x_bind}, y={y_bind}")

    >>

    <<javascript[x_bind, y_bind]
    console.log(`x=${x_bind}, y=${y_bind}`)
    _ = true;
    >>

    # ─────────────────────────────────────────────────────────
    # 3. RETURN VALUES (get results from blocks)
    # ─────────────────────────────────────────────────────────

    # Last expression is returned
    let result = <<python
    2 + 2
    >>
    io.write("Python returned: ", result, "\n")

    let squared = <<python
    [x * x for x in range(1, 6)]
    >>
    io.write("Squares: ", json.stringify(squared), "\n")

    let stats_dict = <<python
    {"min": 1, "max": 100, "avg": 50.5}
    >>
    io.write("Stats: ", json.stringify(stats_dict), "\n")

    # ─────────────────────────────────────────────────────────
    # 4. COMBINING BOTH (variables + return)
    # ─────────────────────────────────────────────────────────

    let numbers_combine = [5, 2, 8, 1, 9]

    let sorted_nums = <<python[numbers_combine]
    sorted(numbers_combine)
    >>
    io.write("Sorted: ", json.stringify(sorted_nums), "\n")

    let doubled = <<javascript[numbers_combine]
    numbers_combine.map(x => x * 2)
    >>
    io.write("Doubled: ", json.stringify(doubled), "\n")

    # ─────────────────────────────────────────────────────────
    # 5. SUPPORTED LANGUAGES (8 total)
    # ─────────────────────────────────────────────────────────

    # Python
    <<python
    print("✓ Python")

    >>

    # JavaScript
    <<javascript
    console.log("✓ JavaScript")
    _ = true;
    >>

    # Bash/Shell
    <<bash
    echo "✓ Bash"

    >>

    # C++ (compiled at runtime)
    let cpp_res2 = <<cpp
    std::cout << "✓ C++" << std::endl;

    >>

    # Also: rust, ruby, go, csharp (placeholders)
    # <<rust
    # println!("  ✓ Rust works!")
    # >>
    # <<ruby
    # puts "  ✓ Ruby works!"
    # >>
    # <<go
    # fmt.Println("  ✓ Go works!")
    # >>
    # <<csharp
    # Console.WriteLine("  ✓ C# works!")
    # >>

    # ─────────────────────────────────────────────────────────
    # 6. REAL-WORLD EXAMPLES
    # ─────────────────────────────────────────────────────────

    # Data processing
    let data_list = [
        {"name": "Alice", "score": "95"},
        {"name": "Bob", "score": "87"}
    ]

    let processed = <<python[data_list]
    [{**item, "score": int(item["score"]) } for item in data_list]
    >>
    io.write("Processed: ", json.stringify(processed), "\n")

    # Pandas analysis (simulated as pandas might not be installed)
    let analysis = <<python
    # import pandas as pd
    # df = pd.DataFrame({"sales": [100, 150, 80, 200]})
    # {"total": int(df["sales"].sum()), "avg": float(df["sales"].mean())}
    {"total": 530, "avg": 132.5} # Simulated result
    >>
    io.write("Analysis: ", json.stringify(analysis), "\n")

    # File operations
    let sh_file_ops_res = <<bash
    echo "Test" > /tmp/test_qr.txt
    cat /tmp/test_qr.txt
    rm /tmp/test_qr.txt

    >>
    io.write("File ops result:", sh_file_ops_res, "\n")


    # ─────────────────────────────────────────────────────────
    # 7. USING NAAB STDLIB (faster than polyglot!)
    # ─────────────────────────────────────────────────────────

    let nums_std = [1, 2, 3, 4, 5]

    # Array operations (FAST - native C++)
    let len = array.length(nums_std)
    let doubled_native = array.map(nums_std, fn(x: int) -> int { return x * 2 })
    let sum_std = array.reduce(nums_std, fn(acc: int, x: int) -> int { return acc + x }, 0)
    io.write("Native sum: ", sum_std, " (10-100x faster!)\n")

    # String operations
    let text_std = "  hello world  "
    let trimmed = string.trim(text_std)
    let upper = string.upper(trimmed)
    io.write("Processed: ", upper, "\n")

    # Math operations
    let sqrt_val = math.sqrt(16.0)
    let pi = math.PI
    io.write("sqrt(16) = ", sqrt_val, "\n")

    # ─────────────────────────────────────────────────────────
    # 8. ERROR HANDLING
    # ─────────────────────────────────────────────────────────

    try {
        let risky = <<python
        1 / 0  # Will throw error
        >>
    } catch (error) {
        io.write("Caught error: ", error, "\n")
    } finally {
        io.write("Cleanup always runs\n")
    }

    # ─────────────────────────────────────────────────────────
    # 9. CHAINING LANGUAGES
    # ─────────────────────────────────────────────────────────

    let initial = [1, 2, 3]

    # NAAb -> Python
    let step1 = <<python[initial]
    [x + 5 for x in initial]
    >>

    # Python result -> JavaScript
    let step2 = <<javascript[step1]
    step1.map(x => x * 2)
    >>

    io.write("Chain: ", json.stringify(initial), " -> ", json.stringify(step1), " -> ", json.stringify(step2), "\n")

    # ─────────────────────────────────────────────────────────
    # 10. BEST PRACTICES
    # ─────────────────────────────────────────────────────────

    # ✓ DO: Use NAAb stdlib when possible (faster!)
    let fast = array.sort(nums_std)
    io.write("Fast sort: ", json.stringify(fast), "\n")

    # ✓ DO: Batch operations in single block
    let batched = <<python[nums_std]
    [x * 2 for x in nums_std]  # All in one block
    >>
    io.write("Batched ops: ", json.stringify(batched), "\n")

    # ✓ DO: Use type inference
    let auto = 42  # Type inferred
    io.write("Auto-inferred type: ", auto, "\n")

    # ✓ DO: Handle errors
    try {
        throw "Simulated error from best practices"
    } catch (error) {
        io.write("Error: ", error, "\n")
    }

    io.write("\n")
    io.write("=== END QUICK REFERENCE ===\n")
}

# ═══════════════════════════════════════════════════════════════
# SYNTAX SUMMARY
# ═══════════════════════════════════════════════════════════════

# Basic block:           <<language code >>
# With variables:        <<language[var1, var2] code >>
# With return:           let x = <<language code >>
# Combined:              let x = <<language[var] code >>

# Supported languages:   python, javascript, bash, cpp, rust, ruby, go, csharp

# Type conversions happen automatically:
# - NAAb int/float/string/bool -> Python/JS equivalent
# - NAAb list -> Python list / JS array
# - NAAb dict -> Python dict / JS object

# Return types supported:
# - int, float, string, bool, list, dict, void