// Performance Benchmark: Pipeline Validation
// Target: Validate pipeline in < 10ms

import "stdlib" as std

print("========================================")
print("  Pipeline Validation Benchmark")
print("========================================")
print("")

// Helper: Measure execution time
function benchmark(name, fn) {
    let start = std.now()
    fn()
    let end = std.now()
    let elapsed = end - start

    print(name + ": " + elapsed + "ms")
    return elapsed
}

// Pipeline functions
function double(x) {
    return x * 2
}

function add_ten(x) {
    return x + 10
}

function square(x) {
    return x * x
}

function subtract_five(x) {
    return x - 5
}

// Benchmark 1: Simple pipeline execution
function bench_simple_pipeline() {
    let iterations = 1000
    let i = 0
    while (i < iterations) {
        let result = 5 |> double |> add_ten
        i = i + 1
    }
}

let time1 = benchmark("Simple pipeline (1,000x)", bench_simple_pipeline)

// Benchmark 2: Long pipeline execution
function bench_long_pipeline() {
    let iterations = 1000
    let i = 0
    while (i < iterations) {
        let result = 3 |> double |> add_ten |> subtract_five |> square |> double
        i = i + 1
    }
}

let time2 = benchmark("Long pipeline (1,000x)", bench_long_pipeline)

// Benchmark 3: Pipeline with array functions
function bench_array_pipeline() {
    let iterations = 100
    let i = 0
    while (i < iterations) {
        let nums = [1, 2, 3, 4, 5]
        let result = nums
            |> std.map_fn(function(x) { return x * 2 })
            |> std.filter_fn(function(x) { return x > 5 })
            |> std.reduce_fn(function(acc, x) { return acc + x }, 0)
        i = i + 1
    }
}

let time3 = benchmark("Array pipeline (100x)", bench_array_pipeline)

// Benchmark 4: Pipeline validation overhead
function validate_pipeline() {
    // Simulate type checking in pipeline
    // In real implementation, this would call CompositionValidator
    let types = ["int", "int", "int", "int"]
    let i = 0
    while (i < std.length(types) - 1) {
        // Check compatibility
        let current = types[i]
        let next = types[i + 1]
        i = i + 1
    }
}

function bench_validation() {
    let iterations = 1000
    let i = 0
    while (i < iterations) {
        validate_pipeline()
        i = i + 1
    }
}

let time4 = benchmark("Pipeline validation (1,000x)", bench_validation)

// Benchmark 5: Complex data transformation pipeline
function bench_complex_pipeline() {
    let iterations = 50
    let i = 0
    while (i < iterations) {
        let data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        let result = data
            |> std.map_fn(function(x) { return x * x })
            |> std.filter_fn(function(x) { return x % 2 == 0 })
            |> std.map_fn(function(x) { return x / 2 })
            |> std.reduce_fn(function(acc, x) { return acc + x }, 0)
        i = i + 1
    }
}

let time5 = benchmark("Complex pipeline (50x)", bench_complex_pipeline)

// Summary
print("")
print("========================================")
print("Summary:")
let total = time1 + time2 + time3 + time4 + time5
print("  Total execution time: " + total + "ms")
print("")

// Performance targets
let avg_validation = time4 / 1000
print("  Average validation time: " + avg_validation + "ms")

if (avg_validation < 10) {
    print("  Status: PASS (< 10ms target)")
} else {
    print("  Status: FAIL (>= 10ms, target is < 10ms)")
}

let all_pass = true
if (time1 > 500) {
    print("  WARNING: Simple pipeline slow (> 500ms for 1000 iterations)")
    all_pass = false
}
if (time2 > 500) {
    print("  WARNING: Long pipeline slow (> 500ms for 1000 iterations)")
    all_pass = false
}

if (all_pass && avg_validation < 10) {
    print("  Overall: PASS")
} else {
    print("  Overall: Some benchmarks need optimization")
}
print("========================================")
