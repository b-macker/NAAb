// Performance Benchmark: Interpreter Execution
// Tests: Function calls, loops, array operations, recursion

import "stdlib" as std

print("========================================")
print("  Interpreter Performance Benchmark")
print("========================================")
print("")

// Helper: Measure execution time
function benchmark(name, fn) {
    let start = std.now()
    fn()
    let end = std.now()
    let elapsed = end - start

    print(name + ": " + elapsed + "ms")
    return elapsed
}

// Benchmark 1: Function call overhead
function empty_function() {
    return 1
}

function bench_function_calls() {
    let i = 0
    let sum = 0
    while (i < 10000) {
        sum = sum + empty_function()
        i = i + 1
    }
    return sum
}

let time1 = benchmark("Function calls (10,000)", bench_function_calls)

// Benchmark 2: Loop performance
function bench_loops() {
    let sum = 0
    let i = 0
    while (i < 100000) {
        sum = sum + i
        i = i + 1
    }
    return sum
}

let time2 = benchmark("While loop (100,000)", bench_loops)

// Benchmark 3: Array operations
function bench_array_ops() {
    let arr = []
    let i = 0
    while (i < 1000) {
        arr = std.push(arr, i)
        i = i + 1
    }

    let sum = 0
    for (item in arr) {
        sum = sum + item
    }
    return sum
}

let time3 = benchmark("Array operations (1,000)", bench_array_ops)

// Benchmark 4: Recursion
function fibonacci(n) {
    if (n <= 1) {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

function bench_recursion() {
    return fibonacci(20)
}

let time4 = benchmark("Recursion (fib 20)", bench_recursion)

// Benchmark 5: String operations
function bench_string_ops() {
    let str = "hello"
    let i = 0
    while (i < 1000) {
        str = std.toUpperCase(str)
        str = std.toLowerCase(str)
        i = i + 1
    }
    return str
}

let time5 = benchmark("String operations (1,000)", bench_string_ops)

// Benchmark 6: Dict operations
function bench_dict_ops() {
    let dict = {}
    let i = 0
    while (i < 1000) {
        dict["key" + i] = i
        i = i + 1
    }

    let sum = 0
    let keys = std.keys(dict)
    for (key in keys) {
        sum = sum + dict[key]
    }
    return sum
}

let time6 = benchmark("Dict operations (1,000)", bench_dict_ops)

// Benchmark 7: Higher-order functions
function bench_higher_order() {
    let nums = []
    let i = 0
    while (i < 100) {
        nums = std.push(nums, i)
        i = i + 1
    }

    let doubled = std.map_fn(nums, function(x) { return x * 2 })
    let filtered = std.filter_fn(doubled, function(x) { return x > 50 })
    let sum = std.reduce_fn(filtered, function(acc, x) { return acc + x }, 0)

    return sum
}

let time7 = benchmark("Higher-order functions", bench_higher_order)

// Summary
print("")
print("========================================")
print("Summary:")
let total = time1 + time2 + time3 + time4 + time5 + time6 + time7
print("  Total execution time: " + total + "ms")
print("  Average per benchmark: " + (total / 7) + "ms")
print("")

// Performance targets
let all_pass = true
if (time1 > 1000) {
    print("  WARNING: Function calls slow (> 1s)")
    all_pass = false
}
if (time2 > 1000) {
    print("  WARNING: Loops slow (> 1s)")
    all_pass = false
}
if (time3 > 1000) {
    print("  WARNING: Array ops slow (> 1s)")
    all_pass = false
}

if (all_pass) {
    print("  Status: PASS (all benchmarks within targets)")
} else {
    print("  Status: WARNING (some benchmarks exceeded targets)")
}
print("========================================")
