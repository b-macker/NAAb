# NAAb Tutorial: Syntax and Polyglot Blocks
# Complete guide to writing NAAb code and using embedded language blocks

# ============================================================================
# PART 1: BASIC NAAB SYNTAX
# ============================================================================

# Variables and basic types
fn demo_basic_syntax() {
    print("=== PART 1: Basic NAAb Syntax ===")
    print("")

    # Variables with type inference (NEW!)
    let name = "Alice"          # string
    let age = 30                # int
    let price = 99.99           # float
    let active = true           # bool

    # Lists and dictionaries
    let numbers = [1, 2, 3, 4, 5]
    let person = {
        "name": "Bob",
        "age": "25",
        "city": "NYC"
    }

    # Array element assignment (NEW 2026-01-20!)
    numbers[0] = 100
    numbers[4] = 500
    person["city"] = "LA"

    print("Modified list: ", numbers)
    print("Modified dict: ", person)
    print("")
}

# ============================================================================
# PART 2: INLINE CODE BLOCKS (Basic - No Variables)
# ============================================================================

fn demo_basic_blocks() {
    print("=== PART 2: Basic Inline Code Blocks ===")
    print("")

    # Python block
    print("Running Python block:")
    <<python
    print("  Hello from Python!")
    for i in range(3):
        print(f"  Python count: {i}")
    >>

    # JavaScript block
    print("Running JavaScript block:")
    <<javascript
    console.log("  Hello from JavaScript!");
    for (let i = 0; i < 3; i++) {
        console.log(`  JS count: ${i}`);
    }
    >>

    # Shell/Bash block
    print("Running Shell block:")
    <<bash
    echo "  Hello from Bash!"
    echo "  Current directory: $(pwd)"
    >>

    print("")
}

# ============================================================================
# PART 3: VARIABLE BINDING (Pass NAAb variables to blocks)
# ============================================================================

fn demo_variable_binding() {
    print("=== PART 3: Variable Binding ===")
    print("")

    # NAAb variables
    let username = "Alice"
    let user_age = 30
    let score = 95.5
    let active = true
    let tags = ["developer", "python", "javascript"]
    let config = {"theme": "dark", "lang": "en"}

    # Bind variables to Python block with [var1, var2, ...] syntax
    print("Python with bound variables:")
    <<python[username, user_age, score, active]
    print(f"  Name: {username}")
    print(f"  Age: {user_age}")
    print(f"  Score: {score}")
    print(f"  Active: {active}")
    print(f"  Types: {type(username)}, {type(user_age)}, {type(score)}, {type(active)}")
    >>

    # Bind list and dict
    print("Python with list and dict:")
    <<python[tags, config]
    print(f"  Tags: {tags}")
    print(f"  Config: {config}")
    print(f"  First tag: {tags[0]}")
    print(f"  Theme: {config['theme']}")
    >>

    # JavaScript with bound variables
    print("JavaScript with bound variables:")
    <<javascript[username, user_age, tags]
    console.log(`  Name: ${username}`);
    console.log(`  Age: ${user_age}`);
    console.log(`  Tags: ${tags.join(', ')}`);
    >>

    # Bash with bound variables
    print("Bash with bound variables:")
    <<bash[username, user_age]
    echo "  Name: $username"
    echo "  Age: $user_age"
    >>

    print("")
}

# ============================================================================
# PART 4: RETURN VALUES (Get results from blocks)
# ============================================================================

fn demo_return_values() {
    print("=== PART 4: Return Values from Blocks ===")
    print("")

    # Return single value (last expression in block)
    let py_result = <<python
    2 + 2
    >>
    print("Python returned: ", py_result)

    # Return from computation
    let factorial = <<python
    result = 1
    for i in range(1, 6):
        result *= i
    result  # Last expression is returned
    >>
    print("Factorial of 5: ", factorial)

    # Return list
    let squares = <<python
    [x * x for x in range(1, 6)]
    >>
    print("Squares: ", squares)

    # Return dictionary
    let stats = <<python
    {
        "min": 1,
        "max": 100,
        "avg": 50.5
    }
    >>
    print("Stats: ", stats)
    print("  Min: ", stats["min"])
    print("  Max: ", stats["max"])

    # JavaScript return
    let js_sum = <<javascript
    [1, 2, 3, 4, 5].reduce((a, b) => a + b, 0)
    >>
    print("JavaScript sum: ", js_sum)

    print("")
}

# ============================================================================
# PART 5: COMBINING VARIABLES AND RETURNS
# ============================================================================

fn demo_combined() {
    print("=== PART 5: Variables + Returns ===")
    print("")

    # Pass data to Python, get processed result
    let numbers = [5, 2, 8, 1, 9, 3, 7, 4, 6]

    let sorted_nums = <<python[numbers]
    sorted(numbers)
    >>
    print("Original: ", numbers)
    print("Sorted (Python): ", sorted_nums)

    # Statistical analysis
    let stats = <<python[numbers]
    import statistics
    {
        "mean": statistics.mean(numbers),
        "median": statistics.median(numbers),
        "stdev": statistics.stdev(numbers)
    }
    >>
    print("Statistics:")
    print("  Mean: ", stats["mean"])
    print("  Median: ", stats["median"])
    print("  StDev: ", stats["stdev"])

    # String processing
    let text = "hello world from naab"
    let processed = <<python[text]
    text.upper().replace(" ", "_")
    >>
    print("Original text: ", text)
    print("Processed: ", processed)

    print("")
}

# ============================================================================
# PART 6: REAL-WORLD EXAMPLES
# ============================================================================

fn demo_real_world() {
    print("=== PART 6: Real-World Examples ===")
    print("")

    # Example 1: Data processing pipeline
    print("[Example 1] Data Processing Pipeline")
    let raw_data = [
        {"name": "Alice", "score": "95"},
        {"name": "Bob", "score": "87"},
        {"name": "Charlie", "score": "92"}
    ]

    let processed = <<python[raw_data]
    # Convert scores to int, calculate grade
    result = []
    for item in raw_data:
        score = int(item["score"])
        grade = "A" if score >= 90 else "B" if score >= 80 else "C"
        result.append({
            "name": item["name"],
            "score": score,
            "grade": grade
        })
    result
    >>

    print("  Processed data:")
    let i = 0
    while i < 3 {
        let person = processed[i]
        print("    ", person["name"], ": ", person["score"], " (", person["grade"], ")")
        i = i + 1
    }
    print("")

    # Example 2: JSON processing with pandas
    print("[Example 2] Using Pandas for Analysis")
    let csv_data = <<python
    import pandas as pd
    # Create sample data
    df = pd.DataFrame({
        'product': ['A', 'B', 'C', 'D'],
        'sales': [100, 150, 80, 200]
    })
    # Return summary as dict
    {
        "total_sales": int(df['sales'].sum()),
        "avg_sales": float(df['sales'].mean()),
        "top_product": df.loc[df['sales'].idxmax(), 'product']
    }
    >>
    print("  Total sales: ", csv_data["total_sales"])
    print("  Average: ", csv_data["avg_sales"])
    print("  Top product: ", csv_data["top_product"])
    print("")

    # Example 3: File operations with multiple blocks
    print("[Example 3] Multi-Language File Processing")

    # Create a file with Bash
    let filename = "/tmp/naab_test.txt"
    <<bash[filename]
    echo "Line 1: Hello from Bash" > "$filename"
    echo "Line 2: NAAb is awesome" >> "$filename"
    echo "Line 3: Polyglot power!" >> "$filename"
    >>

    # Read and process with Python
    let line_count = <<python[filename]
    with open(filename, 'r') as f:
        len(f.readlines())
    >>
    print("  Created file: ", filename)
    print("  Line count: ", line_count)

    # Clean up with Bash
    <<bash[filename]
    rm -f "$filename"
    echo "  Cleaned up temporary file"
    >>
    print("")
}

# ============================================================================
# PART 7: MIXING MULTIPLE LANGUAGES
# ============================================================================

fn demo_multi_language() {
    print("=== PART 7: Multi-Language Mixing ===")
    print("")

    let data = [1, 2, 3, 4, 5]

    # Process with Python
    let py_doubled = <<python[data]
    [x * 2 for x in data]
    >>
    print("Python doubled: ", py_doubled)

    # Process with JavaScript
    let js_tripled = <<javascript[data]
    data.map(x => x * 3)
    >>
    print("JavaScript tripled: ", js_tripled)

    # Combine results in NAAb
    print("First Python: ", py_doubled[0])
    print("First JavaScript: ", js_tripled[0])

    # Chain processing: NAAb -> Python -> JavaScript -> NAAb
    let initial = [10, 20, 30]

    let step1 = <<python[initial]
    [x + 5 for x in initial]
    >>

    let step2 = <<javascript[step1]
    step1.map(x => x * 2)
    >>

    print("Chain: ", initial, " -> ", step1, " -> ", step2)
    print("")
}

# ============================================================================
# PART 8: ADVANCED PATTERNS
# ============================================================================

fn demo_advanced() {
    print("=== PART 8: Advanced Patterns ===")
    print("")

    # Pattern 1: Using NAAb stdlib with polyglot
    use array
    use string

    let names = ["alice", "bob", "charlie"]

    # Capitalize with Python
    let capitalized = <<python[names]
    [name.capitalize() for name in names]
    >>

    # Process with NAAb stdlib
    let joined = string.join(capitalized, ", ")
    print("Capitalized names: ", joined)

    # Pattern 2: Conditional polyglot execution
    let use_python = true

    if use_python {
        let result = <<python
        "Executed Python block"
        >>
        print("Result: ", result)
    } else {
        let result = <<javascript
        "Executed JavaScript block"
        >>
        print("Result: ", result)
    }

    # Pattern 3: Error handling with try/catch
    try {
        let risky_result = <<python
        # This might fail
        1 / 0
        >>
        print("This won't print")
    } catch error {
        print("Caught error from Python block: ", error)
    }

    print("")
}

# ============================================================================
# PART 9: SUPPORTED LANGUAGES
# ============================================================================

fn demo_all_languages() {
    print("=== PART 9: All Supported Languages ===")
    print("")

    # 1. Python
    <<python
    print("  ✓ Python works!")
    >>

    # 2. JavaScript
    <<javascript
    console.log("  ✓ JavaScript works!");
    >>

    # 3. Bash/Shell
    <<bash
    echo "  ✓ Bash works!"
    >>

    # 4. C++ (compiled at runtime)
    <<cpp
    std::cout << "  ✓ C++ works!" << std::endl;
    >>

    # Other supported languages (may require installation):
    # <<rust
    # println!("  ✓ Rust works!");
    # >>

    # <<ruby
    # puts "  ✓ Ruby works!"
    # >>

    # <<go
    # fmt.Println("  ✓ Go works!")
    # >>

    # <<csharp
    # Console.WriteLine("  ✓ C# works!");
    # >>

    print("")
}

# ============================================================================
# PART 10: BEST PRACTICES
# ============================================================================

fn demo_best_practices() {
    print("=== PART 10: Best Practices ===")
    print("")

    # 1. Use NAAb stdlib when possible (faster!)
    use array
    use math

    let nums = [1, 2, 3, 4, 5]

    # Fast - native NAAb
    let sum_naab = array.reduce(nums, fn(acc, x) { return acc + x }, 0)
    print("1. NAAb native sum: ", sum_naab, " (FAST!)")

    # Slower - polyglot overhead
    let sum_python = <<python[nums]
    sum(nums)
    >>
    print("   Python sum: ", sum_python, " (slower)")

    # 2. Minimize polyglot boundary crossings
    print("2. Batch operations when possible")
    # Good - single block
    let results = <<python[nums]
    [x * 2 for x in nums]
    >>
    print("   Batched: ", results)

    # 3. Use type inference for cleaner code
    let auto_typed = 42  # Type inferred as int
    print("3. Type inference: ", auto_typed)

    # 4. Handle errors properly
    print("4. Always use try/catch for risky operations")

    # 5. Document polyglot blocks
    print("5. Comment what each block does")
    # Good practice:
    # Calculate fibonacci sequence using Python
    let fib = <<python
    def fib(n):
        if n <= 1:
            return n
        return fib(n-1) + fib(n-2)
    [fib(i) for i in range(10)]
    >>
    print("   Fibonacci: ", fib)

    print("")
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

main {
    print("╔════════════════════════════════════════════════════════════╗")
    print("║  NAAb Tutorial: Syntax and Polyglot Blocks                ║")
    print("║  Complete guide to writing NAAb code                      ║")
    print("╚════════════════════════════════════════════════════════════╝")
    print("")

    # Run all demos
    demo_basic_syntax()
    demo_basic_blocks()
    demo_variable_binding()
    demo_return_values()
    demo_combined()
    demo_real_world()
    demo_multi_language()
    demo_advanced()
    demo_all_languages()
    demo_best_practices()

    print("╔════════════════════════════════════════════════════════════╗")
    print("║  Tutorial Complete!                                        ║")
    print("║                                                            ║")
    print("║  Key Takeaways:                                            ║")
    print("║  • Inline blocks: <<language code >>                       ║")
    print("║  • Variable binding: <<language[var1, var2] code >>        ║")
    print("║  • Return values: let x = <<language code >>               ║")
    print("║  • 8 languages supported (Python, JS, C++, Bash, etc.)     ║")
    print("║  • Use NAAb stdlib when possible (10-100x faster!)         ║")
    print("╚════════════════════════════════════════════════════════════╝")
}
