// dpre_app/ingestion.naab
// Handles data ingestion from files.

use io   // For error messages
use file // For file system operations
use json // For JSON parsing
use string // For string operations
use csv // Assuming a 'csv' stdlib module exists for CSV parsing.
        // If not, this would need to be implemented manually or via polyglot.

use data_models as dm // Import data models

// Helper function to determine file type from extension.
fn get_file_type_from_path(path: string) -> dm.FileType? {
    let lower_path = string.lower(path)
    if string.ends_with(lower_path, ".csv") {
        return dm.FileType.Csv
    } else if string.ends_with(lower_path, ".json") {
        return dm.FileType.Json
    }
    return null // Unknown type
}

// Reads and parses a CSV file into a list of RawRecords.
fn read_csv(path: string) -> dm.Result<list<dm.RawRecord>, dm.AppError> {
    let file_content_result = file.read(path)
    if file_content_result.err != null {
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.FileNotFound,
                message: string.concat("Failed to read CSV file: ", path),
                details: file_content_result.err.message
            }
        }
    }

    let content = file_content_result.ok // content is a string

    // Assuming csv.parse(content: string) -> list<dict<string, string>> exists
    // If not, this would be a polyglot point or manual implementation.
    let parsed_csv = csv.parse(content)
    if parsed_csv == null { // Placeholder for error handling from csv.parse
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.InvalidFormat,
                message: string.concat("Failed to parse CSV content for file: ", path),
                details: null
            }
        }
    }

    let records: list<dm.RawRecord> = []
    let i = 0
    while i < string.length(parsed_csv) {
        records.append(dm.RawRecord { data: parsed_csv[i] })
        i = i + 1
    }

    return dm.Result<list<dm.RawRecord>, dm.AppError> {
        ok: records,
        err: null
    }
}

// Reads and parses a JSON file into a list of RawRecords.
fn read_json(path: string) -> dm.Result<list<dm.RawRecord>, dm.AppError> {
    let file_content_result = file.read(path)
    if file_content_result.err != null {
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.FileNotFound,
                message: string.concat("Failed to read JSON file: ", path),
                details: file_content_result.err.message
            }
        }
    }

    let content = file_content_result.ok // content is a string

    let parsed_json_result = json.parse(content)
    if parsed_json_result.err != null { // Check for parsing errors
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.InvalidFormat,
                message: string.concat("Failed to parse JSON content for file: ", path),
                details: parsed_json_result.err.message
            }
        }
    }

    let parsed_json = parsed_json_result.ok // parsed_json can be any type
    let records: list<dm.RawRecord> = []

    // Assume the JSON is either a list of objects or a single object.
    // Convert to list<dm.RawRecord>.
    if json.is_list(parsed_json) {
        let json_list = parsed_json as list<any> // Cast to list of dynamic
        let i = 0
        while i < string.length(json_list) {
            if json.is_dict(json_list[i]) {
                // Cast to dict<string, string> - assuming all values are strings initially.
                // In a real app, this might involve more robust type checking and conversion.
                records.append(dm.RawRecord { data: json_list[i] as dict<string, string> })
            } else {
                return dm.Result<list<dm.RawRecord>, dm.AppError> {
                    ok: null,
                    err: dm.AppError {
                        code: dm.ErrorCode.InvalidFormat,
                        message: string.concat("JSON list contains non-object elements in file: ", path),
                        details: null
                    }
                }
            }
            i = i + 1
        }
    } else if json.is_dict(parsed_json) {
        // Handle single JSON object as a list with one RawRecord
        records.append(dm.RawRecord { data: parsed_json as dict<string, string> })
    } else {
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.InvalidFormat,
                message: string.concat("JSON content is neither a list nor an object in file: ", path),
                details: null
            }
        }
    }

    return dm.Result<list<dm.RawRecord>, dm.AppError> {
        ok: records,
        err: null
    }
}

// Main ingestion function: reads data based on configuration.
fn read_data(config: dm.IngestionConfig) -> dm.Result<list<dm.RawRecord>, dm.AppError> {
    if config.file_type == dm.FileType.Csv {
        return read_csv(config.input_file)
    } else if config.file_type == dm.FileType.Json {
        return read_json(config.input_file)
    } else {
        return dm.Result<list<dm.RawRecord>, dm.AppError> {
            ok: null,
            err: dm.AppError {
                code: dm.ErrorCode.InvalidFormat,
                message: string.concat("Unsupported file type specified in ingestion config: ", string.from(config.file_type)),
                details: null
            }
        }
    }
}
