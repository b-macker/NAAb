# NAAb Quick Reference - Syntax and Blocks Cheat Sheet

use math

# ═══════════════════════════════════════════════════════════════
# BASIC SYNTAX (variables, structs, functions)
# ═══════════════════════════════════════════════════════════════

# Functions
fn add(a: int, b: int) -> int {
    return a + b
}

# Structs
struct Person {
    name: string,
    age: int
}

main {
    print("=== POLYGLOT BLOCKS QUICK REFERENCE ===")
    print("")

    # Variables (type inference)
    let name = "Alice"
    let age = 30
    let price = 99.99
    let active = true
    let items = [1, 2, 3]
    let data = {"key": "value"}

    # Array assignment
    items[0] = 100
    data["new_key"] = "new_value"

    # Control flow
    if age > 18 {
        print("Adult")
    } else {
        print("Minor")
    }

    # Struct usage
    let person = new Person { name: "Bob", age: 25 }
    print("Person: ", person.name)

    # Function call
    print("add(2, 3) = ", add(2, 3))

    # ─────────────────────────────────────────────────────────
    # 1. BASIC BLOCKS (no variables)
    # ─────────────────────────────────────────────────────────

    <<python
    print("Hello from Python!")
    >>

    <<bash
    echo "Hello from Bash!"
    >>

    # ─────────────────────────────────────────────────────────
    # 2. VARIABLE BINDING (pass NAAb vars to blocks)
    # ─────────────────────────────────────────────────────────

    # Declare variables for binding (must be before polyglot blocks)
    let x = 42
    let y = "hello"
    let numbers = [5, 2, 8, 1, 9]
    let scores = [95, 87, 72, 91]
    let initial = [1, 2, 3]
    let nums = [1, 2, 3, 4, 5]

    # Syntax: <<language[var1, var2, ...] code >>
    <<python[x, y]
    print(f"x={x}, y={y}")
    >>

    # ─────────────────────────────────────────────────────────
    # 3. RETURN VALUES (get results from blocks)
    # ─────────────────────────────────────────────────────────

    # Last expression is returned
    let result = <<python
    2 + 2
    >>
    print("Python returned: ", result)

    let squared = <<python
    [x * x for x in range(1, 6)]
    >>
    print("Squares: ", squared)

    let stats = <<python
    {"min": 1, "max": 100, "avg": 50.5}
    >>
    print("Stats: ", stats)

    # ─────────────────────────────────────────────────────────
    # 4. COMBINING BOTH (variables + return)
    # ─────────────────────────────────────────────────────────

    let sorted_nums = <<python[numbers]
    sorted(numbers)
    >>
    print("Sorted: ", sorted_nums)

    # ─────────────────────────────────────────────────────────
    # 5. SUPPORTED LANGUAGES
    # ─────────────────────────────────────────────────────────

    <<python
    print("  Python")
    >>

    <<bash
    echo "  Bash"
    >>

    <<cpp
    std::cout << "  C++" << std::endl;
    >>

    # Also: rust, ruby, go, csharp (may need installation)

    # ─────────────────────────────────────────────────────────
    # 6. REAL-WORLD EXAMPLES
    # ─────────────────────────────────────────────────────────

    # Data processing with Python
    let avg = <<python[scores]
    sum(scores) / len(scores)
    >>
    print("Average score: ", avg)

    # ─────────────────────────────────────────────────────────
    # 7. USING NAAB STDLIB (faster than polyglot!)
    # ─────────────────────────────────────────────────────────

    # Array operations (FAST - native C++)
    let nums_len = len(nums)
    let doubled_native = array.map_fn(nums, fn(x) { return x * 2 })
    let nums_sum = array.reduce_fn(nums, fn(acc, x) { return acc + x }, 0)
    print("Native sum: ", nums_sum)

    # String operations
    let text = "  hello world  "
    let trimmed = string.trim(text)
    let upper = string.upper(trimmed)
    print("Processed: ", upper)

    # Math operations
    let sqrt_val = math.sqrt(16.0)
    let pi = math.PI
    print("sqrt(16) = ", sqrt_val)

    # ─────────────────────────────────────────────────────────
    # 8. ERROR HANDLING
    # ─────────────────────────────────────────────────────────

    try {
        let risky = <<python
        1 / 0
        >>
    } catch (error) {
        print("Caught error: ", error)
    } finally {
        print("Cleanup always runs")
    }

    # ─────────────────────────────────────────────────────────
    # 9. CHAINING LANGUAGES
    # ─────────────────────────────────────────────────────────

    # NAAb -> Python
    let step1 = <<python[initial]
    [x + 5 for x in initial]
    >>

    print("Chain: ", initial, " -> ", step1)

    # ─────────────────────────────────────────────────────────
    # 10. BEST PRACTICES
    # ─────────────────────────────────────────────────────────

    # Use NAAb stdlib when possible (faster!)
    let fast = array.sort(nums)

    # Batch operations in single block
    let batched = <<python[nums]
    [x * 2 for x in nums]
    >>

    # Use type inference
    let auto = 42

    # Handle errors
    try {
        let val = 1 / 1
    } catch (error) {
        print("Error: ", error)
    }

    print("")
    print("=== END QUICK REFERENCE ===")
}

# ═══════════════════════════════════════════════════════════════
# SYNTAX SUMMARY
# ═══════════════════════════════════════════════════════════════

# Basic block:           <<language code >>
# With variables:        <<language[var1, var2, ...] code >>
# With return:           let x = <<language code >>
# Combined:              let x = <<language[var] code >>

# Supported languages:   python, javascript, bash, cpp, rust, ruby, go, csharp
