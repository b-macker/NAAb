{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00288_execute() {\n    class CodeGenerator(NodeVisitor):\n    def __init__(\n        self,\n        environment: \"Environment\",\n        name: str | None,\n        filename: str | None,\n        stream: t.TextIO | None = None,\n        defer_init: bool = False,\n        optimized: bool = True,\n    ) -> None:\n        if stream is None:\n            stream = StringIO()\n        self.environment = environment\n        self.name = name\n        self.filename = filename\n        self.stream = stream\n        self.created_block_context = False\n        self.defer_init = defer_init\n        self.optimizer: Optimizer | None = None\n\n        if optimized:\n            self.optimizer = Optimizer(environment)\n\n        # aliases for imports\n        self.import_aliases: dict[str, str] = {}\n\n        # a registry for all blocks.  Because blocks are moved out\n        # into the global python scope they are registered here\n        self.blocks: dict[str, nodes.Block] = {}\n\n        # the number of extends statements so far\n        self.extends_so_far = 0\n\n        # some templates have a rootlevel extends.  In this case we\n        # can safely assume that we're a child template and do some\n        # more optimizations.\n        self.has_known_extends = False\n\n        # the current line number\n        self.code_lineno = 1\n\n        # registry of all filters and tests (global, not block local)\n        self.tests: dict[str, str] = {}\n        self.filters: dict[str, str] = {}\n\n        # the debug information\n        self.debug_info: list[tuple[int, int]] = []\n        self._write_debug_info: int | None = None\n\n        # the number of new lines before the next write()\n        self._new_lines = 0\n\n        # the line number of the last written statement\n        self._last_line = 0\n\n        # true if nothing was written so far.\n        self._first_write = True\n\n        # used by the `temporary_identifier` method to get new\n        # unique, temporary identifier\n        self._last_identifier = 0\n\n        # the current indentation\n        self._indentation = 0\n\n        # Tracks toplevel assignments\n        self._assign_stack: list[set[str]] = []\n\n        # Tracks parameter definition blocks\n        self._param_def_block: list[set[str]] = []\n\n        # Tracks the current context.\n        self._context_reference_stack = [\"context\"]\n\n    @property\n    def optimized(self) -> bool:\n        return self.optimizer is not None\n\n    # -- Various compilation helpers\n\n    def fail(self, msg: str, lineno: int) -> \"te.NoReturn\":\n        \"\"\"Fail with a :exc:`TemplateAssertionError`.\"\"\"\n        raise TemplateAssertionError(msg, lineno, self.name, self.filename)\n\n    def temporary_identifier(self) -> str:\n        \"\"\"Get a new unique identifier.\"\"\"\n        self._last_identifier += 1\n        return f\"t_{self._last_identifier}\"\n\n    def buffer(self, frame: Frame) -> None:\n        \"\"\"Enable buffering for the frame from that point onwards.\"\"\"\n        frame.buffer = self.temporary_identifier()\n        self.writeline(f\"{frame.buffer} = []\")\n\n    def return_buffer_contents(\n        self, frame: Frame, force_unescaped: bool = False\n    ) -> None:\n        \"\"\"Return the buffer contents of the frame.\"\"\"\n        if not force_unescaped:\n            if frame.eval_ctx.volatile:\n                self.writeline(\"if context.eval_ctx.autoescape:\")\n                self.indent()\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                self.outdent()\n                self.writeline(\"else:\")\n                self.indent()\n                self.writeline(f\"return concat({frame.buffer})\")\n                self.outdent()\n                return\n            elif frame.eval_ctx.autoescape:\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                return\n        self.writeline(f\"return concat({frame.buffer})\")\n\n    def indent(self) -> None:\n        \"\"\"Indent by one.\"\"\"\n        self._indentation += 1\n\n    def outdent(self, step: int = 1) -> None:\n        \"\"\"Outdent by step.\"\"\"\n        self._indentation -= step\n\n    def start_write(self, frame: Frame, node: nodes.Node | None = None) -> None:\n        \"\"\"Yield or write into the frame buffer.\"\"\"\n        if frame.buffer is None:\n            self.writeline(\"yield \", node)\n        else:\n            self.writeline(f\"{frame.buffer}.append(\", node)\n\n    def end_write(self, frame: Frame) -> None:\n        \"\"\"End the writing process started by `start_write`.\"\"\"\n        if frame.buffer is not None:\n            self.write(\")\")\n\n    def simple_write(\n        self, s: str, frame: Frame, node: nodes.Node | None = None\n    ) -> None:\n        \"\"\"Simple shortcut for start_write + write + end_write.\"\"\"\n        self.start_write(frame, node)\n        self.write(s)\n        self.end_write(frame)\n\n    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -> None:\n        \"\"\"Visit a list of nodes as block in a frame.  If the current frame\n        is no buffer a dummy ``if 0: yield None`` is written automatically.\n        \"\"\"\n        try:\n            self.writeline(\"pass\")\n            for node in nodes:\n                self.visit(node, frame)\n        except CompilerExit:\n            pass\n\n    def write(self, x: str) -> None:\n        \"\"\"Write a string into the output stream.\"\"\"\n        if self._new_lines:\n            if not self._first_write:\n                self.stream.write(\"\\n\" * self._new_lines)\n                self.code_lineno += self._new_lines\n                if self._write_debug_info is not None:\n                    self.debug_info.append((self._write_debug_info, self.code_lineno))\n                    self._write_debug_info = None\n            self._first_write = False\n            self.stream.write(\"    \" * self._indentation)\n            self._new_lines = 0\n        self.stream.write(x)\n\n    def writeline(self, x: str, node: nodes.Node | None = None, extra: int = 0) -> None:\n        \"\"\"Combination of newline and write.\"\"\"\n        self.newline(node, extra)\n        self.write(x)\n\n    def newline(self, node: nodes.Node | None = None, extra: int = 0) -> None:\n        \"\"\"Add one or more newlines before the next write.\"\"\"\n        self._new_lines = max(self._new_lines, 1 + extra)\n        if node is not None and node.lineno != self._last_line:\n            self._write_debug_info = node.lineno\n            self._last_line = node.lineno\n\n    def signature(\n        self,\n        node: nodes.Call | nodes.Filter | nodes.Test,\n        frame: Frame,\n        extra_kwargs: t.Mapping[str, t.Any] | None = None,\n    ) -> None:\n        \"\"\"Writes a function call to the stream for the current node.\n        A leading comma is added automatically.  The extra keyword\n        arguments may not include python keywords otherwise a syntax\n        error could occur.  The extra keyword arguments should be given\n        as python dict.\n        \"\"\"\n        # if any of the given keyword arguments is a python keyword\n        # we have to make sure that no invalid call is created.\n        kwarg_workaround = any(\n            is_python_keyword(t.cast(str, k))\n            for k in chain((x.key for x in node.kwargs), extra_kwargs or ())\n        )\n\n        for arg in node.args:\n            self.write(\", \")\n            self.visit(arg, frame)\n\n        if not kwarg_workaround:\n            for kwarg in node.kwargs:\n                self.write(\", \")\n                self.visit(kwarg, frame)\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\", {key}={value}\")\n        if node.dyn_args:\n            self.write(\", *\")\n            self.visit(node.dyn_args, frame)\n\n        if kwarg_workaround:\n            if node.dyn_kwargs is not None:\n                self.write(\", **dict({\")\n            else:\n                self.write(\", **{\")\n            for kwarg in node.kwargs:\n                self.write(f\"{kwarg.key!r}: \")\n                self.visit(kwarg.value, frame)\n                self.write(\", \")\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\"{key!r}: {value}, \")\n            if node.dyn_kwargs is not None:\n                self.write(\"}, **\")\n                self.visit(node.dyn_kwargs, frame)\n                self.write(\")\")\n            else:\n                self.write(\"}\")\n\n        elif node.dyn_kwargs is not None:\n            self.write(\", **\")\n            self.visit(node.dyn_kwargs, frame)\n\n    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -> None:\n        \"\"\"Find all filter and test names used in the template and\n        assign them to variables in the compiled namespace. Checking\n        that the names are registered with the environment is done when\n        compiling the Filter and Test nodes. If the node is in an If or\n        CondExpr node, the check is done at runtime instead.\n\n        .. versionchanged:: 3.0\n            Filters and tests in If and CondExpr nodes are checked at\n            runtime instead of compile time.\n        \"\"\"\n        visitor = DependencyFinderVisitor()\n\n        for node in nodes:\n            visitor.visit(node)\n\n        for id_map, names, dependency in (\n            (self.filters, visitor.filters, \"filters\"),\n            (\n                self.tests,\n                visitor.tests,\n                \"tests\",\n            ),\n        ):\n            for name in sorted(names):\n                if name not in id_map:\n                    id_map[name] = self.temporary_identifier()\n\n                # add check during runtime that dependencies used inside of executed\n                # blocks are defined, as this step may be skipped during compile time\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(f\"{id_map[name]} = environment.{dependency}[{name!r}]\")\n                self.outdent()\n                self.writeline(\"except KeyError:\")\n                self.indent()\n                self.writeline(\"@internalcode\")\n                self.writeline(f\"def {id_map[name]}(*unused):\")\n                self.indent()\n                self.writeline(\n                    f'raise TemplateRuntimeError(\"No {dependency[:-1]}'\n                    f' named {name!r} found.\")'\n                )\n                self.outdent()\n                self.outdent()\n\n    def enter_frame(self, frame: Frame) -> None:\n        undefs = []\n        for target, (action, param) in frame.symbols.loads.items():\n            if action == VAR_LOAD_PARAMETER:\n                pass\n            elif action == VAR_LOAD_RESOLVE:\n                self.writeline(f\"{target} = {self.get_resolve_func()}({param!r})\")\n            elif action == VAR_LOAD_ALIAS:\n                self.writeline(f\"{target} = {param}\")\n            elif action == VAR_LOAD_UNDEFINED:\n                undefs.append(target)\n            else:\n                raise NotImplementedError(\"unknown load instruction\")\n        if undefs:\n            self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def leave_frame(self, frame: Frame, with_python_scope: bool = False) -> None:\n        if not with_python_scope:\n            undefs = []\n            for target in frame.symbols.loads:\n                undefs.append(target)\n            if undefs:\n                self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def choose_async(self, async_value: str = \"async \", sync_value: str = \"\") -> str:\n        return async_value if self.environment.is_async else sync_value\n\n    def func(self, name: str) -> str:\n        return f\"{self.choose_async()}def {name}\"\n\n    def macro_body(\n        self, node: nodes.Macro | nodes.CallBlock, frame: Frame\n    ) -> tuple[Frame, MacroRef]:\n        \"\"\"Dump the function def of a macro or call block.\"\"\"\n        frame = frame.inner()\n        frame.symbols.analyze_node(node)\n        macro_ref = MacroRef(node)\n\n        explicit_caller = None\n        skip_special_params = set()\n        args = []\n\n        for idx, arg in enumerate(node.args):\n            if arg.name == \"caller\":\n                explicit_caller = idx\n            if arg.name in (\"kwargs\", \"varargs\"):\n                skip_special_params.add(arg.name)\n            args.append(frame.symbols.ref(arg.name))\n\n        undeclared = find_undeclared(node.body, (\"caller\", \"kwargs\", \"varargs\"))\n\n        if \"caller\" in undeclared:\n            # In older Jinja versions there was a bug that allowed caller\n            # to retain the special behavior even if it was mentioned in\n            # the argument list.  However thankfully this was only really\n            # working if it was the last argument.  So we are explicitly\n            # checking this now and error out if it is anywhere else in\n            # the argument list.\n            if explicit_caller is not None:\n                try:\n                    node.defaults[explicit_caller - len(node.args)]\n                except IndexError:\n                    self.fail(\n                        \"When defining macros or call blocks the \"\n                        'special \"caller\" argument must be omitted '\n                        \"or be given a default.\",\n                        node.lineno,\n                    )\n            else:\n                args.append(frame.symbols.declare_parameter(\"caller\"))\n            macro_ref.accesses_caller = True\n        if \"kwargs\" in undeclared and \"kwargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"kwargs\"))\n            macro_ref.accesses_kwargs = True\n        if \"varargs\" in undeclared and \"varargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"varargs\"))\n            macro_ref.accesses_varargs = True\n\n        # macros are delayed, they never require output checks\n        frame.require_output_check = False\n        frame.symbols.analyze_node(node)\n        self.writeline(f\"{self.func('macro')}({', '.join(args)}):\", node)\n        self.indent()\n\n        self.buffer(frame)\n        self.enter_frame(frame)\n\n        self.push_parameter_definitions(frame)\n        for idx, arg in enumerate(node.args):\n            ref = frame.symbols.ref(arg.name)\n            self.writeline(f\"if {ref} is missing:\")\n            self.indent()\n            try:\n                default = node.defaults[idx - len(node.args)]\n            except IndexError:\n                self.writeline(\n                    f'{ref} = undefined(\"parameter {arg.name!r} was not provided\",'\n                    f\" name={arg.name!r})\"\n                )\n            else:\n                self.writeline(f\"{ref} = \")\n                self.visit(default, frame)\n            self.mark_parameter_stored(ref)\n            self.outdent()\n        self.pop_parameter_definitions()\n\n        self.blockvisit(node.body, frame)\n        self.return_buffer_contents(frame, force_unescaped=True)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        return frame, macro_ref\n\n    def macro_def(self, macro_ref: MacroRef, frame: Frame) -> None:\n        \"\"\"Dump the macro definition for the def created by macro_body.\"\"\"\n        arg_tuple = \", \".join(repr(x.name) for x in macro_ref.node.args)\n        name = getattr(macro_ref.node, \"name\", None)\n        if len(macro_ref.node.args) == 1:\n            arg_tuple += \",\"\n        self.write(\n            f\"Macro(environment, macro, {name!r}, ({arg_tuple}),\"\n            f\" {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},\"\n            f\" {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)\"\n        )\n\n    def position(self, node: nodes.Node) -> str:\n        \"\"\"Return a human readable position for the node.\"\"\"\n        rv = f\"line {node.lineno}\"\n        if self.name is not None:\n            rv = f\"{rv} in {self.name!r}\"\n        return rv\n\n    def dump_local_context(self, frame: Frame) -> str:\n        items_kv = \", \".join(\n            f\"{name!r}: {target}\"\n            for name, target in frame.symbols.dump_stores().items()\n        )\n        return f\"{{{items_kv}}}\"\n\n    def write_commons(self) -> None:\n        \"\"\"Writes a common preamble that is used by root and block functions.\n        Primarily this sets up common local helpers and enforces a generator\n        through a dead branch.\n        \"\"\"\n        self.writeline(\"resolve = context.resolve_or_missing\")\n        self.writeline(\"undefined = environment.undefined\")\n        self.writeline(\"concat = environment.concat\")\n        # always use the standard Undefined class for the implicit else of\n        # conditional expressions\n        self.writeline(\"cond_expr_undefined = Undefined\")\n        self.writeline(\"if 0: yield None\")\n\n    def push_parameter_definitions(self, frame: Frame) -> None:\n        \"\"\"Pushes all parameter targets from the given frame into a local\n        stack that permits tracking of yet to be assigned parameters.  In\n        particular this enables the optimization from `visit_Name` to skip\n        undefined expressions for parameters in macros as macros can reference\n        otherwise unbound parameters.\n        \"\"\"\n        self._param_def_block.append(frame.symbols.dump_param_targets())\n\n    def pop_parameter_definitions(self) -> None:\n        \"\"\"Pops the current parameter definitions set.\"\"\"\n        self._param_def_block.pop()\n\n    def mark_parameter_stored(self, target: str) -> None:\n        \"\"\"Marks a parameter in the current parameter definitions as stored.\n        This will skip the enforced undefined checks.\n        \"\"\"\n        if self._param_def_block:\n            self._param_def_block[-1].discard(target)\n\n    def push_context_reference(self, target: str) -> None:\n        self._context_reference_stack.append(target)\n\n    def pop_context_reference(self) -> None:\n        self._context_reference_stack.pop()\n\n    def get_context_ref(self) -> str:\n        return self._context_reference_stack[-1]\n\n    def get_resolve_func(self) -> str:\n        target = self._context_reference_stack[-1]\n        if target == \"context\":\n            return \"resolve\"\n        return f\"{target}.resolve\"\n\n    def derive_context(self, frame: Frame) -> str:\n        return f\"{self.get_context_ref()}.derived({self.dump_local_context(frame)})\"\n\n    def parameter_is_undeclared(self, target: str) -> bool:\n        \"\"\"Checks if a given target is an undeclared parameter.\"\"\"\n        if not self._param_def_block:\n            return False\n        return target in self._param_def_block[-1]\n\n    def push_assign_tracking(self) -> None:\n        \"\"\"Pushes a new layer for assignment tracking.\"\"\"\n        self._assign_stack.append(set())\n\n    def pop_assign_tracking(self, frame: Frame) -> None:\n        \"\"\"Pops the topmost level for assignment tracking and updates the\n        context variables if necessary.\n        \"\"\"\n        vars = self._assign_stack.pop()\n        if (\n            not frame.block_frame\n            and not frame.loop_frame\n            and not frame.toplevel\n            or not vars\n        ):\n            return\n        public_names = [x for x in vars if x[:1] != \"_\"]\n        if len(vars) == 1:\n            name = next(iter(vars))\n            ref = frame.symbols.ref(name)\n            if frame.loop_frame:\n                self.writeline(f\"_loop_vars[{name!r}] = {ref}\")\n                return\n            if frame.block_frame:\n                self.writeline(f\"_block_vars[{name!r}] = {ref}\")\n                return\n            self.writeline(f\"context.vars[{name!r}] = {ref}\")\n        else:\n            if frame.loop_frame:\n                self.writeline(\"_loop_vars.update({\")\n            elif frame.block_frame:\n                self.writeline(\"_block_vars.update({\")\n            else:\n                self.writeline(\"context.vars.update({\")\n            for idx, name in enumerate(sorted(vars)):\n                if idx:\n                    self.write(\", \")\n                ref = frame.symbols.ref(name)\n                self.write(f\"{name!r}: {ref}\")\n            self.write(\"})\")\n        if not frame.block_frame and not frame.loop_frame and public_names:\n            if len(public_names) == 1:\n                self.writeline(f\"context.exported_vars.add({public_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, sorted(public_names)))\n                self.writeline(f\"context.exported_vars.update(({names_str}))\")\n\n    # -- Statement Visitors\n\n    def visit_Template(self, node: nodes.Template, frame: Frame | None = None) -> None:\n        assert frame is None, \"no root frame allowed\"\n        eval_ctx = EvalContext(self.environment, self.name)\n\n        from .runtime import async_exported\n        from .runtime import exported\n\n        if self.environment.is_async:\n            exported_names = sorted(exported + async_exported)\n        else:\n            exported_names = sorted(exported)\n\n        self.writeline(\"from jinja2.runtime import \" + \", \".join(exported_names))\n\n        # if we want a deferred initialization we cannot move the\n        # environment into a local name\n        envenv = \"\" if self.defer_init else \", environment=environment\"\n\n        # do we have an extends tag at all?  If not, we can save some\n        # overhead by just not processing any inheritance code.\n        have_extends = node.find(nodes.Extends) is not None\n\n        # find all blocks\n        for block in node.find_all(nodes.Block):\n            if block.name in self.blocks:\n                self.fail(f\"block {block.name!r} defined twice\", block.lineno)\n            self.blocks[block.name] = block\n\n        # find all imports and import them\n        for import_ in node.find_all(nodes.ImportedName):\n            if import_.importname not in self.import_aliases:\n                imp = import_.importname\n                self.import_aliases[imp] = alias = self.temporary_identifier()\n                if \".\" in imp:\n                    module, obj = imp.rsplit(\".\", 1)\n                    self.writeline(f\"from {module} import {obj} as {alias}\")\n                else:\n                    self.writeline(f\"import {imp} as {alias}\")\n\n        # add the load name\n        self.writeline(f\"name = {self.name!r}\")\n\n        # generate the root render function.\n        self.writeline(\n            f\"{self.func('root')}(context, missing=missing{envenv}):\", extra=1\n        )\n        self.indent()\n        self.write_commons()\n\n        # process the root\n        frame = Frame(eval_ctx)\n        if \"self\" in find_undeclared(node.body, (\"self\",)):\n            ref = frame.symbols.declare_parameter(\"self\")\n            self.writeline(f\"{ref} = TemplateReference(context)\")\n        frame.symbols.analyze_node(node)\n        frame.toplevel = frame.rootlevel = True\n        frame.require_output_check = have_extends and not self.has_known_extends\n        if have_extends:\n            self.writeline(\"parent_template = None\")\n        self.enter_frame(frame)\n        self.pull_dependencies(node.body)\n        self.blockvisit(node.body, frame)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        # make sure that the parent root is called.\n        if have_extends:\n            if not self.has_known_extends:\n                self.indent()\n                self.writeline(\"if parent_template is not None:\")\n            self.indent()\n            if not self.environment.is_async:\n                self.writeline(\"yield from parent_template.root_render_func(context)\")\n            else:\n                self.writeline(\"agen = parent_template.root_render_func(context)\")\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(\"async for event in agen:\")\n                self.indent()\n                self.writeline(\"yield event\")\n                self.outdent()\n                self.outdent()\n                self.writeline(\"finally: await agen.aclose()\")\n            self.outdent(1 + (not self.has_known_extends))\n\n        # at this point we now have the blocks collected and can visit them too.\n        for name, block in self.blocks.items():\n            self.writeline(\n                f\"{self.func('block_' + name)}(context, missing=missing{envenv}):\",\n                block,\n                1,\n            )\n            self.indent()\n            self.write_commons()\n            # It's important that we do not make this frame a child of the\n            # toplevel template.  This would cause a variety of\n            # interesting issues with identifier tracking.\n            block_frame = Frame(eval_ctx)\n            block_frame.block_frame = True\n            undeclared = find_undeclared(block.body, (\"self\", \"super\"))\n            if \"self\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"self\")\n                self.writeline(f\"{ref} = TemplateReference(context)\")\n            if \"super\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"super\")\n                self.writeline(f\"{ref} = context.super({name!r}, block_{name})\")\n            block_frame.symbols.analyze_node(block)\n            block_frame.block = name\n            self.writeline(\"_block_vars = {}\")\n            self.enter_frame(block_frame)\n            self.pull_dependencies(block.body)\n            self.blockvisit(block.body, block_frame)\n            self.leave_frame(block_frame, with_python_scope=True)\n            self.outdent()\n\n        blocks_kv_str = \", \".join(f\"{x!r}: block_{x}\" for x in self.blocks)\n        self.writeline(f\"blocks = {{{blocks_kv_str}}}\", extra=1)\n        debug_kv_str = \"&\".join(f\"{k}={v}\" for k, v in self.debug_info)\n        self.writeline(f\"debug_info = {debug_kv_str!r}\")\n\n    def visit_Block(self, node: nodes.Block, frame: Frame) -> None:\n        \"\"\"Call a block and register it for the template.\"\"\"\n        level = 0\n        if frame.toplevel:\n            # if we know that we are a child template, there is no need to\n            # check if we are one\n            if self.has_known_extends:\n                return\n            if self.extends_so_far > 0:\n                self.writeline(\"if parent_template is None:\")\n                self.indent()\n                level += 1\n\n        if node.scoped:\n            context = self.derive_context(frame)\n        else:\n            context = self.get_context_ref()\n\n        if node.required:\n            self.writeline(f\"if len(context.blocks[{node.name!r}]) <= 1:\", node)\n            self.indent()\n            self.writeline(\n                f'raise TemplateRuntimeError(\"Required block {node.name!r} not found\")',\n                node,\n            )\n            self.outdent()\n\n        if not self.environment.is_async and frame.buffer is None:\n            self.writeline(\n                f\"yield from context.blocks[{node.name!r}][0]({context})\", node\n            )\n        else:\n            self.writeline(f\"gen = context.blocks[{node.name!r}][0]({context})\")\n            self.writeline(\"try:\")\n            self.indent()\n            self.writeline(\n                f\"{self.choose_async()}for event in gen:\",\n                node,\n            )\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n            self.outdent()\n            self.writeline(\n                f\"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}\"\n            )\n\n        self.outdent(level)\n\n    def visit_Extends(self, node: nodes.Extends, frame: Frame) -> None:\n        \"\"\"Calls the extender.\"\"\"\n        if not frame.toplevel:\n            self.fail(\"cannot use extend from a non top-level scope\", node.lineno)\n\n        # if the number of extends statements in general is zero so\n        # far, we don't have to add a check if something extended\n        # the template before this one.\n        if self.extends_so_far > 0:\n            # if we have a known extends we just add a template runtime\n            # error into the generated code.  We could catch that at compile\n            # time too, but i welcome it not to confuse users by throwing the\n            # same error at different times just \"because we can\".\n            if not self.has_known_extends:\n                self.writeline(\"if parent_template is not None:\")\n                self.indent()\n            self.writeline('raise TemplateRuntimeError(\"extended multiple times\")')\n\n            # if we have a known extends already we don't need that code here\n            # as we know that the template execution will end here.\n            if self.has_known_extends:\n                raise CompilerExit()\n            else:\n                self.outdent()\n\n        self.writeline(\"parent_template = environment.get_template(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        self.writeline(\"for name, parent_block in parent_template.blocks.items():\")\n        self.indent()\n        self.writeline(\"context.blocks.setdefault(name, []).append(parent_block)\")\n        self.outdent()\n\n        # if this extends statement was in the root level we can take\n        # advantage of that information and simplify the generated code\n        # in the top level from this point onwards\n        if frame.rootlevel:\n            self.has_known_extends = True\n\n        # and now we have one more\n        self.extends_so_far += 1\n\n    def visit_Include(self, node: nodes.Include, frame: Frame) -> None:\n        \"\"\"Handles includes.\"\"\"\n        if node.ignore_missing:\n            self.writeline(\"try:\")\n            self.indent()\n\n        func_name = \"get_or_select_template\"\n        if isinstance(node.template, nodes.Const):\n            if isinstance(node.template.value, str):\n                func_name = \"get_template\"\n            elif isinstance(node.template.value, (tuple, list)):\n                func_name = \"select_template\"\n        elif isinstance(node.template, (nodes.Tuple, nodes.List)):\n            func_name = \"select_template\"\n\n        self.writeline(f\"template = environment.{func_name}(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        if node.ignore_missing:\n            self.outdent()\n            self.writeline(\"except TemplateNotFound:\")\n            self.indent()\n            self.writeline(\"pass\")\n            self.outdent()\n            self.writeline(\"else:\")\n            self.indent()\n\n        def loop_body() -> None:\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n\n        if node.with_context:\n            self.writeline(\n                f\"gen = template.root_render_func(\"\n                \"template.new_context(context.get_all(), True,\"\n                f\" {self.dump_local_context(frame)}))\"\n            )\n            self.writeline(\"try:\")\n            self.indent()\n            self.writeline(f\"{self.choose_async()}for event in gen:\")\n            loop_body()\n            self.outdent()\n            self.writeline(\n                f\"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}\"\n            )\n        elif self.environment.is_async:\n            self.writeline(\n                \"for event in (await template._get_default_module_async())\"\n                \"._body_stream:\"\n            )\n            loop_body()\n        else:\n            self.writeline(\"yield from template._get_default_module()._body_stream\")\n\n        if node.ignore_missing:\n            self.outdent()\n\n    def _import_common(\n        self, node: nodes.Import | nodes.FromImport, frame: Frame\n    ) -> None:\n        self.write(f\"{self.choose_async('await ')}environment.get_template(\")\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r}).\")\n\n        if node.with_context:\n            f_name = f\"make_module{self.choose_async('_async')}\"\n            self.write(\n                f\"{f_name}(context.get_all(), True, {self.dump_local_context(frame)})\"\n            )\n        else:\n            self.write(f\"_get_default_module{self.choose_async('_async')}(context)\")\n\n    def visit_Import(self, node: nodes.Import, frame: Frame) -> None:\n        \"\"\"Visit regular imports.\"\"\"\n        self.writeline(f\"{frame.symbols.ref(node.target)} = \", node)\n        if frame.toplevel:\n            self.write(f\"context.vars[{node.target!r}] = \")\n\n        self._import_common(node, frame)\n\n        if frame.toplevel and not node.target.startswith(\"_\"):\n            self.writeline(f\"context.exported_vars.discard({node.target!r})\")\n\n    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -> None:\n        \"\"\"Visit named imports.\"\"\"\n        self.newline(node)\n        self.write(\"included_template = \")\n        self._import_common(node, frame)\n        var_names = []\n        discarded_names = []\n        for name in node.names:\n            if isinstance(name, tuple):\n                name, alias = name\n            else:\n                alias = name\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} =\"\n                f\" getattr(included_template, {name!r}, missing)\"\n            )\n            self.writeline(f\"if {frame.symbols.ref(alias)} is missing:\")\n            self.indent()\n            # The position will contain the template name, and will be formatted\n            # into a string that will be compiled into an f-string. Curly braces\n            # in the name must be replaced with escapes so that they will not be\n            # executed as part of the f-string.\n            position = self.position(node).replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n            message = (\n                \"the template {included_template.__name__!r}\"\n                f\" (imported on {position})\"\n                f\" does not export the requested name {name!r}\"\n            )\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})\"\n            )\n            self.outdent()\n            if frame.toplevel:\n                var_names.append(alias)\n                if not alias.startswith(\"_\"):\n                    discarded_names.append(alias)\n\n        if var_names:\n            if len(var_names) == 1:\n                name = var_names[0]\n                self.writeline(f\"context.vars[{name!r}] = {frame.symbols.ref(name)}\")\n            else:\n                names_kv = \", \".join(\n                    f\"{name!r}: {frame.symbols.ref(name)}\" for name in var_names\n                )\n                self.writeline(f\"context.vars.update({{{names_kv}}})\")\n        if discarded_names:\n            if len(discarded_names) == 1:\n                self.writeline(f\"context.exported_vars.discard({discarded_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, discarded_names))\n                self.writeline(\n                    f\"context.exported_vars.difference_update(({names_str}))\"\n                )\n\n    def visit_For(self, node: nodes.For, frame: Frame) -> None:\n        loop_frame = frame.inner()\n        loop_frame.loop_frame = True\n        test_frame = frame.inner()\n        else_frame = frame.inner()\n\n        # try to figure out if we have an extended loop.  An extended loop\n        # is necessary if the loop is in recursive mode if the special loop\n        # variable is accessed in the body if the body is a scoped block.\n        extended_loop = (\n            node.recursive\n            or \"loop\"\n            in find_undeclared(node.iter_child_nodes(only=(\"body\",)), (\"loop\",))\n            or any(block.scoped for block in node.find_all(nodes.Block))\n        )\n\n        loop_ref = None\n        if extended_loop:\n            loop_ref = loop_frame.symbols.declare_parameter(\"loop\")\n\n        loop_frame.symbols.analyze_node(node, for_branch=\"body\")\n        if node.else_:\n            else_frame.symbols.analyze_node(node, for_branch=\"else\")\n\n        if node.test:\n            loop_filter_func = self.temporary_identifier()\n            test_frame.symbols.analyze_node(node, for_branch=\"test\")\n            self.writeline(f\"{self.func(loop_filter_func)}(fiter):\", node.test)\n            self.indent()\n            self.enter_frame(test_frame)\n            self.writeline(self.choose_async(\"async for \", \"for \"))\n            self.visit(node.target, loop_frame)\n            self.write(\" in \")\n            self.write(self.choose_async(\"auto_aiter(fiter)\", \"fiter\"))\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"if \", node.test)\n            self.visit(node.test, test_frame)\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"yield \")\n            self.visit(node.target, loop_frame)\n            self.outdent(3)\n            self.leave_frame(test_frame, with_python_scope=True)\n\n        # if we don't have an recursive loop we have to find the shadowed\n        # variables at that point.  Because loops can be nested but the loop\n        # variable is a special one we have to enforce aliasing for it.\n        if node.recursive:\n            self.writeline(\n                f\"{self.func('loop')}(reciter, loop_render_func, depth=0):\", node\n            )\n            self.indent()\n            self.buffer(loop_frame)\n\n            # Use the same buffer for the else frame\n            else_frame.buffer = loop_frame.buffer\n\n        # make sure the loop variable is a special one and raise a template\n        # assertion error if a loop tries to write to loop\n        if extended_loop:\n            self.writeline(f\"{loop_ref} = missing\")\n\n        for name in node.find_all(nodes.Name):\n            if name.ctx == \"store\" and name.name == \"loop\":\n                self.fail(\n                    \"Can't assign to special loop variable in for-loop target\",\n                    name.lineno,\n                )\n\n        if node.else_:\n            iteration_indicator = self.temporary_identifier()\n            self.writeline(f\"{iteration_indicator} = 1\")\n\n        self.writeline(self.choose_async(\"async for \", \"for \"), node)\n        self.visit(node.target, loop_frame)\n        if extended_loop:\n            self.write(f\", {loop_ref} in {self.choose_async('Async')}LoopContext(\")\n        else:\n            self.write(\" in \")\n\n        if node.test:\n            self.write(f\"{loop_filter_func}(\")\n        if node.recursive:\n            self.write(\"reciter\")\n        else:\n            if self.environment.is_async and not extended_loop:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async and not extended_loop:\n                self.write(\")\")\n        if node.test:\n            self.write(\")\")\n\n        if node.recursive:\n            self.write(\", undefined, loop_render_func, depth):\")\n        else:\n            self.write(\", undefined):\" if extended_loop else \":\")\n\n        self.indent()\n        self.enter_frame(loop_frame)\n\n        self.writeline(\"_loop_vars = {}\")\n        self.blockvisit(node.body, loop_frame)\n        if node.else_:\n            self.writeline(f\"{iteration_indicator} = 0\")\n        self.outdent()\n        self.leave_frame(\n            loop_frame, with_python_scope=node.recursive and not node.else_\n        )\n\n        if node.else_:\n            self.writeline(f\"if {iteration_indicator}:\")\n            self.indent()\n            self.enter_frame(else_frame)\n            self.blockvisit(node.else_, else_frame)\n            self.leave_frame(else_frame)\n            self.outdent()\n\n        # if the node was recursive we have to return the buffer contents\n        # and start the iteration code\n        if node.recursive:\n            self.return_buffer_contents(loop_frame)\n            self.outdent()\n            self.start_write(frame, node)\n            self.write(f\"{self.choose_async('await ')}loop(\")\n            if self.environment.is_async:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async:\n                self.write(\")\")\n            self.write(\", loop)\")\n            self.end_write(frame)\n\n        # at the end of the iteration, clear any assignments made in the\n        # loop from the top level\n        if self._assign_stack:\n            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)\n\n    def visit_If(self, node: nodes.If, frame: Frame) -> None:\n        if_frame = frame.soft()\n        self.writeline(\"if \", node)\n        self.visit(node.test, if_frame)\n        self.write(\":\")\n        self.indent()\n        self.blockvisit(node.body, if_frame)\n        self.outdent()\n        for elif_ in node.elif_:\n            self.writeline(\"elif \", elif_)\n            self.visit(elif_.test, if_frame)\n            self.write(\":\")\n            self.indent()\n            self.blockvisit(elif_.body, if_frame)\n            self.outdent()\n        if node.else_:\n            self.writeline(\"else:\")\n            self.indent()\n            self.blockvisit(node.else_, if_frame)\n            self.outdent()\n\n    def visit_Macro(self, node: nodes.Macro, frame: Frame) -> None:\n        macro_frame, macro_ref = self.macro_body(node, frame)\n        self.newline()\n        if frame.toplevel:\n            if not node.name.startswith(\"_\"):\n                self.write(f\"context.exported_vars.add({node.name!r})\")\n            self.writeline(f\"context.vars[{node.name!r}] = \")\n        self.write(f\"{frame.symbols.ref(node.name)} = \")\n        self.macro_def(macro_ref, macro_frame)\n\n    def visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -> None:\n        call_frame, macro_ref = self.macro_body(node, frame)\n        self.writeline(\"caller = \")\n        self.macro_def(macro_ref, call_frame)\n        self.start_write(frame, node)\n        self.visit_Call(node.call, frame, forward_caller=True)\n        self.end_write(frame)\n\n    def visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -> None:\n        filter_frame = frame.inner()\n        filter_frame.symbols.analyze_node(node)\n        self.enter_frame(filter_frame)\n        self.buffer(filter_frame)\n        self.blockvisit(node.body, filter_frame)\n        self.start_write(frame, node)\n        self.visit_Filter(node.filter, filter_frame)\n        self.end_write(frame)\n        self.leave_frame(filter_frame)\n\n    def visit_With(self, node: nodes.With, frame: Frame) -> None:\n        with_frame = frame.inner()\n        with_frame.symbols.analyze_node(node)\n        self.enter_frame(with_frame)\n        for target, expr in zip(node.targets, node.values, strict=False):\n            self.newline()\n            self.visit(target, with_frame)\n            self.write(\" = \")\n            self.visit(expr, frame)\n        self.blockvisit(node.body, with_frame)\n        self.leave_frame(with_frame)\n\n    def visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -> None:\n        self.newline(node)\n        self.visit(node.node, frame)\n\n    class _FinalizeInfo(t.NamedTuple):\n        const: t.Callable[..., str] | None\n        src: str | None\n\n    @staticmethod\n    def _default_finalize(value: t.Any) -> t.Any:\n        \"\"\"The default finalize function if the environment isn't\n        configured with one. Or, if the environment has one, this is\n        called on that function's output for constants.\n        \"\"\"\n        return str(value)\n\n    _finalize: _FinalizeInfo | None = None\n\n    def _make_finalize(self) -> _FinalizeInfo:\n        \"\"\"Build the finalize function to be used on constants and at\n        runtime. Cached so it's only created once for all output nodes.\n\n        Returns a ``namedtuple`` with the following attributes:\n\n        ``const``\n            A function to finalize constant data at compile time.\n\n        ``src``\n            Source code to output around nodes to be evaluated at\n            runtime.\n        \"\"\"\n        if self._finalize is not None:\n            return self._finalize\n\n        finalize: t.Callable[..., t.Any] | None\n        finalize = default = self._default_finalize\n        src = None\n\n        if self.environment.finalize:\n            src = \"environment.finalize(\"\n            env_finalize = self.environment.finalize\n            pass_arg = {\n                _PassArg.context: \"context\",\n                _PassArg.eval_context: \"context.eval_ctx\",\n                _PassArg.environment: \"environment\",\n            }.get(\n                _PassArg.from_obj(env_finalize)  # type: ignore\n            )\n            finalize = None\n\n            if pass_arg is None:\n\n                def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                    return default(env_finalize(value))\n\n            else:\n                src = f\"{src}{pass_arg}, \"\n\n                if pass_arg == \"environment\":\n\n                    def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                        return default(env_finalize(self.environment, value))\n\n        self._finalize = self._FinalizeInfo(finalize, src)\n        return self._finalize\n\n    def _output_const_repr(self, group: t.Iterable[t.Any]) -> str:\n        \"\"\"Given a group of constant values converted from ``Output``\n        child nodes, produce a string to write to the template module\n        source.\n        \"\"\"\n        return repr(concat(group))\n\n    def _output_child_to_const(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> str:\n        \"\"\"Try to optimize a child of an ``Output`` node by trying to\n        convert it to constant, finalized data at compile time.\n\n        If :exc:`Impossible` is raised, the node is not constant and\n        will be evaluated at runtime. Any other exception will also be\n        evaluated at runtime for easier debugging.\n        \"\"\"\n        const = node.as_const(frame.eval_ctx)\n\n        if frame.eval_ctx.autoescape:\n            const = escape(const)\n\n        # Template data doesn't go through finalize.\n        if isinstance(node, nodes.TemplateData):\n            return str(const)\n\n        return finalize.const(const)  # type: ignore\n\n    def _output_child_pre(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code before visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        if frame.eval_ctx.volatile:\n            self.write(\"(escape if context.eval_ctx.autoescape else str)(\")\n        elif frame.eval_ctx.autoescape:\n            self.write(\"escape(\")\n        else:\n            self.write(\"str(\")\n\n        if finalize.src is not None:\n            self.write(finalize.src)\n\n    def _output_child_post(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code after visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        self.write(\")\")\n\n        if finalize.src is not None:\n            self.write(\")\")\n\n    def visit_Output(self, node: nodes.Output, frame: Frame) -> None:\n        # If an extends is active, don't render outside a block.\n        if frame.require_output_check:\n            # A top-level extends is known to exist at compile time.\n            if self.has_known_extends:\n                return\n\n            self.writeline(\"if parent_template is None:\")\n            self.indent()\n\n        finalize = self._make_finalize()\n        body: list[list[t.Any] | nodes.Expr] = []\n\n        # Evaluate constants at compile time if possible. Each item in\n        # body will be either a list of static data or a node to be\n        # evaluated at runtime.\n        for child in node.nodes:\n            try:\n                if not (\n                    # If the finalize function requires runtime context,\n                    # constants can't be evaluated at compile time.\n                    finalize.const\n                    # Unless it's basic template data that won't be\n                    # finalized anyway.\n                    or isinstance(child, nodes.TemplateData)\n                ):\n                    raise nodes.Impossible()\n\n                const = self._output_child_to_const(child, frame, finalize)\n            except (nodes.Impossible, Exception):\n                # The node was not constant and needs to be evaluated at\n                # runtime. Or another error was raised, which is easier\n                # to debug at runtime.\n                body.append(child)\n                continue\n\n            if body and isinstance(body[-1], list):\n                body[-1].append(const)\n            else:\n                body.append([const])\n\n        if frame.buffer is not None:\n            if len(body) == 1:\n                self.writeline(f\"{frame.buffer}.append(\")\n            else:\n                self.writeline(f\"{frame.buffer}.extend((\")\n\n            self.indent()\n\n        for item in body:\n            if isinstance(item, list):\n                # A group of constant data to join and output.\n                val = self._output_const_repr(item)\n\n                if frame.buffer is None:\n                    self.writeline(\"yield \" + val)\n                else:\n                    self.writeline(val + \",\")\n            else:\n                if frame.buffer is None:\n                    self.writeline(\"yield \", item)\n                else:\n                    self.newline(item)\n\n                # A node to be evaluated at runtime.\n                self._output_child_pre(item, frame, finalize)\n                self.visit(item, frame)\n                self._output_child_post(item, frame, finalize)\n\n                if frame.buffer is not None:\n                    self.write(\",\")\n\n        if frame.buffer is not None:\n            self.outdent()\n            self.writeline(\")\" if len(body) == 1 else \"))\")\n\n        if frame.require_output_check:\n            self.outdent()\n\n    def visit_Assign(self, node: nodes.Assign, frame: Frame) -> None:\n        self.push_assign_tracking()\n\n        # ``a.b`` is allowed for assignment, and is parsed as an NSRef. However,\n        # it is only valid if it references a Namespace object. Emit a check for\n        # that for each ref here, before assignment code is emitted. This can't\n        # be done in visit_NSRef as the ref could be in the middle of a tuple.\n        seen_refs: set[str] = set()\n\n        for nsref in node.find_all(nodes.NSRef):\n            if nsref.name in seen_refs:\n                # Only emit the check for each reference once, in case the same\n                # ref is used multiple times in a tuple, `ns.a, ns.b = c, d`.\n                continue\n\n            seen_refs.add(nsref.name)\n            ref = frame.symbols.ref(nsref.name)\n            self.writeline(f\"if not isinstance({ref}, Namespace):\")\n            self.indent()\n            self.writeline(\n                \"raise TemplateRuntimeError\"\n                '(\"cannot assign attribute on non-namespace object\")'\n            )\n            self.outdent()\n\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = \")\n        self.visit(node.node, frame)\n        self.pop_assign_tracking(frame)\n\n    def visit_AssignBlock(self, node: nodes.AssignBlock, frame: Frame) -> None:\n        self.push_assign_tracking()\n        block_frame = frame.inner()\n        # This is a special case.  Since a set block always captures we\n        # will disable output checks.  This way one can use set blocks\n        # toplevel even in extended templates.\n        block_frame.require_output_check = False\n        block_frame.symbols.analyze_node(node)\n        self.enter_frame(block_frame)\n        self.buffer(block_frame)\n        self.blockvisit(node.body, block_frame)\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = (Markup if context.eval_ctx.autoescape else identity)(\")\n        if node.filter is not None:\n            self.visit_Filter(node.filter, block_frame)\n        else:\n            self.write(f\"concat({block_frame.buffer})\")\n        self.write(\")\")\n        self.pop_assign_tracking(frame)\n        self.leave_frame(block_frame)\n\n    # -- Expression Visitors\n\n    def visit_Name(self, node: nodes.Name, frame: Frame) -> None:\n        if node.ctx == \"store\" and (\n            frame.toplevel or frame.loop_frame or frame.block_frame\n        ):\n            if self._assign_stack:\n                self._assign_stack[-1].add(node.name)\n        ref = frame.symbols.ref(node.name)\n\n        # If we are looking up a variable we might have to deal with the\n        # case where it's undefined.  We can skip that case if the load\n        # instruction indicates a parameter which are always defined.\n        if node.ctx == \"load\":\n            load = frame.symbols.find_load(ref)\n            if not (\n                load is not None\n                and load[0] == VAR_LOAD_PARAMETER\n                and not self.parameter_is_undeclared(ref)\n            ):\n                self.write(\n                    f\"(undefined(name={node.name!r}) if {ref} is missing else {ref})\"\n                )\n                return\n\n        self.write(ref)\n\n    def visit_NSRef(self, node: nodes.NSRef, frame: Frame) -> None:\n        # NSRef is a dotted assignment target a.b=c, but uses a[b]=c internally.\n        # visit_Assign emits code to validate that each ref is to a Namespace\n        # object only. That can't be emitted here as the ref could be in the\n        # middle of a tuple assignment.\n        ref = frame.symbols.ref(node.name)\n        self.writeline(f\"{ref}[{node.attr!r}]\")\n\n    def visit_Const(self, node: nodes.Const, frame: Frame) -> None:\n        val = node.as_const(frame.eval_ctx)\n        if isinstance(val, float):\n            self.write(str(val))\n        else:\n            self.write(repr(val))\n\n    def visit_TemplateData(self, node: nodes.TemplateData, frame: Frame) -> None:\n        try:\n            self.write(repr(node.as_const(frame.eval_ctx)))\n        except nodes.Impossible:\n            self.write(\n                f\"(Markup if context.eval_ctx.autoescape else identity)({node.data!r})\"\n            )\n\n    def visit_Tuple(self, node: nodes.Tuple, frame: Frame) -> None:\n        self.write(\"(\")\n        idx = -1\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\",)\" if idx == 0 else \")\")\n\n    def visit_List(self, node: nodes.List, frame: Frame) -> None:\n        self.write(\"[\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\"]\")\n\n    def visit_Dict(self, node: nodes.Dict, frame: Frame) -> None:\n        self.write(\"{\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item.key, frame)\n            self.write(\": \")\n            self.visit(item.value, frame)\n        self.write(\"}\")\n\n    visit_Add = _make_binop(\"+\")\n    visit_Sub = _make_binop(\"-\")\n    visit_Mul = _make_binop(\"*\")\n    visit_Div = _make_binop(\"/\")\n    visit_FloorDiv = _make_binop(\"//\")\n    visit_Pow = _make_binop(\"**\")\n    visit_Mod = _make_binop(\"%\")\n    visit_And = _make_binop(\"and\")\n    visit_Or = _make_binop(\"or\")\n    visit_Pos = _make_unop(\"+\")\n    visit_Neg = _make_unop(\"-\")\n    visit_Not = _make_unop(\"not \")\n\n    @optimizeconst\n    def visit_Concat(self, node: nodes.Concat, frame: Frame) -> None:\n        if frame.eval_ctx.volatile:\n            func_name = \"(markup_join if context.eval_ctx.volatile else str_join)\"\n        elif frame.eval_ctx.autoescape:\n            func_name = \"markup_join\"\n        else:\n            func_name = \"str_join\"\n        self.write(f\"{func_name}((\")\n        for arg in node.nodes:\n            self.visit(arg, frame)\n            self.write(\", \")\n        self.write(\"))\")\n\n    @optimizeconst\n    def visit_Compare(self, node: nodes.Compare, frame: Frame) -> None:\n        self.write(\"(\")\n        self.visit(node.expr, frame)\n        for op in node.ops:\n            self.visit(op, frame)\n        self.write(\")\")\n\n    def visit_Operand(self, node: nodes.Operand, frame: Frame) -> None:\n        self.write(f\" {operators[node.op]} \")\n        self.visit(node.expr, frame)\n\n    @optimizeconst\n    def visit_Getattr(self, node: nodes.Getattr, frame: Frame) -> None:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n\n        self.write(\"environment.getattr(\")\n        self.visit(node.node, frame)\n        self.write(f\", {node.attr!r})\")\n\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    @optimizeconst\n    def visit_Getitem(self, node: nodes.Getitem, frame: Frame) -> None:\n        # slices bypass the environment getitem method.\n        if isinstance(node.arg, nodes.Slice):\n            self.visit(node.node, frame)\n            self.write(\"[\")\n            self.visit(node.arg, frame)\n            self.write(\"]\")\n        else:\n            if self.environment.is_async:\n                self.write(\"(await auto_await(\")\n\n            self.write(\"environment.getitem(\")\n            self.visit(node.node, frame)\n            self.write(\", \")\n            self.visit(node.arg, frame)\n            self.write(\")\")\n\n            if self.environment.is_async:\n                self.write(\"))\")\n\n    def visit_Slice(self, node: nodes.Slice, frame: Frame) -> None:\n        if node.start is not None:\n            self.visit(node.start, frame)\n        self.write(\":\")\n        if node.stop is not None:\n            self.visit(node.stop, frame)\n        if node.step is not None:\n            self.write(\":\")\n            self.visit(node.step, frame)\n\n    @contextmanager\n    def _filter_test_common(\n        self, node: nodes.Filter | nodes.Test, frame: Frame, is_filter: bool\n    ) -> t.Iterator[None]:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n\n        if is_filter:\n            self.write(f\"{self.filters[node.name]}(\")\n            func = self.environment.filters.get(node.name)\n        else:\n            self.write(f\"{self.tests[node.name]}(\")\n            func = self.environment.tests.get(node.name)\n\n        # When inside an If or CondExpr frame, allow the filter to be\n        # undefined at compile time and only raise an error if it's\n        # actually called at runtime. See pull_dependencies.\n        if func is None and not frame.soft_frame:\n            type_name = \"filter\" if is_filter else \"test\"\n            self.fail(f\"No {type_name} named {node.name!r}.\", node.lineno)\n\n        pass_arg = {\n            _PassArg.context: \"context\",\n            _PassArg.eval_context: \"context.eval_ctx\",\n            _PassArg.environment: \"environment\",\n        }.get(\n            _PassArg.from_obj(func)  # type: ignore\n        )\n\n        if pass_arg is not None:\n            self.write(f\"{pass_arg}, \")\n\n        # Back to the visitor function to handle visiting the target of\n        # the filter or test.\n        yield\n\n        self.signature(node, frame)\n        self.write(\")\")\n\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    @optimizeconst\n    def visit_Filter(self, node: nodes.Filter, frame: Frame) -> None:\n        with self._filter_test_common(node, frame, True):\n            # if the filter node is None we are inside a filter block\n            # and want to write to the current buffer\n            if node.node is not None:\n                self.visit(node.node, frame)\n            elif frame.eval_ctx.volatile:\n                self.write(\n                    f\"(Markup(concat({frame.buffer}))\"\n                    f\" if context.eval_ctx.autoescape else concat({frame.buffer}))\"\n                )\n            elif frame.eval_ctx.autoescape:\n                self.write(f\"Markup(concat({frame.buffer}))\")\n            else:\n                self.write(f\"concat({frame.buffer})\")\n\n    @optimizeconst\n    def visit_Test(self, node: nodes.Test, frame: Frame) -> None:\n        with self._filter_test_common(node, frame, False):\n            self.visit(node.node, frame)\n\n    @optimizeconst\n    def visit_CondExpr(self, node: nodes.CondExpr, frame: Frame) -> None:\n        frame = frame.soft()\n\n        def write_expr2() -> None:\n            if node.expr2 is not None:\n                self.visit(node.expr2, frame)\n                return\n\n            self.write(\n                f'cond_expr_undefined(\"the inline if-expression on'\n                f\" {self.position(node)} evaluated to false and no else\"\n                f' section was defined.\")'\n            )\n\n        self.write(\"(\")\n        self.visit(node.expr1, frame)\n        self.write(\" if \")\n        self.visit(node.test, frame)\n        self.write(\" else \")\n        write_expr2()\n        self.write(\")\")\n\n    @optimizeconst\n    def visit_Call(\n        self, node: nodes.Call, frame: Frame, forward_caller: bool = False\n    ) -> None:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n        if self.environment.sandboxed:\n            self.write(\"environment.call(context, \")\n        else:\n            self.write(\"context.call(\")\n        self.visit(node.node, frame)\n        extra_kwargs = {\"caller\": \"caller\"} if forward_caller else None\n        loop_kwargs = {\"_loop_vars\": \"_loop_vars\"} if frame.loop_frame else {}\n        block_kwargs = {\"_block_vars\": \"_block_vars\"} if frame.block_frame else {}\n        if extra_kwargs:\n            extra_kwargs.update(loop_kwargs, **block_kwargs)\n        elif loop_kwargs or block_kwargs:\n            extra_kwargs = dict(loop_kwargs, **block_kwargs)\n        self.signature(node, frame, extra_kwargs)\n        self.write(\")\")\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    def visit_Keyword(self, node: nodes.Keyword, frame: Frame) -> None:\n        self.write(node.key + \"=\")\n        self.visit(node.value, frame)\n\n    # -- Unused nodes for extensions\n\n    def visit_MarkSafe(self, node: nodes.MarkSafe, frame: Frame) -> None:\n        self.write(\"Markup(\")\n        self.visit(node.expr, frame)\n        self.write(\")\")\n\n    def visit_MarkSafeIfAutoescape(\n        self, node: nodes.MarkSafeIfAutoescape, frame: Frame\n    ) -> None:\n        self.write(\"(Markup if context.eval_ctx.autoescape else identity)(\")\n        self.visit(node.expr, frame)\n        self.write(\")\")\n\n    def visit_EnvironmentAttribute(\n        self, node: nodes.EnvironmentAttribute, frame: Frame\n    ) -> None:\n        self.write(\"environment.\" + node.name)\n\n    def visit_ExtensionAttribute(\n        self, node: nodes.ExtensionAttribute, frame: Frame\n    ) -> None:\n        self.write(f\"environment.extensions[{node.identifier!r}].{node.name}\")\n\n    def visit_ImportedName(self, node: nodes.ImportedName, frame: Frame) -> None:\n        self.write(self.import_aliases[node.importname])\n\n    def visit_InternalName(self, node: nodes.InternalName, frame: Frame) -> None:\n        self.write(node.name)\n\n    def visit_ContextReference(\n        self, node: nodes.ContextReference, frame: Frame\n    ) -> None:\n        self.write(\"context\")\n\n    def visit_DerivedContextReference(\n        self, node: nodes.DerivedContextReference, frame: Frame\n    ) -> None:\n        self.write(self.derive_context(frame))\n\n    def visit_Continue(self, node: nodes.Continue, frame: Frame) -> None:\n        self.writeline(\"continue\", node)\n\n    def visit_Break(self, node: nodes.Break, frame: Frame) -> None:\n        self.writeline(\"break\", node)\n\n    def visit_Scope(self, node: nodes.Scope, frame: Frame) -> None:\n        scope_frame = frame.inner()\n        scope_frame.symbols.analyze_node(node)\n        self.enter_frame(scope_frame)\n        self.blockvisit(node.body, scope_frame)\n        self.leave_frame(scope_frame)\n\n    def visit_OverlayScope(self, node: nodes.OverlayScope, frame: Frame) -> None:\n        ctx = self.temporary_identifier()\n        self.writeline(f\"{ctx} = {self.derive_context(frame)}\")\n        self.writeline(f\"{ctx}.vars = \")\n        self.visit(node.context, frame)\n        self.push_context_reference(ctx)\n\n        scope_frame = frame.inner(isolated=True)\n        scope_frame.symbols.analyze_node(node)\n        self.enter_frame(scope_frame)\n        self.blockvisit(node.body, scope_frame)\n        self.leave_frame(scope_frame)\n        self.pop_context_reference()\n\n    def visit_EvalContextModifier(\n        self, node: nodes.EvalContextModifier, frame: Frame\n    ) -> None:\n        for keyword in node.options:\n            self.writeline(f\"context.eval_ctx.{keyword.key} = \")\n            self.visit(keyword.value, frame)\n            try:\n                val = keyword.value.as_const(frame.eval_ctx)\n            except nodes.Impossible:\n                frame.eval_ctx.volatile = True\n            else:\n                setattr(frame.eval_ctx, keyword.key, val)\n\n    def visit_ScopedEvalContextModifier(\n        self, node: nodes.ScopedEvalContextModifier, frame: Frame\n    ) -> None:\n        old_ctx_name = self.temporary_identifier()\n        saved_ctx = frame.eval_ctx.save()\n        self.writeline(f\"{old_ctx_name} = context.eval_ctx.save()\")\n        self.visit_EvalContextModifier(node, frame)\n        for child in node.body:\n            self.visit(child, frame)\n        frame.eval_ctx.revert(saved_ctx)\n        self.writeline(f\"context.eval_ctx.revert({old_ctx_name})\")\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00288",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmp8pjecjps.py",
  "source_line": 298,
  "validation_status": "validated"
}