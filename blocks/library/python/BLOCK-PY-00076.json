{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00076_execute() {\n    class OMLGenerator:\n    \"\"\"\n    OML Generator\n\n    Generates OML syntax from English text using multiple strategies.\n\n    Approach:\n    1. Detect command intent (verb extraction)\n    2. Extract parameters (paths, names, options)\n    3. Map to OML commands\n    4. Compress using grammar rules\n    5. Validate generated OML\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize OML generator\"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.grammar = OMLGrammar()\n        self.validator = OMLValidator()\n\n        # Command patterns (English phrase → OML command)\n        self.command_patterns = self._build_command_patterns()\n\n        # Detail level patterns\n        self.detail_patterns = {\n            r'\\b(high|overview|brief)\\b': 'HI',\n            r'\\b(medium|moderate|balanced)\\b': 'MD',\n            r'\\b(detailed|complete|full)\\b': 'DT',\n            r'\\b(minimal|summary)\\b': 'MN',\n        }\n\n    def generate(self, english_text: str, validate: bool = True) -> str:\n        \"\"\"\n        Generate OML from English text\n\n        Args:\n            english_text: Natural English command\n            validate: Whether to validate generated OML\n\n        Returns:\n            OML string\n\n        Raises:\n            OMLGenerateError: If generation fails or validation fails\n\n        Examples:\n            \"Read file.py\" → \"RD:file.py\"\n            \"Read file.py and summarize\" → \"RD:file.py|SUM:MD\"\n            \"Create service TokenMonitor with dependencies database\" → \"CR:svc:TkMon|DEP:db\"\n        \"\"\"\n        if not english_text or not english_text.strip():\n            raise OMLGenerateError(\"Empty English text\")\n\n        english_text = english_text.strip()\n\n        try:\n            # Strategy 1: Try pattern matching first (fast, accurate for common phrases)\n            oml = self._generate_from_patterns(english_text)\n\n            if not oml:\n                # Strategy 2: Parse sentence structure\n                oml = self._generate_from_parse(english_text)\n\n            if not oml:\n                # Strategy 3: Fallback to simple verb extraction\n                oml = self._generate_from_verbs(english_text)\n\n            if not oml:\n                raise OMLGenerateError(\"Could not generate OML from English text\")\n\n            # Compress paths and parameters\n            oml = self._compress_oml(oml)\n\n            # Validate if requested\n            if validate:\n                result = self.validator.validate(oml)\n                if not result.is_valid:\n                    error_msg = result.errors[0] if result.errors else \"Unknown validation error\"\n                    raise OMLGenerateError(f\"Generated invalid OML: {error_msg}\")\n\n            return oml\n\n        except Exception as e:\n            self.logger.error(f\"OML generation failed: {e}\")\n            raise OMLGenerateError(f\"Generation failed: {e}\")\n\n    def _generate_from_patterns(self, text: str) -> Optional[str]:\n        \"\"\"\n        Generate OML using pattern matching\n\n        Fast and accurate for common command patterns.\n        \"\"\"\n        text_lower = text.lower()\n\n        # Try each command pattern\n        for pattern, oml_template in self.command_patterns.items():\n            match = re.search(pattern, text_lower)\n            if match:\n                # Extract matched groups\n                groups = match.groups()\n\n                # Build OML from template\n                try:\n                    oml = self._build_from_template(oml_template, groups, text)\n                    if oml:\n                        return oml\n                except Exception as e:\n                    self.logger.debug(f\"Template building failed: {e}\")\n                    continue\n\n        return None\n\n    def _generate_from_parse(self, text: str) -> Optional[str]:\n        \"\"\"\n        Generate OML by parsing sentence structure\n\n        Extracts verbs, objects, modifiers, and constructs OML.\n        \"\"\"\n        # Extract components\n        verbs = self._extract_verbs(text)\n        paths = self._extract_paths(text)\n        names = self._extract_names(text)\n        detail = self._extract_detail_level(text)\n        options = self._extract_options(text)\n\n        if not verbs:\n            return None\n\n        # Build OML commands\n        commands = []\n\n        for verb in verbs:\n            # Map verb to OML command\n            oml_cmd = self.grammar.get_command(verb)\n            if not oml_cmd:\n                continue\n\n            # Build command string\n            cmd_parts = [oml_cmd]\n\n            # Add path if present\n            if paths:\n                cmd_parts.append(paths[0])\n                paths = paths[1:]  # Use next path for next verb\n\n            # Add name if present and applicable\n            if names and oml_cmd in ['CR', 'GEN', 'MK']:\n                cmd_parts.append(names[0])\n                names = names[1:]\n\n            # Add detail level\n            if detail and oml_cmd in ['SUM', 'ANZ', 'EXP', 'DSC']:\n                cmd_parts.append(detail)\n\n            commands.append(':'.join(cmd_parts))\n\n        if commands:\n            return '|'.join(commands)\n\n        return None\n\n    def _generate_from_verbs(self, text: str) -> Optional[str]:\n        \"\"\"\n        Fallback: Generate OML from extracted verbs only\n\n        Simple but works for basic commands.\n        \"\"\"\n        verbs = self._extract_verbs(text)\n        paths = self._extract_paths(text)\n\n        if not verbs:\n            return None\n\n        oml_cmds = []\n\n        for verb in verbs:\n            oml_cmd = self.grammar.get_command(verb)\n            if oml_cmd:\n                if paths:\n                    oml_cmds.append(f\"{oml_cmd}:{paths[0]}\")\n                    paths = paths[1:]\n                else:\n                    oml_cmds.append(oml_cmd)\n\n        if oml_cmds:\n            return '|'.join(oml_cmds)\n\n        return None\n\n    def _build_command_patterns(self) -> Dict[str, str]:\n        \"\"\"\n        Build regex patterns for common command phrases\n\n        Returns dict of {pattern: oml_template}\n        \"\"\"\n        return {\n            # Read patterns\n            r'read\\s+(?:the\\s+)?(?:file\\s+)?([^\\s]+(?:\\.py|\\.js|\\.json|\\.md)?)': 'RD:{0}',\n            r'show\\s+(?:me\\s+)?(?:the\\s+)?(?:file\\s+)?([^\\s]+)': 'RD:{0}',\n            r'display\\s+([^\\s]+)': 'RD:{0}',\n\n            # Write patterns\n            r'write\\s+(?:to\\s+)?(?:file\\s+)?([^\\s]+)': 'WR:{0}',\n            r'create\\s+(?:a\\s+)?(?:new\\s+)?file\\s+([^\\s]+)': 'CR:{0}',\n\n            # Edit patterns\n            r'edit\\s+([^\\s]+)': 'ED:{0}',\n            r'modify\\s+([^\\s]+)': 'ED:{0}',\n            r'update\\s+([^\\s]+)': 'UPD:{0}',\n\n            # Summarize patterns\n            r'summarize\\s+([^\\s]+)(?:\\s+(?:with\\s+)?(brief|medium|detailed|high|full))?': 'SUM:{0}:{1}',\n            r'summary\\s+of\\s+([^\\s]+)': 'SUM:{0}',\n\n            # Analyze patterns\n            r'analyze\\s+([^\\s]+)': 'ANZ:{0}',\n            r'analyze\\s+the\\s+(\\w+)\\s+directory': 'ANZ:{0}/',\n\n            # Search patterns\n            r'search\\s+for\\s+(.+?)\\s+in\\s+([^\\s]+)': 'SRC:{1}:{0}',\n            r'find\\s+(.+?)\\s+in\\s+([^\\s]+)': 'FND:{1}:{0}',\n\n            # Test patterns\n            r'test\\s+([^\\s]+)': 'TST:{0}',\n            r'run\\s+tests\\s+(?:for\\s+)?([^\\s]+)': 'TST:{0}',\n\n            # List patterns\n            r'list\\s+(?:all\\s+)?(?:files\\s+in\\s+)?([^\\s]+)': 'LST:{0}',\n            r'show\\s+(?:me\\s+)?(?:all\\s+)?(?:files\\s+in\\s+)?([^\\s]+)': 'LST:{0}',\n\n            # Create service patterns\n            r'create\\s+(?:a\\s+)?(?:new\\s+)?service\\s+(?:called\\s+)?(\\w+)': 'CR:svc:{0}',\n\n            # Pipeline patterns (read + summarize)\n            r'read\\s+([^\\s]+)\\s+and\\s+summarize': 'RD:{0}|SUM:fn:MD',\n            r'analyze\\s+([^\\s]+)\\s+and\\s+summarize': 'ANZ:{0}|SUM:MD',\n\n            # Compare/diff patterns\n            r'compare\\s+([^\\s]+)\\s+(?:and|with)\\s+([^\\s]+)': 'CMP:{0}:{1}',\n            r'diff\\s+([^\\s]+)\\s+(?:and|with)\\s+([^\\s]+)': 'DIF:{0}:{1}',\n\n            # Git patterns\n            r'commit\\s+(?:with\\s+message\\s+)?[\"\\'](.+?)[\"\\']': 'CMT:{0}',\n            r'push\\s+(?:to\\s+)?(\\w+)?': 'PSH:{0}',\n\n            # Documentation patterns\n            r'document\\s+([^\\s]+)': 'DOC:{0}',\n            r'explain\\s+([^\\s]+)': 'EXP:{0}',\n        }\n\n    def _build_from_template(self, template: str, groups: Tuple, original_text: str) -> Optional[str]:\n        \"\"\"Build OML string from template and regex groups\"\"\"\n        try:\n            # Replace {0}, {1}, etc. with captured groups\n            oml = template\n\n            for i, group in enumerate(groups):\n                if group:\n                    placeholder = f\"{{{i}}}\"\n                    oml = oml.replace(placeholder, group)\n\n            # Remove any unfilled placeholders\n            oml = re.sub(r':\\{\\d+\\}', '', oml)\n\n            # Clean up double colons\n            oml = re.sub(r':+', ':', oml)\n            oml = oml.rstrip(':')\n\n            return oml if oml else None\n\n        except Exception:\n            return None\n\n    def _extract_verbs(self, text: str) -> List[str]:\n        \"\"\"Extract action verbs from text\"\"\"\n        text_lower = text.lower()\n        verbs = []\n\n        # Common command verbs\n        verb_list = [\n            'read', 'write', 'edit', 'create', 'delete', 'move', 'copy',\n            'summarize', 'analyze', 'search', 'find', 'compare', 'diff',\n            'test', 'run', 'execute', 'validate', 'list', 'show', 'display',\n            'get', 'set', 'update', 'insert', 'query', 'select',\n            'start', 'stop', 'restart', 'build', 'deploy', 'install',\n            'commit', 'push', 'pull', 'merge', 'document', 'explain'\n        ]\n\n        for verb in verb_list:\n            if re.search(r'\\b' + verb + r'\\b', text_lower):\n                verbs.append(verb)\n\n        return verbs\n\n    def _extract_paths(self, text: str) -> List[str]:\n        \"\"\"Extract file paths from text\"\"\"\n        paths = []\n\n        # Pattern 1: paths with extensions\n        matches = re.findall(r'[\\w/.-]+\\.(?:py|js|ts|json|md|txt|yml|yaml|cfg)', text)\n        paths.extend(matches)\n\n        # Pattern 2: directory paths\n        matches = re.findall(r'[\\w/-]+/[\\w/-]+', text)\n        paths.extend([m for m in matches if m not in paths])\n\n        # Pattern 3: quoted paths\n        matches = re.findall(r'[\"\\']([^\"\\']+)[\"\\']', text)\n        for match in matches:\n            if '/' in match or '.' in match:\n                if match not in paths:\n                    paths.append(match)\n\n        return paths\n\n    def _extract_names(self, text: str) -> List[str]:\n        \"\"\"Extract entity names (services, classes, etc.)\"\"\"\n        names = []\n\n        # Pattern: \"called X\" or \"named X\"\n        matches = re.findall(r'\\b(?:called|named)\\s+(\\w+)', text, re.IGNORECASE)\n        names.extend(matches)\n\n        # Pattern: CamelCase names\n        matches = re.findall(r'\\b([A-Z][a-z]+(?:[A-Z][a-z]+)+)\\b', text)\n        names.extend([m for m in matches if m not in names])\n\n        return names\n\n    def _extract_detail_level(self, text: str) -> Optional[str]:\n        \"\"\"Extract detail level from text\"\"\"\n        text_lower = text.lower()\n\n        for pattern, level in self.detail_patterns.items():\n            if re.search(pattern, text_lower):\n                return level\n\n        return None\n\n    def _extract_options(self, text: str) -> Dict[str, str]:\n        \"\"\"Extract key=value options from text\"\"\"\n        options = {}\n\n        # Pattern: key=value or key:value\n        matches = re.findall(r'(\\w+)[:=](\\w+)', text)\n        for key, value in matches:\n            options[key] = value\n\n        return options\n\n    def _compress_oml(self, oml: str) -> str:\n        \"\"\"Apply compression to generated OML\"\"\"\n        # Compress paths\n        for full, abbrev in self.grammar.PATH_MAPPINGS.items():\n            oml = oml.replace(full, abbrev)\n\n        # Compress common words\n        for full, abbrev in self.grammar.ABBREVIATIONS.items():\n            # Only replace whole words\n            oml = re.sub(r'\\b' + full + r'\\b', abbrev, oml, flags=re.IGNORECASE)\n\n        return oml\n\n    def generate_from_ast(self, ast_code: str) -> str:\n        \"\"\"\n        Generate OML from Python AST/code\n\n        Args:\n            ast_code: Python code as string\n\n        Returns:\n            OML representation\n\n        Example:\n            \"def foo(): pass\" → \"fn:foo[]→nil\"\n        \"\"\"\n        import ast\n\n        try:\n            tree = ast.parse(ast_code)\n\n            # Extract functions\n            functions = []\n            classes = []\n\n            for node in ast.walk(tree):\n                if isinstance(node, ast.FunctionDef):\n                    func_name = node.name\n                    params = [arg.arg for arg in node.args.args]\n                    returns = self._get_return_type(node)\n\n                    params_str = ','.join(params) if params else ''\n                    func_oml = f\"fn:{func_name}[{params_str}]\"\n                    if returns:\n                        func_oml += f\"→{returns}\"\n\n                    functions.append(func_oml)\n\n                elif isinstance(node, ast.ClassDef):\n                    classes.append(f\"cls:{node.name}\")\n\n            # Build OML\n            if functions or classes:\n                parts = classes + functions\n                return '{' + '|'.join(parts) + '}'\n\n            return \"\"\n\n        except Exception as e:\n            self.logger.error(f\"AST generation failed: {e}\")\n            return \"\"\n\n    def _get_return_type(self, func_node) -> Optional[str]:\n        \"\"\"Extract return type from function AST node\"\"\"\n        if hasattr(func_node, 'returns') and func_node.returns:\n            if hasattr(func_node.returns, 'id'):\n                return self.grammar.abbreviate(func_node.returns.id)\n\n        return None\n\n    def estimate_compression_ratio(self, english: str, oml: str) -> float:\n        \"\"\"\n        Estimate compression ratio achieved\n\n        Args:\n            english: Original English text\n            oml: Generated OML\n\n        Returns:\n            Compression ratio (0.0 to 1.0, higher = better)\n        \"\"\"\n        english_tokens = len(english) // 4  # Rough estimate\n        oml_tokens = len(oml) // 4\n\n        if english_tokens == 0:\n            return 0.0\n\n        return 1.0 - (oml_tokens / english_tokens)\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00076",
  "language": "python",
  "source_file": "/storage/emulated/0/Download/integrate ideas/Generators/oml_generator.py",
  "source_line": 37,
  "validation_status": "validated"
}