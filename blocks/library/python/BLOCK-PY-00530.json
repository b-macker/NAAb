{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00530_execute() {\n    def get_sources(\n    *,\n    root: Path,\n    src: tuple[str, ...],\n    quiet: bool,\n    verbose: bool,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    report: \"Report\",\n    stdin_filename: str | None,\n) -> set[Path]:\n    \"\"\"Compute the set of files to be formatted.\"\"\"\n    sources: set[Path] = set()\n\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    using_default_exclude = exclude is None\n    exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES) if exclude is None else exclude\n    gitignore: dict[Path, PathSpec] | None = None\n    root_gitignore = get_gitignore(root)\n\n    for s in src:\n        if s == \"-\" and stdin_filename:\n            path = Path(stdin_filename)\n            if path_is_excluded(stdin_filename, force_exclude):\n                report.path_ignored(\n                    path,\n                    \"--stdin-filename matches the --force-exclude regular expression\",\n                )\n                continue\n            is_stdin = True\n        else:\n            path = Path(s)\n            is_stdin = False\n\n        # Compare the logic here to the logic in `gen_python_files`.\n        if is_stdin or path.is_file():\n            if resolves_outside_root_or_cannot_stat(path, root, report):\n                if verbose:\n                    out(f'Skipping invalid source: \"{path}\"', fg=\"red\")\n                continue\n\n            root_relative_path = best_effort_relative_path(path, root).as_posix()\n            root_relative_path = \"/\" + root_relative_path\n\n            # Hard-exclude any files that matches the `--force-exclude` regex.\n            if path_is_excluded(root_relative_path, force_exclude):\n                report.path_ignored(\n                    path, \"matches the --force-exclude regular expression\"\n                )\n                continue\n\n            if is_stdin:\n                path = Path(f\"{STDIN_PLACEHOLDER}{path}\")\n\n            if path.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\n                warn=verbose or not quiet\n            ):\n                continue\n\n            if verbose:\n                out(f'Found input source: \"{path}\"', fg=\"blue\")\n            sources.add(path)\n        elif path.is_dir():\n            path = root / (path.resolve().relative_to(root))\n            if verbose:\n                out(f'Found input source directory: \"{path}\"', fg=\"blue\")\n\n            if using_default_exclude:\n                gitignore = {\n                    root: root_gitignore,\n                    path: get_gitignore(path),\n                }\n            sources.update(\n                gen_python_files(\n                    path.iterdir(),\n                    root,\n                    include,\n                    exclude,\n                    extend_exclude,\n                    force_exclude,\n                    report,\n                    gitignore,\n                    verbose=verbose,\n                    quiet=quiet,\n                )\n            )\n        elif s == \"-\":\n            if verbose:\n                out(\"Found input source stdin\", fg=\"blue\")\n            sources.add(path)\n        else:\n            err(f\"invalid path: {s}\")\n\n    return sources\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00530",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmplabimd09.py",
  "source_line": 733,
  "validation_status": "validated"
}