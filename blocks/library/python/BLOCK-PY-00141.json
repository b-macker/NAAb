{
  "code": "def _generate_express_api(self, request) -> str:\n        \"\"\"Generate production-ready Express.js API\"\"\"\n        return '''\n// Production-Ready Express.js API with Advanced Features\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport compression from 'compression';\nimport { body, validationResult, param } from 'express-validator';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport mongoose from 'mongoose';\nimport winston from 'winston';\nimport { Request, Response, NextFunction } from 'express';\n\n// Types\ninterface User {\n    id: string;\n    email: string;\n    password: string;\n    role: 'admin' | 'user';\n    createdAt: Date;\n    lastLogin?: Date;\n    isActive: boolean;\n}\n\ninterface AuthRequest extends Request {\n    user?: User;\n}\n\ninterface ApiResponse<T = any> {\n    success: boolean;\n    data?: T;\n    message?: string;\n    error?: string;\n    pagination?: {\n        page: number;\n        limit: number;\n        total: number;\n        totalPages: number;\n    };\n}\n\n// Logger configuration\nconst logger = winston.createLogger({\n    level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\n    format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.errors({ stack: true }),\n        winston.format.json()\n    ),\n    transports: [\n        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n        new winston.transports.File({ filename: 'logs/combined.log' }),\n        new winston.transports.Console({\n            format: winston.format.combine(\n                winston.format.colorize(),\n                winston.format.simple()\n            )\n        })\n    ]\n});\n\n// Database connection\nconst connectDB = async () => {\n    try {\n        await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/api', {\n            useNewUrlParser: true,\n            useUnifiedTopology: true,\n        });\n        logger.info('MongoDB connected successfully');\n    } catch (error) {\n        logger.error('Database connection failed:', error);\n        process.exit(1);\n    }\n};\n\n// User Schema\nconst userSchema = new mongoose.Schema({\n    email: { type: String, required: true, unique: true },\n    password: { type: String, required: true },\n    role: { type: String, enum: ['admin', 'user'], default: 'user' },\n    isActive: { type: Boolean, default: true },\n    lastLogin: Date,\n}, {\n    timestamps: true\n});\n\nuserSchema.pre('save', async function(next) {\n    if (!this.isModified('password')) return next();\n    this.password = await bcrypt.hash(this.password, 12);\n    next();\n});\n\nconst UserModel = mongoose.model<User>('User', userSchema);\n\nclass ApiServer {\n    private app: express.Application;\n    private port: number;\n\n    constructor() {\n        this.app = express();\n        this.port = parseInt(process.env.PORT || '3000');\n        this.setupMiddleware();\n        this.setupRoutes();\n        this.setupErrorHandling();\n    }\n\n    private setupMiddleware() {\n        // Security middleware\n        this.app.use(helmet());\n        this.app.use(cors({\n            origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],\n            credentials: true\n        }));\n\n        // Rate limiting\n        const limiter = rateLimit({\n            windowMs: 15 * 60 * 1000, // 15 minutes\n            max: 100, // limit each IP to 100 requests per windowMs\n            message: 'Too many requests from this IP, please try again later.',\n            standardHeaders: true,\n            legacyHeaders: false,\n        });\n        this.app.use('/api/', limiter);\n\n        // Compression and parsing\n        this.app.use(compression());\n        this.app.use(express.json({ limit: '10mb' }));\n        this.app.use(express.urlencoded({ extended: true }));\n\n        // Request logging\n        this.app.use((req: Request, res: Response, next: NextFunction) => {\n            logger.info(`${req.method} ${req.path} - ${req.ip}`);\n            next();\n        });\n    }\n\n    private setupRoutes() {\n        // Health check\n        this.app.get('/health', (req: Request, res: Response) => {\n            res.json({\n                status: 'healthy',\n                timestamp: new Date().toISOString(),\n                uptime: process.uptime(),\n                memory: process.memoryUsage()\n            });\n        });\n\n        // API routes\n        this.app.use('/api/auth', this.authRoutes());\n        this.app.use('/api/users', this.authenticateToken, this.userRoutes());\n        this.app.use('/api/admin', this.authenticateToken, this.requireAdmin, this.adminRoutes());\n\n        // 404 handler\n        this.app.use('*', (req: Request, res: Response) => {\n            res.status(404).json({\n                success: false,\n                error: 'Route not found'\n            });\n        });\n    }\n\n    private authRoutes() {\n        const router = express.Router();\n\n        // Register\n        router.post('/register',\n            [\n                body('email').isEmail().normalizeEmail(),\n                body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)/),\n                body('role').optional().isIn(['admin', 'user'])\n            ],\n            this.handleValidationErrors,\n            async (req: Request, res: Response) => {\n                try {\n                    const { email, password, role = 'user' } = req.body;\n\n                    const existingUser = await UserModel.findOne({ email });\n                    if (existingUser) {\n                        return res.status(409).json({\n                            success: false,\n                            error: 'User already exists'\n                        });\n                    }\n\n                    const user = new UserModel({ email, password, role });\n                    await user.save();\n\n                    const token = this.generateToken(user.id, user.role);\n\n                    logger.info(`New user registered: ${email}`);\n\n                    res.status(201).json({\n                        success: true,\n                        data: {\n                            user: {\n                                id: user.id,\n                                email: user.email,\n                                role: user.role\n                            },\n                            token\n                        }\n                    });\n                } catch (error) {\n                    logger.error('Registration error:', error);\n                    res.status(500).json({\n                        success: false,\n                        error: 'Registration failed'\n                    });\n                }\n            }\n        );\n\n        // Login\n        router.post('/login',\n            [\n                body('email').isEmail().normalizeEmail(),\n                body('password').notEmpty()\n            ],\n            this.handleValidationErrors,\n            async (req: Request, res: Response) => {\n                try {\n                    const { email, password } = req.body;\n\n                    const user = await UserModel.findOne({ email });\n                    if (!user || !user.isActive) {\n                        return res.status(401).json({\n                            success: false,\n                            error: 'Invalid credentials'\n                        });\n                    }\n\n                    const isValidPassword = await bcrypt.compare(password, user.password);\n                    if (!isValidPassword) {\n                        return res.status(401).json({\n                            success: false,\n                            error: 'Invalid credentials'\n                        });\n                    }\n\n                    user.lastLogin = new Date();\n                    await user.save();\n\n                    const token = this.generateToken(user.id, user.role);\n\n                    logger.info(`User logged in: ${email}`);\n\n                    res.json({\n                        success: true,\n                        data: {\n                            user: {\n                                id: user.id,\n                                email: user.email,\n                                role: user.role,\n                                lastLogin: user.lastLogin\n                            },\n                            token\n                        }\n                    });\n                } catch (error) {\n                    logger.error('Login error:', error);\n                    res.status(500).json({\n                        success: false,\n                        error: 'Login failed'\n                    });\n                }\n            }\n        );\n\n        return router;\n    }\n\n    private userRoutes() {\n        const router = express.Router();\n\n        // Get current user profile\n        router.get('/profile', async (req: AuthRequest, res: Response) => {\n            try {\n                const user = await UserModel.findById(req.user!.id).select('-password');\n                res.json({\n                    success: true,\n                    data: { user }\n                });\n            } catch (error) {\n                logger.error('Profile fetch error:', error);\n                res.status(500).json({\n                    success: false,\n                    error: 'Failed to fetch profile'\n                });\n            }\n        });\n\n        // Update user profile\n        router.put('/profile',\n            [\n                body('email').optional().isEmail().normalizeEmail(),\n                body('currentPassword').optional().isLength({ min: 1 }),\n                body('newPassword').optional().isLength({ min: 8 })\n            ],\n            this.handleValidationErrors,\n            async (req: AuthRequest, res: Response) => {\n                try {\n                    const { email, currentPassword, newPassword } = req.body;\n                    const user = await UserModel.findById(req.user!.id);\n\n                    if (!user) {\n                        return res.status(404).json({\n                            success: false,\n                            error: 'User not found'\n                        });\n                    }\n\n                    if (email) {\n                        user.email = email;\n                    }\n\n                    if (newPassword && currentPassword) {\n                        const isValidPassword = await bcrypt.compare(currentPassword, user.password);\n                        if (!isValidPassword) {\n                            return res.status(400).json({\n                                success: false,\n                                error: 'Current password is incorrect'\n                            });\n                        }\n                        user.password = newPassword;\n                    }\n\n                    await user.save();\n\n                    res.json({\n                        success: true,\n                        message: 'Profile updated successfully'\n                    });\n                } catch (error) {\n                    logger.error('Profile update error:', error);\n                    res.status(500).json({\n                        success: false,\n                        error: 'Failed to update profile'\n                    });\n                }\n            }\n        );\n\n        return router;\n    }\n\n    private adminRoutes() {\n        const router = express.Router();\n\n        // Get all users with pagination\n        router.get('/users',\n            async (req: Request, res: Response) => {\n                try {\n                    const page = parseInt(req.query.page as string) || 1;\n                    const limit = parseInt(req.query.limit as string) || 10;\n                    const skip = (page - 1) * limit;\n\n                    const users = await UserModel.find()\n                        .select('-password')\n                        .skip(skip)\n                        .limit(limit)\n                        .sort({ createdAt: -1 });\n\n                    const total = await UserModel.countDocuments();\n                    const totalPages = Math.ceil(total / limit);\n\n                    res.json({\n                        success: true,\n                        data: { users },\n                        pagination: {\n                            page,\n                            limit,\n                            total,\n                            totalPages\n                        }\n                    });\n                } catch (error) {\n                    logger.error('Admin users fetch error:', error);\n                    res.status(500).json({\n                        success: false,\n                        error: 'Failed to fetch users'\n                    });\n                }\n            }\n        );\n\n        // Toggle user status\n        router.patch('/users/:id/status',\n            [param('id').isMongoId()],\n            this.handleValidationErrors,\n            async (req: Request, res: Response) => {\n                try {\n                    const user = await UserModel.findById(req.params.id);\n                    if (!user) {\n                        return res.status(404).json({\n                            success: false,\n                            error: 'User not found'\n                        });\n                    }\n\n                    user.isActive = !user.isActive;\n                    await user.save();\n\n                    logger.info(`User ${user.email} status changed to ${user.isActive ? 'active' : 'inactive'}`);\n\n                    res.json({\n                        success: true,\n                        message: `User ${user.isActive ? 'activated' : 'deactivated'} successfully`\n                    });\n                } catch (error) {\n                    logger.error('User status toggle error:', error);\n                    res.status(500).json({\n                        success: false,\n                        error: 'Failed to update user status'\n                    });\n                }\n            }\n        );\n\n        return router;\n    }\n\n    private setupErrorHandling() {\n        this.app.use((error: Error, req: Request, res: Response, next: NextFunction) => {\n            logger.error('Unhandled error:', error);\n            \n            res.status(500).json({\n                success: false,\n                error: process.env.NODE_ENV === 'production' ? 'Internal server error' : error.message\n            });\n        });\n    }\n\n    private generateToken(userId: string, role: string): string {\n        return jwt.sign(\n            { userId, role },\n            process.env.JWT_SECRET || 'default-secret',\n            { expiresIn: process.env.JWT_EXPIRES_IN || '7d' }\n        );\n    }\n\n    private authenticateToken = async (req: AuthRequest, res: Response, next: NextFunction) => {\n        const authHeader = req.headers.authorization;\n        const token = authHeader && authHeader.split(' ')[1];\n\n        if (!token) {\n            return res.status(401).json({\n                success: false,\n                error: 'Access token required'\n            });\n        }\n\n        try {\n            const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as any;\n            const user = await UserModel.findById(decoded.userId).select('-password');\n            \n            if (!user || !user.isActive) {\n                return res.status(401).json({\n                    success: false,\n                    error: 'Invalid or expired token'\n                });\n            }\n\n            req.user = user;\n            next();\n        } catch (error) {\n            logger.error('Token verification error:', error);\n            res.status(403).json({\n                success: false,\n                error: 'Invalid token'\n            });\n        }\n    };\n\n    private requireAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {\n        if (req.user?.role !== 'admin') {\n            return res.status(403).json({\n                success: false,\n                error: 'Admin access required'\n            });\n        }\n        next();\n    };\n\n    private handleValidationErrors = (req: Request, res: Response, next: NextFunction) => {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({\n                success: false,\n                error: 'Validation failed',\n                details: errors.array()\n            });\n        }\n        next();\n    };\n\n    public async start() {\n        await connectDB();\n        \n        this.app.listen(this.port, () => {\n            logger.info(`Server running on port ${this.port}`);\n            logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);\n        });\n\n        // Graceful shutdown\n        process.on('SIGTERM', () => {\n            logger.info('SIGTERM received. Shutting down gracefully...');\n            process.exit(0);\n        });\n\n        process.on('SIGINT', () => {\n            logger.info('SIGINT received. Shutting down gracefully...');\n            process.exit(0);\n        });\n    }\n}\n\n// Start the server\nif (require.main === module) {\n    const server = new ApiServer();\n    server.start().catch(error => {\n        logger.error('Failed to start server:', error);\n        process.exit(1);\n    });\n}\n\nexport { ApiServer };\n'''",
  "id": "BLOCK-PY-00141",
  "language": "python",
  "source_file": "/storage/emulated/0/Download/integrate ideas/Generators/javascript_generator.py",
  "source_line": 0,
  "validation_status": "validated"
}