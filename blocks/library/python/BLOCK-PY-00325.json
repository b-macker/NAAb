{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00325_execute() {\n    def macro_body(\n        self, node: nodes.Macro | nodes.CallBlock, frame: Frame\n    ) -> tuple[Frame, MacroRef]:\n        \"\"\"Dump the function def of a macro or call block.\"\"\"\n        frame = frame.inner()\n        frame.symbols.analyze_node(node)\n        macro_ref = MacroRef(node)\n\n        explicit_caller = None\n        skip_special_params = set()\n        args = []\n\n        for idx, arg in enumerate(node.args):\n            if arg.name == \"caller\":\n                explicit_caller = idx\n            if arg.name in (\"kwargs\", \"varargs\"):\n                skip_special_params.add(arg.name)\n            args.append(frame.symbols.ref(arg.name))\n\n        undeclared = find_undeclared(node.body, (\"caller\", \"kwargs\", \"varargs\"))\n\n        if \"caller\" in undeclared:\n            # In older Jinja versions there was a bug that allowed caller\n            # to retain the special behavior even if it was mentioned in\n            # the argument list.  However thankfully this was only really\n            # working if it was the last argument.  So we are explicitly\n            # checking this now and error out if it is anywhere else in\n            # the argument list.\n            if explicit_caller is not None:\n                try:\n                    node.defaults[explicit_caller - len(node.args)]\n                except IndexError:\n                    self.fail(\n                        \"When defining macros or call blocks the \"\n                        'special \"caller\" argument must be omitted '\n                        \"or be given a default.\",\n                        node.lineno,\n                    )\n            else:\n                args.append(frame.symbols.declare_parameter(\"caller\"))\n            macro_ref.accesses_caller = True\n        if \"kwargs\" in undeclared and \"kwargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"kwargs\"))\n            macro_ref.accesses_kwargs = True\n        if \"varargs\" in undeclared and \"varargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"varargs\"))\n            macro_ref.accesses_varargs = True\n\n        # macros are delayed, they never require output checks\n        frame.require_output_check = False\n        frame.symbols.analyze_node(node)\n        self.writeline(f\"{self.func('macro')}({', '.join(args)}):\", node)\n        self.indent()\n\n        self.buffer(frame)\n        self.enter_frame(frame)\n\n        self.push_parameter_definitions(frame)\n        for idx, arg in enumerate(node.args):\n            ref = frame.symbols.ref(arg.name)\n            self.writeline(f\"if {ref} is missing:\")\n            self.indent()\n            try:\n                default = node.defaults[idx - len(node.args)]\n            except IndexError:\n                self.writeline(\n                    f'{ref} = undefined(\"parameter {arg.name!r} was not provided\",'\n                    f\" name={arg.name!r})\"\n                )\n            else:\n                self.writeline(f\"{ref} = \")\n                self.visit(default, frame)\n            self.mark_parameter_stored(ref)\n            self.outdent()\n        self.pop_parameter_definitions()\n\n        self.blockvisit(node.body, frame)\n        self.return_buffer_contents(frame, force_unescaped=True)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        return frame, macro_ref\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00325",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmp8pjecjps.py",
  "source_line": 610,
  "validation_status": "validated"
}