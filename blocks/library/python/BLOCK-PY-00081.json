{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00081_execute() {\n    class EnglishGenerator:\n    \"\"\"\n    English Generator\n\n    Generates natural English from OML syntax using templates and grammar expansion.\n\n    Approach:\n    1. Parse OML structure\n    2. Expand abbreviations and paths\n    3. Map to English templates\n    4. Construct fluent sentences\n    5. Format for natural readability\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize English generator\"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.grammar = OMLGrammar()\n        self.parser = OMLParser()\n\n        # Command templates (OML command → English template)\n        self.command_templates = self._build_command_templates()\n\n        # Detail level expansions\n        self.detail_expansions = {\n            'HI': 'high-level overview',\n            'MD': 'medium detail',\n            'DT': 'detailed information',\n            'FL': 'full details',\n            'MN': 'minimal summary',\n            'BR': 'brief summary',\n            'SM': 'summary',\n            'CP': 'complete information',\n        }\n\n    def generate(self, oml_string: str) -> str:\n        \"\"\"\n        Generate English from OML\n\n        Args:\n            oml_string: OML formatted string\n\n        Returns:\n            Natural English text\n\n        Raises:\n            EnglishGenerateError: If generation fails\n\n        Examples:\n            \"RD:file.py\" → \"Read file.py\"\n            \"RD:file.py|SUM:fn:MD\" → \"Read file.py and summarize functions with medium detail\"\n            \"{fn:init,get}\" → \"Functions: init, get\"\n        \"\"\"\n        if not oml_string or not oml_string.strip():\n            raise EnglishGenerateError(\"Empty OML string\")\n\n        oml_string = oml_string.strip()\n\n        try:\n            # Parse OML\n            parsed = self.parser.parse(oml_string)\n\n            # Generate based on type\n            if isinstance(parsed, list):\n                # Pipeline - multiple commands\n                return self._generate_from_pipeline(parsed)\n            elif isinstance(parsed, OMLCommand):\n                # Single command\n                return self._generate_from_command(parsed)\n            elif isinstance(parsed, OMLObject):\n                # Object\n                return self._generate_from_object(parsed)\n            elif isinstance(parsed, OMLArray):\n                # Array\n                return self._generate_from_array(parsed)\n            else:\n                raise EnglishGenerateError(f\"Unknown parsed type: {type(parsed)}\")\n\n        except OMLParseError as e:\n            raise EnglishGenerateError(f\"Failed to parse OML: {e}\")\n        except Exception as e:\n            self.logger.error(f\"English generation failed: {e}\")\n            raise EnglishGenerateError(f\"Generation failed: {e}\")\n\n    def _generate_from_command(self, cmd: OMLCommand) -> str:\n        \"\"\"\n        Generate English from single OML command\n\n        Examples:\n            OMLCommand(command='RD', params=['file.py']) → \"Read file.py\"\n            OMLCommand(command='SUM', params=['fn'], options={'detail': 'MD'}) → \"Summarize functions with medium detail\"\n        \"\"\"\n        # Get English verb for command\n        verb = self._get_command_verb(cmd.command)\n\n        if not verb:\n            raise EnglishGenerateError(f\"Unknown command: {cmd.command}\")\n\n        # Build sentence parts\n        parts = [verb]\n\n        # Expand parameters\n        if cmd.params:\n            expanded_params = []\n            for param in cmd.params:\n                expanded = self._expand_parameter(param)\n                expanded_params.append(expanded)\n\n            parts.extend(expanded_params)\n\n        # Add options\n        if cmd.options:\n            option_text = self._expand_options(cmd.options, cmd.command)\n            if option_text:\n                parts.append(option_text)\n\n        # Join into sentence\n        sentence = ' '.join(parts)\n\n        # Capitalize first letter\n        sentence = sentence[0].upper() + sentence[1:] if sentence else sentence\n\n        return sentence\n\n    def _generate_from_pipeline(self, commands: List[OMLCommand]) -> str:\n        \"\"\"\n        Generate English from command pipeline\n\n        Example:\n            [OMLCommand('RD', ['file.py']), OMLCommand('SUM', ['fn'])]\n            → \"Read file.py and summarize functions\"\n        \"\"\"\n        if not commands:\n            return \"\"\n\n        if len(commands) == 1:\n            return self._generate_from_command(commands[0])\n\n        # Generate each command\n        command_texts = []\n        for cmd in commands:\n            text = self._generate_from_command(cmd)\n            # Lowercase all but the first\n            if command_texts:\n                text = text[0].lower() + text[1:] if text else text\n            command_texts.append(text)\n\n        # Join with \"and\" or commas\n        if len(command_texts) == 2:\n            return f\"{command_texts[0]} and {command_texts[1]}\"\n        else:\n            # Oxford comma for 3+\n            return ', '.join(command_texts[:-1]) + f\", and {command_texts[-1]}\"\n\n    def _generate_from_object(self, obj: OMLObject) -> str:\n        \"\"\"\n        Generate English from OML object\n\n        Example:\n            OMLObject(data={'fn': ['init', 'get'], 'dep': ['db', 'evb']})\n            → \"Functions: init, get. Dependencies: database, event_bus\"\n        \"\"\"\n        parts = []\n\n        for key, value in obj.data.items():\n            # Expand key\n            key_expanded = self._expand_abbreviation(key)\n\n            # Format value\n            if isinstance(value, list):\n                # Expand each item\n                value_items = [self._expand_abbreviation(item) for item in value]\n                value_text = ', '.join(value_items)\n            elif isinstance(value, dict):\n                # Nested object\n                nested_obj = OMLObject(data=value, raw=\"\")\n                value_text = self._generate_from_object(nested_obj)\n            else:\n                value_text = self._expand_abbreviation(str(value))\n\n            parts.append(f\"{key_expanded.capitalize()}: {value_text}\")\n\n        return '. '.join(parts)\n\n    def _generate_from_array(self, arr: OMLArray) -> str:\n        \"\"\"\n        Generate English from OML array\n\n        Example:\n            OMLArray(items=['item1', 'item2', 'item3']) → \"item1, item2, item3\"\n        \"\"\"\n        expanded_items = []\n\n        for item in arr.items:\n            if isinstance(item, dict):\n                # Nested object\n                nested_obj = OMLObject(data=item, raw=\"\")\n                expanded_items.append(self._generate_from_object(nested_obj))\n            elif isinstance(item, list):\n                # Nested array\n                nested_arr = OMLArray(items=item, raw=\"\")\n                expanded_items.append(self._generate_from_array(nested_arr))\n            else:\n                expanded_items.append(self._expand_abbreviation(str(item)))\n\n        return ', '.join(expanded_items)\n\n    def _get_command_verb(self, command: str) -> Optional[str]:\n        \"\"\"Get English verb for OML command\"\"\"\n        # Reverse lookup in grammar\n        for english, oml in self.grammar.COMMANDS.items():\n            if oml == command:\n                return english\n\n        return None\n\n    def _expand_parameter(self, param: str) -> str:\n        \"\"\"\n        Expand OML parameter to English\n\n        Handles:\n        - Path expansion: svc/ctx/ctx_svc.py → services/context/context_service.py\n        - Abbreviation expansion: fn → function, cls → class\n        - Wildcards: * → all\n        \"\"\"\n        # Check if it's a path\n        if '/' in param or '.' in param:\n            # Expand path\n            expanded = self.grammar.expand_path(param)\n            return expanded\n\n        # Check if it's an abbreviation\n        expanded = self._expand_abbreviation(param)\n        return expanded\n\n    def _expand_abbreviation(self, abbrev: str) -> str:\n        \"\"\"Expand abbreviation to full word\"\"\"\n        # Check in abbreviations\n        for full, short in self.grammar.ABBREVIATIONS.items():\n            if short == abbrev.lower():\n                return full\n\n        # Check in file suffixes\n        for full, short in self.grammar.FILE_SUFFIXES.items():\n            if abbrev.endswith(short):\n                return abbrev.replace(short, full)\n\n        # No match - return as-is\n        return abbrev\n\n    def _expand_options(self, options: Dict[str, str], command: str) -> str:\n        \"\"\"\n        Expand command options to English\n\n        Example:\n            {'detail': 'MD'} → \"with medium detail\"\n        \"\"\"\n        parts = []\n\n        for key, value in options.items():\n            if key == 'detail':\n                # Detail level\n                detail_text = self.detail_expansions.get(value.upper(), value)\n                parts.append(f\"with {detail_text}\")\n            else:\n                # Generic key=value\n                parts.append(f\"{key}={value}\")\n\n        return ' '.join(parts)\n\n    def _build_command_templates(self) -> Dict[str, str]:\n        \"\"\"\n        Build English templates for common OML commands\n\n        Returns dict of {command: template}\n        \"\"\"\n        return {\n            'RD': 'read {0}',\n            'WR': 'write {0}',\n            'ED': 'edit {0}',\n            'DEL': 'delete {0}',\n            'MV': 'move {0}',\n            'CP': 'copy {0}',\n            'RN': 'rename {0}',\n            'CR': 'create {0}',\n            'SUM': 'summarize {0}',\n            'ANZ': 'analyze {0}',\n            'SRC': 'search for {0}',\n            'FND': 'find {0}',\n            'GRP': 'grep for {0}',\n            'CMP': 'compare {0}',\n            'DIF': 'show differences in {0}',\n            'RVW': 'review {0}',\n            'RFT': 'refactor {0}',\n            'OPT': 'optimize {0}',\n            'FIX': 'fix {0}',\n            'DBG': 'debug {0}',\n            'TST': 'test {0}',\n            'RUN': 'run {0}',\n            'EXE': 'execute {0}',\n            'VLD': 'validate {0}',\n            'LST': 'list {0}',\n            'SHW': 'show {0}',\n            'PRT': 'print {0}',\n            'DSP': 'display {0}',\n            'GET': 'get {0}',\n            'SET': 'set {0}',\n            'UPD': 'update {0}',\n            'INS': 'insert {0}',\n            'QRY': 'query {0}',\n            'SEL': 'select {0}',\n            'FLT': 'filter {0}',\n            'STR': 'start {0}',\n            'STP': 'stop {0}',\n            'RST': 'restart {0}',\n            'STS': 'show status of {0}',\n            'CMT': 'commit {0}',\n            'PSH': 'push {0}',\n            'PLL': 'pull {0}',\n            'MRG': 'merge {0}',\n            'BRH': 'branch {0}',\n            'CHK': 'checkout {0}',\n            'RBS': 'rebase {0}',\n            'DOC': 'document {0}',\n            'EXP': 'explain {0}',\n            'DSC': 'describe {0}',\n            'HLP': 'help with {0}',\n            'INF': 'get info about {0}',\n            'CFG': 'configure {0}',\n            'BLD': 'build {0}',\n            'DPL': 'deploy {0}',\n            'GEN': 'generate {0}',\n        }\n\n    def generate_readable_summary(self, oml_string: str) -> str:\n        \"\"\"\n        Generate human-readable summary from OML\n\n        More verbose than generate() - adds context and explanation.\n\n        Args:\n            oml_string: OML string\n\n        Returns:\n            Verbose English description\n        \"\"\"\n        try:\n            # Get basic English\n            basic = self.generate(oml_string)\n\n            # Parse to add context\n            parsed = self.parser.parse(oml_string)\n\n            if isinstance(parsed, list) and len(parsed) > 2:\n                # Multi-step pipeline\n                return f\"This is a multi-step operation: {basic}\"\n            elif isinstance(parsed, OMLObject):\n                # Object description\n                return f\"Object specification: {basic}\"\n            elif isinstance(parsed, OMLArray):\n                # Array description\n                return f\"List of items: {basic}\"\n            else:\n                return basic\n\n        except Exception as e:\n            self.logger.warning(f\"Failed to generate readable summary: {e}\")\n            return self.generate(oml_string)\n\n    def estimate_expansion_ratio(self, oml: str, english: str) -> float:\n        \"\"\"\n        Estimate expansion ratio achieved\n\n        Args:\n            oml: OML string\n            english: Generated English\n\n        Returns:\n            Expansion ratio (1.0+, higher = more expansion)\n        \"\"\"\n        oml_tokens = len(oml) // 4  # Rough estimate\n        english_tokens = len(english) // 4\n\n        if oml_tokens == 0:\n            return 1.0\n\n        return english_tokens / oml_tokens\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00081",
  "language": "python",
  "source_file": "/storage/emulated/0/Download/integrate ideas/Generators/english_generator.py",
  "source_line": 36,
  "validation_status": "validated"
}