{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00540_execute() {\n    def format_str(\n    src_contents: str, *, mode: Mode, lines: Collection[tuple[int, int]] = ()\n) -> str:\n    \"\"\"Reformat a string and return new contents.\n\n    `mode` determines formatting options, such as how many characters per line are\n    allowed.  Example:\n\n    >>> import black\n    >>> print(black.format_str(\"def f(arg:str='')->None:...\", mode=black.Mode()))\n    def f(arg: str = \"\") -> None:\n        ...\n\n    A more complex example:\n\n    >>> print(\n    ...   black.format_str(\n    ...     \"def f(arg:str='')->None: hey\",\n    ...     mode=black.Mode(\n    ...       target_versions={black.TargetVersion.PY36},\n    ...       line_length=10,\n    ...       string_normalization=False,\n    ...       is_pyi=False,\n    ...     ),\n    ...   ),\n    ... )\n    def f(\n        arg: str = '',\n    ) -> None:\n        hey\n\n    \"\"\"\n    if lines:\n        lines = sanitized_lines(lines, src_contents)\n        if not lines:\n            return src_contents  # Nothing to format\n    dst_contents = _format_str_once(src_contents, mode=mode, lines=lines)\n    # Forced second pass to work around optional trailing commas (becoming\n    # forced trailing commas on pass 2) interacting differently with optional\n    # parentheses.  Admittedly ugly.\n    if src_contents != dst_contents:\n        if lines:\n            lines = adjusted_lines(lines, src_contents, dst_contents)\n        return _format_str_once(dst_contents, mode=mode, lines=lines)\n    return dst_contents\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00540",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmplabimd09.py",
  "source_line": 1177,
  "validation_status": "validated"
}