{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00341_execute() {\n    def visit_Template(self, node: nodes.Template, frame: Frame | None = None) -> None:\n        assert frame is None, \"no root frame allowed\"\n        eval_ctx = EvalContext(self.environment, self.name)\n\n        from .runtime import async_exported\n        from .runtime import exported\n\n        if self.environment.is_async:\n            exported_names = sorted(exported + async_exported)\n        else:\n            exported_names = sorted(exported)\n\n        self.writeline(\"from jinja2.runtime import \" + \", \".join(exported_names))\n\n        # if we want a deferred initialization we cannot move the\n        # environment into a local name\n        envenv = \"\" if self.defer_init else \", environment=environment\"\n\n        # do we have an extends tag at all?  If not, we can save some\n        # overhead by just not processing any inheritance code.\n        have_extends = node.find(nodes.Extends) is not None\n\n        # find all blocks\n        for block in node.find_all(nodes.Block):\n            if block.name in self.blocks:\n                self.fail(f\"block {block.name!r} defined twice\", block.lineno)\n            self.blocks[block.name] = block\n\n        # find all imports and import them\n        for import_ in node.find_all(nodes.ImportedName):\n            if import_.importname not in self.import_aliases:\n                imp = import_.importname\n                self.import_aliases[imp] = alias = self.temporary_identifier()\n                if \".\" in imp:\n                    module, obj = imp.rsplit(\".\", 1)\n                    self.writeline(f\"from {module} import {obj} as {alias}\")\n                else:\n                    self.writeline(f\"import {imp} as {alias}\")\n\n        # add the load name\n        self.writeline(f\"name = {self.name!r}\")\n\n        # generate the root render function.\n        self.writeline(\n            f\"{self.func('root')}(context, missing=missing{envenv}):\", extra=1\n        )\n        self.indent()\n        self.write_commons()\n\n        # process the root\n        frame = Frame(eval_ctx)\n        if \"self\" in find_undeclared(node.body, (\"self\",)):\n            ref = frame.symbols.declare_parameter(\"self\")\n            self.writeline(f\"{ref} = TemplateReference(context)\")\n        frame.symbols.analyze_node(node)\n        frame.toplevel = frame.rootlevel = True\n        frame.require_output_check = have_extends and not self.has_known_extends\n        if have_extends:\n            self.writeline(\"parent_template = None\")\n        self.enter_frame(frame)\n        self.pull_dependencies(node.body)\n        self.blockvisit(node.body, frame)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        # make sure that the parent root is called.\n        if have_extends:\n            if not self.has_known_extends:\n                self.indent()\n                self.writeline(\"if parent_template is not None:\")\n            self.indent()\n            if not self.environment.is_async:\n                self.writeline(\"yield from parent_template.root_render_func(context)\")\n            else:\n                self.writeline(\"agen = parent_template.root_render_func(context)\")\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(\"async for event in agen:\")\n                self.indent()\n                self.writeline(\"yield event\")\n                self.outdent()\n                self.outdent()\n                self.writeline(\"finally: await agen.aclose()\")\n            self.outdent(1 + (not self.has_known_extends))\n\n        # at this point we now have the blocks collected and can visit them too.\n        for name, block in self.blocks.items():\n            self.writeline(\n                f\"{self.func('block_' + name)}(context, missing=missing{envenv}):\",\n                block,\n                1,\n            )\n            self.indent()\n            self.write_commons()\n            # It's important that we do not make this frame a child of the\n            # toplevel template.  This would cause a variety of\n            # interesting issues with identifier tracking.\n            block_frame = Frame(eval_ctx)\n            block_frame.block_frame = True\n            undeclared = find_undeclared(block.body, (\"self\", \"super\"))\n            if \"self\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"self\")\n                self.writeline(f\"{ref} = TemplateReference(context)\")\n            if \"super\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"super\")\n                self.writeline(f\"{ref} = context.super({name!r}, block_{name})\")\n            block_frame.symbols.analyze_node(block)\n            block_frame.block = name\n            self.writeline(\"_block_vars = {}\")\n            self.enter_frame(block_frame)\n            self.pull_dependencies(block.body)\n            self.blockvisit(block.body, block_frame)\n            self.leave_frame(block_frame, with_python_scope=True)\n            self.outdent()\n\n        blocks_kv_str = \", \".join(f\"{x!r}: block_{x}\" for x in self.blocks)\n        self.writeline(f\"blocks = {{{blocks_kv_str}}}\", extra=1)\n        debug_kv_str = \"&\".join(f\"{k}={v}\" for k, v in self.debug_info)\n        self.writeline(f\"debug_info = {debug_kv_str!r}\")\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00341",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmp8pjecjps.py",
  "source_line": 825,
  "validation_status": "validated"
}