{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00541_execute() {\n    def _format_str_once(\n    src_contents: str, *, mode: Mode, lines: Collection[tuple[int, int]] = ()\n) -> str:\n    if Preview.normalize_cr_newlines in mode:\n        normalized_contents, _, newline_type = decode_bytes(\n            src_contents.encode(\"utf-8\"), mode\n        )\n\n        src_node = lib2to3_parse(\n            normalized_contents.lstrip(), target_versions=mode.target_versions\n        )\n    else:\n        src_node = lib2to3_parse(src_contents.lstrip(), mode.target_versions)\n\n    dst_blocks: list[LinesBlock] = []\n    if mode.target_versions:\n        versions = mode.target_versions\n    else:\n        future_imports = get_future_imports(src_node)\n        versions = detect_target_versions(src_node, future_imports=future_imports)\n\n    line_generation_features = {\n        feature\n        for feature in {\n            Feature.PARENTHESIZED_CONTEXT_MANAGERS,\n            Feature.UNPARENTHESIZED_EXCEPT_TYPES,\n            Feature.T_STRINGS,\n        }\n        if supports_feature(versions, feature)\n    }\n    normalize_fmt_off(src_node, mode, lines)\n    if lines:\n        # This should be called after normalize_fmt_off.\n        convert_unchanged_lines(src_node, lines)\n\n    line_generator = LineGenerator(mode=mode, features=line_generation_features)\n    elt = EmptyLineTracker(mode=mode)\n    split_line_features = {\n        feature\n        for feature in {\n            Feature.TRAILING_COMMA_IN_CALL,\n            Feature.TRAILING_COMMA_IN_DEF,\n        }\n        if supports_feature(versions, feature)\n    }\n    block: LinesBlock | None = None\n    for current_line in line_generator.visit(src_node):\n        block = elt.maybe_empty_lines(current_line)\n        dst_blocks.append(block)\n        for line in transform_line(\n            current_line, mode=mode, features=split_line_features\n        ):\n            block.content_lines.append(str(line))\n    if dst_blocks:\n        dst_blocks[-1].after = 0\n    dst_contents = []\n    for block in dst_blocks:\n        dst_contents.extend(block.all_lines())\n    if not dst_contents:\n        if Preview.normalize_cr_newlines in mode:\n            if \"\\n\" in normalized_contents:\n                return newline_type\n        else:\n            # Use decode_bytes to retrieve the correct source newline (CRLF or LF),\n            # and check if normalized_content has more than one line\n            normalized_content, _, newline = decode_bytes(\n                src_contents.encode(\"utf-8\"), mode\n            )\n            if \"\\n\" in normalized_content:\n                return newline\n        return \"\"\n    if Preview.normalize_cr_newlines in mode:\n        return \"\".join(dst_contents).replace(\"\\n\", newline_type)\n    else:\n        return \"\".join(dst_contents)\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00541",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmplabimd09.py",
  "source_line": 1224,
  "validation_status": "validated"
}