{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00348_execute() {\n    def visit_For(self, node: nodes.For, frame: Frame) -> None:\n        loop_frame = frame.inner()\n        loop_frame.loop_frame = True\n        test_frame = frame.inner()\n        else_frame = frame.inner()\n\n        # try to figure out if we have an extended loop.  An extended loop\n        # is necessary if the loop is in recursive mode if the special loop\n        # variable is accessed in the body if the body is a scoped block.\n        extended_loop = (\n            node.recursive\n            or \"loop\"\n            in find_undeclared(node.iter_child_nodes(only=(\"body\",)), (\"loop\",))\n            or any(block.scoped for block in node.find_all(nodes.Block))\n        )\n\n        loop_ref = None\n        if extended_loop:\n            loop_ref = loop_frame.symbols.declare_parameter(\"loop\")\n\n        loop_frame.symbols.analyze_node(node, for_branch=\"body\")\n        if node.else_:\n            else_frame.symbols.analyze_node(node, for_branch=\"else\")\n\n        if node.test:\n            loop_filter_func = self.temporary_identifier()\n            test_frame.symbols.analyze_node(node, for_branch=\"test\")\n            self.writeline(f\"{self.func(loop_filter_func)}(fiter):\", node.test)\n            self.indent()\n            self.enter_frame(test_frame)\n            self.writeline(self.choose_async(\"async for \", \"for \"))\n            self.visit(node.target, loop_frame)\n            self.write(\" in \")\n            self.write(self.choose_async(\"auto_aiter(fiter)\", \"fiter\"))\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"if \", node.test)\n            self.visit(node.test, test_frame)\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"yield \")\n            self.visit(node.target, loop_frame)\n            self.outdent(3)\n            self.leave_frame(test_frame, with_python_scope=True)\n\n        # if we don't have an recursive loop we have to find the shadowed\n        # variables at that point.  Because loops can be nested but the loop\n        # variable is a special one we have to enforce aliasing for it.\n        if node.recursive:\n            self.writeline(\n                f\"{self.func('loop')}(reciter, loop_render_func, depth=0):\", node\n            )\n            self.indent()\n            self.buffer(loop_frame)\n\n            # Use the same buffer for the else frame\n            else_frame.buffer = loop_frame.buffer\n\n        # make sure the loop variable is a special one and raise a template\n        # assertion error if a loop tries to write to loop\n        if extended_loop:\n            self.writeline(f\"{loop_ref} = missing\")\n\n        for name in node.find_all(nodes.Name):\n            if name.ctx == \"store\" and name.name == \"loop\":\n                self.fail(\n                    \"Can't assign to special loop variable in for-loop target\",\n                    name.lineno,\n                )\n\n        if node.else_:\n            iteration_indicator = self.temporary_identifier()\n            self.writeline(f\"{iteration_indicator} = 1\")\n\n        self.writeline(self.choose_async(\"async for \", \"for \"), node)\n        self.visit(node.target, loop_frame)\n        if extended_loop:\n            self.write(f\", {loop_ref} in {self.choose_async('Async')}LoopContext(\")\n        else:\n            self.write(\" in \")\n\n        if node.test:\n            self.write(f\"{loop_filter_func}(\")\n        if node.recursive:\n            self.write(\"reciter\")\n        else:\n            if self.environment.is_async and not extended_loop:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async and not extended_loop:\n                self.write(\")\")\n        if node.test:\n            self.write(\")\")\n\n        if node.recursive:\n            self.write(\", undefined, loop_render_func, depth):\")\n        else:\n            self.write(\", undefined):\" if extended_loop else \":\")\n\n        self.indent()\n        self.enter_frame(loop_frame)\n\n        self.writeline(\"_loop_vars = {}\")\n        self.blockvisit(node.body, loop_frame)\n        if node.else_:\n            self.writeline(f\"{iteration_indicator} = 0\")\n        self.outdent()\n        self.leave_frame(\n            loop_frame, with_python_scope=node.recursive and not node.else_\n        )\n\n        if node.else_:\n            self.writeline(f\"if {iteration_indicator}:\")\n            self.indent()\n            self.enter_frame(else_frame)\n            self.blockvisit(node.else_, else_frame)\n            self.leave_frame(else_frame)\n            self.outdent()\n\n        # if the node was recursive we have to return the buffer contents\n        # and start the iteration code\n        if node.recursive:\n            self.return_buffer_contents(loop_frame)\n            self.outdent()\n            self.start_write(frame, node)\n            self.write(f\"{self.choose_async('await ')}loop(\")\n            if self.environment.is_async:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async:\n                self.write(\")\")\n            self.write(\", loop)\")\n            self.end_write(frame)\n\n        # at the end of the iteration, clear any assignments made in the\n        # loop from the top level\n        if self._assign_stack:\n            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00348",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmp8pjecjps.py",
  "source_line": 1175,
  "validation_status": "validated"
}