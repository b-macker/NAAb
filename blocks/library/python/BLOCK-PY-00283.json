{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00283_execute() {\n    class Frame:\n    \"\"\"Holds compile time information for us.\"\"\"\n\n    def __init__(\n        self,\n        eval_ctx: EvalContext,\n        parent: t.Optional[\"Frame\"] = None,\n        level: int | None = None,\n    ) -> None:\n        self.eval_ctx = eval_ctx\n\n        # the parent of this frame\n        self.parent = parent\n\n        if parent is None:\n            self.symbols = Symbols(level=level)\n\n            # in some dynamic inheritance situations the compiler needs to add\n            # write tests around output statements.\n            self.require_output_check = False\n\n            # inside some tags we are using a buffer rather than yield statements.\n            # this for example affects {% filter %} or {% macro %}.  If a frame\n            # is buffered this variable points to the name of the list used as\n            # buffer.\n            self.buffer: str | None = None\n\n            # the name of the block we're in, otherwise None.\n            self.block: str | None = None\n\n        else:\n            self.symbols = Symbols(parent.symbols, level=level)\n            self.require_output_check = parent.require_output_check\n            self.buffer = parent.buffer\n            self.block = parent.block\n\n        # a toplevel frame is the root + soft frames such as if conditions.\n        self.toplevel = False\n\n        # the root frame is basically just the outermost frame, so no if\n        # conditions.  This information is used to optimize inheritance\n        # situations.\n        self.rootlevel = False\n\n        # variables set inside of loops and blocks should not affect outer frames,\n        # but they still needs to be kept track of as part of the active context.\n        self.loop_frame = False\n        self.block_frame = False\n\n        # track whether the frame is being used in an if-statement or conditional\n        # expression as it determines which errors should be raised during runtime\n        # or compile time.\n        self.soft_frame = False\n\n    def copy(self) -> \"te.Self\":\n        \"\"\"Create a copy of the current one.\"\"\"\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.symbols = self.symbols.copy()\n        return rv\n\n    def inner(self, isolated: bool = False) -> \"Frame\":\n        \"\"\"Return an inner frame.\"\"\"\n        if isolated:\n            return Frame(self.eval_ctx, level=self.symbols.level + 1)\n        return Frame(self.eval_ctx, self)\n\n    def soft(self) -> \"te.Self\":\n        \"\"\"Return a soft frame.  A soft frame may not be modified as\n        standalone thing as it shares the resources with the frame it\n        was created of, but it's not a rootlevel frame any longer.\n\n        This is only used to implement if-statements and conditional\n        expressions.\n        \"\"\"\n        rv = self.copy()\n        rv.rootlevel = False\n        rv.soft_frame = True\n        return rv\n\n    __copy__ = copy\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00283",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmp8pjecjps.py",
  "source_line": 163,
  "validation_status": "validated"
}