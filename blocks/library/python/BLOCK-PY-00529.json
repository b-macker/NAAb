{
  "code": "extern \"C\" {\n\nvoid BLOCK-PY-00529_execute() {\n    def main(\n    ctx: click.Context,\n    code: str | None,\n    line_length: int,\n    target_version: list[TargetVersion],\n    check: bool,\n    diff: bool,\n    line_ranges: Sequence[str],\n    color: bool,\n    fast: bool,\n    pyi: bool,\n    ipynb: bool,\n    python_cell_magics: Sequence[str],\n    skip_source_first_line: bool,\n    skip_string_normalization: bool,\n    skip_magic_trailing_comma: bool,\n    preview: bool,\n    unstable: bool,\n    enable_unstable_feature: list[Preview],\n    quiet: bool,\n    verbose: bool,\n    required_version: str | None,\n    include: Pattern[str],\n    exclude: Pattern[str] | None,\n    extend_exclude: Pattern[str] | None,\n    force_exclude: Pattern[str] | None,\n    stdin_filename: str | None,\n    workers: int | None,\n    src: tuple[str, ...],\n    config: str | None,\n    no_cache: bool,\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    ctx.ensure_object(dict)\n\n    assert sys.version_info >= (3, 10), \"Black requires Python 3.10+\"\n    if sys.version_info[:3] == (3, 12, 5):\n        out(\n            \"Python 3.12.5 has a memory safety issue that can cause Black's \"\n            \"AST safety checks to fail. \"\n            \"Please upgrade to Python 3.12.6 or downgrade to Python 3.12.4\"\n        )\n        ctx.exit(1)\n\n    if src and code is not None:\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'SRC' and 'code' cannot be passed simultaneously.\"\n        )\n        ctx.exit(1)\n    if not src and code is None:\n        out(main.get_usage(ctx) + \"\\n\\nOne of 'SRC' or 'code' is required.\")\n        ctx.exit(1)\n\n    # It doesn't do anything if --unstable is also passed, so just allow it.\n    if enable_unstable_feature and not (preview or unstable):\n        out(\n            main.get_usage(ctx)\n            + \"\\n\\n'--enable-unstable-feature' requires '--preview'.\"\n        )\n        ctx.exit(1)\n\n    root, method = (\n        find_project_root(src, stdin_filename) if code is None else (None, None)\n    )\n    ctx.obj[\"root\"] = root\n\n    if verbose:\n        if root:\n            out(\n                f\"Identified `{root}` as project root containing a {method}.\",\n                fg=\"blue\",\n            )\n\n        if config:\n            config_source = ctx.get_parameter_source(\"config\")\n            user_level_config = str(find_user_pyproject_toml())\n            if config == user_level_config:\n                out(\n                    \"Using configuration from user-level config at \"\n                    f\"'{user_level_config}'.\",\n                    fg=\"blue\",\n                )\n            elif config_source in (\n                ParameterSource.DEFAULT,\n                ParameterSource.DEFAULT_MAP,\n            ):\n                out(\"Using configuration from project root.\", fg=\"blue\")\n            else:\n                out(f\"Using configuration in '{config}'.\", fg=\"blue\")\n            if ctx.default_map:\n                for param, value in ctx.default_map.items():\n                    out(f\"{param}: {value}\")\n\n    error_msg = \"Oh no! üí• üíî üí•\"\n    if (\n        required_version\n        and required_version != __version__\n        and required_version != __version__.split(\".\")[0]\n    ):\n        err(\n            f\"{error_msg} The required version `{required_version}` does not match\"\n            f\" the running version `{__version__}`!\"\n        )\n        ctx.exit(1)\n    if ipynb and pyi:\n        err(\"Cannot pass both `pyi` and `ipynb` flags!\")\n        ctx.exit(1)\n\n    write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)\n    if target_version:\n        versions = set(target_version)\n    else:\n        # We'll autodetect later.\n        versions = set()\n    mode = Mode(\n        target_versions=versions,\n        line_length=line_length,\n        is_pyi=pyi,\n        is_ipynb=ipynb,\n        skip_source_first_line=skip_source_first_line,\n        string_normalization=not skip_string_normalization,\n        magic_trailing_comma=not skip_magic_trailing_comma,\n        preview=preview,\n        unstable=unstable,\n        python_cell_magics=set(python_cell_magics),\n        enabled_features=set(enable_unstable_feature),\n    )\n\n    lines: list[tuple[int, int]] = []\n    if line_ranges:\n        if ipynb:\n            err(\"Cannot use --line-ranges with ipynb files.\")\n            ctx.exit(1)\n\n        try:\n            lines = parse_line_ranges(line_ranges)\n        except ValueError as e:\n            err(str(e))\n            ctx.exit(1)\n\n    if code is not None:\n        # Run in quiet mode by default with -c; the extra output isn't useful.\n        # You can still pass -v to get verbose output.\n        quiet = True\n\n    report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)\n\n    if code is not None:\n        reformat_code(\n            content=code,\n            fast=fast,\n            write_back=write_back,\n            mode=mode,\n            report=report,\n            lines=lines,\n        )\n    else:\n        assert root is not None  # root is only None if code is not None\n        try:\n            sources = get_sources(\n                root=root,\n                src=src,\n                quiet=quiet,\n                verbose=verbose,\n                include=include,\n                exclude=exclude,\n                extend_exclude=extend_exclude,\n                force_exclude=force_exclude,\n                report=report,\n                stdin_filename=stdin_filename,\n            )\n        except GitWildMatchPatternError:\n            ctx.exit(1)\n\n        if not sources:\n            if verbose or not quiet:\n                out(\"No Python files are present to be formatted. Nothing to do üò¥\")\n            if \"-\" in src:\n                sys.stdout.write(sys.stdin.read())\n            ctx.exit(0)\n\n        if len(sources) == 1:\n            reformat_one(\n                src=sources.pop(),\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                lines=lines,\n                no_cache=no_cache,\n            )\n        else:\n            from black.concurrency import reformat_many\n\n            if lines:\n                err(\"Cannot use --line-ranges to format multiple files.\")\n                ctx.exit(1)\n            reformat_many(\n                sources=sources,\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                workers=workers,\n                no_cache=no_cache,\n            )\n\n    if verbose or not quiet:\n        if code is None and (verbose or report.change_count or report.failure_count):\n            out()\n        out(error_msg if report.return_code else \"All done! ‚ú® üç∞ ‚ú®\")\n        if code is None:\n            click.echo(str(report), err=True)\n    ctx.exit(report.return_code)\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-PY-00529",
  "language": "python",
  "source_file": "/data/data/com.termux/files/usr/tmp/tmplabimd09.py",
  "source_line": 516,
  "validation_status": "validated"
}