{
  "id": "BLOCK-KT-00002",
  "version": "1.0",
  "name": "ktor_rest_routes",
  "language": "kotlin",
  "category": "web_framework",
  "subcategory": null,
  "code": "import io.ktor.server.routing.*\nimport io.ktor.server.response.*\nimport io.ktor.server.request.*\nimport io.ktor.http.*\nimport io.ktor.server.auth.*\nimport io.ktor.server.auth.jwt.*\nimport org.jetbrains.exposed.sql.transactions.transaction\nimport kotlinx.serialization.Serializable\nimport redis.clients.jedis.JedisPool\nimport kotlinx.serialization.json.Json\nimport java.util.UUID\n\nfun Route.productRoutes(redisPool: JedisPool) {\n    route(\"/products\") {\n        // GET /api/products\n        get {\n            val page = call.request.queryParameters[\"page\"]?.toIntOrNull() ?: 1\n            val pageSize = call.request.queryParameters[\"pageSize\"]?.toIntOrNull() ?: 20\n\n            val cacheKey = \"products_page_${page}_size_$pageSize\"\n\n            // Try cache first\n            redisPool.resource.use { jedis ->\n                val cached = jedis.get(cacheKey)\n                if (cached != null) {\n                    val products = Json.decodeFromString<List<ProductDTO>>(cached)\n                    return@get call.respond(products)\n                }\n            }\n\n            // Query database\n            val products = transaction {\n                Product.all()\n                    .limit(pageSize, offset = ((page - 1) * pageSize).toLong())\n                    .map { it.toDTO() }\n            }\n\n            // Cache for 5 minutes\n            redisPool.resource.use { jedis ->\n                val serialized = Json.encodeToString(products)\n                jedis.setex(cacheKey, 300, serialized)\n            }\n\n            call.respond(products)\n        }\n\n        // GET /api/products/:id\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"] ?: return@get call.respond(\n                HttpStatusCode.BadRequest,\n                mapOf(\"error\" to \"Missing product ID\")\n            )\n\n            val product = transaction {\n                Product.findById(UUID.fromString(id))?.toDTO()\n            }\n\n            if (product != null) {\n                call.respond(product)\n            } else {\n                call.respond(HttpStatusCode.NotFound, mapOf(\"error\" to \"Product not found\"))\n            }\n        }\n\n        // Protected routes\n        authenticate(\"auth-jwt\") {\n            // POST /api/products\n            post {\n                val dto = call.receive<CreateProductDTO>()\n                val principal = call.principal<JWTPrincipal>()\n                val userId = principal?.payload?.getClaim(\"userId\")?.asString()\n                    ?: return@post call.respond(HttpStatusCode.Unauthorized)\n\n                val product = transaction {\n                    Product.new {\n                        name = dto.name\n                        description = dto.description\n                        price = dto.price.toBigDecimal()\n                        stock = dto.stock\n                        createdBy = User.findById(UUID.fromString(userId))!!\n                    }.toDTO()\n                }\n\n                // Invalidate cache\n                invalidateProductCache(redisPool)\n\n                call.respond(HttpStatusCode.Created, product)\n            }\n\n            // PUT /api/products/:id\n            put(\"/{id}\") {\n                val id = call.parameters[\"id\"] ?: return@put call.respond(\n                    HttpStatusCode.BadRequest\n                )\n                val dto = call.receive<UpdateProductDTO>()\n\n                val updated = transaction {\n                    val product = Product.findById(UUID.fromString(id))\n                        ?: return@transaction null\n\n                    dto.name?.let { product.name = it }\n                    dto.description?.let { product.description = it }\n                    dto.price?.let { product.price = it.toBigDecimal() }\n                    dto.stock?.let { product.stock = it }\n\n                    product.toDTO()\n                }\n\n                if (updated != null) {\n                    invalidateProductCache(redisPool)\n                    call.respond(updated)\n                } else {\n                    call.respond(HttpStatusCode.NotFound)\n                }\n            }\n\n            // DELETE /api/products/:id\n            delete(\"/{id}\") {\n                val id = call.parameters[\"id\"] ?: return@delete call.respond(\n                    HttpStatusCode.BadRequest\n                )\n\n                val deleted = transaction {\n                    val product = Product.findById(UUID.fromString(id))\n                        ?: return@transaction false\n                    product.delete()\n                    true\n                }\n\n                if (deleted) {\n                    invalidateProductCache(redisPool)\n                    call.respond(HttpStatusCode.NoContent)\n                } else {\n                    call.respond(HttpStatusCode.NotFound)\n                }\n            }\n        }\n    }\n}\n\nprivate fun invalidateProductCache(redisPool: JedisPool) {\n    redisPool.resource.use { jedis ->\n        for (page in 1..10) {\n            jedis.del(\"products_page_${page}_size_20\")\n        }\n    }\n}\n\n@Serializable\ndata class CreateProductDTO(\n    val name: String,\n    val description: String,\n    val price: Double,\n    val stock: Int\n)\n\n@Serializable\ndata class UpdateProductDTO(\n    val name: String? = null,\n    val description: String? = null,\n    val price: Double? = null,\n    val stock: Int? = null\n)",
  "code_hash": "a290b7fae24f03d748a36839435c807d994d3527b14b47728cea2592fab63f0e",
  "imports": [
    "io.ktor.server.routing",
    "org.jetbrains.exposed"
  ],
  "exports": {},
  "parameters": [],
  "dependencies": [],
  "token_count": 1333,
  "times_used": 0,
  "total_tokens_saved": 0,
  "validation_status": "pending",
  "tags": [
    "ktor",
    "rest",
    "crud",
    "cache",
    "routes"
  ],
  "source_file": null,
  "source_line": null,
  "docstring": "Ktor REST routes with caching, pagination, CRUD operations",
  "created_at": "2025-12-13T23:05:06.786170",
  "last_used": null,
  "is_active": true
}