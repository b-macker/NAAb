{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nenum class FormatConversionChar : uint8_t;\nenum class FormatConversionCharSet : uint64_t;\nenum class LengthMod : std::uint8_t { h, hh, l, ll, L, j, z, t, q, none };\n\nnamespace str_format_internal {\n\nclass FormatRawSinkImpl {\n public:\n  // Implicitly convert from any type that provides the hook function as\n  // described above.\n  template <typename T, decltype(str_format_internal::InvokeFlush(\n                            std::declval<T*>(), string_view()))* = nullptr>\n  FormatRawSinkImpl(T* raw)  // NOLINT\n      : sink_(raw), write_(&FormatRawSinkImpl::Flush<T>) {}\n\n  void Write(string_view s) { write_(sink_, s); }\n\n  template <typename T>\n  static FormatRawSinkImpl Extract(T s) {\n    return s.sink_;\n  }\n\n private:\n  template <typename T>\n  static void Flush(void* r, string_view s) {\n    str_format_internal::InvokeFlush(static_cast<T*>(r), s);\n  }\n\n  void* sink_;\n  void (*write_)(void*, string_view);\n};\n\n// An abstraction to which conversions write their string data.\nclass FormatSinkImpl {\n public:\n  explicit FormatSinkImpl(FormatRawSinkImpl raw) : raw_(raw) {}\n\n  ~FormatSinkImpl() { Flush(); }\n\n  void Flush() {\n    raw_.Write(string_view(buf_, static_cast<size_t>(pos_ - buf_)));\n    pos_ = buf_;\n  }\n\n  void Append(size_t n, char c) {\n    if (n == 0) return;\n    size_ += n;\n    auto raw_append = [&](size_t count) {\n      memset(pos_, c, count);\n      pos_ += count;\n    };\n    while (n > Avail()) {\n      n -= Avail();\n      if (Avail() > 0) {\n        raw_append(Avail());\n      }\n      Flush();\n    }\n    raw_append(n);\n  }\n\n  void Append(string_view v) {\n    size_t n = v.size();\n    if (n == 0) return;\n    size_ += n;\n    if (n >= Avail()) {\n      Flush();\n      raw_.Write(v);\n      return;\n    }\n    memcpy(pos_, v.data(), n);\n    pos_ += n;\n  }\n\n  size_t size() const { return size_; }\n\n  // Put 'v' to 'sink' with specified width, precision, and left flag.\n  bool PutPaddedString(string_view v, int width, int precision, bool left);\n\n  template <typename T>\n  T Wrap() {\n    return T(this);\n  }\n\n  template <typename T>\n  static FormatSinkImpl* Extract(T* s) {\n    return s->sink_;\n  }\n\n private:\n  size_t Avail() const {\n    return static_cast<size_t>(buf_ + sizeof(buf_) - pos_);\n  }\n\n  FormatRawSinkImpl raw_;\n  size_t size_ = 0;\n  char* pos_ = buf_;\n  char buf_[1024];\n};\n\nenum class Flags : uint8_t {\n  kBasic = 0,\n  kLeft = 1 << 0,\n  kShowPos = 1 << 1,\n  kSignCol = 1 << 2,\n  kAlt = 1 << 3,\n  kZero = 1 << 4,\n  // This is not a real flag. It just exists to turn off kBasic when no other\n  // flags are set. This is for when width/precision are specified, or a length\n  // modifier affects the behavior (\"%lc\").\n  kNonBasic = 1 << 5,\n};\n\nconstexpr Flags operator|(Flags a, Flags b) {\n  return static_cast<Flags>(static_cast<uint8_t>(a) | static_cast<uint8_t>(b));\n}\n\nconstexpr bool FlagsContains(Flags haystack, Flags needle) {\n  return (static_cast<uint8_t>(haystack) & static_cast<uint8_t>(needle)) ==\n         static_cast<uint8_t>(needle);\n}\n\nstd::string FlagsToString(Flags v);\n\ninline std::ostream& operator<<(std::ostream& os, Flags v) {\n  return os << FlagsToString(v);\n}\n\n// clang-format off\n#define ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(X_VAL, X_SEP) \\\n  /* text */ \\\n  X_VAL(c) X_SEP X_VAL(s) X_SEP \\\n  /* ints */ \\\n  X_VAL(d) X_SEP X_VAL(i) X_SEP X_VAL(o) X_SEP \\\n  X_VAL(u) X_SEP X_VAL(x) X_SEP X_VAL(X) X_SEP \\\n  /* floats */ \\\n  X_VAL(f) X_SEP X_VAL(F) X_SEP X_VAL(e) X_SEP X_VAL(E) X_SEP \\\n  X_VAL(g) X_SEP X_VAL(G) X_SEP X_VAL(a) X_SEP X_VAL(A) X_SEP \\\n  /* misc */ \\\n  X_VAL(n) X_SEP X_VAL(p) X_SEP X_VAL(v)\n// clang-format on\n\n// This type should not be referenced, it exists only to provide labels\n// internally that match the values declared in FormatConversionChar in\n// str_format.h. This is meant to allow internal libraries to use the same\n// declared interface type as the public interface\n// (absl::StrFormatConversionChar) while keeping the definition in a public\n// header.\n// Internal libraries should use the form\n// `FormatConversionCharInternal::c`, `FormatConversionCharInternal::kNone` for\n// comparisons.  Use in switch statements is not recommended due to a bug in how\n// gcc 4.9 -Wswitch handles declared but undefined enums.\nstruct FormatConversionCharInternal {\n  FormatConversionCharInternal() = delete;\n\n private:\n  // clang-format off\n  enum class Enum : uint8_t {\n    c, s,                    // text\n    d, i, o, u, x, X,        // int\n    f, F, e, E, g, G, a, A,  // float\n    n, p, v,                    // misc\n    kNone\n  };\n  // clang-format on\n public:\n#define ABSL_INTERNAL_X_VAL(id)              \\\n  static constexpr FormatConversionChar id = \\\n      static_cast<FormatConversionChar>(Enum::id);\n  ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(ABSL_INTERNAL_X_VAL, )\n#undef ABSL_INTERNAL_X_VAL\n  static constexpr FormatConversionChar kNone =\n      static_cast<FormatConversionChar>(Enum::kNone);\n};\n// clang-format on\n\ninline FormatConversionChar FormatConversionCharFromChar(char c) {\n  switch (c) {\n#define ABSL_INTERNAL_X_VAL(id) \\\n  case #id[0]:                  \\\n    return FormatConversionCharInternal::id;\n    ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(ABSL_INTERNAL_X_VAL, )\n#undef ABSL_INTERNAL_X_VAL\n  }\n  return FormatConversionCharInternal::kNone;\n}\n\ninline bool FormatConversionCharIsUpper(FormatConversionChar c) {\n  if (c == FormatConversionCharInternal::X ||\n      c == FormatConversionCharInternal::F ||\n      c == FormatConversionCharInternal::E ||\n      c == FormatConversionCharInternal::G ||\n      c == FormatConversionCharInternal::A) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\ninline bool FormatConversionCharIsFloat(FormatConversionChar c) {\n  if (c == FormatConversionCharInternal::a ||\n      c == FormatConversionCharInternal::e ||\n      c == FormatConversionCharInternal::f ||\n      c == FormatConversionCharInternal::g ||\n      c == FormatConversionCharInternal::A ||\n      c == FormatConversionCharInternal::E ||\n      c == FormatConversionCharInternal::F ||\n      c == FormatConversionCharInternal::G) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\ninline char FormatConversionCharToChar(FormatConversionChar c) {\n  if (c == FormatConversionCharInternal::kNone) {\n    return '\\0';\n\n#define ABSL_INTERNAL_X_VAL(e)                       \\\n  } else if (c == FormatConversionCharInternal::e) { \\\n    return #e[0];\n#define ABSL_INTERNAL_X_SEP\n  ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(ABSL_INTERNAL_X_VAL,\n                                         ABSL_INTERNAL_X_SEP)\n  } else {\n    return '\\0';\n  }\n\n#undef ABSL_INTERNAL_X_VAL\n#undef ABSL_INTERNAL_X_SEP\n}\n\n// The associated char.\ninline std::ostream& operator<<(std::ostream& os, FormatConversionChar v) {\n  char c = FormatConversionCharToChar(v);\n  if (!c) c = '?';\n  return os << c;\n}\n\nstruct FormatConversionSpecImplFriend;\n\nclass FormatConversionSpecImpl {\n public:\n  // Width and precision are not specified, no flags are set.\n  bool is_basic() const { return flags_ == Flags::kBasic; }\n  bool has_left_flag() const { return FlagsContains(flags_, Flags::kLeft); }\n  bool has_show_pos_flag() const {\n    return FlagsContains(flags_, Flags::kShowPos);\n  }\n  bool has_sign_col_flag() const {\n    return FlagsContains(flags_, Flags::kSignCol);\n  }\n  bool has_alt_flag() const { return FlagsContains(flags_, Flags::kAlt); }\n  bool has_zero_flag() const { return FlagsContains(flags_, Flags::kZero); }\n\n  LengthMod length_mod() const { return length_mod_; }\n\n  FormatConversionChar conversion_char() const {\n    // Keep this field first in the struct . It generates better code when\n    // accessing it when ConversionSpec is passed by value in registers.\n    static_assert(offsetof(FormatConversionSpecImpl, conv_) == 0, \"\");\n    return conv_;\n  }\n\n  void set_conversion_char(FormatConversionChar c) { conv_ = c; }\n\n  // Returns the specified width. If width is unspecfied, it returns a negative\n  // value.\n  int width() const { return width_; }\n  // Returns the specified precision. If precision is unspecfied, it returns a\n  // negative value.\n  int precision() const { return precision_; }\n\n  template <typename T>\n  T Wrap() {\n    return T(*this);\n  }\n\n private:\n  friend struct str_format_internal::FormatConversionSpecImplFriend;\n  FormatConversionChar conv_ = FormatConversionCharInternal::kNone;\n  Flags flags_;\n  LengthMod length_mod_ = LengthMod::none;\n  int width_;\n  int precision_;\n};\n\nstruct FormatConversionSpecImplFriend final {\n  static void SetFlags(Flags f, FormatConversionSpecImpl* conv) {\n    conv->flags_ = f;\n  }\n  static void SetLengthMod(LengthMod l, FormatConversionSpecImpl* conv) {\n    conv->length_mod_ = l;\n  }\n  static void SetConversionChar(FormatConversionChar c,\n                                FormatConversionSpecImpl* conv) {\n    conv->conv_ = c;\n  }\n  static void SetWidth(int w, FormatConversionSpecImpl* conv) {\n    conv->width_ = w;\n  }\n  static void SetPrecision(int p, FormatConversionSpecImpl* conv) {\n    conv->precision_ = p;\n  }\n  static std::string FlagsToString(const FormatConversionSpecImpl& spec) {\n    return str_format_internal::FlagsToString(spec.flags_);\n  }\n};\n\n// Type safe OR operator.\n// We need this for two reasons:\n//  1. operator| on enums makes them decay to integers and the result is an\n//     integer. We need the result to stay as an enum.\n//  2. We use \"enum class\" which would not work even if we accepted the decay.\nconstexpr FormatConversionCharSet FormatConversionCharSetUnion(\n    FormatConversionCharSet a) {\n  return a;\n}\n\ntemplate <typename... CharSet>\nconstexpr FormatConversionCharSet FormatConversionCharSetUnion(\n    FormatConversionCharSet a, CharSet... rest) {\n  return static_cast<FormatConversionCharSet>(\n      static_cast<uint64_t>(a) |\n      static_cast<uint64_t>(FormatConversionCharSetUnion(rest...)));\n}\n\nconstexpr uint64_t FormatConversionCharToConvInt(FormatConversionChar c) {\n  return uint64_t{1} << (1 + static_cast<uint8_t>(c));\n}\n\nconstexpr uint64_t FormatConversionCharToConvInt(char conv) {\n  return\n#define ABSL_INTERNAL_CHAR_SET_CASE(c)                                 \\\n  conv == #c[0]                                                        \\\n      ? FormatConversionCharToConvInt(FormatConversionCharInternal::c) \\\n      :\n      ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(ABSL_INTERNAL_CHAR_SET_CASE, )\n#undef ABSL_INTERNAL_CHAR_SET_CASE\n                  conv == '*'\n          ? 1\n          : 0;\n}\n\nconstexpr FormatConversionCharSet FormatConversionCharToConvValue(char conv) {\n  return static_cast<FormatConversionCharSet>(\n      FormatConversionCharToConvInt(conv));\n}\n\nstruct FormatConversionCharSetInternal {\n#define ABSL_INTERNAL_CHAR_SET_CASE(c)         \\\n  static constexpr FormatConversionCharSet c = \\\n      FormatConversionCharToConvValue(#c[0]);\n  ABSL_INTERNAL_CONVERSION_CHARS_EXPAND_(ABSL_INTERNAL_CHAR_SET_CASE, )\n#undef ABSL_INTERNAL_CHAR_SET_CASE\n\n  // Used for width/precision '*' specification.\n  static constexpr FormatConversionCharSet kStar =\n      FormatConversionCharToConvValue('*');\n\n  static constexpr FormatConversionCharSet kIntegral =\n      FormatConversionCharSetUnion(d, i, u, o, x, X);\n  static constexpr FormatConversionCharSet kFloating =\n      FormatConversionCharSetUnion(a, e, f, g, A, E, F, G);\n  static constexpr FormatConversionCharSet kNumeric =\n      FormatConversionCharSetUnion(kIntegral, kFloating);\n  static constexpr FormatConversionCharSet kPointer = p;\n};\n\n// Type safe OR operator.\n// We need this for two reasons:\n//  1. operator| on enums makes them decay to integers and the result is an\n//     integer. We need the result to stay as an enum.\n//  2. We use \"enum class\" which would not work even if we accepted the decay.\nconstexpr FormatConversionCharSet operator|(FormatConversionCharSet a,\n                                            FormatConversionCharSet b) {\n  return FormatConversionCharSetUnion(a, b);\n}\n\n// Overloaded conversion functions to support absl::ParsedFormat.\n// Get a conversion with a single character in it.\nconstexpr FormatConversionCharSet ToFormatConversionCharSet(char c) {\n  return static_cast<FormatConversionCharSet>(\n      FormatConversionCharToConvValue(c));\n}\n\n// Get a conversion with a single character in it.\nconstexpr FormatConversionCharSet ToFormatConversionCharSet(\n    FormatConversionCharSet c) {\n  return c;\n}\n\ntemplate <typename T>\nvoid ToFormatConversionCharSet(T) = delete;\n\n// Checks whether `c` exists in `set`.\nconstexpr bool Contains(FormatConversionCharSet set, char c) {\n  return (static_cast<uint64_t>(set) &\n          static_cast<uint64_t>(FormatConversionCharToConvValue(c))) != 0;\n}\n\n// Checks whether all the characters in `c` are contained in `set`\nconstexpr bool Contains(FormatConversionCharSet set,\n                        FormatConversionCharSet c) {\n  return (static_cast<uint64_t>(set) & static_cast<uint64_t>(c)) ==\n         static_cast<uint64_t>(c);\n}\n\n// Checks whether all the characters in `c` are contained in `set`\nconstexpr bool Contains(FormatConversionCharSet set, FormatConversionChar c) {\n  return (static_cast<uint64_t>(set) & FormatConversionCharToConvInt(c)) != 0;\n}\n\n// Return capacity - used, clipped to a minimum of 0.\ninline size_t Excess(size_t used, size_t capacity) {\n  return used < capacity ? capacity - used : 0;\n}\n\n}  // namespace str_format_internal\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06408",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/extension.h",
  "source_line": 30,
  "validation_status": "validated"
}