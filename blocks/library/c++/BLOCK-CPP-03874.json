{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// log_uniform_int_distribution:\n//\n// Returns a random variate R in range [min, max] such that\n// floor(log(R-min, base)) is uniformly distributed.\n// We ensure uniformity by discretization using the\n// boundary sets [0, 1, base, base * base, ... min(base*n, max)]\n//\ntemplate <typename IntType = int>\nclass log_uniform_int_distribution {\n private:\n  using unsigned_type =\n      typename random_internal::make_unsigned_bits<IntType>::type;\n\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = log_uniform_int_distribution;\n\n    explicit param_type(\n        result_type min = 0,\n        result_type max = (std::numeric_limits<result_type>::max)(),\n        result_type base = 2)\n        : min_(min),\n          max_(max),\n          base_(base),\n          range_(static_cast<unsigned_type>(max_) -\n                 static_cast<unsigned_type>(min_)),\n          log_range_(0) {\n      assert(max_ >= min_);\n      assert(base_ > 1);\n\n      if (base_ == 2) {\n        // Determine where the first set bit is on range(), giving a log2(range)\n        // value which can be used to construct bounds.\n        log_range_ = (std::min)(random_internal::BitWidth(range()),\n                                std::numeric_limits<unsigned_type>::digits);\n      } else {\n        // NOTE: Computing the logN(x) introduces error from 2 sources:\n        // 1. Conversion of int to double loses precision for values >=\n        // 2^53, which may cause some log() computations to operate on\n        // different values.\n        // 2. The error introduced by the division will cause the result\n        // to differ from the expected value.\n        //\n        // Thus a result which should equal K may equal K +/- epsilon,\n        // which can eliminate some values depending on where the bounds fall.\n        const double inv_log_base = 1.0 / std::log(static_cast<double>(base_));\n        const double log_range = std::log(static_cast<double>(range()) + 0.5);\n        log_range_ = static_cast<int>(std::ceil(inv_log_base * log_range));\n      }\n    }\n\n    result_type(min)() const { return min_; }\n    result_type(max)() const { return max_; }\n    result_type base() const { return base_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.min_ == b.min_ && a.max_ == b.max_ && a.base_ == b.base_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class log_uniform_int_distribution;\n\n    int log_range() const { return log_range_; }\n    unsigned_type range() const { return range_; }\n\n    result_type min_;\n    result_type max_;\n    result_type base_;\n    unsigned_type range_;  // max - min\n    int log_range_;        // ceil(logN(range_))\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::log_uniform_int_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  log_uniform_int_distribution() : log_uniform_int_distribution(0) {}\n\n  explicit log_uniform_int_distribution(\n      result_type min,\n      result_type max = (std::numeric_limits<result_type>::max)(),\n      result_type base = 2)\n      : param_(min, max, base) {}\n\n  explicit log_uniform_int_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p) {\n    return static_cast<result_type>((p.min)() + Generate(g, p));\n  }\n\n  result_type(min)() const { return (param_.min)(); }\n  result_type(max)() const { return (param_.max)(); }\n  result_type base() const { return param_.base(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  friend bool operator==(const log_uniform_int_distribution& a,\n                         const log_uniform_int_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const log_uniform_int_distribution& a,\n                         const log_uniform_int_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  // Returns a log-uniform variate in the range [0, p.range()]. The caller\n  // should add min() to shift the result to the correct range.\n  template <typename URNG>\n  unsigned_type Generate(URNG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param_;\n};\n\ntemplate <typename IntType>\ntemplate <typename URBG>\ntypename log_uniform_int_distribution<IntType>::unsigned_type\nlog_uniform_int_distribution<IntType>::Generate(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  // sample e over [0, log_range]. Map the results of e to this:\n  // 0 => 0\n  // 1 => [1, b-1]\n  // 2 => [b, (b^2)-1]\n  // n => [b^(n-1)..(b^n)-1]\n  const int e = absl::uniform_int_distribution<int>(0, p.log_range())(g);\n  if (e == 0) {\n    return 0;\n  }\n  const int d = e - 1;\n\n  unsigned_type base_e, top_e;\n  if (p.base() == 2) {\n    base_e = static_cast<unsigned_type>(1) << d;\n\n    top_e = (e >= std::numeric_limits<unsigned_type>::digits)\n                ? (std::numeric_limits<unsigned_type>::max)()\n                : (static_cast<unsigned_type>(1) << e) - 1;\n  } else {\n    const double r = std::pow(static_cast<double>(p.base()), d);\n    const double s = (r * static_cast<double>(p.base())) - 1.0;\n\n    base_e =\n        (r > static_cast<double>((std::numeric_limits<unsigned_type>::max)()))\n            ? (std::numeric_limits<unsigned_type>::max)()\n            : static_cast<unsigned_type>(r);\n\n    top_e =\n        (s > static_cast<double>((std::numeric_limits<unsigned_type>::max)()))\n            ? (std::numeric_limits<unsigned_type>::max)()\n            : static_cast<unsigned_type>(s);\n  }\n\n  const unsigned_type lo = (base_e >= p.range()) ? p.range() : base_e;\n  const unsigned_type hi = (top_e >= p.range()) ? p.range() : top_e;\n\n  // choose uniformly over [lo, hi]\n  return absl::uniform_int_distribution<result_type>(\n      static_cast<result_type>(lo), static_cast<result_type>(hi))(g);\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const log_uniform_int_distribution<IntType>& x) {\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os << static_cast<stream_type>((x.min)()) << os.fill()\n     << static_cast<stream_type>((x.max)()) << os.fill()\n     << static_cast<stream_type>(x.base());\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,       // NOLINT(runtime/references)\n    log_uniform_int_distribution<IntType>& x) {  // NOLINT(runtime/references)\n  using param_type = typename log_uniform_int_distribution<IntType>::param_type;\n  using result_type =\n      typename log_uniform_int_distribution<IntType>::result_type;\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n\n  stream_type min;\n  stream_type max;\n  stream_type base;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  is >> min >> max >> base;\n  if (!is.fail()) {\n    x.param(param_type(static_cast<result_type>(min),\n                       static_cast<result_type>(max),\n                       static_cast<result_type>(base)));\n  }\n  return is;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03874",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/log_uniform_int_distribution.h",
  "source_line": 33,
  "validation_status": "validated"
}