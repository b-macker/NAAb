{
  "code": "{\n public:\n  // Print the unsigned integer as octal.\n  // Supports unsigned integral types and uint128.\n  template <typename T>\n  void PrintAsOct(T v) {\n    static_assert(!IsSigned<T>::value, \"\");\n    char *p = storage_ + sizeof(storage_);\n    do {\n      *--p = static_cast<char>('0' + (static_cast<size_t>(v) & 7));\n      v >>= 3;\n    } while (v);\n    start_ = p;\n    size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);\n  }\n\n  // Print the signed or unsigned integer as decimal.\n  // Supports all integral types.\n  template <typename T>\n  void PrintAsDec(T v) {\n    static_assert(std::is_integral<T>::value, \"\");\n    start_ = storage_;\n    size_ = static_cast<size_t>(numbers_internal::FastIntToBuffer(v, storage_) -\n                                storage_);\n  }\n\n  void PrintAsDec(int128 v) {\n    auto u = static_cast<uint128>(v);\n    bool add_neg = false;\n    if (v < 0) {\n      add_neg = true;\n      u = uint128{} - u;\n    }\n    PrintAsDec(u, add_neg);\n  }\n\n  void PrintAsDec(uint128 v, bool add_neg = false) {\n    // This function can be sped up if needed. We can call FastIntToBuffer\n    // twice, or fix FastIntToBuffer to support uint128.\n    char *p = storage_ + sizeof(storage_);\n    do {\n      p -= 2;\n      numbers_internal::PutTwoDigits(static_cast<uint32_t>(v % 100), p);\n      v /= 100;\n    } while (v);\n    if (p[0] == '0') {\n      // We printed one too many hexits.\n      ++p;\n    }\n    if (add_neg) {\n      *--p = '-';\n    }\n    size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);\n    start_ = p;\n  }\n\n  // Print the unsigned integer as hex using lowercase.\n  // Supports unsigned integral types and uint128.\n  template <typename T>\n  void PrintAsHexLower(T v) {\n    static_assert(!IsSigned<T>::value, \"\");\n    char *p = storage_ + sizeof(storage_);\n\n    do {\n      p -= 2;\n      constexpr const char* table = numbers_internal::kHexTable;\n      std::memcpy(p, table + 2 * (static_cast<size_t>(v) & 0xFF), 2);\n      if (sizeof(T) == 1) break;\n      v >>= 8;\n    } while (v);\n    if (p[0] == '0') {\n      // We printed one too many digits.\n      ++p;\n    }\n    start_ = p;\n    size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);\n  }\n\n  // Print the unsigned integer as hex using uppercase.\n  // Supports unsigned integral types and uint128.\n  template <typename T>\n  void PrintAsHexUpper(T v) {\n    static_assert(!IsSigned<T>::value, \"\");\n    char *p = storage_ + sizeof(storage_);\n\n    // kHexTable is only lowercase, so do it manually for uppercase.\n    do {\n      *--p = \"0123456789ABCDEF\"[static_cast<size_t>(v) & 15];\n      v >>= 4;\n    } while (v);\n    start_ = p;\n    size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);\n  }\n\n  // The printed value including the '-' sign if available.\n  // For inputs of value `0`, this will return \"0\"\n  string_view with_neg_and_zero() const { return {start_, size_}; }\n\n  // The printed value not including the '-' sign.\n  // For inputs of value `0`, this will return \"\".\n  string_view without_neg_or_zero() const {\n    static_assert('-' < '0', \"The check below verifies both.\");\n    size_t advance = start_[0] <= '0' ? 1 : 0;\n    return {start_ + advance, size_ - advance};\n  }\n\n  bool is_negative() const { return start_[0] == '-'; }\n\n private:\n  const char *start_;\n  size_t size_;\n  // Max size: 128 bit value as octal -> 43 digits, plus sign char\n  char storage_[128 / 3 + 1 + 1];\n}",
  "id": "BLOCK-CPP-03009",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/arg.cc",
  "source_line": 80,
  "validation_status": "validated"
}