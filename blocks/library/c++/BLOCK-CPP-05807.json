{
  "code": "#include <cstdint>\n#include <limits>\n#include <type_traits>\n#include <intrin.h>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace numeric_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05807_execute() {\n    {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_clzll)\n  // Use __builtin_clzll, which uses the following instructions:\n  //  x86: bsr, lzcnt\n  //  ARM64: clz\n  //  PPC: cntlzd\n  static_assert(sizeof(unsigned long long) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_clzll does not take 64-bit arg\");\n\n  // Handle 0 as a special case because __builtin_clzll(0) is undefined.\n  return x == 0 ? 64 : __builtin_clzll(x);\n#elif defined(_MSC_VER) && !defined(__clang__) && \\\n    (defined(_M_X64) || defined(_M_ARM64))\n  // MSVC does not have __buitin_clzll. Use _BitScanReverse64.\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if (_BitScanReverse64(&result, x)) {\n    return 63 - result;\n  }\n  return 64;\n#elif defined(_MSC_VER) && !defined(__clang__)\n  // MSVC does not have __buitin_clzll. Compose two calls to _BitScanReverse\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if ((x >> 32) &&\n      _BitScanReverse(&result, static_cast<unsigned long>(x >> 32))) {\n    return 31 - result;\n  }\n  if (_BitScanReverse(&result, static_cast<unsigned long>(x))) {\n    return 63 - result;\n  }\n  return 64;\n#else\n  int zeroes = 60;\n  if (x >> 32) {\n    zeroes -= 32;\n    x >>= 32;\n  }\n  if (x >> 16) {\n    zeroes -= 16;\n    x >>= 16;\n  }\n  if (x >> 8) {\n    zeroes -= 8;\n    x >>= 8;\n  }\n  if (x >> 4) {\n    zeroes -= 4;\n    x >>= 4;\n  }\n  return \"\\4\\3\\2\\2\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\"[x] + zeroes;\n#endif\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05807",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/internal/bits.h",
  "source_line": 179,
  "validation_status": "validated"
}