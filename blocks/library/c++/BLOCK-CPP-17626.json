{
  "code": "{\nclass CompilerInstance;\nclass ASTContext;\nclass ASTImporter;\nclass ASTUnit;\nclass DeclContext;\nclass FunctionDecl;\nclass VarDecl;\nclass NamedDecl;\nclass TranslationUnitDecl;\n\nnamespace cross_tu {\n\nenum class index_error_code {\n  success = 0,\n  unspecified = 1,\n  missing_index_file,\n  invalid_index_format,\n  multiple_definitions,\n  missing_definition,\n  failed_import,\n  failed_to_get_external_ast,\n  failed_to_generate_usr,\n  triple_mismatch,\n  lang_mismatch,\n  lang_dialect_mismatch,\n  load_threshold_reached,\n  invocation_list_ambiguous,\n  invocation_list_file_not_found,\n  invocation_list_empty,\n  invocation_list_wrong_format,\n  invocation_list_lookup_unsuccessful\n};\n\nclass IndexError : public llvm::ErrorInfo<IndexError> {\npublic:\n  static char ID;\n  IndexError(index_error_code C) : Code(C), LineNo(0) {}\n  IndexError(index_error_code C, std::string FileName, int LineNo = 0)\n      : Code(C), FileName(std::move(FileName)), LineNo(LineNo) {}\n  IndexError(index_error_code C, std::string FileName, std::string TripleToName,\n             std::string TripleFromName)\n      : Code(C), FileName(std::move(FileName)),\n        TripleToName(std::move(TripleToName)),\n        TripleFromName(std::move(TripleFromName)) {}\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n  index_error_code getCode() const { return Code; }\n  int getLineNum() const { return LineNo; }\n  std::string getFileName() const { return FileName; }\n  std::string getTripleToName() const { return TripleToName; }\n  std::string getTripleFromName() const { return TripleFromName; }\n\nprivate:\n  index_error_code Code;\n  std::string FileName;\n  int LineNo;\n  std::string TripleToName;\n  std::string TripleFromName;\n};\n\n/// This function parses an index file that determines which\n/// translation unit contains which definition. The IndexPath is not prefixed\n/// with CTUDir, so an absolute path is expected for consistent results.\n///\n/// The index file format is the following:\n/// each line consists of an USR and a filepath separated by a space.\n///\n/// \\return Returns a map where the USR is the key and the filepath is the value\n///         or an error.\nllvm::Expected<llvm::StringMap<std::string>>\nparseCrossTUIndex(StringRef IndexPath);\n\nstd::string createCrossTUIndexString(const llvm::StringMap<std::string> &Index);\n\nusing InvocationListTy = llvm::StringMap<llvm::SmallVector<std::string, 32>>;\n/// Parse the YAML formatted invocation list file content \\p FileContent.\n/// The format is expected to be a mapping from absolute source file\n/// paths in the filesystem to a list of command-line parts, which\n/// constitute the invocation needed to compile that file. That invocation\n/// will be used to produce the AST of the TU.\nllvm::Expected<InvocationListTy> parseInvocationList(\n    StringRef FileContent,\n    llvm::sys::path::Style PathStyle = llvm::sys::path::Style::posix);\n\n/// Returns true if it makes sense to import a foreign variable definition.\n/// For instance, we don't want to import variables that have non-trivial types\n/// because the constructor might have side-effects.\nbool shouldImport(const VarDecl *VD, const ASTContext &ACtx);\n\n/// This class is used for tools that requires cross translation\n///        unit capability.\n///\n/// This class can load definitions from external AST sources.\n/// The loaded definition will be merged back to the original AST using the\n/// AST Importer.\n/// In order to use this class, an index file is required that describes\n/// the locations of the AST files for each definition.\n///\n/// Note that this class also implements caching.\nclass CrossTranslationUnitContext {\npublic:\n  CrossTranslationUnitContext(CompilerInstance &CI);\n  ~CrossTranslationUnitContext();\n\n  /// This function loads a function or variable definition from an\n  ///        external AST file and merges it into the original AST.\n  ///\n  /// This method should only be used on functions that have no definitions or\n  /// variables that have no initializer in\n  /// the current translation unit. A function definition with the same\n  /// declaration will be looked up in the index file which should be in the\n  /// \\p CrossTUDir directory, called \\p IndexName. In case the declaration is\n  /// found in the index the corresponding AST will be loaded and the\n  /// definition will be merged into the original AST using the AST Importer.\n  ///\n  /// \\return The declaration with the definition will be returned.\n  /// If no suitable definition is found in the index file or multiple\n  /// definitions found error will be returned.\n  ///\n  /// Note that the AST files should also be in the \\p CrossTUDir.\n  llvm::Expected<const FunctionDecl *>\n  getCrossTUDefinition(const FunctionDecl *FD, StringRef CrossTUDir,\n                       StringRef IndexName, bool DisplayCTUProgress = false);\n  llvm::Expected<const VarDecl *>\n  getCrossTUDefinition(const VarDecl *VD, StringRef CrossTUDir,\n                       StringRef IndexName, bool DisplayCTUProgress = false);\n\n  /// This function loads a definition from an external AST file.\n  ///\n  /// A definition with the same declaration will be looked up in the\n  /// index file which should be in the \\p CrossTUDir directory, called\n  /// \\p IndexName. In case the declaration is found in the index the\n  /// corresponding AST will be loaded. If the number of TUs imported\n  /// reaches \\p CTULoadTreshold, no loading is performed.\n  ///\n  /// \\return Returns a pointer to the ASTUnit that contains the definition of\n  /// the looked up name or an Error.\n  /// The returned pointer is never a nullptr.\n  ///\n  /// Note that the AST files should also be in the \\p CrossTUDir.\n  llvm::Expected<ASTUnit *> loadExternalAST(StringRef LookupName,\n                                            StringRef CrossTUDir,\n                                            StringRef IndexName,\n                                            bool DisplayCTUProgress = false);\n\n  /// This function merges a definition from a separate AST Unit into\n  ///        the current one which was created by the compiler instance that\n  ///        was passed to the constructor.\n  ///\n  /// \\return Returns the resulting definition or an error.\n  llvm::Expected<const FunctionDecl *> importDefinition(const FunctionDecl *FD,\n                                                        ASTUnit *Unit);\n  llvm::Expected<const VarDecl *> importDefinition(const VarDecl *VD,\n                                                   ASTUnit *Unit);\n\n  /// Get a name to identify a named decl.\n  static std::optional<std::string> getLookupName(const NamedDecl *ND);\n\n  /// Emit diagnostics for the user for potential configuration errors.\n  void emitCrossTUDiagnostics(const IndexError &IE);\n\n  /// Returns the MacroExpansionContext for the imported TU to which the given\n  /// source-location corresponds.\n  /// \\p ToLoc Source location in the imported-to AST.\n  /// \\note If any error happens such as \\p ToLoc is a non-imported\n  ///       source-location, empty is returned.\n  /// \\note Macro expansion tracking for imported TUs is not implemented yet.\n  ///       It returns empty unconditionally.\n  std::optional<clang::MacroExpansionContext>\n  getMacroExpansionContextForSourceLocation(\n      const clang::SourceLocation &ToLoc) const;\n\n  /// Returns true if the given Decl is newly created during the import.\n  bool isImportedAsNew(const Decl *ToDecl) const;\n\n  /// Returns true if the given Decl is mapped (or created) during an import\n  /// but there was an unrecoverable error (the AST node cannot be erased, it\n  /// is marked with an Error object in this case).\n  bool hasError(const Decl *ToDecl) const;\n\nprivate:\n  void lazyInitImporterSharedSt(TranslationUnitDecl *ToTU);\n  ASTImporter &getOrCreateASTImporter(ASTUnit *Unit);\n  template <typename T>\n  llvm::Expected<const T *> getCrossTUDefinitionImpl(const T *D,\n                                                     StringRef CrossTUDir,\n                                                     StringRef IndexName,\n                                                     bool DisplayCTUProgress);\n  template <typename T>\n  const T *findDefInDeclContext(const DeclContext *DC,\n                                StringRef LookupName);\n  template <typename T>\n  llvm::Expected<const T *> importDefinitionImpl(const T *D, ASTUnit *Unit);\n\n  using ImporterMapTy =\n      llvm::DenseMap<TranslationUnitDecl *, std::unique_ptr<ASTImporter>>;\n\n  ImporterMapTy ASTUnitImporterMap;\n\n  ASTContext &Context;\n  std::shared_ptr<ASTImporterSharedState> ImporterSharedSt;\n\n  using LoadResultTy = llvm::Expected<std::unique_ptr<ASTUnit>>;\n\n  /// Loads ASTUnits from AST-dumps or source-files.\n  class ASTLoader {\n  public:\n    ASTLoader(CompilerInstance &CI, StringRef CTUDir,\n              StringRef InvocationListFilePath);\n\n    /// Load the ASTUnit by its identifier found in the index file. If the\n    /// identifier is suffixed with '.ast' it is considered a dump. Otherwise\n    /// it is treated as source-file, and on-demand parsed. Relative paths are\n    /// prefixed with CTUDir.\n    LoadResultTy load(StringRef Identifier);\n\n    /// Lazily initialize the invocation list information, which is needed for\n    /// on-demand parsing.\n    llvm::Error lazyInitInvocationList();\n\n  private:\n    /// The style used for storage and lookup of filesystem paths.\n    /// Defaults to posix.\n    const llvm::sys::path::Style PathStyle = llvm::sys::path::Style::posix;\n\n    /// Loads an AST from a pch-dump.\n    LoadResultTy loadFromDump(StringRef Identifier);\n    /// Loads an AST from a source-file.\n    LoadResultTy loadFromSource(StringRef Identifier);\n\n    CompilerInstance &CI;\n    StringRef CTUDir;\n    /// The path to the file containing the invocation list, which is in YAML\n    /// format, and contains a mapping from source files to compiler invocations\n    /// that produce the AST used for analysis.\n    StringRef InvocationListFilePath;\n    /// In case of on-demand parsing, the invocations for parsing the source\n    /// files is stored.\n    std::optional<InvocationListTy> InvocationList;\n    index_error_code PreviousParsingResult = index_error_code::success;\n  };\n\n  /// Maintain number of AST loads and check for reaching the load limit.\n  class ASTLoadGuard {\n  public:\n    ASTLoadGuard(unsigned Limit) : Limit(Limit) {}\n\n    /// Indicates, whether a new load operation is permitted, it is within the\n    /// threshold.\n    operator bool() const { return Count < Limit; }\n\n    /// Tell that a new AST was loaded successfully.\n    void indicateLoadSuccess() { ++Count; }\n\n  private:\n    /// The number of ASTs actually imported.\n    unsigned Count{0u};\n    /// The limit (threshold) value for number of loaded ASTs.\n    const unsigned Limit;\n  };\n\n  /// Storage and load of ASTUnits, cached access, and providing searchability\n  /// are the concerns of ASTUnitStorage class.\n  class ASTUnitStorage {\n  public:\n    ASTUnitStorage(CompilerInstance &CI);\n    /// Loads an ASTUnit for a function.\n    ///\n    /// \\param FunctionName USR name of the function.\n    /// \\param CrossTUDir Path to the directory used to store CTU related files.\n    /// \\param IndexName Name of the file inside \\p CrossTUDir which maps\n    /// function USR names to file paths. These files contain the corresponding\n    /// AST-dumps.\n    /// \\param DisplayCTUProgress Display a message about loading new ASTs.\n    ///\n    /// \\return An Expected instance which contains the ASTUnit pointer or the\n    /// error occurred during the load.\n    llvm::Expected<ASTUnit *> getASTUnitForFunction(StringRef FunctionName,\n                                                    StringRef CrossTUDir,\n                                                    StringRef IndexName,\n                                                    bool DisplayCTUProgress);\n    /// Identifies the path of the file which can be used to load the ASTUnit\n    /// for a given function.\n    ///\n    /// \\param FunctionName USR name of the function.\n    /// \\param CrossTUDir Path to the directory used to store CTU related files.\n    /// \\param IndexName Name of the file inside \\p CrossTUDir which maps\n    /// function USR names to file paths. These files contain the corresponding\n    /// AST-dumps.\n    ///\n    /// \\return An Expected instance containing the filepath.\n    llvm::Expected<std::string> getFileForFunction(StringRef FunctionName,\n                                                   StringRef CrossTUDir,\n                                                   StringRef IndexName);\n\n  private:\n    llvm::Error ensureCTUIndexLoaded(StringRef CrossTUDir, StringRef IndexName);\n    llvm::Expected<ASTUnit *> getASTUnitForFile(StringRef FileName,\n                                                bool DisplayCTUProgress);\n\n    template <typename... T> using BaseMapTy = llvm::StringMap<T...>;\n    using OwningMapTy = BaseMapTy<std::unique_ptr<clang::ASTUnit>>;\n    using NonOwningMapTy = BaseMapTy<clang::ASTUnit *>;\n\n    OwningMapTy FileASTUnitMap;\n    NonOwningMapTy NameASTUnitMap;\n\n    using IndexMapTy = BaseMapTy<std::string>;\n    IndexMapTy NameFileMap;\n\n    /// Loads the AST based on the identifier found in the index.\n    ASTLoader Loader;\n\n    /// Limit the number of loaded ASTs. It is used to limit the  memory usage\n    /// of the CrossTranslationUnitContext. The ASTUnitStorage has the\n    /// information whether the AST to load is actually loaded or returned from\n    /// cache. This information is needed to maintain the counter.\n    ASTLoadGuard LoadGuard;\n  };\n\n  ASTUnitStorage ASTStorage;\n};\n\n} // namespace cross_tu\n}",
  "id": "BLOCK-CPP-17626",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CrossTU/CrossTranslationUnit.h",
  "source_line": 27,
  "validation_status": "validated"
}