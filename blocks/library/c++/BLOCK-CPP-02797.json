{
  "code": "{\n\n// The default return at the end of the function might be unreachable depending\n// on the configuration. Ignore that warning.\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code-return\"\n#endif\n\n// CPUSupportsRandenHwAes returns whether the CPU is a microarchitecture\n// which supports the crpyto/aes instructions or extensions necessary to use the\n// accelerated RandenHwAes implementation.\n//\n// 1. For x86 it is sufficient to use the CPUID instruction to detect whether\n//    the cpu supports AES instructions. Done.\n//\n// Fon non-x86 it is much more complicated.\n//\n// 2. When ABSL_INTERNAL_USE_GETAUXVAL is defined, use getauxval() (either\n//    the direct c-library version, or the android probing version which loads\n//    libc), and read the hardware capability bits.\n//    This is based on the technique used by boringssl uses to detect\n//    cpu capabilities, and should allow us to enable crypto in the android\n//    builds where it is supported.\n//\n// 3. Use the default for the compiler architecture.\n//\n\nbool CPUSupportsRandenHwAes() {\n#if defined(ABSL_INTERNAL_USE_X86_CPUID)\n  // 1. For x86: Use CPUID to detect the required AES instruction set.\n  int regs[4];\n  __cpuid(reinterpret_cast<int*>(regs), 1);\n  return regs[2] & (1 << 25);  // AES\n\n#elif defined(ABSL_INTERNAL_USE_GETAUXVAL)\n  // 2. Use getauxval() to read the hardware bits and determine\n  // cpu capabilities.\n\n#define AT_HWCAP 16\n#define AT_HWCAP2 26\n#if defined(ABSL_ARCH_PPC)\n  // For Power / PPC: Expect that the cpu supports VCRYPTO\n  // See https://members.openpowerfoundation.org/document/dl/576\n  // VCRYPTO should be present in POWER8 >= 2.07.\n  // Uses Linux kernel constants from arch/powerpc/include/uapi/asm/cputable.h\n  static const uint32_t kVCRYPTO = 0x02000000;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP2);\n  return (hwcap & kVCRYPTO) != 0;\n\n#elif defined(ABSL_ARCH_ARM)\n  // For ARM: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  // Uses Linux kernel constants from arch/arm64/include/asm/hwcap.h\n  static const uint32_t kNEON = 1 << 12;\n  uint32_t hwcap = GetAuxval(AT_HWCAP);\n  if ((hwcap & kNEON) == 0) {\n    return false;\n  }\n\n  // And use it again to detect AES.\n  static const uint32_t kAES = 1 << 0;\n  const uint32_t hwcap2 = GetAuxval(AT_HWCAP2);\n  return (hwcap2 & kAES) != 0;\n\n#elif defined(ABSL_ARCH_AARCH64)\n  // For AARCH64: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  static const uint32_t kNEON = 1 << 1;\n  static const uint32_t kAES = 1 << 3;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP);\n  return ((hwcap & kNEON) != 0) && ((hwcap & kAES) != 0);\n#endif\n\n#else  // ABSL_INTERNAL_USE_GETAUXVAL\n  // 3. By default, assume that the compiler default.\n  return ABSL_HAVE_ACCELERATED_AES ? true : false;\n\n#endif\n  // NOTE: There are some other techniques that may be worth trying:\n  //\n  // * Use an environment variable: ABSL_RANDOM_USE_HWAES\n  //\n  // * Rely on compiler-generated target-based dispatch.\n  // Using x86/gcc it might look something like this:\n  //\n  // int __attribute__((target(\"aes\"))) HasAes() { return 1; }\n  // int __attribute__((target(\"default\"))) HasAes() { return 0; }\n  //\n  // This does not work on all architecture/compiler combinations.\n  //\n  // * On Linux consider reading /proc/cpuinfo and/or /proc/self/auxv.\n  // These files have lines which are easy to parse; for ARM/AARCH64 it is quite\n  // easy to find the Features: line and extract aes / neon. Likewise for\n  // PPC.\n  //\n  // * Fork a process and test for SIGILL:\n  //\n  // * Many architectures have instructions to read the ISA. Unfortunately\n  //   most of those require that the code is running in ring 0 /\n  //   protected-mode.\n  //\n  //   There are several examples. e.g. Valgrind detects PPC ISA 2.07:\n  //   https://github.com/lu-zero/valgrind/blob/master/none/tests/ppc64/test_isa_2_07_part1.c\n  //\n  //   MRS <Xt>, ID_AA64ISAR0_EL1 ; Read ID_AA64ISAR0_EL1 into Xt\n  //\n  //   uint64_t val;\n  //   __asm __volatile(\"mrs %0, id_aa64isar0_el1\" :\"=&r\" (val));\n  //\n  // * Use a CPUID-style heuristic database.\n  //\n  // * On Apple (__APPLE__), AES is available on Arm v8.\n  //   https://stackoverflow.com/questions/45637888/how-to-determine-armv8-features-at-runtime-on-ios\n}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n}",
  "id": "BLOCK-CPP-02797",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/randen_detect.cc",
  "source_line": 107,
  "validation_status": "validated"
}