{
  "code": "{\n\n// Split a time_point<D> into a time_point<seconds> and a D subseconds.\n// Undefined behavior if time_point<seconds> is not of sufficient range.\n// Note that this means it is UB to call cctz::time_zone::lookup(tp) or\n// cctz::format(fmt, tp, tz) with a time_point that is outside the range\n// of a 64-bit std::time_t.\ntemplate <typename D>\nstd::pair<time_point<seconds>, D> split_seconds(const time_point<D>& tp) {\n  auto sec = std::chrono::time_point_cast<seconds>(tp);\n  auto sub = tp - sec;\n  if (sub.count() < 0) {\n    sec -= seconds(1);\n    sub += seconds(1);\n  }\n  return {sec, std::chrono::duration_cast<D>(sub)};\n}\n\ninline std::pair<time_point<seconds>, seconds> split_seconds(\n    const time_point<seconds>& tp) {\n  return {tp, seconds::zero()};\n}\n\n// Join a time_point<seconds> and femto subseconds into a time_point<D>.\n// Floors to the resolution of time_point<D>. Returns false if time_point<D>\n// is not of sufficient range.\ntemplate <typename Rep, std::intmax_t Denom>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<1, Denom>>;\n  // TODO(#199): Return false if result unrepresentable as a time_point<D>.\n  *tpp = std::chrono::time_point_cast<D>(sec);\n  *tpp += std::chrono::duration_cast<D>(fs);\n  return true;\n}\n\ntemplate <typename Rep, std::intmax_t Num>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds&,\n    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<Num, 1>>;\n  auto count = sec.time_since_epoch().count();\n  if (count >= 0 || count % Num == 0) {\n    count /= Num;\n  } else {\n    count /= Num;\n    count -= 1;\n  }\n  if (count > (std::numeric_limits<Rep>::max)()) return false;\n  if (count < (std::numeric_limits<Rep>::min)()) return false;\n  *tpp = time_point<D>() + D{static_cast<Rep>(count)};\n  return true;\n}\n\ntemplate <typename Rep>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds&,\n    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<1, 1>>;\n  auto count = sec.time_since_epoch().count();\n  if (count > (std::numeric_limits<Rep>::max)()) return false;\n  if (count < (std::numeric_limits<Rep>::min)()) return false;\n  *tpp = time_point<D>() + D{static_cast<Rep>(count)};\n  return true;\n}\n\ninline bool join_seconds(const time_point<seconds>& sec, const femtoseconds&,\n                         time_point<seconds>* tpp) {\n  *tpp = sec;\n  return true;\n}\n\n}",
  "id": "BLOCK-CPP-06618",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/time_zone.h",
  "source_line": 381,
  "validation_status": "validated"
}