{
  "code": "#include \"clang/Basic/LangOptions.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16698_execute() {\n    {\n\n/// OpenMP directives.\nusing OpenMPDirectiveKind = llvm::omp::Directive;\n\n/// OpenMP clauses.\nusing OpenMPClauseKind = llvm::omp::Clause;\n\n/// OpenMP attributes for 'schedule' clause.\nenum OpenMPScheduleClauseKind {\n#define OPENMP_SCHEDULE_KIND(Name) \\\n  OMPC_SCHEDULE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_SCHEDULE_unknown\n};\n\n/// OpenMP modifiers for 'schedule' clause.\nenum OpenMPScheduleClauseModifier {\n  OMPC_SCHEDULE_MODIFIER_unknown = OMPC_SCHEDULE_unknown,\n#define OPENMP_SCHEDULE_MODIFIER(Name) \\\n  OMPC_SCHEDULE_MODIFIER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_SCHEDULE_MODIFIER_last\n};\n\n/// OpenMP modifiers for 'device' clause.\nenum OpenMPDeviceClauseModifier {\n#define OPENMP_DEVICE_MODIFIER(Name) OMPC_DEVICE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DEVICE_unknown,\n};\n\n/// OpenMP attributes for 'depend' clause.\nenum OpenMPDependClauseKind {\n#define OPENMP_DEPEND_KIND(Name) \\\n  OMPC_DEPEND_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DEPEND_unknown\n};\n\n/// OpenMP attributes for 'linear' clause.\nenum OpenMPLinearClauseKind {\n#define OPENMP_LINEAR_KIND(Name) \\\n  OMPC_LINEAR_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_LINEAR_unknown\n};\n\n/// OpenMP mapping kind for 'map' clause.\nenum OpenMPMapClauseKind {\n#define OPENMP_MAP_KIND(Name) \\\n  OMPC_MAP_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_MAP_unknown\n};\n\n/// OpenMP modifier kind for 'map' clause.\nenum OpenMPMapModifierKind {\n  OMPC_MAP_MODIFIER_unknown = OMPC_MAP_unknown,\n#define OPENMP_MAP_MODIFIER_KIND(Name) \\\n  OMPC_MAP_MODIFIER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_MAP_MODIFIER_last\n};\n\n/// Number of allowed map-type-modifiers.\nstatic constexpr unsigned NumberOfOMPMapClauseModifiers =\n    OMPC_MAP_MODIFIER_last - OMPC_MAP_MODIFIER_unknown - 1;\n\n/// OpenMP modifier kind for 'to' or 'from' clause.\nenum OpenMPMotionModifierKind {\n#define OPENMP_MOTION_MODIFIER_KIND(Name) \\\n  OMPC_MOTION_MODIFIER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_MOTION_MODIFIER_unknown\n};\n\n/// Number of allowed motion-modifiers.\nstatic constexpr unsigned NumberOfOMPMotionModifiers =\n    OMPC_MOTION_MODIFIER_unknown;\n\n/// OpenMP attributes for 'dist_schedule' clause.\nenum OpenMPDistScheduleClauseKind {\n#define OPENMP_DIST_SCHEDULE_KIND(Name) OMPC_DIST_SCHEDULE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DIST_SCHEDULE_unknown\n};\n\n/// OpenMP attributes for 'defaultmap' clause.\nenum OpenMPDefaultmapClauseKind {\n#define OPENMP_DEFAULTMAP_KIND(Name) \\\n  OMPC_DEFAULTMAP_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DEFAULTMAP_unknown\n};\n\n/// OpenMP modifiers for 'defaultmap' clause.\nenum OpenMPDefaultmapClauseModifier {\n  OMPC_DEFAULTMAP_MODIFIER_unknown = OMPC_DEFAULTMAP_unknown,\n#define OPENMP_DEFAULTMAP_MODIFIER(Name) \\\n  OMPC_DEFAULTMAP_MODIFIER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DEFAULTMAP_MODIFIER_last\n};\n\n/// OpenMP attributes for 'atomic_default_mem_order' clause.\nenum OpenMPAtomicDefaultMemOrderClauseKind {\n#define OPENMP_ATOMIC_DEFAULT_MEM_ORDER_KIND(Name)  \\\n  OMPC_ATOMIC_DEFAULT_MEM_ORDER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown\n};\n\n/// OpenMP attributes for 'at' clause.\nenum OpenMPAtClauseKind {\n#define OPENMP_AT_KIND(Name) OMPC_AT_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_AT_unknown\n};\n\n/// OpenMP attributes for 'severity' clause.\nenum OpenMPSeverityClauseKind {\n#define OPENMP_SEVERITY_KIND(Name) OMPC_SEVERITY_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_SEVERITY_unknown\n};\n\n/// OpenMP device type for 'device_type' clause.\nenum OpenMPDeviceType {\n#define OPENMP_DEVICE_TYPE_KIND(Name) \\\n  OMPC_DEVICE_TYPE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DEVICE_TYPE_unknown\n};\n\n/// OpenMP 'lastprivate' clause modifier.\nenum OpenMPLastprivateModifier {\n#define OPENMP_LASTPRIVATE_KIND(Name) OMPC_LASTPRIVATE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_LASTPRIVATE_unknown,\n};\n\n/// OpenMP attributes for 'order' clause.\nenum OpenMPOrderClauseKind {\n#define OPENMP_ORDER_KIND(Name) OMPC_ORDER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_ORDER_unknown,\n};\n\n/// OpenMP modifiers for 'order' clause.\nenum OpenMPOrderClauseModifier {\n  OMPC_ORDER_MODIFIER_unknown = OMPC_ORDER_unknown,\n#define OPENMP_ORDER_MODIFIER(Name) OMPC_ORDER_MODIFIER_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_ORDER_MODIFIER_last\n};\n\n/// Scheduling data for loop-based OpenMP directives.\nstruct OpenMPScheduleTy final {\n  OpenMPScheduleClauseKind Schedule = OMPC_SCHEDULE_unknown;\n  OpenMPScheduleClauseModifier M1 = OMPC_SCHEDULE_MODIFIER_unknown;\n  OpenMPScheduleClauseModifier M2 = OMPC_SCHEDULE_MODIFIER_unknown;\n};\n\n/// OpenMP modifiers for 'reduction' clause.\nenum OpenMPReductionClauseModifier {\n#define OPENMP_REDUCTION_MODIFIER(Name) OMPC_REDUCTION_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_REDUCTION_unknown,\n};\n\n/// OpenMP adjust-op kinds for 'adjust_args' clause.\nenum OpenMPAdjustArgsOpKind {\n#define OPENMP_ADJUST_ARGS_KIND(Name) OMPC_ADJUST_ARGS_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_ADJUST_ARGS_unknown,\n};\n\n/// OpenMP bindings for the 'bind' clause.\nenum OpenMPBindClauseKind {\n#define OPENMP_BIND_KIND(Name) OMPC_BIND_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_BIND_unknown\n};\n\nenum OpenMPGrainsizeClauseModifier {\n#define OPENMP_GRAINSIZE_MODIFIER(Name) OMPC_GRAINSIZE_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_GRAINSIZE_unknown\n};\n\nenum OpenMPNumTasksClauseModifier {\n#define OPENMP_NUMTASKS_MODIFIER(Name) OMPC_NUMTASKS_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_NUMTASKS_unknown\n};\n\n/// OpenMP dependence types for 'doacross' clause.\nenum OpenMPDoacrossClauseModifier {\n#define OPENMP_DOACROSS_MODIFIER(Name) OMPC_DOACROSS_##Name,\n#include \"clang/Basic/OpenMPKinds.def\"\n  OMPC_DOACROSS_unknown\n};\n\n/// Contains 'interop' data for 'append_args' and 'init' clauses.\nclass Expr;\nstruct OMPInteropInfo final {\n  OMPInteropInfo(bool IsTarget = false, bool IsTargetSync = false)\n      : IsTarget(IsTarget), IsTargetSync(IsTargetSync) {}\n  bool IsTarget;\n  bool IsTargetSync;\n  llvm::SmallVector<Expr *, 4> PreferTypes;\n};\n\nunsigned getOpenMPSimpleClauseType(OpenMPClauseKind Kind, llvm::StringRef Str,\n                                   const LangOptions &LangOpts);\nconst char *getOpenMPSimpleClauseTypeName(OpenMPClauseKind Kind, unsigned Type);\n\n/// Checks if the specified directive is a directive with an associated\n/// loop construct.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a loop-associated directive like 'omp simd'\n/// or 'omp for' directive, otherwise - false.\nbool isOpenMPLoopDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a worksharing directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a worksharing directive like 'omp for',\n/// otherwise - false.\nbool isOpenMPWorksharingDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a taskloop directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a worksharing directive like 'omp taskloop',\n/// otherwise - false.\nbool isOpenMPTaskLoopDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a parallel-kind directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a parallel-like directive like 'omp\n/// parallel', otherwise - false.\nbool isOpenMPParallelDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a target code offload directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a target code offload directive like\n/// 'omp target', 'omp target parallel', 'omp target xxx'\n/// otherwise - false.\nbool isOpenMPTargetExecutionDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a target data offload directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a target data offload directive like\n/// 'omp target data', 'omp target update', 'omp target enter data',\n/// 'omp target exit data'\n/// otherwise - false.\nbool isOpenMPTargetDataManagementDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified composite/combined directive constitutes a teams\n/// directive in the outermost nest.  For example\n/// 'omp teams distribute' or 'omp teams distribute parallel for'.\n/// \\param DKind Specified directive.\n/// \\return true - the directive has teams on the outermost nest, otherwise -\n/// false.\nbool isOpenMPNestingTeamsDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a teams-kind directive.  For example,\n/// 'omp teams distribute' or 'omp target teams'.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a teams-like directive, otherwise - false.\nbool isOpenMPTeamsDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a simd directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a simd directive like 'omp simd',\n/// otherwise - false.\nbool isOpenMPSimdDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a distribute directive.\n/// \\param DKind Specified directive.\n/// \\return true - the directive is a distribute-directive like 'omp\n/// distribute',\n/// otherwise - false.\nbool isOpenMPDistributeDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified composite/combined directive constitutes a\n/// distribute directive in the outermost nest.  For example,\n/// 'omp distribute parallel for' or 'omp distribute'.\n/// \\param DKind Specified directive.\n/// \\return true - the directive has distribute on the outermost nest.\n/// otherwise - false.\nbool isOpenMPNestingDistributeDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive constitutes a 'loop' directive in the\n/// outermost nest.  For example, 'omp teams loop' or 'omp loop'.\n/// \\param DKind Specified directive.\n/// \\return true - the directive has loop on the outermost nest.\n/// otherwise - false.\nbool isOpenMPGenericLoopDirective(OpenMPDirectiveKind DKind);\n\n/// Checks if the specified clause is one of private clauses like\n/// 'private', 'firstprivate', 'reduction' etc..\n/// \\param Kind Clause kind.\n/// \\return true - the clause is a private clause, otherwise - false.\nbool isOpenMPPrivate(OpenMPClauseKind Kind);\n\n/// Checks if the specified clause is one of threadprivate clauses like\n/// 'threadprivate', 'copyin' or 'copyprivate'.\n/// \\param Kind Clause kind.\n/// \\return true - the clause is a threadprivate clause, otherwise - false.\nbool isOpenMPThreadPrivate(OpenMPClauseKind Kind);\n\n/// Checks if the specified directive kind is one of tasking directives - task,\n/// taskloop, taksloop simd, master taskloop, parallel master taskloop, master\n/// taskloop simd, or parallel master taskloop simd.\nbool isOpenMPTaskingDirective(OpenMPDirectiveKind Kind);\n\n/// Checks if the specified directive kind is one of the composite or combined\n/// directives that need loop bound sharing across loops outlined in nested\n/// functions\nbool isOpenMPLoopBoundSharingDirective(OpenMPDirectiveKind Kind);\n\n/// Checks if the specified directive is a loop transformation directive.\n/// \\param DKind Specified directive.\n/// \\return True iff the directive is a loop transformation.\nbool isOpenMPLoopTransformationDirective(OpenMPDirectiveKind DKind);\n\n/// Return the captured regions of an OpenMP directive.\nvoid getOpenMPCaptureRegions(\n    llvm::SmallVectorImpl<OpenMPDirectiveKind> &CaptureRegions,\n    OpenMPDirectiveKind DKind);\n\n/// Checks if the specified directive is a combined construct for which\n/// the first construct is a parallel construct.\n/// \\param DKind Specified directive.\n/// \\return true - if the above condition is met for this directive\n/// otherwise - false.\nbool isOpenMPCombinedParallelADirective(OpenMPDirectiveKind DKind);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16698",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/OpenMPKinds.h",
  "source_line": 21,
  "validation_status": "validated"
}