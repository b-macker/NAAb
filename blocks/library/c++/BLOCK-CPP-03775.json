{
  "code": "#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n#include <iosfwd>\n#include <limits>\n#include <string>\n#include <utility>\n#include \"absl/base/config.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/port.h\"\n#include <intrin.h>\n\nusing namespace absl;\nusing namespace absl;\nusing namespace std;\nusing namespace std;\nusing namespace absl;\nusing namespace absl;\nusing namespace std;\nusing namespace std;\nusing namespace absl;\nusing namespace int128_internal;\nusing namespace int128_internal;\nusing namespace int128_internal;\nusing namespace int128_internal;\nusing namespace int128_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03775_execute() {\n    {\n  // Casting an unsigned integer to a signed integer of the same\n  // width is implementation defined behavior if the source value would not fit\n  // in the destination type. We step around it with a roundtrip bitwise not\n  // operation to make sure this function remains constexpr. Clang, GCC, and\n  // MSVC optimize this to a no-op on x86-64.\n  return v & (uint64_t{1} << 63) ? ~static_cast<int64_t>(~v)\n                                 : static_cast<int64_t>(v);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03775",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.h",
  "source_line": 1139,
  "validation_status": "validated"
}