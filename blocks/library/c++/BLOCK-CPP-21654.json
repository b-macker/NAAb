{
  "code": "{\npublic:\n  SFunction(Variable *Vd, SExpr *B)\n      : SExpr(COP_SFunction), VarDecl(Vd), Body(B) {\n    assert(Vd->Definition == nullptr);\n    Vd->setKind(Variable::VK_SFun);\n    Vd->Definition = this;\n  }\n\n  SFunction(const SFunction &F, Variable *Vd, SExpr *B) // rewrite constructor\n      : SExpr(F), VarDecl(Vd), Body(B) {\n    assert(Vd->Definition == nullptr);\n    Vd->setKind(Variable::VK_SFun);\n    Vd->Definition = this;\n  }\n\n  static bool classof(const SExpr *E) { return E->opcode() == COP_SFunction; }\n\n  Variable *variableDecl() { return VarDecl; }\n  const Variable *variableDecl() const { return VarDecl; }\n\n  SExpr *body() { return Body; }\n  const SExpr *body() const { return Body; }\n\n  template <class V>\n  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {\n    // A self-variable points to the SFunction itself.\n    // A rewrite must introduce the variable with a null definition, and update\n    // it after 'this' has been rewritten.\n    Variable *Nvd = Vs.enterScope(*VarDecl, nullptr);\n    auto E1 = Vs.traverse(Body, Vs.declCtx(Ctx));\n    Vs.exitScope(*VarDecl);\n    // A rewrite operation will call SFun constructor to set Vvd->Definition.\n    return Vs.reduceSFunction(*this, Nvd, E1);\n  }\n\n  template <class C>\n  typename C::CType compare(const SFunction* E, C& Cmp) const {\n    Cmp.enterScope(variableDecl(), E->variableDecl());\n    typename C::CType Ct = Cmp.compare(body(), E->body());\n    Cmp.leaveScope();\n    return Ct;\n  }\n\nprivate:\n  Variable *VarDecl;\n  SExpr* Body;\n}",
  "id": "BLOCK-CPP-21654",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h",
  "source_line": 724,
  "validation_status": "validated"
}