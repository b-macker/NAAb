{
  "code": "#include <memory>\n#include <string>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/fast_type_id.h\"\n#include \"absl/flags/internal/commandlineflag.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/types/optional.h\"\n\nusing namespace absl;\nusing namespace flags_internal;\nusing namespace flags_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03584_execute() {\n    {\n public:\n  constexpr CommandLineFlag() = default;\n\n  // Not copyable/assignable.\n  CommandLineFlag(const CommandLineFlag&) = delete;\n  CommandLineFlag& operator=(const CommandLineFlag&) = delete;\n\n  // absl::CommandLineFlag::IsOfType()\n  //\n  // Return true iff flag has type T.\n  template <typename T>\n  inline bool IsOfType() const {\n    return TypeId() == base_internal::FastTypeId<T>();\n  }\n\n  // absl::CommandLineFlag::TryGet()\n  //\n  // Attempts to retrieve the flag value. Returns value on success,\n  // absl::nullopt otherwise.\n  template <typename T>\n  absl::optional<T> TryGet() const {\n    if (IsRetired() || !IsOfType<T>()) {\n      return absl::nullopt;\n    }\n\n    // Implementation notes:\n    //\n    // We are wrapping a union around the value of `T` to serve three purposes:\n    //\n    //  1. `U.value` has correct size and alignment for a value of type `T`\n    //  2. The `U.value` constructor is not invoked since U's constructor does\n    //     not do it explicitly.\n    //  3. The `U.value` destructor is invoked since U's destructor does it\n    //     explicitly. This makes `U` a kind of RAII wrapper around non default\n    //     constructible value of T, which is destructed when we leave the\n    //     scope. We do need to destroy U.value, which is constructed by\n    //     CommandLineFlag::Read even though we left it in a moved-from state\n    //     after std::move.\n    //\n    // All of this serves to avoid requiring `T` being default constructible.\n    union U {\n      T value;\n      U() {}\n      ~U() { value.~T(); }\n    };\n    U u;\n\n    Read(&u.value);\n    // allow retired flags to be \"read\", so we can report invalid access.\n    if (IsRetired()) {\n      return absl::nullopt;\n    }\n    return std::move(u.value);\n  }\n\n  // absl::CommandLineFlag::Name()\n  //\n  // Returns name of this flag.\n  virtual absl::string_view Name() const = 0;\n\n  // absl::CommandLineFlag::Filename()\n  //\n  // Returns name of the file where this flag is defined.\n  virtual std::string Filename() const = 0;\n\n  // absl::CommandLineFlag::Help()\n  //\n  // Returns help message associated with this flag.\n  virtual std::string Help() const = 0;\n\n  // absl::CommandLineFlag::IsRetired()\n  //\n  // Returns true iff this object corresponds to retired flag.\n  virtual bool IsRetired() const;\n\n  // absl::CommandLineFlag::DefaultValue()\n  //\n  // Returns the default value for this flag.\n  virtual std::string DefaultValue() const = 0;\n\n  // absl::CommandLineFlag::CurrentValue()\n  //\n  // Returns the current value for this flag.\n  virtual std::string CurrentValue() const = 0;\n\n  // absl::CommandLineFlag::ParseFrom()\n  //\n  // Sets the value of the flag based on specified string `value`. If the flag\n  // was successfully set to new value, it returns true. Otherwise, sets `error`\n  // to indicate the error, leaves the flag unchanged, and returns false.\n  bool ParseFrom(absl::string_view value, std::string* error);\n\n protected:\n  ~CommandLineFlag() = default;\n\n private:\n  friend class flags_internal::PrivateHandleAccessor;\n\n  // Sets the value of the flag based on specified string `value`. If the flag\n  // was successfully set to new value, it returns true. Otherwise, sets `error`\n  // to indicate the error, leaves the flag unchanged, and returns false. There\n  // are three ways to set the flag's value:\n  //  * Update the current flag value\n  //  * Update the flag's default value\n  //  * Update the current flag value if it was never set before\n  // The mode is selected based on `set_mode` parameter.\n  virtual bool ParseFrom(absl::string_view value,\n                         flags_internal::FlagSettingMode set_mode,\n                         flags_internal::ValueSource source,\n                         std::string& error) = 0;\n\n  // Returns id of the flag's value type.\n  virtual flags_internal::FlagFastTypeId TypeId() const = 0;\n\n  // Interface to save flag to some persistent state. Returns current flag state\n  // or nullptr if flag does not support saving and restoring a state.\n  virtual std::unique_ptr<flags_internal::FlagStateInterface> SaveState() = 0;\n\n  // Copy-construct a new value of the flag's type in a memory referenced by\n  // the dst based on the current flag's value.\n  virtual void Read(void* dst) const = 0;\n\n  // To be deleted. Used to return true if flag's current value originated from\n  // command line.\n  virtual bool IsSpecifiedOnCommandLine() const = 0;\n\n  // Validates supplied value using validator or parseflag routine\n  virtual bool ValidateInputValue(absl::string_view value) const = 0;\n\n  // Checks that flags default value can be converted to string and back to the\n  // flag's value type.\n  virtual void CheckDefaultValueParsingRoundtrip() const = 0;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03584",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/commandlineflag.h",
  "source_line": 62,
  "validation_status": "validated"
}