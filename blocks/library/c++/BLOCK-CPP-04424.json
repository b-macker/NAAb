{
  "code": "{\n public:\n  // Value semantics.\n  constexpr Duration() : rep_hi_(0), rep_lo_(0) {}  // zero-length duration\n\n  // Copyable.\n#if !defined(__clang__) && defined(_MSC_VER) && _MSC_VER < 1930\n  // Explicitly defining the constexpr copy constructor avoids an MSVC bug.\n  constexpr Duration(const Duration& d)\n      : rep_hi_(d.rep_hi_), rep_lo_(d.rep_lo_) {}\n#else\n  constexpr Duration(const Duration& d) = default;\n#endif\n  Duration& operator=(const Duration& d) = default;\n\n  // Compound assignment operators.\n  Duration& operator+=(Duration d);\n  Duration& operator-=(Duration d);\n  Duration& operator*=(int64_t r);\n  Duration& operator*=(double r);\n  Duration& operator/=(int64_t r);\n  Duration& operator/=(double r);\n  Duration& operator%=(Duration rhs);\n\n  // Overloads that forward to either the int64_t or double overloads above.\n  // Integer operands must be representable as int64_t. Integer division is\n  // truncating, so values less than the resolution will be returned as zero.\n  // Floating-point multiplication and division is rounding (halfway cases\n  // rounding away from zero), so values less than the resolution may be\n  // returned as either the resolution or zero.  In particular, `d / 2.0`\n  // can produce `d` when it is the resolution and \"even\".\n  template <typename T, time_internal::EnableIfIntegral<T> = 0>\n  Duration& operator*=(T r) {\n    int64_t x = r;\n    return *this *= x;\n  }\n\n  template <typename T, time_internal::EnableIfIntegral<T> = 0>\n  Duration& operator/=(T r) {\n    int64_t x = r;\n    return *this /= x;\n  }\n\n  template <typename T, time_internal::EnableIfFloat<T> = 0>\n  Duration& operator*=(T r) {\n    double x = r;\n    return *this *= x;\n  }\n\n  template <typename T, time_internal::EnableIfFloat<T> = 0>\n  Duration& operator/=(T r) {\n    double x = r;\n    return *this /= x;\n  }\n\n  template <typename H>\n  friend H AbslHashValue(H h, Duration d) {\n    return H::combine(std::move(h), d.rep_hi_.Get(), d.rep_lo_);\n  }\n\n private:\n  friend constexpr int64_t time_internal::GetRepHi(Duration d);\n  friend constexpr uint32_t time_internal::GetRepLo(Duration d);\n  friend constexpr Duration time_internal::MakeDuration(int64_t hi,\n                                                        uint32_t lo);\n  constexpr Duration(int64_t hi, uint32_t lo) : rep_hi_(hi), rep_lo_(lo) {}\n\n  // We store `rep_hi_` 4-byte rather than 8-byte aligned to avoid 4 bytes of\n  // tail padding.\n  class HiRep {\n   public:\n    // Default constructor default-initializes `hi_`, which has the same\n    // semantics as default-initializing an `int64_t` (undetermined value).\n    HiRep() = default;\n\n    HiRep(const HiRep&) = default;\n    HiRep& operator=(const HiRep&) = default;\n\n    explicit constexpr HiRep(const int64_t value)\n        :  // C++17 forbids default-initialization in constexpr contexts. We can\n           // remove this in C++20.\n#if defined(ABSL_IS_BIG_ENDIAN) && ABSL_IS_BIG_ENDIAN\n          hi_(0),\n          lo_(0)\n#else\n          lo_(0),\n          hi_(0)\n#endif\n    {\n      *this = value;\n    }\n\n    constexpr int64_t Get() const {\n      const uint64_t unsigned_value =\n          (static_cast<uint64_t>(hi_) << 32) | static_cast<uint64_t>(lo_);\n      // `static_cast<int64_t>(unsigned_value)` is implementation-defined\n      // before c++20. On all supported platforms the behaviour is that mandated\n      // by c++20, i.e. \"If the destination type is signed, [...] the result is\n      // the unique value of the destination type equal to the source value\n      // modulo 2^n, where n is the number of bits used to represent the\n      // destination type.\"\n      static_assert(\n          (static_cast<int64_t>((std::numeric_limits<uint64_t>::max)()) ==\n           int64_t{-1}) &&\n              (static_cast<int64_t>(static_cast<uint64_t>(\n                                        (std::numeric_limits<int64_t>::max)()) +\n                                    1) ==\n               (std::numeric_limits<int64_t>::min)()),\n          \"static_cast<int64_t>(uint64_t) does not have c++20 semantics\");\n      return static_cast<int64_t>(unsigned_value);\n    }\n\n    constexpr HiRep& operator=(const int64_t value) {\n      // \"If the destination type is unsigned, the resulting value is the\n      // smallest unsigned value equal to the source value modulo 2^n\n      // where `n` is the number of bits used to represent the destination\n      // type\".\n      const auto unsigned_value = static_cast<uint64_t>(value);\n      hi_ = static_cast<uint32_t>(unsigned_value >> 32);\n      lo_ = static_cast<uint32_t>(unsigned_value);\n      return *this;\n    }\n\n   private:\n    // Notes:\n    //  - Ideally we would use a `char[]` and `std::bitcast`, but the latter\n    //    does not exist (and is not constexpr in `absl`) before c++20.\n    //  - Order is optimized depending on endianness so that the compiler can\n    //    turn `Get()` (resp. `operator=()`) into a single 8-byte load (resp.\n    //    store).\n#if defined(ABSL_IS_BIG_ENDIAN) && ABSL_IS_BIG_ENDIAN\n    uint32_t hi_;\n    uint32_t lo_;\n#else\n    uint32_t lo_;\n    uint32_t hi_;\n#endif\n  };\n  HiRep rep_hi_;\n  uint32_t rep_lo_;\n}",
  "id": "BLOCK-CPP-04424",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 166,
  "validation_status": "validated"
}