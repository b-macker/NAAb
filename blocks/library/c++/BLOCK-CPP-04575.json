{
  "code": "{\n\n// Platform specific logic extracted from\n// https://chromium.googlesource.com/linux-syscall-support/+/master/linux_syscall_support.h\ninline void* DirectMmap(void* start, size_t length, int prot, int flags, int fd,\n                        off_t offset) noexcept {\n#if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || \\\n    defined(__m68k__) || defined(__sh__) ||                                  \\\n    (defined(__hppa__) && !defined(__LP64__)) ||                             \\\n    (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \\\n    (defined(__PPC__) && !defined(__PPC64__)) ||                             \\\n    (defined(__riscv) && __riscv_xlen == 32) ||                              \\\n    (defined(__s390__) && !defined(__s390x__)) ||                            \\\n    (defined(__sparc__) && !defined(__arch64__))\n  // On these architectures, implement mmap with mmap2.\n  static int pagesize = 0;\n  if (pagesize == 0) {\n#if defined(__wasm__) || defined(__asmjs__)\n    pagesize = getpagesize();\n#else\n    pagesize = sysconf(_SC_PAGESIZE);\n#endif\n  }\n  if (offset < 0 || offset % pagesize != 0) {\n    errno = EINVAL;\n    return MAP_FAILED;\n  }\n#ifdef __BIONIC__\n  // SYS_mmap2 has problems on Android API level <= 16.\n  // Workaround by invoking __mmap2() instead.\n  return __mmap2(start, length, prot, flags, fd,\n                 static_cast<size_t>(offset / pagesize));\n#else\n  return reinterpret_cast<void*>(\n      syscall(SYS_mmap2, start, length, prot, flags, fd,\n              static_cast<unsigned long>(offset / pagesize)));  // NOLINT\n#endif\n#elif defined(__s390x__)\n  // On s390x, mmap() arguments are passed in memory.\n  unsigned long buf[6] = {reinterpret_cast<unsigned long>(start),  // NOLINT\n                          static_cast<unsigned long>(length),      // NOLINT\n                          static_cast<unsigned long>(prot),        // NOLINT\n                          static_cast<unsigned long>(flags),       // NOLINT\n                          static_cast<unsigned long>(fd),          // NOLINT\n                          static_cast<unsigned long>(offset)};     // NOLINT\n  return reinterpret_cast<void*>(syscall(SYS_mmap, buf));\n#elif defined(__x86_64__)\n// The x32 ABI has 32 bit longs, but the syscall interface is 64 bit.\n// We need to explicitly cast to an unsigned 64 bit type to avoid implicit\n// sign extension.  We can't cast pointers directly because those are\n// 32 bits, and gcc will dump ugly warnings about casting from a pointer\n// to an integer of a different size. We also need to make sure __off64_t\n// isn't truncated to 32-bits under x32.\n#define MMAP_SYSCALL_ARG(x) ((uint64_t)(uintptr_t)(x))\n  return reinterpret_cast<void*>(\n      syscall(SYS_mmap, MMAP_SYSCALL_ARG(start), MMAP_SYSCALL_ARG(length),\n              MMAP_SYSCALL_ARG(prot), MMAP_SYSCALL_ARG(flags),\n              MMAP_SYSCALL_ARG(fd), static_cast<uint64_t>(offset)));\n#undef MMAP_SYSCALL_ARG\n#else  // Remaining 64-bit aritectures.\n  static_assert(sizeof(unsigned long) == 8, \"Platform is not 64-bit\");\n  return reinterpret_cast<void*>(\n      syscall(SYS_mmap, start, length, prot, flags, fd, offset));\n#endif\n}\n\ninline int DirectMunmap(void* start, size_t length) {\n  return static_cast<int>(syscall(SYS_munmap, start, length));\n}\n\n}",
  "id": "BLOCK-CPP-04575",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/direct_mmap.h",
  "source_line": 70,
  "validation_status": "validated"
}