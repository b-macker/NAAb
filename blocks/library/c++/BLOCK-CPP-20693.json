{
  "code": "{\n    /// The template argument list at a certain template depth\n\n    using ArgList = ArrayRef<TemplateArgument>;\n    struct ArgumentListLevel {\n      llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndFinal;\n      ArgList Args;\n    };\n    using ContainerType = SmallVector<ArgumentListLevel, 4>;\n\n    using ArgListsIterator = ContainerType::iterator;\n    using ConstArgListsIterator = ContainerType::const_iterator;\n\n    /// The template argument lists, stored from the innermost template\n    /// argument list (first) to the outermost template argument list (last).\n    ContainerType TemplateArgumentLists;\n\n    /// The number of outer levels of template arguments that are not\n    /// being substituted.\n    unsigned NumRetainedOuterLevels = 0;\n\n    /// The kind of substitution described by this argument list.\n    TemplateSubstitutionKind Kind = TemplateSubstitutionKind::Specialization;\n\n  public:\n    /// Construct an empty set of template argument lists.\n    MultiLevelTemplateArgumentList() = default;\n\n    /// Construct a single-level template argument list.\n    MultiLevelTemplateArgumentList(Decl *D, ArgList Args, bool Final) {\n      addOuterTemplateArguments(D, Args, Final);\n    }\n\n    void setKind(TemplateSubstitutionKind K) { Kind = K; }\n\n    /// Determine the kind of template substitution being performed.\n    TemplateSubstitutionKind getKind() const { return Kind; }\n\n    /// Determine whether we are rewriting template parameters rather than\n    /// substituting for them. If so, we should not leave references to the\n    /// original template parameters behind.\n    bool isRewrite() const {\n      return Kind == TemplateSubstitutionKind::Rewrite;\n    }\n\n    /// Determine the number of levels in this template argument\n    /// list.\n    unsigned getNumLevels() const {\n      return TemplateArgumentLists.size() + NumRetainedOuterLevels;\n    }\n\n    /// Determine the number of substituted levels in this template\n    /// argument list.\n    unsigned getNumSubstitutedLevels() const {\n      return TemplateArgumentLists.size();\n    }\n\n    // Determine the number of substituted args at 'Depth'.\n    unsigned getNumSubsitutedArgs(unsigned Depth) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size();\n    }\n\n    unsigned getNumRetainedOuterLevels() const {\n      return NumRetainedOuterLevels;\n    }\n\n    /// Determine how many of the \\p OldDepth outermost template parameter\n    /// lists would be removed by substituting these arguments.\n    unsigned getNewDepth(unsigned OldDepth) const {\n      if (OldDepth < NumRetainedOuterLevels)\n        return OldDepth;\n      if (OldDepth < getNumLevels())\n        return NumRetainedOuterLevels;\n      return OldDepth - TemplateArgumentLists.size();\n    }\n\n    /// Retrieve the template argument at a given depth and index.\n    const TemplateArgument &operator()(unsigned Depth, unsigned Index) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index <\n             TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1].Args[Index];\n    }\n\n    /// A template-like entity which owns the whole pattern being substituted.\n    /// This will usually own a set of template parameters, or in some\n    /// cases might even be a template parameter itself.\n    std::pair<Decl *, bool> getAssociatedDecl(unsigned Depth) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      auto AD = TemplateArgumentLists[getNumLevels() - Depth - 1]\n                    .AssociatedDeclAndFinal;\n      return {AD.getPointer(), AD.getInt()};\n    }\n\n    /// Determine whether there is a non-NULL template argument at the\n    /// given depth and index.\n    ///\n    /// There must exist a template argument list at the given depth.\n    bool hasTemplateArgument(unsigned Depth, unsigned Index) const {\n      assert(Depth < getNumLevels());\n\n      if (Depth < NumRetainedOuterLevels)\n        return false;\n\n      if (Index >=\n          TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size())\n        return false;\n\n      return !(*this)(Depth, Index).isNull();\n    }\n\n    bool isAnyArgInstantiationDependent() const {\n      for (ArgumentListLevel ListLevel : TemplateArgumentLists)\n        for (const TemplateArgument &TA : ListLevel.Args)\n          if (TA.isInstantiationDependent())\n            return true;\n      return false;\n    }\n\n    /// Clear out a specific template argument.\n    void setArgument(unsigned Depth, unsigned Index,\n                     TemplateArgument Arg) {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index <\n             TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size());\n      const_cast<TemplateArgument &>(\n          TemplateArgumentLists[getNumLevels() - Depth - 1].Args[Index]) = Arg;\n    }\n\n    /// Add a new outmost level to the multi-level template argument\n    /// list.\n    /// A 'Final' substitution means that Subst* nodes won't be built\n    /// for the replacements.\n    void addOuterTemplateArguments(Decl *AssociatedDecl, ArgList Args,\n                                   bool Final) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      assert(getKind() == TemplateSubstitutionKind::Specialization);\n      TemplateArgumentLists.push_back(\n          {{AssociatedDecl->getCanonicalDecl(), Final}, Args});\n    }\n\n    void addOuterTemplateArguments(ArgList Args) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      assert(getKind() == TemplateSubstitutionKind::Rewrite);\n      TemplateArgumentLists.push_back({{}, Args});\n    }\n\n    void addOuterTemplateArguments(std::nullopt_t) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      TemplateArgumentLists.push_back({});\n    }\n\n    /// Replaces the current 'innermost' level with the provided argument list.\n    /// This is useful for type deduction cases where we need to get the entire\n    /// list from the AST, but then add the deduced innermost list.\n    void replaceInnermostTemplateArguments(Decl *AssociatedDecl, ArgList Args) {\n      assert((!TemplateArgumentLists.empty() || NumRetainedOuterLevels) &&\n             \"Replacing in an empty list?\");\n\n      if (!TemplateArgumentLists.empty()) {\n        assert((TemplateArgumentLists[0].AssociatedDeclAndFinal.getPointer() ||\n                TemplateArgumentLists[0].AssociatedDeclAndFinal.getPointer() ==\n                    AssociatedDecl) &&\n               \"Trying to change incorrect declaration?\");\n        TemplateArgumentLists[0].Args = Args;\n      } else {\n        --NumRetainedOuterLevels;\n        TemplateArgumentLists.push_back(\n            {{AssociatedDecl, /*Final=*/false}, Args});\n      }\n    }\n\n    /// Add an outermost level that we are not substituting. We have no\n    /// arguments at this level, and do not remove it from the depth of inner\n    /// template parameters that we instantiate.\n    void addOuterRetainedLevel() {\n      ++NumRetainedOuterLevels;\n    }\n    void addOuterRetainedLevels(unsigned Num) {\n      NumRetainedOuterLevels += Num;\n    }\n\n    /// Retrieve the innermost template argument list.\n    const ArgList &getInnermost() const {\n      return TemplateArgumentLists.front().Args;\n    }\n    /// Retrieve the outermost template argument list.\n    const ArgList &getOutermost() const {\n      return TemplateArgumentLists.back().Args;\n    }\n    ArgListsIterator begin() { return TemplateArgumentLists.begin(); }\n    ConstArgListsIterator begin() const {\n      return TemplateArgumentLists.begin();\n    }\n    ArgListsIterator end() { return TemplateArgumentLists.end(); }\n    ConstArgListsIterator end() const { return TemplateArgumentLists.end(); }\n\n    LLVM_DUMP_METHOD void dump() const {\n      LangOptions LO;\n      LO.CPlusPlus = true;\n      LO.Bool = true;\n      PrintingPolicy PP(LO);\n      llvm::errs() << \"NumRetainedOuterLevels: \" << NumRetainedOuterLevels\n                   << \"\\n\";\n      for (unsigned Depth = NumRetainedOuterLevels; Depth < getNumLevels();\n           ++Depth) {\n        llvm::errs() << Depth << \": \";\n        printTemplateArgumentList(\n            llvm::errs(),\n            TemplateArgumentLists[getNumLevels() - Depth - 1].Args, PP);\n        llvm::errs() << \"\\n\";\n      }\n    }\n  }",
  "id": "BLOCK-CPP-20693",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Template.h",
  "source_line": 76,
  "validation_status": "validated"
}