{
  "code": "{\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\nconstexpr char FutexWaiter::kName[];\n#endif\n\nint FutexWaiter::WaitUntil(std::atomic<int32_t>* v, int32_t val,\n                           KernelTimeout t) {\n#ifdef CLOCK_MONOTONIC\n  constexpr bool kHasClockMonotonic = true;\n#else\n  constexpr bool kHasClockMonotonic = false;\n#endif\n\n  // We can't call Futex::WaitUntil() here because the prodkernel implementation\n  // does not know about KernelTimeout::SupportsSteadyClock().\n  if (!t.has_timeout()) {\n    return Futex::Wait(v, val);\n  } else if (kHasClockMonotonic && KernelTimeout::SupportsSteadyClock() &&\n             t.is_relative_timeout()) {\n    auto rel_timespec = t.MakeRelativeTimespec();\n    return Futex::WaitRelativeTimeout(v, val, &rel_timespec);\n  } else {\n    auto abs_timespec = t.MakeAbsTimespec();\n    return Futex::WaitAbsoluteTimeout(v, val, &abs_timespec);\n  }\n}\n\nbool FutexWaiter::Wait(KernelTimeout t) {\n  // Loop until we can atomically decrement futex from a positive\n  // value, waiting on a futex while we believe it is zero.\n  // Note that, since the thread ticker is just reset, we don't need to check\n  // whether the thread is idle on the very first pass of the loop.\n  bool first_pass = true;\n  while (true) {\n    int32_t x = futex_.load(std::memory_order_relaxed);\n    while (x != 0) {\n      if (!futex_.compare_exchange_weak(x, x - 1,\n                                        std::memory_order_acquire,\n                                        std::memory_order_relaxed)) {\n        continue;  // Raced with someone, retry.\n      }\n      return true;  // Consumed a wakeup, we are done.\n    }\n\n    if (!first_pass) MaybeBecomeIdle();\n    const int err = WaitUntil(&futex_, 0, t);\n    if (err != 0) {\n      if (err == -EINTR || err == -EWOULDBLOCK) {\n        // Do nothing, the loop will retry.\n      } else if (err == -ETIMEDOUT) {\n        return false;\n      } else {\n        ABSL_RAW_LOG(FATAL, \"Futex operation failed with error %d\\n\", err);\n      }\n    }\n    first_pass = false;\n  }\n}\n\nvoid FutexWaiter::Post() {\n  if (futex_.fetch_add(1, std::memory_order_release) == 0) {\n    // We incremented from 0, need to wake a potential waiter.\n    Poke();\n  }\n}\n\nvoid FutexWaiter::Poke() {\n  // Wake one thread waiting on the futex.\n  const int err = Futex::Wake(&futex_, 1);\n  if (ABSL_PREDICT_FALSE(err < 0)) {\n    ABSL_RAW_LOG(FATAL, \"Futex operation failed with error %d\\n\", err);\n  }\n}\n\n}",
  "id": "BLOCK-CPP-03129",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/futex_waiter.cc",
  "source_line": 32,
  "validation_status": "validated"
}