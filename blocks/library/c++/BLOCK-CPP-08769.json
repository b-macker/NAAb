{
  "code": "{\n  // Note this is not a PointerIntPair because we need the address of the\n  // non-group case to be valid as a Decl** for iteration.\n  enum Kind { SingleDeclKind=0x0, DeclGroupKind=0x1, Mask=0x1 };\n\n  Decl* D = nullptr;\n\n  Kind getKind() const {\n    return (Kind) (reinterpret_cast<uintptr_t>(D) & Mask);\n  }\n\npublic:\n  DeclGroupRef() = default;\n  explicit DeclGroupRef(Decl* d) : D(d) {}\n  explicit DeclGroupRef(DeclGroup* dg)\n    : D((Decl*) (reinterpret_cast<uintptr_t>(dg) | DeclGroupKind)) {}\n\n  static DeclGroupRef Create(ASTContext &C, Decl **Decls, unsigned NumDecls) {\n    if (NumDecls == 0)\n      return DeclGroupRef();\n    if (NumDecls == 1)\n      return DeclGroupRef(Decls[0]);\n    return DeclGroupRef(DeclGroup::Create(C, Decls, NumDecls));\n  }\n\n  using iterator = Decl **;\n  using const_iterator = Decl * const *;\n\n  bool isNull() const { return D == nullptr; }\n  bool isSingleDecl() const { return getKind() == SingleDeclKind; }\n  bool isDeclGroup() const { return getKind() == DeclGroupKind; }\n\n  Decl *getSingleDecl() {\n    assert(isSingleDecl() && \"Isn't a single decl\");\n    return D;\n  }\n  const Decl *getSingleDecl() const {\n    return const_cast<DeclGroupRef*>(this)->getSingleDecl();\n  }\n\n  DeclGroup &getDeclGroup() {\n    assert(isDeclGroup() && \"Isn't a declgroup\");\n    return *((DeclGroup*)(reinterpret_cast<uintptr_t>(D) & ~Mask));\n  }\n  const DeclGroup &getDeclGroup() const {\n    return const_cast<DeclGroupRef*>(this)->getDeclGroup();\n  }\n\n  iterator begin() {\n    if (isSingleDecl())\n      return D ? &D : nullptr;\n    return &getDeclGroup()[0];\n  }\n\n  iterator end() {\n    if (isSingleDecl())\n      return D ? &D+1 : nullptr;\n    DeclGroup &G = getDeclGroup();\n    return &G[0] + G.size();\n  }\n\n  const_iterator begin() const {\n    if (isSingleDecl())\n      return D ? &D : nullptr;\n    return &getDeclGroup()[0];\n  }\n\n  const_iterator end() const {\n    if (isSingleDecl())\n      return D ? &D+1 : nullptr;\n    const DeclGroup &G = getDeclGroup();\n    return &G[0] + G.size();\n  }\n\n  void *getAsOpaquePtr() const { return D; }\n  static DeclGroupRef getFromOpaquePtr(void *Ptr) {\n    DeclGroupRef X;\n    X.D = static_cast<Decl*>(Ptr);\n    return X;\n  }\n}",
  "id": "BLOCK-CPP-08769",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclGroup.h",
  "source_line": 51,
  "validation_status": "validated"
}