{
  "code": "#include <sys/types.h>\n#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/base/port.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04726_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\n// Nominal core processor cycles per second of each processor.   This is _not_\n// necessarily the frequency of the CycleClock counter (see cycleclock.h)\n// Thread-safe.\ndouble NominalCPUFrequency();\n\n// Number of logical processors (hyperthreads) in system. Thread-safe.\nint NumCPUs();\n\n// Return the thread id of the current thread, as told by the system.\n// No two currently-live threads implemented by the OS shall have the same ID.\n// Thread ids of exited threads may be reused.   Multiple user-level threads\n// may have the same thread ID if multiplexed on the same OS thread.\n//\n// On Linux, you may send a signal to the resulting ID with kill().  However,\n// it is recommended for portability that you use pthread_kill() instead.\n#ifdef _WIN32\n// On Windows, process id and thread id are of the same type according to the\n// return types of GetProcessId() and GetThreadId() are both DWORD, an unsigned\n// 32-bit type.\nusing pid_t = uint32_t;\n#endif\npid_t GetTID();\n\n// Like GetTID(), but caches the result in thread-local storage in order\n// to avoid unnecessary system calls. Note that there are some cases where\n// one must call through to GetTID directly, which is why this exists as a\n// separate function. For example, GetCachedTID() is not safe to call in\n// an asynchronous signal-handling context nor right after a call to fork().\npid_t GetCachedTID();\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04726",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/sysinfo.h",
  "source_line": 36,
  "validation_status": "validated"
}