{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// int128\n//\n// A signed 128-bit integer type. The API is meant to mimic an intrinsic\n// integral type as closely as is practical, including exhibiting undefined\n// behavior in analogous cases (e.g. division by zero).\n//\n// An `int128` supports the following:\n//\n//   * Implicit construction from integral types\n//   * Explicit conversion to integral types\n//\n// However, an `int128` differs from intrinsic integral types in the following\n// ways:\n//\n//   * It is not implicitly convertible to other integral types.\n//   * Requires explicit construction from and conversion to floating point\n//     types.\n\n// Additionally, if your compiler supports `__int128`, `int128` is\n// interoperable with that type. (Abseil checks for this compatibility through\n// the `ABSL_HAVE_INTRINSIC_INT128` macro.)\n//\n// The design goal for `int128` is that it will be compatible with a future\n// `int128_t`, if that type becomes a part of the standard.\n//\n// Example:\n//\n//     float y = absl::int128(17);  // Error. int128 cannot be implicitly\n//                                  // converted to float.\n//\n//     absl::int128 v;\n//     int64_t i = v;                        // Error\n//     int64_t i = static_cast<int64_t>(v);  // OK\n//\nclass int128 {\n public:\n  int128() = default;\n\n  // Constructors from arithmetic types\n  constexpr int128(int v);                 // NOLINT(runtime/explicit)\n  constexpr int128(unsigned int v);        // NOLINT(runtime/explicit)\n  constexpr int128(long v);                // NOLINT(runtime/int)\n  constexpr int128(unsigned long v);       // NOLINT(runtime/int)\n  constexpr int128(long long v);           // NOLINT(runtime/int)\n  constexpr int128(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr int128(__int128 v);  // NOLINT(runtime/explicit)\n  constexpr explicit int128(unsigned __int128 v);\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  constexpr explicit int128(uint128 v);\n  explicit int128(float v);\n  explicit int128(double v);\n  explicit int128(long double v);\n\n  // Assignment operators from arithmetic types\n  int128& operator=(int v);\n  int128& operator=(unsigned int v);\n  int128& operator=(long v);                // NOLINT(runtime/int)\n  int128& operator=(unsigned long v);       // NOLINT(runtime/int)\n  int128& operator=(long long v);           // NOLINT(runtime/int)\n  int128& operator=(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  int128& operator=(__int128 v);\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n\n  // Conversion operators to other arithmetic types\n  constexpr explicit operator bool() const;\n  constexpr explicit operator char() const;\n  constexpr explicit operator signed char() const;\n  constexpr explicit operator unsigned char() const;\n  constexpr explicit operator char16_t() const;\n  constexpr explicit operator char32_t() const;\n  constexpr explicit operator ABSL_INTERNAL_WCHAR_T() const;\n  constexpr explicit operator short() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned short() const;\n  constexpr explicit operator int() const;\n  constexpr explicit operator unsigned int() const;\n  constexpr explicit operator long() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator long long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long long() const;\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr explicit operator __int128() const;\n  constexpr explicit operator unsigned __int128() const;\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  explicit operator float() const;\n  explicit operator double() const;\n  explicit operator long double() const;\n\n  // Trivial copy constructor, assignment operator and destructor.\n\n  // Arithmetic operators\n  int128& operator+=(int128 other);\n  int128& operator-=(int128 other);\n  int128& operator*=(int128 other);\n  int128& operator/=(int128 other);\n  int128& operator%=(int128 other);\n  int128 operator++(int);  // postfix increment: i++\n  int128 operator--(int);  // postfix decrement: i--\n  int128& operator++();    // prefix increment:  ++i\n  int128& operator--();    // prefix decrement:  --i\n  int128& operator&=(int128 other);\n  int128& operator|=(int128 other);\n  int128& operator^=(int128 other);\n  int128& operator<<=(int amount);\n  int128& operator>>=(int amount);\n\n  // Int128Low64()\n  //\n  // Returns the lower 64-bit value of a `int128` value.\n  friend constexpr uint64_t Int128Low64(int128 v);\n\n  // Int128High64()\n  //\n  // Returns the higher 64-bit value of a `int128` value.\n  friend constexpr int64_t Int128High64(int128 v);\n\n  // MakeInt128()\n  //\n  // Constructs a `int128` numeric value from two 64-bit integers. Note that\n  // signedness is conveyed in the upper `high` value.\n  //\n  //   (absl::int128(1) << 64) * high + low\n  //\n  // Note that this factory function is the only way to construct a `int128`\n  // from integer values greater than 2^64 or less than -2^64.\n  //\n  // Example:\n  //\n  //   absl::int128 big = absl::MakeInt128(1, 0);\n  //   absl::int128 big_n = absl::MakeInt128(-1, 0);\n  friend constexpr int128 MakeInt128(int64_t high, uint64_t low);\n\n  // Int128Max()\n  //\n  // Returns the maximum value for a 128-bit signed integer.\n  friend constexpr int128 Int128Max();\n\n  // Int128Min()\n  //\n  // Returns the minimum value for a 128-bit signed integer.\n  friend constexpr int128 Int128Min();\n\n  // Support for absl::Hash.\n  template <typename H>\n  friend H AbslHashValue(H h, int128 v) {\n    return H::combine(std::move(h), Int128High64(v), Int128Low64(v));\n  }\n\n  // Support for absl::StrCat() etc.\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, int128 v) {\n    sink.Append(v.ToString());\n  }\n\n private:\n  constexpr int128(int64_t high, uint64_t low);\n\n  std::string ToString() const;\n\n#if defined(ABSL_HAVE_INTRINSIC_INT128)\n  __int128 v_;\n#else  // ABSL_HAVE_INTRINSIC_INT128\n#if defined(ABSL_IS_LITTLE_ENDIAN)\n  uint64_t lo_;\n  int64_t hi_;\n#elif defined(ABSL_IS_BIG_ENDIAN)\n  int64_t hi_;\n  uint64_t lo_;\n#else  // byte order\n#error \"Unsupported byte order: must be little-endian or big-endian.\"\n#endif  // byte order\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n};\n\nstd::ostream& operator<<(std::ostream& os, int128 v);\n\n// TODO(absl-team) add operator>>(std::istream&, int128)\n\nconstexpr int128 Int128Max() {\n  return int128((std::numeric_limits<int64_t>::max)(),\n                (std::numeric_limits<uint64_t>::max)());\n}\n\nconstexpr int128 Int128Min() {\n  return int128((std::numeric_limits<int64_t>::min)(), 0);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03779",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.h",
  "source_line": 310,
  "validation_status": "validated"
}