{
  "code": "{\n\nnamespace ast_matchers {\n\n/// A class to allow finding matches over the Clang AST.\n///\n/// After creation, you can add multiple matchers to the MatchFinder via\n/// calls to addMatcher(...).\n///\n/// Once all matchers are added, newASTConsumer() returns an ASTConsumer\n/// that will trigger the callbacks specified via addMatcher(...) when a match\n/// is found.\n///\n/// The order of matches is guaranteed to be equivalent to doing a pre-order\n/// traversal on the AST, and applying the matchers in the order in which they\n/// were added to the MatchFinder.\n///\n/// See ASTMatchers.h for more information about how to create matchers.\n///\n/// Not intended to be subclassed.\nclass MatchFinder {\npublic:\n  /// Contains all information for a given match.\n  ///\n  /// Every time a match is found, the MatchFinder will invoke the registered\n  /// MatchCallback with a MatchResult containing information about the match.\n  struct MatchResult {\n    MatchResult(const BoundNodes &Nodes, clang::ASTContext *Context);\n\n    /// Contains the nodes bound on the current match.\n    ///\n    /// This allows user code to easily extract matched AST nodes.\n    const BoundNodes Nodes;\n\n    /// Utilities for interpreting the matched AST structures.\n    /// @{\n    clang::ASTContext * const Context;\n    clang::SourceManager * const SourceManager;\n    /// @}\n  };\n\n  /// Called when the Match registered for it was successfully found\n  /// in the AST.\n  class MatchCallback {\n  public:\n    virtual ~MatchCallback();\n\n    /// Called on every match by the \\c MatchFinder.\n    virtual void run(const MatchResult &Result) = 0;\n\n    /// Called at the start of each translation unit.\n    ///\n    /// Optionally override to do per translation unit tasks.\n    virtual void onStartOfTranslationUnit() {}\n\n    /// Called at the end of each translation unit.\n    ///\n    /// Optionally override to do per translation unit tasks.\n    virtual void onEndOfTranslationUnit() {}\n\n    /// An id used to group the matchers.\n    ///\n    /// This id is used, for example, for the profiling output.\n    /// It defaults to \"<unknown>\".\n    virtual StringRef getID() const;\n\n    /// TraversalKind to use while matching and processing\n    /// the result nodes. This API is temporary to facilitate\n    /// third parties porting existing code to the default\n    /// behavior of clang-tidy.\n    virtual std::optional<TraversalKind> getCheckTraversalKind() const;\n  };\n\n  /// Called when parsing is finished. Intended for testing only.\n  class ParsingDoneTestCallback {\n  public:\n    virtual ~ParsingDoneTestCallback();\n    virtual void run() = 0;\n  };\n\n  struct MatchFinderOptions {\n    struct Profiling {\n      Profiling(llvm::StringMap<llvm::TimeRecord> &Records)\n          : Records(Records) {}\n\n      /// Per bucket timing information.\n      llvm::StringMap<llvm::TimeRecord> &Records;\n    };\n\n    /// Enables per-check timers.\n    ///\n    /// It prints a report after match.\n    std::optional<Profiling> CheckProfiling;\n  };\n\n  MatchFinder(MatchFinderOptions Options = MatchFinderOptions());\n  ~MatchFinder();\n\n  /// Adds a matcher to execute when running over the AST.\n  ///\n  /// Calls 'Action' with the BoundNodes on every match.\n  /// Adding more than one 'NodeMatch' allows finding different matches in a\n  /// single pass over the AST.\n  ///\n  /// Does not take ownership of 'Action'.\n  /// @{\n  void addMatcher(const DeclarationMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const TypeMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const StatementMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const NestedNameSpecifierMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const NestedNameSpecifierLocMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const TypeLocMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const CXXCtorInitializerMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const TemplateArgumentLocMatcher &NodeMatch,\n                  MatchCallback *Action);\n  void addMatcher(const AttrMatcher &NodeMatch, MatchCallback *Action);\n  /// @}\n\n  /// Adds a matcher to execute when running over the AST.\n  ///\n  /// This is similar to \\c addMatcher(), but it uses the dynamic interface. It\n  /// is more flexible, but the lost type information enables a caller to pass\n  /// a matcher that cannot match anything.\n  ///\n  /// \\returns \\c true if the matcher is a valid top-level matcher, \\c false\n  ///   otherwise.\n  bool addDynamicMatcher(const internal::DynTypedMatcher &NodeMatch,\n                         MatchCallback *Action);\n\n  /// Creates a clang ASTConsumer that finds all matches.\n  std::unique_ptr<clang::ASTConsumer> newASTConsumer();\n\n  /// Calls the registered callbacks on all matches on the given \\p Node.\n  ///\n  /// Note that there can be multiple matches on a single node, for\n  /// example when using decl(forEachDescendant(stmt())).\n  ///\n  /// @{\n  template <typename T> void match(const T &Node, ASTContext &Context) {\n    match(clang::DynTypedNode::create(Node), Context);\n  }\n  void match(const clang::DynTypedNode &Node, ASTContext &Context);\n  /// @}\n\n  /// Finds all matches in the given AST.\n  void matchAST(ASTContext &Context);\n\n  /// Registers a callback to notify the end of parsing.\n  ///\n  /// The provided closure is called after parsing is done, before the AST is\n  /// traversed. Useful for benchmarking.\n  /// Each call to FindAll(...) will call the closure once.\n  void registerTestCallbackAfterParsing(ParsingDoneTestCallback *ParsingDone);\n\n  /// For each \\c Matcher<> a \\c MatchCallback that will be called\n  /// when it matches.\n  struct MatchersByType {\n    std::vector<std::pair<internal::DynTypedMatcher, MatchCallback *>>\n        DeclOrStmt;\n    std::vector<std::pair<TypeMatcher, MatchCallback *>> Type;\n    std::vector<std::pair<NestedNameSpecifierMatcher, MatchCallback *>>\n        NestedNameSpecifier;\n    std::vector<std::pair<NestedNameSpecifierLocMatcher, MatchCallback *>>\n        NestedNameSpecifierLoc;\n    std::vector<std::pair<TypeLocMatcher, MatchCallback *>> TypeLoc;\n    std::vector<std::pair<CXXCtorInitializerMatcher, MatchCallback *>> CtorInit;\n    std::vector<std::pair<TemplateArgumentLocMatcher, MatchCallback *>>\n        TemplateArgumentLoc;\n    std::vector<std::pair<AttrMatcher, MatchCallback *>> Attr;\n    /// All the callbacks in one container to simplify iteration.\n    llvm::SmallPtrSet<MatchCallback *, 16> AllCallbacks;\n  };\n\nprivate:\n  MatchersByType Matchers;\n\n  MatchFinderOptions Options;\n\n  /// Called when parsing is done.\n  ParsingDoneTestCallback *ParsingDone;\n};\n\n/// Returns the results of matching \\p Matcher on \\p Node.\n///\n/// Collects the \\c BoundNodes of all callback invocations when matching\n/// \\p Matcher on \\p Node and returns the collected results.\n///\n/// Multiple results occur when using matchers like \\c forEachDescendant,\n/// which generate a result for each sub-match.\n///\n/// If you want to find all matches on the sub-tree rooted at \\c Node (rather\n/// than only the matches on \\c Node itself), surround the \\c Matcher with a\n/// \\c findAll().\n///\n/// \\see selectFirst\n/// @{\ntemplate <typename MatcherT, typename NodeT>\nSmallVector<BoundNodes, 1>\nmatch(MatcherT Matcher, const NodeT &Node, ASTContext &Context);\n\ntemplate <typename MatcherT>\nSmallVector<BoundNodes, 1> match(MatcherT Matcher, const DynTypedNode &Node,\n                                 ASTContext &Context);\n/// @}\n\n/// Returns the results of matching \\p Matcher on the translation unit of\n/// \\p Context and collects the \\c BoundNodes of all callback invocations.\ntemplate <typename MatcherT>\nSmallVector<BoundNodes, 1> match(MatcherT Matcher, ASTContext &Context);\n\n/// Returns the first result of type \\c NodeT bound to \\p BoundTo.\n///\n/// Returns \\c NULL if there is no match, or if the matching node cannot be\n/// casted to \\c NodeT.\n///\n/// This is useful in combanation with \\c match():\n/// \\code\n///   const Decl *D = selectFirst<Decl>(\"id\", match(Matcher.bind(\"id\"),\n///                                                 Node, Context));\n/// \\endcode\ntemplate <typename NodeT>\nconst NodeT *\nselectFirst(StringRef BoundTo, const SmallVectorImpl<BoundNodes> &Results) {\n  for (const BoundNodes &N : Results) {\n    if (const NodeT *Node = N.getNodeAs<NodeT>(BoundTo))\n      return Node;\n  }\n  return nullptr;\n}\n\nnamespace internal {\nclass CollectMatchesCallback : public MatchFinder::MatchCallback {\npublic:\n  void run(const MatchFinder::MatchResult &Result) override {\n    Nodes.push_back(Result.Nodes);\n  }\n\n  std::optional<TraversalKind> getCheckTraversalKind() const override {\n    return std::nullopt;\n  }\n\n  SmallVector<BoundNodes, 1> Nodes;\n};\n}\n\ntemplate <typename MatcherT>\nSmallVector<BoundNodes, 1> match(MatcherT Matcher, const DynTypedNode &Node,\n                                 ASTContext &Context) {\n  internal::CollectMatchesCallback Callback;\n  MatchFinder Finder;\n  Finder.addMatcher(Matcher, &Callback);\n  Finder.match(Node, Context);\n  return std::move(Callback.Nodes);\n}\n\ntemplate <typename MatcherT, typename NodeT>\nSmallVector<BoundNodes, 1>\nmatch(MatcherT Matcher, const NodeT &Node, ASTContext &Context) {\n  return match(Matcher, DynTypedNode::create(Node), Context);\n}\n\ntemplate <typename MatcherT>\nSmallVector<BoundNodes, 1>\nmatch(MatcherT Matcher, ASTContext &Context) {\n  internal::CollectMatchesCallback Callback;\n  MatchFinder Finder;\n  Finder.addMatcher(Matcher, &Callback);\n  Finder.matchAST(Context);\n  return std::move(Callback.Nodes);\n}\n\ninline SmallVector<BoundNodes, 1>\nmatchDynamic(internal::DynTypedMatcher Matcher, const DynTypedNode &Node,\n             ASTContext &Context) {\n  internal::CollectMatchesCallback Callback;\n  MatchFinder Finder;\n  Finder.addDynamicMatcher(Matcher, &Callback);\n  Finder.match(Node, Context);\n  return std::move(Callback.Nodes);\n}\n\ntemplate <typename NodeT>\nSmallVector<BoundNodes, 1> matchDynamic(internal::DynTypedMatcher Matcher,\n                                        const NodeT &Node,\n                                        ASTContext &Context) {\n  return matchDynamic(Matcher, DynTypedNode::create(Node), Context);\n}\n\ninline SmallVector<BoundNodes, 1>\nmatchDynamic(internal::DynTypedMatcher Matcher, ASTContext &Context) {\n  internal::CollectMatchesCallback Callback;\n  MatchFinder Finder;\n  Finder.addDynamicMatcher(Matcher, &Callback);\n  Finder.matchAST(Context);\n  return std::move(Callback.Nodes);\n}\n\n} // end namespace ast_matchers\n}",
  "id": "BLOCK-CPP-14682",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchFinder.h",
  "source_line": 49,
  "validation_status": "validated"
}