{
  "code": "{\n public:\n  static_assert(max_words == 4 || max_words == 84,\n                \"unsupported max_words value\");\n\n  BigUnsigned() : size_(0), words_{} {}\n  explicit constexpr BigUnsigned(uint64_t v)\n      : size_((v >> 32) ? 2 : v ? 1 : 0),\n        words_{static_cast<uint32_t>(v & 0xffffffffu),\n               static_cast<uint32_t>(v >> 32)} {}\n\n  // Constructs a BigUnsigned from the given string_view containing a decimal\n  // value.  If the input string is not a decimal integer, constructs a 0\n  // instead.\n  explicit BigUnsigned(absl::string_view sv) : size_(0), words_{} {\n    // Check for valid input, returning a 0 otherwise.  This is reasonable\n    // behavior only because this constructor is for unit tests.\n    if (std::find_if_not(sv.begin(), sv.end(), ascii_isdigit) != sv.end() ||\n        sv.empty()) {\n      return;\n    }\n    int exponent_adjust =\n        ReadDigits(sv.data(), sv.data() + sv.size(), Digits10() + 1);\n    if (exponent_adjust > 0) {\n      MultiplyByTenToTheNth(exponent_adjust);\n    }\n  }\n\n  // Loads the mantissa value of a previously-parsed float.\n  //\n  // Returns the associated decimal exponent.  The value of the parsed float is\n  // exactly *this * 10**exponent.\n  int ReadFloatMantissa(const ParsedFloat& fp, int significant_digits);\n\n  // Returns the number of decimal digits of precision this type provides.  All\n  // numbers with this many decimal digits or fewer are representable by this\n  // type.\n  //\n  // Analogous to std::numeric_limits<BigUnsigned>::digits10.\n  static constexpr int Digits10() {\n    // 9975007/1035508 is very slightly less than log10(2**32).\n    return static_cast<uint64_t>(max_words) * 9975007 / 1035508;\n  }\n\n  // Shifts left by the given number of bits.\n  void ShiftLeft(int count) {\n    if (count > 0) {\n      const int word_shift = count / 32;\n      if (word_shift >= max_words) {\n        SetToZero();\n        return;\n      }\n      size_ = (std::min)(size_ + word_shift, max_words);\n      count %= 32;\n      if (count == 0) {\n        std::copy_backward(words_, words_ + size_ - word_shift, words_ + size_);\n      } else {\n        for (int i = (std::min)(size_, max_words - 1); i > word_shift; --i) {\n          words_[i] = (words_[i - word_shift] << count) |\n                      (words_[i - word_shift - 1] >> (32 - count));\n        }\n        words_[word_shift] = words_[0] << count;\n        // Grow size_ if necessary.\n        if (size_ < max_words && words_[size_]) {\n          ++size_;\n        }\n      }\n      std::fill_n(words_, word_shift, 0u);\n    }\n  }\n\n\n  // Multiplies by v in-place.\n  void MultiplyBy(uint32_t v) {\n    if (size_ == 0 || v == 1) {\n      return;\n    }\n    if (v == 0) {\n      SetToZero();\n      return;\n    }\n    const uint64_t factor = v;\n    uint64_t window = 0;\n    for (int i = 0; i < size_; ++i) {\n      window += factor * words_[i];\n      words_[i] = window & 0xffffffff;\n      window >>= 32;\n    }\n    // If carry bits remain and there's space for them, grow size_.\n    if (window && size_ < max_words) {\n      words_[size_] = window & 0xffffffff;\n      ++size_;\n    }\n  }\n\n  void MultiplyBy(uint64_t v) {\n    uint32_t words[2];\n    words[0] = static_cast<uint32_t>(v);\n    words[1] = static_cast<uint32_t>(v >> 32);\n    if (words[1] == 0) {\n      MultiplyBy(words[0]);\n    } else {\n      MultiplyBy(2, words);\n    }\n  }\n\n  // Multiplies in place by 5 to the power of n.  n must be non-negative.\n  void MultiplyByFiveToTheNth(int n) {\n    while (n >= kMaxSmallPowerOfFive) {\n      MultiplyBy(kFiveToNth[kMaxSmallPowerOfFive]);\n      n -= kMaxSmallPowerOfFive;\n    }\n    if (n > 0) {\n      MultiplyBy(kFiveToNth[n]);\n    }\n  }\n\n  // Multiplies in place by 10 to the power of n.  n must be non-negative.\n  void MultiplyByTenToTheNth(int n) {\n    if (n > kMaxSmallPowerOfTen) {\n      // For large n, raise to a power of 5, then shift left by the same amount.\n      // (10**n == 5**n * 2**n.)  This requires fewer multiplications overall.\n      MultiplyByFiveToTheNth(n);\n      ShiftLeft(n);\n    } else if (n > 0) {\n      // We can do this more quickly for very small N by using a single\n      // multiplication.\n      MultiplyBy(kTenToNth[n]);\n    }\n  }\n\n  // Returns the value of 5**n, for non-negative n.  This implementation uses\n  // a lookup table, and is faster then seeding a BigUnsigned with 1 and calling\n  // MultiplyByFiveToTheNth().\n  static BigUnsigned FiveToTheNth(int n);\n\n  // Multiplies by another BigUnsigned, in-place.\n  template <int M>\n  void MultiplyBy(const BigUnsigned<M>& other) {\n    MultiplyBy(other.size(), other.words());\n  }\n\n  void SetToZero() {\n    std::fill_n(words_, size_, 0u);\n    size_ = 0;\n  }\n\n  // Returns the value of the nth word of this BigUnsigned.  This is\n  // range-checked, and returns 0 on out-of-bounds accesses.\n  uint32_t GetWord(int index) const {\n    if (index < 0 || index >= size_) {\n      return 0;\n    }\n    return words_[index];\n  }\n\n  // Returns this integer as a decimal string.  This is not used in the decimal-\n  // to-binary conversion; it is intended to aid in testing.\n  std::string ToString() const;\n\n  int size() const { return size_; }\n  const uint32_t* words() const { return words_; }\n\n private:\n  // Reads the number between [begin, end), possibly containing a decimal point,\n  // into this BigUnsigned.\n  //\n  // Callers are required to ensure [begin, end) contains a valid number, with\n  // one or more decimal digits and at most one decimal point.  This routine\n  // will behave unpredictably if these preconditions are not met.\n  //\n  // Only the first `significant_digits` digits are read.  Digits beyond this\n  // limit are \"sticky\": If the final significant digit is 0 or 5, and if any\n  // dropped digit is nonzero, then that final significant digit is adjusted up\n  // to 1 or 6.  This adjustment allows for precise rounding.\n  //\n  // Returns `exponent_adjustment`, a power-of-ten exponent adjustment to\n  // account for the decimal point and for dropped significant digits.  After\n  // this function returns,\n  //   actual_value_of_parsed_string ~= *this * 10**exponent_adjustment.\n  int ReadDigits(const char* begin, const char* end, int significant_digits);\n\n  // Performs a step of big integer multiplication.  This computes the full\n  // (64-bit-wide) values that should be added at the given index (step), and\n  // adds to that location in-place.\n  //\n  // Because our math all occurs in place, we must multiply starting from the\n  // highest word working downward.  (This is a bit more expensive due to the\n  // extra carries involved.)\n  //\n  // This must be called in steps, for each word to be calculated, starting from\n  // the high end and working down to 0.  The first value of `step` should be\n  //   `std::min(original_size + other.size_ - 2, max_words - 1)`.\n  // The reason for this expression is that multiplying the i'th word from one\n  // multiplicand and the j'th word of another multiplicand creates a\n  // two-word-wide value to be stored at the (i+j)'th element.  The highest\n  // word indices we will access are `original_size - 1` from this object, and\n  // `other.size_ - 1` from our operand.  Therefore,\n  // `original_size + other.size_ - 2` is the first step we should calculate,\n  // but limited on an upper bound by max_words.\n\n  // Working from high-to-low ensures that we do not overwrite the portions of\n  // the initial value of *this which are still needed for later steps.\n  //\n  // Once called with step == 0, *this contains the result of the\n  // multiplication.\n  //\n  // `original_size` is the size_ of *this before the first call to\n  // MultiplyStep().  `other_words` and `other_size` are the contents of our\n  // operand.  `step` is the step to perform, as described above.\n  void MultiplyStep(int original_size, const uint32_t* other_words,\n                    int other_size, int step);\n\n  void MultiplyBy(int other_size, const uint32_t* other_words) {\n    const int original_size = size_;\n    const int first_step =\n        (std::min)(original_size + other_size - 2, max_words - 1);\n    for (int step = first_step; step >= 0; --step) {\n      MultiplyStep(original_size, other_words, other_size, step);\n    }\n  }\n\n  // Adds a 32-bit value to the index'th word, with carry.\n  void AddWithCarry(int index, uint32_t value) {\n    if (value) {\n      while (index < max_words && value > 0) {\n        words_[index] += value;\n        // carry if we overflowed in this word:\n        if (value > words_[index]) {\n          value = 1;\n          ++index;\n        } else {\n          value = 0;\n        }\n      }\n      size_ = (std::min)(max_words, (std::max)(index + 1, size_));\n    }\n  }\n\n  void AddWithCarry(int index, uint64_t value) {\n    if (value && index < max_words) {\n      uint32_t high = value >> 32;\n      uint32_t low = value & 0xffffffff;\n      words_[index] += low;\n      if (words_[index] < low) {\n        ++high;\n        if (high == 0) {\n          // Carry from the low word caused our high word to overflow.\n          // Short circuit here to do the right thing.\n          AddWithCarry(index + 2, static_cast<uint32_t>(1));\n          return;\n        }\n      }\n      if (high > 0) {\n        AddWithCarry(index + 1, high);\n      } else {\n        // Normally 32-bit AddWithCarry() sets size_, but since we don't call\n        // it when `high` is 0, do it ourselves here.\n        size_ = (std::min)(max_words, (std::max)(index + 1, size_));\n      }\n    }\n  }\n\n  // Divide this in place by a constant divisor.  Returns the remainder of the\n  // division.\n  template <uint32_t divisor>\n  uint32_t DivMod() {\n    uint64_t accumulator = 0;\n    for (int i = size_ - 1; i >= 0; --i) {\n      accumulator <<= 32;\n      accumulator += words_[i];\n      // accumulator / divisor will never overflow an int32_t in this loop\n      words_[i] = static_cast<uint32_t>(accumulator / divisor);\n      accumulator = accumulator % divisor;\n    }\n    while (size_ > 0 && words_[size_ - 1] == 0) {\n      --size_;\n    }\n    return static_cast<uint32_t>(accumulator);\n  }\n\n  // The number of elements in words_ that may carry significant values.\n  // All elements beyond this point are 0.\n  //\n  // When size_ is 0, this BigUnsigned stores the value 0.\n  // When size_ is nonzero, is *not* guaranteed that words_[size_ - 1] is\n  // nonzero.  This can occur due to overflow truncation.\n  // In particular, x.size_ != y.size_ does *not* imply x != y.\n  int size_;\n  uint32_t words_[max_words];\n}",
  "id": "BLOCK-CPP-06049",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/charconv_bigint.h",
  "source_line": 56,
  "validation_status": "validated",
  "description": "C++ block with 291 lines of code implementing BLOCK-CPP-06049",
  "short_desc": "C++ block with 291 lines of code implementing BLOCK-CPP-06049",
  "input_types": "any",
  "output_type": "void",
  "keywords": [
    "c++",
    "create",
    "find",
    "number",
    "object",
    "parse",
    "read",
    "string",
    "write"
  ],
  "use_cases": [
    "File I/O operations"
  ],
  "related_blocks": [],
  "avg_execution_ms": 100.0,
  "max_memory_mb": 32,
  "performance_tier": "slow",
  "success_rate_percent": 100,
  "avg_tokens_saved": 50,
  "test_coverage_percent": 0,
  "security_audited": false,
  "stability": "stable"
}