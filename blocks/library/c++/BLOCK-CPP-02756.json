{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\nnamespace {\nvoid EncodeRawVarint(uint64_t value, size_t size, absl::Span<char> *buf) {\n  for (size_t s = 0; s < size; s++) {\n    (*buf)[s] = static_cast<char>((value & 0x7f) | (s + 1 == size ? 0 : 0x80));\n    value >>= 7;\n  }\n  buf->remove_prefix(size);\n}\nconstexpr uint64_t MakeTagType(uint64_t tag, WireType type) {\n  return tag << 3 | static_cast<uint64_t>(type);\n}\n}  // namespace\n\nbool EncodeVarint(uint64_t tag, uint64_t value, absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::kVarint);\n  const size_t tag_type_size = VarintSize(tag_type);\n  const size_t value_size = VarintSize(value);\n  if (tag_type_size + value_size > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return false;\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  EncodeRawVarint(value, value_size, buf);\n  return true;\n}\n\nbool Encode64Bit(uint64_t tag, uint64_t value, absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::k64Bit);\n  const size_t tag_type_size = VarintSize(tag_type);\n  if (tag_type_size + sizeof(value) > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return false;\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  for (size_t s = 0; s < sizeof(value); s++) {\n    (*buf)[s] = static_cast<char>(value & 0xff);\n    value >>= 8;\n  }\n  buf->remove_prefix(sizeof(value));\n  return true;\n}\n\nbool Encode32Bit(uint64_t tag, uint32_t value, absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::k32Bit);\n  const size_t tag_type_size = VarintSize(tag_type);\n  if (tag_type_size + sizeof(value) > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return false;\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  for (size_t s = 0; s < sizeof(value); s++) {\n    (*buf)[s] = static_cast<char>(value & 0xff);\n    value >>= 8;\n  }\n  buf->remove_prefix(sizeof(value));\n  return true;\n}\n\nbool EncodeBytes(uint64_t tag, absl::Span<const char> value,\n                 absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);\n  const size_t tag_type_size = VarintSize(tag_type);\n  uint64_t length = value.size();\n  const size_t length_size = VarintSize(length);\n  if (tag_type_size + length_size + value.size() > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return false;\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  EncodeRawVarint(length, length_size, buf);\n  memcpy(buf->data(), value.data(), value.size());\n  buf->remove_prefix(value.size());\n  return true;\n}\n\nbool EncodeBytesTruncate(uint64_t tag, absl::Span<const char> value,\n                         absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);\n  const size_t tag_type_size = VarintSize(tag_type);\n  uint64_t length = value.size();\n  const size_t length_size =\n      VarintSize(std::min<uint64_t>(length, buf->size()));\n  if (tag_type_size + length_size <= buf->size() &&\n      tag_type_size + length_size + value.size() > buf->size()) {\n    value.remove_suffix(tag_type_size + length_size + value.size() -\n                        buf->size());\n    length = value.size();\n  }\n  if (tag_type_size + length_size + value.size() > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return false;\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  EncodeRawVarint(length, length_size, buf);\n  memcpy(buf->data(), value.data(), value.size());\n  buf->remove_prefix(value.size());\n  return true;\n}\n\nABSL_MUST_USE_RESULT absl::Span<char> EncodeMessageStart(\n    uint64_t tag, uint64_t max_size, absl::Span<char> *buf) {\n  const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);\n  const size_t tag_type_size = VarintSize(tag_type);\n  max_size = std::min<uint64_t>(max_size, buf->size());\n  const size_t length_size = VarintSize(max_size);\n  if (tag_type_size + length_size > buf->size()) {\n    buf->remove_suffix(buf->size());\n    return absl::Span<char>();\n  }\n  EncodeRawVarint(tag_type, tag_type_size, buf);\n  const absl::Span<char> ret = buf->subspan(0, length_size);\n  EncodeRawVarint(0, length_size, buf);\n  return ret;\n}\n\nvoid EncodeMessageLength(absl::Span<char> msg, const absl::Span<char> *buf) {\n  if (!msg.data()) return;\n  assert(buf->data() >= msg.data());\n  if (buf->data() < msg.data()) return;\n  EncodeRawVarint(\n      static_cast<uint64_t>(buf->data() - (msg.data() + msg.size())),\n      msg.size(), &msg);\n}\n\nnamespace {\nuint64_t DecodeVarint(absl::Span<const char> *buf) {\n  uint64_t value = 0;\n  size_t s = 0;\n  while (s < buf->size()) {\n    value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]) & 0x7f)\n             << 7 * s;\n    if (!((*buf)[s++] & 0x80)) break;\n  }\n  buf->remove_prefix(s);\n  return value;\n}\n\nuint64_t Decode64Bit(absl::Span<const char> *buf) {\n  uint64_t value = 0;\n  size_t s = 0;\n  while (s < buf->size()) {\n    value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]))\n             << 8 * s;\n    if (++s == sizeof(value)) break;\n  }\n  buf->remove_prefix(s);\n  return value;\n}\n\nuint32_t Decode32Bit(absl::Span<const char> *buf) {\n  uint32_t value = 0;\n  size_t s = 0;\n  while (s < buf->size()) {\n    value |= static_cast<uint32_t>(static_cast<unsigned char>((*buf)[s]))\n             << 8 * s;\n    if (++s == sizeof(value)) break;\n  }\n  buf->remove_prefix(s);\n  return value;\n}\n}  // namespace\n\nbool ProtoField::DecodeFrom(absl::Span<const char> *data) {\n  if (data->empty()) return false;\n  const uint64_t tag_type = DecodeVarint(data);\n  tag_ = tag_type >> 3;\n  type_ = static_cast<WireType>(tag_type & 0x07);\n  switch (type_) {\n    case WireType::kVarint:\n      value_ = DecodeVarint(data);\n      break;\n    case WireType::k64Bit:\n      value_ = Decode64Bit(data);\n      break;\n    case WireType::kLengthDelimited: {\n      value_ = DecodeVarint(data);\n      data_ = data->subspan(\n          0, static_cast<size_t>(std::min<uint64_t>(value_, data->size())));\n      data->remove_prefix(data_.size());\n      break;\n    }\n    case WireType::k32Bit:\n      value_ = Decode32Bit(data);\n      break;\n  }\n  return true;\n}\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02756",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/proto.cc",
  "source_line": 27,
  "validation_status": "validated"
}