{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace {\n\n// Return whether int *arg is true.\nbool IsDone(void *arg) { return *reinterpret_cast<bool *>(arg); }\n\n}  // namespace\n\nBlockingCounter::BlockingCounter(int initial_count)\n    : count_(initial_count),\n      num_waiting_(0),\n      done_{initial_count == 0 ? true : false} {\n  ABSL_RAW_CHECK(initial_count >= 0, \"BlockingCounter initial_count negative\");\n}\n\nbool BlockingCounter::DecrementCount() {\n  int count = count_.fetch_sub(1, std::memory_order_acq_rel) - 1;\n  ABSL_RAW_CHECK(count >= 0,\n                 \"BlockingCounter::DecrementCount() called too many times\");\n  if (count == 0) {\n    MutexLock l(&lock_);\n    done_ = true;\n    return true;\n  }\n  return false;\n}\n\nvoid BlockingCounter::Wait() {\n  MutexLock l(&this->lock_);\n\n  // only one thread may call Wait(). To support more than one thread,\n  // implement a counter num_to_exit, like in the Barrier class.\n  ABSL_RAW_CHECK(num_waiting_ == 0, \"multiple threads called Wait()\");\n  num_waiting_++;\n\n  this->lock_.Await(Condition(IsDone, &this->done_));\n\n  // At this point, we know that all threads executing DecrementCount\n  // will not touch this object again.\n  // Therefore, the thread calling this method is free to delete the object\n  // after we return from this method.\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02056",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/blocking_counter.cc",
  "source_line": 21,
  "validation_status": "validated"
}