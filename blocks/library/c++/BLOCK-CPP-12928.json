{
  "code": "{\n///   __if_exists (T::foo) {\n///     t.foo(); // okay: only called when T::foo exists.\n///   }\n/// }\n/// \\endcode\n///\n/// Similarly, the __if_not_exists statement can be used to include the\n/// statements when a particular name does not exist.\n///\n/// Note that this statement only captures __if_exists and __if_not_exists\n/// statements whose name is dependent. All non-dependent cases are handled\n/// directly in the parser, so that they don't introduce a new scope. Clang\n/// introduces scopes in the dependent case to keep names inside the compound\n/// statement from leaking out into the surround statements, which would\n/// compromise the template instantiation model. This behavior differs from\n/// Visual C++ (which never introduces a scope), but is a fairly reasonable\n/// approximation of the VC++ behavior.\nclass MSDependentExistsStmt : public Stmt {\n  SourceLocation KeywordLoc;\n  bool IsIfExists;\n  NestedNameSpecifierLoc QualifierLoc;\n  DeclarationNameInfo NameInfo;\n  Stmt *SubStmt;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\npublic:\n  MSDependentExistsStmt(SourceLocation KeywordLoc, bool IsIfExists,\n                        NestedNameSpecifierLoc QualifierLoc,\n                        DeclarationNameInfo NameInfo,\n                        CompoundStmt *SubStmt)\n  : Stmt(MSDependentExistsStmtClass),\n    KeywordLoc(KeywordLoc), IsIfExists(IsIfExists),\n    QualifierLoc(QualifierLoc), NameInfo(NameInfo),\n    SubStmt(reinterpret_cast<Stmt *>(SubStmt)) { }\n\n  /// Retrieve the location of the __if_exists or __if_not_exists\n  /// keyword.\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  /// Determine whether this is an __if_exists statement.\n  bool isIfExists() const { return IsIfExists; }\n\n  /// Determine whether this is an __if_exists statement.\n  bool isIfNotExists() const { return !IsIfExists; }\n\n  /// Retrieve the nested-name-specifier that qualifies this name, if\n  /// any.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the name of the entity we're testing for, along with\n  /// location information\n  DeclarationNameInfo getNameInfo() const { return NameInfo; }\n\n  /// Retrieve the compound statement that will be included in the\n  /// program only if the existence of the symbol matches the initial keyword.\n  CompoundStmt *getSubStmt() const {\n    return reinterpret_cast<CompoundStmt *>(SubStmt);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(&SubStmt, &SubStmt+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSDependentExistsStmtClass;\n  }\n};\n\n/// Represents the body of a coroutine. This wraps the normal function\n/// body and holds the additional semantic context required to set up and tear\n/// down the coroutine frame.\nclass CoroutineBodyStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<CoroutineBodyStmt, Stmt *> {\n  enum SubStmt {\n    Body,          ///< The body of the coroutine.\n    Promise,       ///< The promise statement.\n    InitSuspend,   ///< The initial suspend statement, run before the body.\n    FinalSuspend,  ///< The final suspend statement, run after the body.\n    OnException,   ///< Handler for exceptions thrown in the body.\n    OnFallthrough, ///< Handler for control flow falling off the body.\n    Allocate,      ///< Coroutine frame memory allocation.\n    Deallocate,    ///< Coroutine frame memory deallocation.\n    ResultDecl,    ///< Declaration holding the result of get_return_object.\n    ReturnValue,   ///< Return value for thunk function: p.get_return_object().\n    ReturnStmt,    ///< Return statement for the thunk function.\n    ReturnStmtOnAllocFailure, ///< Return statement if allocation failed.\n    FirstParamMove ///< First offset for move construction of parameter copies.\n  };\n  unsigned NumParams;\n\n  friend class ASTStmtReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  Stmt **getStoredStmts() { return getTrailingObjects<Stmt *>(); }\n\n  Stmt *const *getStoredStmts() const { return getTrailingObjects<Stmt *>(); }\n\npublic:\n\n  struct CtorArgs {\n    Stmt *Body = nullptr;\n    Stmt *Promise = nullptr;\n    Expr *InitialSuspend = nullptr;\n    Expr *FinalSuspend = nullptr;\n    Stmt *OnException = nullptr;\n    Stmt *OnFallthrough = nullptr;\n    Expr *Allocate = nullptr;\n    Expr *Deallocate = nullptr;\n    Stmt *ResultDecl = nullptr;\n    Expr *ReturnValue = nullptr;\n    Stmt *ReturnStmt = nullptr;\n    Stmt *ReturnStmtOnAllocFailure = nullptr;\n    ArrayRef<Stmt *> ParamMoves;\n  };\n\nprivate:\n\n  CoroutineBodyStmt(CtorArgs const& Args);\n\npublic:\n  static CoroutineBodyStmt *Create(const ASTContext &C, CtorArgs const &Args);\n  static CoroutineBodyStmt *Create(const ASTContext &C, EmptyShell,\n                                   unsigned NumParams);\n\n  bool hasDependentPromiseType() const {\n    return getPromiseDecl()->getType()->isDependentType();\n  }\n\n  /// Retrieve the body of the coroutine as written. This will be either\n  /// a CompoundStmt. If the coroutine is in function-try-block, we will\n  /// wrap the CXXTryStmt into a CompoundStmt to keep consistency.\n  CompoundStmt *getBody() const {\n    return cast<CompoundStmt>(getStoredStmts()[SubStmt::Body]);\n  }\n\n  Stmt *getPromiseDeclStmt() const {\n    return getStoredStmts()[SubStmt::Promise];\n  }\n  VarDecl *getPromiseDecl() const {\n    return cast<VarDecl>(cast<DeclStmt>(getPromiseDeclStmt())->getSingleDecl());\n  }\n\n  Stmt *getInitSuspendStmt() const {\n    return getStoredStmts()[SubStmt::InitSuspend];\n  }\n  Stmt *getFinalSuspendStmt() const {\n    return getStoredStmts()[SubStmt::FinalSuspend];\n  }\n\n  Stmt *getExceptionHandler() const {\n    return getStoredStmts()[SubStmt::OnException];\n  }\n  Stmt *getFallthroughHandler() const {\n    return getStoredStmts()[SubStmt::OnFallthrough];\n  }\n\n  Expr *getAllocate() const {\n    return cast_or_null<Expr>(getStoredStmts()[SubStmt::Allocate]);\n  }\n  Expr *getDeallocate() const {\n    return cast_or_null<Expr>(getStoredStmts()[SubStmt::Deallocate]);\n  }\n  Stmt *getResultDecl() const { return getStoredStmts()[SubStmt::ResultDecl]; }\n  Expr *getReturnValueInit() const {\n    return cast<Expr>(getStoredStmts()[SubStmt::ReturnValue]);\n  }\n  Expr *getReturnValue() const {\n    auto *RS = dyn_cast_or_null<clang::ReturnStmt>(getReturnStmt());\n    return RS ? RS->getRetValue() : nullptr;\n  }\n  Stmt *getReturnStmt() const { return getStoredStmts()[SubStmt::ReturnStmt]; }\n  Stmt *getReturnStmtOnAllocFailure() const {\n    return getStoredStmts()[SubStmt::ReturnStmtOnAllocFailure];\n  }\n  ArrayRef<Stmt const *> getParamMoves() const {\n    return {getStoredStmts() + SubStmt::FirstParamMove, NumParams};\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getBeginLoc()\n                     : getPromiseDecl()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getEndLoc() : getPromiseDecl()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(getStoredStmts(),\n                       getStoredStmts() + SubStmt::FirstParamMove + NumParams);\n  }\n\n  const_child_range children() const {\n    return const_child_range(getStoredStmts(), getStoredStmts() +\n                                                   SubStmt::FirstParamMove +\n                                                   NumParams);\n  }\n\n  child_range childrenExclBody() {\n    return child_range(getStoredStmts() + SubStmt::Body + 1,\n                       getStoredStmts() + SubStmt::FirstParamMove + NumParams);\n  }\n\n  const_child_range childrenExclBody() const {\n    return const_child_range(getStoredStmts() + SubStmt::Body + 1,\n                             getStoredStmts() + SubStmt::FirstParamMove +\n                                 NumParams);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoroutineBodyStmtClass;\n  }\n};\n\n/// Represents a 'co_return' statement in the C++ Coroutines TS.\n///\n/// This statament models the initialization of the coroutine promise\n/// (encapsulating the eventual notional return value) from an expression\n/// (or braced-init-list), followed by termination of the coroutine.\n///\n/// This initialization is modeled by the evaluation of the operand\n/// followed by a call to one of:\n///   <promise>.return_value(<operand>)\n///   <promise>.return_void()\n/// which we name the \"promise call\".\nclass CoreturnStmt : public Stmt {\n  SourceLocation CoreturnLoc;\n\n  enum SubStmt { Operand, PromiseCall, Count };\n  Stmt *SubStmts[SubStmt::Count];\n\n  bool IsImplicit : 1;\n\n  friend class ASTStmtReader;\npublic:\n  CoreturnStmt(SourceLocation CoreturnLoc, Stmt *Operand, Stmt *PromiseCall,\n               bool IsImplicit = false)\n      : Stmt(CoreturnStmtClass), CoreturnLoc(CoreturnLoc),\n        IsImplicit(IsImplicit) {\n    SubStmts[SubStmt::Operand] = Operand;\n    SubStmts[SubStmt::PromiseCall] = PromiseCall;\n  }\n\n  CoreturnStmt(EmptyShell) : CoreturnStmt({}, {}, {}) {}\n\n  SourceLocation getKeywordLoc() const { return CoreturnLoc; }\n\n  /// Retrieve the operand of the 'co_return' statement. Will be nullptr\n  /// if none was specified.\n  Expr *getOperand() const { return static_cast<Expr*>(SubStmts[Operand]); }\n\n  /// Retrieve the promise call that results from this 'co_return'\n  /// statement. Will be nullptr if either the coroutine has not yet been\n  /// finalized or the coroutine has no eventual return type.\n  Expr *getPromiseCall() const {\n    return static_cast<Expr*>(SubStmts[PromiseCall]);\n  }\n\n  bool isImplicit() const { return IsImplicit; }\n  void setIsImplicit(bool value = true) { IsImplicit = value; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return CoreturnLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand() ? getOperand()->getEndLoc() : getBeginLoc();\n  }\n\n  child_range children() {\n    return child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoreturnStmtClass;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-12928",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtCXX.h",
  "source_line": 235,
  "validation_status": "validated"
}