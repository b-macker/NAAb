{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace debugging_internal {\n\nnamespace {\nconstexpr int kDefaultDumpStackFramesLimit = 64;\n// The %p field width for printf() functions is two characters per byte,\n// and two extra for the leading \"0x\".\nconstexpr int kPrintfPointerFieldWidth = 2 + 2 * sizeof(void*);\n\nABSL_CONST_INIT SymbolizeUrlEmitter debug_stack_trace_hook = nullptr;\n\n// Async-signal safe mmap allocator.\nvoid* Allocate(size_t num_bytes) {\n#ifdef ABSL_HAVE_MMAP\n  void* p = ::mmap(nullptr, num_bytes, PROT_READ | PROT_WRITE,\n                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  return p == MAP_FAILED ? nullptr : p;\n#else\n  (void)num_bytes;\n  return nullptr;\n#endif  // ABSL_HAVE_MMAP\n}\n\nvoid Deallocate(void* p, size_t size) {\n#ifdef ABSL_HAVE_MMAP\n  ::munmap(p, size);\n#else\n  (void)p;\n  (void)size;\n#endif  // ABSL_HAVE_MMAP\n}\n\n// Print a program counter only.\nvoid DumpPC(OutputWriter* writer, void* writer_arg, void* const pc,\n            const char* const prefix) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"%s@ %*p\\n\", prefix, kPrintfPointerFieldWidth, pc);\n  writer(buf, writer_arg);\n}\n\n// Print a program counter and the corresponding stack frame size.\nvoid DumpPCAndFrameSize(OutputWriter* writer, void* writer_arg, void* const pc,\n                        int framesize, const char* const prefix) {\n  char buf[100];\n  if (framesize <= 0) {\n    snprintf(buf, sizeof(buf), \"%s@ %*p  (unknown)\\n\", prefix,\n             kPrintfPointerFieldWidth, pc);\n  } else {\n    snprintf(buf, sizeof(buf), \"%s@ %*p  %9d\\n\", prefix,\n             kPrintfPointerFieldWidth, pc, framesize);\n  }\n  writer(buf, writer_arg);\n}\n\n// Print a program counter and the corresponding symbol.\nvoid DumpPCAndSymbol(OutputWriter* writer, void* writer_arg, void* const pc,\n                     const char* const prefix) {\n  char tmp[1024];\n  const char* symbol = \"(unknown)\";\n  // Symbolizes the previous address of pc because pc may be in the\n  // next function.  The overrun happens when the function ends with\n  // a call to a function annotated noreturn (e.g. CHECK).\n  // If symbolization of pc-1 fails, also try pc on the off-chance\n  // that we crashed on the first instruction of a function (that\n  // actually happens very often for e.g. __restore_rt).\n  const uintptr_t prev_pc = reinterpret_cast<uintptr_t>(pc) - 1;\n  if (absl::Symbolize(reinterpret_cast<const char*>(prev_pc), tmp,\n                      sizeof(tmp)) ||\n      absl::Symbolize(pc, tmp, sizeof(tmp))) {\n    symbol = tmp;\n  }\n  char buf[1024];\n  snprintf(buf, sizeof(buf), \"%s@ %*p  %s\\n\", prefix, kPrintfPointerFieldWidth,\n           pc, symbol);\n  writer(buf, writer_arg);\n}\n\n// Print a program counter, its stack frame size, and its symbol name.\n// Note that there is a separate symbolize_pc argument. Return addresses may be\n// at the end of the function, and this allows the caller to back up from pc if\n// appropriate.\nvoid DumpPCAndFrameSizeAndSymbol(OutputWriter* writer, void* writer_arg,\n                                 void* const pc, void* const symbolize_pc,\n                                 int framesize, const char* const prefix) {\n  char tmp[1024];\n  const char* symbol = \"(unknown)\";\n  if (absl::Symbolize(symbolize_pc, tmp, sizeof(tmp))) {\n    symbol = tmp;\n  }\n  char buf[1024];\n  if (framesize <= 0) {\n    snprintf(buf, sizeof(buf), \"%s@ %*p  (unknown)  %s\\n\", prefix,\n             kPrintfPointerFieldWidth, pc, symbol);\n  } else {\n    snprintf(buf, sizeof(buf), \"%s@ %*p  %9d  %s\\n\", prefix,\n             kPrintfPointerFieldWidth, pc, framesize, symbol);\n  }\n  writer(buf, writer_arg);\n}\n\n}  // namespace\n\nvoid RegisterDebugStackTraceHook(SymbolizeUrlEmitter hook) {\n  debug_stack_trace_hook = hook;\n}\n\nSymbolizeUrlEmitter GetDebugStackTraceHook() { return debug_stack_trace_hook; }\n\n// Returns the program counter from signal context, nullptr if\n// unknown. vuc is a ucontext_t*. We use void* to avoid the use of\n// ucontext_t on non-POSIX systems.\nvoid* GetProgramCounter(void* const vuc) {\n#ifdef __linux__\n  if (vuc != nullptr) {\n    ucontext_t* context = reinterpret_cast<ucontext_t*>(vuc);\n#if defined(__aarch64__)\n    return reinterpret_cast<void*>(context->uc_mcontext.pc);\n#elif defined(__alpha__)\n    return reinterpret_cast<void*>(context->uc_mcontext.sc_pc);\n#elif defined(__arm__)\n    return reinterpret_cast<void*>(context->uc_mcontext.arm_pc);\n#elif defined(__hppa__)\n    return reinterpret_cast<void*>(context->uc_mcontext.sc_iaoq[0]);\n#elif defined(__i386__)\n    if (14 < ABSL_ARRAYSIZE(context->uc_mcontext.gregs))\n      return reinterpret_cast<void*>(context->uc_mcontext.gregs[14]);\n#elif defined(__ia64__)\n    return reinterpret_cast<void*>(context->uc_mcontext.sc_ip);\n#elif defined(__m68k__)\n    return reinterpret_cast<void*>(context->uc_mcontext.gregs[16]);\n#elif defined(__mips__)\n    return reinterpret_cast<void*>(context->uc_mcontext.pc);\n#elif defined(__powerpc64__)\n    return reinterpret_cast<void*>(context->uc_mcontext.gp_regs[32]);\n#elif defined(__powerpc__)\n    return reinterpret_cast<void*>(context->uc_mcontext.uc_regs->gregs[32]);\n#elif defined(__riscv)\n    return reinterpret_cast<void*>(context->uc_mcontext.__gregs[REG_PC]);\n#elif defined(__s390__) && !defined(__s390x__)\n    return reinterpret_cast<void*>(context->uc_mcontext.psw.addr & 0x7fffffff);\n#elif defined(__s390__) && defined(__s390x__)\n    return reinterpret_cast<void*>(context->uc_mcontext.psw.addr);\n#elif defined(__sh__)\n    return reinterpret_cast<void*>(context->uc_mcontext.pc);\n#elif defined(__sparc__) && !defined(__arch64__)\n    return reinterpret_cast<void*>(context->uc_mcontext.gregs[19]);\n#elif defined(__sparc__) && defined(__arch64__)\n    return reinterpret_cast<void*>(context->uc_mcontext.mc_gregs[19]);\n#elif defined(__x86_64__)\n    if (16 < ABSL_ARRAYSIZE(context->uc_mcontext.gregs))\n      return reinterpret_cast<void*>(context->uc_mcontext.gregs[16]);\n#elif defined(__e2k__)\n    return reinterpret_cast<void*>(context->uc_mcontext.cr0_hi);\n#elif defined(__loongarch__)\n    return reinterpret_cast<void*>(context->uc_mcontext.__pc);\n#else\n#error \"Undefined Architecture.\"\n#endif\n  }\n#elif defined(__APPLE__)\n  if (vuc != nullptr) {\n    ucontext_t* signal_ucontext = reinterpret_cast<ucontext_t*>(vuc);\n#if defined(__aarch64__)\n    return reinterpret_cast<void*>(\n        __darwin_arm_thread_state64_get_pc(signal_ucontext->uc_mcontext->__ss));\n#elif defined(__arm__)\n#if __DARWIN_UNIX03\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__pc);\n#else\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.pc);\n#endif\n#elif defined(__i386__)\n#if __DARWIN_UNIX03\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__eip);\n#else\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.eip);\n#endif\n#elif defined(__x86_64__)\n#if __DARWIN_UNIX03\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__rip);\n#else\n    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.rip);\n#endif\n#endif\n  }\n#elif defined(__akaros__)\n  auto* ctx = reinterpret_cast<struct user_context*>(vuc);\n  return reinterpret_cast<void*>(get_user_ctx_pc(ctx));\n#endif\n  static_cast<void>(vuc);\n  return nullptr;\n}\n\nvoid DumpPCAndFrameSizesAndStackTrace(void* const pc, void* const stack[],\n                                      int frame_sizes[], int depth,\n                                      int min_dropped_frames,\n                                      bool symbolize_stacktrace,\n                                      OutputWriter* writer, void* writer_arg) {\n  if (pc != nullptr) {\n    // We don't know the stack frame size for PC, use 0.\n    if (symbolize_stacktrace) {\n      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, pc, pc, 0, \"PC: \");\n    } else {\n      DumpPCAndFrameSize(writer, writer_arg, pc, 0, \"PC: \");\n    }\n  }\n  for (int i = 0; i < depth; i++) {\n    if (symbolize_stacktrace) {\n      // Pass the previous address of pc as the symbol address because pc is a\n      // return address, and an overrun may occur when the function ends with a\n      // call to a function annotated noreturn (e.g. CHECK). Note that we don't\n      // do this for pc above, as the adjustment is only correct for return\n      // addresses.\n      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, stack[i],\n                                  reinterpret_cast<char*>(stack[i]) - 1,\n                                  frame_sizes[i], \"    \");\n    } else {\n      DumpPCAndFrameSize(writer, writer_arg, stack[i], frame_sizes[i], \"    \");\n    }\n  }\n  if (min_dropped_frames > 0) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"    @ ... and at least %d more frames\\n\",\n             min_dropped_frames);\n    writer(buf, writer_arg);\n  }\n}\n\n// Dump current stack trace as directed by writer.\n// Make sure this function is not inlined to avoid skipping too many top frames.\nABSL_ATTRIBUTE_NOINLINE\nvoid DumpStackTrace(int min_dropped_frames, int max_num_frames,\n                    bool symbolize_stacktrace, OutputWriter* writer,\n                    void* writer_arg) {\n  // Print stack trace\n  void* stack_buf[kDefaultDumpStackFramesLimit];\n  void** stack = stack_buf;\n  int num_stack = kDefaultDumpStackFramesLimit;\n  size_t allocated_bytes = 0;\n\n  if (num_stack >= max_num_frames) {\n    // User requested fewer frames than we already have space for.\n    num_stack = max_num_frames;\n  } else {\n    const size_t needed_bytes =\n        static_cast<size_t>(max_num_frames) * sizeof(stack[0]);\n    void* p = Allocate(needed_bytes);\n    if (p != nullptr) {  // We got the space.\n      num_stack = max_num_frames;\n      stack = reinterpret_cast<void**>(p);\n      allocated_bytes = needed_bytes;\n    }\n  }\n\n  int depth = absl::GetStackTrace(stack, num_stack, min_dropped_frames + 1);\n  for (int i = 0; i < depth; i++) {\n    if (symbolize_stacktrace) {\n      DumpPCAndSymbol(writer, writer_arg, stack[static_cast<size_t>(i)],\n                      \"    \");\n    } else {\n      DumpPC(writer, writer_arg, stack[static_cast<size_t>(i)], \"    \");\n    }\n  }\n\n  auto hook = GetDebugStackTraceHook();\n  if (hook != nullptr) {\n    (*hook)(stack, depth, writer, writer_arg);\n  }\n\n  if (allocated_bytes != 0) Deallocate(stack, allocated_bytes);\n}\n\n}  // namespace debugging_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02602",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/examine_stack.cc",
  "source_line": 45,
  "validation_status": "validated"
}