{
  "code": "#include \"absl/strings/internal/str_format/float_conversion.h\"\n#include <string.h>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <limits>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/functional/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/numeric/internal/representation.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03089_execute() {\n    {\n  assert((CanFitMantissa<Float, Int>()));\n\n  const int int_bits = std::numeric_limits<Int>::digits;\n\n  // In precision mode, we start printing one char to the right because it will\n  // also include the '.'\n  // In fixed mode we put the dot afterwards on the right.\n  out->begin = out->end =\n      out->data + 1 + kMaxFixedPrecision + (mode == FormatStyle::Precision);\n\n  if (exp >= 0) {\n    if (std::numeric_limits<Float>::digits + exp > int_bits) {\n      // The value will overflow the Int\n      return false;\n    }\n    size_t digits_printed = PrintIntegralDigits<mode>(int_mantissa << exp, out);\n    size_t digits_to_zero_pad = precision;\n    if (mode == FormatStyle::Precision) {\n      *exp_out = static_cast<int>(digits_printed - 1);\n      if (digits_to_zero_pad < digits_printed - 1) {\n        RemoveExtraPrecision(digits_printed - 1 - digits_to_zero_pad, false,\n                             out, exp_out);\n        return true;\n      }\n      digits_to_zero_pad -= digits_printed - 1;\n    }\n    for (; digits_to_zero_pad-- > 0;) out->push_back('0');\n    return true;\n  }\n\n  exp = -exp;\n  // We need at least 4 empty bits for the next decimal digit.\n  // We will multiply by 10.\n  if (exp > int_bits - 4) return false;\n\n  const Int mask = (Int{1} << exp) - 1;\n\n  // Print the integral part first.\n  size_t digits_printed = PrintIntegralDigits<mode>(int_mantissa >> exp, out);\n  int_mantissa &= mask;\n\n  size_t fractional_count = precision;\n  if (mode == FormatStyle::Precision) {\n    if (digits_printed == 0) {\n      // Find the first non-zero digit, when in Precision mode.\n      *exp_out = 0;\n      if (int_mantissa) {\n        while (int_mantissa <= mask) {\n          int_mantissa *= 10;\n          --*exp_out;\n        }\n      }\n      out->push_front(static_cast<char>(int_mantissa >> exp) + '0');\n      out->push_back('.');\n      int_mantissa &= mask;\n    } else {\n      // We already have a digit, and a '.'\n      *exp_out = static_cast<int>(digits_printed - 1);\n      if (fractional_count < digits_printed - 1) {\n        // If we had enough digits, return right away.\n        // The code below will try to round again otherwise.\n        RemoveExtraPrecision(digits_printed - 1 - fractional_count,\n                             int_mantissa != 0, out, exp_out);\n        return true;\n      }\n      fractional_count -= digits_printed - 1;\n    }\n  }\n\n  auto get_next_digit = [&] {\n    int_mantissa *= 10;\n    char digit = static_cast<char>(int_mantissa >> exp);\n    int_mantissa &= mask;\n    return digit;\n  };\n\n  // Print fractional_count more digits, if available.\n  for (; fractional_count > 0; --fractional_count) {\n    out->push_back(get_next_digit() + '0');\n  }\n\n  char next_digit = get_next_digit();\n  if (next_digit > 5 ||\n      (next_digit == 5 && (int_mantissa || out->last_digit() % 2 == 1))) {\n    RoundUp<mode>(out, exp_out);\n  }\n\n  return true;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03089",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 1188,
  "validation_status": "validated"
}