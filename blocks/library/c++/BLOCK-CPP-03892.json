{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::poisson_distribution:\n// Generates discrete variates conforming to a Poisson distribution.\n//   p(n) = (mean^n / n!) exp(-mean)\n//\n// Depending on the parameter, the distribution selects one of the following\n// algorithms:\n// * The standard algorithm, attributed to Knuth, extended using a split method\n// for larger values\n// * The \"Ratio of Uniforms as a convenient method for sampling from classical\n// discrete distributions\", Stadlober, 1989.\n// http://www.sciencedirect.com/science/article/pii/0377042790903495\n//\n// NOTE: param_type.mean() is a double, which permits values larger than\n// poisson_distribution<IntType>::max(), however this should be avoided and\n// the distribution results are limited to the max() value.\n//\n// The goals of this implementation are to provide good performance while still\n// beig thread-safe: This limits the implementation to not using lgamma provided\n// by <math.h>.\n//\ntemplate <typename IntType = int>\nclass poisson_distribution {\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = poisson_distribution;\n    explicit param_type(double mean = 1.0);\n\n    double mean() const { return mean_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.mean_ == b.mean_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class poisson_distribution;\n\n    double mean_;\n    double emu_;  // e ^ -mean_\n    double lmu_;  // ln(mean_)\n    double s_;\n    double log_k_;\n    int split_;\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::poisson_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  poisson_distribution() : poisson_distribution(1.0) {}\n\n  explicit poisson_distribution(double mean) : param_(mean) {}\n\n  explicit poisson_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const { return (std::numeric_limits<result_type>::max)(); }\n\n  double mean() const { return param_.mean(); }\n\n  friend bool operator==(const poisson_distribution& a,\n                         const poisson_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const poisson_distribution& a,\n                         const poisson_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n  random_internal::FastUniformBits<uint64_t> fast_u64_;\n};\n\n// -----------------------------------------------------------------------------\n// Implementation details follow\n// -----------------------------------------------------------------------------\n\ntemplate <typename IntType>\npoisson_distribution<IntType>::param_type::param_type(double mean)\n    : mean_(mean), split_(0) {\n  assert(mean >= 0);\n  assert(mean <=\n         static_cast<double>((std::numeric_limits<result_type>::max)()));\n  // As a defensive measure, avoid large values of the mean.  The rejection\n  // algorithm used does not support very large values well.  It my be worth\n  // changing algorithms to better deal with these cases.\n  assert(mean <= 1e10);\n  if (mean_ < 10) {\n    // For small lambda, use the knuth method.\n    split_ = 1;\n    emu_ = std::exp(-mean_);\n  } else if (mean_ <= 50) {\n    // Use split-knuth method.\n    split_ = 1 + static_cast<int>(mean_ / 10.0);\n    emu_ = std::exp(-mean_ / static_cast<double>(split_));\n  } else {\n    // Use ratio of uniforms method.\n    constexpr double k2E = 0.7357588823428846;\n    constexpr double kSA = 0.4494580810294493;\n\n    lmu_ = std::log(mean_);\n    double a = mean_ + 0.5;\n    s_ = kSA + std::sqrt(k2E * a);\n    const double mode = std::ceil(mean_) - 1;\n    log_k_ = lmu_ * mode - absl::random_internal::StirlingLogFactorial(mode);\n  }\n}\n\ntemplate <typename IntType>\ntemplate <typename URBG>\ntypename poisson_distribution<IntType>::result_type\npoisson_distribution<IntType>::operator()(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n  using random_internal::GenerateSignedTag;\n\n  if (p.split_ != 0) {\n    // Use Knuth's algorithm with range splitting to avoid floating-point\n    // errors. Knuth's algorithm is: Ui is a sequence of uniform variates on\n    // (0,1); return the number of variates required for product(Ui) <\n    // exp(-lambda).\n    //\n    // The expected number of variates required for Knuth's method can be\n    // computed as follows:\n    // The expected value of U is 0.5, so solving for 0.5^n < exp(-lambda) gives\n    // the expected number of uniform variates\n    // required for a given lambda, which is:\n    //  lambda = [2, 5,  9, 10, 11, 12, 13, 14, 15, 16, 17]\n    //  n      = [3, 8, 13, 15, 16, 18, 19, 21, 22, 24, 25]\n    //\n    result_type n = 0;\n    for (int split = p.split_; split > 0; --split) {\n      double r = 1.0;\n      do {\n        r *= GenerateRealFromBits<double, GeneratePositiveTag, true>(\n            fast_u64_(g));  // U(-1, 0)\n        ++n;\n      } while (r > p.emu_);\n      --n;\n    }\n    return n;\n  }\n\n  // Use ratio of uniforms method.\n  //\n  // Let u ~ Uniform(0, 1), v ~ Uniform(-1, 1),\n  //     a = lambda + 1/2,\n  //     s = 1.5 - sqrt(3/e) + sqrt(2(lambda + 1/2)/e),\n  //     x = s * v/u + a.\n  // P(floor(x) = k | u^2 < f(floor(x))/k), where\n  // f(m) = lambda^m exp(-lambda)/ m!, for 0 <= m, and f(m) = 0 otherwise,\n  // and k = max(f).\n  const double a = p.mean_ + 0.5;\n  for (;;) {\n    const double u = GenerateRealFromBits<double, GeneratePositiveTag, false>(\n        fast_u64_(g));  // U(0, 1)\n    const double v = GenerateRealFromBits<double, GenerateSignedTag, false>(\n        fast_u64_(g));  // U(-1, 1)\n\n    const double x = std::floor(p.s_ * v / u + a);\n    if (x < 0) continue;  // f(negative) = 0\n    const double rhs = x * p.lmu_;\n    // clang-format off\n    double s = (x <= 1.0) ? 0.0\n             : (x == 2.0) ? 0.693147180559945\n             : absl::random_internal::StirlingLogFactorial(x);\n    // clang-format on\n    const double lhs = 2.0 * std::log(u) + p.log_k_ + s;\n    if (lhs < rhs) {\n      return x > static_cast<double>((max)())\n                 ? (max)()\n                 : static_cast<result_type>(x);  // f(x)/k >= u^2\n    }\n  }\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const poisson_distribution<IntType>& x) {\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os.precision(random_internal::stream_precision_helper<double>::kPrecision);\n  os << x.mean();\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    poisson_distribution<IntType>& x) {     // NOLINT(runtime/references)\n  using param_type = typename poisson_distribution<IntType>::param_type;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  double mean = random_internal::read_floating_point<double>(is);\n  if (!is.fail()) {\n    x.param(param_type(mean));\n  }\n  return is;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03892",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/poisson_distribution.h",
  "source_line": 31,
  "validation_status": "validated"
}