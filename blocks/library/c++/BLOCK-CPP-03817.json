{
  "code": "{\n  // SFINAE to detect whether the URBG type includes a member matching\n  // bool InvokeMock(base_internal::FastTypeIdType, void*, void*).\n  //\n  // These live inside BitGenRef so that they have friend access\n  // to MockingBitGen. (see similar methods in DistributionCaller).\n  template <template <class...> class Trait, class AlwaysVoid, class... Args>\n  struct detector : std::false_type {};\n  template <template <class...> class Trait, class... Args>\n  struct detector<Trait, absl::void_t<Trait<Args...>>, Args...>\n      : std::true_type {};\n\n  template <class T>\n  using invoke_mock_t = decltype(std::declval<T*>()->InvokeMock(\n      std::declval<base_internal::FastTypeIdType>(), std::declval<void*>(),\n      std::declval<void*>()));\n\n  template <typename T>\n  using HasInvokeMock = typename detector<invoke_mock_t, void, T>::type;\n\n public:\n  BitGenRef(const BitGenRef&) = default;\n  BitGenRef(BitGenRef&&) = default;\n  BitGenRef& operator=(const BitGenRef&) = default;\n  BitGenRef& operator=(BitGenRef&&) = default;\n\n  template <typename URBG, typename absl::enable_if_t<\n                               (!std::is_same<URBG, BitGenRef>::value &&\n                                random_internal::is_urbg<URBG>::value &&\n                                !HasInvokeMock<URBG>::value)>* = nullptr>\n  BitGenRef(URBG& gen)  // NOLINT\n      : t_erased_gen_ptr_(reinterpret_cast<uintptr_t>(&gen)),\n        mock_call_(NotAMock),\n        generate_impl_fn_(ImplFn<URBG>) {}\n\n  template <typename URBG,\n            typename absl::enable_if_t<(!std::is_same<URBG, BitGenRef>::value &&\n                                        random_internal::is_urbg<URBG>::value &&\n                                        HasInvokeMock<URBG>::value)>* = nullptr>\n  BitGenRef(URBG& gen)  // NOLINT\n      : t_erased_gen_ptr_(reinterpret_cast<uintptr_t>(&gen)),\n        mock_call_(&MockCall<URBG>),\n        generate_impl_fn_(ImplFn<URBG>) {}\n\n  using result_type = uint64_t;\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  result_type operator()() { return generate_impl_fn_(t_erased_gen_ptr_); }\n\n private:\n  using impl_fn = result_type (*)(uintptr_t);\n  using mock_call_fn = bool (*)(uintptr_t, base_internal::FastTypeIdType, void*,\n                                void*);\n\n  template <typename URBG>\n  static result_type ImplFn(uintptr_t ptr) {\n    // Ensure that the return values from operator() fill the entire\n    // range promised by result_type, min() and max().\n    absl::random_internal::FastUniformBits<result_type> fast_uniform_bits;\n    return fast_uniform_bits(*reinterpret_cast<URBG*>(ptr));\n  }\n\n  // Get a type-erased InvokeMock pointer.\n  template <typename URBG>\n  static bool MockCall(uintptr_t gen_ptr, base_internal::FastTypeIdType type,\n                       void* result, void* arg_tuple) {\n    return reinterpret_cast<URBG*>(gen_ptr)->InvokeMock(type, result,\n                                                        arg_tuple);\n  }\n  static bool NotAMock(uintptr_t, base_internal::FastTypeIdType, void*, void*) {\n    return false;\n  }\n\n  inline bool InvokeMock(base_internal::FastTypeIdType type, void* args_tuple,\n                         void* result) {\n    if (mock_call_ == NotAMock) return false;  // avoids an indirect call.\n    return mock_call_(t_erased_gen_ptr_, type, args_tuple, result);\n  }\n\n  uintptr_t t_erased_gen_ptr_;\n  mock_call_fn mock_call_;\n  impl_fn generate_impl_fn_;\n\n  template <typename>\n  friend struct ::absl::random_internal::DistributionCaller;  // for InvokeMock\n  friend class ::absl::random_internal::MockHelpers;          // for InvokeMock\n}",
  "id": "BLOCK-CPP-03817",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/bit_gen_ref.h",
  "source_line": 87,
  "validation_status": "validated"
}