{
  "code": "{\nnamespace comments {\n\nclass Lexer;\nclass TextTokenRetokenizer;\nstruct CommandInfo;\nclass CommandTraits;\n\nnamespace tok {\nenum TokenKind {\n  eof,\n  newline,\n  text,\n  unknown_command,   // Command that does not have an ID.\n  backslash_command, // Command with an ID, that used backslash marker.\n  at_command,        // Command with an ID, that used 'at' marker.\n  verbatim_block_begin,\n  verbatim_block_line,\n  verbatim_block_end,\n  verbatim_line_name,\n  verbatim_line_text,\n  html_start_tag,     // <tag\n  html_ident,         // attr\n  html_equals,        // =\n  html_quoted_string, // \"blah\\\"blah\" or 'blah\\'blah'\n  html_greater,       // >\n  html_slash_greater, // />\n  html_end_tag        // </tag\n};\n} // end namespace tok\n\n/// Comment token.\nclass Token {\n  friend class Lexer;\n  friend class TextTokenRetokenizer;\n\n  /// The location of the token.\n  SourceLocation Loc;\n\n  /// The actual kind of the token.\n  tok::TokenKind Kind;\n\n  /// Integer value associated with a token.\n  ///\n  /// If the token is a known command, contains command ID and TextPtr is\n  /// unused (command spelling can be found with CommandTraits).  Otherwise,\n  /// contains the length of the string that starts at TextPtr.\n  unsigned IntVal;\n\n  /// Length of the token spelling in comment.  Can be 0 for synthenized\n  /// tokens.\n  unsigned Length;\n\n  /// Contains text value associated with a token.\n  const char *TextPtr;\n\npublic:\n  SourceLocation getLocation() const LLVM_READONLY { return Loc; }\n  void setLocation(SourceLocation SL) { Loc = SL; }\n\n  SourceLocation getEndLocation() const LLVM_READONLY {\n    if (Length == 0 || Length == 1)\n      return Loc;\n    return Loc.getLocWithOffset(Length - 1);\n  }\n\n  tok::TokenKind getKind() const LLVM_READONLY { return Kind; }\n  void setKind(tok::TokenKind K) { Kind = K; }\n\n  bool is(tok::TokenKind K) const LLVM_READONLY { return Kind == K; }\n  bool isNot(tok::TokenKind K) const LLVM_READONLY { return Kind != K; }\n\n  unsigned getLength() const LLVM_READONLY { return Length; }\n  void setLength(unsigned L) { Length = L; }\n\n  StringRef getText() const LLVM_READONLY {\n    assert(is(tok::text));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setText(StringRef Text) {\n    assert(is(tok::text));\n    TextPtr = Text.data();\n    IntVal = Text.size();\n  }\n\n  StringRef getUnknownCommandName() const LLVM_READONLY {\n    assert(is(tok::unknown_command));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setUnknownCommandName(StringRef Name) {\n    assert(is(tok::unknown_command));\n    TextPtr = Name.data();\n    IntVal = Name.size();\n  }\n\n  unsigned getCommandID() const LLVM_READONLY {\n    assert(is(tok::backslash_command) || is(tok::at_command));\n    return IntVal;\n  }\n\n  void setCommandID(unsigned ID) {\n    assert(is(tok::backslash_command) || is(tok::at_command));\n    IntVal = ID;\n  }\n\n  unsigned getVerbatimBlockID() const LLVM_READONLY {\n    assert(is(tok::verbatim_block_begin) || is(tok::verbatim_block_end));\n    return IntVal;\n  }\n\n  void setVerbatimBlockID(unsigned ID) {\n    assert(is(tok::verbatim_block_begin) || is(tok::verbatim_block_end));\n    IntVal = ID;\n  }\n\n  StringRef getVerbatimBlockText() const LLVM_READONLY {\n    assert(is(tok::verbatim_block_line));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setVerbatimBlockText(StringRef Text) {\n    assert(is(tok::verbatim_block_line));\n    TextPtr = Text.data();\n    IntVal = Text.size();\n  }\n\n  unsigned getVerbatimLineID() const LLVM_READONLY {\n    assert(is(tok::verbatim_line_name));\n    return IntVal;\n  }\n\n  void setVerbatimLineID(unsigned ID) {\n    assert(is(tok::verbatim_line_name));\n    IntVal = ID;\n  }\n\n  StringRef getVerbatimLineText() const LLVM_READONLY {\n    assert(is(tok::verbatim_line_text));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setVerbatimLineText(StringRef Text) {\n    assert(is(tok::verbatim_line_text));\n    TextPtr = Text.data();\n    IntVal = Text.size();\n  }\n\n  StringRef getHTMLTagStartName() const LLVM_READONLY {\n    assert(is(tok::html_start_tag));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setHTMLTagStartName(StringRef Name) {\n    assert(is(tok::html_start_tag));\n    TextPtr = Name.data();\n    IntVal = Name.size();\n  }\n\n  StringRef getHTMLIdent() const LLVM_READONLY {\n    assert(is(tok::html_ident));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setHTMLIdent(StringRef Name) {\n    assert(is(tok::html_ident));\n    TextPtr = Name.data();\n    IntVal = Name.size();\n  }\n\n  StringRef getHTMLQuotedString() const LLVM_READONLY {\n    assert(is(tok::html_quoted_string));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setHTMLQuotedString(StringRef Str) {\n    assert(is(tok::html_quoted_string));\n    TextPtr = Str.data();\n    IntVal = Str.size();\n  }\n\n  StringRef getHTMLTagEndName() const LLVM_READONLY {\n    assert(is(tok::html_end_tag));\n    return StringRef(TextPtr, IntVal);\n  }\n\n  void setHTMLTagEndName(StringRef Name) {\n    assert(is(tok::html_end_tag));\n    TextPtr = Name.data();\n    IntVal = Name.size();\n  }\n\n  void dump(const Lexer &L, const SourceManager &SM) const;\n};\n\n/// Comment lexer.\nclass Lexer {\nprivate:\n  Lexer(const Lexer &) = delete;\n  void operator=(const Lexer &) = delete;\n\n  /// Allocator for strings that are semantic values of tokens and have to be\n  /// computed (for example, resolved decimal character references).\n  llvm::BumpPtrAllocator &Allocator;\n\n  DiagnosticsEngine &Diags;\n\n  const CommandTraits &Traits;\n\n  const char *const BufferStart;\n  const char *const BufferEnd;\n\n  const char *BufferPtr;\n\n  /// One past end pointer for the current comment.  For BCPL comments points\n  /// to newline or BufferEnd, for C comments points to star in '*/'.\n  const char *CommentEnd;\n\n  SourceLocation FileLoc;\n\n  /// If true, the commands, html tags, etc will be parsed and reported as\n  /// separate tokens inside the comment body. If false, the comment text will\n  /// be parsed into text and newline tokens.\n  bool ParseCommands;\n\n  enum LexerCommentState : uint8_t {\n    LCS_BeforeComment,\n    LCS_InsideBCPLComment,\n    LCS_InsideCComment,\n    LCS_BetweenComments\n  };\n\n  /// Low-level lexer state, track if we are inside or outside of comment.\n  LexerCommentState CommentState;\n\n  enum LexerState : uint8_t {\n    /// Lexing normal comment text\n    LS_Normal,\n\n    /// Finished lexing verbatim block beginning command, will lex first body\n    /// line.\n    LS_VerbatimBlockFirstLine,\n\n    /// Lexing verbatim block body line-by-line, skipping line-starting\n    /// decorations.\n    LS_VerbatimBlockBody,\n\n    /// Finished lexing verbatim line beginning command, will lex text (one\n    /// line).\n    LS_VerbatimLineText,\n\n    /// Finished lexing \\verbatim <TAG \\endverbatim part, lexing tag attributes.\n    LS_HTMLStartTag,\n\n    /// Finished lexing \\verbatim </TAG \\endverbatim part, lexing '>'.\n    LS_HTMLEndTag\n  };\n\n  /// Current lexing mode.\n  LexerState State;\n\n  /// If State is LS_VerbatimBlock, contains the name of verbatim end\n  /// command, including command marker.\n  SmallString<16> VerbatimBlockEndCommandName;\n\n  /// Given a character reference name (e.g., \"lt\"), return the character that\n  /// it stands for (e.g., \"<\").\n  StringRef resolveHTMLNamedCharacterReference(StringRef Name) const;\n\n  /// Given a Unicode codepoint as base-10 integer, return the character.\n  StringRef resolveHTMLDecimalCharacterReference(StringRef Name) const;\n\n  /// Given a Unicode codepoint as base-16 integer, return the character.\n  StringRef resolveHTMLHexCharacterReference(StringRef Name) const;\n\n  void formTokenWithChars(Token &Result, const char *TokEnd,\n                          tok::TokenKind Kind);\n\n  void formTextToken(Token &Result, const char *TokEnd) {\n    StringRef Text(BufferPtr, TokEnd - BufferPtr);\n    formTokenWithChars(Result, TokEnd, tok::text);\n    Result.setText(Text);\n  }\n\n  SourceLocation getSourceLocation(const char *Loc) const {\n    assert(Loc >= BufferStart && Loc <= BufferEnd &&\n           \"Location out of range for this buffer!\");\n\n    const unsigned CharNo = Loc - BufferStart;\n    return FileLoc.getLocWithOffset(CharNo);\n  }\n\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) {\n    return Diags.Report(Loc, DiagID);\n  }\n\n  /// Eat string matching regexp \\code \\s*\\* \\endcode.\n  void skipLineStartingDecorations();\n\n  /// Skip over pure text.\n  const char *skipTextToken();\n\n  /// Lex comment text, including commands if ParseCommands is set to true.\n  void lexCommentText(Token &T);\n\n  void setupAndLexVerbatimBlock(Token &T, const char *TextBegin, char Marker,\n                                const CommandInfo *Info);\n\n  void lexVerbatimBlockFirstLine(Token &T);\n\n  void lexVerbatimBlockBody(Token &T);\n\n  void setupAndLexVerbatimLine(Token &T, const char *TextBegin,\n                               const CommandInfo *Info);\n\n  void lexVerbatimLineText(Token &T);\n\n  void lexHTMLCharacterReference(Token &T);\n\n  void setupAndLexHTMLStartTag(Token &T);\n\n  void lexHTMLStartTag(Token &T);\n\n  void setupAndLexHTMLEndTag(Token &T);\n\n  void lexHTMLEndTag(Token &T);\n\npublic:\n  Lexer(llvm::BumpPtrAllocator &Allocator, DiagnosticsEngine &Diags,\n        const CommandTraits &Traits, SourceLocation FileLoc,\n        const char *BufferStart, const char *BufferEnd,\n        bool ParseCommands = true);\n\n  void lex(Token &T);\n\n  StringRef getSpelling(const Token &Tok, const SourceManager &SourceMgr) const;\n};\n\n} // end namespace comments\n}",
  "id": "BLOCK-CPP-23441",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CommentLexer.h",
  "source_line": 23,
  "validation_status": "validated"
}