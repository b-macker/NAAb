{
  "code": "{\n  /// Source - The action which caused the creation of this job.\n  const Action &Source;\n\n  /// Tool - The tool which caused the creation of this job.\n  const Tool &Creator;\n\n  /// Whether and how to generate response files if the arguments are too long.\n  ResponseFileSupport ResponseSupport;\n\n  /// The executable to run.\n  const char *Executable;\n\n  /// Optional argument to prepend.\n  const char *PrependArg;\n\n  /// The list of program arguments (not including the implicit first\n  /// argument, which will be the executable).\n  llvm::opt::ArgStringList Arguments;\n\n  /// The list of program inputs.\n  std::vector<InputInfo> InputInfoList;\n\n  /// The list of program arguments which are outputs. May be empty.\n  std::vector<std::string> OutputFilenames;\n\n  /// Response file name, if this command is set to use one, or nullptr\n  /// otherwise\n  const char *ResponseFile = nullptr;\n\n  /// The input file list in case we need to emit a file list instead of a\n  /// proper response file\n  llvm::opt::ArgStringList InputFileList;\n\n  /// String storage if we need to create a new argument to specify a response\n  /// file\n  std::string ResponseFileFlag;\n\n  /// See Command::setEnvironment\n  std::vector<const char *> Environment;\n\n  /// Optional redirection for stdin, stdout, stderr.\n  std::vector<std::optional<std::string>> RedirectFiles;\n\n  /// Information on executable run provided by OS.\n  mutable std::optional<llvm::sys::ProcessStatistics> ProcStat;\n\n  /// When a response file is needed, we try to put most arguments in an\n  /// exclusive file, while others remains as regular command line arguments.\n  /// This functions fills a vector with the regular command line arguments,\n  /// argv, excluding the ones passed in a response file.\n  void buildArgvForResponseFile(llvm::SmallVectorImpl<const char *> &Out) const;\n\n  /// Encodes an array of C strings into a single string separated by whitespace.\n  /// This function will also put in quotes arguments that have whitespaces and\n  /// will escape the regular backslashes (used in Windows paths) and quotes.\n  /// The results are the contents of a response file, written into a raw_ostream.\n  void writeResponseFile(raw_ostream &OS) const;\n\npublic:\n  /// Whether to print the input filenames when executing.\n  bool PrintInputFilenames = false;\n\n  /// Whether the command will be executed in this process or not.\n  bool InProcess = false;\n\n  Command(const Action &Source, const Tool &Creator,\n          ResponseFileSupport ResponseSupport, const char *Executable,\n          const llvm::opt::ArgStringList &Arguments, ArrayRef<InputInfo> Inputs,\n          ArrayRef<InputInfo> Outputs = std::nullopt,\n          const char *PrependArg = nullptr);\n  // FIXME: This really shouldn't be copyable, but is currently copied in some\n  // error handling in Driver::generateCompilationDiagnostics.\n  Command(const Command &) = default;\n  virtual ~Command() = default;\n\n  virtual void Print(llvm::raw_ostream &OS, const char *Terminator, bool Quote,\n                     CrashReportInfo *CrashInfo = nullptr) const;\n\n  virtual int Execute(ArrayRef<std::optional<StringRef>> Redirects,\n                      std::string *ErrMsg, bool *ExecutionFailed) const;\n\n  /// getSource - Return the Action which caused the creation of this job.\n  const Action &getSource() const { return Source; }\n\n  /// getCreator - Return the Tool which caused the creation of this job.\n  const Tool &getCreator() const { return Creator; }\n\n  /// Returns the kind of response file supported by the current invocation.\n  const ResponseFileSupport &getResponseFileSupport() {\n    return ResponseSupport;\n  }\n\n  /// Set to pass arguments via a response file when launching the command\n  void setResponseFile(const char *FileName);\n\n  /// Set an input file list, necessary if you specified an RF_FileList response\n  /// file support.\n  void setInputFileList(llvm::opt::ArgStringList List) {\n    InputFileList = std::move(List);\n  }\n\n  /// Sets the environment to be used by the new process.\n  /// \\param NewEnvironment An array of environment variables.\n  /// \\remark If the environment remains unset, then the environment\n  ///         from the parent process will be used.\n  virtual void setEnvironment(llvm::ArrayRef<const char *> NewEnvironment);\n\n  void\n  setRedirectFiles(const std::vector<std::optional<std::string>> &Redirects);\n\n  void replaceArguments(llvm::opt::ArgStringList List) {\n    Arguments = std::move(List);\n  }\n\n  void replaceExecutable(const char *Exe) { Executable = Exe; }\n\n  const char *getExecutable() const { return Executable; }\n\n  const llvm::opt::ArgStringList &getArguments() const { return Arguments; }\n\n  const std::vector<InputInfo> &getInputInfos() const { return InputInfoList; }\n\n  const std::vector<std::string> &getOutputFilenames() const {\n    return OutputFilenames;\n  }\n\n  std::optional<llvm::sys::ProcessStatistics> getProcessStatistics() const {\n    return ProcStat;\n  }\n\nprotected:\n  /// Optionally print the filenames to be compiled\n  void PrintFileNames() const;\n}",
  "id": "BLOCK-CPP-17796",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Job.h",
  "source_line": 106,
  "validation_status": "validated"
}