{
  "code": "    #include <spdlog/details/file_helper.h>\n#include <spdlog/common.h>\n#include <spdlog/details/os.h>\n#include <cerrno>\n#include <chrono>\n#include <cstdio>\n#include <string>\n#include <thread>\n#include <tuple>\n\nusing namespace spdlog;\nusing namespace details;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00216_execute() {\n    {\n\nSPDLOG_INLINE file_helper::file_helper(const file_event_handlers &event_handlers)\n    : event_handlers_(event_handlers) {}\n\nSPDLOG_INLINE file_helper::~file_helper() { close(); }\n\nSPDLOG_INLINE void file_helper::open(const filename_t &fname, bool truncate) {\n    close();\n    filename_ = fname;\n\n    auto *mode = SPDLOG_FILENAME_T(\"ab\");\n    auto *trunc_mode = SPDLOG_FILENAME_T(\"wb\");\n\n    if (event_handlers_.before_open) {\n        event_handlers_.before_open(filename_);\n    }\n    for (int tries = 0; tries < open_tries_; ++tries) {\n        // create containing folder if not exists already.\n        os::create_dir(os::dir_name(fname));\n        if (truncate) {\n            // Truncate by opening-and-closing a tmp file in \"wb\" mode, always\n            // opening the actual log-we-write-to in \"ab\" mode, since that\n            // interacts more politely with eternal processes that might\n            // rotate/truncate the file underneath us.\n            std::FILE *tmp;\n            if (os::fopen_s(&tmp, fname, trunc_mode)) {\n                continue;\n            }\n            std::fclose(tmp);\n        }\n        if (!os::fopen_s(&fd_, fname, mode)) {\n            if (event_handlers_.after_open) {\n                event_handlers_.after_open(filename_, fd_);\n            }\n            return;\n        }\n\n        details::os::sleep_for_millis(open_interval_);\n    }\n\n    throw_spdlog_ex(\"Failed opening file \" + os::filename_to_str(filename_) + \" for writing\",\n                    errno);\n}\n\nSPDLOG_INLINE void file_helper::reopen(bool truncate) {\n    if (filename_.empty()) {\n        throw_spdlog_ex(\"Failed re opening file - was not opened before\");\n    }\n    this->open(filename_, truncate);\n}\n\nSPDLOG_INLINE void file_helper::flush() {\n    if (std::fflush(fd_) != 0) {\n        throw_spdlog_ex(\"Failed flush to file \" + os::filename_to_str(filename_), errno);\n    }\n}\n\nSPDLOG_INLINE void file_helper::sync() {\n    if (!os::fsync(fd_)) {\n        throw_spdlog_ex(\"Failed to fsync file \" + os::filename_to_str(filename_), errno);\n    }\n}\n\nSPDLOG_INLINE void file_helper::close() {\n    if (fd_ != nullptr) {\n        if (event_handlers_.before_close) {\n            event_handlers_.before_close(filename_, fd_);\n        }\n\n        std::fclose(fd_);\n        fd_ = nullptr;\n\n        if (event_handlers_.after_close) {\n            event_handlers_.after_close(filename_);\n        }\n    }\n}\n\nSPDLOG_INLINE void file_helper::write(const memory_buf_t &buf) {\n    if(fd_ == nullptr) return;\n    size_t msg_size = buf.size();\n    auto data = buf.data();\n    if (std::fwrite(data, 1, msg_size, fd_) != msg_size) {\n        throw_spdlog_ex(\"Failed writing to file \" + os::filename_to_str(filename_), errno);\n    }\n}\n\nSPDLOG_INLINE size_t file_helper::size() const {\n    if (fd_ == nullptr) {\n        throw_spdlog_ex(\"Cannot use size() on closed file \" + os::filename_to_str(filename_));\n    }\n    return os::filesize(fd_);\n}\n\nSPDLOG_INLINE const filename_t &file_helper::filename() const { return filename_; }\n\n//\n// return file path and its extension:\n//\n// \"mylog.txt\" => (\"mylog\", \".txt\")\n// \"mylog\" => (\"mylog\", \"\")\n// \"mylog.\" => (\"mylog.\", \"\")\n// \"/dir1/dir2/mylog.txt\" => (\"/dir1/dir2/mylog\", \".txt\")\n//\n// the starting dot in filenames is ignored (hidden files):\n//\n// \".mylog\" => (\".mylog\". \"\")\n// \"my_folder/.mylog\" => (\"my_folder/.mylog\", \"\")\n// \"my_folder/.mylog.txt\" => (\"my_folder/.mylog\", \".txt\")\nSPDLOG_INLINE std::tuple<filename_t, filename_t> file_helper::split_by_extension(\n    const filename_t &fname) {\n    auto ext_index = fname.rfind('.');\n\n    // no valid extension found - return whole path and empty string as\n    // extension\n    if (ext_index == filename_t::npos || ext_index == 0 || ext_index == fname.size() - 1) {\n        return std::make_tuple(fname, filename_t());\n    }\n\n    // treat cases like \"/etc/rc.d/somelogfile or \"/abc/.hiddenfile\"\n    auto folder_index = fname.find_last_of(details::os::folder_seps_filename);\n    if (folder_index != filename_t::npos && folder_index >= ext_index - 1) {\n        return std::make_tuple(fname, filename_t());\n    }\n\n    // finally - return a valid base and extension tuple\n    return std::make_tuple(fname.substr(0, ext_index), fname.substr(ext_index));\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00216",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/file_helper-inl.h",
  "source_line": 21,
  "validation_status": "validated"
}