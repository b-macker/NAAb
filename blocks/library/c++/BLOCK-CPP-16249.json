{
  "code": "{\n  friend class DiagnosticsEngine;\n  friend class PartialDiagnostic;\n\n  mutable DiagnosticsEngine *DiagObj = nullptr;\n\n  /// Status variable indicating if this diagnostic is still active.\n  ///\n  // NOTE: This field is redundant with DiagObj (IsActive iff (DiagObj == 0)),\n  // but LLVM is not currently smart enough to eliminate the null check that\n  // Emit() would end up with if we used that as our status variable.\n  mutable bool IsActive = false;\n\n  /// Flag indicating that this diagnostic is being emitted via a\n  /// call to ForceEmit.\n  mutable bool IsForceEmit = false;\n\n  DiagnosticBuilder() = default;\n\n  explicit DiagnosticBuilder(DiagnosticsEngine *diagObj)\n      : StreamingDiagnostic(&diagObj->DiagStorage), DiagObj(diagObj),\n        IsActive(true) {\n    assert(diagObj && \"DiagnosticBuilder requires a valid DiagnosticsEngine!\");\n    assert(DiagStorage &&\n           \"DiagnosticBuilder requires a valid DiagnosticStorage!\");\n    DiagStorage->NumDiagArgs = 0;\n    DiagStorage->DiagRanges.clear();\n    DiagStorage->FixItHints.clear();\n  }\n\nprotected:\n  /// Clear out the current diagnostic.\n  void Clear() const {\n    DiagObj = nullptr;\n    IsActive = false;\n    IsForceEmit = false;\n  }\n\n  /// Determine whether this diagnostic is still active.\n  bool isActive() const { return IsActive; }\n\n  /// Force the diagnostic builder to emit the diagnostic now.\n  ///\n  /// Once this function has been called, the DiagnosticBuilder object\n  /// should not be used again before it is destroyed.\n  ///\n  /// \\returns true if a diagnostic was emitted, false if the\n  /// diagnostic was suppressed.\n  bool Emit() {\n    // If this diagnostic is inactive, then its soul was stolen by the copy ctor\n    // (or by a subclass, as in SemaDiagnosticBuilder).\n    if (!isActive()) return false;\n\n    // Process the diagnostic.\n    bool Result = DiagObj->EmitCurrentDiagnostic(IsForceEmit);\n\n    // This diagnostic is dead.\n    Clear();\n\n    return Result;\n  }\n\npublic:\n  /// Copy constructor.  When copied, this \"takes\" the diagnostic info from the\n  /// input and neuters it.\n  DiagnosticBuilder(const DiagnosticBuilder &D) : StreamingDiagnostic() {\n    DiagObj = D.DiagObj;\n    DiagStorage = D.DiagStorage;\n    IsActive = D.IsActive;\n    IsForceEmit = D.IsForceEmit;\n    D.Clear();\n  }\n\n  template <typename T> const DiagnosticBuilder &operator<<(const T &V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T,\n            typename = std::enable_if_t<!std::is_lvalue_reference<T>::value>>\n  const DiagnosticBuilder &operator<<(T &&V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  DiagnosticBuilder &operator=(const DiagnosticBuilder &) = delete;\n\n  /// Emits the diagnostic.\n  ~DiagnosticBuilder() { Emit(); }\n\n  /// Forces the diagnostic to be emitted.\n  const DiagnosticBuilder &setForceEmit() const {\n    IsForceEmit = true;\n    return *this;\n  }\n\n  void addFlagValue(StringRef V) const { DiagObj->FlagValue = std::string(V); }\n}",
  "id": "BLOCK-CPP-16249",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Diagnostic.h",
  "source_line": 1266,
  "validation_status": "validated"
}