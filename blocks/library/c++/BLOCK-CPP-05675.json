{
  "code": "#include <Availability.h>\n#include <TargetConditionals.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cmath>\n#include <cstddef>\n#include <cstring>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/unaligned_access.h\"\n#include \"absl/base/port.h\"\n#include \"absl/container/fixed_array.h\"\n#include \"absl/hash/internal/city.h\"\n#include \"absl/hash/internal/low_level_hash.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/variant.h\"\n#include \"absl/utility/utility.h\"\n#include <filesystem>  // NOLINT\n#include <string_view>\n\nusing namespace absl;\nusing namespace hash_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05675_execute() {\n    {\n private:\n  struct State : HashStateBase<State> {\n    static State combine_contiguous(State hash_state, const unsigned char*,\n                                    size_t);\n    using State::HashStateBase::combine_contiguous;\n  };\n\n  struct UniquelyRepresentedProbe {\n    template <typename H, typename T>\n    static auto Invoke(H state, const T& value)\n        -> absl::enable_if_t<is_uniquely_represented<T>::value, H> {\n      return hash_internal::hash_bytes(std::move(state), value);\n    }\n  };\n\n  struct HashValueProbe {\n    template <typename H, typename T>\n    static auto Invoke(H state, const T& value) -> absl::enable_if_t<\n        std::is_same<H,\n                     decltype(AbslHashValue(std::move(state), value))>::value,\n        H> {\n      return AbslHashValue(std::move(state), value);\n    }\n  };\n\n  struct LegacyHashProbe {\n#if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_\n    template <typename H, typename T>\n    static auto Invoke(H state, const T& value) -> absl::enable_if_t<\n        std::is_convertible<\n            decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>()(value)),\n            size_t>::value,\n        H> {\n      return hash_internal::hash_bytes(\n          std::move(state),\n          ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>{}(value));\n    }\n#endif  // ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_\n  };\n\n  struct StdHashProbe {\n    template <typename H, typename T>\n    static auto Invoke(H state, const T& value)\n        -> absl::enable_if_t<type_traits_internal::IsHashable<T>::value, H> {\n      return hash_internal::hash_bytes(std::move(state), std::hash<T>{}(value));\n    }\n  };\n\n  template <typename Hash, typename T>\n  struct Probe : Hash {\n   private:\n    template <typename H, typename = decltype(H::Invoke(\n                              std::declval<State>(), std::declval<const T&>()))>\n    static std::true_type Test(int);\n    template <typename U>\n    static std::false_type Test(char);\n\n   public:\n    static constexpr bool value = decltype(Test<Hash>(0))::value;\n  };\n\n public:\n  // Probe each implementation in order.\n  // disjunction provides short circuiting wrt instantiation.\n  template <typename T>\n  using Apply = absl::disjunction<         //\n      Probe<UniquelyRepresentedProbe, T>,  //\n      Probe<HashValueProbe, T>,            //\n      Probe<LegacyHashProbe, T>,           //\n      Probe<StdHashProbe, T>,              //\n      std::false_type>;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05675",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/internal/hash.h",
  "source_line": 916,
  "validation_status": "validated"
}