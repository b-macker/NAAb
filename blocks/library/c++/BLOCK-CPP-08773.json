{
  "code": "#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclContextInternals.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include <cstddef>\n#include <iterator>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-08773_execute() {\n    {\n\n/// all_lookups_iterator - An iterator that provides a view over the results\n/// of looking up every possible name.\nclass DeclContext::all_lookups_iterator {\n  StoredDeclsMap::iterator It, End;\n\npublic:\n  using value_type = lookup_result;\n  using reference = lookup_result;\n  using pointer = lookup_result;\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n\n  all_lookups_iterator() = default;\n  all_lookups_iterator(StoredDeclsMap::iterator It,\n                       StoredDeclsMap::iterator End)\n      : It(It), End(End) {}\n\n  DeclarationName getLookupName() const { return It->first; }\n\n  reference operator*() const { return It->second.getLookupResult(); }\n  pointer operator->() const { return It->second.getLookupResult(); }\n\n  all_lookups_iterator& operator++() {\n    // Filter out using directives. They don't belong as results from name\n    // lookup anyways, except as an implementation detail. Users of the API\n    // should not expect to get them (or worse, rely on it).\n    do {\n      ++It;\n    } while (It != End &&\n             It->first == DeclarationName::getUsingDirectiveName());\n\n    return *this;\n  }\n\n  all_lookups_iterator operator++(int) {\n    all_lookups_iterator tmp(*this);\n    ++(*this);\n    return tmp;\n  }\n\n  friend bool operator==(all_lookups_iterator x, all_lookups_iterator y) {\n    return x.It == y.It;\n  }\n\n  friend bool operator!=(all_lookups_iterator x, all_lookups_iterator y) {\n    return x.It != y.It;\n  }\n};\n\ninline DeclContext::lookups_range DeclContext::lookups() const {\n  DeclContext *Primary = const_cast<DeclContext*>(this)->getPrimaryContext();\n  if (Primary->hasExternalVisibleStorage())\n    getParentASTContext().getExternalSource()->completeVisibleDeclsMap(Primary);\n  if (StoredDeclsMap *Map = Primary->buildLookup())\n    return lookups_range(all_lookups_iterator(Map->begin(), Map->end()),\n                         all_lookups_iterator(Map->end(), Map->end()));\n\n  // Synthesize an empty range. This requires that two default constructed\n  // versions of these iterators form a valid empty range.\n  return lookups_range(all_lookups_iterator(), all_lookups_iterator());\n}\n\ninline DeclContext::lookups_range\nDeclContext::noload_lookups(bool PreserveInternalState) const {\n  DeclContext *Primary = const_cast<DeclContext*>(this)->getPrimaryContext();\n  if (!PreserveInternalState)\n    Primary->loadLazyLocalLexicalLookups();\n  if (StoredDeclsMap *Map = Primary->getLookupPtr())\n    return lookups_range(all_lookups_iterator(Map->begin(), Map->end()),\n                         all_lookups_iterator(Map->end(), Map->end()));\n\n  // Synthesize an empty range. This requires that two default constructed\n  // versions of these iterators form a valid empty range.\n  return lookups_range(all_lookups_iterator(), all_lookups_iterator());\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-08773",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclLookups.h",
  "source_line": 24,
  "validation_status": "validated"
}