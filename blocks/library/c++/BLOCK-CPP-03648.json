{
  "code": "{\n//    public:\n//     template <typename H>\n//     friend H AbslHashValue(H state, const Interface& value) {\n//       state = H::combine(std::move(state), std::type_index(typeid(*this)));\n//       value.HashValue(absl::HashState::Create(&state));\n//       return state;\n//     }\n//    private:\n//     virtual void HashValue(absl::HashState state) const = 0;\n//   };\n//\n//   class Impl : Interface {\n//    private:\n//     void HashValue(absl::HashState state) const override {\n//       absl::HashState::combine(std::move(state), v1_, v2_);\n//     }\n//     int v1_;\n//     std::string v2_;\n//   };\nclass HashState : public hash_internal::HashStateBase<HashState> {\n public:\n  // HashState::Create()\n  //\n  // Create a new `HashState` instance that wraps `state`. All calls to\n  // `combine()` and `combine_contiguous()` on the new instance will be\n  // redirected to the original `state` object. The `state` object must outlive\n  // the `HashState` instance.\n  template <typename T>\n  static HashState Create(T* state) {\n    HashState s;\n    s.Init(state);\n    return s;\n  }\n\n  HashState(const HashState&) = delete;\n  HashState& operator=(const HashState&) = delete;\n  HashState(HashState&&) = default;\n  HashState& operator=(HashState&&) = default;\n\n  // HashState::combine()\n  //\n  // Combines an arbitrary number of values into a hash state, returning the\n  // updated state.\n  using HashState::HashStateBase::combine;\n\n  // HashState::combine_contiguous()\n  //\n  // Combines a contiguous array of `size` elements into a hash state, returning\n  // the updated state.\n  static HashState combine_contiguous(HashState hash_state,\n                                      const unsigned char* first, size_t size) {\n    hash_state.combine_contiguous_(hash_state.state_, first, size);\n    return hash_state;\n  }\n  using HashState::HashStateBase::combine_contiguous;\n\n private:\n  HashState() = default;\n\n  friend class HashState::HashStateBase;\n\n  template <typename T>\n  static void CombineContiguousImpl(void* p, const unsigned char* first,\n                                    size_t size) {\n    T& state = *static_cast<T*>(p);\n    state = T::combine_contiguous(std::move(state), first, size);\n  }\n\n  template <typename T>\n  void Init(T* state) {\n    state_ = state;\n    combine_contiguous_ = &CombineContiguousImpl<T>;\n    run_combine_unordered_ = &RunCombineUnorderedImpl<T>;\n  }\n\n  template <typename HS>\n  struct CombineUnorderedInvoker {\n    template <typename T, typename ConsumerT>\n    void operator()(T inner_state, ConsumerT inner_cb) {\n      f(HashState::Create(&inner_state),\n        [&](HashState& inner_erased) { inner_cb(inner_erased.Real<T>()); });\n    }\n\n    absl::FunctionRef<void(HS, absl::FunctionRef<void(HS&)>)> f;\n  };\n\n  template <typename T>\n  static HashState RunCombineUnorderedImpl(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>\n          f) {\n    // Note that this implementation assumes that inner_state and outer_state\n    // are the same type.  This isn't true in the SpyHash case, but SpyHash\n    // types are move-convertible to each other, so this still works.\n    T& real_state = state.Real<T>();\n    real_state = T::RunCombineUnordered(\n        std::move(real_state), CombineUnorderedInvoker<HashState>{f});\n    return state;\n  }\n\n  template <typename CombinerT>\n  static HashState RunCombineUnordered(HashState state, CombinerT combiner) {\n    auto* run = state.run_combine_unordered_;\n    return run(std::move(state), std::ref(combiner));\n  }\n\n  // Do not erase an already erased state.\n  void Init(HashState* state) {\n    state_ = state->state_;\n    combine_contiguous_ = state->combine_contiguous_;\n    run_combine_unordered_ = state->run_combine_unordered_;\n  }\n\n  template <typename T>\n  T& Real() {\n    return *static_cast<T*>(state_);\n  }\n\n  void* state_;\n  void (*combine_contiguous_)(void*, const unsigned char*, size_t);\n  HashState (*run_combine_unordered_)(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>);\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03648",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/hash.h",
  "source_line": 295,
  "validation_status": "validated"
}