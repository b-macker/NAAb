{
  "code": "{\n  ABSL_ASSUME(i < 10000'0000);\n  // Prepare 2 blocks of 4 digits \"in parallel\".\n  uint32_t hi = i / 10000;\n  uint32_t lo = i % 10000;\n  uint64_t merged = (uint64_t{hi} << (reversed ? 32 : 0)) |\n                    (uint64_t{lo} << (reversed ? 0 : 32));\n  uint64_t div100 = ((merged * kDivisionBy100Mul) / kDivisionBy100Div) &\n                    ((0x7Full << 32) | 0x7Full);\n  uint64_t mod100 = merged - 100ull * div100;\n  uint64_t hundreds =\n      (mod100 << (reversed ? 0 : 16)) + (div100 << (reversed ? 16 : 0));\n  uint64_t tens = (hundreds * kDivisionBy10Mul) / kDivisionBy10Div;\n  tens &= (0xFull << 48) | (0xFull << 32) | (0xFull << 16) | 0xFull;\n  tens = (tens << (reversed ? 8 : 0)) +\n         ((hundreds - 10ull * tens) << (reversed ? 0 : 8));\n  return tens;\n}\ninline uint64_t PrepareEightDigits(uint32_t i) {\n  return PrepareEightDigitsImpl(i, false);\n}\ninline uint64_t PrepareEightDigitsReversed(uint32_t i) {\n  return PrepareEightDigitsImpl(i, true);\n}\n\ntemplate <typename T, typename BackwardIt>\nclass FastUIntToStringConverter {\n  static_assert(\n      std::is_same<T, decltype(+std::declval<T>())>::value,\n      \"to avoid code bloat, only instantiate this for int and larger types\");\n  static_assert(std::is_unsigned<T>::value,\n                \"this class is only for unsigned types\");\n\n public:\n  // Outputs the given number backward (like with std::copy_backward),\n  // starting from the end of the string.\n  // The number of digits in the number must have been already measured and\n  // passed *exactly*, otherwise the behavior is undefined.\n  // (This is an optimization, as calculating the number of digits again would\n  // slow down the hot path.)\n  // Returns an iterator to the start of the suffix that was appended.\n  static BackwardIt FastIntToBufferBackward(T v, BackwardIt end) {\n    // THIS IS A HOT FUNCTION with a very deliberate structure to exploit branch\n    // prediction and shorten the critical path for smaller numbers.\n    // Do not move around the if/else blocks or attempt to simplify it\n    // without benchmarking any changes.\n\n    if (v < 10) {\n      goto AT_LEAST_1 /* NOTE: mandatory for the 0 case */;\n    }\n    if (v < 1000) {\n      goto AT_LEAST_10;\n    }\n    if (v < 10000000) {\n      goto AT_LEAST_1000;\n    }\n\n    if (v >= 100000000 / 10) {\n      if (v >= 10000000000000000 / 10) {\n        DoFastIntToBufferBackward<8>(v, end);\n      }\n      DoFastIntToBufferBackward<8>(v, end);\n    }\n\n    if (v >= 10000 / 10) {\n    AT_LEAST_1000:\n      DoFastIntToBufferBackward<4>(v, end);\n    }\n\n    if (v >= 100 / 10) {\n    AT_LEAST_10:\n      DoFastIntToBufferBackward<2>(v, end);\n    }\n\n    if (v >= 10 / 10) {\n    AT_LEAST_1:\n      end = DoFastIntToBufferBackward(v, end, std::integral_constant<int, 1>());\n    }\n    return end;\n  }\n\n private:\n  // Only assume pointers are contiguous for now. String and vector iterators\n  // could be special-cased as well, but there's no need for them here.\n  // With C++20 we can probably switch to std::contiguous_iterator_tag.\n  static constexpr bool kIsContiguousIterator =\n      std::is_pointer<BackwardIt>::value;\n\n  template <int Exponent>\n  static void DoFastIntToBufferBackward(T& v, BackwardIt& end) {\n    constexpr T kModulus = Pow<T>(10, Exponent);\n    T remainder = static_cast<T>(v % kModulus);\n    v = static_cast<T>(v / kModulus);\n    end = DoFastIntToBufferBackward(remainder, end,\n                                    std::integral_constant<int, Exponent>());\n  }\n\n  static BackwardIt DoFastIntToBufferBackward(const T&, BackwardIt end,\n                                              std::integral_constant<int, 0>) {\n    return end;\n  }\n\n  static BackwardIt DoFastIntToBufferBackward(T v, BackwardIt end,\n                                              std::integral_constant<int, 1>) {\n    *--end = static_cast<char>('0' + v);\n    return DoFastIntToBufferBackward(v, end, std::integral_constant<int, 0>());\n  }\n\n  static BackwardIt DoFastIntToBufferBackward(T v, BackwardIt end,\n                                              std::integral_constant<int, 4>) {\n    if (kIsContiguousIterator) {\n      const uint32_t digits =\n          PrepareFourDigits(static_cast<uint32_t>(v)) + kFourZeroBytes;\n      end -= sizeof(digits);\n      little_endian::Store32(&*end, digits);\n    } else {\n      uint32_t digits =\n          PrepareFourDigitsReversed(static_cast<uint32_t>(v)) + kFourZeroBytes;\n      for (size_t i = 0; i < sizeof(digits); ++i) {\n        *--end = static_cast<char>(digits);\n        digits >>= CHAR_BIT;\n      }\n    }\n    return end;\n  }\n\n  static BackwardIt DoFastIntToBufferBackward(T v, BackwardIt end,\n                                              std::integral_constant<int, 8>) {\n    if (kIsContiguousIterator) {\n      const uint64_t digits =\n          PrepareEightDigits(static_cast<uint32_t>(v)) + kEightZeroBytes;\n      end -= sizeof(digits);\n      little_endian::Store64(&*end, digits);\n    } else {\n      uint64_t digits = PrepareEightDigitsReversed(static_cast<uint32_t>(v)) +\n                        kEightZeroBytes;\n      for (size_t i = 0; i < sizeof(digits); ++i) {\n        *--end = static_cast<char>(digits);\n        digits >>= CHAR_BIT;\n      }\n    }\n    return end;\n  }\n\n  template <int Digits>\n  static BackwardIt DoFastIntToBufferBackward(\n      T v, BackwardIt end, std::integral_constant<int, Digits>) {\n    constexpr int kLogModulus = Digits - Digits / 2;\n    constexpr T kModulus = Pow(static_cast<T>(10), kLogModulus);\n    bool is_safe_to_use_division_trick = Digits <= 8;\n    T quotient, remainder;\n    if (is_safe_to_use_division_trick) {\n      constexpr uint64_t kCoefficient =\n          ComputePowerOf100DivisionCoefficient<uint64_t>(kLogModulus);\n      quotient = (v * kCoefficient) >> (10 * kLogModulus);\n      remainder = v - quotient * kModulus;\n    } else {\n      quotient = v / kModulus;\n      remainder = v % kModulus;\n    }\n    end = DoFastIntToBufferBackward(remainder, end,\n                                    std::integral_constant<int, kLogModulus>());\n    return DoFastIntToBufferBackward(\n        quotient, end, std::integral_constant<int, Digits - kLogModulus>());\n  }\n}",
  "id": "BLOCK-CPP-01959",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/numbers.cc",
  "source_line": 265,
  "validation_status": "validated"
}