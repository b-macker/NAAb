{
  "code": "{\n///   typedef typename MetaFun::template apply<T1, T2>::type type;\n/// };\n/// \\endcode\n///\n/// Here, \"apply\" is treated as a template name within the typename\n/// specifier in the typedef. \"apply\" is a nested template, and can\n/// only be understood in the context of\nclass TemplateName {\n  // NameDecl is either a TemplateDecl or a UsingShadowDecl depending on the\n  // NameKind.\n  // !! There is no free low bits in 32-bit builds to discriminate more than 4\n  // pointer types in PointerUnion.\n  using StorageType =\n      llvm::PointerUnion<Decl *, UncommonTemplateNameStorage *,\n                         QualifiedTemplateName *, DependentTemplateName *>;\n\n  StorageType Storage;\n\n  explicit TemplateName(void *Ptr);\n\npublic:\n  // Kind of name that is actually stored.\n  enum NameKind {\n    /// A single template declaration.\n    Template,\n\n    /// A set of overloaded template declarations.\n    OverloadedTemplate,\n\n    /// An unqualified-id that has been assumed to name a function template\n    /// that will be found by ADL.\n    AssumedTemplate,\n\n    /// A qualified template name, where the qualification is kept\n    /// to describe the source code as written.\n    QualifiedTemplate,\n\n    /// A dependent template name that has not been resolved to a\n    /// template (or set of templates).\n    DependentTemplate,\n\n    /// A template template parameter that has been substituted\n    /// for some other template name.\n    SubstTemplateTemplateParm,\n\n    /// A template template parameter pack that has been substituted for\n    /// a template template argument pack, but has not yet been expanded into\n    /// individual arguments.\n    SubstTemplateTemplateParmPack,\n\n    /// A template name that refers to a template declaration found through a\n    /// specific using shadow declaration.\n    UsingTemplate,\n  };\n\n  TemplateName() = default;\n  explicit TemplateName(TemplateDecl *Template);\n  explicit TemplateName(OverloadedTemplateStorage *Storage);\n  explicit TemplateName(AssumedTemplateStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmPackStorage *Storage);\n  explicit TemplateName(QualifiedTemplateName *Qual);\n  explicit TemplateName(DependentTemplateName *Dep);\n  explicit TemplateName(UsingShadowDecl *Using);\n\n  /// Determine whether this template name is NULL.\n  bool isNull() const;\n\n  // Get the kind of name that is actually stored.\n  NameKind getKind() const;\n\n  /// Retrieve the underlying template declaration that\n  /// this template name refers to, if known.\n  ///\n  /// \\returns The template declaration that this template name refers\n  /// to, if any. If the template name does not refer to a specific\n  /// declaration because it is a dependent name, or if it refers to a\n  /// set of function templates, returns NULL.\n  TemplateDecl *getAsTemplateDecl() const;\n\n  /// Retrieve the underlying, overloaded function template\n  /// declarations that this template name refers to, if known.\n  ///\n  /// \\returns The set of overloaded function templates that this template\n  /// name refers to, if known. If the template name does not refer to a\n  /// specific set of function templates because it is a dependent name or\n  /// refers to a single template, returns NULL.\n  OverloadedTemplateStorage *getAsOverloadedTemplate() const;\n\n  /// Retrieve information on a name that has been assumed to be a\n  /// template-name in order to permit a call via ADL.\n  AssumedTemplateStorage *getAsAssumedTemplateName() const;\n\n  /// Retrieve the substituted template template parameter, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmStorage *getAsSubstTemplateTemplateParm() const;\n\n  /// Retrieve the substituted template template parameter pack, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter pack,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmPackStorage *\n  getAsSubstTemplateTemplateParmPack() const;\n\n  /// Retrieve the underlying qualified template name\n  /// structure, if any.\n  QualifiedTemplateName *getAsQualifiedTemplateName() const;\n\n  /// Retrieve the underlying dependent template name\n  /// structure, if any.\n  DependentTemplateName *getAsDependentTemplateName() const;\n\n  /// Retrieve the using shadow declaration through which the underlying\n  /// template declaration is introduced, if any.\n  UsingShadowDecl *getAsUsingShadowDecl() const;\n\n  TemplateName getUnderlying() const;\n\n  /// Get the template name to substitute when this template name is used as a\n  /// template template argument. This refers to the most recent declaration of\n  /// the template, including any default template arguments.\n  TemplateName getNameToSubstitute() const;\n\n  TemplateNameDependence getDependence() const;\n\n  /// Determines whether this is a dependent template name.\n  bool isDependent() const;\n\n  /// Determines whether this is a template name that somehow\n  /// depends on a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determines whether this template name contains an\n  /// unexpanded parameter pack (for C++0x variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  enum class Qualified { None, AsWritten, Fully };\n  /// Print the template name.\n  ///\n  /// \\param OS the output stream to which the template name will be\n  /// printed.\n  ///\n  /// \\param Qual print the (Qualified::None) simple name,\n  /// (Qualified::AsWritten) any written (possibly partial) qualifier, or\n  /// (Qualified::Fully) the fully qualified name.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             Qualified Qual = Qualified::AsWritten) const;\n\n  /// Debugging aid that dumps the template name.\n  void dump(raw_ostream &OS) const;\n\n  /// Debugging aid that dumps the template name to standard\n  /// error.\n  void dump() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n\n  /// Retrieve the template name as a void pointer.\n  void *getAsVoidPointer() const { return Storage.getOpaqueValue(); }\n\n  /// Build a template name from a void pointer.\n  static TemplateName getFromVoidPointer(void *Ptr) {\n    return TemplateName(Ptr);\n  }\n};\n\n/// Insertion operator for diagnostics.  This allows sending TemplateName's\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      TemplateName N);\n\n/// A structure for storing the information associated with a\n/// substituted template template parameter.\nclass SubstTemplateTemplateParmStorage\n  : public UncommonTemplateNameStorage, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  TemplateName Replacement;\n  Decl *AssociatedDecl;\n\n  SubstTemplateTemplateParmStorage(TemplateName Replacement,\n                                   Decl *AssociatedDecl, unsigned Index,\n                                   std::optional<unsigned> PackIndex)\n      : UncommonTemplateNameStorage(SubstTemplateTemplateParm, Index,\n                                    PackIndex ? *PackIndex + 1 : 0),\n        Replacement(Replacement), AssociatedDecl(AssociatedDecl) {\n    assert(AssociatedDecl != nullptr);\n  }\n\npublic:\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDecl; }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameter()->getIndex()`.\n  unsigned getIndex() const { return Bits.Index; }\n\n  std::optional<unsigned> getPackIndex() const {\n    if (Bits.Data == 0)\n      return std::nullopt;\n    return Bits.Data - 1;\n  }\n\n  TemplateTemplateParmDecl *getParameter() const;\n  TemplateName getReplacement() const { return Replacement; }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName Replacement,\n                      Decl *AssociatedDecl, unsigned Index,\n                      std::optional<unsigned> PackIndex);\n};\n\ninline TemplateName TemplateName::getUnderlying() const {\n  if (SubstTemplateTemplateParmStorage *subst\n        = getAsSubstTemplateTemplateParm())\n    return subst->getReplacement().getUnderlying();\n  return *this;\n}\n\n/// Represents a template name that was expressed as a\n/// qualified name.\n///\n/// This kind of template name refers to a template name that was\n/// preceded by a nested name specifier, e.g., \\c std::vector. Here,\n/// the nested name specifier is \"std::\" and the template name is the\n/// declaration for \"vector\". The QualifiedTemplateName class is only\n/// used to provide \"sugar\" for template names that were expressed\n/// with a qualified name, and has no semantic meaning. In this\n/// manner, it is to TemplateName what ElaboratedType is to Type,\n/// providing extra syntactic sugar for downstream clients.\nclass QualifiedTemplateName : public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The nested name specifier that qualifies the template name.\n  ///\n  /// The bit is used to indicate whether the \"template\" keyword was\n  /// present before the template name itself. Note that the\n  /// \"template\" keyword is always redundant in this case (otherwise,\n  /// the template name would be a dependent name and we would express\n  /// this name with DependentTemplateName).\n  llvm::PointerIntPair<NestedNameSpecifier *, 1> Qualifier;\n\n  /// The underlying template name, it is either\n  ///  1) a Template -- a template declaration that this qualified name refers\n  ///     to.\n  ///  2) or a UsingTemplate -- a template declaration introduced by a\n  ///     using-shadow declaration.\n  TemplateName UnderlyingTemplate;\n\n  QualifiedTemplateName(NestedNameSpecifier *NNS, bool TemplateKeyword,\n                        TemplateName Template)\n      : Qualifier(NNS, TemplateKeyword ? 1 : 0), UnderlyingTemplate(Template) {\n    assert(UnderlyingTemplate.getKind() == TemplateName::Template ||\n           UnderlyingTemplate.getKind() == TemplateName::UsingTemplate);\n  }\n\npublic:\n  /// Return the nested name specifier that qualifies this name.\n  NestedNameSpecifier *getQualifier() const { return Qualifier.getPointer(); }\n\n  /// Whether the template name was prefixed by the \"template\"\n  /// keyword.\n  bool hasTemplateKeyword() const { return Qualifier.getInt(); }\n\n  /// Return the underlying template name.\n  TemplateName getUnderlyingTemplate() const { return UnderlyingTemplate; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getQualifier(), hasTemplateKeyword(), UnderlyingTemplate);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      bool TemplateKeyword, TemplateName TN) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(TemplateKeyword);\n    ID.AddPointer(TN.getAsVoidPointer());\n  }\n};\n\n/// Represents a dependent template name that cannot be\n/// resolved prior to template instantiation.\n///\n/// This kind of template name refers to a dependent template name,\n/// including its nested name specifier (if any). For example,\n/// DependentTemplateName can refer to \"MetaFun::template apply\",\n/// where \"MetaFun::\" is the nested name specifier and \"apply\" is the\n/// template name referenced. The \"template\" keyword is implied.\nclass DependentTemplateName : public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The nested name specifier that qualifies the template\n  /// name.\n  ///\n  /// The bit stored in this qualifier describes whether the \\c Name field\n  /// is interpreted as an IdentifierInfo pointer (when clear) or as an\n  /// overloaded operator kind (when set).\n  llvm::PointerIntPair<NestedNameSpecifier *, 1, bool> Qualifier;\n\n  /// The dependent template name.\n  union {\n    /// The identifier template name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is clear.\n    const IdentifierInfo *Identifier;\n\n    /// The overloaded operator name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is set.\n    OverloadedOperatorKind Operator;\n  };\n\n  /// The canonical template name to which this dependent\n  /// template name refers.\n  ///\n  /// The canonical template name for a dependent template name is\n  /// another dependent template name whose nested name specifier is\n  /// canonical.\n  TemplateName CanonicalTemplateName;\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier,\n                        TemplateName Canon)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(Canon) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator)\n      : Qualifier(Qualifier, true), Operator(Operator),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator,\n                        TemplateName Canon)\n       : Qualifier(Qualifier, true), Operator(Operator),\n         CanonicalTemplateName(Canon) {}\n\npublic:\n  /// Return the nested name specifier that qualifies this name.\n  NestedNameSpecifier *getQualifier() const { return Qualifier.getPointer(); }\n\n  /// Determine whether this template name refers to an identifier.\n  bool isIdentifier() const { return !Qualifier.getInt(); }\n\n  /// Returns the identifier to which this template name refers.\n  const IdentifierInfo *getIdentifier() const {\n    assert(isIdentifier() && \"Template name isn't an identifier?\");\n    return Identifier;\n  }\n\n  /// Determine whether this template name refers to an overloaded\n  /// operator.\n  bool isOverloadedOperator() const { return Qualifier.getInt(); }\n\n  /// Return the overloaded operator to which this template name refers.\n  OverloadedOperatorKind getOperator() const {\n    assert(isOverloadedOperator() &&\n           \"Template name isn't an overloaded operator?\");\n    return Operator;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    if (isIdentifier())\n      Profile(ID, getQualifier(), getIdentifier());\n    else\n      Profile(ID, getQualifier(), getOperator());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      const IdentifierInfo *Identifier) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(false);\n    ID.AddPointer(Identifier);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      OverloadedOperatorKind Operator) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(true);\n    ID.AddInteger(Operator);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-13494",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TemplateName.h",
  "source_line": 194,
  "validation_status": "validated"
}