{
  "code": "{\nnamespace threadSafety {\n\nstd::string getSourceLiteralString(const Expr *CE);\n\nnamespace til {\n\n// A simple fixed size array class that does not manage its own memory,\n// suitable for use with bump pointer allocation.\ntemplate <class T> class SimpleArray {\npublic:\n  SimpleArray() = default;\n  SimpleArray(T *Dat, size_t Cp, size_t Sz = 0)\n      : Data(Dat), Size(Sz), Capacity(Cp) {}\n  SimpleArray(MemRegionRef A, size_t Cp)\n      : Data(Cp == 0 ? nullptr : A.allocateT<T>(Cp)), Capacity(Cp) {}\n  SimpleArray(const SimpleArray<T> &A) = delete;\n\n  SimpleArray(SimpleArray<T> &&A)\n      : Data(A.Data), Size(A.Size), Capacity(A.Capacity) {\n    A.Data = nullptr;\n    A.Size = 0;\n    A.Capacity = 0;\n  }\n\n  SimpleArray &operator=(SimpleArray &&RHS) {\n    if (this != &RHS) {\n      Data = RHS.Data;\n      Size = RHS.Size;\n      Capacity = RHS.Capacity;\n\n      RHS.Data = nullptr;\n      RHS.Size = RHS.Capacity = 0;\n    }\n    return *this;\n  }\n\n  // Reserve space for at least Ncp items, reallocating if necessary.\n  void reserve(size_t Ncp, MemRegionRef A) {\n    if (Ncp <= Capacity)\n      return;\n    T *Odata = Data;\n    Data = A.allocateT<T>(Ncp);\n    Capacity = Ncp;\n    memcpy(Data, Odata, sizeof(T) * Size);\n  }\n\n  // Reserve space for at least N more items.\n  void reserveCheck(size_t N, MemRegionRef A) {\n    if (Capacity == 0)\n      reserve(u_max(InitialCapacity, N), A);\n    else if (Size + N < Capacity)\n      reserve(u_max(Size + N, Capacity * 2), A);\n  }\n\n  using iterator = T *;\n  using const_iterator = const T *;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  size_t size() const { return Size; }\n  size_t capacity() const { return Capacity; }\n\n  T &operator[](unsigned i) {\n    assert(i < Size && \"Array index out of bounds.\");\n    return Data[i];\n  }\n\n  const T &operator[](unsigned i) const {\n    assert(i < Size && \"Array index out of bounds.\");\n    return Data[i];\n  }\n\n  T &back() {\n    assert(Size && \"No elements in the array.\");\n    return Data[Size - 1];\n  }\n\n  const T &back() const {\n    assert(Size && \"No elements in the array.\");\n    return Data[Size - 1];\n  }\n\n  iterator begin() { return Data; }\n  iterator end() { return Data + Size; }\n\n  const_iterator begin() const { return Data; }\n  const_iterator end() const { return Data + Size; }\n\n  const_iterator cbegin() const { return Data; }\n  const_iterator cend() const { return Data + Size; }\n\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  void push_back(const T &Elem) {\n    assert(Size < Capacity);\n    Data[Size++] = Elem;\n  }\n\n  // drop last n elements from array\n  void drop(unsigned n = 0) {\n    assert(Size > n);\n    Size -= n;\n  }\n\n  void setValues(unsigned Sz, const T& C) {\n    assert(Sz <= Capacity);\n    Size = Sz;\n    for (unsigned i = 0; i < Sz; ++i) {\n      Data[i] = C;\n    }\n  }\n\n  template <class Iter> unsigned append(Iter I, Iter E) {\n    size_t Osz = Size;\n    size_t J = Osz;\n    for (; J < Capacity && I != E; ++J, ++I)\n      Data[J] = *I;\n    Size = J;\n    return J - Osz;\n  }\n\n  llvm::iterator_range<reverse_iterator> reverse() {\n    return llvm::reverse(*this);\n  }\n\n  llvm::iterator_range<const_reverse_iterator> reverse() const {\n    return llvm::reverse(*this);\n  }\n\nprivate:\n  // std::max is annoying here, because it requires a reference,\n  // thus forcing InitialCapacity to be initialized outside the .h file.\n  size_t u_max(size_t i, size_t j) { return (i < j) ? j : i; }\n\n  static const size_t InitialCapacity = 4;\n\n  T *Data = nullptr;\n  size_t Size = 0;\n  size_t Capacity = 0;\n};\n\n}  // namespace til\n\n// A copy on write vector.\n// The vector can be in one of three states:\n// * invalid -- no operations are permitted.\n// * read-only -- read operations are permitted.\n// * writable -- read and write operations are permitted.\n// The init(), destroy(), and makeWritable() methods will change state.\ntemplate<typename T>\nclass CopyOnWriteVector {\n  class VectorData {\n  public:\n    unsigned NumRefs = 1;\n    std::vector<T> Vect;\n\n    VectorData() = default;\n    VectorData(const VectorData &VD) : Vect(VD.Vect) {}\n\n    // The copy assignment operator is defined as deleted pending further\n    // motivation.\n    VectorData &operator=(const VectorData &) = delete;\n  };\n\npublic:\n  CopyOnWriteVector() = default;\n  CopyOnWriteVector(CopyOnWriteVector &&V) : Data(V.Data) { V.Data = nullptr; }\n\n  CopyOnWriteVector &operator=(CopyOnWriteVector &&V) {\n    destroy();\n    Data = V.Data;\n    V.Data = nullptr;\n    return *this;\n  }\n\n  // No copy constructor or copy assignment.  Use clone() with move assignment.\n  CopyOnWriteVector(const CopyOnWriteVector &) = delete;\n  CopyOnWriteVector &operator=(const CopyOnWriteVector &) = delete;\n\n  ~CopyOnWriteVector() { destroy(); }\n\n  // Returns true if this holds a valid vector.\n  bool valid() const  { return Data; }\n\n  // Returns true if this vector is writable.\n  bool writable() const { return Data && Data->NumRefs == 1; }\n\n  // If this vector is not valid, initialize it to a valid vector.\n  void init() {\n    if (!Data) {\n      Data = new VectorData();\n    }\n  }\n\n  // Destroy this vector; thus making it invalid.\n  void destroy() {\n    if (!Data)\n      return;\n    if (Data->NumRefs <= 1)\n      delete Data;\n    else\n      --Data->NumRefs;\n    Data = nullptr;\n  }\n\n  // Make this vector writable, creating a copy if needed.\n  void makeWritable() {\n    if (!Data) {\n      Data = new VectorData();\n      return;\n    }\n    if (Data->NumRefs == 1)\n      return;   // already writeable.\n    --Data->NumRefs;\n    Data = new VectorData(*Data);\n  }\n\n  // Create a lazy copy of this vector.\n  CopyOnWriteVector clone() { return CopyOnWriteVector(Data); }\n\n  using const_iterator = typename std::vector<T>::const_iterator;\n\n  const std::vector<T> &elements() const { return Data->Vect; }\n\n  const_iterator begin() const { return elements().cbegin(); }\n  const_iterator end() const { return elements().cend(); }\n\n  const T& operator[](unsigned i) const { return elements()[i]; }\n\n  unsigned size() const { return Data ? elements().size() : 0; }\n\n  // Return true if V and this vector refer to the same data.\n  bool sameAs(const CopyOnWriteVector &V) const { return Data == V.Data; }\n\n  // Clear vector.  The vector must be writable.\n  void clear() {\n    assert(writable() && \"Vector is not writable!\");\n    Data->Vect.clear();\n  }\n\n  // Push a new element onto the end.  The vector must be writable.\n  void push_back(const T &Elem) {\n    assert(writable() && \"Vector is not writable!\");\n    Data->Vect.push_back(Elem);\n  }\n\n  // Gets a mutable reference to the element at index(i).\n  // The vector must be writable.\n  T& elem(unsigned i) {\n    assert(writable() && \"Vector is not writable!\");\n    return Data->Vect[i];\n  }\n\n  // Drops elements from the back until the vector has size i.\n  void downsize(unsigned i) {\n    assert(writable() && \"Vector is not writable!\");\n    Data->Vect.erase(Data->Vect.begin() + i, Data->Vect.end());\n  }\n\nprivate:\n  CopyOnWriteVector(VectorData *D) : Data(D) {\n    if (!Data)\n      return;\n    ++Data->NumRefs;\n  }\n\n  VectorData *Data = nullptr;\n};\n\ninline std::ostream& operator<<(std::ostream& ss, const StringRef str) {\n  return ss.write(str.data(), str.size());\n}\n\n} // namespace threadSafety\n}",
  "id": "BLOCK-CPP-21848",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h",
  "source_line": 75,
  "validation_status": "validated"
}