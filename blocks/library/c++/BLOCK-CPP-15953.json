{
  "code": "{\n\n/// ArgEffects summarizes the effects of a function/method call on all of\n/// its arguments.\ntypedef llvm::ImmutableMap<unsigned, ArgEffect> ArgEffects;\n\n/// Summary for a function with respect to ownership changes.\nclass RetainSummary {\n  /// Args - a map of (index, ArgEffect) pairs, where index\n  ///  specifies the argument (starting from 0).  This can be sparsely\n  ///  populated; arguments with no entry in Args use 'DefaultArgEffect'.\n  ArgEffects Args;\n\n  /// DefaultArgEffect - The default ArgEffect to apply to arguments that\n  ///  do not have an entry in Args.\n  ArgEffect DefaultArgEffect;\n\n  /// Receiver - If this summary applies to an Objective-C message expression,\n  ///  this is the effect applied to the state of the receiver.\n  ArgEffect Receiver;\n\n  /// Effect on \"this\" pointer - applicable only to C++ method calls.\n  ArgEffect This;\n\n  /// Ret - The effect on the return value.  Used to indicate if the\n  ///  function/method call returns a new tracked symbol.\n  RetEffect Ret;\n\npublic:\n  RetainSummary(ArgEffects A,\n                RetEffect R,\n                ArgEffect defaultEff,\n                ArgEffect ReceiverEff,\n                ArgEffect ThisEff)\n    : Args(A), DefaultArgEffect(defaultEff), Receiver(ReceiverEff),\n      This(ThisEff), Ret(R) {}\n\n  /// getArg - Return the argument effect on the argument specified by\n  ///  idx (starting from 0).\n  ArgEffect getArg(unsigned idx) const {\n    if (const ArgEffect *AE = Args.lookup(idx))\n      return *AE;\n\n    return DefaultArgEffect;\n  }\n\n  void addArg(ArgEffects::Factory &af, unsigned idx, ArgEffect e) {\n    Args = af.add(Args, idx, e);\n  }\n\n  /// setDefaultArgEffect - Set the default argument effect.\n  void setDefaultArgEffect(ArgEffect E) {\n    DefaultArgEffect = E;\n  }\n\n  /// getRetEffect - Returns the effect on the return value of the call.\n  RetEffect getRetEffect() const { return Ret; }\n\n  /// setRetEffect - Set the effect of the return value of the call.\n  void setRetEffect(RetEffect E) { Ret = E; }\n\n\n  /// Sets the effect on the receiver of the message.\n  void setReceiverEffect(ArgEffect e) { Receiver = e; }\n\n  /// getReceiverEffect - Returns the effect on the receiver of the call.\n  ///  This is only meaningful if the summary applies to an ObjCMessageExpr*.\n  ArgEffect getReceiverEffect() const { return Receiver; }\n\n  /// \\return the effect on the \"this\" receiver of the method call.\n  /// This is only meaningful if the summary applies to CXXMethodDecl*.\n  ArgEffect getThisEffect() const { return This; }\n\n  ArgEffect getDefaultEffect() const { return DefaultArgEffect; }\n\n  /// Set the effect of the method on \"this\".\n  void setThisEffect(ArgEffect e) { This = e; }\n\n  bool isNoop() const {\n    return Ret == RetEffect::MakeNoRet() && Receiver.getKind() == DoNothing\n      && DefaultArgEffect.getKind() == MayEscape && This.getKind() == DoNothing\n      && Args.isEmpty();\n  }\n\n  /// Test if two retain summaries are identical. Note that merely equivalent\n  /// summaries are not necessarily identical (for example, if an explicit\n  /// argument effect matches the default effect).\n  bool operator==(const RetainSummary &Other) const {\n    return Args == Other.Args && DefaultArgEffect == Other.DefaultArgEffect &&\n           Receiver == Other.Receiver && This == Other.This && Ret == Other.Ret;\n  }\n\n  /// Profile this summary for inclusion in a FoldingSet.\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.Add(Args);\n    ID.Add(DefaultArgEffect);\n    ID.Add(Receiver);\n    ID.Add(This);\n    ID.Add(Ret);\n  }\n\n  /// A retain summary is simple if it has no ArgEffects other than the default.\n  bool isSimple() const {\n    return Args.isEmpty();\n  }\n\n  ArgEffects getArgEffects() const { return Args; }\n\nprivate:\n  ArgEffect getDefaultArgEffect() const { return DefaultArgEffect; }\n\n  friend class RetainSummaryManager;\n};\n\nclass ObjCSummaryCache {\n  typedef llvm::DenseMap<ObjCSummaryKey, const RetainSummary *> MapTy;\n  MapTy M;\npublic:\n  ObjCSummaryCache() {}\n\n  const RetainSummary * find(const ObjCInterfaceDecl *D, Selector S) {\n    // Do a lookup with the (D,S) pair.  If we find a match return\n    // the iterator.\n    ObjCSummaryKey K(D, S);\n    MapTy::iterator I = M.find(K);\n\n    if (I != M.end())\n      return I->second;\n    if (!D)\n      return nullptr;\n\n    // Walk the super chain.  If we find a hit with a parent, we'll end\n    // up returning that summary.  We actually allow that key (null,S), as\n    // we cache summaries for the null ObjCInterfaceDecl* to allow us to\n    // generate initial summaries without having to worry about NSObject\n    // being declared.\n    // FIXME: We may change this at some point.\n    for (ObjCInterfaceDecl *C=D->getSuperClass() ;; C=C->getSuperClass()) {\n      if ((I = M.find(ObjCSummaryKey(C, S))) != M.end())\n        break;\n\n      if (!C)\n        return nullptr;\n    }\n\n    // Cache the summary with original key to make the next lookup faster\n    // and return the iterator.\n    const RetainSummary *Summ = I->second;\n    M[K] = Summ;\n    return Summ;\n  }\n\n  const RetainSummary *find(IdentifierInfo* II, Selector S) {\n    // FIXME: Class method lookup.  Right now we don't have a good way\n    // of going between IdentifierInfo* and the class hierarchy.\n    MapTy::iterator I = M.find(ObjCSummaryKey(II, S));\n\n    if (I == M.end())\n      I = M.find(ObjCSummaryKey(S));\n\n    return I == M.end() ? nullptr : I->second;\n  }\n\n  const RetainSummary *& operator[](ObjCSummaryKey K) {\n    return M[K];\n  }\n\n  const RetainSummary *& operator[](Selector S) {\n    return M[ ObjCSummaryKey(S) ];\n  }\n};\n\nclass RetainSummaryTemplate;\n\nclass RetainSummaryManager {\n  typedef llvm::DenseMap<const FunctionDecl*, const RetainSummary *>\n          FuncSummariesTy;\n\n  typedef ObjCSummaryCache ObjCMethodSummariesTy;\n\n  typedef llvm::FoldingSetNodeWrapper<RetainSummary> CachedSummaryNode;\n\n  /// Ctx - The ASTContext object for the analyzed ASTs.\n  ASTContext &Ctx;\n\n  /// Records whether or not the analyzed code runs in ARC mode.\n  const bool ARCEnabled;\n\n  /// Track Objective-C and CoreFoundation objects.\n  const bool TrackObjCAndCFObjects;\n\n  /// Track sublcasses of OSObject.\n  const bool TrackOSObjects;\n\n  /// FuncSummaries - A map from FunctionDecls to summaries.\n  FuncSummariesTy FuncSummaries;\n\n  /// ObjCClassMethodSummaries - A map from selectors (for instance methods)\n  ///  to summaries.\n  ObjCMethodSummariesTy ObjCClassMethodSummaries;\n\n  /// ObjCMethodSummaries - A map from selectors to summaries.\n  ObjCMethodSummariesTy ObjCMethodSummaries;\n\n  /// BPAlloc - A BumpPtrAllocator used for allocating summaries, ArgEffects,\n  ///  and all other data used by the checker.\n  llvm::BumpPtrAllocator BPAlloc;\n\n  /// AF - A factory for ArgEffects objects.\n  ArgEffects::Factory AF;\n\n  /// ObjCAllocRetE - Default return effect for methods returning Objective-C\n  ///  objects.\n  RetEffect ObjCAllocRetE;\n\n  /// ObjCInitRetE - Default return effect for init methods returning\n  ///   Objective-C objects.\n  RetEffect ObjCInitRetE;\n\n  /// SimpleSummaries - Used for uniquing summaries that don't have special\n  /// effects.\n  llvm::FoldingSet<CachedSummaryNode> SimpleSummaries;\n\n  /// Create an OS object at +1.\n  const RetainSummary *getOSSummaryCreateRule(const FunctionDecl *FD);\n\n  /// Get an OS object at +0.\n  const RetainSummary *getOSSummaryGetRule(const FunctionDecl *FD);\n\n  /// Increment the reference count on OS object.\n  const RetainSummary *getOSSummaryRetainRule(const FunctionDecl *FD);\n\n  /// Decrement the reference count on OS object.\n  const RetainSummary *getOSSummaryReleaseRule(const FunctionDecl *FD);\n\n  /// Free the OS object.\n  const RetainSummary *getOSSummaryFreeRule(const FunctionDecl *FD);\n\n  const RetainSummary *getUnarySummary(const FunctionType* FT,\n                                       ArgEffectKind AE);\n\n  const RetainSummary *getCFSummaryCreateRule(const FunctionDecl *FD);\n  const RetainSummary *getCFSummaryGetRule(const FunctionDecl *FD);\n  const RetainSummary *getCFCreateGetRuleSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getPersistentSummary(const RetainSummary &OldSumm);\n\n  const RetainSummary *\n  getPersistentSummary(RetEffect RetEff, ArgEffects ScratchArgs,\n                       ArgEffect ReceiverEff = ArgEffect(DoNothing),\n                       ArgEffect DefaultEff = ArgEffect(MayEscape),\n                       ArgEffect ThisEff = ArgEffect(DoNothing)) {\n    RetainSummary Summ(ScratchArgs, RetEff, DefaultEff, ReceiverEff, ThisEff);\n    return getPersistentSummary(Summ);\n  }\n\n  const RetainSummary *getDoNothingSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(DoNothing));\n  }\n\n  const RetainSummary *getDefaultSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(MayEscape));\n  }\n\n  const RetainSummary *getPersistentStopSummary() {\n    return getPersistentSummary(\n        RetEffect::MakeNoRet(), ArgEffects(AF.getEmptyMap()),\n        ArgEffect(StopTracking), ArgEffect(StopTracking));\n  }\n\n  void InitializeClassMethodSummaries();\n  void InitializeMethodSummaries();\n\n  void addNSObjectClsMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCClassMethodSummaries[S] = Summ;\n  }\n\n  void addNSObjectMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCMethodSummaries[S] = Summ;\n  }\n\n  void addClassMethSummary(const char* Cls, const char* name,\n                           const RetainSummary *Summ, bool isNullary = true) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = isNullary ? GetNullarySelector(name, Ctx)\n                           : GetUnarySelector(name, Ctx);\n    ObjCClassMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  void addInstMethSummary(const char* Cls, const char* nullaryName,\n                          const RetainSummary *Summ) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = GetNullarySelector(nullaryName, Ctx);\n    ObjCMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  template <typename... Keywords>\n  void addMethodSummary(IdentifierInfo *ClsII, ObjCMethodSummariesTy &Summaries,\n                        const RetainSummary *Summ, Keywords *... Kws) {\n    Selector S = getKeywordSelector(Ctx, Kws...);\n    Summaries[ObjCSummaryKey(ClsII, S)] = Summ;\n  }\n\n  template <typename... Keywords>\n  void addInstMethSummary(const char *Cls, const RetainSummary *Summ,\n                          Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCMethodSummaries, Summ, Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(const char *Cls, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCClassMethodSummaries, Summ,\n                     Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(IdentifierInfo *II, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(II, ObjCClassMethodSummaries, Summ, Kws...);\n  }\n\n  const RetainSummary * generateSummary(const FunctionDecl *FD,\n                                        bool &AllowAnnotations);\n\n  /// Return a summary for OSObject, or nullptr if not found.\n  const RetainSummary *getSummaryForOSObject(const FunctionDecl *FD,\n                                             StringRef FName, QualType RetTy);\n\n  /// Return a summary for Objective-C or CF object, or nullptr if not found.\n  const RetainSummary *getSummaryForObjCOrCFObject(\n    const FunctionDecl *FD,\n    StringRef FName,\n    QualType RetTy,\n    const FunctionType *FT,\n    bool &AllowAnnotations);\n\n  /// Apply the annotation of @c pd in function @c FD\n  /// to the resulting summary stored in out-parameter @c Template.\n  /// \\return whether an annotation was applied.\n  bool applyParamAnnotationEffect(const ParmVarDecl *pd, unsigned parm_idx,\n                                  const NamedDecl *FD,\n                                  RetainSummaryTemplate &Template);\n\npublic:\n  RetainSummaryManager(ASTContext &ctx, bool trackObjCAndCFObjects,\n                       bool trackOSObjects)\n      : Ctx(ctx), ARCEnabled((bool)Ctx.getLangOpts().ObjCAutoRefCount),\n        TrackObjCAndCFObjects(trackObjCAndCFObjects),\n        TrackOSObjects(trackOSObjects), AF(BPAlloc),\n        ObjCAllocRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                 : RetEffect::MakeOwned(ObjKind::ObjC)),\n        ObjCInitRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                : RetEffect::MakeOwnedWhenTrackedReceiver()) {\n    InitializeClassMethodSummaries();\n    InitializeMethodSummaries();\n  }\n\n  enum class BehaviorSummary {\n    // Function does not return.\n    NoOp,\n\n    // Function returns the first argument.\n    Identity,\n\n    // Function returns \"this\" argument.\n    IdentityThis,\n\n    // Function either returns zero, or the input parameter.\n    IdentityOrZero\n  };\n\n  std::optional<BehaviorSummary>\n  canEval(const CallExpr *CE, const FunctionDecl *FD,\n          bool &hasTrustedImplementationAnnotation);\n\n  /// \\return Whether the type corresponds to a known smart pointer\n  /// implementation (that is, everything about it is inlineable).\n  static bool isKnownSmartPointer(QualType QT);\n\n  bool isTrustedReferenceCountImplementation(const Decl *FD);\n\n  const RetainSummary *getSummary(AnyCall C,\n                                  bool HasNonZeroCallbackArg=false,\n                                  bool IsReceiverUnconsumedSelf=false,\n                                  QualType ReceiverType={});\n\n  RetEffect getObjAllocRetEffect() const { return ObjCAllocRetE; }\n\nprivate:\n\n  /// getMethodSummary - This version of getMethodSummary is used to query\n  ///  the summary for the current method being analyzed.\n  const RetainSummary *getMethodSummary(const ObjCMethodDecl *MD);\n\n  const RetainSummary *getFunctionSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getMethodSummary(Selector S, const ObjCInterfaceDecl *ID,\n                                        const ObjCMethodDecl *MD,\n                                        QualType RetTy,\n                                        ObjCMethodSummariesTy &CachedSummaries);\n\n  const RetainSummary *\n  getInstanceMethodSummary(const ObjCMessageExpr *ME, QualType ReceiverType);\n\n  const RetainSummary *getClassMethodSummary(const ObjCMessageExpr *ME);\n\n  const RetainSummary *getStandardMethodSummary(const ObjCMethodDecl *MD,\n                                                Selector S, QualType RetTy);\n\n  /// Determine if there is a special return effect for this function or method.\n  std::optional<RetEffect> getRetEffectFromAnnotations(QualType RetTy,\n                                                       const Decl *D);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const ObjCMethodDecl *MD);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const FunctionDecl *FD);\n\n  const RetainSummary *updateSummaryForNonZeroCallbackArg(const RetainSummary *S,\n                                                          AnyCall &C);\n\n  /// Special case '[super init];' and '[self init];'\n  ///\n  /// Even though calling '[super init]' without assigning the result to self\n  /// and checking if the parent returns 'nil' is a bad pattern, it is common.\n  /// Additionally, our Self Init checker already warns about it. To avoid\n  /// overwhelming the user with messages from both checkers, we model the case\n  /// of '[super init]' in cases when it is not consumed by another expression\n  /// as if the call preserves the value of 'self'; essentially, assuming it can\n  /// never fail and return 'nil'.\n  /// Note, we don't want to just stop tracking the value since we want the\n  /// RetainCount checker to report leaks and use-after-free if SelfInit checker\n  /// is turned off.\n  void updateSummaryForReceiverUnconsumedSelf(const RetainSummary *&S);\n\n  /// Set argument types for arguments which are not doing anything.\n  void updateSummaryForArgumentTypes(const AnyCall &C, const RetainSummary *&RS);\n\n  /// Determine whether a declaration @c D of correspondent type (return\n  /// type for functions/methods) @c QT has any of the given attributes,\n  /// provided they pass necessary validation checks AND tracking the given\n  /// attribute is enabled.\n  /// Returns the object kind corresponding to the present attribute, or\n  /// std::nullopt, if none of the specified attributes are present.\n  /// Crashes if passed an attribute which is not explicitly handled.\n  template <class T>\n  std::optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  template <class T1, class T2, class... Others>\n  std::optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  friend class RetainSummaryTemplate;\n};\n\n\n// Used to avoid allocating long-term (BPAlloc'd) memory for default retain\n// summaries. If a function or method looks like it has a default summary, but\n// it has annotations, the annotations are added to the stack-based template\n// and then copied into managed memory.\nclass RetainSummaryTemplate {\n  RetainSummaryManager &Manager;\n  const RetainSummary *&RealSummary;\n  RetainSummary ScratchSummary;\n  bool Accessed;\npublic:\n  RetainSummaryTemplate(const RetainSummary *&real, RetainSummaryManager &mgr)\n    : Manager(mgr), RealSummary(real), ScratchSummary(*real), Accessed(false) {}\n\n  ~RetainSummaryTemplate() {\n    if (Accessed)\n      RealSummary = Manager.getPersistentSummary(ScratchSummary);\n  }\n\n  RetainSummary &operator*() {\n    Accessed = true;\n    return ScratchSummary;\n  }\n\n  RetainSummary *operator->() {\n    Accessed = true;\n    return &ScratchSummary;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-15953",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/RetainSummaryManager.h",
  "source_line": 276,
  "validation_status": "validated"
}