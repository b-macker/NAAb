{
  "code": "{\npublic:\n  struct StandaloneFixIt {\n    std::pair<unsigned, unsigned> RemoveRange;\n    std::pair<unsigned, unsigned> InsertFromRange;\n    std::string CodeToInsert;\n    bool BeforePreviousInsertions;\n  };\n\n  struct StandaloneDiagnostic {\n    unsigned ID;\n    DiagnosticsEngine::Level Level;\n    std::string Message;\n    std::string Filename;\n    unsigned LocOffset;\n    std::vector<std::pair<unsigned, unsigned>> Ranges;\n    std::vector<StandaloneFixIt> FixIts;\n  };\n\nprivate:\n  std::shared_ptr<LangOptions>            LangOpts;\n  IntrusiveRefCntPtr<DiagnosticsEngine>   Diagnostics;\n  IntrusiveRefCntPtr<FileManager>         FileMgr;\n  IntrusiveRefCntPtr<SourceManager>       SourceMgr;\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n  std::unique_ptr<HeaderSearch>           HeaderInfo;\n  IntrusiveRefCntPtr<TargetInfo>          Target;\n  std::shared_ptr<Preprocessor>           PP;\n  IntrusiveRefCntPtr<ASTContext>          Ctx;\n  std::shared_ptr<TargetOptions>          TargetOpts;\n  std::shared_ptr<HeaderSearchOptions>    HSOpts;\n  std::shared_ptr<PreprocessorOptions>    PPOpts;\n  IntrusiveRefCntPtr<ASTReader> Reader;\n  bool HadModuleLoaderFatalFailure = false;\n  bool StorePreamblesInMemory = false;\n\n  struct ASTWriterData;\n  std::unique_ptr<ASTWriterData> WriterData;\n\n  FileSystemOptions FileSystemOpts;\n  std::string PreambleStoragePath;\n\n  /// The AST consumer that received information about the translation\n  /// unit as it was parsed or loaded.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The semantic analysis object used to type-check the translation\n  /// unit.\n  std::unique_ptr<Sema> TheSema;\n\n  /// Optional owned invocation, just used to make the invocation used in\n  /// LoadFromCommandLine available.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// Fake module loader: the AST unit doesn't need to load any modules.\n  TrivialModuleLoader ModuleLoader;\n\n  // OnlyLocalDecls - when true, walking this AST should only visit declarations\n  // that come from the AST itself, not from included precompiled headers.\n  // FIXME: This is temporary; eventually, CIndex will always do this.\n  bool OnlyLocalDecls = false;\n\n  /// Whether to capture any diagnostics produced.\n  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None;\n\n  /// Track whether the main file was loaded from an AST or not.\n  bool MainFileIsAST;\n\n  /// What kind of translation unit this AST represents.\n  TranslationUnitKind TUKind = TU_Complete;\n\n  /// Whether we should time each operation.\n  bool WantTiming;\n\n  /// Whether the ASTUnit should delete the remapped buffers.\n  bool OwnsRemappedFileBuffers = true;\n\n  /// Track the top-level decls which appeared in an ASTUnit which was loaded\n  /// from a source file.\n  //\n  // FIXME: This is just an optimization hack to avoid deserializing large parts\n  // of a PCH file when using the Index library on an ASTUnit loaded from\n  // source. In the long term we should make the Index library use efficient and\n  // more scalable search mechanisms.\n  std::vector<Decl*> TopLevelDecls;\n\n  /// Sorted (by file offset) vector of pairs of file offset/Decl.\n  using LocDeclsTy = SmallVector<std::pair<unsigned, Decl *>, 64>;\n  using FileDeclsTy = llvm::DenseMap<FileID, std::unique_ptr<LocDeclsTy>>;\n\n  /// Map from FileID to the file-level declarations that it contains.\n  /// The files and decls are only local (and non-preamble) ones.\n  FileDeclsTy FileDecls;\n\n  /// The name of the original source file used to generate this ASTUnit.\n  std::string OriginalSourceFile;\n\n  /// The set of diagnostics produced when creating the preamble.\n  SmallVector<StandaloneDiagnostic, 4> PreambleDiagnostics;\n\n  /// The set of diagnostics produced when creating this\n  /// translation unit.\n  SmallVector<StoredDiagnostic, 4> StoredDiagnostics;\n\n  /// The set of diagnostics produced when failing to parse, e.g. due\n  /// to failure to load the PCH.\n  SmallVector<StoredDiagnostic, 4> FailedParseDiagnostics;\n\n  /// The number of stored diagnostics that come from the driver\n  /// itself.\n  ///\n  /// Diagnostics that come from the driver are retained from one parse to\n  /// the next.\n  unsigned NumStoredDiagnosticsFromDriver = 0;\n\n  /// Counter that determines when we want to try building a\n  /// precompiled preamble.\n  ///\n  /// If zero, we will never build a precompiled preamble. Otherwise,\n  /// it's treated as a counter that decrements each time we reparse\n  /// without the benefit of a precompiled preamble. When it hits 1,\n  /// we'll attempt to rebuild the precompiled header. This way, if\n  /// building the precompiled preamble fails, we won't try again for\n  /// some number of calls.\n  unsigned PreambleRebuildCountdown = 0;\n\n  /// Counter indicating how often the preamble was build in total.\n  unsigned PreambleCounter = 0;\n\n  /// Cache pairs \"filename - source location\"\n  ///\n  /// Cache contains only source locations from preamble so it is\n  /// guaranteed that they stay valid when the SourceManager is recreated.\n  /// This cache is used when loading preamble to increase performance\n  /// of that loading. It must be cleared when preamble is recreated.\n  llvm::StringMap<SourceLocation> PreambleSrcLocCache;\n\n  /// The contents of the preamble.\n  std::optional<PrecompiledPreamble> Preamble;\n\n  /// When non-NULL, this is the buffer used to store the contents of\n  /// the main file when it has been padded for use with the precompiled\n  /// preamble.\n  std::unique_ptr<llvm::MemoryBuffer> SavedMainFileBuffer;\n\n  /// The number of warnings that occurred while parsing the preamble.\n  ///\n  /// This value will be used to restore the state of the \\c DiagnosticsEngine\n  /// object when re-using the precompiled preamble. Note that only the\n  /// number of warnings matters, since we will not save the preamble\n  /// when any errors are present.\n  unsigned NumWarningsInPreamble = 0;\n\n  /// A list of the serialization ID numbers for each of the top-level\n  /// declarations parsed within the precompiled preamble.\n  std::vector<serialization::DeclID> TopLevelDeclsInPreamble;\n\n  /// Whether we should be caching code-completion results.\n  bool ShouldCacheCodeCompletionResults : 1;\n\n  /// Whether to include brief documentation within the set of code\n  /// completions cached.\n  bool IncludeBriefCommentsInCodeCompletion : 1;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool UserFilesAreVolatile : 1;\n\n  static void ConfigureDiags(IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                             ASTUnit &AST, CaptureDiagsKind CaptureDiagnostics);\n\n  void TranslateStoredDiagnostics(FileManager &FileMgr,\n                                  SourceManager &SrcMan,\n                      const SmallVectorImpl<StandaloneDiagnostic> &Diags,\n                            SmallVectorImpl<StoredDiagnostic> &Out);\n\n  void clearFileLevelDecls();\n\npublic:\n  /// A cached code-completion result, which may be introduced in one of\n  /// many different contexts.\n  struct CachedCodeCompletionResult {\n    /// The code-completion string corresponding to this completion\n    /// result.\n    CodeCompletionString *Completion;\n\n    /// A bitmask that indicates which code-completion contexts should\n    /// contain this completion result.\n    ///\n    /// The bits in the bitmask correspond to the values of\n    /// CodeCompleteContext::Kind. To map from a completion context kind to a\n    /// bit, shift 1 by that number of bits. Many completions can occur in\n    /// several different contexts.\n    uint64_t ShowInContexts;\n\n    /// The priority given to this code-completion result.\n    unsigned Priority;\n\n    /// The libclang cursor kind corresponding to this code-completion\n    /// result.\n    CXCursorKind Kind;\n\n    /// The availability of this code-completion result.\n    CXAvailabilityKind Availability;\n\n    /// The simplified type class for a non-macro completion result.\n    SimplifiedTypeClass TypeClass;\n\n    /// The type of a non-macro completion result, stored as a unique\n    /// integer used by the string map of cached completion types.\n    ///\n    /// This value will be zero if the type is not known, or a unique value\n    /// determined by the formatted type string. Se \\c CachedCompletionTypes\n    /// for more information.\n    unsigned Type;\n  };\n\n  /// Retrieve the mapping from formatted type names to unique type\n  /// identifiers.\n  llvm::StringMap<unsigned> &getCachedCompletionTypes() {\n    return CachedCompletionTypes;\n  }\n\n  /// Retrieve the allocator used to cache global code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator>\n  getCachedCompletionAllocator() {\n    return CachedCompletionAllocator;\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() {\n    if (!CCTUInfo)\n      CCTUInfo = std::make_unique<CodeCompletionTUInfo>(\n          std::make_shared<GlobalCodeCompletionAllocator>());\n    return *CCTUInfo;\n  }\n\nprivate:\n  /// Allocator used to store cached code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator> CachedCompletionAllocator;\n\n  std::unique_ptr<CodeCompletionTUInfo> CCTUInfo;\n\n  /// The set of cached code-completion results.\n  std::vector<CachedCodeCompletionResult> CachedCompletionResults;\n\n  /// A mapping from the formatted type name to a unique number for that\n  /// type, which is used for type equality comparisons.\n  llvm::StringMap<unsigned> CachedCompletionTypes;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the file.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache.\n  unsigned CompletionCacheTopLevelHashValue = 0;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the precompiled preamble.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache after a rebuild of the precompiled preamble.\n  unsigned PreambleTopLevelHashValue = 0;\n\n  /// The current hash value for the top-level declaration and macro\n  /// definition names\n  unsigned CurrentTopLevelHashValue = 0;\n\n  /// Bit used by CIndex to mark when a translation unit may be in an\n  /// inconsistent state, and is not safe to free.\n  unsigned UnsafeToFree : 1;\n\n  /// \\brief Enumerator specifying the scope for skipping function bodies.\n  SkipFunctionBodiesScope SkipFunctionBodies = SkipFunctionBodiesScope::None;\n\n  /// Cache any \"global\" code-completion results, so that we can avoid\n  /// recomputing them with each completion.\n  void CacheCodeCompletionResults();\n\n  /// Clear out and deallocate\n  void ClearCachedCompletionResults();\n\n  explicit ASTUnit(bool MainFileIsAST);\n\n  bool Parse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n             std::unique_ptr<llvm::MemoryBuffer> OverrideMainBuffer,\n             IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\n  std::unique_ptr<llvm::MemoryBuffer> getMainBufferWithPrecompiledPreamble(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      CompilerInvocation &PreambleInvocationIn,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, bool AllowRebuild = true,\n      unsigned MaxLines = 0);\n  void RealizeTopLevelDeclsFromPreamble();\n\n  /// Transfers ownership of the objects (like SourceManager) from\n  /// \\param CI to this ASTUnit.\n  void transferASTDataFromCompilerInstance(CompilerInstance &CI);\n\n  /// Allows us to assert that ASTUnit is not being used concurrently,\n  /// which is not supported.\n  ///\n  /// Clients should create instances of the ConcurrencyCheck class whenever\n  /// using the ASTUnit in a way that isn't intended to be concurrent, which is\n  /// just about any usage.\n  /// Becomes a noop in release mode; only useful for debug mode checking.\n  class ConcurrencyState {\n    void *Mutex; // a std::recursive_mutex in debug;\n\n  public:\n    ConcurrencyState();\n    ~ConcurrencyState();\n\n    void start();\n    void finish();\n  };\n  ConcurrencyState ConcurrencyCheckValue;\n\npublic:\n  friend class ConcurrencyCheck;\n\n  class ConcurrencyCheck {\n    ASTUnit &Self;\n\n  public:\n    explicit ConcurrencyCheck(ASTUnit &Self) : Self(Self) {\n      Self.ConcurrencyCheckValue.start();\n    }\n\n    ~ConcurrencyCheck() {\n      Self.ConcurrencyCheckValue.finish();\n    }\n  };\n\n  ASTUnit(const ASTUnit &) = delete;\n  ASTUnit &operator=(const ASTUnit &) = delete;\n  ~ASTUnit();\n\n  bool isMainFileAST() const { return MainFileIsAST; }\n\n  bool isUnsafeToFree() const { return UnsafeToFree; }\n  void setUnsafeToFree(bool Value) { UnsafeToFree = Value; }\n\n  const DiagnosticsEngine &getDiagnostics() const { return *Diagnostics; }\n  DiagnosticsEngine &getDiagnostics() { return *Diagnostics; }\n\n  const SourceManager &getSourceManager() const { return *SourceMgr; }\n  SourceManager &getSourceManager() { return *SourceMgr; }\n\n  const Preprocessor &getPreprocessor() const { return *PP; }\n  Preprocessor &getPreprocessor() { return *PP; }\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() const { return PP; }\n\n  const ASTContext &getASTContext() const { return *Ctx; }\n  ASTContext &getASTContext() { return *Ctx; }\n\n  void setASTContext(ASTContext *ctx) { Ctx = ctx; }\n  void setPreprocessor(std::shared_ptr<Preprocessor> pp);\n\n  /// Enable source-range based diagnostic messages.\n  ///\n  /// If diagnostic messages with source-range information are to be expected\n  /// and AST comes not from file (e.g. after LoadFromCompilerInvocation) this\n  /// function has to be called.\n  /// The function is to be called only once and the AST should be associated\n  /// with the same source file afterwards.\n  void enableSourceFileDiagnostics();\n\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"ASTUnit does not have a Sema object!\");\n    return *TheSema;\n  }\n\n  const LangOptions &getLangOpts() const {\n    assert(LangOpts && \"ASTUnit does not have language options\");\n    return *LangOpts;\n  }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    assert(HSOpts && \"ASTUnit does not have header search options\");\n    return *HSOpts;\n  }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    assert(PPOpts && \"ASTUnit does not have preprocessor options\");\n    return *PPOpts;\n  }\n\n  const FileManager &getFileManager() const { return *FileMgr; }\n  FileManager &getFileManager() { return *FileMgr; }\n\n  const FileSystemOptions &getFileSystemOpts() const { return FileSystemOpts; }\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n\n  StringRef getOriginalSourceFileName() const {\n    return OriginalSourceFile;\n  }\n\n  ASTMutationListener *getASTMutationListener();\n  ASTDeserializationListener *getDeserializationListener();\n\n  bool getOnlyLocalDecls() const { return OnlyLocalDecls; }\n\n  bool getOwnsRemappedFileBuffers() const { return OwnsRemappedFileBuffers; }\n  void setOwnsRemappedFileBuffers(bool val) { OwnsRemappedFileBuffers = val; }\n\n  StringRef getMainFileName() const;\n\n  /// If this ASTUnit came from an AST file, returns the filename for it.\n  StringRef getASTFileName() const;\n\n  using top_level_iterator = std::vector<Decl *>::iterator;\n\n  top_level_iterator top_level_begin() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.begin();\n  }\n\n  top_level_iterator top_level_end() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.end();\n  }\n\n  std::size_t top_level_size() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.size() + TopLevelDecls.size();\n  }\n\n  bool top_level_empty() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.empty() && TopLevelDecls.empty();\n  }\n\n  /// Add a new top-level declaration.\n  void addTopLevelDecl(Decl *D) {\n    TopLevelDecls.push_back(D);\n  }\n\n  /// Add a new local file-level declaration.\n  void addFileLevelDecl(Decl *D);\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void findFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls);\n\n  /// Retrieve a reference to the current top-level name hash value.\n  ///\n  /// Note: This is used internally by the top-level tracking action\n  unsigned &getCurrentTopLevelHashValue() { return CurrentTopLevelHashValue; }\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// The difference with SourceManager::getLocation is that this method checks\n  /// whether the requested location points inside the precompiled preamble\n  /// in which case the returned source location will be a \"loaded\" one.\n  SourceLocation getLocation(const FileEntry *File,\n                             unsigned Line, unsigned Col) const;\n\n  /// Get the source location for the given file:offset pair.\n  SourceLocation getLocation(const FileEntry *File, unsigned Offset) const;\n\n  /// If \\p Loc is a loaded location from the preamble, returns\n  /// the corresponding local location of the main file, otherwise it returns\n  /// \\p Loc.\n  SourceLocation mapLocationFromPreamble(SourceLocation Loc) const;\n\n  /// If \\p Loc is a local location of the main file but inside the\n  /// preamble chunk, returns the corresponding loaded location from the\n  /// preamble, otherwise it returns \\p Loc.\n  SourceLocation mapLocationToPreamble(SourceLocation Loc) const;\n\n  bool isInPreambleFileID(SourceLocation Loc) const;\n  bool isInMainFileID(SourceLocation Loc) const;\n  SourceLocation getStartOfMainFileID() const;\n  SourceLocation getEndOfPreambleFileID() const;\n\n  /// \\see mapLocationFromPreamble.\n  SourceRange mapRangeFromPreamble(SourceRange R) const {\n    return SourceRange(mapLocationFromPreamble(R.getBegin()),\n                       mapLocationFromPreamble(R.getEnd()));\n  }\n\n  /// \\see mapLocationToPreamble.\n  SourceRange mapRangeToPreamble(SourceRange R) const {\n    return SourceRange(mapLocationToPreamble(R.getBegin()),\n                       mapLocationToPreamble(R.getEnd()));\n  }\n\n  unsigned getPreambleCounterForTests() const { return PreambleCounter; }\n\n  // Retrieve the diagnostics associated with this AST\n  using stored_diag_iterator = StoredDiagnostic *;\n  using stored_diag_const_iterator = const StoredDiagnostic *;\n\n  stored_diag_const_iterator stored_diag_begin() const {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_iterator stored_diag_begin() {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_const_iterator stored_diag_end() const {\n    return StoredDiagnostics.end();\n  }\n\n  stored_diag_iterator stored_diag_end() {\n    return StoredDiagnostics.end();\n  }\n\n  unsigned stored_diag_size() const { return StoredDiagnostics.size(); }\n\n  stored_diag_iterator stored_diag_afterDriver_begin() {\n    if (NumStoredDiagnosticsFromDriver > StoredDiagnostics.size())\n      NumStoredDiagnosticsFromDriver = 0;\n    return StoredDiagnostics.begin() + NumStoredDiagnosticsFromDriver;\n  }\n\n  using cached_completion_iterator =\n      std::vector<CachedCodeCompletionResult>::iterator;\n\n  cached_completion_iterator cached_completion_begin() {\n    return CachedCompletionResults.begin();\n  }\n\n  cached_completion_iterator cached_completion_end() {\n    return CachedCompletionResults.end();\n  }\n\n  unsigned cached_completion_size() const {\n    return CachedCompletionResults.size();\n  }\n\n  /// Returns an iterator range for the local preprocessing entities\n  /// of the local Preprocessor, if this is a parsed source file, or the loaded\n  /// preprocessing entities of the primary module if this is an AST file.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getLocalPreprocessingEntities() const;\n\n  /// Type for a function iterating over a number of declarations.\n  /// \\returns true to continue iteration and false to abort.\n  using DeclVisitorFn = bool (*)(void *context, const Decl *D);\n\n  /// Iterate over local declarations (locally parsed if this is a parsed\n  /// source file or the loaded declarations of the primary module if this is an\n  /// AST file).\n  /// \\returns true if the iteration was complete or false if it was aborted.\n  bool visitLocalTopLevelDecls(void *context, DeclVisitorFn Fn);\n\n  /// Get the PCH file if one was included.\n  OptionalFileEntryRef getPCHFile();\n\n  /// Returns true if the ASTUnit was constructed from a serialized\n  /// module file.\n  bool isModuleFile() const;\n\n  std::unique_ptr<llvm::MemoryBuffer>\n  getBufferForFile(StringRef Filename, std::string *ErrorStr = nullptr);\n\n  /// Determine what kind of translation unit this AST represents.\n  TranslationUnitKind getTranslationUnitKind() const { return TUKind; }\n\n  /// Determine the input kind this AST unit represents.\n  InputKind getInputKind() const;\n\n  /// A mapping from a file name to the memory buffer that stores the\n  /// remapped contents of that file.\n  using RemappedFile = std::pair<std::string, llvm::MemoryBuffer *>;\n\n  /// Create a ASTUnit. Gets ownership of the passed CompilerInvocation.\n  static std::unique_ptr<ASTUnit>\n  create(std::shared_ptr<CompilerInvocation> CI,\n         IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n         CaptureDiagsKind CaptureDiagnostics, bool UserFilesAreVolatile);\n\n  enum WhatToLoad {\n    /// Load options and the preprocessor state.\n    LoadPreprocessorOnly,\n\n    /// Load the AST, but do not restore Sema state.\n    LoadASTOnly,\n\n    /// Load everything, including Sema.\n    LoadEverything\n  };\n\n  /// Create a ASTUnit from an AST file.\n  ///\n  /// \\param Filename - The AST file to load.\n  ///\n  /// \\param PCHContainerRdr - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\returns - The initialized ASTUnit or null if the AST failed to load.\n  static std::unique_ptr<ASTUnit>\n  LoadFromASTFile(const std::string &Filename,\n                  const PCHContainerReader &PCHContainerRdr, WhatToLoad ToLoad,\n                  IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                  const FileSystemOptions &FileSystemOpts,\n                  std::shared_ptr<HeaderSearchOptions> HSOpts,\n                  bool UseDebugInfo = false, bool OnlyLocalDecls = false,\n                  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n                  bool AllowASTWithCompilerErrors = false,\n                  bool UserFilesAreVolatile = false,\n                  IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS =\n                      llvm::vfs::getRealFileSystem());\n\nprivate:\n  /// Helper function for \\c LoadFromCompilerInvocation() and\n  /// \\c LoadFromCommandLine(), which loads an AST from a compiler invocation.\n  ///\n  /// \\param PrecompilePreambleAfterNParses After how many parses the preamble\n  /// of this translation unit should be precompiled, to improve the performance\n  /// of reparsing. Set to zero to disable preambles.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem).\n  ///\n  /// \\returns \\c true if a catastrophic failure occurred (which means that the\n  /// \\c ASTUnit itself is invalid), or \\c false otherwise.\n  bool LoadFromCompilerInvocation(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      unsigned PrecompilePreambleAfterNParses,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\npublic:\n  /// Create an ASTUnit from a source file, via a CompilerInvocation\n  /// object, by invoking the optionally provided ASTFrontendAction.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param Action - The ASTFrontendAction to invoke. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Unit - optionally an already created ASTUnit. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Persistent - if true the returned ASTUnit will be complete.\n  /// false means the caller is only interested in getting info through the\n  /// provided \\see Action.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  /// This will only receive an ASTUnit if a new one was created. If an already\n  /// created ASTUnit was passed in \\p Unit then the caller can check that.\n  ///\n  static ASTUnit *LoadFromCompilerInvocationAction(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n      FrontendAction *Action = nullptr, ASTUnit *Unit = nullptr,\n      bool Persistent = true, StringRef ResourceFilesPath = StringRef(),\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      bool CacheCodeCompletionResults = false,\n      bool UserFilesAreVolatile = false,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr);\n\n  /// LoadFromCompilerInvocation - Create an ASTUnit from a source file, via a\n  /// CompilerInvocation object.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  //\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static std::unique_ptr<ASTUnit> LoadFromCompilerInvocation(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FileManager *FileMgr,\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool UserFilesAreVolatile = false);\n\n  /// LoadFromCommandLine - Create an ASTUnit from a vector of command line\n  /// arguments, which must specify exactly one source file.\n  ///\n  /// \\param ArgBegin - The beginning of the argument vector.\n  ///\n  /// \\param ArgEnd - The end of the argument vector.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param ResourceFilesPath - The path to the compiler resource files.\n  ///\n  /// \\param StorePreamblesInMemory - Whether to store PCH in memory. If false,\n  /// PCH are stored in temporary files.\n  ///\n  /// \\param PreambleStoragePath - The path to a directory, in which to create\n  /// temporary PCH files. If empty, the default system temporary directory is\n  /// used. This parameter is ignored if \\p StorePreamblesInMemory is true.\n  ///\n  /// \\param ModuleFormat - If provided, uses the specific module format.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem). RealFileSystem will be used\n  /// if \\p VFS is nullptr.\n  ///\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static std::unique_ptr<ASTUnit> LoadFromCommandLine(\n      const char **ArgBegin, const char **ArgEnd,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, StringRef ResourceFilesPath,\n      bool StorePreamblesInMemory = false,\n      StringRef PreambleStoragePath = StringRef(), bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      ArrayRef<RemappedFile> RemappedFiles = std::nullopt,\n      bool RemappedFilesKeepOriginalName = true,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool AllowPCHWithCompilerErrors = false,\n      SkipFunctionBodiesScope SkipFunctionBodies =\n          SkipFunctionBodiesScope::None,\n      bool SingleFileParse = false, bool UserFilesAreVolatile = false,\n      bool ForSerialization = false,\n      bool RetainExcludedConditionalBlocks = false,\n      std::optional<StringRef> ModuleFormat = std::nullopt,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Reparse the source files using the same command-line options that\n  /// were originally used to produce this translation unit.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should give an access to\n  /// this(i.e. be an overlay over RealFileSystem).\n  /// FileMgr->getVirtualFileSystem() will be used if \\p VFS is nullptr.\n  ///\n  /// \\returns True if a failure occurred that causes the ASTUnit not to\n  /// contain any translation-unit information, false otherwise.\n  bool Reparse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n               ArrayRef<RemappedFile> RemappedFiles = std::nullopt,\n               IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Free data that will be re-generated on the next parse.\n  ///\n  /// Preamble-related data is not affected.\n  void ResetForParse();\n\n  /// Perform code completion at the given file, line, and\n  /// column within this translation unit.\n  ///\n  /// \\param File The file in which code completion will occur.\n  ///\n  /// \\param Line The line at which code completion will occur.\n  ///\n  /// \\param Column The column at which code completion will occur.\n  ///\n  /// \\param IncludeMacros Whether to include macros in the code-completion\n  /// results.\n  ///\n  /// \\param IncludeCodePatterns Whether to include code patterns (such as a\n  /// for loop) in the code-completion results.\n  ///\n  /// \\param IncludeBriefComments Whether to include brief documentation within\n  /// the set of code completions returned.\n  ///\n  /// FIXME: The Diag, LangOpts, SourceMgr, FileMgr, StoredDiagnostics, and\n  /// OwnedBuffers parameters are all disgusting hacks. They will go away.\n  void CodeComplete(StringRef File, unsigned Line, unsigned Column,\n                    ArrayRef<RemappedFile> RemappedFiles, bool IncludeMacros,\n                    bool IncludeCodePatterns, bool IncludeBriefComments,\n                    CodeCompleteConsumer &Consumer,\n                    std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n                    DiagnosticsEngine &Diag, LangOptions &LangOpts,\n                    SourceManager &SourceMgr, FileManager &FileMgr,\n                    SmallVectorImpl<StoredDiagnostic> &StoredDiagnostics,\n                    SmallVectorImpl<const llvm::MemoryBuffer *> &OwnedBuffers);\n\n  /// Save this translation unit to a file with the given name.\n  ///\n  /// \\returns true if there was a file error or false if the save was\n  /// successful.\n  bool Save(StringRef File);\n\n  /// Serialize this translation unit with the given output stream.\n  ///\n  /// \\returns True if an error occurred, false otherwise.\n  bool serialize(raw_ostream &OS);\n}",
  "id": "BLOCK-CPP-18213",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/ASTUnit.h",
  "source_line": 88,
  "validation_status": "validated"
}