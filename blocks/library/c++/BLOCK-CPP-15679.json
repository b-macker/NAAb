{
  "code": "{\npublic:\n  enum ItemKind {\n    VariableKind,\n    NewAllocatorKind,\n    ReturnKind,\n    MaterializationKind,\n    TemporaryDestructorKind,\n    ElidedDestructorKind,\n    ElidableConstructorKind,\n    ArgumentKind,\n    LambdaCaptureKind,\n    STATEMENT_WITH_INDEX_KIND_BEGIN = ArgumentKind,\n    STATEMENT_WITH_INDEX_KIND_END = LambdaCaptureKind,\n    STATEMENT_KIND_BEGIN = VariableKind,\n    STATEMENT_KIND_END = LambdaCaptureKind,\n    InitializerKind,\n    INITIALIZER_KIND_BEGIN = InitializerKind,\n    INITIALIZER_KIND_END = InitializerKind\n  };\n\n  LLVM_DUMP_METHOD static StringRef getKindAsString(ItemKind K) {\n    switch (K) {\n      case VariableKind:            return \"construct into local variable\";\n      case NewAllocatorKind:        return \"construct into new-allocator\";\n      case ReturnKind:              return \"construct into return address\";\n      case MaterializationKind:     return \"materialize temporary\";\n      case TemporaryDestructorKind: return \"destroy temporary\";\n      case ElidedDestructorKind:    return \"elide destructor\";\n      case ElidableConstructorKind: return \"elide constructor\";\n      case ArgumentKind:            return \"construct into argument\";\n      case LambdaCaptureKind:\n        return \"construct into lambda captured variable\";\n      case InitializerKind:         return \"construct into member variable\";\n    };\n    llvm_unreachable(\"Unknown ItemKind\");\n  }\n\nprivate:\n  const void *const Data;\n  const ItemKind Kind;\n  const unsigned Index = 0;\n\n  bool hasStatement() const {\n    return Kind >= STATEMENT_KIND_BEGIN &&\n           Kind <= STATEMENT_KIND_END;\n  }\n\n  bool hasIndex() const {\n    return Kind >= STATEMENT_WITH_INDEX_KIND_BEGIN &&\n           Kind <= STATEMENT_WITH_INDEX_KIND_END;\n  }\n\n  bool hasInitializer() const {\n    return Kind >= INITIALIZER_KIND_BEGIN &&\n           Kind <= INITIALIZER_KIND_END;\n  }\n\npublic:\n  // ConstructionContextItem should be simple enough so that it was easy to\n  // re-construct it from the AST node it captures. For that reason we provide\n  // simple implicit conversions from all sorts of supported AST nodes.\n  ConstructionContextItem(const DeclStmt *DS)\n      : Data(DS), Kind(VariableKind) {}\n\n  ConstructionContextItem(const CXXNewExpr *NE)\n      : Data(NE), Kind(NewAllocatorKind) {}\n\n  ConstructionContextItem(const ReturnStmt *RS)\n      : Data(RS), Kind(ReturnKind) {}\n\n  ConstructionContextItem(const MaterializeTemporaryExpr *MTE)\n      : Data(MTE), Kind(MaterializationKind) {}\n\n  ConstructionContextItem(const CXXBindTemporaryExpr *BTE,\n                          bool IsElided = false)\n      : Data(BTE),\n        Kind(IsElided ? ElidedDestructorKind : TemporaryDestructorKind) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE)\n      : Data(CE), Kind(ElidableConstructorKind) {}\n\n  ConstructionContextItem(const CallExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXInheritedCtorInitExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const ObjCMessageExpr *ME, unsigned Index)\n      : Data(ME), Kind(ArgumentKind), Index(Index) {}\n\n  // A polymorphic version of the previous calls with dynamic type check.\n  ConstructionContextItem(const Expr *E, unsigned Index)\n      : Data(E), Kind(ArgumentKind), Index(Index) {\n    assert(isa<CallExpr>(E) || isa<CXXConstructExpr>(E) ||\n           isa<CXXDeleteExpr>(E) || isa<CXXInheritedCtorInitExpr>(E) ||\n           isa<ObjCMessageExpr>(E));\n  }\n\n  ConstructionContextItem(const CXXCtorInitializer *Init)\n      : Data(Init), Kind(InitializerKind), Index(0) {}\n\n  ConstructionContextItem(const LambdaExpr *LE, unsigned Index)\n      : Data(LE), Kind(LambdaCaptureKind), Index(Index) {}\n\n  ItemKind getKind() const { return Kind; }\n\n  LLVM_DUMP_METHOD StringRef getKindAsString() const {\n    return getKindAsString(getKind());\n  }\n\n  /// The construction site - the statement that triggered the construction\n  /// for one of its parts. For instance, stack variable declaration statement\n  /// triggers construction of itself or its elements if it's an array,\n  /// new-expression triggers construction of the newly allocated object(s).\n  const Stmt *getStmt() const {\n    assert(hasStatement());\n    return static_cast<const Stmt *>(Data);\n  }\n\n  const Stmt *getStmtOrNull() const {\n    return hasStatement() ? getStmt() : nullptr;\n  }\n\n  /// The construction site is not necessarily a statement. It may also be a\n  /// CXXCtorInitializer, which means that a member variable is being\n  /// constructed during initialization of the object that contains it.\n  const CXXCtorInitializer *getCXXCtorInitializer() const {\n    assert(hasInitializer());\n    return static_cast<const CXXCtorInitializer *>(Data);\n  }\n\n  /// If a single trigger statement triggers multiple constructors, they are\n  /// usually being enumerated. This covers function argument constructors\n  /// triggered by a call-expression and items in an initializer list triggered\n  /// by an init-list-expression.\n  unsigned getIndex() const {\n    // This is a fairly specific request. Let's make sure the user knows\n    // what he's doing.\n    assert(hasIndex());\n    return Index;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Data);\n    ID.AddInteger(Kind);\n    ID.AddInteger(Index);\n  }\n\n  bool operator==(const ConstructionContextItem &Other) const {\n    // For most kinds the Index comparison is trivially true, but\n    // checking kind separately doesn't seem to be less expensive\n    // than checking Index. Same in operator<().\n    return std::make_tuple(Data, Kind, Index) ==\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n\n  bool operator<(const ConstructionContextItem &Other) const {\n    return std::make_tuple(Data, Kind, Index) <\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n}",
  "id": "BLOCK-CPP-15679",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/ConstructionContext.h",
  "source_line": 28,
  "validation_status": "validated"
}