{
  "code": "#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/Endian.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <vector>\n\nusing namespace clang;\nusing namespace serialization;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21026_execute() {\n    {\npublic:\n  ModuleFile(ModuleKind Kind, unsigned Generation)\n      : Kind(Kind), Generation(Generation) {}\n  ~ModuleFile();\n\n  // === General information ===\n\n  /// The index of this module in the list of modules.\n  unsigned Index = 0;\n\n  /// The type of this module.\n  ModuleKind Kind;\n\n  /// The file name of the module file.\n  std::string FileName;\n\n  /// The name of the module.\n  std::string ModuleName;\n\n  /// The base directory of the module.\n  std::string BaseDirectory;\n\n  std::string getTimestampFilename() const {\n    return FileName + \".timestamp\";\n  }\n\n  /// The original source file name that was used to build the\n  /// primary AST file, which may have been modified for\n  /// relocatable-pch support.\n  std::string OriginalSourceFileName;\n\n  /// The actual original source file name that was used to\n  /// build this AST file.\n  std::string ActualOriginalSourceFileName;\n\n  /// The file ID for the original source file that was used to\n  /// build this AST file.\n  FileID OriginalSourceFileID;\n\n  std::string ModuleMapPath;\n\n  /// Whether this precompiled header is a relocatable PCH file.\n  bool RelocatablePCH = false;\n\n  /// Whether this module file is a standard C++ module.\n  bool StandardCXXModule = false;\n\n  /// Whether timestamps are included in this module file.\n  bool HasTimestamps = false;\n\n  /// Whether the top-level module has been read from the AST file.\n  bool DidReadTopLevelSubmodule = false;\n\n  /// The file entry for the module file.\n  OptionalFileEntryRefDegradesToFileEntryPtr File;\n\n  /// The signature of the module file, which may be used instead of the size\n  /// and modification time to identify this particular file.\n  ASTFileSignature Signature;\n\n  /// The signature of the AST block of the module file, this can be used to\n  /// unique module files based on AST contents.\n  ASTFileSignature ASTBlockHash;\n\n  /// The bit vector denoting usage of each header search entry (true = used).\n  llvm::BitVector SearchPathUsage;\n\n  /// Whether this module has been directly imported by the\n  /// user.\n  bool DirectlyImported = false;\n\n  /// The generation of which this module file is a part.\n  unsigned Generation;\n\n  /// The memory buffer that stores the data associated with\n  /// this AST file, owned by the InMemoryModuleCache.\n  llvm::MemoryBuffer *Buffer = nullptr;\n\n  /// The size of this file, in bits.\n  uint64_t SizeInBits = 0;\n\n  /// The global bit offset (or base) of this module\n  uint64_t GlobalBitOffset = 0;\n\n  /// The bit offset of the AST block of this module.\n  uint64_t ASTBlockStartOffset = 0;\n\n  /// The serialized bitstream data for this file.\n  StringRef Data;\n\n  /// The main bitstream cursor for the main block.\n  llvm::BitstreamCursor Stream;\n\n  /// The source location where the module was explicitly or implicitly\n  /// imported in the local translation unit.\n  ///\n  /// If module A depends on and imports module B, both modules will have the\n  /// same DirectImportLoc, but different ImportLoc (B's ImportLoc will be a\n  /// source location inside module A).\n  ///\n  /// WARNING: This is largely useless. It doesn't tell you when a module was\n  /// made visible, just when the first submodule of that module was imported.\n  SourceLocation DirectImportLoc;\n\n  /// The source location where this module was first imported.\n  SourceLocation ImportLoc;\n\n  /// The first source location in this module.\n  SourceLocation FirstLoc;\n\n  /// The list of extension readers that are attached to this module\n  /// file.\n  std::vector<std::unique_ptr<ModuleFileExtensionReader>> ExtensionReaders;\n\n  /// The module offset map data for this file. If non-empty, the various\n  /// ContinuousRangeMaps described below have not yet been populated.\n  StringRef ModuleOffsetMap;\n\n  // === Input Files ===\n\n  /// The cursor to the start of the input-files block.\n  llvm::BitstreamCursor InputFilesCursor;\n\n  /// Offsets for all of the input file entries in the AST file.\n  const llvm::support::unaligned_uint64_t *InputFileOffsets = nullptr;\n\n  /// The input files that have been loaded from this AST file.\n  std::vector<InputFile> InputFilesLoaded;\n\n  /// The input file infos that have been loaded from this AST file.\n  std::vector<InputFileInfo> InputFileInfosLoaded;\n\n  // All user input files reside at the index range [0, NumUserInputFiles), and\n  // system input files reside at [NumUserInputFiles, InputFilesLoaded.size()).\n  unsigned NumUserInputFiles = 0;\n\n  /// If non-zero, specifies the time when we last validated input\n  /// files.  Zero means we never validated them.\n  ///\n  /// The time is specified in seconds since the start of the Epoch.\n  uint64_t InputFilesValidationTimestamp = 0;\n\n  // === Source Locations ===\n\n  /// Cursor used to read source location entries.\n  llvm::BitstreamCursor SLocEntryCursor;\n\n  /// The bit offset to the start of the SOURCE_MANAGER_BLOCK.\n  uint64_t SourceManagerBlockStartOffset = 0;\n\n  /// The number of source location entries in this AST file.\n  unsigned LocalNumSLocEntries = 0;\n\n  /// The base ID in the source manager's view of this module.\n  int SLocEntryBaseID = 0;\n\n  /// The base offset in the source manager's view of this module.\n  SourceLocation::UIntTy SLocEntryBaseOffset = 0;\n\n  /// Base file offset for the offsets in SLocEntryOffsets. Real file offset\n  /// for the entry is SLocEntryOffsetsBase + SLocEntryOffsets[i].\n  uint64_t SLocEntryOffsetsBase = 0;\n\n  /// Offsets for all of the source location entries in the\n  /// AST file.\n  const uint32_t *SLocEntryOffsets = nullptr;\n\n  /// SLocEntries that we're going to preload.\n  SmallVector<uint64_t, 4> PreloadSLocEntries;\n\n  /// Remapping table for source locations in this module.\n  ContinuousRangeMap<SourceLocation::UIntTy, SourceLocation::IntTy, 2>\n      SLocRemap;\n\n  // === Identifiers ===\n\n  /// The number of identifiers in this AST file.\n  unsigned LocalNumIdentifiers = 0;\n\n  /// Offsets into the identifier table data.\n  ///\n  /// This array is indexed by the identifier ID (-1), and provides\n  /// the offset into IdentifierTableData where the string data is\n  /// stored.\n  const uint32_t *IdentifierOffsets = nullptr;\n\n  /// Base identifier ID for identifiers local to this module.\n  serialization::IdentID BaseIdentifierID = 0;\n\n  /// Remapping table for identifier IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> IdentifierRemap;\n\n  /// Actual data for the on-disk hash table of identifiers.\n  ///\n  /// This pointer points into a memory buffer, where the on-disk hash\n  /// table for identifiers actually lives.\n  const unsigned char *IdentifierTableData = nullptr;\n\n  /// A pointer to an on-disk hash table of opaque type\n  /// IdentifierHashTable.\n  void *IdentifierLookupTable = nullptr;\n\n  /// Offsets of identifiers that we're going to preload within\n  /// IdentifierTableData.\n  std::vector<unsigned> PreloadIdentifierOffsets;\n\n  // === Macros ===\n\n  /// The cursor to the start of the preprocessor block, which stores\n  /// all of the macro definitions.\n  llvm::BitstreamCursor MacroCursor;\n\n  /// The number of macros in this AST file.\n  unsigned LocalNumMacros = 0;\n\n  /// Base file offset for the offsets in MacroOffsets. Real file offset for\n  /// the entry is MacroOffsetsBase + MacroOffsets[i].\n  uint64_t MacroOffsetsBase = 0;\n\n  /// Offsets of macros in the preprocessor block.\n  ///\n  /// This array is indexed by the macro ID (-1), and provides\n  /// the offset into the preprocessor block where macro definitions are\n  /// stored.\n  const uint32_t *MacroOffsets = nullptr;\n\n  /// Base macro ID for macros local to this module.\n  serialization::MacroID BaseMacroID = 0;\n\n  /// Remapping table for macro IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> MacroRemap;\n\n  /// The offset of the start of the set of defined macros.\n  uint64_t MacroStartOffset = 0;\n\n  // === Detailed PreprocessingRecord ===\n\n  /// The cursor to the start of the (optional) detailed preprocessing\n  /// record block.\n  llvm::BitstreamCursor PreprocessorDetailCursor;\n\n  /// The offset of the start of the preprocessor detail cursor.\n  uint64_t PreprocessorDetailStartOffset = 0;\n\n  /// Base preprocessed entity ID for preprocessed entities local to\n  /// this module.\n  serialization::PreprocessedEntityID BasePreprocessedEntityID = 0;\n\n  /// Remapping table for preprocessed entity IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> PreprocessedEntityRemap;\n\n  const PPEntityOffset *PreprocessedEntityOffsets = nullptr;\n  unsigned NumPreprocessedEntities = 0;\n\n  /// Base ID for preprocessed skipped ranges local to this module.\n  unsigned BasePreprocessedSkippedRangeID = 0;\n\n  const PPSkippedRange *PreprocessedSkippedRangeOffsets = nullptr;\n  unsigned NumPreprocessedSkippedRanges = 0;\n\n  // === Header search information ===\n\n  /// The number of local HeaderFileInfo structures.\n  unsigned LocalNumHeaderFileInfos = 0;\n\n  /// Actual data for the on-disk hash table of header file\n  /// information.\n  ///\n  /// This pointer points into a memory buffer, where the on-disk hash\n  /// table for header file information actually lives.\n  const char *HeaderFileInfoTableData = nullptr;\n\n  /// The on-disk hash table that contains information about each of\n  /// the header files.\n  void *HeaderFileInfoTable = nullptr;\n\n  // === Submodule information ===\n\n  /// The number of submodules in this module.\n  unsigned LocalNumSubmodules = 0;\n\n  /// Base submodule ID for submodules local to this module.\n  serialization::SubmoduleID BaseSubmoduleID = 0;\n\n  /// Remapping table for submodule IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> SubmoduleRemap;\n\n  // === Selectors ===\n\n  /// The number of selectors new to this file.\n  ///\n  /// This is the number of entries in SelectorOffsets.\n  unsigned LocalNumSelectors = 0;\n\n  /// Offsets into the selector lookup table's data array\n  /// where each selector resides.\n  const uint32_t *SelectorOffsets = nullptr;\n\n  /// Base selector ID for selectors local to this module.\n  serialization::SelectorID BaseSelectorID = 0;\n\n  /// Remapping table for selector IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> SelectorRemap;\n\n  /// A pointer to the character data that comprises the selector table\n  ///\n  /// The SelectorOffsets table refers into this memory.\n  const unsigned char *SelectorLookupTableData = nullptr;\n\n  /// A pointer to an on-disk hash table of opaque type\n  /// ASTSelectorLookupTable.\n  ///\n  /// This hash table provides the IDs of all selectors, and the associated\n  /// instance and factory methods.\n  void *SelectorLookupTable = nullptr;\n\n  // === Declarations ===\n\n  /// DeclsCursor - This is a cursor to the start of the DECLTYPES_BLOCK block.\n  /// It has read all the abbreviations at the start of the block and is ready\n  /// to jump around with these in context.\n  llvm::BitstreamCursor DeclsCursor;\n\n  /// The offset to the start of the DECLTYPES_BLOCK block.\n  uint64_t DeclsBlockStartOffset = 0;\n\n  /// The number of declarations in this AST file.\n  unsigned LocalNumDecls = 0;\n\n  /// Offset of each declaration within the bitstream, indexed\n  /// by the declaration ID (-1).\n  const DeclOffset *DeclOffsets = nullptr;\n\n  /// Base declaration ID for declarations local to this module.\n  serialization::DeclID BaseDeclID = 0;\n\n  /// Remapping table for declaration IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> DeclRemap;\n\n  /// Mapping from the module files that this module file depends on\n  /// to the base declaration ID for that module as it is understood within this\n  /// module.\n  ///\n  /// This is effectively a reverse global-to-local mapping for declaration\n  /// IDs, so that we can interpret a true global ID (for this translation unit)\n  /// as a local ID (for this module file).\n  llvm::DenseMap<ModuleFile *, serialization::DeclID> GlobalToLocalDeclIDs;\n\n  /// Array of file-level DeclIDs sorted by file.\n  const serialization::DeclID *FileSortedDecls = nullptr;\n  unsigned NumFileSortedDecls = 0;\n\n  /// Array of category list location information within this\n  /// module file, sorted by the definition ID.\n  const serialization::ObjCCategoriesInfo *ObjCCategoriesMap = nullptr;\n\n  /// The number of redeclaration info entries in ObjCCategoriesMap.\n  unsigned LocalNumObjCCategoriesInMap = 0;\n\n  /// The Objective-C category lists for categories known to this\n  /// module.\n  SmallVector<uint64_t, 1> ObjCCategories;\n\n  // === Types ===\n\n  /// The number of types in this AST file.\n  unsigned LocalNumTypes = 0;\n\n  /// Offset of each type within the bitstream, indexed by the\n  /// type ID, or the representation of a Type*.\n  const UnderalignedInt64 *TypeOffsets = nullptr;\n\n  /// Base type ID for types local to this module as represented in\n  /// the global type ID space.\n  serialization::TypeID BaseTypeIndex = 0;\n\n  /// Remapping table for type IDs in this module.\n  ContinuousRangeMap<uint32_t, int, 2> TypeRemap;\n\n  // === Miscellaneous ===\n\n  /// Diagnostic IDs and their mappings that the user changed.\n  SmallVector<uint64_t, 8> PragmaDiagMappings;\n\n  /// List of modules which depend on this module\n  llvm::SetVector<ModuleFile *> ImportedBy;\n\n  /// List of modules which this module depends on\n  llvm::SetVector<ModuleFile *> Imports;\n\n  /// Determine whether this module was directly imported at\n  /// any point during translation.\n  bool isDirectlyImported() const { return DirectlyImported; }\n\n  /// Is this a module file for a module (rather than a PCH or similar).\n  bool isModule() const {\n    return Kind == MK_ImplicitModule || Kind == MK_ExplicitModule ||\n           Kind == MK_PrebuiltModule;\n  }\n\n  /// Dump debugging output for this module.\n  void dump();\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21026",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ModuleFile.h",
  "source_line": 122,
  "validation_status": "validated"
}