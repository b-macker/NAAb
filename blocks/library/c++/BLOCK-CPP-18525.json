{
  "code": "{\n\nclass ASTContext;\nclass Interpreter;\nclass QualType;\n\n#if defined(_WIN32)\n// REPL_EXTERNAL_VISIBILITY are symbols that we need to be able to locate\n// at runtime. On Windows, this requires them to be exported from any of the\n// modules loaded at runtime. Marking them as dllexport achieves this; both\n// for DLLs (that normally export symbols as part of their interface) and for\n// EXEs (that normally don't export anything).\n// For a build with libclang-cpp.dll, this doesn't make any difference - the\n// functions would have been exported anyway. But for cases when these are\n// statically linked into an EXE, it makes sure that they're exported.\n#define REPL_EXTERNAL_VISIBILITY __declspec(dllexport)\n#elif __has_attribute(visibility)\n#if defined(LLVM_BUILD_LLVM_DYLIB) || defined(LLVM_BUILD_SHARED_LIBS)\n#define REPL_EXTERNAL_VISIBILITY __attribute__((visibility(\"default\")))\n#else\n#define REPL_EXTERNAL_VISIBILITY\n#endif\n#else\n#define REPL_EXTERNAL_VISIBILITY\n#endif\n\n#define REPL_BUILTIN_TYPES                                                     \\\n  X(bool, Bool)                                                                \\\n  X(char, Char_S)                                                              \\\n  X(signed char, SChar)                                                        \\\n  X(unsigned char, UChar)                                                      \\\n  X(short, Short)                                                              \\\n  X(unsigned short, UShort)                                                    \\\n  X(int, Int)                                                                  \\\n  X(unsigned int, UInt)                                                        \\\n  X(long, Long)                                                                \\\n  X(unsigned long, ULong)                                                      \\\n  X(long long, LongLong)                                                       \\\n  X(unsigned long long, ULongLong)                                             \\\n  X(float, Float)                                                              \\\n  X(double, Double)                                                            \\\n  X(long double, LongDouble)\n\nclass REPL_EXTERNAL_VISIBILITY Value {\n  union Storage {\n#define X(type, name) type m_##name;\n    REPL_BUILTIN_TYPES\n#undef X\n    void *m_Ptr;\n  };\n\npublic:\n  enum Kind {\n#define X(type, name) K_##name,\n    REPL_BUILTIN_TYPES\n#undef X\n\n    K_Void,\n    K_PtrOrObj,\n    K_Unspecified\n  };\n\n  Value() = default;\n  Value(Interpreter *In, void *Ty);\n  Value(const Value &RHS);\n  Value(Value &&RHS) noexcept;\n  Value &operator=(const Value &RHS);\n  Value &operator=(Value &&RHS) noexcept;\n  ~Value();\n\n  void printType(llvm::raw_ostream &Out) const;\n  void printData(llvm::raw_ostream &Out) const;\n  void print(llvm::raw_ostream &Out) const;\n  void dump() const;\n  void clear();\n\n  ASTContext &getASTContext();\n  const ASTContext &getASTContext() const;\n  Interpreter &getInterpreter();\n  const Interpreter &getInterpreter() const;\n  QualType getType() const;\n\n  bool isValid() const { return ValueKind != K_Unspecified; }\n  bool isVoid() const { return ValueKind == K_Void; }\n  bool hasValue() const { return isValid() && !isVoid(); }\n  bool isManuallyAlloc() const { return IsManuallyAlloc; }\n  Kind getKind() const { return ValueKind; }\n  void setKind(Kind K) { ValueKind = K; }\n  void setOpaqueType(void *Ty) { OpaqueType = Ty; }\n\n  void *getPtr() const;\n  void setPtr(void *Ptr) { Data.m_Ptr = Ptr; }\n\n#define X(type, name)                                                          \\\n  void set##name(type Val) { Data.m_##name = Val; }                            \\\n  type get##name() const { return Data.m_##name; }\n  REPL_BUILTIN_TYPES\n#undef X\n\n  /// \\brief Get the value with cast.\n  //\n  /// Get the value cast to T. This is similar to reinterpret_cast<T>(value),\n  /// casting the value of builtins (except void), enums and pointers.\n  /// Values referencing an object are treated as pointers to the object.\n  template <typename T> T convertTo() const {\n    return convertFwd<T>::cast(*this);\n  }\n\nprotected:\n  bool isPointerOrObjectType() const { return ValueKind == K_PtrOrObj; }\n\n  /// \\brief Get to the value with type checking casting the underlying\n  /// stored value to T.\n  template <typename T> T as() const {\n    switch (ValueKind) {\n    default:\n      return T();\n#define X(type, name)                                                          \\\n  case Value::K_##name:                                                        \\\n    return (T)Data.m_##name;\n      REPL_BUILTIN_TYPES\n#undef X\n    }\n  }\n\n  // Allow convertTo to be partially specialized.\n  template <typename T> struct convertFwd {\n    static T cast(const Value &V) {\n      if (V.isPointerOrObjectType())\n        return (T)(uintptr_t)V.as<void *>();\n      if (!V.isValid() || V.isVoid()) {\n        return T();\n      }\n      return V.as<T>();\n    }\n  };\n\n  template <typename T> struct convertFwd<T *> {\n    static T *cast(const Value &V) {\n      if (V.isPointerOrObjectType())\n        return (T *)(uintptr_t)V.as<void *>();\n      return nullptr;\n    }\n  };\n\n  Interpreter *Interp = nullptr;\n  void *OpaqueType = nullptr;\n  Storage Data;\n  Kind ValueKind = K_Unspecified;\n  bool IsManuallyAlloc = false;\n};\n\ntemplate <> inline void *Value::as() const {\n  if (isPointerOrObjectType())\n    return Data.m_Ptr;\n  return (void *)as<uintptr_t>();\n}\n\n}",
  "id": "BLOCK-CPP-18525",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Interpreter/Value.h",
  "source_line": 49,
  "validation_status": "validated"
}