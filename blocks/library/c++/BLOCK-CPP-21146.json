{
  "code": "{\n\n/// Specifies the working directory and command of a compilation.\nstruct CompileCommand {\n  CompileCommand() = default;\n  CompileCommand(const Twine &Directory, const Twine &Filename,\n                 std::vector<std::string> CommandLine, const Twine &Output)\n      : Directory(Directory.str()), Filename(Filename.str()),\n        CommandLine(std::move(CommandLine)), Output(Output.str()) {}\n\n  /// The working directory the command was executed from.\n  std::string Directory;\n\n  /// The source file associated with the command.\n  std::string Filename;\n\n  /// The command line that was executed.\n  std::vector<std::string> CommandLine;\n\n  /// The output file associated with the command.\n  std::string Output;\n\n  /// If this compile command was guessed rather than read from an authoritative\n  /// source, a short human-readable explanation.\n  /// e.g. \"inferred from foo/bar.h\".\n  std::string Heuristic;\n\n  friend bool operator==(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return LHS.Directory == RHS.Directory && LHS.Filename == RHS.Filename &&\n           LHS.CommandLine == RHS.CommandLine && LHS.Output == RHS.Output &&\n           LHS.Heuristic == RHS.Heuristic;\n  }\n\n  friend bool operator!=(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n/// Interface for compilation databases.\n///\n/// A compilation database allows the user to retrieve compile command lines\n/// for the files in a project.\n///\n/// Many implementations are enumerable, allowing all command lines to be\n/// retrieved. These can be used to run clang tools over a subset of the files\n/// in a project.\nclass CompilationDatabase {\npublic:\n  virtual ~CompilationDatabase();\n\n  /// Loads a compilation database from a build directory.\n  ///\n  /// Looks at the specified 'BuildDirectory' and creates a compilation database\n  /// that allows to query compile commands for source files in the\n  /// corresponding source tree.\n  ///\n  /// Returns NULL and sets ErrorMessage if we were not able to build up a\n  /// compilation database for the build directory.\n  ///\n  /// FIXME: Currently only supports JSON compilation databases, which\n  /// are named 'compile_commands.json' in the given directory. Extend this\n  /// for other build types (like ninja build files).\n  static std::unique_ptr<CompilationDatabase>\n  loadFromDirectory(StringRef BuildDirectory, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in all parent paths of file 'SourceFile'\n  /// by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromSource(StringRef SourceFile, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in directory 'SourceDir' and all\n  /// its parent paths by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromDirectory(StringRef SourceDir, std::string &ErrorMessage);\n\n  /// Returns all compile commands in which the specified file was\n  /// compiled.\n  ///\n  /// This includes compile commands that span multiple source files.\n  /// For example, consider a project with the following compilations:\n  /// $ clang++ -o test a.cc b.cc t.cc\n  /// $ clang++ -o production a.cc b.cc -DPRODUCTION\n  /// A compilation database representing the project would return both command\n  /// lines for a.cc and b.cc and only the first command line for t.cc.\n  virtual std::vector<CompileCommand> getCompileCommands(\n      StringRef FilePath) const = 0;\n\n  /// Returns the list of all files available in the compilation database.\n  ///\n  /// By default, returns nothing. Implementations should override this if they\n  /// can enumerate their source files.\n  virtual std::vector<std::string> getAllFiles() const { return {}; }\n\n  /// Returns all compile commands for all the files in the compilation\n  /// database.\n  ///\n  /// FIXME: Add a layer in Tooling that provides an interface to run a tool\n  /// over all files in a compilation database. Not all build systems have the\n  /// ability to provide a feasible implementation for \\c getAllCompileCommands.\n  ///\n  /// By default, this is implemented in terms of getAllFiles() and\n  /// getCompileCommands(). Subclasses may override this for efficiency.\n  virtual std::vector<CompileCommand> getAllCompileCommands() const;\n};\n\n/// A compilation database that returns a single compile command line.\n///\n/// Useful when we want a tool to behave more like a compiler invocation.\n/// This compilation database is not enumerable: getAllFiles() returns {}.\nclass FixedCompilationDatabase : public CompilationDatabase {\npublic:\n  /// Creates a FixedCompilationDatabase from the arguments after \"--\".\n  ///\n  /// Parses the given command line for \"--\". If \"--\" is found, the rest of\n  /// the arguments will make up the command line in the returned\n  /// FixedCompilationDatabase.\n  /// The arguments after \"--\" must not include positional parameters or the\n  /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase\n  /// when a CompileCommand is requested. The argv[0] of the returned command\n  /// line will be \"clang-tool\".\n  ///\n  /// Returns NULL in case \"--\" is not found.\n  ///\n  /// The argument list is meant to be compatible with normal llvm command line\n  /// parsing in main methods.\n  /// int main(int argc, char **argv) {\n  ///   std::unique_ptr<FixedCompilationDatabase> Compilations(\n  ///     FixedCompilationDatabase::loadFromCommandLine(argc, argv));\n  ///   cl::ParseCommandLineOptions(argc, argv);\n  ///   ...\n  /// }\n  ///\n  /// \\param Argc The number of command line arguments - will be changed to\n  /// the number of arguments before \"--\", if \"--\" was found in the argument\n  /// list.\n  /// \\param Argv Points to the command line arguments.\n  /// \\param ErrorMsg Contains error text if the function returns null pointer.\n  /// \\param Directory The base directory used in the FixedCompilationDatabase.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromCommandLine(int &Argc, const char *const *Argv, std::string &ErrorMsg,\n                      const Twine &Directory = \".\");\n\n  /// Reads flags from the given file, one-per-line.\n  /// Returns nullptr and sets ErrorMessage if we can't read the file.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromFile(StringRef Path, std::string &ErrorMsg);\n\n  /// Reads flags from the given buffer, one-per-line.\n  /// Directory is the command CWD, typically the parent of compile_flags.txt.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromBuffer(StringRef Directory, StringRef Data, std::string &ErrorMsg);\n\n  /// Constructs a compilation data base from a specified directory\n  /// and command line.\n  FixedCompilationDatabase(const Twine &Directory,\n                           ArrayRef<std::string> CommandLine);\n\n  /// Returns the given compile command.\n  ///\n  /// Will always return a vector with one entry that contains the directory\n  /// and command line specified at construction with \"clang-tool\" as argv[0]\n  /// and 'FilePath' as positional argument.\n  std::vector<CompileCommand>\n  getCompileCommands(StringRef FilePath) const override;\n\nprivate:\n  /// This is built up to contain a single entry vector to be returned from\n  /// getCompileCommands after adding the positional argument.\n  std::vector<CompileCommand> CompileCommands;\n};\n\n/// Transforms a compile command so that it applies the same configuration to\n/// a different file. Most args are left intact, but tweaks may be needed\n/// to certain flags (-x, -std etc).\n///\n/// The output command will always end in {\"--\", Filename}.\ntooling::CompileCommand transferCompileCommand(tooling::CompileCommand,\n                                               StringRef Filename);\n\n/// Returns a wrapped CompilationDatabase that defers to the provided one,\n/// but getCompileCommands() will infer commands for unknown files.\n/// The return value of getAllFiles() or getAllCompileCommands() is unchanged.\n/// See InterpolatingCompilationDatabase.cpp for details on heuristics.\nstd::unique_ptr<CompilationDatabase>\n    inferMissingCompileCommands(std::unique_ptr<CompilationDatabase>);\n\n/// Returns a wrapped CompilationDatabase that will add -target and -mode flags\n/// to commandline when they can be deduced from argv[0] of commandline returned\n/// by underlying database.\nstd::unique_ptr<CompilationDatabase>\ninferTargetAndDriverMode(std::unique_ptr<CompilationDatabase> Base);\n\n/// Returns a wrapped CompilationDatabase that will expand all rsp(response)\n/// files on commandline returned by underlying database.\nstd::unique_ptr<CompilationDatabase>\nexpandResponseFiles(std::unique_ptr<CompilationDatabase> Base,\n                    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS);\n\n}",
  "id": "BLOCK-CPP-21146",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/CompilationDatabase.h",
  "source_line": 41,
  "validation_status": "validated"
}