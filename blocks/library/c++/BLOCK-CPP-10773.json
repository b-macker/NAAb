{
  "code": "{\n  friend class ASTStmtReader;\n\n  /// The rewritten semantic form.\n  Stmt *SemanticForm;\n\npublic:\n  CXXRewrittenBinaryOperator(Expr *SemanticForm, bool IsReversed)\n      : Expr(CXXRewrittenBinaryOperatorClass, SemanticForm->getType(),\n             SemanticForm->getValueKind(), SemanticForm->getObjectKind()),\n        SemanticForm(SemanticForm) {\n    CXXRewrittenBinaryOperatorBits.IsReversed = IsReversed;\n    setDependence(computeDependence(this));\n  }\n  CXXRewrittenBinaryOperator(EmptyShell Empty)\n      : Expr(CXXRewrittenBinaryOperatorClass, Empty), SemanticForm() {}\n\n  /// Get an equivalent semantic form for this expression.\n  Expr *getSemanticForm() { return cast<Expr>(SemanticForm); }\n  const Expr *getSemanticForm() const { return cast<Expr>(SemanticForm); }\n\n  struct DecomposedForm {\n    /// The original opcode, prior to rewriting.\n    BinaryOperatorKind Opcode;\n    /// The original left-hand side.\n    const Expr *LHS;\n    /// The original right-hand side.\n    const Expr *RHS;\n    /// The inner \\c == or \\c <=> operator expression.\n    const Expr *InnerBinOp;\n  };\n\n  /// Decompose this operator into its syntactic form.\n  DecomposedForm getDecomposedForm() const LLVM_READONLY;\n\n  /// Determine whether this expression was rewritten in reverse form.\n  bool isReversed() const { return CXXRewrittenBinaryOperatorBits.IsReversed; }\n\n  BinaryOperatorKind getOperator() const { return getDecomposedForm().Opcode; }\n  BinaryOperatorKind getOpcode() const { return getOperator(); }\n  static StringRef getOpcodeStr(BinaryOperatorKind Op) {\n    return BinaryOperator::getOpcodeStr(Op);\n  }\n  StringRef getOpcodeStr() const {\n    return BinaryOperator::getOpcodeStr(getOpcode());\n  }\n  bool isComparisonOp() const { return true; }\n  bool isAssignmentOp() const { return false; }\n\n  const Expr *getLHS() const { return getDecomposedForm().LHS; }\n  const Expr *getRHS() const { return getDecomposedForm().RHS; }\n\n  SourceLocation getOperatorLoc() const LLVM_READONLY {\n    return getDecomposedForm().InnerBinOp->getExprLoc();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY { return getOperatorLoc(); }\n\n  /// Compute the begin and end locations from the decomposed form.\n  /// The locations of the semantic form are not reliable if this is\n  /// a reversed expression.\n  //@{\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getDecomposedForm().LHS->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getDecomposedForm().RHS->getEndLoc();\n  }\n  SourceRange getSourceRange() const LLVM_READONLY {\n    DecomposedForm DF = getDecomposedForm();\n    return SourceRange(DF.LHS->getBeginLoc(), DF.RHS->getEndLoc());\n  }\n  //@}\n\n  child_range children() {\n    return child_range(&SemanticForm, &SemanticForm + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXRewrittenBinaryOperatorClass;\n  }\n}",
  "id": "BLOCK-CPP-10773",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 283,
  "validation_status": "validated"
}