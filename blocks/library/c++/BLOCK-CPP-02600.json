{
  "code": "#include \"absl/debugging/internal/examine_stack.h\"\n#include <unistd.h>\n#include \"absl/base/config.h\"\n#include <sys/mman.h>\n#include <sys/ucontext.h>\n#include <csignal>\n#include <cstdio>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/debugging/stacktrace.h\"\n#include \"absl/debugging/symbolize.h\"\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02600_execute() {\n    {\n  if (pc != nullptr) {\n    // We don't know the stack frame size for PC, use 0.\n    if (symbolize_stacktrace) {\n      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, pc, pc, 0, \"PC: \");\n    } else {\n      DumpPCAndFrameSize(writer, writer_arg, pc, 0, \"PC: \");\n    }\n  }\n  for (int i = 0; i < depth; i++) {\n    if (symbolize_stacktrace) {\n      // Pass the previous address of pc as the symbol address because pc is a\n      // return address, and an overrun may occur when the function ends with a\n      // call to a function annotated noreturn (e.g. CHECK). Note that we don't\n      // do this for pc above, as the adjustment is only correct for return\n      // addresses.\n      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, stack[i],\n                                  reinterpret_cast<char*>(stack[i]) - 1,\n                                  frame_sizes[i], \"    \");\n    } else {\n      DumpPCAndFrameSize(writer, writer_arg, stack[i], frame_sizes[i], \"    \");\n    }\n  }\n  if (min_dropped_frames > 0) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"    @ ... and at least %d more frames\\n\",\n             min_dropped_frames);\n    writer(buf, writer_arg);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02600",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/examine_stack.cc",
  "source_line": 239,
  "validation_status": "validated"
}