{
  "code": "{\n\nclass NamedDecl;\n\n/// The iterator over UnresolvedSets.  Serves as both the const and\n/// non-const iterator.\nclass UnresolvedSetIterator : public llvm::iterator_adaptor_base<\n                                  UnresolvedSetIterator, DeclAccessPair *,\n                                  std::random_access_iterator_tag, NamedDecl *,\n                                  std::ptrdiff_t, NamedDecl *, NamedDecl *> {\n  friend class ASTUnresolvedSet;\n  friend class OverloadExpr;\n  friend class UnresolvedSetImpl;\n\n  explicit UnresolvedSetIterator(DeclAccessPair *Iter)\n      : iterator_adaptor_base(Iter) {}\n  explicit UnresolvedSetIterator(const DeclAccessPair *Iter)\n      : iterator_adaptor_base(const_cast<DeclAccessPair *>(Iter)) {}\n\npublic:\n  // Work around a bug in MSVC 2013 where explicitly default constructed\n  // temporaries with defaulted ctors are not zero initialized.\n  UnresolvedSetIterator() : iterator_adaptor_base(nullptr) {}\n\n  NamedDecl *getDecl() const { return I->getDecl(); }\n  void setDecl(NamedDecl *ND) const { return I->setDecl(ND); }\n  AccessSpecifier getAccess() const { return I->getAccess(); }\n  void setAccess(AccessSpecifier AS) { I->setAccess(AS); }\n  const DeclAccessPair &getPair() const { return *I; }\n\n  NamedDecl *operator*() const { return getDecl(); }\n  NamedDecl *operator->() const { return **this; }\n};\n\n/// A set of unresolved declarations.\nclass UnresolvedSetImpl {\n  using DeclsTy = SmallVectorImpl<DeclAccessPair>;\n\n  // Don't allow direct construction, and only permit subclassing by\n  // UnresolvedSet.\nprivate:\n  template <unsigned N> friend class UnresolvedSet;\n\n  UnresolvedSetImpl() = default;\n  UnresolvedSetImpl(const UnresolvedSetImpl &) = default;\n  UnresolvedSetImpl &operator=(const UnresolvedSetImpl &) = default;\n\n  // FIXME: Switch these to \"= default\" once MSVC supports generating move ops\n  UnresolvedSetImpl(UnresolvedSetImpl &&) {}\n  UnresolvedSetImpl &operator=(UnresolvedSetImpl &&) { return *this; }\n\npublic:\n  // We don't currently support assignment through this iterator, so we might\n  // as well use the same implementation twice.\n  using iterator = UnresolvedSetIterator;\n  using const_iterator = UnresolvedSetIterator;\n\n  iterator begin() { return iterator(decls().begin()); }\n  iterator end() { return iterator(decls().end()); }\n\n  const_iterator begin() const { return const_iterator(decls().begin()); }\n  const_iterator end() const { return const_iterator(decls().end()); }\n\n  ArrayRef<DeclAccessPair> pairs() const { return decls(); }\n\n  void addDecl(NamedDecl *D) {\n    addDecl(D, AS_none);\n  }\n\n  void addDecl(NamedDecl *D, AccessSpecifier AS) {\n    decls().push_back(DeclAccessPair::make(D, AS));\n  }\n\n  /// Replaces the given declaration with the new one, once.\n  ///\n  /// \\return true if the set changed\n  bool replace(const NamedDecl* Old, NamedDecl *New) {\n    for (DeclsTy::iterator I = decls().begin(), E = decls().end(); I != E; ++I)\n      if (I->getDecl() == Old)\n        return (I->setDecl(New), true);\n    return false;\n  }\n\n  /// Replaces the declaration at the given iterator with the new one,\n  /// preserving the original access bits.\n  void replace(iterator I, NamedDecl *New) { I.I->setDecl(New); }\n\n  void replace(iterator I, NamedDecl *New, AccessSpecifier AS) {\n    I.I->set(New, AS);\n  }\n\n  void erase(unsigned I) {\n    auto val = decls().pop_back_val();\n    if (I < size())\n      decls()[I] = val;\n  }\n\n  void erase(iterator I) {\n    auto val = decls().pop_back_val();\n    if (I != end())\n      *I.I = val;\n  }\n\n  void setAccess(iterator I, AccessSpecifier AS) { I.I->setAccess(AS); }\n\n  void clear() { decls().clear(); }\n  void truncate(unsigned N) { decls().truncate(N); }\n\n  bool empty() const { return decls().empty(); }\n  unsigned size() const { return decls().size(); }\n\n  void append(iterator I, iterator E) { decls().append(I.I, E.I); }\n\n  template<typename Iter> void assign(Iter I, Iter E) { decls().assign(I, E); }\n\n  DeclAccessPair &operator[](unsigned I) { return decls()[I]; }\n  const DeclAccessPair &operator[](unsigned I) const { return decls()[I]; }\n\nprivate:\n  // These work because the only permitted subclass is UnresolvedSetImpl\n\n  DeclsTy &decls() {\n    return *reinterpret_cast<DeclsTy*>(this);\n  }\n  const DeclsTy &decls() const {\n    return *reinterpret_cast<const DeclsTy*>(this);\n  }\n};\n\n/// A set of unresolved declarations.\ntemplate <unsigned InlineCapacity> class UnresolvedSet :\n    public UnresolvedSetImpl {\n  SmallVector<DeclAccessPair, InlineCapacity> Decls;\n};\n\n\n}",
  "id": "BLOCK-CPP-14611",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/UnresolvedSet.h",
  "source_line": 26,
  "validation_status": "validated"
}