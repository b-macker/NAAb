{
  "code": "#include \"clang/AST/Decl.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/Interpreter/PartialTranslationUnit.h\"\n#include \"clang/Interpreter/Value.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ExecutionEngine/JITSymbol.h\"\n#include \"llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h\"\n#include \"llvm/Support/Error.h\"\n#include <memory>\n#include <vector>\n\nusing namespace llvm;\nusing namespace orc;\nusing namespace orc;\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18504_execute() {\n    {\n  std::unique_ptr<llvm::orc::ThreadSafeContext> TSCtx;\n  std::unique_ptr<IncrementalParser> IncrParser;\n  std::unique_ptr<IncrementalExecutor> IncrExecutor;\n\n  // An optional parser for CUDA offloading\n  std::unique_ptr<IncrementalParser> DeviceParser;\n\n  Interpreter(std::unique_ptr<CompilerInstance> CI, llvm::Error &Err);\n\n  llvm::Error CreateExecutor();\n  unsigned InitPTUSize = 0;\n\n  // This member holds the last result of the value printing. It's a class\n  // member because we might want to access it after more inputs. If no value\n  // printing happens, it's in an invalid state.\n  Value LastValue;\n\npublic:\n  ~Interpreter();\n  static llvm::Expected<std::unique_ptr<Interpreter>>\n  create(std::unique_ptr<CompilerInstance> CI);\n  static llvm::Expected<std::unique_ptr<Interpreter>>\n  createWithCUDA(std::unique_ptr<CompilerInstance> CI,\n                 std::unique_ptr<CompilerInstance> DCI);\n  const ASTContext &getASTContext() const;\n  ASTContext &getASTContext();\n  const CompilerInstance *getCompilerInstance() const;\n  llvm::Expected<llvm::orc::LLJIT &> getExecutionEngine();\n\n  llvm::Expected<PartialTranslationUnit &> Parse(llvm::StringRef Code);\n  llvm::Error Execute(PartialTranslationUnit &T);\n  llvm::Error ParseAndExecute(llvm::StringRef Code, Value *V = nullptr);\n  llvm::Expected<llvm::orc::ExecutorAddr> CompileDtorCall(CXXRecordDecl *CXXRD);\n\n  /// Undo N previous incremental inputs.\n  llvm::Error Undo(unsigned N = 1);\n\n  /// Link a dynamic library\n  llvm::Error LoadDynamicLibrary(const char *name);\n\n  /// \\returns the \\c ExecutorAddr of a \\c GlobalDecl. This interface uses\n  /// the CodeGenModule's internal mangling cache to avoid recomputing the\n  /// mangled name.\n  llvm::Expected<llvm::orc::ExecutorAddr> getSymbolAddress(GlobalDecl GD) const;\n\n  /// \\returns the \\c ExecutorAddr of a given name as written in the IR.\n  llvm::Expected<llvm::orc::ExecutorAddr>\n  getSymbolAddress(llvm::StringRef IRName) const;\n\n  /// \\returns the \\c ExecutorAddr of a given name as written in the object\n  /// file.\n  llvm::Expected<llvm::orc::ExecutorAddr>\n  getSymbolAddressFromLinkerName(llvm::StringRef LinkerName) const;\n\n  enum InterfaceKind { NoAlloc, WithAlloc, CopyArray };\n\n  const llvm::SmallVectorImpl<Expr *> &getValuePrintingInfo() const {\n    return ValuePrintingInfo;\n  }\n\n  Expr *SynthesizeExpr(Expr *E);\n\nprivate:\n  size_t getEffectivePTUSize() const;\n\n  bool FindRuntimeInterface();\n\n  llvm::DenseMap<CXXRecordDecl *, llvm::orc::ExecutorAddr> Dtors;\n\n  llvm::SmallVector<Expr *, 3> ValuePrintingInfo;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18504",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Interpreter/Interpreter.h",
  "source_line": 76,
  "validation_status": "validated"
}