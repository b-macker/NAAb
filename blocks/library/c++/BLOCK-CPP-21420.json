{
  "code": "{\n\nclass BeforeSet;\n\n/// This enum distinguishes between different kinds of operations that may\n/// need to be protected by locks. We use this enum in error handling.\nenum ProtectedOperationKind {\n  /// Dereferencing a variable (e.g. p in *p = 5;)\n  POK_VarDereference,\n\n  /// Reading or writing a variable (e.g. x in x = 5;)\n  POK_VarAccess,\n\n  /// Making a function call (e.g. fool())\n  POK_FunctionCall,\n\n  /// Passing a guarded variable by reference.\n  POK_PassByRef,\n\n  /// Passing a pt-guarded variable by reference.\n  POK_PtPassByRef\n};\n\n/// This enum distinguishes between different kinds of lock actions. For\n/// example, it is an error to write a variable protected by shared version of a\n/// mutex.\nenum LockKind {\n  /// Shared/reader lock of a mutex.\n  LK_Shared,\n\n  /// Exclusive/writer lock of a mutex.\n  LK_Exclusive,\n\n  /// Can be either Shared or Exclusive.\n  LK_Generic\n};\n\n/// This enum distinguishes between different ways to access (read or write) a\n/// variable.\nenum AccessKind {\n  /// Reading a variable.\n  AK_Read,\n\n  /// Writing a variable.\n  AK_Written\n};\n\n/// This enum distinguishes between different situations where we warn due to\n/// inconsistent locking.\n/// \\enum SK_LockedSomeLoopIterations -- a mutex is locked for some but not all\n/// loop iterations.\n/// \\enum SK_LockedSomePredecessors -- a mutex is locked in some but not all\n/// predecessors of a CFGBlock.\n/// \\enum SK_LockedAtEndOfFunction -- a mutex is still locked at the end of a\n/// function.\nenum LockErrorKind {\n  LEK_LockedSomeLoopIterations,\n  LEK_LockedSomePredecessors,\n  LEK_LockedAtEndOfFunction,\n  LEK_NotLockedAtEndOfFunction\n};\n\n/// Handler class for thread safety warnings.\nclass ThreadSafetyHandler {\npublic:\n  using Name = StringRef;\n\n  ThreadSafetyHandler() = default;\n  virtual ~ThreadSafetyHandler();\n\n  /// Warn about lock expressions which fail to resolve to lockable objects.\n  /// \\param Loc -- the SourceLocation of the unresolved expression.\n  virtual void handleInvalidLockExp(SourceLocation Loc) {}\n\n  /// Warn about unlock function calls that do not have a prior matching lock\n  /// expression.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc -- The SourceLocation of the Unlock\n  /// \\param LocPreviousUnlock -- If valid, the location of a previous Unlock.\n  virtual void handleUnmatchedUnlock(StringRef Kind, Name LockName,\n                                     SourceLocation Loc,\n                                     SourceLocation LocPreviousUnlock) {}\n\n  /// Warn about an unlock function call that attempts to unlock a lock with\n  /// the incorrect lock kind. For instance, a shared lock being unlocked\n  /// exclusively, or vice versa.\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param Expected -- the kind of lock expected.\n  /// \\param Received -- the kind of lock received.\n  /// \\param LocLocked -- The SourceLocation of the Lock.\n  /// \\param LocUnlock -- The SourceLocation of the Unlock.\n  virtual void handleIncorrectUnlockKind(StringRef Kind, Name LockName,\n                                         LockKind Expected, LockKind Received,\n                                         SourceLocation LocLocked,\n                                         SourceLocation LocUnlock) {}\n\n  /// Warn about lock function calls for locks which are already held.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LocLocked -- The location of the first lock expression.\n  /// \\param LocDoubleLock -- The location of the second lock expression.\n  virtual void handleDoubleLock(StringRef Kind, Name LockName,\n                                SourceLocation LocLocked,\n                                SourceLocation LocDoubleLock) {}\n\n  /// Warn about situations where a mutex is sometimes held and sometimes not.\n  /// The three situations are:\n  /// 1. a mutex is locked on an \"if\" branch but not the \"else\" branch,\n  /// 2, or a mutex is only held at the start of some loop iterations,\n  /// 3. or when a mutex is locked but not unlocked inside a function.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LocLocked -- The location of the lock expression where the mutex is\n  ///               locked\n  /// \\param LocEndOfScope -- The location of the end of the scope where the\n  ///               mutex is no longer held\n  /// \\param LEK -- which of the three above cases we should warn for\n  virtual void handleMutexHeldEndOfScope(StringRef Kind, Name LockName,\n                                         SourceLocation LocLocked,\n                                         SourceLocation LocEndOfScope,\n                                         LockErrorKind LEK) {}\n\n  /// Warn when a mutex is held exclusively and shared at the same point. For\n  /// example, if a mutex is locked exclusively during an if branch and shared\n  /// during the else branch.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc1 -- The location of the first lock expression.\n  /// \\param Loc2 -- The location of the second lock expression.\n  virtual void handleExclusiveAndShared(StringRef Kind, Name LockName,\n                                        SourceLocation Loc1,\n                                        SourceLocation Loc2) {}\n\n  /// Warn when a protected operation occurs while no locks are held.\n  /// \\param D -- The decl for the protected variable or function\n  /// \\param POK -- The kind of protected operation (e.g. variable access)\n  /// \\param AK -- The kind of access (i.e. read or write) that occurred\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNoMutexHeld(const NamedDecl *D, ProtectedOperationKind POK,\n                                 AccessKind AK, SourceLocation Loc) {}\n\n  /// Warn when a protected operation occurs while the specific mutex protecting\n  /// the operation is not locked.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param D -- The decl for the protected variable or function\n  /// \\param POK -- The kind of protected operation (e.g. variable access)\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LK -- The kind of access (i.e. read or write) that occurred\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleMutexNotHeld(StringRef Kind, const NamedDecl *D,\n                                  ProtectedOperationKind POK, Name LockName,\n                                  LockKind LK, SourceLocation Loc,\n                                  Name *PossibleMatch = nullptr) {}\n\n  /// Warn when acquiring a lock that the negative capability is not held.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- The name for the lock expression, to be printed in the\n  /// diagnostic.\n  /// \\param Neg -- The name of the negative capability to be printed in the\n  /// diagnostic.\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNegativeNotHeld(StringRef Kind, Name LockName, Name Neg,\n                                     SourceLocation Loc) {}\n\n  /// Warn when calling a function that a negative capability is not held.\n  /// \\param D -- The decl for the function requiring the negative capability.\n  /// \\param LockName -- The name for the lock expression, to be printed in the\n  /// diagnostic.\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNegativeNotHeld(const NamedDecl *D, Name LockName,\n                                     SourceLocation Loc) {}\n\n  /// Warn when a function is called while an excluded mutex is locked. For\n  /// example, the mutex may be locked inside the function.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param FunName -- The name of the function\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc -- The location of the function call.\n  virtual void handleFunExcludesLock(StringRef Kind, Name FunName,\n                                     Name LockName, SourceLocation Loc) {}\n\n  /// Warn that L1 cannot be acquired before L2.\n  virtual void handleLockAcquiredBefore(StringRef Kind, Name L1Name,\n                                        Name L2Name, SourceLocation Loc) {}\n\n  /// Warn that there is a cycle in acquired_before/after dependencies.\n  virtual void handleBeforeAfterCycle(Name L1Name, SourceLocation Loc) {}\n\n  /// Called by the analysis when starting analysis of a function.\n  /// Used to issue suggestions for changes to annotations.\n  virtual void enterFunction(const FunctionDecl *FD) {}\n\n  /// Called by the analysis when finishing analysis of a function.\n  virtual void leaveFunction(const FunctionDecl *FD) {}\n\n  bool issueBetaWarnings() { return IssueBetaWarnings; }\n  void setIssueBetaWarnings(bool b) { IssueBetaWarnings = b; }\n\nprivate:\n  bool IssueBetaWarnings = false;\n};\n\n/// Check a function's CFG for thread-safety violations.\n///\n/// We traverse the blocks in the CFG, compute the set of mutexes that are held\n/// at the end of each block, and issue warnings for thread safety violations.\n/// Each block in the CFG is traversed exactly once.\nvoid runThreadSafetyAnalysis(AnalysisDeclContext &AC,\n                             ThreadSafetyHandler &Handler,\n                             BeforeSet **Bset);\n\nvoid threadSafetyCleanup(BeforeSet *Cache);\n\n/// Helper function that returns a LockKind required for the given level\n/// of access.\nLockKind getLockKindFromAccessKind(AccessKind AK);\n\n}",
  "id": "BLOCK-CPP-21420",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafety.h",
  "source_line": 30,
  "validation_status": "validated"
}