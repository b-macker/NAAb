{
  "code": "{\n  DeclaratorChunk() {};\n\n  enum {\n    Pointer, Reference, Array, Function, BlockPointer, MemberPointer, Paren, Pipe\n  } Kind;\n\n  /// Loc - The place where this type was defined.\n  SourceLocation Loc;\n  /// EndLoc - If valid, the place where this chunck ends.\n  SourceLocation EndLoc;\n\n  SourceRange getSourceRange() const {\n    if (EndLoc.isInvalid())\n      return SourceRange(Loc, Loc);\n    return SourceRange(Loc, EndLoc);\n  }\n\n  ParsedAttributesView AttrList;\n\n  struct PointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/unaligned/atomic.\n    unsigned TypeQuals : 5;\n\n    /// The location of the const-qualifier, if any.\n    SourceLocation ConstQualLoc;\n\n    /// The location of the volatile-qualifier, if any.\n    SourceLocation VolatileQualLoc;\n\n    /// The location of the restrict-qualifier, if any.\n    SourceLocation RestrictQualLoc;\n\n    /// The location of the _Atomic-qualifier, if any.\n    SourceLocation AtomicQualLoc;\n\n    /// The location of the __unaligned-qualifier, if any.\n    SourceLocation UnalignedQualLoc;\n\n    void destroy() {\n    }\n  };\n\n  struct ReferenceTypeInfo {\n    /// The type qualifier: restrict. [GNU] C++ extension\n    bool HasRestrict : 1;\n    /// True if this is an lvalue reference, false if it's an rvalue reference.\n    bool LValueRef : 1;\n    void destroy() {\n    }\n  };\n\n  struct ArrayTypeInfo {\n    /// The type qualifiers for the array:\n    /// const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    /// True if this dimension included the 'static' keyword.\n    unsigned hasStatic : 1;\n\n    /// True if this dimension was [*].  In this case, NumElts is null.\n    unsigned isStar : 1;\n\n    /// This is the size of the array, or null if [] or [*] was specified.\n    /// Since the parser is multi-purpose, and we don't want to impose a root\n    /// expression class on all clients, NumElts is untyped.\n    Expr *NumElts;\n\n    void destroy() {}\n  };\n\n  /// ParamInfo - An array of paraminfo objects is allocated whenever a function\n  /// declarator is parsed.  There are two interesting styles of parameters\n  /// here:\n  /// K&R-style identifier lists and parameter type lists.  K&R-style identifier\n  /// lists will have information about the identifier, but no type information.\n  /// Parameter type lists will have type info (if the actions module provides\n  /// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.\n  struct ParamInfo {\n    IdentifierInfo *Ident;\n    SourceLocation IdentLoc;\n    Decl *Param;\n\n    /// DefaultArgTokens - When the parameter's default argument\n    /// cannot be parsed immediately (because it occurs within the\n    /// declaration of a member function), it will be stored here as a\n    /// sequence of tokens to be parsed once the class definition is\n    /// complete. Non-NULL indicates that there is a default argument.\n    std::unique_ptr<CachedTokens> DefaultArgTokens;\n\n    ParamInfo() = default;\n    ParamInfo(IdentifierInfo *ident, SourceLocation iloc,\n              Decl *param,\n              std::unique_ptr<CachedTokens> DefArgTokens = nullptr)\n      : Ident(ident), IdentLoc(iloc), Param(param),\n        DefaultArgTokens(std::move(DefArgTokens)) {}\n  };\n\n  struct TypeAndRange {\n    ParsedType Ty;\n    SourceRange Range;\n  };\n\n  struct FunctionTypeInfo {\n    /// hasPrototype - This is true if the function had at least one typed\n    /// parameter.  If the function is () or (a,b,c), then it has no prototype,\n    /// and is treated as a K&R-style function.\n    unsigned hasPrototype : 1;\n\n    /// isVariadic - If this function has a prototype, and if that\n    /// proto ends with ',...)', this is true. When true, EllipsisLoc\n    /// contains the location of the ellipsis.\n    unsigned isVariadic : 1;\n\n    /// Can this declaration be a constructor-style initializer?\n    unsigned isAmbiguous : 1;\n\n    /// Whether the ref-qualifier (if any) is an lvalue reference.\n    /// Otherwise, it's an rvalue reference.\n    unsigned RefQualifierIsLValueRef : 1;\n\n    /// ExceptionSpecType - An ExceptionSpecificationType value.\n    unsigned ExceptionSpecType : 4;\n\n    /// DeleteParams - If this is true, we need to delete[] Params.\n    unsigned DeleteParams : 1;\n\n    /// HasTrailingReturnType - If this is true, a trailing return type was\n    /// specified.\n    unsigned HasTrailingReturnType : 1;\n\n    /// The location of the left parenthesis in the source.\n    SourceLocation LParenLoc;\n\n    /// When isVariadic is true, the location of the ellipsis in the source.\n    SourceLocation EllipsisLoc;\n\n    /// The location of the right parenthesis in the source.\n    SourceLocation RParenLoc;\n\n    /// NumParams - This is the number of formal parameters specified by the\n    /// declarator.\n    unsigned NumParams;\n\n    /// NumExceptionsOrDecls - This is the number of types in the\n    /// dynamic-exception-decl, if the function has one. In C, this is the\n    /// number of declarations in the function prototype.\n    unsigned NumExceptionsOrDecls;\n\n    /// The location of the ref-qualifier, if any.\n    ///\n    /// If this is an invalid location, there is no ref-qualifier.\n    SourceLocation RefQualifierLoc;\n\n    /// The location of the 'mutable' qualifer in a lambda-declarator, if\n    /// any.\n    SourceLocation MutableLoc;\n\n    /// The beginning location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocBeg;\n\n    /// The end location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocEnd;\n\n    /// Params - This is a pointer to a new[]'d array of ParamInfo objects that\n    /// describe the parameters specified by this function declarator.  null if\n    /// there are no parameters specified.\n    ParamInfo *Params;\n\n    /// DeclSpec for the function with the qualifier related info.\n    DeclSpec *MethodQualifiers;\n\n    /// AttributeFactory for the MethodQualifiers.\n    AttributeFactory *QualAttrFactory;\n\n    union {\n      /// Pointer to a new[]'d array of TypeAndRange objects that\n      /// contain the types in the function's dynamic exception specification\n      /// and their locations, if there is one.\n      TypeAndRange *Exceptions;\n\n      /// Pointer to the expression in the noexcept-specifier of this\n      /// function, if it has one.\n      Expr *NoexceptExpr;\n\n      /// Pointer to the cached tokens for an exception-specification\n      /// that has not yet been parsed.\n      CachedTokens *ExceptionSpecTokens;\n\n      /// Pointer to a new[]'d array of declarations that need to be available\n      /// for lookup inside the function body, if one exists. Does not exist in\n      /// C++.\n      NamedDecl **DeclsInPrototype;\n    };\n\n    /// If HasTrailingReturnType is true, this is the trailing return\n    /// type specified.\n    UnionParsedType TrailingReturnType;\n\n    /// If HasTrailingReturnType is true, this is the location of the trailing\n    /// return type.\n    SourceLocation TrailingReturnTypeLoc;\n\n    /// Reset the parameter list to having zero parameters.\n    ///\n    /// This is used in various places for error recovery.\n    void freeParams() {\n      for (unsigned I = 0; I < NumParams; ++I)\n        Params[I].DefaultArgTokens.reset();\n      if (DeleteParams) {\n        delete[] Params;\n        DeleteParams = false;\n      }\n      NumParams = 0;\n    }\n\n    void destroy() {\n      freeParams();\n      delete QualAttrFactory;\n      delete MethodQualifiers;\n      switch (getExceptionSpecType()) {\n      default:\n        break;\n      case EST_Dynamic:\n        delete[] Exceptions;\n        break;\n      case EST_Unparsed:\n        delete ExceptionSpecTokens;\n        break;\n      case EST_None:\n        if (NumExceptionsOrDecls != 0)\n          delete[] DeclsInPrototype;\n        break;\n      }\n    }\n\n    DeclSpec &getOrCreateMethodQualifiers() {\n      if (!MethodQualifiers) {\n        QualAttrFactory = new AttributeFactory();\n        MethodQualifiers = new DeclSpec(*QualAttrFactory);\n      }\n      return *MethodQualifiers;\n    }\n\n    /// isKNRPrototype - Return true if this is a K&R style identifier list,\n    /// like \"void foo(a,b,c)\".  In a function definition, this will be followed\n    /// by the parameter type definitions.\n    bool isKNRPrototype() const { return !hasPrototype && NumParams != 0; }\n\n    SourceLocation getLParenLoc() const { return LParenLoc; }\n\n    SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n    SourceLocation getRParenLoc() const { return RParenLoc; }\n\n    SourceLocation getExceptionSpecLocBeg() const {\n      return ExceptionSpecLocBeg;\n    }\n\n    SourceLocation getExceptionSpecLocEnd() const {\n      return ExceptionSpecLocEnd;\n    }\n\n    SourceRange getExceptionSpecRange() const {\n      return SourceRange(getExceptionSpecLocBeg(), getExceptionSpecLocEnd());\n    }\n\n    /// Retrieve the location of the ref-qualifier, if any.\n    SourceLocation getRefQualifierLoc() const { return RefQualifierLoc; }\n\n    /// Retrieve the location of the 'const' qualifier.\n    SourceLocation getConstQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getConstSpecLoc();\n    }\n\n    /// Retrieve the location of the 'volatile' qualifier.\n    SourceLocation getVolatileQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getVolatileSpecLoc();\n    }\n\n    /// Retrieve the location of the 'restrict' qualifier.\n    SourceLocation getRestrictQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getRestrictSpecLoc();\n    }\n\n    /// Retrieve the location of the 'mutable' qualifier, if any.\n    SourceLocation getMutableLoc() const { return MutableLoc; }\n\n    /// Determine whether this function declaration contains a\n    /// ref-qualifier.\n    bool hasRefQualifier() const { return getRefQualifierLoc().isValid(); }\n\n    /// Determine whether this lambda-declarator contains a 'mutable'\n    /// qualifier.\n    bool hasMutableQualifier() const { return getMutableLoc().isValid(); }\n\n    /// Determine whether this method has qualifiers.\n    bool hasMethodTypeQualifiers() const {\n      return MethodQualifiers && (MethodQualifiers->getTypeQualifiers() ||\n                                  MethodQualifiers->getAttributes().size());\n    }\n\n    /// Get the type of exception specification this function has.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      return static_cast<ExceptionSpecificationType>(ExceptionSpecType);\n    }\n\n    /// Get the number of dynamic exception specifications.\n    unsigned getNumExceptions() const {\n      assert(ExceptionSpecType != EST_None);\n      return NumExceptionsOrDecls;\n    }\n\n    /// Get the non-parameter decls defined within this function\n    /// prototype. Typically these are tag declarations.\n    ArrayRef<NamedDecl *> getDeclsInPrototype() const {\n      assert(ExceptionSpecType == EST_None);\n      return llvm::ArrayRef(DeclsInPrototype, NumExceptionsOrDecls);\n    }\n\n    /// Determine whether this function declarator had a\n    /// trailing-return-type.\n    bool hasTrailingReturnType() const { return HasTrailingReturnType; }\n\n    /// Get the trailing-return-type for this function declarator.\n    ParsedType getTrailingReturnType() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnType;\n    }\n\n    /// Get the trailing-return-type location for this function declarator.\n    SourceLocation getTrailingReturnTypeLoc() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnTypeLoc;\n    }\n  };\n\n  struct BlockPointerTypeInfo {\n    /// For now, sema will catch these as invalid.\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    void destroy() {\n    }\n  };\n\n  struct MemberPointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n    /// Location of the '*' token.\n    SourceLocation StarLoc;\n    // CXXScopeSpec has a constructor, so it can't be a direct member.\n    // So we need some pointer-aligned storage and a bit of trickery.\n    alignas(CXXScopeSpec) char ScopeMem[sizeof(CXXScopeSpec)];\n    CXXScopeSpec &Scope() {\n      return *reinterpret_cast<CXXScopeSpec *>(ScopeMem);\n    }\n    const CXXScopeSpec &Scope() const {\n      return *reinterpret_cast<const CXXScopeSpec *>(ScopeMem);\n    }\n    void destroy() {\n      Scope().~CXXScopeSpec();\n    }\n  };\n\n  struct PipeTypeInfo {\n    /// The access writes.\n    unsigned AccessWrites : 3;\n\n    void destroy() {}\n  };\n\n  union {\n    PointerTypeInfo       Ptr;\n    ReferenceTypeInfo     Ref;\n    ArrayTypeInfo         Arr;\n    FunctionTypeInfo      Fun;\n    BlockPointerTypeInfo  Cls;\n    MemberPointerTypeInfo Mem;\n    PipeTypeInfo          PipeInfo;\n  };\n\n  void destroy() {\n    switch (Kind) {\n    case DeclaratorChunk::Function:      return Fun.destroy();\n    case DeclaratorChunk::Pointer:       return Ptr.destroy();\n    case DeclaratorChunk::BlockPointer:  return Cls.destroy();\n    case DeclaratorChunk::Reference:     return Ref.destroy();\n    case DeclaratorChunk::Array:         return Arr.destroy();\n    case DeclaratorChunk::MemberPointer: return Mem.destroy();\n    case DeclaratorChunk::Paren:         return;\n    case DeclaratorChunk::Pipe:          return PipeInfo.destroy();\n    }\n  }\n\n  /// If there are attributes applied to this declaratorchunk, return\n  /// them.\n  const ParsedAttributesView &getAttrs() const { return AttrList; }\n  ParsedAttributesView &getAttrs() { return AttrList; }\n\n  /// Return a DeclaratorChunk for a pointer.\n  static DeclaratorChunk getPointer(unsigned TypeQuals, SourceLocation Loc,\n                                    SourceLocation ConstQualLoc,\n                                    SourceLocation VolatileQualLoc,\n                                    SourceLocation RestrictQualLoc,\n                                    SourceLocation AtomicQualLoc,\n                                    SourceLocation UnalignedQualLoc) {\n    DeclaratorChunk I;\n    I.Kind                = Pointer;\n    I.Loc                 = Loc;\n    new (&I.Ptr) PointerTypeInfo;\n    I.Ptr.TypeQuals       = TypeQuals;\n    I.Ptr.ConstQualLoc    = ConstQualLoc;\n    I.Ptr.VolatileQualLoc = VolatileQualLoc;\n    I.Ptr.RestrictQualLoc = RestrictQualLoc;\n    I.Ptr.AtomicQualLoc   = AtomicQualLoc;\n    I.Ptr.UnalignedQualLoc = UnalignedQualLoc;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a reference.\n  static DeclaratorChunk getReference(unsigned TypeQuals, SourceLocation Loc,\n                                      bool lvalue) {\n    DeclaratorChunk I;\n    I.Kind            = Reference;\n    I.Loc             = Loc;\n    I.Ref.HasRestrict = (TypeQuals & DeclSpec::TQ_restrict) != 0;\n    I.Ref.LValueRef   = lvalue;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for an array.\n  static DeclaratorChunk getArray(unsigned TypeQuals,\n                                  bool isStatic, bool isStar, Expr *NumElts,\n                                  SourceLocation LBLoc, SourceLocation RBLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Array;\n    I.Loc           = LBLoc;\n    I.EndLoc        = RBLoc;\n    I.Arr.TypeQuals = TypeQuals;\n    I.Arr.hasStatic = isStatic;\n    I.Arr.isStar    = isStar;\n    I.Arr.NumElts   = NumElts;\n    return I;\n  }\n\n  /// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.\n  /// \"TheDeclarator\" is the declarator that this will be added to.\n  static DeclaratorChunk getFunction(bool HasProto,\n                                     bool IsAmbiguous,\n                                     SourceLocation LParenLoc,\n                                     ParamInfo *Params, unsigned NumParams,\n                                     SourceLocation EllipsisLoc,\n                                     SourceLocation RParenLoc,\n                                     bool RefQualifierIsLvalueRef,\n                                     SourceLocation RefQualifierLoc,\n                                     SourceLocation MutableLoc,\n                                     ExceptionSpecificationType ESpecType,\n                                     SourceRange ESpecRange,\n                                     ParsedType *Exceptions,\n                                     SourceRange *ExceptionRanges,\n                                     unsigned NumExceptions,\n                                     Expr *NoexceptExpr,\n                                     CachedTokens *ExceptionSpecTokens,\n                                     ArrayRef<NamedDecl *> DeclsInPrototype,\n                                     SourceLocation LocalRangeBegin,\n                                     SourceLocation LocalRangeEnd,\n                                     Declarator &TheDeclarator,\n                                     TypeResult TrailingReturnType =\n                                                    TypeResult(),\n                                     SourceLocation TrailingReturnTypeLoc =\n                                                    SourceLocation(),\n                                     DeclSpec *MethodQualifiers = nullptr);\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getBlockPointer(unsigned TypeQuals,\n                                         SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = BlockPointer;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getPipe(unsigned TypeQuals,\n                                 SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = Pipe;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  static DeclaratorChunk getMemberPointer(const CXXScopeSpec &SS,\n                                          unsigned TypeQuals,\n                                          SourceLocation StarLoc,\n                                          SourceLocation EndLoc) {\n    DeclaratorChunk I;\n    I.Kind          = MemberPointer;\n    I.Loc           = SS.getBeginLoc();\n    I.EndLoc = EndLoc;\n    new (&I.Mem) MemberPointerTypeInfo;\n    I.Mem.StarLoc = StarLoc;\n    I.Mem.TypeQuals = TypeQuals;\n    new (I.Mem.ScopeMem) CXXScopeSpec(SS);\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a paren.\n  static DeclaratorChunk getParen(SourceLocation LParenLoc,\n                                  SourceLocation RParenLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Paren;\n    I.Loc           = LParenLoc;\n    I.EndLoc        = RParenLoc;\n    return I;\n  }\n\n  bool isParen() const {\n    return Kind == Paren;\n  }\n}",
  "id": "BLOCK-CPP-19719",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DeclSpec.h",
  "source_line": 1212,
  "validation_status": "validated"
}