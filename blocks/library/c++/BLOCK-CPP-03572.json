{
  "code": "#include \"absl/base/config.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03572_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// FailureSignalHandlerOptions\n//\n// Struct for holding `absl::InstallFailureSignalHandler()` configuration\n// options.\nstruct FailureSignalHandlerOptions {\n  // If true, try to symbolize the stacktrace emitted on failure, provided that\n  // you have initialized a symbolizer for that purpose. (See symbolize.h for\n  // more information.)\n  bool symbolize_stacktrace = true;\n\n  // If true, try to run signal handlers on an alternate stack (if supported on\n  // the given platform). An alternate stack is useful for program crashes due\n  // to a stack overflow; by running on a alternate stack, the signal handler\n  // may run even when normal stack space has been exhausted. The downside of\n  // using an alternate stack is that extra memory for the alternate stack needs\n  // to be pre-allocated.\n  bool use_alternate_stack = true;\n\n  // If positive, indicates the number of seconds after which the failure signal\n  // handler is invoked to abort the program. Setting such an alarm is useful in\n  // cases where the failure signal handler itself may become hung or\n  // deadlocked.\n  int alarm_on_failure_secs = 3;\n\n  // If true, call the previously registered signal handler for the signal that\n  // was received (if one was registered) after the existing signal handler\n  // runs. This mechanism can be used to chain signal handlers together.\n  //\n  // If false, the signal is raised to the default handler for that signal\n  // (which normally terminates the program).\n  //\n  // IMPORTANT: If true, the chained fatal signal handlers must not try to\n  // recover from the fatal signal. Instead, they should terminate the program\n  // via some mechanism, like raising the default handler for the signal, or by\n  // calling `_exit()`. Note that the failure signal handler may put parts of\n  // the Abseil library into a state from which they cannot recover.\n  bool call_previous_handler = false;\n\n  // If non-null, indicates a pointer to a callback function that will be called\n  // upon failure, with a string argument containing failure data. This function\n  // may be used as a hook to write failure data to a secondary location, such\n  // as a log file. This function will also be called with null data, as a hint\n  // to flush any buffered data before the program may be terminated. Consider\n  // flushing any buffered data in all calls to this function.\n  //\n  // Since this function runs within a signal handler, it should be\n  // async-signal-safe if possible.\n  // See http://man7.org/linux/man-pages/man7/signal-safety.7.html\n  void (*writerfn)(const char*) = nullptr;\n};\n\n// InstallFailureSignalHandler()\n//\n// Installs a signal handler for the common failure signals `SIGSEGV`, `SIGILL`,\n// `SIGFPE`, `SIGABRT`, `SIGTERM`, `SIGBUG`, and `SIGTRAP` (provided they exist\n// on the given platform). The failure signal handler dumps program failure data\n// useful for debugging in an unspecified format to stderr. This data may\n// include the program counter, a stacktrace, and register information on some\n// systems; do not rely on an exact format for the output, as it is subject to\n// change.\nvoid InstallFailureSignalHandler(const FailureSignalHandlerOptions& options);\n\nnamespace debugging_internal {\nconst char* FailureSignalToString(int signo);\n}  // namespace debugging_internal\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03572",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/failure_signal_handler.h",
  "source_line": 49,
  "validation_status": "validated"
}