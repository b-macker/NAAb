{
  "code": "{\n\n//===----------------------------------------------------------------------===//\n/// Dataflow Directional Tag Classes.  These are used for tag dispatching\n///  within the dataflow solver/transfer functions to determine what direction\n///  a dataflow analysis flows.\n//===----------------------------------------------------------------------===//\n\nnamespace dataflow {\n  struct forward_analysis_tag {};\n  struct backward_analysis_tag {};\n} // end namespace dataflow\n\n//===----------------------------------------------------------------------===//\n/// DataflowValues.  Container class to store dataflow values for a CFG.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ValueTypes,\n          typename _AnalysisDirTag = dataflow::forward_analysis_tag >\nclass DataflowValues {\n\n  //===--------------------------------------------------------------------===//\n  // Type declarations.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  typedef typename ValueTypes::ValTy               ValTy;\n  typedef typename ValueTypes::AnalysisDataTy      AnalysisDataTy;\n  typedef _AnalysisDirTag                          AnalysisDirTag;\n  typedef llvm::DenseMap<ProgramPoint, ValTy>      EdgeDataMapTy;\n  typedef llvm::DenseMap<const CFGBlock*, ValTy>   BlockDataMapTy;\n  typedef llvm::DenseMap<const Stmt*, ValTy>       StmtDataMapTy;\n\n  //===--------------------------------------------------------------------===//\n  // Predicates.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// isForwardAnalysis - Returns true if the dataflow values are computed\n  ///  from a forward analysis.\n  bool isForwardAnalysis() { return isForwardAnalysis(AnalysisDirTag()); }\n\n  /// isBackwardAnalysis - Returns true if the dataflow values are computed\n  ///  from a backward analysis.\n  bool isBackwardAnalysis() { return !isForwardAnalysis(); }\n\nprivate:\n  bool isForwardAnalysis(dataflow::forward_analysis_tag)  { return true; }\n  bool isForwardAnalysis(dataflow::backward_analysis_tag) { return false; }\n\n  //===--------------------------------------------------------------------===//\n  // Initialization and accessors methods.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  DataflowValues() : StmtDataMap(NULL) {}\n  ~DataflowValues() { delete StmtDataMap; }\n\n  /// InitializeValues - Invoked by the solver to initialize state needed for\n  ///  dataflow analysis.  This method is usually specialized by subclasses.\n  void InitializeValues(const CFG& cfg) {}\n\n\n  /// getEdgeData - Retrieves the dataflow values associated with a\n  ///  CFG edge.\n  ValTy& getEdgeData(const BlockEdge &E) {\n    typename EdgeDataMapTy::iterator I = EdgeDataMap.find(E);\n    assert (I != EdgeDataMap.end() && \"No data associated with Edge.\");\n    return I->second;\n  }\n\n  const ValTy& getEdgeData(const BlockEdge &E) const {\n    return reinterpret_cast<DataflowValues*>(this)->getEdgeData(E);\n  }\n\n  /// getBlockData - Retrieves the dataflow values associated with a\n  ///  specified CFGBlock.  If the dataflow analysis is a forward analysis,\n  ///  this data is associated with the END of the block.  If the analysis\n  ///  is a backwards analysis, it is associated with the ENTRY of the block.\n  ValTy& getBlockData(const CFGBlock *B) {\n    typename BlockDataMapTy::iterator I = BlockDataMap.find(B);\n    assert (I != BlockDataMap.end() && \"No data associated with block.\");\n    return I->second;\n  }\n\n  const ValTy& getBlockData(const CFGBlock *B) const {\n    return const_cast<DataflowValues*>(this)->getBlockData(B);\n  }\n\n  /// getStmtData - Retrieves the dataflow values associated with a\n  ///  specified Stmt.  If the dataflow analysis is a forward analysis,\n  ///  this data corresponds to the point immediately before a Stmt.\n  ///  If the analysis is a backwards analysis, it is associated with\n  ///  the point after a Stmt.  This data is only computed for block-level\n  ///  expressions, and only when requested when the analysis is executed.\n  ValTy& getStmtData(const Stmt *S) {\n    assert (StmtDataMap && \"Dataflow values were not computed for statements.\");\n    typename StmtDataMapTy::iterator I = StmtDataMap->find(S);\n    assert (I != StmtDataMap->end() && \"No data associated with statement.\");\n    return I->second;\n  }\n\n  const ValTy& getStmtData(const Stmt *S) const {\n    return const_cast<DataflowValues*>(this)->getStmtData(S);\n  }\n\n  /// getEdgeDataMap - Retrieves the internal map between CFG edges and\n  ///  dataflow values.  Usually used by a dataflow solver to compute\n  ///  values for blocks.\n  EdgeDataMapTy& getEdgeDataMap() { return EdgeDataMap; }\n  const EdgeDataMapTy& getEdgeDataMap() const { return EdgeDataMap; }\n\n  /// getBlockDataMap - Retrieves the internal map between CFGBlocks and\n  /// dataflow values.  If the dataflow analysis operates in the forward\n  /// direction, the values correspond to the dataflow values at the start\n  /// of the block.  Otherwise, for a backward analysis, the values correspond\n  /// to the dataflow values at the end of the block.\n  BlockDataMapTy& getBlockDataMap() { return BlockDataMap; }\n  const BlockDataMapTy& getBlockDataMap() const { return BlockDataMap; }\n\n  /// getStmtDataMap - Retrieves the internal map between Stmts and\n  /// dataflow values.\n  StmtDataMapTy& getStmtDataMap() {\n    if (!StmtDataMap) StmtDataMap = new StmtDataMapTy();\n    return *StmtDataMap;\n  }\n\n  const StmtDataMapTy& getStmtDataMap() const {\n    return const_cast<DataflowValues*>(this)->getStmtDataMap();\n  }\n\n  /// getAnalysisData - Retrieves the meta data associated with a\n  ///  dataflow analysis for analyzing a particular CFG.\n  ///  This is typically consumed by transfer function code (via the solver).\n  ///  This can also be used by subclasses to interpret the dataflow values.\n  AnalysisDataTy& getAnalysisData() { return AnalysisData; }\n  const AnalysisDataTy& getAnalysisData() const { return AnalysisData; }\n\n  //===--------------------------------------------------------------------===//\n  // Internal data.\n  //===--------------------------------------------------------------------===//\n\nprotected:\n  EdgeDataMapTy      EdgeDataMap;\n  BlockDataMapTy     BlockDataMap;\n  StmtDataMapTy*     StmtDataMap;\n  AnalysisDataTy     AnalysisData;\n};\n\n}",
  "id": "BLOCK-CPP-21925",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/DataflowValues.h",
  "source_line": 22,
  "validation_status": "validated"
}