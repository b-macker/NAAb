{
  "code": "{\n\n/// Defines synch scope values used internally by clang.\n///\n/// The enum values start from 0 and are contiguous. They are mainly used for\n/// enumerating all supported synch scope values and mapping them to LLVM\n/// synch scopes. Their numerical values may be different from the corresponding\n/// synch scope enums used in source languages.\n///\n/// In atomic builtin and expressions, language-specific synch scope enums are\n/// used. Currently only OpenCL memory scope enums are supported and assumed\n/// to be used by all languages. However, in the future, other languages may\n/// define their own set of synch scope enums. The language-specific synch scope\n/// values are represented by class AtomicScopeModel and its derived classes.\n///\n/// To add a new enum value:\n///   Add the enum value to enum class SyncScope.\n///   Update enum value Last if necessary.\n///   Update getAsString.\n///\nenum class SyncScope {\n  HIPSingleThread,\n  HIPWavefront,\n  HIPWorkgroup,\n  HIPAgent,\n  HIPSystem,\n  OpenCLWorkGroup,\n  OpenCLDevice,\n  OpenCLAllSVMDevices,\n  OpenCLSubGroup,\n  Last = OpenCLSubGroup\n};\n\ninline llvm::StringRef getAsString(SyncScope S) {\n  switch (S) {\n  case SyncScope::HIPSingleThread:\n    return \"hip_singlethread\";\n  case SyncScope::HIPWavefront:\n    return \"hip_wavefront\";\n  case SyncScope::HIPWorkgroup:\n    return \"hip_workgroup\";\n  case SyncScope::HIPAgent:\n    return \"hip_agent\";\n  case SyncScope::HIPSystem:\n    return \"hip_system\";\n  case SyncScope::OpenCLWorkGroup:\n    return \"opencl_workgroup\";\n  case SyncScope::OpenCLDevice:\n    return \"opencl_device\";\n  case SyncScope::OpenCLAllSVMDevices:\n    return \"opencl_allsvmdevices\";\n  case SyncScope::OpenCLSubGroup:\n    return \"opencl_subgroup\";\n  }\n  llvm_unreachable(\"Invalid synch scope\");\n}\n\n/// Defines the kind of atomic scope models.\nenum class AtomicScopeModelKind { None, OpenCL, HIP };\n\n/// Defines the interface for synch scope model.\nclass AtomicScopeModel {\npublic:\n  virtual ~AtomicScopeModel() {}\n  /// Maps language specific synch scope values to internal\n  /// SyncScope enum.\n  virtual SyncScope map(unsigned S) const = 0;\n\n  /// Check if the compile-time constant synch scope value\n  /// is valid.\n  virtual bool isValid(unsigned S) const = 0;\n\n  /// Get all possible synch scope values that might be\n  /// encountered at runtime for the current language.\n  virtual ArrayRef<unsigned> getRuntimeValues() const = 0;\n\n  /// If atomic builtin function is called with invalid\n  /// synch scope value at runtime, it will fall back to a valid\n  /// synch scope value returned by this function.\n  virtual unsigned getFallBackValue() const = 0;\n\n  /// Create an atomic scope model by AtomicScopeModelKind.\n  /// \\return an empty std::unique_ptr for AtomicScopeModelKind::None.\n  static std::unique_ptr<AtomicScopeModel> create(AtomicScopeModelKind K);\n};\n\n/// Defines the synch scope model for OpenCL.\nclass AtomicScopeOpenCLModel : public AtomicScopeModel {\npublic:\n  /// The enum values match the pre-defined macros\n  /// __OPENCL_MEMORY_SCOPE_*, which are used to define memory_scope_*\n  /// enums in opencl-c-base.h.\n  enum ID {\n    WorkGroup = 1,\n    Device = 2,\n    AllSVMDevices = 3,\n    SubGroup = 4,\n    Last = SubGroup\n  };\n\n  AtomicScopeOpenCLModel() {}\n\n  SyncScope map(unsigned S) const override {\n    switch (static_cast<ID>(S)) {\n    case WorkGroup:\n      return SyncScope::OpenCLWorkGroup;\n    case Device:\n      return SyncScope::OpenCLDevice;\n    case AllSVMDevices:\n      return SyncScope::OpenCLAllSVMDevices;\n    case SubGroup:\n      return SyncScope::OpenCLSubGroup;\n    }\n    llvm_unreachable(\"Invalid language synch scope value\");\n  }\n\n  bool isValid(unsigned S) const override {\n    return S >= static_cast<unsigned>(WorkGroup) &&\n           S <= static_cast<unsigned>(Last);\n  }\n\n  ArrayRef<unsigned> getRuntimeValues() const override {\n    static_assert(Last == SubGroup, \"Does not include all synch scopes\");\n    static const unsigned Scopes[] = {\n        static_cast<unsigned>(WorkGroup), static_cast<unsigned>(Device),\n        static_cast<unsigned>(AllSVMDevices), static_cast<unsigned>(SubGroup)};\n    return llvm::ArrayRef(Scopes);\n  }\n\n  unsigned getFallBackValue() const override {\n    return static_cast<unsigned>(AllSVMDevices);\n  }\n};\n\n/// Defines the synch scope model for HIP.\nclass AtomicScopeHIPModel : public AtomicScopeModel {\npublic:\n  /// The enum values match the pre-defined macros\n  /// __HIP_MEMORY_SCOPE_*, which are used to define memory_scope_*\n  /// enums in hip-c.h.\n  enum ID {\n    SingleThread = 1,\n    Wavefront = 2,\n    Workgroup = 3,\n    Agent = 4,\n    System = 5,\n    Last = System\n  };\n\n  AtomicScopeHIPModel() {}\n\n  SyncScope map(unsigned S) const override {\n    switch (static_cast<ID>(S)) {\n    case SingleThread:\n      return SyncScope::HIPSingleThread;\n    case Wavefront:\n      return SyncScope::HIPWavefront;\n    case Workgroup:\n      return SyncScope::HIPWorkgroup;\n    case Agent:\n      return SyncScope::HIPAgent;\n    case System:\n      return SyncScope::HIPSystem;\n    }\n    llvm_unreachable(\"Invalid language synch scope value\");\n  }\n\n  bool isValid(unsigned S) const override {\n    return S >= static_cast<unsigned>(SingleThread) &&\n           S <= static_cast<unsigned>(Last);\n  }\n\n  ArrayRef<unsigned> getRuntimeValues() const override {\n    static_assert(Last == System, \"Does not include all synch scopes\");\n    static const unsigned Scopes[] = {\n        static_cast<unsigned>(SingleThread), static_cast<unsigned>(Wavefront),\n        static_cast<unsigned>(Workgroup), static_cast<unsigned>(Agent),\n        static_cast<unsigned>(System)};\n    return llvm::ArrayRef(Scopes);\n  }\n\n  unsigned getFallBackValue() const override {\n    return static_cast<unsigned>(System);\n  }\n};\n\ninline std::unique_ptr<AtomicScopeModel>\nAtomicScopeModel::create(AtomicScopeModelKind K) {\n  switch (K) {\n  case AtomicScopeModelKind::None:\n    return std::unique_ptr<AtomicScopeModel>{};\n  case AtomicScopeModelKind::OpenCL:\n    return std::make_unique<AtomicScopeOpenCLModel>();\n  case AtomicScopeModelKind::HIP:\n    return std::make_unique<AtomicScopeHIPModel>();\n  }\n  llvm_unreachable(\"Invalid atomic scope model kind\");\n}\n}",
  "id": "BLOCK-CPP-17022",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SyncScope.h",
  "source_line": 22,
  "validation_status": "validated"
}