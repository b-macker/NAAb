{
  "code": "{\nnamespace cctz {\n\n// Convenience aliases. Not intended as public API points.\ntemplate <typename D>\nusing time_point = std::chrono::time_point<std::chrono::system_clock, D>;\nusing seconds = std::chrono::duration<std::int_fast64_t>;\nusing sys_seconds = seconds;  // Deprecated.  Use cctz::seconds instead.\n\nnamespace detail {\ntemplate <typename D>\nstd::pair<time_point<seconds>, D> split_seconds(const time_point<D>& tp);\nstd::pair<time_point<seconds>, seconds> split_seconds(\n    const time_point<seconds>& tp);\n}  // namespace detail\n\n// cctz::time_zone is an opaque, small, value-type class representing a\n// geo-political region within which particular rules are used for mapping\n// between absolute and civil times. Time zones are named using the TZ\n// identifiers from the IANA Time Zone Database, such as \"America/Los_Angeles\"\n// or \"Australia/Sydney\". Time zones are created from factory functions such\n// as load_time_zone(). Note: strings like \"PST\" and \"EDT\" are not valid TZ\n// identifiers.\n//\n// Example:\n//   cctz::time_zone utc = cctz::utc_time_zone();\n//   cctz::time_zone pst = cctz::fixed_time_zone(std::chrono::hours(-8));\n//   cctz::time_zone loc = cctz::local_time_zone();\n//   cctz::time_zone lax;\n//   if (!cctz::load_time_zone(\"America/Los_Angeles\", &lax)) { ... }\n//\n// See also:\n// - http://www.iana.org/time-zones\n// - https://en.wikipedia.org/wiki/Zoneinfo\nclass time_zone {\n public:\n  time_zone() : time_zone(nullptr) {}  // Equivalent to UTC\n  time_zone(const time_zone&) = default;\n  time_zone& operator=(const time_zone&) = default;\n\n  std::string name() const;\n\n  // An absolute_lookup represents the civil time (cctz::civil_second) within\n  // this time_zone at the given absolute time (time_point). There are\n  // additionally a few other fields that may be useful when working with\n  // older APIs, such as std::tm.\n  //\n  // Example:\n  //   const cctz::time_zone tz = ...\n  //   const auto tp = std::chrono::system_clock::now();\n  //   const cctz::time_zone::absolute_lookup al = tz.lookup(tp);\n  struct absolute_lookup {\n    civil_second cs;\n    // Note: The following fields exist for backward compatibility with older\n    // APIs. Accessing these fields directly is a sign of imprudent logic in\n    // the calling code. Modern time-related code should only access this data\n    // indirectly by way of cctz::format().\n    int offset;        // civil seconds east of UTC\n    bool is_dst;       // is offset non-standard?\n    const char* abbr;  // time-zone abbreviation (e.g., \"PST\")\n  };\n  absolute_lookup lookup(const time_point<seconds>& tp) const;\n  template <typename D>\n  absolute_lookup lookup(const time_point<D>& tp) const {\n    return lookup(detail::split_seconds(tp).first);\n  }\n\n  // A civil_lookup represents the absolute time(s) (time_point) that\n  // correspond to the given civil time (cctz::civil_second) within this\n  // time_zone. Usually the given civil time represents a unique instant\n  // in time, in which case the conversion is unambiguous. However,\n  // within this time zone, the given civil time may be skipped (e.g.,\n  // during a positive UTC offset shift), or repeated (e.g., during a\n  // negative UTC offset shift). To account for these possibilities,\n  // civil_lookup is richer than just a single time_point.\n  //\n  // In all cases the civil_lookup::kind enum will indicate the nature\n  // of the given civil-time argument, and the pre, trans, and post\n  // members will give the absolute time answers using the pre-transition\n  // offset, the transition point itself, and the post-transition offset,\n  // respectively (all three times are equal if kind == UNIQUE). If any\n  // of these three absolute times is outside the representable range of a\n  // time_point<seconds> the field is set to its maximum/minimum value.\n  //\n  // Example:\n  //   cctz::time_zone lax;\n  //   if (!cctz::load_time_zone(\"America/Los_Angeles\", &lax)) { ... }\n  //\n  //   // A unique civil time.\n  //   auto jan01 = lax.lookup(cctz::civil_second(2011, 1, 1, 0, 0, 0));\n  //   // jan01.kind == cctz::time_zone::civil_lookup::UNIQUE\n  //   // jan01.pre    is 2011/01/01 00:00:00 -0800\n  //   // jan01.trans  is 2011/01/01 00:00:00 -0800\n  //   // jan01.post   is 2011/01/01 00:00:00 -0800\n  //\n  //   // A Spring DST transition, when there is a gap in civil time.\n  //   auto mar13 = lax.lookup(cctz::civil_second(2011, 3, 13, 2, 15, 0));\n  //   // mar13.kind == cctz::time_zone::civil_lookup::SKIPPED\n  //   // mar13.pre   is 2011/03/13 03:15:00 -0700\n  //   // mar13.trans is 2011/03/13 03:00:00 -0700\n  //   // mar13.post  is 2011/03/13 01:15:00 -0800\n  //\n  //   // A Fall DST transition, when civil times are repeated.\n  //   auto nov06 = lax.lookup(cctz::civil_second(2011, 11, 6, 1, 15, 0));\n  //   // nov06.kind == cctz::time_zone::civil_lookup::REPEATED\n  //   // nov06.pre   is 2011/11/06 01:15:00 -0700\n  //   // nov06.trans is 2011/11/06 01:00:00 -0800\n  //   // nov06.post  is 2011/11/06 01:15:00 -0800\n  struct civil_lookup {\n    enum civil_kind {\n      UNIQUE,    // the civil time was singular (pre == trans == post)\n      SKIPPED,   // the civil time did not exist (pre >= trans > post)\n      REPEATED,  // the civil time was ambiguous (pre < trans <= post)\n    } kind;\n    time_point<seconds> pre;    // uses the pre-transition offset\n    time_point<seconds> trans;  // instant of civil-offset change\n    time_point<seconds> post;   // uses the post-transition offset\n  };\n  civil_lookup lookup(const civil_second& cs) const;\n\n  // Finds the time of the next/previous offset change in this time zone.\n  //\n  // By definition, next_transition(tp, &trans) returns false when tp has\n  // its maximum value, and prev_transition(tp, &trans) returns false\n  // when tp has its minimum value. If the zone has no transitions, the\n  // result will also be false no matter what the argument.\n  //\n  // Otherwise, when tp has its minimum value, next_transition(tp, &trans)\n  // returns true and sets trans to the first recorded transition. Chains\n  // of calls to next_transition()/prev_transition() will eventually return\n  // false, but it is unspecified exactly when next_transition(tp, &trans)\n  // jumps to false, or what time is set by prev_transition(tp, &trans) for\n  // a very distant tp.\n  //\n  // Note: Enumeration of time-zone transitions is for informational purposes\n  // only. Modern time-related code should not care about when offset changes\n  // occur.\n  //\n  // Example:\n  //   cctz::time_zone nyc;\n  //   if (!cctz::load_time_zone(\"America/New_York\", &nyc)) { ... }\n  //   const auto now = std::chrono::system_clock::now();\n  //   auto tp = cctz::time_point<cctz::seconds>::min();\n  //   cctz::time_zone::civil_transition trans;\n  //   while (tp <= now && nyc.next_transition(tp, &trans)) {\n  //     // transition: trans.from -> trans.to\n  //     tp = nyc.lookup(trans.to).trans;\n  //   }\n  struct civil_transition {\n    civil_second from;  // the civil time we jump from\n    civil_second to;    // the civil time we jump to\n  };\n  bool next_transition(const time_point<seconds>& tp,\n                       civil_transition* trans) const;\n  template <typename D>\n  bool next_transition(const time_point<D>& tp, civil_transition* trans) const {\n    return next_transition(detail::split_seconds(tp).first, trans);\n  }\n  bool prev_transition(const time_point<seconds>& tp,\n                       civil_transition* trans) const;\n  template <typename D>\n  bool prev_transition(const time_point<D>& tp, civil_transition* trans) const {\n    return prev_transition(detail::split_seconds(tp).first, trans);\n  }\n\n  // version() and description() provide additional information about the\n  // time zone. The content of each of the returned strings is unspecified,\n  // however, when the IANA Time Zone Database is the underlying data source\n  // the version() string will be in the familar form (e.g, \"2018e\") or\n  // empty when unavailable.\n  //\n  // Note: These functions are for informational or testing purposes only.\n  std::string version() const;  // empty when unknown\n  std::string description() const;\n\n  // Relational operators.\n  friend bool operator==(time_zone lhs, time_zone rhs) {\n    return &lhs.effective_impl() == &rhs.effective_impl();\n  }\n  friend bool operator!=(time_zone lhs, time_zone rhs) { return !(lhs == rhs); }\n\n  template <typename H>\n  friend H AbslHashValue(H h, time_zone tz) {\n    return H::combine(std::move(h), &tz.effective_impl());\n  }\n\n  class Impl;\n\n private:\n  explicit time_zone(const Impl* impl) : impl_(impl) {}\n  const Impl& effective_impl() const;  // handles implicit UTC\n  const Impl* impl_;\n};\n\n// Loads the named time zone. May perform I/O on the initial load.\n// If the name is invalid, or some other kind of error occurs, returns\n// false and \"*tz\" is set to the UTC time zone.\nbool load_time_zone(const std::string& name, time_zone* tz);\n\n// Returns a time_zone representing UTC. Cannot fail.\ntime_zone utc_time_zone();\n\n// Returns a time zone that is a fixed offset (seconds east) from UTC.\n// Note: If the absolute value of the offset is greater than 24 hours\n// you'll get UTC (i.e., zero offset) instead.\ntime_zone fixed_time_zone(const seconds& offset);\n\n// Returns a time zone representing the local time zone. Falls back to UTC.\n// Note: local_time_zone.name() may only be something like \"localtime\".\ntime_zone local_time_zone();\n\n// Returns the civil time (cctz::civil_second) within the given time zone at\n// the given absolute time (time_point). Since the additional fields provided\n// by the time_zone::absolute_lookup struct should rarely be needed in modern\n// code, this convert() function is simpler and should be preferred.\ntemplate <typename D>\ninline civil_second convert(const time_point<D>& tp, const time_zone& tz) {\n  return tz.lookup(tp).cs;\n}\n\n// Returns the absolute time (time_point) that corresponds to the given civil\n// time within the given time zone. If the civil time is not unique (i.e., if\n// it was either repeated or non-existent), then the returned time_point is\n// the best estimate that preserves relative order. That is, this function\n// guarantees that if cs1 < cs2, then convert(cs1, tz) <= convert(cs2, tz).\ninline time_point<seconds> convert(const civil_second& cs,\n                                   const time_zone& tz) {\n  const time_zone::civil_lookup cl = tz.lookup(cs);\n  if (cl.kind == time_zone::civil_lookup::SKIPPED) return cl.trans;\n  return cl.pre;\n}\n\nnamespace detail {\nusing femtoseconds = std::chrono::duration<std::int_fast64_t, std::femto>;\nstd::string format(const std::string&, const time_point<seconds>&,\n                   const femtoseconds&, const time_zone&);\nbool parse(const std::string&, const std::string&, const time_zone&,\n           time_point<seconds>*, femtoseconds*, std::string* err = nullptr);\ntemplate <typename Rep, std::intmax_t Denom>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp);\ntemplate <typename Rep, std::intmax_t Num>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp);\ntemplate <typename Rep>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp);\nbool join_seconds(const time_point<seconds>& sec, const femtoseconds&,\n                  time_point<seconds>* tpp);\n}  // namespace detail\n\n// Formats the given time_point in the given cctz::time_zone according to\n// the provided format string. Uses strftime()-like formatting options,\n// with the following extensions:\n//\n//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)\n//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)\n//   - %E#S - Seconds with # digits of fractional precision\n//   - %E*S - Seconds with full fractional precision (a literal '*')\n//   - %E#f - Fractional seconds with # digits of precision\n//   - %E*f - Fractional seconds with full precision (a literal '*')\n//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)\n//   - %ET  - The RFC3339 \"date-time\" separator \"T\"\n//\n// Note that %E0S behaves like %S, and %E0f produces no characters. In\n// contrast %E*f always produces at least one digit, which may be '0'.\n//\n// Note that %Y produces as many characters as it takes to fully render the\n// year. A year outside of [-999:9999] when formatted with %E4Y will produce\n// more than four characters, just like %Y.\n//\n// Tip: Format strings should include the UTC offset (e.g., %z, %Ez, or %E*z)\n// so that the resulting string uniquely identifies an absolute time.\n//\n// Example:\n//   cctz::time_zone lax;\n//   if (!cctz::load_time_zone(\"America/Los_Angeles\", &lax)) { ... }\n//   auto tp = cctz::convert(cctz::civil_second(2013, 1, 2, 3, 4, 5), lax);\n//   std::string f = cctz::format(\"%H:%M:%S\", tp, lax);  // \"03:04:05\"\n//   f = cctz::format(\"%H:%M:%E3S\", tp, lax);            // \"03:04:05.000\"\ntemplate <typename D>\ninline std::string format(const std::string& fmt, const time_point<D>& tp,\n                          const time_zone& tz) {\n  const auto p = detail::split_seconds(tp);\n  const auto n = std::chrono::duration_cast<detail::femtoseconds>(p.second);\n  return detail::format(fmt, p.first, n, tz);\n}\n\n// Parses an input string according to the provided format string and\n// returns the corresponding time_point. Uses strftime()-like formatting\n// options, with the same extensions as cctz::format(), but with the\n// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f. %Ez\n// and %E*z also accept the same inputs, which (along with %z) includes\n// 'z' and 'Z' as synonyms for +00:00.  %ET accepts either 'T' or 't'.\n//\n// %Y consumes as many numeric characters as it can, so the matching data\n// should always be terminated with a non-numeric. %E4Y always consumes\n// exactly four characters, including any sign.\n//\n// Unspecified fields are taken from the default date and time of ...\n//\n//   \"1970-01-01 00:00:00.0 +0000\"\n//\n// For example, parsing a string of \"15:45\" (%H:%M) will return a time_point\n// that represents \"1970-01-01 15:45:00.0 +0000\".\n//\n// Note that parse() returns time instants, so it makes most sense to parse\n// fully-specified date/time strings that include a UTC offset (%z, %Ez, or\n// %E*z).\n//\n// Note also that parse() only heeds the fields year, month, day, hour,\n// minute, (fractional) second, and UTC offset. Other fields, like weekday (%a\n// or %A), while parsed for syntactic validity, are ignored in the conversion.\n//\n// Date and time fields that are out-of-range will be treated as errors rather\n// than normalizing them like cctz::civil_second() would do. For example, it\n// is an error to parse the date \"Oct 32, 2013\" because 32 is out of range.\n//\n// A second of \":60\" is normalized to \":00\" of the following minute with\n// fractional seconds discarded. The following table shows how the given\n// seconds and subseconds will be parsed:\n//\n//   \"59.x\" -> 59.x  // exact\n//   \"60.x\" -> 00.0  // normalized\n//   \"00.x\" -> 00.x  // exact\n//\n// Errors are indicated by returning false.\n//\n// Example:\n//   const cctz::time_zone tz = ...\n//   std::chrono::system_clock::time_point tp;\n//   if (cctz::parse(\"%Y-%m-%d\", \"2015-10-09\", tz, &tp)) {\n//     ...\n//   }\ntemplate <typename D>\ninline bool parse(const std::string& fmt, const std::string& input,\n                  const time_zone& tz, time_point<D>* tpp) {\n  time_point<seconds> sec;\n  detail::femtoseconds fs;\n  return detail::parse(fmt, input, tz, &sec, &fs) &&\n         detail::join_seconds(sec, fs, tpp);\n}\n\nnamespace detail {\n\n// Split a time_point<D> into a time_point<seconds> and a D subseconds.\n// Undefined behavior if time_point<seconds> is not of sufficient range.\n// Note that this means it is UB to call cctz::time_zone::lookup(tp) or\n// cctz::format(fmt, tp, tz) with a time_point that is outside the range\n// of a 64-bit std::time_t.\ntemplate <typename D>\nstd::pair<time_point<seconds>, D> split_seconds(const time_point<D>& tp) {\n  auto sec = std::chrono::time_point_cast<seconds>(tp);\n  auto sub = tp - sec;\n  if (sub.count() < 0) {\n    sec -= seconds(1);\n    sub += seconds(1);\n  }\n  return {sec, std::chrono::duration_cast<D>(sub)};\n}\n\ninline std::pair<time_point<seconds>, seconds> split_seconds(\n    const time_point<seconds>& tp) {\n  return {tp, seconds::zero()};\n}\n\n// Join a time_point<seconds> and femto subseconds into a time_point<D>.\n// Floors to the resolution of time_point<D>. Returns false if time_point<D>\n// is not of sufficient range.\ntemplate <typename Rep, std::intmax_t Denom>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<1, Denom>>;\n  // TODO(#199): Return false if result unrepresentable as a time_point<D>.\n  *tpp = std::chrono::time_point_cast<D>(sec);\n  *tpp += std::chrono::duration_cast<D>(fs);\n  return true;\n}\n\ntemplate <typename Rep, std::intmax_t Num>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds&,\n    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<Num, 1>>;\n  auto count = sec.time_since_epoch().count();\n  if (count >= 0 || count % Num == 0) {\n    count /= Num;\n  } else {\n    count /= Num;\n    count -= 1;\n  }\n  if (count > (std::numeric_limits<Rep>::max)()) return false;\n  if (count < (std::numeric_limits<Rep>::min)()) return false;\n  *tpp = time_point<D>() + D{static_cast<Rep>(count)};\n  return true;\n}\n\ntemplate <typename Rep>\nbool join_seconds(\n    const time_point<seconds>& sec, const femtoseconds&,\n    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp) {\n  using D = std::chrono::duration<Rep, std::ratio<1, 1>>;\n  auto count = sec.time_since_epoch().count();\n  if (count > (std::numeric_limits<Rep>::max)()) return false;\n  if (count < (std::numeric_limits<Rep>::min)()) return false;\n  *tpp = time_point<D>() + D{static_cast<Rep>(count)};\n  return true;\n}\n\ninline bool join_seconds(const time_point<seconds>& sec, const femtoseconds&,\n                         time_point<seconds>* tpp) {\n  *tpp = sec;\n  return true;\n}\n\n}  // namespace detail\n}  // namespace cctz\n}",
  "id": "BLOCK-CPP-06614",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/time_zone.h",
  "source_line": 35,
  "validation_status": "validated"
}