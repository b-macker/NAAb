{
  "code": "#include \"clang/Analysis/FlowSensitive/Formula.h\"\n#include \"clang/Analysis/FlowSensitive/Solver.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <limits>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-22046_execute() {\n    {\nnamespace dataflow {\n\n/// A SAT solver that is an implementation of Algorithm D from Knuth's The Art\n/// of Computer Programming Volume 4: Satisfiability, Fascicle 6. It is based on\n/// the Davis-Putnam-Logemann-Loveland (DPLL) algorithm, keeps references to a\n/// single \"watched\" literal per clause, and uses a set of \"active\" variables\n/// for unit propagation.\nclass WatchedLiteralsSolver : public Solver {\n  // Count of the iterations of the main loop of the solver. This spans *all*\n  // calls to the underlying solver across the life of this object. It is\n  // reduced with every (non-trivial) call to the solver.\n  //\n  // We give control over the abstract count of iterations instead of concrete\n  // measurements like CPU cycles or time to ensure deterministic results.\n  std::int64_t MaxIterations = std::numeric_limits<std::int64_t>::max();\n\npublic:\n  WatchedLiteralsSolver() = default;\n\n  // `Work` specifies a computational limit on the solver. Units of \"work\"\n  // roughly correspond to attempts to assign a value to a single\n  // variable. Since the algorithm is exponential in the number of variables,\n  // this is the most direct (abstract) unit to target.\n  explicit WatchedLiteralsSolver(std::int64_t WorkLimit)\n      : MaxIterations(WorkLimit) {}\n\n  Result solve(llvm::ArrayRef<const Formula *> Vals) override;\n\n  // The solver reached its maximum number of iterations.\n  bool reachedLimit() const { return MaxIterations == 0; }\n};\n\n} // namespace dataflow\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-22046",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/WatchedLiteralsSolver.h",
  "source_line": 22,
  "validation_status": "validated"
}