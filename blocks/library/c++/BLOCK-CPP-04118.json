{
  "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/port.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/strings/has_absl_stringify.h\"\n#include \"absl/strings/internal/resize_uninitialized.h\"\n#include \"absl/strings/internal/stringify_sink.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace of;\nusing namespace as;\nusing namespace absl;\nusing namespace strings_internal;\nusing namespace strings_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04118_execute() {\n    {\n public:\n  // No bool ctor -- bools convert to an integral type.\n  // A bool ctor would also convert incoming pointers (bletch).\n\n  AlphaNum(int x)  // NOLINT(runtime/explicit)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n  AlphaNum(unsigned int x)  // NOLINT(runtime/explicit)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n  AlphaNum(long x)  // NOLINT(*)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n  AlphaNum(unsigned long x)  // NOLINT(*)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n  AlphaNum(long long x)  // NOLINT(*)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n  AlphaNum(unsigned long long x)  // NOLINT(*)\n      : piece_(digits_, static_cast<size_t>(\n                            numbers_internal::FastIntToBuffer(x, digits_) -\n                            &digits_[0])) {}\n\n  AlphaNum(float f)  // NOLINT(runtime/explicit)\n      : piece_(digits_, numbers_internal::SixDigitsToBuffer(f, digits_)) {}\n  AlphaNum(double f)  // NOLINT(runtime/explicit)\n      : piece_(digits_, numbers_internal::SixDigitsToBuffer(f, digits_)) {}\n\n  template <size_t size>\n  AlphaNum(  // NOLINT(runtime/explicit)\n      const strings_internal::AlphaNumBuffer<size>& buf\n          ABSL_ATTRIBUTE_LIFETIME_BOUND)\n      : piece_(&buf.data[0], buf.size) {}\n\n  AlphaNum(absl::Nullable<const char*> c_str  // NOLINT(runtime/explicit)\n               ABSL_ATTRIBUTE_LIFETIME_BOUND)\n      : piece_(NullSafeStringView(c_str)) {}\n  AlphaNum(absl::string_view pc  // NOLINT(runtime/explicit)\n               ABSL_ATTRIBUTE_LIFETIME_BOUND)\n      : piece_(pc) {}\n\n  template <typename T, typename = typename std::enable_if<\n                            HasAbslStringify<T>::value>::type>\n  AlphaNum(  // NOLINT(runtime/explicit)\n      const T& v ABSL_ATTRIBUTE_LIFETIME_BOUND,\n      strings_internal::StringifySink&& sink ABSL_ATTRIBUTE_LIFETIME_BOUND = {})\n      : piece_(strings_internal::ExtractStringification(sink, v)) {}\n\n  template <typename Allocator>\n  AlphaNum(  // NOLINT(runtime/explicit)\n      const std::basic_string<char, std::char_traits<char>, Allocator>& str\n          ABSL_ATTRIBUTE_LIFETIME_BOUND)\n      : piece_(str) {}\n\n  // Use string literals \":\" instead of character literals ':'.\n  AlphaNum(char c) = delete;  // NOLINT(runtime/explicit)\n\n  AlphaNum(const AlphaNum&) = delete;\n  AlphaNum& operator=(const AlphaNum&) = delete;\n\n  absl::string_view::size_type size() const { return piece_.size(); }\n  absl::Nullable<const char*> data() const { return piece_.data(); }\n  absl::string_view Piece() const { return piece_; }\n\n  // Match unscoped enums.  Use integral promotion so that a `char`-backed\n  // enum becomes a wider integral type AlphaNum will accept.\n  template <typename T,\n            typename = typename std::enable_if<\n                std::is_enum<T>{} && std::is_convertible<T, int>{} &&\n                !HasAbslStringify<T>::value>::type>\n  AlphaNum(T e)  // NOLINT(runtime/explicit)\n      : AlphaNum(+e) {}\n\n  // This overload matches scoped enums.  We must explicitly cast to the\n  // underlying type, but use integral promotion for the same reason as above.\n  template <typename T,\n            typename std::enable_if<std::is_enum<T>{} &&\n                                        !std::is_convertible<T, int>{} &&\n                                        !HasAbslStringify<T>::value,\n                                    char*>::type = nullptr>\n  AlphaNum(T e)  // NOLINT(runtime/explicit)\n      : AlphaNum(+static_cast<typename std::underlying_type<T>::type>(e)) {}\n\n  // vector<bool>::reference and const_reference require special help to\n  // convert to `AlphaNum` because it requires two user defined conversions.\n  template <\n      typename T,\n      typename std::enable_if<\n          std::is_class<T>::value &&\n          (std::is_same<T, std::vector<bool>::reference>::value ||\n           std::is_same<T, std::vector<bool>::const_reference>::value)>::type* =\n          nullptr>\n  AlphaNum(T e) : AlphaNum(static_cast<bool>(e)) {}  // NOLINT(runtime/explicit)\n\n private:\n  absl::string_view piece_;\n  char digits_[numbers_internal::kFastToBufferSize];\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04118",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.h",
  "source_line": 310,
  "validation_status": "validated"
}