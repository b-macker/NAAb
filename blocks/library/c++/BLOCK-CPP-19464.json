{
  "code": "{\nprotected:\n  const CodeCompleteOptions CodeCompleteOpts;\n\npublic:\n  class OverloadCandidate {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template, arguments are being completed.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType,\n\n      /// The candidate is a variable or expression of function type\n      /// for which we have the location of the prototype declaration.\n      CK_FunctionProtoTypeLoc,\n\n      /// The candidate is a template, template arguments are being completed.\n      CK_Template,\n\n      /// The candidate is aggregate initialization of a record type.\n      CK_Aggregate,\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n\n      /// The location of the function prototype that describes the entity being\n      /// called, when Kind == CK_FunctionProtoTypeLoc.\n      FunctionProtoTypeLoc ProtoTypeLoc;\n\n      /// The template overload candidate, available when\n      /// Kind == CK_Template.\n      const TemplateDecl *Template;\n\n      /// The class being aggregate-initialized,\n      /// when Kind == CK_Aggregate\n      const RecordDecl *AggregateType;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {\n      assert(Function != nullptr);\n    }\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {\n      assert(FunctionTemplateDecl != nullptr);\n    }\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {\n      assert(Type != nullptr);\n    }\n\n    OverloadCandidate(FunctionProtoTypeLoc Prototype)\n        : Kind(CK_FunctionProtoTypeLoc), ProtoTypeLoc(Prototype) {\n      assert(!Prototype.isNull());\n    }\n\n    OverloadCandidate(const RecordDecl *Aggregate)\n        : Kind(CK_Aggregate), AggregateType(Aggregate) {\n      assert(Aggregate != nullptr);\n    }\n\n    OverloadCandidate(const TemplateDecl *Template)\n        : Kind(CK_Template), Template(Template) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Retrieve the function ProtoTypeLoc candidate.\n    /// This can be called for any Kind, but returns null for kinds\n    /// other than CK_FunctionProtoTypeLoc.\n    const FunctionProtoTypeLoc getFunctionProtoTypeLoc() const;\n\n    const TemplateDecl *getTemplate() const {\n      assert(getKind() == CK_Template && \"Not a template\");\n      return Template;\n    }\n\n    /// Retrieve the aggregate type being initialized.\n    const RecordDecl *getAggregate() const {\n      assert(getKind() == CK_Aggregate);\n      return AggregateType;\n    }\n\n    /// Get the number of parameters in this signature.\n    unsigned getNumParams() const;\n\n    /// Get the type of the Nth parameter.\n    /// Returns null if the type is unknown or N is out of range.\n    QualType getParamType(unsigned N) const;\n\n    /// Get the declaration of the Nth parameter.\n    /// Returns null if the decl is unknown or N is out of range.\n    const NamedDecl *getParamDecl(unsigned N) const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *\n    CreateSignatureString(unsigned CurrentArg, Sema &S,\n                          CodeCompletionAllocator &Allocator,\n                          CodeCompletionTUInfo &CCTUInfo,\n                          bool IncludeBriefComments, bool Braced) const;\n  };\n\n  CodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts)\n      : CodeCompleteOpts(CodeCompleteOpts) {}\n\n  /// Whether the code-completion consumer wants to see macros.\n  bool includeMacros() const {\n    return CodeCompleteOpts.IncludeMacros;\n  }\n\n  /// Whether the code-completion consumer wants to see code patterns.\n  bool includeCodePatterns() const {\n    return CodeCompleteOpts.IncludeCodePatterns;\n  }\n\n  /// Whether to include global (top-level) declaration results.\n  bool includeGlobals() const { return CodeCompleteOpts.IncludeGlobals; }\n\n  /// Whether to include declarations in namespace contexts (including\n  /// the global namespace). If this is false, `includeGlobals()` will be\n  /// ignored.\n  bool includeNamespaceLevelDecls() const {\n    return CodeCompleteOpts.IncludeNamespaceLevelDecls;\n  }\n\n  /// Whether to include brief documentation comments within the set of\n  /// code completions returned.\n  bool includeBriefComments() const {\n    return CodeCompleteOpts.IncludeBriefComments;\n  }\n\n  /// Whether to include completion items with small fix-its, e.g. change\n  /// '.' to '->' on member access, etc.\n  bool includeFixIts() const { return CodeCompleteOpts.IncludeFixIts; }\n\n  /// Hint whether to load data from the external AST in order to provide\n  /// full results. If false, declarations from the preamble may be omitted.\n  bool loadExternal() const {\n    return CodeCompleteOpts.LoadExternal;\n  }\n\n  /// Deregisters and destroys this code-completion consumer.\n  virtual ~CodeCompleteConsumer();\n\n  /// \\name Code-completion filtering\n  /// Check if the result should be filtered out.\n  virtual bool isResultFilteredOut(StringRef Filter,\n                                   CodeCompletionResult Results) {\n    return false;\n  }\n\n  /// \\name Code-completion callbacks\n  //@{\n  /// Process the finalized code-completion results.\n  virtual void ProcessCodeCompleteResults(Sema &S,\n                                          CodeCompletionContext Context,\n                                          CodeCompletionResult *Results,\n                                          unsigned NumResults) {}\n\n  /// \\param S the semantic-analyzer object for which code-completion is being\n  /// done.\n  ///\n  /// \\param CurrentArg the index of the current argument.\n  ///\n  /// \\param Candidates an array of overload candidates.\n  ///\n  /// \\param NumCandidates the number of overload candidates\n  ///\n  /// \\param OpenParLoc location of the opening parenthesis of the argument\n  ///        list.\n  virtual void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                         OverloadCandidate *Candidates,\n                                         unsigned NumCandidates,\n                                         SourceLocation OpenParLoc,\n                                         bool Braced) {}\n  //@}\n\n  /// Retrieve the allocator that will be used to allocate\n  /// code completion strings.\n  virtual CodeCompletionAllocator &getAllocator() = 0;\n\n  virtual CodeCompletionTUInfo &getCodeCompletionTUInfo() = 0;\n}",
  "id": "BLOCK-CPP-19464",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/CodeCompleteConsumer.h",
  "source_line": 1012,
  "validation_status": "validated"
}