{
  "code": "{\n\nbool HasRandenHwAesImplementation() { return true; }\n\nconst void* ABSL_TARGET_CRYPTO RandenHwAes::GetKeys() {\n  // Round keys for one AES per Feistel round and branch.\n  // The canonical implementation uses first digits of Pi.\n#if defined(ABSL_ARCH_PPC)\n  return kRandenRoundKeysBE;\n#else\n  return kRandenRoundKeys;\n#endif\n}\n\n// NOLINTNEXTLINE\nvoid ABSL_TARGET_CRYPTO RandenHwAes::Absorb(const void* seed_void,\n                                            void* state_void) {\n  static_assert(RandenTraits::kCapacityBytes / sizeof(Vector128) == 1,\n                \"Unexpected Randen kCapacityBlocks\");\n  static_assert(RandenTraits::kStateBytes / sizeof(Vector128) == 16,\n                \"Unexpected Randen kStateBlocks\");\n\n  auto* state = reinterpret_cast<absl::uint128 * ABSL_RANDOM_INTERNAL_RESTRICT>(\n      state_void);\n  const auto* seed =\n      reinterpret_cast<const absl::uint128 * ABSL_RANDOM_INTERNAL_RESTRICT>(\n          seed_void);\n\n  Vector128 b1 = Vector128Load(state + 1);\n  b1 ^= Vector128Load(seed + 0);\n  Vector128Store(b1, state + 1);\n\n  Vector128 b2 = Vector128Load(state + 2);\n  b2 ^= Vector128Load(seed + 1);\n  Vector128Store(b2, state + 2);\n\n  Vector128 b3 = Vector128Load(state + 3);\n  b3 ^= Vector128Load(seed + 2);\n  Vector128Store(b3, state + 3);\n\n  Vector128 b4 = Vector128Load(state + 4);\n  b4 ^= Vector128Load(seed + 3);\n  Vector128Store(b4, state + 4);\n\n  Vector128 b5 = Vector128Load(state + 5);\n  b5 ^= Vector128Load(seed + 4);\n  Vector128Store(b5, state + 5);\n\n  Vector128 b6 = Vector128Load(state + 6);\n  b6 ^= Vector128Load(seed + 5);\n  Vector128Store(b6, state + 6);\n\n  Vector128 b7 = Vector128Load(state + 7);\n  b7 ^= Vector128Load(seed + 6);\n  Vector128Store(b7, state + 7);\n\n  Vector128 b8 = Vector128Load(state + 8);\n  b8 ^= Vector128Load(seed + 7);\n  Vector128Store(b8, state + 8);\n\n  Vector128 b9 = Vector128Load(state + 9);\n  b9 ^= Vector128Load(seed + 8);\n  Vector128Store(b9, state + 9);\n\n  Vector128 b10 = Vector128Load(state + 10);\n  b10 ^= Vector128Load(seed + 9);\n  Vector128Store(b10, state + 10);\n\n  Vector128 b11 = Vector128Load(state + 11);\n  b11 ^= Vector128Load(seed + 10);\n  Vector128Store(b11, state + 11);\n\n  Vector128 b12 = Vector128Load(state + 12);\n  b12 ^= Vector128Load(seed + 11);\n  Vector128Store(b12, state + 12);\n\n  Vector128 b13 = Vector128Load(state + 13);\n  b13 ^= Vector128Load(seed + 12);\n  Vector128Store(b13, state + 13);\n\n  Vector128 b14 = Vector128Load(state + 14);\n  b14 ^= Vector128Load(seed + 13);\n  Vector128Store(b14, state + 14);\n\n  Vector128 b15 = Vector128Load(state + 15);\n  b15 ^= Vector128Load(seed + 14);\n  Vector128Store(b15, state + 15);\n}\n\n// NOLINTNEXTLINE\nvoid ABSL_TARGET_CRYPTO RandenHwAes::Generate(const void* keys_void,\n                                              void* state_void) {\n  static_assert(RandenTraits::kCapacityBytes == sizeof(Vector128),\n                \"Capacity mismatch\");\n\n  auto* state = reinterpret_cast<absl::uint128*>(state_void);\n  const auto* keys = reinterpret_cast<const absl::uint128*>(keys_void);\n\n  const Vector128 prev_inner = Vector128Load(state);\n\n  SwapEndian(state);\n\n  Permute(state, keys);\n\n  SwapEndian(state);\n\n  // Ensure backtracking resistance.\n  Vector128 inner = Vector128Load(state);\n  inner ^= prev_inner;\n  Vector128Store(inner, state);\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n}",
  "id": "BLOCK-CPP-02826",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/randen_hwaes.cc",
  "source_line": 406,
  "validation_status": "validated"
}