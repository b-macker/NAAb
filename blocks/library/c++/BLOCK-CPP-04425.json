{
  "code": "#include <sys/time.h>\n#include <chrono>  // NOLINT(build/c++11)\n#include <cmath>\n#include <cstdint>\n#include <ctime>\n#include <limits>\n#include <ostream>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/config.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/time/civil_time.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace time_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04425_execute() {\n    {\n   public:\n    // Default constructor default-initializes `hi_`, which has the same\n    // semantics as default-initializing an `int64_t` (undetermined value).\n    HiRep() = default;\n\n    HiRep(const HiRep&) = default;\n    HiRep& operator=(const HiRep&) = default;\n\n    explicit constexpr HiRep(const int64_t value)\n        :  // C++17 forbids default-initialization in constexpr contexts. We can\n           // remove this in C++20.\n#if defined(ABSL_IS_BIG_ENDIAN) && ABSL_IS_BIG_ENDIAN\n          hi_(0),\n          lo_(0)\n#else\n          lo_(0),\n          hi_(0)\n#endif\n    {\n      *this = value;\n    }\n\n    constexpr int64_t Get() const {\n      const uint64_t unsigned_value =\n          (static_cast<uint64_t>(hi_) << 32) | static_cast<uint64_t>(lo_);\n      // `static_cast<int64_t>(unsigned_value)` is implementation-defined\n      // before c++20. On all supported platforms the behaviour is that mandated\n      // by c++20, i.e. \"If the destination type is signed, [...] the result is\n      // the unique value of the destination type equal to the source value\n      // modulo 2^n, where n is the number of bits used to represent the\n      // destination type.\"\n      static_assert(\n          (static_cast<int64_t>((std::numeric_limits<uint64_t>::max)()) ==\n           int64_t{-1}) &&\n              (static_cast<int64_t>(static_cast<uint64_t>(\n                                        (std::numeric_limits<int64_t>::max)()) +\n                                    1) ==\n               (std::numeric_limits<int64_t>::min)()),\n          \"static_cast<int64_t>(uint64_t) does not have c++20 semantics\");\n      return static_cast<int64_t>(unsigned_value);\n    }\n\n    constexpr HiRep& operator=(const int64_t value) {\n      // \"If the destination type is unsigned, the resulting value is the\n      // smallest unsigned value equal to the source value modulo 2^n\n      // where `n` is the number of bits used to represent the destination\n      // type\".\n      const auto unsigned_value = static_cast<uint64_t>(value);\n      hi_ = static_cast<uint32_t>(unsigned_value >> 32);\n      lo_ = static_cast<uint32_t>(unsigned_value);\n      return *this;\n    }\n\n   private:\n    // Notes:\n    //  - Ideally we would use a `char[]` and `std::bitcast`, but the latter\n    //    does not exist (and is not constexpr in `absl`) before c++20.\n    //  - Order is optimized depending on endianness so that the compiler can\n    //    turn `Get()` (resp. `operator=()`) into a single 8-byte load (resp.\n    //    store).\n#if defined(ABSL_IS_BIG_ENDIAN) && ABSL_IS_BIG_ENDIAN\n    uint32_t hi_;\n    uint32_t lo_;\n#else\n    uint32_t lo_;\n    uint32_t hi_;\n#endif\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04425",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 235,
  "validation_status": "validated"
}