{
  "code": "{\n  using field_type = typename Node::field_type;\n  using key_type = typename Node::key_type;\n  using size_type = typename Node::size_type;\n  using params_type = typename Node::params_type;\n  using is_map_container = typename params_type::is_map_container;\n\n  using node_type = Node;\n  using normal_node = typename std::remove_const<Node>::type;\n  using const_node = const Node;\n  using normal_pointer = typename params_type::pointer;\n  using normal_reference = typename params_type::reference;\n  using const_pointer = typename params_type::const_pointer;\n  using const_reference = typename params_type::const_reference;\n  using slot_type = typename params_type::slot_type;\n\n  // In sets, all iterators are const.\n  using iterator = absl::conditional_t<\n      is_map_container::value,\n      btree_iterator<normal_node, normal_reference, normal_pointer>,\n      btree_iterator<normal_node, const_reference, const_pointer>>;\n  using const_iterator =\n      btree_iterator<const_node, const_reference, const_pointer>;\n\n public:\n  // These aliases are public for std::iterator_traits.\n  using difference_type = typename Node::difference_type;\n  using value_type = typename params_type::value_type;\n  using pointer = Pointer;\n  using reference = Reference;\n  using iterator_category = std::bidirectional_iterator_tag;\n\n  btree_iterator() : btree_iterator(nullptr, -1) {}\n  explicit btree_iterator(Node *n) : btree_iterator(n, n->start()) {}\n  btree_iterator(Node *n, int p)\n      : btree_iterator_generation_info(n != nullptr ? n->generation()\n                                                    : ~uint32_t{}),\n        node_(n),\n        position_(p) {}\n\n  // NOTE: this SFINAE allows for implicit conversions from iterator to\n  // const_iterator, but it specifically avoids hiding the copy constructor so\n  // that the trivial one will be used when possible.\n  template <typename N, typename R, typename P,\n            absl::enable_if_t<\n                std::is_same<btree_iterator<N, R, P>, iterator>::value &&\n                    std::is_same<btree_iterator, const_iterator>::value,\n                int> = 0>\n  btree_iterator(const btree_iterator<N, R, P> other)  // NOLINT\n      : btree_iterator_generation_info(other),\n        node_(other.node_),\n        position_(other.position_) {}\n\n  bool operator==(const iterator &other) const {\n    return Equals(other);\n  }\n  bool operator==(const const_iterator &other) const {\n    return Equals(other);\n  }\n  bool operator!=(const iterator &other) const {\n    return !Equals(other);\n  }\n  bool operator!=(const const_iterator &other) const {\n    return !Equals(other);\n  }\n\n  // Returns n such that n calls to ++other yields *this.\n  // Precondition: n exists.\n  difference_type operator-(const_iterator other) const {\n    if (node_ == other.node_) {\n      if (node_->is_leaf()) return position_ - other.position_;\n      if (position_ == other.position_) return 0;\n    }\n    return distance_slow(other);\n  }\n\n  // Accessors for the key/value the iterator is pointing at.\n  reference operator*() const {\n    ABSL_HARDENING_ASSERT(node_ != nullptr);\n    assert_valid_generation(node_);\n    ABSL_HARDENING_ASSERT(position_ >= node_->start());\n    if (position_ >= node_->finish()) {\n      ABSL_HARDENING_ASSERT(!IsEndIterator() && \"Dereferencing end() iterator\");\n      ABSL_HARDENING_ASSERT(position_ < node_->finish());\n    }\n    return node_->value(static_cast<field_type>(position_));\n  }\n  pointer operator->() const { return &operator*(); }\n\n  btree_iterator &operator++() {\n    increment();\n    return *this;\n  }\n  btree_iterator &operator--() {\n    decrement();\n    return *this;\n  }\n  btree_iterator operator++(int) {\n    btree_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n  btree_iterator operator--(int) {\n    btree_iterator tmp = *this;\n    --*this;\n    return tmp;\n  }\n\n private:\n  friend iterator;\n  friend const_iterator;\n  template <typename Params>\n  friend class btree;\n  template <typename Tree>\n  friend class btree_container;\n  template <typename Tree>\n  friend class btree_set_container;\n  template <typename Tree>\n  friend class btree_map_container;\n  template <typename Tree>\n  friend class btree_multiset_container;\n  template <typename TreeType, typename CheckerType>\n  friend class base_checker;\n  friend struct btree_access;\n\n  // This SFINAE allows explicit conversions from const_iterator to\n  // iterator, but also avoids hiding the copy constructor.\n  // NOTE: the const_cast is safe because this constructor is only called by\n  // non-const methods and the container owns the nodes.\n  template <typename N, typename R, typename P,\n            absl::enable_if_t<\n                std::is_same<btree_iterator<N, R, P>, const_iterator>::value &&\n                    std::is_same<btree_iterator, iterator>::value,\n                int> = 0>\n  explicit btree_iterator(const btree_iterator<N, R, P> other)\n      : btree_iterator_generation_info(other.generation()),\n        node_(const_cast<node_type *>(other.node_)),\n        position_(other.position_) {}\n\n  bool Equals(const const_iterator other) const {\n    ABSL_HARDENING_ASSERT(((node_ == nullptr && other.node_ == nullptr) ||\n                           (node_ != nullptr && other.node_ != nullptr)) &&\n                          \"Comparing default-constructed iterator with \"\n                          \"non-default-constructed iterator.\");\n    // Note: we use assert instead of ABSL_HARDENING_ASSERT here because this\n    // changes the complexity of Equals from O(1) to O(log(N) + log(M)) where\n    // N/M are sizes of the containers containing node_/other.node_.\n    assert(AreNodesFromSameContainer(node_, other.node_) &&\n           \"Comparing iterators from different containers.\");\n    assert_valid_generation(node_);\n    other.assert_valid_generation(other.node_);\n    return node_ == other.node_ && position_ == other.position_;\n  }\n\n  bool IsEndIterator() const {\n    if (position_ != node_->finish()) return false;\n    node_type *node = node_;\n    while (!node->is_root()) {\n      if (node->position() != node->parent()->finish()) return false;\n      node = node->parent();\n    }\n    return true;\n  }\n\n  // Returns n such that n calls to ++other yields *this.\n  // Precondition: n exists && (this->node_ != other.node_ ||\n  // !this->node_->is_leaf() || this->position_ != other.position_).\n  difference_type distance_slow(const_iterator other) const;\n\n  // Increment/decrement the iterator.\n  void increment() {\n    assert_valid_generation(node_);\n    if (node_->is_leaf() && ++position_ < node_->finish()) {\n      return;\n    }\n    increment_slow();\n  }\n  void increment_slow();\n\n  void decrement() {\n    assert_valid_generation(node_);\n    if (node_->is_leaf() && --position_ >= node_->start()) {\n      return;\n    }\n    decrement_slow();\n  }\n  void decrement_slow();\n\n  const key_type &key() const {\n    return node_->key(static_cast<size_type>(position_));\n  }\n  decltype(std::declval<Node *>()->slot(0)) slot() {\n    return node_->slot(static_cast<size_type>(position_));\n  }\n\n  void update_generation() {\n    btree_iterator_generation_info::update_generation(node_);\n  }\n\n  // The node in the tree the iterator is pointing at.\n  Node *node_;\n  // The position within the node of the tree the iterator is pointing at.\n  // NOTE: this is an int rather than a field_type because iterators can point\n  // to invalid positions (such as -1) in certain circumstances.\n  int position_;\n}",
  "id": "BLOCK-CPP-04879",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree.h",
  "source_line": 1108,
  "validation_status": "validated"
}