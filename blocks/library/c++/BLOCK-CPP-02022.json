{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n\n// ----------------------------------------------------------------------\n// StrCat()\n//    This merges the given strings or integers, with no delimiter. This\n//    is designed to be the fastest possible way to construct a string out\n//    of a mix of raw C strings, string_views, strings, and integer values.\n// ----------------------------------------------------------------------\n\nnamespace {\n// Append is merely a version of memcpy that returns the address of the byte\n// after the area just overwritten.\nabsl::Nonnull<char*> Append(absl::Nonnull<char*> out, const AlphaNum& x) {\n  // memcpy is allowed to overwrite arbitrary memory, so doing this after the\n  // call would force an extra fetch of x.size().\n  char* after = out + x.size();\n  if (x.size() != 0) {\n    memcpy(out, x.data(), x.size());\n  }\n  return after;\n}\n\n}  // namespace\n\nstd::string StrCat(const AlphaNum& a, const AlphaNum& b) {\n  std::string result;\n  absl::strings_internal::STLStringResizeUninitialized(&result,\n                                                       a.size() + b.size());\n  char* const begin = &result[0];\n  char* out = begin;\n  out = Append(out, a);\n  out = Append(out, b);\n  assert(out == begin + result.size());\n  return result;\n}\n\nstd::string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c) {\n  std::string result;\n  strings_internal::STLStringResizeUninitialized(\n      &result, a.size() + b.size() + c.size());\n  char* const begin = &result[0];\n  char* out = begin;\n  out = Append(out, a);\n  out = Append(out, b);\n  out = Append(out, c);\n  assert(out == begin + result.size());\n  return result;\n}\n\nstd::string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c,\n                   const AlphaNum& d) {\n  std::string result;\n  strings_internal::STLStringResizeUninitialized(\n      &result, a.size() + b.size() + c.size() + d.size());\n  char* const begin = &result[0];\n  char* out = begin;\n  out = Append(out, a);\n  out = Append(out, b);\n  out = Append(out, c);\n  out = Append(out, d);\n  assert(out == begin + result.size());\n  return result;\n}\n\nnamespace strings_internal {\n\n// Do not call directly - these are not part of the public API.\nvoid STLStringAppendUninitializedAmortized(std::string* dest,\n                                           size_t to_append) {\n  strings_internal::AppendUninitializedTraits<std::string>::Append(dest,\n                                                                   to_append);\n}\n\ntemplate <typename Integer>\nstd::enable_if_t<std::is_integral<Integer>::value, std::string> IntegerToString(\n    Integer i) {\n  std::string str;\n  const auto /* either bool or std::false_type */ is_negative =\n      absl::numbers_internal::IsNegative(i);\n  const uint32_t digits = absl::numbers_internal::Base10Digits(\n      absl::numbers_internal::UnsignedAbsoluteValue(i));\n  absl::strings_internal::STLStringResizeUninitialized(\n      &str, digits + static_cast<uint32_t>(is_negative));\n  absl::numbers_internal::FastIntToBufferBackward(i, &str[str.size()], digits);\n  return str;\n}\n\ntemplate <>\nstd::string IntegerToString(long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(int)) {\n    return IntegerToString(static_cast<int>(i));\n  } else {\n    return IntegerToString(static_cast<long long>(i));  // NOLINT\n  }\n}\n\ntemplate <>\nstd::string IntegerToString(unsigned long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(unsigned int)) {\n    return IntegerToString(static_cast<unsigned int>(i));\n  } else {\n    return IntegerToString(static_cast<unsigned long long>(i));  // NOLINT\n  }\n}\n\ntemplate <typename Float>\nstd::enable_if_t<std::is_floating_point<Float>::value, std::string>\nFloatToString(Float f) {\n  std::string result;\n  strings_internal::STLStringResizeUninitialized(\n      &result, numbers_internal::kSixDigitsToBufferSize);\n  char* start = &result[0];\n  result.erase(numbers_internal::SixDigitsToBuffer(f, start));\n  return result;\n}\n\nstd::string SingleArgStrCat(int x) { return IntegerToString(x); }\nstd::string SingleArgStrCat(unsigned int x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(unsigned long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(long long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(unsigned long long x) { return IntegerToString(x); }\nstd::string SingleArgStrCat(float x) { return FloatToString(x); }\nstd::string SingleArgStrCat(double x) { return FloatToString(x); }\n\ntemplate <class Integer>\nstd::enable_if_t<std::is_integral<Integer>::value, void> AppendIntegerToString(\n    std::string& str, Integer i) {\n  const auto /* either bool or std::false_type */ is_negative =\n      absl::numbers_internal::IsNegative(i);\n  const uint32_t digits = absl::numbers_internal::Base10Digits(\n      absl::numbers_internal::UnsignedAbsoluteValue(i));\n  absl::strings_internal::STLStringAppendUninitializedAmortized(\n      &str, digits + static_cast<uint32_t>(is_negative));\n  absl::numbers_internal::FastIntToBufferBackward(i, &str[str.size()], digits);\n}\n\ntemplate <>\nvoid AppendIntegerToString(std::string& str, long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(int)) {\n    return AppendIntegerToString(str, static_cast<int>(i));\n  } else {\n    return AppendIntegerToString(str, static_cast<long long>(i));  // NOLINT\n  }\n}\n\ntemplate <>\nvoid AppendIntegerToString(std::string& str,\n                           unsigned long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(unsigned int)) {\n    return AppendIntegerToString(str, static_cast<unsigned int>(i));\n  } else {\n    return AppendIntegerToString(str,\n                                 static_cast<unsigned long long>(i));  // NOLINT\n  }\n}\n\n// `SingleArgStrAppend` overloads are defined here for the same reasons as with\n// `SingleArgStrCat` above.\nvoid SingleArgStrAppend(std::string& str, int x) {\n  return AppendIntegerToString(str, x);\n}\n\nvoid SingleArgStrAppend(std::string& str, unsigned int x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, unsigned long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, long long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, unsigned long long x) {\n  return AppendIntegerToString(str, x);\n}\n\nstd::string CatPieces(std::initializer_list<absl::string_view> pieces) {\n  std::string result;\n  size_t total_size = 0;\n  for (absl::string_view piece : pieces) total_size += piece.size();\n  strings_internal::STLStringResizeUninitialized(&result, total_size);\n\n  char* const begin = &result[0];\n  char* out = begin;\n  for (absl::string_view piece : pieces) {\n    const size_t this_size = piece.size();\n    if (this_size != 0) {\n      memcpy(out, piece.data(), this_size);\n      out += this_size;\n    }\n  }\n  assert(out == begin + result.size());\n  return result;\n}\n\n// It's possible to call StrAppend with an absl::string_view that is itself a\n// fragment of the string we're appending to.  However the results of this are\n// random. Therefore, check for this in debug mode.  Use unsigned math so we\n// only have to do one comparison. Note, there's an exception case: appending an\n// empty string is always allowed.\n#define ASSERT_NO_OVERLAP(dest, src) \\\n  assert(((src).size() == 0) ||      \\\n         (uintptr_t((src).data() - (dest).data()) > uintptr_t((dest).size())))\n\nvoid AppendPieces(absl::Nonnull<std::string*> dest,\n                  std::initializer_list<absl::string_view> pieces) {\n  size_t old_size = dest->size();\n  size_t to_append = 0;\n  for (absl::string_view piece : pieces) {\n    ASSERT_NO_OVERLAP(*dest, piece);\n    to_append += piece.size();\n  }\n  strings_internal::STLStringAppendUninitializedAmortized(dest, to_append);\n\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  for (absl::string_view piece : pieces) {\n    const size_t this_size = piece.size();\n    if (this_size != 0) {\n      memcpy(out, piece.data(), this_size);\n      out += this_size;\n    }\n  }\n  assert(out == begin + dest->size());\n}\n\n}  // namespace strings_internal\n\nvoid StrAppend(absl::Nonnull<std::string*> dest, const AlphaNum& a) {\n  ASSERT_NO_OVERLAP(*dest, a);\n  std::string::size_type old_size = dest->size();\n  strings_internal::STLStringAppendUninitializedAmortized(dest, a.size());\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  out = Append(out, a);\n  assert(out == begin + dest->size());\n}\n\nvoid StrAppend(absl::Nonnull<std::string*> dest, const AlphaNum& a,\n               const AlphaNum& b) {\n  ASSERT_NO_OVERLAP(*dest, a);\n  ASSERT_NO_OVERLAP(*dest, b);\n  std::string::size_type old_size = dest->size();\n  strings_internal::STLStringAppendUninitializedAmortized(dest,\n                                                          a.size() + b.size());\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  out = Append(out, a);\n  out = Append(out, b);\n  assert(out == begin + dest->size());\n}\n\nvoid StrAppend(absl::Nonnull<std::string*> dest, const AlphaNum& a,\n               const AlphaNum& b, const AlphaNum& c) {\n  ASSERT_NO_OVERLAP(*dest, a);\n  ASSERT_NO_OVERLAP(*dest, b);\n  ASSERT_NO_OVERLAP(*dest, c);\n  std::string::size_type old_size = dest->size();\n  strings_internal::STLStringAppendUninitializedAmortized(\n      dest, a.size() + b.size() + c.size());\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  out = Append(out, a);\n  out = Append(out, b);\n  out = Append(out, c);\n  assert(out == begin + dest->size());\n}\n\nvoid StrAppend(absl::Nonnull<std::string*> dest, const AlphaNum& a,\n               const AlphaNum& b, const AlphaNum& c, const AlphaNum& d) {\n  ASSERT_NO_OVERLAP(*dest, a);\n  ASSERT_NO_OVERLAP(*dest, b);\n  ASSERT_NO_OVERLAP(*dest, c);\n  ASSERT_NO_OVERLAP(*dest, d);\n  std::string::size_type old_size = dest->size();\n  strings_internal::STLStringAppendUninitializedAmortized(\n      dest, a.size() + b.size() + c.size() + d.size());\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  out = Append(out, a);\n  out = Append(out, b);\n  out = Append(out, c);\n  out = Append(out, d);\n  assert(out == begin + dest->size());\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02022",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.cc",
  "source_line": 32,
  "validation_status": "validated"
}