{
  "code": "{\n\nclass Decl;\nstruct DeducedPack;\nclass Sema;\n\nnamespace sema {\n\n/// Provides information about an attempted template argument\n/// deduction, whose success or failure was described by a\n/// TemplateDeductionResult value.\nclass TemplateDeductionInfo {\n  /// The deduced template argument list.\n  TemplateArgumentList *DeducedSugared = nullptr, *DeducedCanonical = nullptr;\n\n  /// The source location at which template argument\n  /// deduction is occurring.\n  SourceLocation Loc;\n\n  /// Have we suppressed an error during deduction?\n  bool HasSFINAEDiagnostic = false;\n\n  /// The template parameter depth for which we're performing deduction.\n  unsigned DeducedDepth;\n\n  /// The number of parameters with explicitly-specified template arguments,\n  /// up to and including the partially-specified pack (if any).\n  unsigned ExplicitArgs = 0;\n\n  /// Warnings (and follow-on notes) that were suppressed due to\n  /// SFINAE while performing template argument deduction.\n  SmallVector<PartialDiagnosticAt, 4> SuppressedDiagnostics;\n\npublic:\n  TemplateDeductionInfo(SourceLocation Loc, unsigned DeducedDepth = 0)\n      : Loc(Loc), DeducedDepth(DeducedDepth) {}\n  TemplateDeductionInfo(const TemplateDeductionInfo &) = delete;\n  TemplateDeductionInfo &operator=(const TemplateDeductionInfo &) = delete;\n\n  enum ForBaseTag { ForBase };\n  /// Create temporary template deduction info for speculatively deducing\n  /// against a base class of an argument's type.\n  TemplateDeductionInfo(ForBaseTag, const TemplateDeductionInfo &Info)\n      : DeducedSugared(Info.DeducedSugared), Loc(Info.Loc),\n        DeducedDepth(Info.DeducedDepth), ExplicitArgs(Info.ExplicitArgs) {}\n\n  /// Returns the location at which template argument is\n  /// occurring.\n  SourceLocation getLocation() const {\n    return Loc;\n  }\n\n  /// The depth of template parameters for which deduction is being\n  /// performed.\n  unsigned getDeducedDepth() const {\n    return DeducedDepth;\n  }\n\n  /// Get the number of explicitly-specified arguments.\n  unsigned getNumExplicitArgs() const {\n    return ExplicitArgs;\n  }\n\n  /// Take ownership of the deduced template argument lists.\n  TemplateArgumentList *takeSugared() {\n    TemplateArgumentList *Result = DeducedSugared;\n    DeducedSugared = nullptr;\n    return Result;\n  }\n  TemplateArgumentList *takeCanonical() {\n    TemplateArgumentList *Result = DeducedCanonical;\n    DeducedCanonical = nullptr;\n    return Result;\n  }\n\n  /// Take ownership of the SFINAE diagnostic.\n  void takeSFINAEDiagnostic(PartialDiagnosticAt &PD) {\n    assert(HasSFINAEDiagnostic);\n    PD.first = SuppressedDiagnostics.front().first;\n    PD.second.swap(SuppressedDiagnostics.front().second);\n    clearSFINAEDiagnostic();\n  }\n\n  /// Discard any SFINAE diagnostics.\n  void clearSFINAEDiagnostic() {\n    SuppressedDiagnostics.clear();\n    HasSFINAEDiagnostic = false;\n  }\n\n  /// Peek at the SFINAE diagnostic.\n  const PartialDiagnosticAt &peekSFINAEDiagnostic() const {\n    assert(HasSFINAEDiagnostic);\n    return SuppressedDiagnostics.front();\n  }\n\n  /// Provide an initial template argument list that contains the\n  /// explicitly-specified arguments.\n  void setExplicitArgs(TemplateArgumentList *NewDeducedSugared,\n                       TemplateArgumentList *NewDeducedCanonical) {\n    assert(NewDeducedSugared->size() == NewDeducedCanonical->size());\n    DeducedSugared = NewDeducedSugared;\n    DeducedCanonical = NewDeducedCanonical;\n    ExplicitArgs = DeducedSugared->size();\n  }\n\n  /// Provide a new template argument list that contains the\n  /// results of template argument deduction.\n  void reset(TemplateArgumentList *NewDeducedSugared,\n             TemplateArgumentList *NewDeducedCanonical) {\n    DeducedSugared = NewDeducedSugared;\n    DeducedCanonical = NewDeducedCanonical;\n  }\n\n  /// Is a SFINAE diagnostic available?\n  bool hasSFINAEDiagnostic() const {\n    return HasSFINAEDiagnostic;\n  }\n\n  /// Set the diagnostic which caused the SFINAE failure.\n  void addSFINAEDiagnostic(SourceLocation Loc, PartialDiagnostic PD) {\n    // Only collect the first diagnostic.\n    if (HasSFINAEDiagnostic)\n      return;\n    SuppressedDiagnostics.clear();\n    SuppressedDiagnostics.emplace_back(Loc, std::move(PD));\n    HasSFINAEDiagnostic = true;\n  }\n\n  /// Add a new diagnostic to the set of diagnostics\n  void addSuppressedDiagnostic(SourceLocation Loc,\n                               PartialDiagnostic PD) {\n    if (HasSFINAEDiagnostic)\n      return;\n    SuppressedDiagnostics.emplace_back(Loc, std::move(PD));\n  }\n\n  /// Iterator over the set of suppressed diagnostics.\n  using diag_iterator = SmallVectorImpl<PartialDiagnosticAt>::const_iterator;\n\n  /// Returns an iterator at the beginning of the sequence of suppressed\n  /// diagnostics.\n  diag_iterator diag_begin() const { return SuppressedDiagnostics.begin(); }\n\n  /// Returns an iterator at the end of the sequence of suppressed\n  /// diagnostics.\n  diag_iterator diag_end() const { return SuppressedDiagnostics.end(); }\n\n  /// The template parameter to which a template argument\n  /// deduction failure refers.\n  ///\n  /// Depending on the result of template argument deduction, this\n  /// template parameter may have different meanings:\n  ///\n  ///   TDK_Incomplete: this is the first template parameter whose\n  ///   corresponding template argument was not deduced.\n  ///\n  ///   TDK_IncompletePack: this is the expanded parameter pack for\n  ///   which we deduced too few arguments.\n  ///\n  ///   TDK_Inconsistent: this is the template parameter for which\n  ///   two different template argument values were deduced.\n  TemplateParameter Param;\n\n  /// The first template argument to which the template\n  /// argument deduction failure refers.\n  ///\n  /// Depending on the result of the template argument deduction,\n  /// this template argument may have different meanings:\n  ///\n  ///   TDK_IncompletePack: this is the number of arguments we deduced\n  ///   for the pack.\n  ///\n  ///   TDK_Inconsistent: this argument is the first value deduced\n  ///   for the corresponding template parameter.\n  ///\n  ///   TDK_SubstitutionFailure: this argument is the template\n  ///   argument we were instantiating when we encountered an error.\n  ///\n  ///   TDK_DeducedMismatch: this is the parameter type, after substituting\n  ///   deduced arguments.\n  ///\n  ///   TDK_NonDeducedMismatch: this is the component of the 'parameter'\n  ///   of the deduction, directly provided in the source code.\n  TemplateArgument FirstArg;\n\n  /// The second template argument to which the template\n  /// argument deduction failure refers.\n  ///\n  ///   TDK_Inconsistent: this argument is the second value deduced\n  ///   for the corresponding template parameter.\n  ///\n  ///   TDK_DeducedMismatch: this is the (adjusted) call argument type.\n  ///\n  ///   TDK_NonDeducedMismatch: this is the mismatching component of the\n  ///   'argument' of the deduction, from which we are deducing arguments.\n  ///\n  /// FIXME: Finish documenting this.\n  TemplateArgument SecondArg;\n\n  /// The index of the function argument that caused a deduction\n  /// failure.\n  ///\n  ///   TDK_DeducedMismatch: this is the index of the argument that had a\n  ///   different argument type from its substituted parameter type.\n  unsigned CallArgIndex = 0;\n\n  // C++20 [over.match.class.deduct]p5.2:\n  //   During template argument deduction for the aggregate deduction\n  //   candidate, the number of elements in a trailing parameter pack is only\n  //   deduced from the number of remaining function arguments if it is not\n  //   otherwise deduced.\n  bool AggregateDeductionCandidateHasMismatchedArity = false;\n\n  /// Information on packs that we're currently expanding.\n  ///\n  /// FIXME: This should be kept internal to SemaTemplateDeduction.\n  SmallVector<DeducedPack *, 8> PendingDeducedPacks;\n\n  /// \\brief The constraint satisfaction details resulting from the associated\n  /// constraints satisfaction tests.\n  ConstraintSatisfaction AssociatedConstraintsSatisfaction;\n};\n\n} // namespace sema\n\n/// A structure used to record information about a failed\n/// template argument deduction, for diagnosis.\nstruct DeductionFailureInfo {\n  /// A Sema::TemplateDeductionResult.\n  unsigned Result : 8;\n\n  /// Indicates whether a diagnostic is stored in Diagnostic.\n  unsigned HasDiagnostic : 1;\n\n  /// Opaque pointer containing additional data about\n  /// this deduction failure.\n  void *Data;\n\n  /// A diagnostic indicating why deduction failed.\n  alignas(PartialDiagnosticAt) char Diagnostic[sizeof(PartialDiagnosticAt)];\n\n  /// Retrieve the diagnostic which caused this deduction failure,\n  /// if any.\n  PartialDiagnosticAt *getSFINAEDiagnostic();\n\n  /// Retrieve the template parameter this deduction failure\n  /// refers to, if any.\n  TemplateParameter getTemplateParameter();\n\n  /// Retrieve the template argument list associated with this\n  /// deduction failure, if any.\n  TemplateArgumentList *getTemplateArgumentList();\n\n  /// Return the first template argument this deduction failure\n  /// refers to, if any.\n  const TemplateArgument *getFirstArg();\n\n  /// Return the second template argument this deduction failure\n  /// refers to, if any.\n  const TemplateArgument *getSecondArg();\n\n  /// Return the index of the call argument that this deduction\n  /// failure refers to, if any.\n  std::optional<unsigned> getCallArgIndex();\n\n  /// Free any memory associated with this deduction failure.\n  void Destroy();\n};\n\n/// TemplateSpecCandidate - This is a generalization of OverloadCandidate\n/// which keeps track of template argument deduction failure info, when\n/// handling explicit specializations (and instantiations) of templates\n/// beyond function overloading.\n/// For now, assume that the candidates are non-matching specializations.\n/// TODO: In the future, we may need to unify/generalize this with\n/// OverloadCandidate.\nstruct TemplateSpecCandidate {\n  /// The declaration that was looked up, together with its access.\n  /// Might be a UsingShadowDecl, but usually a FunctionTemplateDecl.\n  DeclAccessPair FoundDecl;\n\n  /// Specialization - The actual specialization that this candidate\n  /// represents. When NULL, this may be a built-in candidate.\n  Decl *Specialization;\n\n  /// Template argument deduction info\n  DeductionFailureInfo DeductionFailure;\n\n  void set(DeclAccessPair Found, Decl *Spec, DeductionFailureInfo Info) {\n    FoundDecl = Found;\n    Specialization = Spec;\n    DeductionFailure = Info;\n  }\n\n  /// Diagnose a template argument deduction failure.\n  void NoteDeductionFailure(Sema &S, bool ForTakingAddress);\n};\n\n/// TemplateSpecCandidateSet - A set of generalized overload candidates,\n/// used in template specializations.\n/// TODO: In the future, we may need to unify/generalize this with\n/// OverloadCandidateSet.\nclass TemplateSpecCandidateSet {\n  SmallVector<TemplateSpecCandidate, 16> Candidates;\n  SourceLocation Loc;\n\n  // Stores whether we're taking the address of these candidates. This helps us\n  // produce better error messages when dealing with the pass_object_size\n  // attribute on parameters.\n  bool ForTakingAddress;\n\n  void destroyCandidates();\n\npublic:\n  TemplateSpecCandidateSet(SourceLocation Loc, bool ForTakingAddress = false)\n      : Loc(Loc), ForTakingAddress(ForTakingAddress) {}\n  TemplateSpecCandidateSet(const TemplateSpecCandidateSet &) = delete;\n  TemplateSpecCandidateSet &\n  operator=(const TemplateSpecCandidateSet &) = delete;\n  ~TemplateSpecCandidateSet() { destroyCandidates(); }\n\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Clear out all of the candidates.\n  /// TODO: This may be unnecessary.\n  void clear();\n\n  using iterator = SmallVector<TemplateSpecCandidate, 16>::iterator;\n\n  iterator begin() { return Candidates.begin(); }\n  iterator end() { return Candidates.end(); }\n\n  size_t size() const { return Candidates.size(); }\n  bool empty() const { return Candidates.empty(); }\n\n  /// Add a new candidate with NumConversions conversion sequence slots\n  /// to the overload set.\n  TemplateSpecCandidate &addCandidate() {\n    Candidates.emplace_back();\n    return Candidates.back();\n  }\n\n  void NoteCandidates(Sema &S, SourceLocation Loc);\n\n  void NoteCandidates(Sema &S, SourceLocation Loc) const {\n    const_cast<TemplateSpecCandidateSet *>(this)->NoteCandidates(S, Loc);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-20724",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/TemplateDeduction.h",
  "source_line": 31,
  "validation_status": "validated"
}