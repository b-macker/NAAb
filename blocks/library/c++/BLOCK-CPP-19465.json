{
  "code": "#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <optional>\n#include <string>\n#include <utility>\n    /// Code completion inside the filename part of a #include directive.\n\nusing namespace clang;\nusing namespace or;\nusing namespace or;\nusing namespace clang;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-19465_execute() {\n    {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template, arguments are being completed.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType,\n\n      /// The candidate is a variable or expression of function type\n      /// for which we have the location of the prototype declaration.\n      CK_FunctionProtoTypeLoc,\n\n      /// The candidate is a template, template arguments are being completed.\n      CK_Template,\n\n      /// The candidate is aggregate initialization of a record type.\n      CK_Aggregate,\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n\n      /// The location of the function prototype that describes the entity being\n      /// called, when Kind == CK_FunctionProtoTypeLoc.\n      FunctionProtoTypeLoc ProtoTypeLoc;\n\n      /// The template overload candidate, available when\n      /// Kind == CK_Template.\n      const TemplateDecl *Template;\n\n      /// The class being aggregate-initialized,\n      /// when Kind == CK_Aggregate\n      const RecordDecl *AggregateType;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {\n      assert(Function != nullptr);\n    }\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {\n      assert(FunctionTemplateDecl != nullptr);\n    }\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {\n      assert(Type != nullptr);\n    }\n\n    OverloadCandidate(FunctionProtoTypeLoc Prototype)\n        : Kind(CK_FunctionProtoTypeLoc), ProtoTypeLoc(Prototype) {\n      assert(!Prototype.isNull());\n    }\n\n    OverloadCandidate(const RecordDecl *Aggregate)\n        : Kind(CK_Aggregate), AggregateType(Aggregate) {\n      assert(Aggregate != nullptr);\n    }\n\n    OverloadCandidate(const TemplateDecl *Template)\n        : Kind(CK_Template), Template(Template) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Retrieve the function ProtoTypeLoc candidate.\n    /// This can be called for any Kind, but returns null for kinds\n    /// other than CK_FunctionProtoTypeLoc.\n    const FunctionProtoTypeLoc getFunctionProtoTypeLoc() const;\n\n    const TemplateDecl *getTemplate() const {\n      assert(getKind() == CK_Template && \"Not a template\");\n      return Template;\n    }\n\n    /// Retrieve the aggregate type being initialized.\n    const RecordDecl *getAggregate() const {\n      assert(getKind() == CK_Aggregate);\n      return AggregateType;\n    }\n\n    /// Get the number of parameters in this signature.\n    unsigned getNumParams() const;\n\n    /// Get the type of the Nth parameter.\n    /// Returns null if the type is unknown or N is out of range.\n    QualType getParamType(unsigned N) const;\n\n    /// Get the declaration of the Nth parameter.\n    /// Returns null if the decl is unknown or N is out of range.\n    const NamedDecl *getParamDecl(unsigned N) const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *\n    CreateSignatureString(unsigned CurrentArg, Sema &S,\n                          CodeCompletionAllocator &Allocator,\n                          CodeCompletionTUInfo &CCTUInfo,\n                          bool IncludeBriefComments, bool Braced) const;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-19465",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/CodeCompleteConsumer.h",
  "source_line": 1017,
  "validation_status": "validated"
}