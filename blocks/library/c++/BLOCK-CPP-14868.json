{
  "code": "{\n///     int i = 1 + t;\n///   }\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType() matches the type of 't' but not '1'\nextern const AstTypeMatcher<SubstTemplateTypeParmType>\n    substTemplateTypeParmType;\n\n/// Matches template type parameter substitutions that have a replacement\n/// type that matches the provided matcher.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   double F(T t);\n///   int i;\n///   double j = F(i);\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType(hasReplacementType(type())) matches int\nAST_TYPE_TRAVERSE_MATCHER(\n    hasReplacementType, getReplacementType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(SubstTemplateTypeParmType));\n\n/// Matches template type parameter types.\n///\n/// Example matches T, but not int.\n///     (matcher = templateTypeParmType())\n/// \\code\n///   template <typename T> void f(int i);\n/// \\endcode\nextern const AstTypeMatcher<TemplateTypeParmType> templateTypeParmType;\n\n/// Matches injected class name types.\n///\n/// Example matches S s, but not S<T> s.\n///     (matcher = parmVarDecl(hasType(injectedClassNameType())))\n/// \\code\n///   template <typename T> struct S {\n///     void f(S s);\n///     void g(S<T> s);\n///   };\n/// \\endcode\nextern const AstTypeMatcher<InjectedClassNameType> injectedClassNameType;\n\n/// Matches decayed type\n/// Example matches i[] in declaration of f.\n///     (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType())))))\n/// Example matches i[1].\n///     (matcher = expr(hasType(decayedType(hasDecayedType(pointerType())))))\n/// \\code\n///   void f(int i[]) {\n///     i[1] = 0;\n///   }\n/// \\endcode\nextern const AstTypeMatcher<DecayedType> decayedType;\n\n/// Matches the decayed type, whoes decayed type matches \\c InnerMatcher\nAST_MATCHER_P(DecayedType, hasDecayedType, internal::Matcher<QualType>,\n              InnerType) {\n  return InnerType.matches(Node.getDecayedType(), Finder, Builder);\n}\n\n/// Matches declarations whose declaration context, interpreted as a\n/// Decl, matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n/// \\endcode\n///\n/// \\c cxxRcordDecl(hasDeclContext(namedDecl(hasName(\"M\")))) matches the\n/// declaration of \\c class \\c D.\nAST_MATCHER_P(Decl, hasDeclContext, internal::Matcher<Decl>, InnerMatcher) {\n  const DeclContext *DC = Node.getDeclContext();\n  if (!DC) return false;\n  return InnerMatcher.matches(*Decl::castFromDeclContext(DC), Finder, Builder);\n}\n\n/// Matches nested name specifiers.\n///\n/// Given\n/// \\code\n///   namespace ns {\n///     struct A { static void f(); };\n///     void A::f() {}\n///     void g() { A::f(); }\n///   }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier()\n///   matches \"ns::\" and both \"A::\"\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifier>\n    nestedNameSpecifier;\n\n/// Same as \\c nestedNameSpecifier but matches \\c NestedNameSpecifierLoc.\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifierLoc>\n    nestedNameSpecifierLoc;\n\n/// Matches \\c NestedNameSpecifierLocs for which the given inner\n/// NestedNameSpecifier-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(\n    internal::BindableMatcher<NestedNameSpecifierLoc>, loc,\n    internal::Matcher<NestedNameSpecifier>, InnerMatcher, 1) {\n  return internal::BindableMatcher<NestedNameSpecifierLoc>(\n      new internal::LocMatcher<NestedNameSpecifierLoc, NestedNameSpecifier>(\n          InnerMatcher));\n}\n\n/// Matches nested name specifiers that specify a type matching the\n/// given \\c QualType matcher without qualifiers.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(specifiesType(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))\n/// ))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (!Node.getAsType())\n    return false;\n  return InnerMatcher.matches(QualType(Node.getAsType(), 0), Finder, Builder);\n}\n\n/// Matches nested name specifier locs that specify a type matching the\n/// given \\c TypeLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))))))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifierLoc, specifiesTypeLoc,\n              internal::Matcher<TypeLoc>, InnerMatcher) {\n  return Node && Node.getNestedNameSpecifier()->getAsType() &&\n         InnerMatcher.matches(Node.getTypeLoc(), Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifier.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(hasPrefix(specifiesType(asString(\"struct A\")))) and\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifier, hasPrefix,\n                       internal::Matcher<NestedNameSpecifier>, InnerMatcher,\n                       0) {\n  const NestedNameSpecifier *NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(*NextNode, Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifierLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(\"struct A\")))))\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifierLoc, hasPrefix,\n                       internal::Matcher<NestedNameSpecifierLoc>, InnerMatcher,\n                       1) {\n  NestedNameSpecifierLoc NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(NextNode, Finder, Builder);\n}\n\n/// Matches nested name specifiers that specify a namespace matching the\n/// given namespace matcher.\n///\n/// Given\n/// \\code\n///   namespace ns { struct A {}; }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier(specifiesNamespace(hasName(\"ns\")))\n///   matches \"ns::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesNamespace,\n              internal::Matcher<NamespaceDecl>, InnerMatcher) {\n  if (!Node.getAsNamespace())\n    return false;\n  return InnerMatcher.matches(*Node.getAsNamespace(), Finder, Builder);\n}\n\n/// Matches attributes.\n/// Attributes may be attached with a variety of different syntaxes (including\n/// keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,\n/// and ``#pragma``s). They may also be implicit.\n///\n/// Given\n/// \\code\n///   struct [[nodiscard]] Foo{};\n///   void bar(int * __attribute__((nonnull)) );\n///   __declspec(noinline) void baz();\n///\n///   #pragma omp declare simd\n///   int min();\n/// \\endcode\n/// attr()\n///   matches \"nodiscard\", \"nonnull\", \"noinline\", and the whole \"#pragma\" line.\nextern const internal::VariadicAllOfMatcher<Attr> attr;\n\n/// Overloads for the \\c equalsNode matcher.\n/// FIXME: Implement for other node types.\n/// @{\n\n/// Matches if a node equals another node.\n///\n/// \\c Decl has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Decl, equalsNode, const Decl*, Other, 0) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Stmt has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Stmt, equalsNode, const Stmt*, Other, 1) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Type has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Type, equalsNode, const Type*, Other, 2) {\n    return &Node == Other;\n}\n\n/// @}\n\n/// Matches each case or default statement belonging to the given switch\n/// statement. This matcher may produce multiple matches.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }\n/// \\endcode\n/// switchStmt(forEachSwitchCase(caseStmt().bind(\"c\"))).bind(\"s\")\n///   matches four times, with \"c\" binding each of \"case 1:\", \"case 2:\",\n/// \"case 3:\" and \"case 4:\", and \"s\" respectively binding \"switch (1)\",\n/// \"switch (1)\", \"switch (2)\" and \"switch (2)\".\nAST_MATCHER_P(SwitchStmt, forEachSwitchCase, internal::Matcher<SwitchCase>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  // FIXME: getSwitchCaseList() does not necessarily guarantee a stable\n  // iteration order. We should use the more general iterating matchers once\n  // they are capable of expressing this matcher (for example, it should ignore\n  // case statements belonging to nested switch statements).\n  bool Matched = false;\n  for (const SwitchCase *SC = Node.getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    BoundNodesTreeBuilder CaseBuilder(*Builder);\n    bool CaseMatched = InnerMatcher.matches(*SC, Finder, &CaseBuilder);\n    if (CaseMatched) {\n      Matched = true;\n      Result.addMatch(CaseBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches each constructor initializer in a constructor definition.\n///\n/// Given\n/// \\code\n///   class A { A() : i(42), j(42) {} int i; int j; };\n/// \\endcode\n/// cxxConstructorDecl(forEachConstructorInitializer(\n///   forField(decl().bind(\"x\"))\n/// ))\n///   will trigger two matches, binding for 'i' and 'j' respectively.\nAST_MATCHER_P(CXXConstructorDecl, forEachConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *I : Node.inits()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() && !I->isWritten())\n      continue;\n    BoundNodesTreeBuilder InitBuilder(*Builder);\n    if (InnerMatcher.matches(*I, Finder, &InitBuilder)) {\n      Matched = true;\n      Result.addMatch(InitBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches constructor declarations that are copy constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3.\nAST_MATCHER(CXXConstructorDecl, isCopyConstructor) {\n  return Node.isCopyConstructor();\n}\n\n/// Matches constructor declarations that are move constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isMoveConstructor) {\n  return Node.isMoveConstructor();\n}\n\n/// Matches constructor declarations that are default constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXConstructorDecl, isDefaultConstructor) {\n  return Node.isDefaultConstructor();\n}\n\n/// Matches constructors that delegate to another constructor.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(int) {} // #2\n///     S(S &&) : S() {} // #3\n///   };\n///   S::S() : S(0) {} // #4\n/// \\endcode\n/// cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not\n/// #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isDelegatingConstructor) {\n  return Node.isDelegatingConstructor();\n}\n\n/// Matches constructor, conversion function, and deduction guide declarations\n/// that have an explicit specifier if this explicit specifier is resolved to\n/// true.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.\n/// cxxConversionDecl(isExplicit()) will match #4, but not #3.\n/// cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5.\nAST_POLYMORPHIC_MATCHER(isExplicit, AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                        CXXConstructorDecl, CXXConversionDecl,\n                                        CXXDeductionGuideDecl)) {\n  return Node.isExplicit();\n}\n\n/// Matches the expression in an explicit specifier if present in the given\n/// declaration.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.\n/// cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.\n/// cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6.\nAST_MATCHER_P(FunctionDecl, hasExplicitSpecifier, internal::Matcher<Expr>,\n              InnerMatcher) {\n  ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(&Node);\n  if (!ES.getExpr())\n    return false;\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  return InnerMatcher.matches(*ES.getExpr(), Finder, Builder);\n}\n\n/// Matches functions, variables and namespace declarations that are marked with\n/// the inline keyword.\n///\n/// Given\n/// \\code\n///   inline void f();\n///   void g();\n///   namespace n {\n///   inline namespace m {}\n///   }\n///   inline int Foo = 5;\n/// \\endcode\n/// functionDecl(isInline()) will match ::f().\n/// namespaceDecl(isInline()) will match n::m.\n/// varDecl(isInline()) will match Foo;\nAST_POLYMORPHIC_MATCHER(isInline, AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,\n                                                                  FunctionDecl,\n                                                                  VarDecl)) {\n  // This is required because the spelling of the function used to determine\n  // whether inline is specified or not differs between the polymorphic types.\n  if (const auto *FD = dyn_cast<FunctionDecl>(&Node))\n    return FD->isInlineSpecified();\n  if (const auto *NSD = dyn_cast<NamespaceDecl>(&Node))\n    return NSD->isInline();\n  if (const auto *VD = dyn_cast<VarDecl>(&Node))\n    return VD->isInline();\n  llvm_unreachable(\"Not a valid polymorphic type\");\n}\n\n/// Matches anonymous namespace declarations.\n///\n/// Given\n/// \\code\n///   namespace n {\n///   namespace {} // #1\n///   }\n/// \\endcode\n/// namespaceDecl(isAnonymous()) will match #1 but not ::n.\nAST_MATCHER(NamespaceDecl, isAnonymous) {\n  return Node.isAnonymousNamespace();\n}\n\n/// Matches declarations in the namespace `std`, but not in nested namespaces.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace std {\n///       class vector {};\n///     }\n///   }\n///   namespace std {\n///     inline namespace __1 {\n///       class vector {}; // #1\n///       namespace experimental {\n///         class vector {};\n///       }\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInStdNamespace()) will match only #1.\nAST_MATCHER(Decl, isInStdNamespace) { return Node.isInStdNamespace(); }\n\n/// Matches declarations in an anonymous namespace.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace {\n///       class vector {}; // #1\n///     }\n///   }\n///   namespace {\n///     class vector {}; // #2\n///     namespace foo {\n///       class vector{}; // #3\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInAnonymousNamespace()) will match\n/// #1, #2 and #3.\nAST_MATCHER(Decl, isInAnonymousNamespace) {\n  return Node.isInAnonymousNamespace();\n}\n\n/// If the given case statement does not use the GNU case range\n/// extension, matches the constant given in the statement.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }\n/// \\endcode\n/// caseStmt(hasCaseConstant(integerLiteral()))\n///   matches \"case 1:\"\nAST_MATCHER_P(CaseStmt, hasCaseConstant, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (Node.getRHS())\n    return false;\n\n  return InnerMatcher.matches(*Node.getLHS(), Finder, Builder);\n}\n\n/// Matches declaration that has a given attribute.\n///\n/// Given\n/// \\code\n///   __attribute__((device)) void f() { ... }\n/// \\endcode\n/// decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of\n/// f. If the matcher is used from clang-query, attr::Kind parameter should be\n/// passed as a quoted string. e.g., hasAttr(\"attr::CUDADevice\").\nAST_MATCHER_P(Decl, hasAttr, attr::Kind, AttrKind) {\n  for (const auto *Attr : Node.attrs()) {\n    if (Attr->getKind() == AttrKind)\n      return true;\n  }\n  return false;\n}\n\n/// Matches the return value expression of a return statement\n///\n/// Given\n/// \\code\n///   return a + b;\n/// \\endcode\n/// hasReturnValue(binaryOperator())\n///   matches 'return a + b'\n/// with binaryOperator()\n///   matching 'a + b'\nAST_MATCHER_P(ReturnStmt, hasReturnValue, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (const auto *RetValue = Node.getRetValue())\n    return InnerMatcher.matches(*RetValue, Finder, Builder);\n  return false;\n}\n\n/// Matches CUDA kernel call expression.\n///\n/// Example matches,\n/// \\code\n///   kernel<<<i,j>>>();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CUDAKernelCallExpr>\n    cudaKernelCallExpr;\n\n/// Matches expressions that resolve to a null pointer constant, such as\n/// GNU's __null, C++11's nullptr, or C's NULL macro.\n///\n/// Given:\n/// \\code\n///   void *v1 = NULL;\n///   void *v2 = nullptr;\n///   void *v3 = __null; // GNU extension\n///   char *cp = (char *)0;\n///   int *ip = 0;\n///   int i = 0;\n/// \\endcode\n/// expr(nullPointerConstant())\n///   matches the initializer for v1, v2, v3, cp, and ip. Does not match the\n///   initializer for i.\nAST_MATCHER_FUNCTION(internal::Matcher<Expr>, nullPointerConstant) {\n  return anyOf(\n      gnuNullExpr(), cxxNullPtrLiteralExpr(),\n      integerLiteral(equals(0), hasParent(expr(hasType(pointerType())))));\n}\n\n/// Matches the DecompositionDecl the binding belongs to.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   bindingDecl(hasName(\"f\"),\n///                 forDecomposition(decompositionDecl())\n/// \\endcode\n/// matches 'f' in 'auto &[f, s, t]'.\nAST_MATCHER_P(BindingDecl, forDecomposition, internal::Matcher<ValueDecl>,\n              InnerMatcher) {\n  if (const ValueDecl *VD = Node.getDecomposedDecl())\n    return InnerMatcher.matches(*VD, Finder, Builder);\n  return false;\n}\n\n/// Matches the Nth binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasBinding(0,\n///   bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P2(DecompositionDecl, hasBinding, unsigned, N,\n               internal::Matcher<BindingDecl>, InnerMatcher) {\n  if (Node.bindings().size() <= N)\n    return false;\n  return InnerMatcher.matches(*Node.bindings()[N], Finder, Builder);\n}\n\n/// Matches any binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasAnyBinding(bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P(DecompositionDecl, hasAnyBinding, internal::Matcher<BindingDecl>,\n              InnerMatcher) {\n  return llvm::any_of(Node.bindings(), [&](const auto *Binding) {\n    return InnerMatcher.matches(*Binding, Finder, Builder);\n  });\n}\n\n/// Matches declaration of the function the statement belongs to.\n///\n/// Deprecated. Use forCallable() to correctly handle the situation when\n/// the declaration is not a function (but a block or an Objective-C method).\n/// forFunction() not only fails to take non-functions into account but also\n/// may match the wrong declaration in their presence.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forFunction(hasName(\"operator=\")))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\nAST_MATCHER_P(Stmt, forFunction, internal::Matcher<FunctionDecl>,\n              InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches declaration of the function, method, or block the statement\n/// belongs to.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forCallable(functionDecl(hasName(\"operator=\"))))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\n///\n/// Given:\n/// \\code\n/// -(void) foo {\n///   int x = 1;\n///   dispatch_sync(queue, ^{ int y = 2; });\n/// }\n/// \\endcode\n/// declStmt(forCallable(objcMethodDecl()))\n///   matches 'int x = 1'\n///   but does not match 'int y = 2'.\n/// whereas declStmt(forCallable(blockDecl()))\n///   matches 'int y = 2'\n///   but does not match 'int x = 1'.\nAST_MATCHER_P(Stmt, forCallable, internal::Matcher<Decl>, InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else if (const auto *ObjCMethodDeclNode = CurNode.get<ObjCMethodDecl>()) {\n      if (InnerMatcher.matches(*ObjCMethodDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *BlockDeclNode = CurNode.get<BlockDecl>()) {\n      if (InnerMatcher.matches(*BlockDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches a declaration that has external formal linkage.\n///\n/// Example matches only z (matcher = varDecl(hasExternalFormalLinkage()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\n///\n/// Example matches f() because it has external formal linkage despite being\n/// unique to the translation unit as though it has internal likage\n/// (matcher = functionDecl(hasExternalFormalLinkage()))\n///\n/// \\code\n/// namespace {\n/// void f() {}\n/// }\n/// \\endcode\nAST_MATCHER(NamedDecl, hasExternalFormalLinkage) {\n  return Node.hasExternalFormalLinkage();\n}\n\n/// Matches a declaration that has default arguments.\n///\n/// Example matches y (matcher = parmVarDecl(hasDefaultArgument()))\n/// \\code\n/// void x(int val) {}\n/// void y(int val = 0) {}\n/// \\endcode\n///\n/// Deprecated. Use hasInitializer() instead to be able to\n/// match on the contents of the default argument.  For example:\n///\n/// \\code\n/// void x(int val = 7) {}\n/// void y(int val = 42) {}\n/// \\endcode\n/// parmVarDecl(hasInitializer(integerLiteral(equals(42))))\n///   matches the parameter of y\n///\n/// A matcher such as\n///   parmVarDecl(hasInitializer(anything()))\n/// is equivalent to parmVarDecl(hasDefaultArgument()).\nAST_MATCHER(ParmVarDecl, hasDefaultArgument) {\n  return Node.hasDefaultArg();\n}\n\n/// Matches array new expressions.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(isArray())\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER(CXXNewExpr, isArray) {\n  return Node.isArray();\n}\n\n/// Matches placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage, 16) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16))))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,\n               internal::Matcher<Expr>, InnerMatcher) {\n  return Node.getNumPlacementArgs() > Index &&\n         InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder);\n}\n\n/// Matches any placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasAnyPlacementArg(anything()))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return llvm::any_of(Node.placement_arguments(), [&](const Expr *Arg) {\n    return InnerMatcher.matches(*Arg, Finder, Builder);\n  });\n}\n\n/// Matches array new expressions with a given array size.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(hasArraySize(integerLiteral(equals(10))))\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher<Expr>, InnerMatcher) {\n  return Node.isArray() && *Node.getArraySize() &&\n         InnerMatcher.matches(**Node.getArraySize(), Finder, Builder);\n}\n\n/// Matches a class declaration that is defined.\n///\n/// Example matches x (matcher = cxxRecordDecl(hasDefinition()))\n/// \\code\n/// class x {};\n/// class y;\n/// \\endcode\nAST_MATCHER(CXXRecordDecl, hasDefinition) {\n  return Node.hasDefinition();\n}\n\n/// Matches C++11 scoped enum declaration.\n///\n/// Example matches Y (matcher = enumDecl(isScoped()))\n/// \\code\n/// enum X {};\n/// enum class Y {};\n/// \\endcode\nAST_MATCHER(EnumDecl, isScoped) {\n  return Node.isScoped();\n}\n\n/// Matches a function declared with a trailing return type.\n///\n/// Example matches Y (matcher = functionDecl(hasTrailingReturn()))\n/// \\code\n/// int X() {}\n/// auto Y() -> int {}\n/// \\endcode\nAST_MATCHER(FunctionDecl, hasTrailingReturn) {\n  if (const auto *F = Node.getType()->getAs<FunctionProtoType>())\n    return F->hasTrailingReturn();\n  return false;\n}\n\n/// Matches expressions that match InnerMatcher that are possibly wrapped in an\n/// elidable constructor and other corresponding bookkeeping nodes.\n///\n/// In C++17, elidable copy constructors are no longer being generated in the\n/// AST as it is not permitted by the standard. They are, however, part of the\n/// AST in C++14 and earlier. So, a matcher must abstract over these differences\n/// to work in all language modes. This matcher skips elidable constructor-call\n/// AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and\n/// various implicit nodes inside the constructor calls, all of which will not\n/// appear in the C++17 AST.\n///\n/// Given\n///\n/// \\code\n/// struct H {};\n/// H G();\n/// void f() {\n///   H D = G();\n/// }\n/// \\endcode\n///\n/// ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``\n/// matches ``H D = G()`` in C++11 through C++17 (and beyond).\nAST_MATCHER_P(Expr, ignoringElidableConstructorCall,\n              ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  // E tracks the node that we are examining.\n  const Expr *E = &Node;\n  // If present, remove an outer `ExprWithCleanups` corresponding to the\n  // underlying `CXXConstructExpr`. This check won't cover all cases of added\n  // `ExprWithCleanups` corresponding to `CXXConstructExpr` nodes (because the\n  // EWC is placed on the outermost node of the expression, which this may not\n  // be), but, it still improves the coverage of this matcher.\n  if (const auto *CleanupsExpr = dyn_cast<ExprWithCleanups>(&Node))\n    E = CleanupsExpr->getSubExpr();\n  if (const auto *CtorExpr = dyn_cast<CXXConstructExpr>(E)) {\n    if (CtorExpr->isElidable()) {\n      if (const auto *MaterializeTemp =\n              dyn_cast<MaterializeTemporaryExpr>(CtorExpr->getArg(0))) {\n        return InnerMatcher.matches(*MaterializeTemp->getSubExpr(), Finder,\n                                    Builder);\n      }\n    }\n  }\n  return InnerMatcher.matches(Node, Finder, Builder);\n}\n\n//----------------------------------------------------------------------------//\n// OpenMP handling.\n//----------------------------------------------------------------------------//\n\n/// Matches any ``#pragma omp`` executable directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective()`` matches ``omp parallel``,\n/// ``omp parallel default(none)`` and ``omp taskyield``.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OMPExecutableDirective>\n    ompExecutableDirective;\n\n/// Matches standalone OpenMP directives,\n/// i.e., directives that can't have a structured block.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   {}\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective(isStandaloneDirective()))`` matches\n/// ``omp taskyield``.\nAST_MATCHER(OMPExecutableDirective, isStandaloneDirective) {\n  return Node.isStandaloneDirective();\n}\n\n/// Matches the structured-block of the OpenMP executable directive\n///\n/// Prerequisite: the executable directive must not be standalone directive.\n/// If it is, it will never match.\n///\n/// Given\n///\n/// \\code\n///    #pragma omp parallel\n///    ;\n///    #pragma omp parallel\n///    {}\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``\nAST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  if (Node.isStandaloneDirective())\n    return false; // Standalone directives have no structured blocks.\n  return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder);\n}\n\n/// Matches any clause in an OpenMP directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasAnyClause(anything()))`` matches\n/// ``omp parallel default(none)``.\nAST_MATCHER_P(OMPExecutableDirective, hasAnyClause,\n              internal::Matcher<OMPClause>, InnerMatcher) {\n  ArrayRef<OMPClause *> Clauses = Node.clauses();\n  return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(),\n                                    Clauses.end(), Finder,\n                                    Builder) != Clauses.end();\n}\n\n/// Matches OpenMP ``default`` clause.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n///   #pragma omp parallel\n/// \\endcode\n///\n/// ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,\n/// `` default(private)`` and ``default(firstprivate)``\nextern const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>\n    ompDefaultClause;\n\n/// Matches if the OpenMP ``default`` clause has ``none`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isNoneKind())`` matches only ``default(none)``.\nAST_MATCHER(OMPDefaultClause, isNoneKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``shared`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isSharedKind())`` matches only ``default(shared)``.\nAST_MATCHER(OMPDefaultClause, isSharedKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``private`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isPrivateKind())`` matches only\n/// ``default(private)``.\nAST_MATCHER(OMPDefaultClause, isPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_private;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``firstprivate`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isFirstPrivateKind())`` matches only\n/// ``default(firstprivate)``.\nAST_MATCHER(OMPDefaultClause, isFirstPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate;\n}\n\n/// Matches if the OpenMP directive is allowed to contain the specified OpenMP\n/// clause kind.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel for\n///   #pragma omp          for\n/// \\endcode\n///\n/// `ompExecutableDirective(isAllowedToContainClause(OMPC_default))`` matches\n/// ``omp parallel`` and ``omp parallel for``.\n///\n/// If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter\n/// should be passed as a quoted string. e.g.,\n/// ``isAllowedToContainClauseKind(\"OMPC_default\").``\nAST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,\n              OpenMPClauseKind, CKind) {\n  return llvm::omp::isAllowedClauseForDirective(\n      Node.getDirectiveKind(), CKind,\n      Finder->getASTContext().getLangOpts().OpenMP);\n}\n\n//----------------------------------------------------------------------------//\n// End OpenMP handling.\n//----------------------------------------------------------------------------//\n\n}",
  "id": "BLOCK-CPP-14868",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchers.h",
  "source_line": 7409,
  "validation_status": "validated"
}