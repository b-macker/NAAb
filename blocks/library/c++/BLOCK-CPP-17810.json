{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <functional>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17810_execute() {\n    {\nnamespace driver {\n\n/// This corresponds to a single GCC Multilib, or a segment of one controlled\n/// by a command line flag.\n/// See also MultilibBuilder for building a multilib by mutating it\n/// incrementally.\nclass Multilib {\npublic:\n  using flags_list = std::vector<std::string>;\n\nprivate:\n  std::string GCCSuffix;\n  std::string OSSuffix;\n  std::string IncludeSuffix;\n  flags_list Flags;\n\npublic:\n  /// GCCSuffix, OSSuffix & IncludeSuffix will be appended directly to the\n  /// sysroot string so they must either be empty or begin with a '/' character.\n  /// This is enforced with an assert in the constructor.\n  Multilib(StringRef GCCSuffix = {}, StringRef OSSuffix = {},\n           StringRef IncludeSuffix = {},\n           const flags_list &Flags = flags_list());\n\n  /// Get the detected GCC installation path suffix for the multi-arch\n  /// target variant. Always starts with a '/', unless empty\n  const std::string &gccSuffix() const { return GCCSuffix; }\n\n  /// Get the detected os path suffix for the multi-arch\n  /// target variant. Always starts with a '/', unless empty\n  const std::string &osSuffix() const { return OSSuffix; }\n\n  /// Get the include directory suffix. Always starts with a '/', unless\n  /// empty\n  const std::string &includeSuffix() const { return IncludeSuffix; }\n\n  /// Get the flags that indicate or contraindicate this multilib's use\n  /// All elements begin with either '-' or '!'\n  const flags_list &flags() const { return Flags; }\n\n  LLVM_DUMP_METHOD void dump() const;\n  /// print summary of the Multilib\n  void print(raw_ostream &OS) const;\n\n  /// Check whether the default is selected\n  bool isDefault() const\n  { return GCCSuffix.empty() && OSSuffix.empty() && IncludeSuffix.empty(); }\n\n  bool operator==(const Multilib &Other) const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const Multilib &M);\n\n/// See also MultilibSetBuilder for combining multilibs into a set.\nclass MultilibSet {\npublic:\n  using multilib_list = std::vector<Multilib>;\n  using const_iterator = multilib_list::const_iterator;\n  using IncludeDirsFunc =\n      std::function<std::vector<std::string>(const Multilib &M)>;\n  using FilterCallback = llvm::function_ref<bool(const Multilib &)>;\n\n  /// Uses regular expressions to simplify flags used for multilib selection.\n  /// For example, we may wish both -mfloat-abi=soft and -mfloat-abi=softfp to\n  /// be treated as -mfloat-abi=soft.\n  struct FlagMatcher {\n    std::string Match;\n    std::vector<std::string> Flags;\n  };\n\nprivate:\n  multilib_list Multilibs;\n  std::vector<FlagMatcher> FlagMatchers;\n  IncludeDirsFunc IncludeCallback;\n  IncludeDirsFunc FilePathsCallback;\n\npublic:\n  MultilibSet() = default;\n  MultilibSet(multilib_list &&Multilibs,\n              std::vector<FlagMatcher> &&FlagMatchers = {})\n      : Multilibs(Multilibs), FlagMatchers(FlagMatchers) {}\n\n  const multilib_list &getMultilibs() { return Multilibs; }\n\n  /// Filter out some subset of the Multilibs using a user defined callback\n  MultilibSet &FilterOut(FilterCallback F);\n\n  /// Add a completed Multilib to the set\n  void push_back(const Multilib &M);\n\n  const_iterator begin() const { return Multilibs.begin(); }\n  const_iterator end() const { return Multilibs.end(); }\n\n  /// Select compatible variants, \\returns false if none are compatible\n  bool select(const Multilib::flags_list &Flags,\n              llvm::SmallVector<Multilib> &) const;\n\n  unsigned size() const { return Multilibs.size(); }\n\n  /// Get the given flags plus flags found by matching them against the\n  /// FlagMatchers and choosing the Flags of each accordingly. The select method\n  /// calls this method so in most cases it's not necessary to call it directly.\n  llvm::StringSet<> expandFlags(const Multilib::flags_list &) const;\n\n  LLVM_DUMP_METHOD void dump() const;\n  void print(raw_ostream &OS) const;\n\n  MultilibSet &setIncludeDirsCallback(IncludeDirsFunc F) {\n    IncludeCallback = std::move(F);\n    return *this;\n  }\n\n  const IncludeDirsFunc &includeDirsCallback() const { return IncludeCallback; }\n\n  MultilibSet &setFilePathsCallback(IncludeDirsFunc F) {\n    FilePathsCallback = std::move(F);\n    return *this;\n  }\n\n  const IncludeDirsFunc &filePathsCallback() const { return FilePathsCallback; }\n\n  static llvm::ErrorOr<MultilibSet>\n  parseYaml(llvm::MemoryBufferRef, llvm::SourceMgr::DiagHandlerTy = nullptr,\n            void *DiagHandlerCtxt = nullptr);\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const MultilibSet &MS);\n\n} // namespace driver\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17810",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Multilib.h",
  "source_line": 25,
  "validation_status": "validated"
}