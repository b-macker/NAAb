{
  "code": "{\nnamespace tooling {\n\n/// Base class for RefactoringCallbacks.\n///\n/// Collects \\c tooling::Replacements while running.\nclass RefactoringCallback : public ast_matchers::MatchFinder::MatchCallback {\npublic:\n  RefactoringCallback();\n  Replacements &getReplacements();\n\nprotected:\n  Replacements Replace;\n};\n\n/// Adaptor between \\c ast_matchers::MatchFinder and \\c\n/// tooling::RefactoringTool.\n///\n/// Runs AST matchers and stores the \\c tooling::Replacements in a map.\nclass ASTMatchRefactorer {\npublic:\n  explicit ASTMatchRefactorer(\n    std::map<std::string, Replacements> &FileToReplaces);\n\n  template <typename T>\n  void addMatcher(const T &Matcher, RefactoringCallback *Callback) {\n    MatchFinder.addMatcher(Matcher, Callback);\n    Callbacks.push_back(Callback);\n  }\n\n  void addDynamicMatcher(const ast_matchers::internal::DynTypedMatcher &Matcher,\n                         RefactoringCallback *Callback);\n\n  std::unique_ptr<ASTConsumer> newASTConsumer();\n\nprivate:\n  friend class RefactoringASTConsumer;\n  std::vector<RefactoringCallback *> Callbacks;\n  ast_matchers::MatchFinder MatchFinder;\n  std::map<std::string, Replacements> &FileToReplaces;\n};\n\n/// Replace the text of the statement bound to \\c FromId with the text in\n/// \\c ToText.\nclass ReplaceStmtWithText : public RefactoringCallback {\npublic:\n  ReplaceStmtWithText(StringRef FromId, StringRef ToText);\n  void run(const ast_matchers::MatchFinder::MatchResult &Result) override;\n\nprivate:\n  std::string FromId;\n  std::string ToText;\n};\n\n/// Replace the text of an AST node bound to \\c FromId with the result of\n/// evaluating the template in \\c ToTemplate.\n///\n/// Expressions of the form ${NodeName} in \\c ToTemplate will be\n/// replaced by the text of the node bound to ${NodeName}. The string\n/// \"$$\" will be replaced by \"$\".\nclass ReplaceNodeWithTemplate : public RefactoringCallback {\npublic:\n  static llvm::Expected<std::unique_ptr<ReplaceNodeWithTemplate>>\n  create(StringRef FromId, StringRef ToTemplate);\n  void run(const ast_matchers::MatchFinder::MatchResult &Result) override;\n\nprivate:\n  struct TemplateElement {\n    enum { Literal, Identifier } Type;\n    std::string Value;\n  };\n  ReplaceNodeWithTemplate(llvm::StringRef FromId,\n                          std::vector<TemplateElement> Template);\n  std::string FromId;\n  std::vector<TemplateElement> Template;\n};\n\n/// Replace the text of the statement bound to \\c FromId with the text of\n/// the statement bound to \\c ToId.\nclass ReplaceStmtWithStmt : public RefactoringCallback {\npublic:\n  ReplaceStmtWithStmt(StringRef FromId, StringRef ToId);\n  void run(const ast_matchers::MatchFinder::MatchResult &Result) override;\n\nprivate:\n  std::string FromId;\n  std::string ToId;\n};\n\n/// Replace an if-statement bound to \\c Id with the outdented text of its\n/// body, choosing the consequent or the alternative based on whether\n/// \\c PickTrueBranch is true.\nclass ReplaceIfStmtWithItsBody : public RefactoringCallback {\npublic:\n  ReplaceIfStmtWithItsBody(StringRef Id, bool PickTrueBranch);\n  void run(const ast_matchers::MatchFinder::MatchResult &Result) override;\n\nprivate:\n  std::string Id;\n  const bool PickTrueBranch;\n};\n\n} // end namespace tooling\n}",
  "id": "BLOCK-CPP-21213",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/RefactoringCallbacks.h",
  "source_line": 34,
  "validation_status": "validated"
}