{
  "code": "#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <random>\n#include <type_traits>\n#include \"absl/base/internal/inline_variable.h\"\n#include \"absl/random/bernoulli_distribution.h\"\n#include \"absl/random/beta_distribution.h\"\n#include \"absl/random/exponential_distribution.h\"\n#include \"absl/random/gaussian_distribution.h\"\n#include \"absl/random/internal/distribution_caller.h\"  // IWYU pragma: export\n#include \"absl/random/internal/uniform_helper.h\"  // IWYU pragma: export\n#include \"absl/random/log_uniform_int_distribution.h\"\n#include \"absl/random/poisson_distribution.h\"\n#include \"absl/random/uniform_int_distribution.h\"\n#include \"absl/random/uniform_real_distribution.h\"\n#include \"absl/random/zipf_distribution.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03834_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalClosedClosedTag, IntervalClosedClosed,\n                               {});\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalClosedClosedTag, IntervalClosed, {});\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalClosedOpenTag, IntervalClosedOpen, {});\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalOpenOpenTag, IntervalOpenOpen, {});\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalOpenOpenTag, IntervalOpen, {});\nABSL_INTERNAL_INLINE_CONSTEXPR(IntervalOpenClosedTag, IntervalOpenClosed, {});\n\n// -----------------------------------------------------------------------------\n// absl::Uniform<T>(tag, bitgen, lo, hi)\n// -----------------------------------------------------------------------------\n//\n// `absl::Uniform()` produces random values of type `T` uniformly distributed in\n// a defined interval {lo, hi}. The interval `tag` defines the type of interval\n// which should be one of the following possible values:\n//\n//   * `absl::IntervalOpenOpen`\n//   * `absl::IntervalOpenClosed`\n//   * `absl::IntervalClosedOpen`\n//   * `absl::IntervalClosedClosed`\n//\n// where \"open\" refers to an exclusive value (excluded) from the output, while\n// \"closed\" refers to an inclusive value (included) from the output.\n//\n// In the absence of an explicit return type `T`, `absl::Uniform()` will deduce\n// the return type based on the provided endpoint arguments {A lo, B hi}.\n// Given these endpoints, one of {A, B} will be chosen as the return type, if\n// a type can be implicitly converted into the other in a lossless way. The\n// lack of any such implicit conversion between {A, B} will produce a\n// compile-time error\n//\n// See https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//\n//   // Produce a random float value between 0.0 and 1.0, inclusive\n//   auto x = absl::Uniform(absl::IntervalClosedClosed, bitgen, 0.0f, 1.0f);\n//\n//   // The most common interval of `absl::IntervalClosedOpen` is available by\n//   // default:\n//\n//   auto x = absl::Uniform(bitgen, 0.0f, 1.0f);\n//\n//   // Return-types are typically inferred from the arguments, however callers\n//   // can optionally provide an explicit return-type to the template.\n//\n//   auto x = absl::Uniform<float>(bitgen, 0, 1);\n//\ntemplate <typename R = void, typename TagType, typename URBG>\ntypename absl::enable_if_t<!std::is_same<R, void>::value, R>  //\nUniform(TagType tag,\n        URBG&& urbg,  // NOLINT(runtime/references)\n        R lo, R hi) {\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = random_internal::UniformDistributionWrapper<R>;\n\n  auto a = random_internal::uniform_lower_bound(tag, lo, hi);\n  auto b = random_internal::uniform_upper_bound(tag, lo, hi);\n  if (!random_internal::is_uniform_range_valid(a, b)) return lo;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, tag, lo, hi);\n}\n\n// absl::Uniform<T>(bitgen, lo, hi)\n//\n// Overload of `Uniform()` using the default closed-open interval of [lo, hi),\n// and returning values of type `T`\ntemplate <typename R = void, typename URBG>\ntypename absl::enable_if_t<!std::is_same<R, void>::value, R>  //\nUniform(URBG&& urbg,  // NOLINT(runtime/references)\n        R lo, R hi) {\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = random_internal::UniformDistributionWrapper<R>;\n  constexpr auto tag = absl::IntervalClosedOpen;\n\n  auto a = random_internal::uniform_lower_bound(tag, lo, hi);\n  auto b = random_internal::uniform_upper_bound(tag, lo, hi);\n  if (!random_internal::is_uniform_range_valid(a, b)) return lo;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, lo, hi);\n}\n\n// absl::Uniform(tag, bitgen, lo, hi)\n//\n// Overload of `Uniform()` using different (but compatible) lo, hi types. Note\n// that a compile-error will result if the return type cannot be deduced\n// correctly from the passed types.\ntemplate <typename R = void, typename TagType, typename URBG, typename A,\n          typename B>\ntypename absl::enable_if_t<std::is_same<R, void>::value,\n                           random_internal::uniform_inferred_return_t<A, B>>\nUniform(TagType tag,\n        URBG&& urbg,  // NOLINT(runtime/references)\n        A lo, B hi) {\n  using gen_t = absl::decay_t<URBG>;\n  using return_t = typename random_internal::uniform_inferred_return_t<A, B>;\n  using distribution_t = random_internal::UniformDistributionWrapper<return_t>;\n\n  auto a = random_internal::uniform_lower_bound<return_t>(tag, lo, hi);\n  auto b = random_internal::uniform_upper_bound<return_t>(tag, lo, hi);\n  if (!random_internal::is_uniform_range_valid(a, b)) return lo;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, tag, static_cast<return_t>(lo),\n                                static_cast<return_t>(hi));\n}\n\n// absl::Uniform(bitgen, lo, hi)\n//\n// Overload of `Uniform()` using different (but compatible) lo, hi types and the\n// default closed-open interval of [lo, hi). Note that a compile-error will\n// result if the return type cannot be deduced correctly from the passed types.\ntemplate <typename R = void, typename URBG, typename A, typename B>\ntypename absl::enable_if_t<std::is_same<R, void>::value,\n                           random_internal::uniform_inferred_return_t<A, B>>\nUniform(URBG&& urbg,  // NOLINT(runtime/references)\n        A lo, B hi) {\n  using gen_t = absl::decay_t<URBG>;\n  using return_t = typename random_internal::uniform_inferred_return_t<A, B>;\n  using distribution_t = random_internal::UniformDistributionWrapper<return_t>;\n\n  constexpr auto tag = absl::IntervalClosedOpen;\n  auto a = random_internal::uniform_lower_bound<return_t>(tag, lo, hi);\n  auto b = random_internal::uniform_upper_bound<return_t>(tag, lo, hi);\n  if (!random_internal::is_uniform_range_valid(a, b)) return lo;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, static_cast<return_t>(lo),\n                                static_cast<return_t>(hi));\n}\n\n// absl::Uniform<unsigned T>(bitgen)\n//\n// Overload of Uniform() using the minimum and maximum values of a given type\n// `T` (which must be unsigned), returning a value of type `unsigned T`\ntemplate <typename R, typename URBG>\ntypename absl::enable_if_t<!std::is_signed<R>::value, R>  //\nUniform(URBG&& urbg) {  // NOLINT(runtime/references)\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = random_internal::UniformDistributionWrapper<R>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Bernoulli(bitgen, p)\n// -----------------------------------------------------------------------------\n//\n// `absl::Bernoulli` produces a random boolean value, with probability `p`\n// (where 0.0 <= p <= 1.0) equaling `true`.\n//\n// Prefer `absl::Bernoulli` to produce boolean values over other alternatives\n// such as comparing an `absl::Uniform()` value to a specific output.\n//\n// See https://en.wikipedia.org/wiki/Bernoulli_distribution\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   if (absl::Bernoulli(bitgen, 1.0/3721.0)) {\n//     std::cout << \"Asteroid field navigation successful.\";\n//   }\n//\ntemplate <typename URBG>\nbool Bernoulli(URBG&& urbg,  // NOLINT(runtime/references)\n               double p) {\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = absl::bernoulli_distribution;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, p);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Beta<T>(bitgen, alpha, beta)\n// -----------------------------------------------------------------------------\n//\n// `absl::Beta` produces a floating point number distributed in the closed\n// interval [0,1] and parameterized by two values `alpha` and `beta` as per a\n// Beta distribution. `T` must be a floating point type, but may be inferred\n// from the types of `alpha` and `beta`.\n//\n// See https://en.wikipedia.org/wiki/Beta_distribution.\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   double sample = absl::Beta(bitgen, 3.0, 2.0);\n//\ntemplate <typename RealType, typename URBG>\nRealType Beta(URBG&& urbg,  // NOLINT(runtime/references)\n              RealType alpha, RealType beta) {\n  static_assert(\n      std::is_floating_point<RealType>::value,\n      \"Template-argument 'RealType' must be a floating-point type, in \"\n      \"absl::Beta<RealType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::beta_distribution<RealType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, alpha, beta);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Exponential<T>(bitgen, lambda = 1)\n// -----------------------------------------------------------------------------\n//\n// `absl::Exponential` produces a floating point number representing the\n// distance (time) between two consecutive events in a point process of events\n// occurring continuously and independently at a constant average rate. `T` must\n// be a floating point type, but may be inferred from the type of `lambda`.\n//\n// See https://en.wikipedia.org/wiki/Exponential_distribution.\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   double call_length = absl::Exponential(bitgen, 7.0);\n//\ntemplate <typename RealType, typename URBG>\nRealType Exponential(URBG&& urbg,  // NOLINT(runtime/references)\n                     RealType lambda = 1) {\n  static_assert(\n      std::is_floating_point<RealType>::value,\n      \"Template-argument 'RealType' must be a floating-point type, in \"\n      \"absl::Exponential<RealType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::exponential_distribution<RealType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, lambda);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Gaussian<T>(bitgen, mean = 0, stddev = 1)\n// -----------------------------------------------------------------------------\n//\n// `absl::Gaussian` produces a floating point number selected from the Gaussian\n// (ie. \"Normal\") distribution. `T` must be a floating point type, but may be\n// inferred from the types of `mean` and `stddev`.\n//\n// See https://en.wikipedia.org/wiki/Normal_distribution\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   double giraffe_height = absl::Gaussian(bitgen, 16.3, 3.3);\n//\ntemplate <typename RealType, typename URBG>\nRealType Gaussian(URBG&& urbg,  // NOLINT(runtime/references)\n                  RealType mean = 0, RealType stddev = 1) {\n  static_assert(\n      std::is_floating_point<RealType>::value,\n      \"Template-argument 'RealType' must be a floating-point type, in \"\n      \"absl::Gaussian<RealType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::gaussian_distribution<RealType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, mean, stddev);\n}\n\n// -----------------------------------------------------------------------------\n// absl::LogUniform<T>(bitgen, lo, hi, base = 2)\n// -----------------------------------------------------------------------------\n//\n// `absl::LogUniform` produces random values distributed where the log to a\n// given base of all values is uniform in a closed interval [lo, hi]. `T` must\n// be an integral type, but may be inferred from the types of `lo` and `hi`.\n//\n// I.e., `LogUniform(0, n, b)` is uniformly distributed across buckets\n// [0], [1, b-1], [b, b^2-1] .. [b^(k-1), (b^k)-1] .. [b^floor(log(n, b)), n]\n// and is uniformly distributed within each bucket.\n//\n// The resulting probability density is inversely related to bucket size, though\n// values in the final bucket may be more likely than previous values. (In the\n// extreme case where n = b^i the final value will be tied with zero as the most\n// probable result.\n//\n// If `lo` is nonzero then this distribution is shifted to the desired interval,\n// so LogUniform(lo, hi, b) is equivalent to LogUniform(0, hi-lo, b)+lo.\n//\n// See https://en.wikipedia.org/wiki/Log-normal_distribution\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   int v = absl::LogUniform(bitgen, 0, 1000);\n//\ntemplate <typename IntType, typename URBG>\nIntType LogUniform(URBG&& urbg,  // NOLINT(runtime/references)\n                   IntType lo, IntType hi, IntType base = 2) {\n  static_assert(random_internal::IsIntegral<IntType>::value,\n                \"Template-argument 'IntType' must be an integral type, in \"\n                \"absl::LogUniform<IntType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::log_uniform_int_distribution<IntType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, lo, hi, base);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Poisson<T>(bitgen, mean = 1)\n// -----------------------------------------------------------------------------\n//\n// `absl::Poisson` produces discrete probabilities for a given number of events\n// occurring within a fixed interval within the closed interval [0, max]. `T`\n// must be an integral type.\n//\n// See https://en.wikipedia.org/wiki/Poisson_distribution\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   int requests_per_minute = absl::Poisson<int>(bitgen, 3.2);\n//\ntemplate <typename IntType, typename URBG>\nIntType Poisson(URBG&& urbg,  // NOLINT(runtime/references)\n                double mean = 1.0) {\n  static_assert(random_internal::IsIntegral<IntType>::value,\n                \"Template-argument 'IntType' must be an integral type, in \"\n                \"absl::Poisson<IntType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::poisson_distribution<IntType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, mean);\n}\n\n// -----------------------------------------------------------------------------\n// absl::Zipf<T>(bitgen, hi = max, q = 2, v = 1)\n// -----------------------------------------------------------------------------\n//\n// `absl::Zipf` produces discrete probabilities commonly used for modelling of\n// rare events over the closed interval [0, hi]. The parameters `v` and `q`\n// determine the skew of the distribution. `T`  must be an integral type, but\n// may be inferred from the type of `hi`.\n//\n// See http://mathworld.wolfram.com/ZipfDistribution.html\n//\n// Example:\n//\n//   absl::BitGen bitgen;\n//   ...\n//   int term_rank = absl::Zipf<int>(bitgen);\n//\ntemplate <typename IntType, typename URBG>\nIntType Zipf(URBG&& urbg,  // NOLINT(runtime/references)\n             IntType hi = (std::numeric_limits<IntType>::max)(), double q = 2.0,\n             double v = 1.0) {\n  static_assert(random_internal::IsIntegral<IntType>::value,\n                \"Template-argument 'IntType' must be an integral type, in \"\n                \"absl::Zipf<IntType, URBG>(...)\");\n\n  using gen_t = absl::decay_t<URBG>;\n  using distribution_t = typename absl::zipf_distribution<IntType>;\n\n  return random_internal::DistributionCaller<gen_t>::template Call<\n      distribution_t>(&urbg, hi, q, v);\n}\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03834",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/distributions.h",
  "source_line": 68,
  "validation_status": "validated"
}