{
  "code": "{\n\nclass DeclContext;\nclass LangOptions;\nclass Stmt;\n\nclass PrinterHelper {\npublic:\n  virtual ~PrinterHelper();\n  virtual bool handledStmt(Stmt* E, raw_ostream& OS) = 0;\n};\n\n/// Callbacks to use to customize the behavior of the pretty-printer.\nclass PrintingCallbacks {\nprotected:\n  ~PrintingCallbacks() = default;\n\npublic:\n  /// Remap a path to a form suitable for printing.\n  virtual std::string remapPath(StringRef Path) const {\n    return std::string(Path);\n  }\n\n  /// When printing type to be inserted into code in specific context, this\n  /// callback can be used to avoid printing the redundant part of the\n  /// qualifier. For example, when inserting code inside namespace foo, we\n  /// should print bar::SomeType instead of foo::bar::SomeType.\n  /// To do this, shouldPrintScope should return true on \"foo\" NamespaceDecl.\n  /// The printing stops at the first isScopeVisible() == true, so there will\n  /// be no calls with outer scopes.\n  virtual bool isScopeVisible(const DeclContext *DC) const { return false; }\n};\n\n/// Describes how types, statements, expressions, and declarations should be\n/// printed.\n///\n/// This type is intended to be small and suitable for passing by value.\n/// It is very frequently copied.\nstruct PrintingPolicy {\n  /// Create a default printing policy for the specified language.\n  PrintingPolicy(const LangOptions &LO)\n      : Indentation(2), SuppressSpecifiers(false),\n        SuppressTagKeyword(LO.CPlusPlus), IncludeTagDefinition(false),\n        SuppressScope(false), SuppressUnwrittenScope(false),\n        SuppressInlineNamespace(true), SuppressElaboration(false),\n        SuppressInitializers(false), ConstantArraySizeAsWritten(false),\n        AnonymousTagLocations(true), SuppressStrongLifetime(false),\n        SuppressLifetimeQualifiers(false),\n        SuppressTemplateArgsInCXXConstructors(false),\n        SuppressDefaultTemplateArgs(true), Bool(LO.Bool),\n        Nullptr(LO.CPlusPlus11 || LO.C2x), NullptrTypeInNamespace(LO.CPlusPlus),\n        Restrict(LO.C99), Alignof(LO.CPlusPlus11), UnderscoreAlignof(LO.C11),\n        UseVoidForZeroParams(!LO.CPlusPlus),\n        SplitTemplateClosers(!LO.CPlusPlus11), TerseOutput(false),\n        PolishForDeclaration(false), Half(LO.Half),\n        MSWChar(LO.MicrosoftExt && !LO.WChar), IncludeNewlines(true),\n        MSVCFormatting(false), ConstantsAsWritten(false),\n        SuppressImplicitBase(false), FullyQualifiedName(false),\n        PrintCanonicalTypes(false), PrintInjectedClassNameWithArguments(true),\n        UsePreferredNames(true), AlwaysIncludeTypeForTemplateArgument(false),\n        CleanUglifiedParameters(false), EntireContentsOfLargeArray(true),\n        UseEnumerators(true) {}\n\n  /// Adjust this printing policy for cases where it's known that we're\n  /// printing C++ code (for instance, if AST dumping reaches a C++-only\n  /// construct). This should not be used if a real LangOptions object is\n  /// available.\n  void adjustForCPlusPlus() {\n    SuppressTagKeyword = true;\n    Bool = true;\n    UseVoidForZeroParams = false;\n  }\n\n  /// The number of spaces to use to indent each line.\n  unsigned Indentation : 8;\n\n  /// Whether we should suppress printing of the actual specifiers for\n  /// the given type or declaration.\n  ///\n  /// This flag is only used when we are printing declarators beyond\n  /// the first declarator within a declaration group. For example, given:\n  ///\n  /// \\code\n  /// const int *x, *y;\n  /// \\endcode\n  ///\n  /// SuppressSpecifiers will be false when printing the\n  /// declaration for \"x\", so that we will print \"int *x\"; it will be\n  /// \\c true when we print \"y\", so that we suppress printing the\n  /// \"const int\" type specifier and instead only print the \"*y\".\n  unsigned SuppressSpecifiers : 1;\n\n  /// Whether type printing should skip printing the tag keyword.\n  ///\n  /// This is used when printing the inner type of elaborated types,\n  /// (as the tag keyword is part of the elaborated type):\n  ///\n  /// \\code\n  /// struct Geometry::Point;\n  /// \\endcode\n  unsigned SuppressTagKeyword : 1;\n\n  /// When true, include the body of a tag definition.\n  ///\n  /// This is used to place the definition of a struct\n  /// in the middle of another declaration as with:\n  ///\n  /// \\code\n  /// typedef struct { int x, y; } Point;\n  /// \\endcode\n  unsigned IncludeTagDefinition : 1;\n\n  /// Suppresses printing of scope specifiers.\n  unsigned SuppressScope : 1;\n\n  /// Suppress printing parts of scope specifiers that are never\n  /// written, e.g., for anonymous namespaces.\n  unsigned SuppressUnwrittenScope : 1;\n\n  /// Suppress printing parts of scope specifiers that correspond\n  /// to inline namespaces, where the name is unambiguous with the specifier\n  /// removed.\n  unsigned SuppressInlineNamespace : 1;\n\n  /// Ignore qualifiers and tag keywords as specified by elaborated type sugar,\n  /// instead letting the underlying type print as normal.\n  unsigned SuppressElaboration : 1;\n\n  /// Suppress printing of variable initializers.\n  ///\n  /// This flag is used when printing the loop variable in a for-range\n  /// statement. For example, given:\n  ///\n  /// \\code\n  /// for (auto x : coll)\n  /// \\endcode\n  ///\n  /// SuppressInitializers will be true when printing \"auto x\", so that the\n  /// internal initializer constructed for x will not be printed.\n  unsigned SuppressInitializers : 1;\n\n  /// Whether we should print the sizes of constant array expressions as written\n  /// in the sources.\n  ///\n  /// This flag determines whether array types declared as\n  ///\n  /// \\code\n  /// int a[4+10*10];\n  /// char a[] = \"A string\";\n  /// \\endcode\n  ///\n  /// will be printed as written or as follows:\n  ///\n  /// \\code\n  /// int a[104];\n  /// char a[9] = \"A string\";\n  /// \\endcode\n  unsigned ConstantArraySizeAsWritten : 1;\n\n  /// When printing an anonymous tag name, also print the location of that\n  /// entity (e.g., \"enum <anonymous at t.h:10:5>\"). Otherwise, just prints\n  /// \"(anonymous)\" for the name.\n  unsigned AnonymousTagLocations : 1;\n\n  /// When true, suppress printing of the __strong lifetime qualifier in ARC.\n  unsigned SuppressStrongLifetime : 1;\n\n  /// When true, suppress printing of lifetime qualifier in ARC.\n  unsigned SuppressLifetimeQualifiers : 1;\n\n  /// When true, suppresses printing template arguments in names of C++\n  /// constructors.\n  unsigned SuppressTemplateArgsInCXXConstructors : 1;\n\n  /// When true, attempt to suppress template arguments that match the default\n  /// argument for the parameter.\n  unsigned SuppressDefaultTemplateArgs : 1;\n\n  /// Whether we can use 'bool' rather than '_Bool' (even if the language\n  /// doesn't actually have 'bool', because, e.g., it is defined as a macro).\n  unsigned Bool : 1;\n\n  /// Whether we should use 'nullptr' rather than '0' as a null pointer\n  /// constant.\n  unsigned Nullptr : 1;\n\n  /// Whether 'nullptr_t' is in namespace 'std' or not.\n  unsigned NullptrTypeInNamespace : 1;\n\n  /// Whether we can use 'restrict' rather than '__restrict'.\n  unsigned Restrict : 1;\n\n  /// Whether we can use 'alignof' rather than '__alignof'.\n  unsigned Alignof : 1;\n\n  /// Whether we can use '_Alignof' rather than '__alignof'.\n  unsigned UnderscoreAlignof : 1;\n\n  /// Whether we should use '(void)' rather than '()' for a function prototype\n  /// with zero parameters.\n  unsigned UseVoidForZeroParams : 1;\n\n  /// Whether nested templates must be closed like 'a\\<b\\<c\\> \\>' rather than\n  /// 'a\\<b\\<c\\>\\>'.\n  unsigned SplitTemplateClosers : 1;\n\n  /// Provide a 'terse' output.\n  ///\n  /// For example, in this mode we don't print function bodies, class members,\n  /// declarations inside namespaces etc.  Effectively, this should print\n  /// only the requested declaration.\n  unsigned TerseOutput : 1;\n\n  /// When true, do certain refinement needed for producing proper declaration\n  /// tag; such as, do not print attributes attached to the declaration.\n  ///\n  unsigned PolishForDeclaration : 1;\n\n  /// When true, print the half-precision floating-point type as 'half'\n  /// instead of '__fp16'\n  unsigned Half : 1;\n\n  /// When true, print the built-in wchar_t type as __wchar_t. For use in\n  /// Microsoft mode when wchar_t is not available.\n  unsigned MSWChar : 1;\n\n  /// When true, include newlines after statements like \"break\", etc.\n  unsigned IncludeNewlines : 1;\n\n  /// Use whitespace and punctuation like MSVC does. In particular, this prints\n  /// anonymous namespaces as `anonymous namespace' and does not insert spaces\n  /// after template arguments.\n  unsigned MSVCFormatting : 1;\n\n  /// Whether we should print the constant expressions as written in the\n  /// sources.\n  ///\n  /// This flag determines whether constants expressions like\n  ///\n  /// \\code\n  /// 0x10\n  /// 2.5e3\n  /// \\endcode\n  ///\n  /// will be printed as written or as follows:\n  ///\n  /// \\code\n  /// 0x10\n  /// 2.5e3\n  /// \\endcode\n  unsigned ConstantsAsWritten : 1;\n\n  /// When true, don't print the implicit 'self' or 'this' expressions.\n  unsigned SuppressImplicitBase : 1;\n\n  /// When true, print the fully qualified name of function declarations.\n  /// This is the opposite of SuppressScope and thus overrules it.\n  unsigned FullyQualifiedName : 1;\n\n  /// Whether to print types as written or canonically.\n  unsigned PrintCanonicalTypes : 1;\n\n  /// Whether to print an InjectedClassNameType with template arguments or as\n  /// written. When a template argument is unnamed, printing it results in\n  /// invalid C++ code.\n  unsigned PrintInjectedClassNameWithArguments : 1;\n\n  /// Whether to use C++ template preferred_name attributes when printing\n  /// templates.\n  unsigned UsePreferredNames : 1;\n\n  /// Whether to use type suffixes (eg: 1U) on integral non-type template\n  /// parameters.\n  unsigned AlwaysIncludeTypeForTemplateArgument : 1;\n\n  /// Whether to strip underscores when printing reserved parameter names.\n  /// e.g. std::vector<class _Tp> becomes std::vector<class Tp>.\n  /// This only affects parameter names, and so describes a compatible API.\n  unsigned CleanUglifiedParameters : 1;\n\n  /// Whether to print the entire array initializers, especially on non-type\n  /// template parameters, no matter how many elements there are.\n  unsigned EntireContentsOfLargeArray : 1;\n\n  /// Whether to print enumerator non-type template parameters with a matching\n  /// enumerator name or via cast of an integer.\n  unsigned UseEnumerators : 1;\n\n  /// Callbacks to use to allow the behavior of printing to be customized.\n  const PrintingCallbacks *Callbacks = nullptr;\n};\n\n}",
  "id": "BLOCK-CPP-12330",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/PrettyPrinter.h",
  "source_line": 19,
  "validation_status": "validated"
}