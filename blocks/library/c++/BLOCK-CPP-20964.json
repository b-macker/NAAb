{
  "code": "{\n\nclass TypeLoc;\n\n/// An object for streaming information to a record.\nclass ASTRecordWriter\n    : public serialization::DataStreamBasicWriter<ASTRecordWriter> {\n  using LocSeq = SourceLocationSequence;\n\n  ASTWriter *Writer;\n  ASTWriter::RecordDataImpl *Record;\n\n  /// Statements that we've encountered while serializing a\n  /// declaration or type.\n  SmallVector<Stmt *, 16> StmtsToEmit;\n\n  /// Indices of record elements that describe offsets within the\n  /// bitcode. These will be converted to offsets relative to the current\n  /// record when emitted.\n  SmallVector<unsigned, 8> OffsetIndices;\n\n  /// Flush all of the statements and expressions that have\n  /// been added to the queue via AddStmt().\n  void FlushStmts();\n  void FlushSubStmts();\n\n  void PrepareToEmit(uint64_t MyOffset) {\n    // Convert offsets into relative form.\n    for (unsigned I : OffsetIndices) {\n      auto &StoredOffset = (*Record)[I];\n      assert(StoredOffset < MyOffset && \"invalid offset\");\n      if (StoredOffset)\n        StoredOffset = MyOffset - StoredOffset;\n    }\n    OffsetIndices.clear();\n  }\n\npublic:\n  /// Construct a ASTRecordWriter that uses the default encoding scheme.\n  ASTRecordWriter(ASTWriter &W, ASTWriter::RecordDataImpl &Record)\n      : DataStreamBasicWriter(W.getASTContext()), Writer(&W), Record(&Record) {}\n\n  /// Construct a ASTRecordWriter that uses the same encoding scheme as another\n  /// ASTRecordWriter.\n  ASTRecordWriter(ASTRecordWriter &Parent, ASTWriter::RecordDataImpl &Record)\n      : DataStreamBasicWriter(Parent.getASTContext()), Writer(Parent.Writer),\n        Record(&Record) {}\n\n  /// Copying an ASTRecordWriter is almost certainly a bug.\n  ASTRecordWriter(const ASTRecordWriter &) = delete;\n  ASTRecordWriter &operator=(const ASTRecordWriter &) = delete;\n\n  /// Extract the underlying record storage.\n  ASTWriter::RecordDataImpl &getRecordData() const { return *Record; }\n\n  /// Minimal vector-like interface.\n  /// @{\n  void push_back(uint64_t N) { Record->push_back(N); }\n  template<typename InputIterator>\n  void append(InputIterator begin, InputIterator end) {\n    Record->append(begin, end);\n  }\n  bool empty() const { return Record->empty(); }\n  size_t size() const { return Record->size(); }\n  uint64_t &operator[](size_t N) { return (*Record)[N]; }\n  /// @}\n\n  /// Emit the record to the stream, followed by its substatements, and\n  /// return its offset.\n  // FIXME: Allow record producers to suggest Abbrevs.\n  uint64_t Emit(unsigned Code, unsigned Abbrev = 0) {\n    uint64_t Offset = Writer->Stream.GetCurrentBitNo();\n    PrepareToEmit(Offset);\n    Writer->Stream.EmitRecord(Code, *Record, Abbrev);\n    FlushStmts();\n    return Offset;\n  }\n\n  /// Emit the record to the stream, preceded by its substatements.\n  uint64_t EmitStmt(unsigned Code, unsigned Abbrev = 0) {\n    FlushSubStmts();\n    PrepareToEmit(Writer->Stream.GetCurrentBitNo());\n    Writer->Stream.EmitRecord(Code, *Record, Abbrev);\n    return Writer->Stream.GetCurrentBitNo();\n  }\n\n  /// Add a bit offset into the record. This will be converted into an\n  /// offset relative to the current record when emitted.\n  void AddOffset(uint64_t BitOffset) {\n    OffsetIndices.push_back(Record->size());\n    Record->push_back(BitOffset);\n  }\n\n  /// Add the given statement or expression to the queue of\n  /// statements to emit.\n  ///\n  /// This routine should be used when emitting types and declarations\n  /// that have expressions as part of their formulation. Once the\n  /// type or declaration has been written, Emit() will write\n  /// the corresponding statements just after the record.\n  void AddStmt(Stmt *S) {\n    StmtsToEmit.push_back(S);\n  }\n  void writeStmtRef(const Stmt *S) {\n    AddStmt(const_cast<Stmt*>(S));\n  }\n\n  /// Write an BTFTypeTagAttr object.\n  void writeBTFTypeTagAttr(const BTFTypeTagAttr *A) { AddAttr(A); }\n\n  /// Add a definition for the given function to the queue of statements\n  /// to emit.\n  void AddFunctionDefinition(const FunctionDecl *FD);\n\n  /// Emit a source location.\n  void AddSourceLocation(SourceLocation Loc, LocSeq *Seq = nullptr) {\n    return Writer->AddSourceLocation(Loc, *Record, Seq);\n  }\n  void writeSourceLocation(SourceLocation Loc) {\n    AddSourceLocation(Loc);\n  }\n\n  /// Emit a source range.\n  void AddSourceRange(SourceRange Range, LocSeq *Seq = nullptr) {\n    return Writer->AddSourceRange(Range, *Record, Seq);\n  }\n\n  void writeBool(bool Value) {\n    Record->push_back(Value);\n  }\n\n  void writeUInt32(uint32_t Value) {\n    Record->push_back(Value);\n  }\n\n  void writeUInt64(uint64_t Value) {\n    Record->push_back(Value);\n  }\n\n  /// Emit an integral value.\n  void AddAPInt(const llvm::APInt &Value) {\n    writeAPInt(Value);\n  }\n\n  /// Emit a signed integral value.\n  void AddAPSInt(const llvm::APSInt &Value) {\n    writeAPSInt(Value);\n  }\n\n  /// Emit a floating-point value.\n  void AddAPFloat(const llvm::APFloat &Value);\n\n  /// Emit an APvalue.\n  void AddAPValue(const APValue &Value) { writeAPValue(Value); }\n\n  /// Emit a reference to an identifier.\n  void AddIdentifierRef(const IdentifierInfo *II) {\n    return Writer->AddIdentifierRef(II, *Record);\n  }\n  void writeIdentifier(const IdentifierInfo *II) {\n    AddIdentifierRef(II);\n  }\n\n  /// Emit a Selector (which is a smart pointer reference).\n  void AddSelectorRef(Selector S);\n  void writeSelector(Selector sel) {\n    AddSelectorRef(sel);\n  }\n\n  /// Emit a CXXTemporary.\n  void AddCXXTemporary(const CXXTemporary *Temp);\n\n  /// Emit a C++ base specifier.\n  void AddCXXBaseSpecifier(const CXXBaseSpecifier &Base);\n\n  /// Emit a set of C++ base specifiers.\n  void AddCXXBaseSpecifiers(ArrayRef<CXXBaseSpecifier> Bases);\n\n  /// Emit a reference to a type.\n  void AddTypeRef(QualType T) {\n    return Writer->AddTypeRef(T, *Record);\n  }\n  void writeQualType(QualType T) {\n    AddTypeRef(T);\n  }\n\n  /// Emits a reference to a declarator info.\n  void AddTypeSourceInfo(TypeSourceInfo *TInfo);\n\n  /// Emits source location information for a type. Does not emit the type.\n  void AddTypeLoc(TypeLoc TL, LocSeq *Seq = nullptr);\n\n  /// Emits a template argument location info.\n  void AddTemplateArgumentLocInfo(TemplateArgument::ArgKind Kind,\n                                  const TemplateArgumentLocInfo &Arg);\n\n  /// Emits a template argument location.\n  void AddTemplateArgumentLoc(const TemplateArgumentLoc &Arg);\n\n  /// Emits an AST template argument list info.\n  void AddASTTemplateArgumentListInfo(\n      const ASTTemplateArgumentListInfo *ASTTemplArgList);\n\n  /// Emit a reference to a declaration.\n  void AddDeclRef(const Decl *D) {\n    return Writer->AddDeclRef(D, *Record);\n  }\n  void writeDeclRef(const Decl *D) {\n    AddDeclRef(D);\n  }\n\n  /// Emit a declaration name.\n  void AddDeclarationName(DeclarationName Name) {\n    writeDeclarationName(Name);\n  }\n\n  void AddDeclarationNameLoc(const DeclarationNameLoc &DNLoc,\n                             DeclarationName Name);\n  void AddDeclarationNameInfo(const DeclarationNameInfo &NameInfo);\n\n  void AddQualifierInfo(const QualifierInfo &Info);\n\n  /// Emit a nested name specifier.\n  void AddNestedNameSpecifier(NestedNameSpecifier *NNS) {\n    writeNestedNameSpecifier(NNS);\n  }\n\n  /// Emit a nested name specifier with source-location information.\n  void AddNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);\n\n  /// Emit a template name.\n  void AddTemplateName(TemplateName Name) {\n    writeTemplateName(Name);\n  }\n\n  /// Emit a template argument.\n  void AddTemplateArgument(const TemplateArgument &Arg) {\n    writeTemplateArgument(Arg);\n  }\n\n  /// Emit a template parameter list.\n  void AddTemplateParameterList(const TemplateParameterList *TemplateParams);\n\n  /// Emit a template argument list.\n  void AddTemplateArgumentList(const TemplateArgumentList *TemplateArgs);\n\n  /// Emit a UnresolvedSet structure.\n  void AddUnresolvedSet(const ASTUnresolvedSet &Set);\n\n  /// Emit a CXXCtorInitializer array.\n  void AddCXXCtorInitializers(ArrayRef<CXXCtorInitializer *> CtorInits);\n\n  void AddCXXDefinitionData(const CXXRecordDecl *D);\n\n  /// Emit information about the initializer of a VarDecl.\n  void AddVarDeclInit(const VarDecl *VD);\n\n  /// Write an OMPTraitInfo object.\n  void writeOMPTraitInfo(const OMPTraitInfo *TI);\n\n  void writeOMPClause(OMPClause *C);\n\n  /// Writes data related to the OpenMP directives.\n  void writeOMPChildren(OMPChildren *Data);\n\n  /// Emit a string.\n  void AddString(StringRef Str) {\n    return Writer->AddString(Str, *Record);\n  }\n\n  /// Emit a path.\n  void AddPath(StringRef Path) {\n    return Writer->AddPath(Path, *Record);\n  }\n\n  /// Emit a version tuple.\n  void AddVersionTuple(const VersionTuple &Version) {\n    return Writer->AddVersionTuple(Version, *Record);\n  }\n\n  // Emit an attribute.\n  void AddAttr(const Attr *A);\n\n  /// Emit a list of attributes.\n  void AddAttributes(ArrayRef<const Attr*> Attrs);\n};\n\n}",
  "id": "BLOCK-CPP-20964",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ASTRecordWriter.h",
  "source_line": 22,
  "validation_status": "validated"
}