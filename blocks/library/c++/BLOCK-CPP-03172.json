{
  "code": "{\n public:\n  explicit PointerMap(const Vec<Node*>* nodes) : nodes_(nodes) {\n    table_.fill(-1);\n  }\n\n  int32_t Find(void* ptr) {\n    auto masked = base_internal::HidePtr(ptr);\n    for (int32_t i = table_[Hash(ptr)]; i != -1;) {\n      Node* n = (*nodes_)[static_cast<uint32_t>(i)];\n      if (n->masked_ptr == masked) return i;\n      i = n->next_hash;\n    }\n    return -1;\n  }\n\n  void Add(void* ptr, int32_t i) {\n    int32_t* head = &table_[Hash(ptr)];\n    (*nodes_)[static_cast<uint32_t>(i)]->next_hash = *head;\n    *head = i;\n  }\n\n  int32_t Remove(void* ptr) {\n    // Advance through linked list while keeping track of the\n    // predecessor slot that points to the current entry.\n    auto masked = base_internal::HidePtr(ptr);\n    for (int32_t* slot = &table_[Hash(ptr)]; *slot != -1; ) {\n      int32_t index = *slot;\n      Node* n = (*nodes_)[static_cast<uint32_t>(index)];\n      if (n->masked_ptr == masked) {\n        *slot = n->next_hash;  // Remove n from linked list\n        n->next_hash = -1;\n        return index;\n      }\n      slot = &n->next_hash;\n    }\n    return -1;\n  }\n\n private:\n  // Number of buckets in hash table for pointer lookups.\n  static constexpr uint32_t kHashTableSize = 8171;  // should be prime\n\n  const Vec<Node*>* nodes_;\n  std::array<int32_t, kHashTableSize> table_;\n\n  static uint32_t Hash(void* ptr) {\n    return reinterpret_cast<uintptr_t>(ptr) % kHashTableSize;\n  }\n}",
  "id": "BLOCK-CPP-03172",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/graphcycles.cc",
  "source_line": 295,
  "validation_status": "validated"
}