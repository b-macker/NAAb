{
  "code": "#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclContextInternals.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include <cassert>\n#include <iterator>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-09501_execute() {\n    {\n\nclass ASTContext;\nclass CXXRecordDecl;\nclass NamedDecl;\n\n/// A dependently-generated diagnostic.\nclass DependentDiagnostic {\npublic:\n  enum AccessNonce { Access = 0 };\n\n  static DependentDiagnostic *Create(ASTContext &Context,\n                                     DeclContext *Parent,\n                                     AccessNonce _,\n                                     SourceLocation Loc,\n                                     bool IsMemberAccess,\n                                     AccessSpecifier AS,\n                                     NamedDecl *TargetDecl,\n                                     CXXRecordDecl *NamingClass,\n                                     QualType BaseObjectType,\n                                     const PartialDiagnostic &PDiag) {\n    DependentDiagnostic *DD = Create(Context, Parent, PDiag);\n    DD->AccessData.Loc = Loc;\n    DD->AccessData.IsMember = IsMemberAccess;\n    DD->AccessData.Access = AS;\n    DD->AccessData.TargetDecl = TargetDecl;\n    DD->AccessData.NamingClass = NamingClass;\n    DD->AccessData.BaseObjectType = BaseObjectType.getAsOpaquePtr();\n    return DD;\n  }\n\n  unsigned getKind() const {\n    return Access;\n  }\n\n  bool isAccessToMember() const {\n    assert(getKind() == Access);\n    return AccessData.IsMember;\n  }\n\n  AccessSpecifier getAccess() const {\n    assert(getKind() == Access);\n    return AccessSpecifier(AccessData.Access);\n  }\n\n  SourceLocation getAccessLoc() const {\n    assert(getKind() == Access);\n    return AccessData.Loc;\n  }\n\n  NamedDecl *getAccessTarget() const {\n    assert(getKind() == Access);\n    return AccessData.TargetDecl;\n  }\n\n  NamedDecl *getAccessNamingClass() const {\n    assert(getKind() == Access);\n    return AccessData.NamingClass;\n  }\n\n  QualType getAccessBaseObjectType() const {\n    assert(getKind() == Access);\n    return QualType::getFromOpaquePtr(AccessData.BaseObjectType);\n  }\n\n  const PartialDiagnostic &getDiagnostic() const {\n    return Diag;\n  }\n\nprivate:\n  friend class DeclContext::ddiag_iterator;\n  friend class DependentStoredDeclsMap;\n\n  DependentDiagnostic(const PartialDiagnostic &PDiag,\n                      DiagnosticStorage *Storage)\n      : Diag(PDiag, Storage) {}\n\n  static DependentDiagnostic *Create(ASTContext &Context,\n                                     DeclContext *Parent,\n                                     const PartialDiagnostic &PDiag);\n\n  DependentDiagnostic *NextDiagnostic;\n\n  PartialDiagnostic Diag;\n\n  struct {\n    SourceLocation Loc;\n    unsigned Access : 2;\n    unsigned IsMember : 1;\n    NamedDecl *TargetDecl;\n    CXXRecordDecl *NamingClass;\n    void *BaseObjectType;\n  } AccessData;\n};\n\n/// An iterator over the dependent diagnostics in a dependent context.\nclass DeclContext::ddiag_iterator {\npublic:\n  ddiag_iterator() = default;\n  explicit ddiag_iterator(DependentDiagnostic *Ptr) : Ptr(Ptr) {}\n\n  using value_type = DependentDiagnostic *;\n  using reference = DependentDiagnostic *;\n  using pointer = DependentDiagnostic *;\n  using difference_type = int;\n  using iterator_category = std::forward_iterator_tag;\n\n  reference operator*() const { return Ptr; }\n\n  ddiag_iterator &operator++() {\n    assert(Ptr && \"attempt to increment past end of diag list\");\n    Ptr = Ptr->NextDiagnostic;\n    return *this;\n  }\n\n  ddiag_iterator operator++(int) {\n    ddiag_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  bool operator==(ddiag_iterator Other) const {\n    return Ptr == Other.Ptr;\n  }\n\n  bool operator!=(ddiag_iterator Other) const {\n    return Ptr != Other.Ptr;\n  }\n\n  ddiag_iterator &operator+=(difference_type N) {\n    assert(N >= 0 && \"cannot rewind a DeclContext::ddiag_iterator\");\n    while (N--)\n      ++*this;\n    return *this;\n  }\n\n  ddiag_iterator operator+(difference_type N) const {\n    ddiag_iterator tmp = *this;\n    tmp += N;\n    return tmp;\n  }\n\nprivate:\n  DependentDiagnostic *Ptr = nullptr;\n};\n\ninline DeclContext::ddiag_range DeclContext::ddiags() const {\n  assert(isDependentContext()\n         && \"cannot iterate dependent diagnostics of non-dependent context\");\n  const DependentStoredDeclsMap *Map\n    = static_cast<DependentStoredDeclsMap*>(getPrimaryContext()->getLookupPtr());\n\n  if (!Map)\n    // Return an empty range using the always-end default constructor.\n    return ddiag_range(ddiag_iterator(), ddiag_iterator());\n\n  return ddiag_range(ddiag_iterator(Map->FirstDiagnostic), ddiag_iterator());\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-09501",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DependentDiagnostic.h",
  "source_line": 29,
  "validation_status": "validated"
}