{
  "code": "{\npublic:\n  enum ManglerKind {\n    MK_Itanium,\n    MK_Microsoft\n  };\n\nprivate:\n  virtual void anchor();\n\n  ASTContext &Context;\n  DiagnosticsEngine &Diags;\n  const ManglerKind Kind;\n  /// For aux target. If true, uses mangling number for aux target from\n  /// ASTContext.\n  bool IsAux = false;\n\n  llvm::DenseMap<const BlockDecl*, unsigned> GlobalBlockIds;\n  llvm::DenseMap<const BlockDecl*, unsigned> LocalBlockIds;\n  llvm::DenseMap<const NamedDecl*, uint64_t> AnonStructIds;\n  llvm::DenseMap<const FunctionDecl*, unsigned> FuncAnonStructSize;\n\npublic:\n  ManglerKind getKind() const { return Kind; }\n\n  bool isAux() const { return IsAux; }\n\n  explicit MangleContext(ASTContext &Context, DiagnosticsEngine &Diags,\n                         ManglerKind Kind, bool IsAux = false)\n      : Context(Context), Diags(Diags), Kind(Kind), IsAux(IsAux) {}\n\n  virtual ~MangleContext() { }\n\n  ASTContext &getASTContext() const { return Context; }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  virtual void startNewFunction() { LocalBlockIds.clear(); }\n\n  unsigned getBlockId(const BlockDecl *BD, bool Local) {\n    llvm::DenseMap<const BlockDecl *, unsigned> &BlockIds\n      = Local? LocalBlockIds : GlobalBlockIds;\n    std::pair<llvm::DenseMap<const BlockDecl *, unsigned>::iterator, bool>\n      Result = BlockIds.insert(std::make_pair(BD, BlockIds.size()));\n    return Result.first->second;\n  }\n\n  uint64_t getAnonymousStructId(const NamedDecl *D,\n                                const FunctionDecl *FD = nullptr) {\n    auto FindResult = AnonStructIds.find(D);\n    if (FindResult != AnonStructIds.end())\n      return FindResult->second;\n\n    // If FunctionDecl is passed in, the anonymous structID will be per-function\n    // based.\n    unsigned Id = FD ? FuncAnonStructSize[FD]++ : AnonStructIds.size();\n    std::pair<llvm::DenseMap<const NamedDecl *, uint64_t>::iterator, bool>\n        Result = AnonStructIds.insert(std::make_pair(D, Id));\n    return Result.first->second;\n  }\n\n  uint64_t getAnonymousStructIdForDebugInfo(const NamedDecl *D) {\n    llvm::DenseMap<const NamedDecl *, uint64_t>::iterator Result =\n        AnonStructIds.find(D);\n    // The decl should already be inserted, but return 0 in case it is not.\n    if (Result == AnonStructIds.end())\n      return 0;\n    return Result->second;\n  }\n\n  virtual std::string getLambdaString(const CXXRecordDecl *Lambda) = 0;\n\n  /// @name Mangler Entry Points\n  /// @{\n\n  bool shouldMangleDeclName(const NamedDecl *D);\n  virtual bool shouldMangleCXXName(const NamedDecl *D) = 0;\n  virtual bool shouldMangleStringLiteral(const StringLiteral *SL) = 0;\n\n  virtual bool isUniqueInternalLinkageDecl(const NamedDecl *ND) {\n    return false;\n  }\n\n  virtual void needsUniqueInternalLinkageNames() { }\n\n  // FIXME: consider replacing raw_ostream & with something like SmallString &.\n  void mangleName(GlobalDecl GD, raw_ostream &);\n  virtual void mangleCXXName(GlobalDecl GD, raw_ostream &) = 0;\n  virtual void mangleThunk(const CXXMethodDecl *MD,\n                          const ThunkInfo &Thunk,\n                          raw_ostream &) = 0;\n  virtual void mangleCXXDtorThunk(const CXXDestructorDecl *DD, CXXDtorType Type,\n                                  const ThisAdjustment &ThisAdjustment,\n                                  raw_ostream &) = 0;\n  virtual void mangleReferenceTemporary(const VarDecl *D,\n                                        unsigned ManglingNumber,\n                                        raw_ostream &) = 0;\n  virtual void mangleCXXRTTI(QualType T, raw_ostream &) = 0;\n  virtual void mangleCXXRTTIName(QualType T, raw_ostream &,\n                                 bool NormalizeIntegers = false) = 0;\n  virtual void mangleStringLiteral(const StringLiteral *SL, raw_ostream &) = 0;\n  virtual void mangleMSGuidDecl(const MSGuidDecl *GD, raw_ostream&);\n\n  void mangleGlobalBlock(const BlockDecl *BD,\n                         const NamedDecl *ID,\n                         raw_ostream &Out);\n  void mangleCtorBlock(const CXXConstructorDecl *CD, CXXCtorType CT,\n                       const BlockDecl *BD, raw_ostream &Out);\n  void mangleDtorBlock(const CXXDestructorDecl *CD, CXXDtorType DT,\n                       const BlockDecl *BD, raw_ostream &Out);\n  void mangleBlock(const DeclContext *DC, const BlockDecl *BD,\n                   raw_ostream &Out);\n\n  void mangleObjCMethodName(const ObjCMethodDecl *MD, raw_ostream &OS,\n                            bool includePrefixByte = true,\n                            bool includeCategoryNamespace = true);\n  void mangleObjCMethodNameAsSourceName(const ObjCMethodDecl *MD,\n                                        raw_ostream &);\n\n  virtual void mangleStaticGuardVariable(const VarDecl *D, raw_ostream &) = 0;\n\n  virtual void mangleDynamicInitializer(const VarDecl *D, raw_ostream &) = 0;\n\n  virtual void mangleDynamicAtExitDestructor(const VarDecl *D,\n                                             raw_ostream &) = 0;\n\n  virtual void mangleSEHFilterExpression(GlobalDecl EnclosingDecl,\n                                         raw_ostream &Out) = 0;\n\n  virtual void mangleSEHFinallyBlock(GlobalDecl EnclosingDecl,\n                                     raw_ostream &Out) = 0;\n\n  /// Generates a unique string for an externally visible type for use with TBAA\n  /// or type uniquing.\n  /// TODO: Extend this to internal types by generating names that are unique\n  /// across translation units so it can be used with LTO.\n  virtual void mangleTypeName(QualType T, raw_ostream &,\n                              bool NormalizeIntegers = false) = 0;\n\n  /// @}\n}",
  "id": "BLOCK-CPP-11291",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Mangle.h",
  "source_line": 45,
  "validation_status": "validated"
}