{
  "code": "{\n\nclass AnalysisDeclContext;\nclass BlockDecl;\nclass CFG;\nclass Decl;\nclass Expr;\nclass ParmVarDecl;\nclass Stmt;\n\n/// Classification of situations when parameter is not called on every path.\n/// \\enum IfThen -- then branch of the if statement has no call.\n/// \\enum IfElse -- else branch of the if statement has no call.\n/// \\enum Switch -- one of the switch cases doesn't have a call.\n/// \\enum SwitchSkipped -- there is no call if none of the cases applies.\n/// \\enum LoopEntered -- no call when the loop is entered.\n/// \\enum LoopSkipped -- no call when the loop is not entered.\n/// \\enum FallbackReason -- fallback case when we were not able to figure out\n/// the reason.\nenum class NeverCalledReason {\n  IfThen,\n  IfElse,\n  Switch,\n  SwitchSkipped,\n  LoopEntered,\n  LoopSkipped,\n  FallbackReason,\n  LARGEST_VALUE = FallbackReason\n};\n\nclass CalledOnceCheckHandler {\npublic:\n  CalledOnceCheckHandler() = default;\n  virtual ~CalledOnceCheckHandler() = default;\n\n  /// Called when parameter is called twice.\n  /// \\param Parameter -- parameter that should be called once.\n  /// \\param Call -- call to report the warning.\n  /// \\param PrevCall -- previous call.\n  /// \\param IsCompletionHandler -- true, if parameter is a completion handler.\n  /// \\param Poised -- true, if the second call is guaranteed to happen after\n  /// the first call.\n  virtual void handleDoubleCall(const ParmVarDecl *Parameter, const Expr *Call,\n                                const Expr *PrevCall, bool IsCompletionHandler,\n                                bool Poised) {}\n\n  /// Called when parameter is not called at all.\n  /// \\param Parameter -- parameter that should be called once.\n  /// \\param IsCompletionHandler -- true, if parameter is a completion handler.\n  virtual void handleNeverCalled(const ParmVarDecl *Parameter,\n                                 bool IsCompletionHandler) {}\n\n  /// Called when captured parameter is not called at all.\n  /// \\param Parameter -- parameter that should be called once.\n  /// \\param Where -- declaration that captures \\p Parameter\n  /// \\param IsCompletionHandler -- true, if parameter is a completion handler.\n  virtual void handleCapturedNeverCalled(const ParmVarDecl *Parameter,\n                                         const Decl *Where,\n                                         bool IsCompletionHandler) {}\n\n  /// Called when parameter is not called on one of the paths.\n  /// Usually we try to find a statement that is the least common ancestor of\n  /// the path containing the call and not containing the call.  This helps us\n  /// to pinpoint a bad path for the user.\n  /// \\param Parameter -- parameter that should be called once.\n  /// \\param Function -- function declaration where the problem occurred.\n  /// \\param Where -- the least common ancestor statement.\n  /// \\param Reason -- a reason describing the path without a call.\n  /// \\param IsCalledDirectly -- true, if parameter actually gets called on\n  /// the other path.  It is opposed to be used in some other way (added to some\n  /// collection, passed as a parameter, etc.).\n  /// \\param IsCompletionHandler -- true, if parameter is a completion handler.\n  virtual void handleNeverCalled(const ParmVarDecl *Parameter,\n                                 const Decl *Function, const Stmt *Where,\n                                 NeverCalledReason Reason,\n                                 bool IsCalledDirectly,\n                                 bool IsCompletionHandler) {}\n\n  /// Called when the block is guaranteed to be called exactly once.\n  /// It means that we can be stricter with what we report on that block.\n  /// \\param Block -- block declaration that is known to be called exactly once.\n  virtual void\n  handleBlockThatIsGuaranteedToBeCalledOnce(const BlockDecl *Block) {}\n\n  /// Called when the block has no guarantees about how many times it can get\n  /// called.\n  /// It means that we should be more lenient with reporting warnings in it.\n  /// \\param Block -- block declaration in question.\n  virtual void handleBlockWithNoGuarantees(const BlockDecl *Block) {}\n};\n\n/// Check given CFG for 'called once' parameter violations.\n///\n/// It traverses the function and tracks how such parameters are used.\n/// It detects two main violations:\n///   * parameter is called twice\n///   * parameter is not called\n///\n/// \\param AC -- context.\n/// \\param Handler -- a handler for found violations.\n/// \\param CheckConventionalParameters -- true, if we want to check parameters\n/// not explicitly marked as 'called once', but having the same requirements\n/// according to conventions.\nvoid checkCalledOnceParameters(AnalysisDeclContext &AC,\n                               CalledOnceCheckHandler &Handler,\n                               bool CheckConventionalParameters);\n\n}",
  "id": "BLOCK-CPP-21316",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/CalledOnceCheck.h",
  "source_line": 17,
  "validation_status": "validated"
}