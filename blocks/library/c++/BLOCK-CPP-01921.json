{
  "code": "{\n  static const char kPad64Equals = '=';\n  static const char kPad64Dot = '.';\n\n  size_t destidx = 0;\n  int decode = 0;\n  int state = 0;\n  unsigned char ch = 0;\n  unsigned int temp = 0;\n\n  // If \"char\" is signed by default, using *src as an array index results in\n  // accessing negative array elements. Treat the input as a pointer to\n  // unsigned char to avoid this.\n  const unsigned char* src = reinterpret_cast<const unsigned char*>(src_param);\n\n  // The GET_INPUT macro gets the next input character, skipping\n  // over any whitespace, and stopping when we reach the end of the\n  // string or when we read any non-data character.  The arguments are\n  // an arbitrary identifier (used as a label for goto) and the number\n  // of data bytes that must remain in the input to avoid aborting the\n  // loop.\n#define GET_INPUT(label, remain)                                \\\n  label:                                                        \\\n  --szsrc;                                                      \\\n  ch = *src++;                                                  \\\n  decode = unbase64[ch];                                        \\\n  if (decode < 0) {                                             \\\n    if (absl::ascii_isspace(ch) && szsrc >= remain) goto label; \\\n    state = 4 - remain;                                         \\\n    break;                                                      \\\n  }\n\n  // if dest is null, we're just checking to see if it's legal input\n  // rather than producing output.  (I suspect this could just be done\n  // with a regexp...).  We duplicate the loop so this test can be\n  // outside it instead of in every iteration.\n\n  if (dest) {\n    // This loop consumes 4 input bytes and produces 3 output bytes\n    // per iteration.  We can't know at the start that there is enough\n    // data left in the string for a full iteration, so the loop may\n    // break out in the middle; if so 'state' will be set to the\n    // number of input bytes read.\n\n    while (szsrc >= 4) {\n      // We'll start by optimistically assuming that the next four\n      // bytes of the string (src[0..3]) are four good data bytes\n      // (that is, no nulls, whitespace, padding chars, or illegal\n      // chars).  We need to test src[0..2] for nulls individually\n      // before constructing temp to preserve the property that we\n      // never read past a null in the string (no matter how long\n      // szsrc claims the string is).\n\n      if (!src[0] || !src[1] || !src[2] ||\n          ((temp = ((unsigned(unbase64[src[0]]) << 18) |\n                    (unsigned(unbase64[src[1]]) << 12) |\n                    (unsigned(unbase64[src[2]]) << 6) |\n                    (unsigned(unbase64[src[3]])))) &\n           0x80000000)) {\n        // Iff any of those four characters was bad (null, illegal,\n        // whitespace, padding), then temp's high bit will be set\n        // (because unbase64[] is -1 for all bad characters).\n        //\n        // We'll back up and resort to the slower decoder, which knows\n        // how to handle those cases.\n\n        GET_INPUT(first, 4);\n        temp = static_cast<unsigned char>(decode);\n        GET_INPUT(second, 3);\n        temp = (temp << 6) | static_cast<unsigned char>(decode);\n        GET_INPUT(third, 2);\n        temp = (temp << 6) | static_cast<unsigned char>(decode);\n        GET_INPUT(fourth, 1);\n        temp = (temp << 6) | static_cast<unsigned char>(decode);\n      } else {\n        // We really did have four good data bytes, so advance four\n        // characters in the string.\n\n        szsrc -= 4;\n        src += 4;\n      }\n\n      // temp has 24 bits of input, so write that out as three bytes.\n\n      if (destidx + 3 > szdest) return false;\n      dest[destidx + 2] = static_cast<char>(temp);\n      temp >>= 8;\n      dest[destidx + 1] = static_cast<char>(temp);\n      temp >>= 8;\n      dest[destidx] = static_cast<char>(temp);\n      destidx += 3;\n    }\n  } else {\n    while (szsrc >= 4) {\n      if (!src[0] || !src[1] || !src[2] ||\n          ((temp = ((unsigned(unbase64[src[0]]) << 18) |\n                    (unsigned(unbase64[src[1]]) << 12) |\n                    (unsigned(unbase64[src[2]]) << 6) |\n                    (unsigned(unbase64[src[3]])))) &\n           0x80000000)) {\n        GET_INPUT(first_no_dest, 4);\n        GET_INPUT(second_no_dest, 3);\n        GET_INPUT(third_no_dest, 2);\n        GET_INPUT(fourth_no_dest, 1);\n      } else {\n        szsrc -= 4;\n        src += 4;\n      }\n      destidx += 3;\n    }\n  }\n\n#undef GET_INPUT\n\n  // if the loop terminated because we read a bad character, return\n  // now.\n  if (decode < 0 && ch != kPad64Equals && ch != kPad64Dot &&\n      !absl::ascii_isspace(ch))\n    return false;\n\n  if (ch == kPad64Equals || ch == kPad64Dot) {\n    // if we stopped by hitting an '=' or '.', un-read that character -- we'll\n    // look at it again when we count to check for the proper number of\n    // equals signs at the end.\n    ++szsrc;\n    --src;\n  } else {\n    // This loop consumes 1 input byte per iteration.  It's used to\n    // clean up the 0-3 input bytes remaining when the first, faster\n    // loop finishes.  'temp' contains the data from 'state' input\n    // characters read by the first loop.\n    while (szsrc > 0) {\n      --szsrc;\n      ch = *src++;\n      decode = unbase64[ch];\n      if (decode < 0) {\n        if (absl::ascii_isspace(ch)) {\n          continue;\n        } else if (ch == kPad64Equals || ch == kPad64Dot) {\n          // back up one character; we'll read it again when we check\n          // for the correct number of pad characters at the end.\n          ++szsrc;\n          --src;\n          break;\n        } else {\n          return false;\n        }\n      }\n\n      // Each input character gives us six bits of output.\n      temp = (temp << 6) | static_cast<unsigned char>(decode);\n      ++state;\n      if (state == 4) {\n        // If we've accumulated 24 bits of output, write that out as\n        // three bytes.\n        if (dest) {\n          if (destidx + 3 > szdest) return false;\n          dest[destidx + 2] = static_cast<char>(temp);\n          temp >>= 8;\n          dest[destidx + 1] = static_cast<char>(temp);\n          temp >>= 8;\n          dest[destidx] = static_cast<char>(temp);\n        }\n        destidx += 3;\n        state = 0;\n        temp = 0;\n      }\n    }\n  }\n\n  // Process the leftover data contained in 'temp' at the end of the input.\n  int expected_equals = 0;\n  switch (state) {\n    case 0:\n      // Nothing left over; output is a multiple of 3 bytes.\n      break;\n\n    case 1:\n      // Bad input; we have 6 bits left over.\n      return false;\n\n    case 2:\n      // Produce one more output byte from the 12 input bits we have left.\n      if (dest) {\n        if (destidx + 1 > szdest) return false;\n        temp >>= 4;\n        dest[destidx] = static_cast<char>(temp);\n      }\n      ++destidx;\n      expected_equals = 2;\n      break;\n\n    case 3:\n      // Produce two more output bytes from the 18 input bits we have left.\n      if (dest) {\n        if (destidx + 2 > szdest) return false;\n        temp >>= 2;\n        dest[destidx + 1] = static_cast<char>(temp);\n        temp >>= 8;\n        dest[destidx] = static_cast<char>(temp);\n      }\n      destidx += 2;\n      expected_equals = 1;\n      break;\n\n    default:\n      // state should have no other values at this point.\n      ABSL_RAW_LOG(FATAL, \"This can't happen; base64 decoder state = %d\",\n                   state);\n  }\n\n  // The remainder of the string should be all whitespace, mixed with\n  // exactly 0 equals signs, or exactly 'expected_equals' equals\n  // signs.  (Always accepting 0 equals signs is an Abseil extension\n  // not covered in the RFC, as is accepting dot as the pad character.)\n\n  int equals = 0;\n  while (szsrc > 0) {\n    if (*src == kPad64Equals || *src == kPad64Dot)\n      ++equals;\n    else if (!absl::ascii_isspace(*src))\n      return false;\n    --szsrc;\n    ++src;\n  }\n\n  const bool ok = (equals == 0 || equals == expected_equals);\n  if (ok) *len = destidx;\n  return ok;\n}",
  "id": "BLOCK-CPP-01921",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/escaping.cc",
  "source_line": 449,
  "validation_status": "validated"
}