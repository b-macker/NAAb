{
  "code": "{\npublic:\n  SExpr() = delete;\n\n  TIL_Opcode opcode() const { return Opcode; }\n\n  // Subclasses of SExpr must define the following:\n  //\n  // This(const This& E, ...) {\n  //   copy constructor: construct copy of E, with some additional arguments.\n  // }\n  //\n  // template <class V>\n  // typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {\n  //   traverse all subexpressions, following the traversal/rewriter interface.\n  // }\n  //\n  // template <class C> typename C::CType compare(CType* E, C& Cmp) {\n  //   compare all subexpressions, following the comparator interface\n  // }\n  void *operator new(size_t S, MemRegionRef &R) {\n    return ::operator new(S, R);\n  }\n\n  /// SExpr objects must be created in an arena.\n  void *operator new(size_t) = delete;\n\n  /// SExpr objects cannot be deleted.\n  // This declaration is public to workaround a gcc bug that breaks building\n  // with REQUIRES_EH=1.\n  void operator delete(void *) = delete;\n\n  /// Returns the instruction ID for this expression.\n  /// All basic block instructions have a unique ID (i.e. virtual register).\n  unsigned id() const { return SExprID; }\n\n  /// Returns the block, if this is an instruction in a basic block,\n  /// otherwise returns null.\n  BasicBlock *block() const { return Block; }\n\n  /// Set the basic block and instruction ID for this expression.\n  void setID(BasicBlock *B, unsigned id) { Block = B; SExprID = id; }\n\nprotected:\n  SExpr(TIL_Opcode Op) : Opcode(Op) {}\n  SExpr(const SExpr &E) : Opcode(E.Opcode), Flags(E.Flags) {}\n  SExpr &operator=(const SExpr &) = delete;\n\n  const TIL_Opcode Opcode;\n  unsigned char Reserved = 0;\n  unsigned short Flags = 0;\n  unsigned SExprID = 0;\n  BasicBlock *Block = nullptr;\n}",
  "id": "BLOCK-CPP-21645",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h",
  "source_line": 276,
  "validation_status": "validated"
}