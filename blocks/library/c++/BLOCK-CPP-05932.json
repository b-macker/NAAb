{
  "code": "#include <cinttypes>\n#include <limits>\n#include \"absl/random/internal/traits.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05932_execute() {\n    {\n\n// RandenPool is a thread-safe random number generator [random.req.urbg] that\n// uses an underlying pool of Randen generators to generate values.  Each thread\n// has affinity to one instance of the underlying pool generators.  Concurrent\n// access is guarded by a spin-lock.\ntemplate <typename T>\nclass RandenPool {\n public:\n  using result_type = T;\n  static_assert(std::is_unsigned<result_type>::value,\n                \"RandenPool template argument must be a built-in unsigned \"\n                \"integer type\");\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  RandenPool() {}\n\n  // Returns a single value.\n  inline result_type operator()() { return Generate(); }\n\n  // Fill data with random values.\n  static void Fill(absl::Span<result_type> data);\n\n protected:\n  // Generate returns a single value.\n  static result_type Generate();\n};\n\nextern template class RandenPool<uint8_t>;\nextern template class RandenPool<uint16_t>;\nextern template class RandenPool<uint32_t>;\nextern template class RandenPool<uint64_t>;\n\n// PoolURBG uses an underlying pool of random generators to implement a\n// thread-compatible [random.req.urbg] interface with an internal cache of\n// values.\ntemplate <typename T, size_t kBufferSize>\nclass PoolURBG {\n  // Inheritance to access the protected static members of RandenPool.\n  using unsigned_type = typename make_unsigned_bits<T>::type;\n  using PoolType = RandenPool<unsigned_type>;\n  using SpanType = absl::Span<unsigned_type>;\n\n  static constexpr size_t kInitialBuffer = kBufferSize + 1;\n  static constexpr size_t kHalfBuffer = kBufferSize / 2;\n\n public:\n  using result_type = T;\n\n  static_assert(std::is_unsigned<result_type>::value,\n                \"PoolURBG must be parameterized by an unsigned integer type\");\n\n  static_assert(kBufferSize > 1,\n                \"PoolURBG must be parameterized by a buffer-size > 1\");\n\n  static_assert(kBufferSize <= 256,\n                \"PoolURBG must be parameterized by a buffer-size <= 256\");\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  PoolURBG() : next_(kInitialBuffer) {}\n\n  // copy-constructor does not copy cache.\n  PoolURBG(const PoolURBG&) : next_(kInitialBuffer) {}\n  const PoolURBG& operator=(const PoolURBG&) {\n    next_ = kInitialBuffer;\n    return *this;\n  }\n\n  // move-constructor does move cache.\n  PoolURBG(PoolURBG&&) = default;\n  PoolURBG& operator=(PoolURBG&&) = default;\n\n  inline result_type operator()() {\n    if (next_ >= kBufferSize) {\n      next_ = (kBufferSize > 2 && next_ > kBufferSize) ? kHalfBuffer : 0;\n      PoolType::Fill(SpanType(reinterpret_cast<unsigned_type*>(state_ + next_),\n                              kBufferSize - next_));\n    }\n    return state_[next_++];\n  }\n\n private:\n  // Buffer size.\n  size_t next_;  // index within state_\n  result_type state_[kBufferSize];\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05932",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/pool_urbg.h",
  "source_line": 26,
  "validation_status": "validated"
}