{
  "code": "using namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17351_execute() {\n    {\n\n/// Specifies the kind of template name that an identifier refers to.\n/// Be careful when changing this: this enumeration is used in diagnostics.\nenum TemplateNameKind {\n  /// The name does not refer to a template.\n  TNK_Non_template = 0,\n  /// The name refers to a function template or a set of overloaded\n  /// functions that includes at least one function template, or (in C++20)\n  /// refers to a set of non-template functions but is followed by a '<'.\n  TNK_Function_template,\n  /// The name refers to a template whose specialization produces a\n  /// type. The template itself could be a class template, template\n  /// template parameter, or template alias.\n  TNK_Type_template,\n  /// The name refers to a variable template whose specialization produces a\n  /// variable.\n  TNK_Var_template,\n  /// The name refers to a dependent template name:\n  /// \\code\n  /// template<typename MetaFun, typename T1, typename T2> struct apply2 {\n  ///   typedef typename MetaFun::template apply<T1, T2>::type type;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, \"apply\" is a dependent template name within the typename\n  /// specifier in the typedef. \"apply\" is a nested template, and\n  /// whether the template name is assumed to refer to a type template or a\n  /// function template depends on the context in which the template\n  /// name occurs.\n  TNK_Dependent_template_name,\n  /// Lookup for the name failed, but we're assuming it was a template name\n  /// anyway. In C++20, this is mandatory in order to parse ADL-only function\n  /// template specialization calls.\n  TNK_Undeclared_template,\n  /// The name refers to a concept.\n  TNK_Concept_template,\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17351",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/TemplateKinds.h",
  "source_line": 16,
  "validation_status": "validated"
}