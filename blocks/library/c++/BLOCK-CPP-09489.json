{
  "code": "{\npublic:\n  enum Bits : uint8_t {\n    None = 0,\n\n    // Contains a template parameter pack that wasn't expanded.\n    UnexpandedPack = 1,\n    // Depends on a template parameter or an error in some way.\n    // Validity depends on how the template is instantiated or the error is\n    // resolved.\n    Instantiation = 2,\n    // Expression type depends on template context, or an error.\n    // Value and Instantiation should also be set.\n    Type = 4,\n    // Expression value depends on template context, or an error.\n    // Instantiation should also be set.\n    Value = 8,\n    // Depends on template context, or an error.\n    // The type/value distinction is only meaningful for expressions.\n    Dependent = Type | Value,\n    // Includes an error, and depends on how it is resolved.\n    Error = 16,\n    // Type depends on a runtime value (variable-length array).\n    VariablyModified = 32,\n\n    // Dependence that is propagated syntactically, regardless of semantics.\n    Syntactic = UnexpandedPack | Instantiation | Error,\n    // Dependence that is propagated semantically, even in cases where the\n    // type doesn't syntactically appear. This currently excludes only\n    // UnexpandedPack. Even though Instantiation dependence is also notionally\n    // syntactic, we also want to propagate it semantically because anything\n    // that semantically depends on an instantiation-dependent entity should\n    // always be instantiated when that instantiation-dependent entity is.\n    Semantic =\n        Instantiation | Type | Value | Dependent | Error | VariablyModified,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/VariablyModified)\n  };\n\n  Dependence() : V(None) {}\n\n  Dependence(TypeDependence D)\n      : V(translate(D, TypeDependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TypeDependence::Instantiation, Instantiation) |\n          translate(D, TypeDependence::Dependent, Dependent) |\n          translate(D, TypeDependence::Error, Error) |\n          translate(D, TypeDependence::VariablyModified, VariablyModified)) {}\n\n  Dependence(ExprDependence D)\n      : V(translate(D, ExprDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, ExprDependence::Instantiation, Instantiation) |\n             translate(D, ExprDependence::Type, Type) |\n             translate(D, ExprDependence::Value, Value) |\n             translate(D, ExprDependence::Error, Error)) {}\n\n  Dependence(NestedNameSpecifierDependence D) :\n    V ( translate(D, NNSDependence::UnexpandedPack, UnexpandedPack) |\n            translate(D, NNSDependence::Instantiation, Instantiation) |\n            translate(D, NNSDependence::Dependent, Dependent) |\n            translate(D, NNSDependence::Error, Error)) {}\n\n  Dependence(TemplateArgumentDependence D)\n      : V(translate(D, TADependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TADependence::Instantiation, Instantiation) |\n          translate(D, TADependence::Dependent, Dependent) |\n          translate(D, TADependence::Error, Error)) {}\n\n  Dependence(TemplateNameDependence D)\n      : V(translate(D, TNDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, TNDependence::Instantiation, Instantiation) |\n             translate(D, TNDependence::Dependent, Dependent) |\n             translate(D, TNDependence::Error, Error)) {}\n\n  /// Extract only the syntactic portions of this type's dependence.\n  Dependence syntactic() {\n    Dependence Result = *this;\n    Result.V &= Syntactic;\n    return Result;\n  }\n\n  /// Extract the semantic portions of this type's dependence that apply even\n  /// to uses where the type does not appear syntactically.\n  Dependence semantic() {\n    Dependence Result = *this;\n    Result.V &= Semantic;\n    return Result;\n  }\n\n  TypeDependence type() const {\n    return translate(V, UnexpandedPack, TypeDependence::UnexpandedPack) |\n           translate(V, Instantiation, TypeDependence::Instantiation) |\n           translate(V, Dependent, TypeDependence::Dependent) |\n           translate(V, Error, TypeDependence::Error) |\n           translate(V, VariablyModified, TypeDependence::VariablyModified);\n  }\n\n  ExprDependence expr() const {\n    return translate(V, UnexpandedPack, ExprDependence::UnexpandedPack) |\n           translate(V, Instantiation, ExprDependence::Instantiation) |\n           translate(V, Type, ExprDependence::Type) |\n           translate(V, Value, ExprDependence::Value) |\n           translate(V, Error, ExprDependence::Error);\n  }\n\n  NestedNameSpecifierDependence nestedNameSpecifier() const {\n    return translate(V, UnexpandedPack, NNSDependence::UnexpandedPack) |\n           translate(V, Instantiation, NNSDependence::Instantiation) |\n           translate(V, Dependent, NNSDependence::Dependent) |\n           translate(V, Error, NNSDependence::Error);\n  }\n\n  TemplateArgumentDependence templateArgument() const {\n    return translate(V, UnexpandedPack, TADependence::UnexpandedPack) |\n           translate(V, Instantiation, TADependence::Instantiation) |\n           translate(V, Dependent, TADependence::Dependent) |\n           translate(V, Error, TADependence::Error);\n  }\n\n  TemplateNameDependence templateName() const {\n    return translate(V, UnexpandedPack, TNDependence::UnexpandedPack) |\n           translate(V, Instantiation, TNDependence::Instantiation) |\n           translate(V, Dependent, TNDependence::Dependent) |\n           translate(V, Error, TNDependence::Error);\n  }\n\nprivate:\n  Bits V;\n\n  template <typename T, typename U>\n  static U translate(T Bits, T FromBit, U ToBit) {\n    return (Bits & FromBit) ? ToBit : static_cast<U>(0);\n  }\n\n  // Abbreviations to make conversions more readable.\n  using NNSDependence = NestedNameSpecifierDependence;\n  using TADependence = TemplateArgumentDependence;\n  using TNDependence = TemplateNameDependence;\n}",
  "id": "BLOCK-CPP-09489",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DependenceFlags.h",
  "source_line": 106,
  "validation_status": "validated"
}