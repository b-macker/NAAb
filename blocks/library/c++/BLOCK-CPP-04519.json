{
  "code": "#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/internal/throw_delegate.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/base/port.h\"    // TODO(strel): remove this include\n#include \"absl/meta/type_traits.h\"\n#include \"absl/types/internal/span.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04519_execute() {\n    {\n//     ...\n//   };\n//   // my_vector is a container of non-const types\n//   std::vector<MyComplicatedType> my_vector;\n//\n//   // Constructing a Span implicitly attempts to create a Span of type\n//   // `Span<const T>`\n//   MyRoutine(my_vector);                // error, type mismatch\n//\n//   // Explicitly constructing the Span is verbose\n//   MyRoutine(absl::Span<MyComplicatedType>(my_vector));\n//\n//   // Use MakeSpan() to make an absl::Span<T>\n//   MyRoutine(absl::MakeSpan(my_vector));\n//\n//   // Construct a span from an array ptr+size\n//   absl::Span<T> my_span() {\n//     return absl::MakeSpan(&array[0], num_elements_);\n//   }\n//\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nconstexpr Span<T> MakeSpan(absl::Nullable<T*> ptr, size_t size) noexcept {\n  return Span<T>(ptr, size);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nSpan<T> MakeSpan(absl::Nullable<T*> begin, absl::Nullable<T*> end) noexcept {\n  return ABSL_HARDENING_ASSERT(begin <= end),\n         Span<T>(begin, static_cast<size_t>(end - begin));\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename C>\nconstexpr auto MakeSpan(C& c) noexcept  // NOLINT(runtime/references)\n    -> decltype(absl::MakeSpan(span_internal::GetData(c), c.size())) {\n  return MakeSpan(span_internal::GetData(c), c.size());\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T, size_t N>\nconstexpr Span<T> MakeSpan(T (&array)[N]) noexcept {\n  return Span<T>(array, N);\n}\n\n// MakeConstSpan()\n//\n// Constructs a `Span<const T>` as with `MakeSpan`, deducing `T` automatically,\n// but always returning a `Span<const T>`.\n//\n// Examples:\n//\n//   void ProcessInts(absl::Span<const int> some_ints);\n//\n//   // Call with a pointer and size.\n//   int array[3] = { 0, 0, 0 };\n//   ProcessInts(absl::MakeConstSpan(&array[0], 3));\n//\n//   // Call with a [begin, end) pair.\n//   ProcessInts(absl::MakeConstSpan(&array[0], &array[3]));\n//\n//   // Call directly with an array.\n//   ProcessInts(absl::MakeConstSpan(array));\n//\n//   // Call with a contiguous container.\n//   std::vector<int> some_ints = ...;\n//   ProcessInts(absl::MakeConstSpan(some_ints));\n//   ProcessInts(absl::MakeConstSpan(std::vector<int>{ 0, 0, 0 }));\n//\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nconstexpr Span<const T> MakeConstSpan(absl::Nullable<T*> ptr,\n                                      size_t size) noexcept {\n  return Span<const T>(ptr, size);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nSpan<const T> MakeConstSpan(absl::Nullable<T*> begin,\n                            absl::Nullable<T*> end) noexcept {\n  return ABSL_HARDENING_ASSERT(begin <= end), Span<const T>(begin, end - begin);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename C>\nconstexpr auto MakeConstSpan(const C& c) noexcept -> decltype(MakeSpan(c)) {\n  return MakeSpan(c);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T, size_t N>\nconstexpr Span<const T> MakeConstSpan(const T (&array)[N]) noexcept {\n  return Span<const T>(array, N);\n}\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04519",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/span.h",
  "source_line": 663,
  "validation_status": "validated"
}