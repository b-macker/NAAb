{
  "code": "{\n public:\n  // Width and precision are not specified, no flags are set.\n  bool is_basic() const { return flags_ == Flags::kBasic; }\n  bool has_left_flag() const { return FlagsContains(flags_, Flags::kLeft); }\n  bool has_show_pos_flag() const {\n    return FlagsContains(flags_, Flags::kShowPos);\n  }\n  bool has_sign_col_flag() const {\n    return FlagsContains(flags_, Flags::kSignCol);\n  }\n  bool has_alt_flag() const { return FlagsContains(flags_, Flags::kAlt); }\n  bool has_zero_flag() const { return FlagsContains(flags_, Flags::kZero); }\n\n  LengthMod length_mod() const { return length_mod_; }\n\n  FormatConversionChar conversion_char() const {\n    // Keep this field first in the struct . It generates better code when\n    // accessing it when ConversionSpec is passed by value in registers.\n    static_assert(offsetof(FormatConversionSpecImpl, conv_) == 0, \"\");\n    return conv_;\n  }\n\n  void set_conversion_char(FormatConversionChar c) { conv_ = c; }\n\n  // Returns the specified width. If width is unspecfied, it returns a negative\n  // value.\n  int width() const { return width_; }\n  // Returns the specified precision. If precision is unspecfied, it returns a\n  // negative value.\n  int precision() const { return precision_; }\n\n  template <typename T>\n  T Wrap() {\n    return T(*this);\n  }\n\n private:\n  friend struct str_format_internal::FormatConversionSpecImplFriend;\n  FormatConversionChar conv_ = FormatConversionCharInternal::kNone;\n  Flags flags_;\n  LengthMod length_mod_ = LengthMod::none;\n  int width_;\n  int precision_;\n}",
  "id": "BLOCK-CPP-06405",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/extension.h",
  "source_line": 274,
  "validation_status": "validated"
}