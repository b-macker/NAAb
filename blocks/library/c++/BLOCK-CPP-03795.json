{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::bernoulli_distribution is a drop in replacement for\n// std::bernoulli_distribution. It guarantees that (given a perfect\n// UniformRandomBitGenerator) the acceptance probability is *exactly* equal to\n// the given double.\n//\n// The implementation assumes that double is IEEE754\nclass bernoulli_distribution {\n public:\n  using result_type = bool;\n\n  class param_type {\n   public:\n    using distribution_type = bernoulli_distribution;\n\n    explicit param_type(double p = 0.5) : prob_(p) {\n      assert(p >= 0.0 && p <= 1.0);\n    }\n\n    double p() const { return prob_; }\n\n    friend bool operator==(const param_type& p1, const param_type& p2) {\n      return p1.p() == p2.p();\n    }\n    friend bool operator!=(const param_type& p1, const param_type& p2) {\n      return p1.p() != p2.p();\n    }\n\n   private:\n    double prob_;\n  };\n\n  bernoulli_distribution() : bernoulli_distribution(0.5) {}\n\n  explicit bernoulli_distribution(double p) : param_(p) {}\n\n  explicit bernoulli_distribution(param_type p) : param_(p) {}\n\n  // no-op\n  void reset() {}\n\n  template <typename URBG>\n  bool operator()(URBG& g) {  // NOLINT(runtime/references)\n    return Generate(param_.p(), g);\n  }\n\n  template <typename URBG>\n  bool operator()(URBG& g,  // NOLINT(runtime/references)\n                  const param_type& param) {\n    return Generate(param.p(), g);\n  }\n\n  param_type param() const { return param_; }\n  void param(const param_type& param) { param_ = param; }\n\n  double p() const { return param_.p(); }\n\n  result_type(min)() const { return false; }\n  result_type(max)() const { return true; }\n\n  friend bool operator==(const bernoulli_distribution& d1,\n                         const bernoulli_distribution& d2) {\n    return d1.param_ == d2.param_;\n  }\n\n  friend bool operator!=(const bernoulli_distribution& d1,\n                         const bernoulli_distribution& d2) {\n    return d1.param_ != d2.param_;\n  }\n\n private:\n  static constexpr uint64_t kP32 = static_cast<uint64_t>(1) << 32;\n\n  template <typename URBG>\n  static bool Generate(double p, URBG& g);  // NOLINT(runtime/references)\n\n  param_type param_;\n};\n\ntemplate <typename CharT, typename Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const bernoulli_distribution& x) {\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os.precision(random_internal::stream_precision_helper<double>::kPrecision);\n  os << x.p();\n  return os;\n}\n\ntemplate <typename CharT, typename Traits>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    bernoulli_distribution& x) {            // NOLINT(runtime/references)\n  auto saver = random_internal::make_istream_state_saver(is);\n  auto p = random_internal::read_floating_point<double>(is);\n  if (!is.fail()) {\n    x.param(bernoulli_distribution::param_type(p));\n  }\n  return is;\n}\n\ntemplate <typename URBG>\nbool bernoulli_distribution::Generate(double p,\n                                      URBG& g) {  // NOLINT(runtime/references)\n  random_internal::FastUniformBits<uint32_t> fast_u32;\n\n  while (true) {\n    // There are two aspects of the definition of `c` below that are worth\n    // commenting on.  First, because `p` is in the range [0, 1], `c` is in the\n    // range [0, 2^32] which does not fit in a uint32_t and therefore requires\n    // 64 bits.\n    //\n    // Second, `c` is constructed by first casting explicitly to a signed\n    // integer and then casting explicitly to an unsigned integer of the same\n    // size.  This is done because the hardware conversion instructions produce\n    // signed integers from double; if taken as a uint64_t the conversion would\n    // be wrong for doubles greater than 2^63 (not relevant in this use-case).\n    // If converted directly to an unsigned integer, the compiler would end up\n    // emitting code to handle such large values that are not relevant due to\n    // the known bounds on `c`.  To avoid these extra instructions this\n    // implementation converts first to the signed type and then convert to\n    // unsigned (which is a no-op).\n    const uint64_t c = static_cast<uint64_t>(static_cast<int64_t>(p * kP32));\n    const uint32_t v = fast_u32(g);\n    // FAST PATH: this path fails with probability 1/2^32.  Note that simply\n    // returning v <= c would approximate P very well (up to an absolute error\n    // of 1/2^32); the slow path (taken in that range of possible error, in the\n    // case of equality) eliminates the remaining error.\n    if (ABSL_PREDICT_TRUE(v != c)) return v < c;\n\n    // It is guaranteed that `q` is strictly less than 1, because if `q` were\n    // greater than or equal to 1, the same would be true for `p`. Certainly `p`\n    // cannot be greater than 1, and if `p == 1`, then the fast path would\n    // necessary have been taken already.\n    const double q = static_cast<double>(c) / kP32;\n\n    // The probability of acceptance on the fast path is `q` and so the\n    // probability of acceptance here should be `p - q`.\n    //\n    // Note that `q` is obtained from `p` via some shifts and conversions, the\n    // upshot of which is that `q` is simply `p` with some of the\n    // least-significant bits of its mantissa set to zero. This means that the\n    // difference `p - q` will not have any rounding errors. To see why, pretend\n    // that double has 10 bits of resolution and q is obtained from `p` in such\n    // a way that the 4 least-significant bits of its mantissa are set to zero.\n    // For example:\n    //   p   = 1.1100111011 * 2^-1\n    //   q   = 1.1100110000 * 2^-1\n    // p - q = 1.011        * 2^-8\n    // The difference `p - q` has exactly the nonzero mantissa bits that were\n    // \"lost\" in `q` producing a number which is certainly representable in a\n    // double.\n    const double left = p - q;\n\n    // By construction, the probability of being on this slow path is 1/2^32, so\n    // P(accept in slow path) = P(accept| in slow path) * P(slow path),\n    // which means the probability of acceptance here is `1 / (left * kP32)`:\n    const double here = left * kP32;\n\n    // The simplest way to compute the result of this trial is to repeat the\n    // whole algorithm with the new probability. This terminates because even\n    // given  arbitrarily unfriendly \"random\" bits, each iteration either\n    // multiplies a tiny probability by 2^32 (if c == 0) or strips off some\n    // number of nonzero mantissa bits. That process is bounded.\n    if (here == 0) return false;\n    p = here;\n  }\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03795",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/bernoulli_distribution.h",
  "source_line": 26,
  "validation_status": "validated"
}