{
  "code": "{\n  // Shark shows that using MallocAllocator is *much* slower than using this\n  // BumpPtrAllocator!\n  using HashTableTy = llvm::StringMap<IdentifierInfo *, llvm::BumpPtrAllocator>;\n  HashTableTy HashTable;\n\n  IdentifierInfoLookup* ExternalLookup;\n\npublic:\n  /// Create the identifier table.\n  explicit IdentifierTable(IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Create the identifier table, populating it with info about the\n  /// language keywords for the language specified by \\p LangOpts.\n  explicit IdentifierTable(const LangOptions &LangOpts,\n                           IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Set the external identifier lookup mechanism.\n  void setExternalIdentifierLookup(IdentifierInfoLookup *IILookup) {\n    ExternalLookup = IILookup;\n  }\n\n  /// Retrieve the external identifier lookup object, if any.\n  IdentifierInfoLookup *getExternalIdentifierLookup() const {\n    return ExternalLookup;\n  }\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return HashTable.getAllocator();\n  }\n\n  /// Return the identifier token info for the specified named\n  /// identifier.\n  IdentifierInfo &get(StringRef Name) {\n    auto &Entry = *HashTable.try_emplace(Name, nullptr).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II) return *II;\n\n    // No entry; if we have an external lookup, look there first.\n    if (ExternalLookup) {\n      II = ExternalLookup->get(Name);\n      if (II)\n        return *II;\n    }\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    return *II;\n  }\n\n  IdentifierInfo &get(StringRef Name, tok::TokenKind TokenCode) {\n    IdentifierInfo &II = get(Name);\n    II.TokenID = TokenCode;\n    assert(II.TokenID == (unsigned) TokenCode && \"TokenCode too large\");\n    return II;\n  }\n\n  /// Gets an IdentifierInfo for the given name without consulting\n  ///        external sources.\n  ///\n  /// This is a version of get() meant for external sources that want to\n  /// introduce or modify an identifier. If they called get(), they would\n  /// likely end up in a recursion.\n  IdentifierInfo &getOwn(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II)\n      return *II;\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    // If this is the 'import' contextual keyword, mark it as such.\n    if (Name.equals(\"import\"))\n      II->setModulesImport(true);\n\n    return *II;\n  }\n\n  using iterator = HashTableTy::const_iterator;\n  using const_iterator = HashTableTy::const_iterator;\n\n  iterator begin() const { return HashTable.begin(); }\n  iterator end() const   { return HashTable.end(); }\n  unsigned size() const  { return HashTable.size(); }\n\n  iterator find(StringRef Name) const { return HashTable.find(Name); }\n\n  /// Print some statistics to stderr that indicate how well the\n  /// hashing is doing.\n  void PrintStats() const;\n\n  /// Populate the identifier table with info about the language keywords\n  /// for the language specified by \\p LangOpts.\n  void AddKeywords(const LangOptions &LangOpts);\n\n  /// Returns the correct diagnostic to issue for a future-compat diagnostic\n  /// warning. Note, this function assumes the identifier passed has already\n  /// been determined to be a future compatible keyword.\n  diag::kind getFutureCompatDiagKind(const IdentifierInfo &II,\n                                     const LangOptions &LangOpts);\n}",
  "id": "BLOCK-CPP-16489",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/IdentifierTable.h",
  "source_line": 606,
  "validation_status": "validated"
}