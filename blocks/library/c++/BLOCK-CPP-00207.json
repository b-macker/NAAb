{
  "code": "{\n    size_t max_items_ = 0;\n    typename std::vector<T>::size_type head_ = 0;\n    typename std::vector<T>::size_type tail_ = 0;\n    size_t overrun_counter_ = 0;\n    std::vector<T> v_;\n\npublic:\n    using value_type = T;\n\n    // empty ctor - create a disabled queue with no elements allocated at all\n    circular_q() = default;\n\n    explicit circular_q(size_t max_items)\n        : max_items_(max_items + 1)  // one item is reserved as marker for full q\n          ,\n          v_(max_items_) {}\n\n    circular_q(const circular_q &) = default;\n    circular_q &operator=(const circular_q &) = default;\n\n    // move cannot be default,\n    // since we need to reset head_, tail_, etc to zero in the moved object\n    circular_q(circular_q &&other) SPDLOG_NOEXCEPT { copy_moveable(std::move(other)); }\n\n    circular_q &operator=(circular_q &&other) SPDLOG_NOEXCEPT {\n        copy_moveable(std::move(other));\n        return *this;\n    }\n\n    // push back, overrun (oldest) item if no room left\n    void push_back(T &&item) {\n        if (max_items_ > 0) {\n            v_[tail_] = std::move(item);\n            tail_ = (tail_ + 1) % max_items_;\n\n            if (tail_ == head_)  // overrun last item if full\n            {\n                head_ = (head_ + 1) % max_items_;\n                ++overrun_counter_;\n            }\n        }\n    }\n\n    // Return reference to the front item.\n    // If there are no elements in the container, the behavior is undefined.\n    const T &front() const { return v_[head_]; }\n\n    T &front() { return v_[head_]; }\n\n    // Return number of elements actually stored\n    size_t size() const {\n        if (tail_ >= head_) {\n            return tail_ - head_;\n        } else {\n            return max_items_ - (head_ - tail_);\n        }\n    }\n\n    // Return const reference to item by index.\n    // If index is out of range 0â€¦size()-1, the behavior is undefined.\n    const T &at(size_t i) const {\n        assert(i < size());\n        return v_[(head_ + i) % max_items_];\n    }\n\n    // Pop item from front.\n    // If there are no elements in the container, the behavior is undefined.\n    void pop_front() { head_ = (head_ + 1) % max_items_; }\n\n    bool empty() const { return tail_ == head_; }\n\n    bool full() const {\n        // head is ahead of the tail by 1\n        if (max_items_ > 0) {\n            return ((tail_ + 1) % max_items_) == head_;\n        }\n        return false;\n    }\n\n    size_t overrun_counter() const { return overrun_counter_; }\n\n    void reset_overrun_counter() { overrun_counter_ = 0; }\n\nprivate:\n    // copy from other&& and reset it to disabled state\n    void copy_moveable(circular_q &&other) SPDLOG_NOEXCEPT {\n        max_items_ = other.max_items_;\n        head_ = other.head_;\n        tail_ = other.tail_;\n        overrun_counter_ = other.overrun_counter_;\n        v_ = std::move(other.v_);\n\n        // put &&other in disabled, but valid state\n        other.max_items_ = 0;\n        other.head_ = other.tail_ = 0;\n        other.overrun_counter_ = 0;\n    }\n}",
  "id": "BLOCK-CPP-00207",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/circular_q.h",
  "source_line": 12,
  "validation_status": "validated"
}