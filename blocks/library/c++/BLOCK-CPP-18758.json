{
  "code": "{\n  //===--------------------------------------------------------------------===//\n  // State set when the macro is defined.\n\n  /// The location the macro is defined.\n  SourceLocation Location;\n\n  /// The location of the last token in the macro.\n  SourceLocation EndLocation;\n\n  /// The list of arguments for a function-like macro.\n  ///\n  /// ParameterList points to the first of NumParameters pointers.\n  ///\n  /// This can be empty, for, e.g. \"#define X()\".  In a C99-style variadic\n  /// macro, this includes the \\c __VA_ARGS__ identifier on the list.\n  IdentifierInfo **ParameterList = nullptr;\n\n  /// This is the list of tokens that the macro is defined to.\n  const Token *ReplacementTokens = nullptr;\n\n  /// \\see ParameterList\n  unsigned NumParameters = 0;\n\n  /// \\see ReplacementTokens\n  unsigned NumReplacementTokens = 0;\n\n  /// Length in characters of the macro definition.\n  mutable unsigned DefinitionLength;\n  mutable bool IsDefinitionLengthCached : 1;\n\n  /// True if this macro is function-like, false if it is object-like.\n  bool IsFunctionLike : 1;\n\n  /// True if this macro is of the form \"#define X(...)\" or\n  /// \"#define X(Y,Z,...)\".\n  ///\n  /// The __VA_ARGS__ token should be replaced with the contents of \"...\" in an\n  /// invocation.\n  bool IsC99Varargs : 1;\n\n  /// True if this macro is of the form \"#define X(a...)\".\n  ///\n  /// The \"a\" identifier in the replacement list will be replaced with all\n  /// arguments of the macro starting with the specified one.\n  bool IsGNUVarargs : 1;\n\n  /// True if this macro requires processing before expansion.\n  ///\n  /// This is the case for builtin macros such as __LINE__, so long as they have\n  /// not been redefined, but not for regular predefined macros from the\n  /// \"<built-in>\" memory buffer (see Preprocessing::getPredefinesFileID).\n  bool IsBuiltinMacro : 1;\n\n  /// Whether this macro contains the sequence \", ## __VA_ARGS__\"\n  bool HasCommaPasting : 1;\n\n  //===--------------------------------------------------------------------===//\n  // State that changes as the macro is used.\n\n  /// True if we have started an expansion of this macro already.\n  ///\n  /// This disables recursive expansion, which would be quite bad for things\n  /// like \\#define A A.\n  bool IsDisabled : 1;\n\n  /// True if this macro is either defined in the main file and has\n  /// been used, or if it is not defined in the main file.\n  ///\n  /// This is used to emit -Wunused-macros diagnostics.\n  bool IsUsed : 1;\n\n  /// True if this macro can be redefined without emitting a warning.\n  bool IsAllowRedefinitionsWithoutWarning : 1;\n\n  /// Must warn if the macro is unused at the end of translation unit.\n  bool IsWarnIfUnused : 1;\n\n  /// Whether this macro was used as header guard.\n  bool UsedForHeaderGuard : 1;\n\n  // Only the Preprocessor gets to create these.\n  MacroInfo(SourceLocation DefLoc);\n\npublic:\n  /// Return the location that the macro was defined at.\n  SourceLocation getDefinitionLoc() const { return Location; }\n\n  /// Set the location of the last token in the macro.\n  void setDefinitionEndLoc(SourceLocation EndLoc) { EndLocation = EndLoc; }\n\n  /// Return the location of the last token in the macro.\n  SourceLocation getDefinitionEndLoc() const { return EndLocation; }\n\n  /// Get length in characters of the macro definition.\n  unsigned getDefinitionLength(const SourceManager &SM) const {\n    if (IsDefinitionLengthCached)\n      return DefinitionLength;\n    return getDefinitionLengthSlow(SM);\n  }\n\n  /// Return true if the specified macro definition is equal to\n  /// this macro in spelling, arguments, and whitespace.\n  ///\n  /// \\param Syntactically if true, the macro definitions can be identical even\n  /// if they use different identifiers for the function macro parameters.\n  /// Otherwise the comparison is lexical and this implements the rules in\n  /// C99 6.10.3.\n  bool isIdenticalTo(const MacroInfo &Other, Preprocessor &PP,\n                     bool Syntactically) const;\n\n  /// Set or clear the isBuiltinMacro flag.\n  void setIsBuiltinMacro(bool Val = true) { IsBuiltinMacro = Val; }\n\n  /// Set the value of the IsUsed flag.\n  void setIsUsed(bool Val) { IsUsed = Val; }\n\n  /// Set the value of the IsAllowRedefinitionsWithoutWarning flag.\n  void setIsAllowRedefinitionsWithoutWarning(bool Val) {\n    IsAllowRedefinitionsWithoutWarning = Val;\n  }\n\n  /// Set the value of the IsWarnIfUnused flag.\n  void setIsWarnIfUnused(bool val) { IsWarnIfUnused = val; }\n\n  /// Set the specified list of identifiers as the parameter list for\n  /// this macro.\n  void setParameterList(ArrayRef<IdentifierInfo *> List,\n                       llvm::BumpPtrAllocator &PPAllocator) {\n    assert(ParameterList == nullptr && NumParameters == 0 &&\n           \"Parameter list already set!\");\n    if (List.empty())\n      return;\n\n    NumParameters = List.size();\n    ParameterList = PPAllocator.Allocate<IdentifierInfo *>(List.size());\n    std::copy(List.begin(), List.end(), ParameterList);\n  }\n\n  /// Parameters - The list of parameters for a function-like macro.  This can\n  /// be empty, for, e.g. \"#define X()\".\n  using param_iterator = IdentifierInfo *const *;\n  bool param_empty() const { return NumParameters == 0; }\n  param_iterator param_begin() const { return ParameterList; }\n  param_iterator param_end() const { return ParameterList + NumParameters; }\n  unsigned getNumParams() const { return NumParameters; }\n  ArrayRef<const IdentifierInfo *> params() const {\n    return ArrayRef<const IdentifierInfo *>(ParameterList, NumParameters);\n  }\n\n  /// Return the parameter number of the specified identifier,\n  /// or -1 if the identifier is not a formal parameter identifier.\n  int getParameterNum(const IdentifierInfo *Arg) const {\n    for (param_iterator I = param_begin(), E = param_end(); I != E; ++I)\n      if (*I == Arg)\n        return I - param_begin();\n    return -1;\n  }\n\n  /// Function/Object-likeness.  Keep track of whether this macro has formal\n  /// parameters.\n  void setIsFunctionLike() { IsFunctionLike = true; }\n  bool isFunctionLike() const { return IsFunctionLike; }\n  bool isObjectLike() const { return !IsFunctionLike; }\n\n  /// Varargs querying methods.  This can only be set for function-like macros.\n  void setIsC99Varargs() { IsC99Varargs = true; }\n  void setIsGNUVarargs() { IsGNUVarargs = true; }\n  bool isC99Varargs() const { return IsC99Varargs; }\n  bool isGNUVarargs() const { return IsGNUVarargs; }\n  bool isVariadic() const { return IsC99Varargs || IsGNUVarargs; }\n\n  /// Return true if this macro requires processing before expansion.\n  ///\n  /// This is true only for builtin macro, such as \\__LINE__, whose values\n  /// are not given by fixed textual expansions.  Regular predefined macros\n  /// from the \"<built-in>\" buffer are not reported as builtins by this\n  /// function.\n  bool isBuiltinMacro() const { return IsBuiltinMacro; }\n\n  bool hasCommaPasting() const { return HasCommaPasting; }\n  void setHasCommaPasting() { HasCommaPasting = true; }\n\n  /// Return false if this macro is defined in the main file and has\n  /// not yet been used.\n  bool isUsed() const { return IsUsed; }\n\n  /// Return true if this macro can be redefined without warning.\n  bool isAllowRedefinitionsWithoutWarning() const {\n    return IsAllowRedefinitionsWithoutWarning;\n  }\n\n  /// Return true if we should emit a warning if the macro is unused.\n  bool isWarnIfUnused() const { return IsWarnIfUnused; }\n\n  /// Return the number of tokens that this macro expands to.\n  unsigned getNumTokens() const { return NumReplacementTokens; }\n\n  const Token &getReplacementToken(unsigned Tok) const {\n    assert(Tok < NumReplacementTokens && \"Invalid token #\");\n    return ReplacementTokens[Tok];\n  }\n\n  using const_tokens_iterator = const Token *;\n\n  const_tokens_iterator tokens_begin() const { return ReplacementTokens; }\n  const_tokens_iterator tokens_end() const {\n    return ReplacementTokens + NumReplacementTokens;\n  }\n  bool tokens_empty() const { return NumReplacementTokens == 0; }\n  ArrayRef<Token> tokens() const {\n    return llvm::ArrayRef(ReplacementTokens, NumReplacementTokens);\n  }\n\n  llvm::MutableArrayRef<Token>\n  allocateTokens(unsigned NumTokens, llvm::BumpPtrAllocator &PPAllocator) {\n    assert(ReplacementTokens == nullptr && NumReplacementTokens == 0 &&\n           \"Token list already allocated!\");\n    NumReplacementTokens = NumTokens;\n    Token *NewReplacementTokens = PPAllocator.Allocate<Token>(NumTokens);\n    ReplacementTokens = NewReplacementTokens;\n    return llvm::MutableArrayRef(NewReplacementTokens, NumTokens);\n  }\n\n  void setTokens(ArrayRef<Token> Tokens, llvm::BumpPtrAllocator &PPAllocator) {\n    assert(\n        !IsDefinitionLengthCached &&\n        \"Changing replacement tokens after definition length got calculated\");\n    assert(ReplacementTokens == nullptr && NumReplacementTokens == 0 &&\n           \"Token list already set!\");\n    if (Tokens.empty())\n      return;\n\n    NumReplacementTokens = Tokens.size();\n    Token *NewReplacementTokens = PPAllocator.Allocate<Token>(Tokens.size());\n    std::copy(Tokens.begin(), Tokens.end(), NewReplacementTokens);\n    ReplacementTokens = NewReplacementTokens;\n  }\n\n  /// Return true if this macro is enabled.\n  ///\n  /// In other words, that we are not currently in an expansion of this macro.\n  bool isEnabled() const { return !IsDisabled; }\n\n  void EnableMacro() {\n    assert(IsDisabled && \"Cannot enable an already-enabled macro!\");\n    IsDisabled = false;\n  }\n\n  void DisableMacro() {\n    assert(!IsDisabled && \"Cannot disable an already-disabled macro!\");\n    IsDisabled = true;\n  }\n\n  /// Determine whether this macro was used for a header guard.\n  bool isUsedForHeaderGuard() const { return UsedForHeaderGuard; }\n\n  void setUsedForHeaderGuard(bool Val) { UsedForHeaderGuard = Val; }\n\n  void dump() const;\n\nprivate:\n  friend class Preprocessor;\n\n  unsigned getDefinitionLengthSlow(const SourceManager &SM) const;\n}",
  "id": "BLOCK-CPP-18758",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/MacroInfo.h",
  "source_line": 39,
  "validation_status": "validated"
}