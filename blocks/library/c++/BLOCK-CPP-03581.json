{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// InitializeSymbolizer()\n//\n// Initializes the program counter symbolizer, given the path of the program\n// (typically obtained through `main()`s `argv[0]`). The Abseil symbolizer\n// allows you to read program counters (instruction pointer values) using their\n// human-readable names within output such as stack traces.\n//\n// Example:\n//\n// int main(int argc, char *argv[]) {\n//   absl::InitializeSymbolizer(argv[0]);\n//   // Now you can use the symbolizer\n// }\nvoid InitializeSymbolizer(const char* argv0);\n//\n// Symbolize()\n//\n// Symbolizes a program counter (instruction pointer value) `pc` and, on\n// success, writes the name to `out`. The symbol name is demangled, if possible.\n// Note that the symbolized name may be truncated and will be NUL-terminated.\n// Demangling is supported for symbols generated by GCC 3.x or newer). Returns\n// `false` on failure.\n//\n// Example:\n//\n//   // Print a program counter and its symbol name.\n//   static void DumpPCAndSymbol(void *pc) {\n//     char tmp[1024];\n//     const char *symbol = \"(unknown)\";\n//     if (absl::Symbolize(pc, tmp, sizeof(tmp))) {\n//       symbol = tmp;\n//     }\n//     absl::PrintF(\"%p  %s\\n\", pc, symbol);\n//  }\nbool Symbolize(const void *pc, char *out, int out_size);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03581",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/symbolize.h",
  "source_line": 57,
  "validation_status": "validated"
}