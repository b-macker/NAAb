{
  "code": "{\nprivate:\n  // Print out additional information.\n  bool Verbose;\n\n  // Omit redundant decls.\n  bool Cleanup;\n\n  // Print exprs in C-like syntax.\n  bool CStyle;\n\npublic:\n  PrettyPrinter(bool V = false, bool C = true, bool CS = true)\n      : Verbose(V), Cleanup(C), CStyle(CS) {}\n\n  static void print(const SExpr *E, StreamType &SS) {\n    Self printer;\n    printer.printSExpr(E, SS, Prec_MAX);\n  }\n\nprotected:\n  Self *self() { return reinterpret_cast<Self *>(this); }\n\n  void newline(StreamType &SS) {\n    SS << \"\\n\";\n  }\n\n  // TODO: further distinguish between binary operations.\n  static const unsigned Prec_Atom = 0;\n  static const unsigned Prec_Postfix = 1;\n  static const unsigned Prec_Unary = 2;\n  static const unsigned Prec_Binary = 3;\n  static const unsigned Prec_Other = 4;\n  static const unsigned Prec_Decl = 5;\n  static const unsigned Prec_MAX = 6;\n\n  // Return the precedence of a given node, for use in pretty printing.\n  unsigned precedence(const SExpr *E) {\n    switch (E->opcode()) {\n      case COP_Future:     return Prec_Atom;\n      case COP_Undefined:  return Prec_Atom;\n      case COP_Wildcard:   return Prec_Atom;\n\n      case COP_Literal:    return Prec_Atom;\n      case COP_LiteralPtr: return Prec_Atom;\n      case COP_Variable:   return Prec_Atom;\n      case COP_Function:   return Prec_Decl;\n      case COP_SFunction:  return Prec_Decl;\n      case COP_Code:       return Prec_Decl;\n      case COP_Field:      return Prec_Decl;\n\n      case COP_Apply:      return Prec_Postfix;\n      case COP_SApply:     return Prec_Postfix;\n      case COP_Project:    return Prec_Postfix;\n\n      case COP_Call:       return Prec_Postfix;\n      case COP_Alloc:      return Prec_Other;\n      case COP_Load:       return Prec_Postfix;\n      case COP_Store:      return Prec_Other;\n      case COP_ArrayIndex: return Prec_Postfix;\n      case COP_ArrayAdd:   return Prec_Postfix;\n\n      case COP_UnaryOp:    return Prec_Unary;\n      case COP_BinaryOp:   return Prec_Binary;\n      case COP_Cast:       return Prec_Atom;\n\n      case COP_SCFG:       return Prec_Decl;\n      case COP_BasicBlock: return Prec_MAX;\n      case COP_Phi:        return Prec_Atom;\n      case COP_Goto:       return Prec_Atom;\n      case COP_Branch:     return Prec_Atom;\n      case COP_Return:     return Prec_Other;\n\n      case COP_Identifier: return Prec_Atom;\n      case COP_IfThenElse: return Prec_Other;\n      case COP_Let:        return Prec_Decl;\n    }\n    return Prec_MAX;\n  }\n\n  void printBlockLabel(StreamType & SS, const BasicBlock *BB, int index) {\n    if (!BB) {\n      SS << \"BB_null\";\n      return;\n    }\n    SS << \"BB_\";\n    SS << BB->blockID();\n    if (index >= 0) {\n      SS << \":\";\n      SS << index;\n    }\n  }\n\n  void printSExpr(const SExpr *E, StreamType &SS, unsigned P, bool Sub=true) {\n    if (!E) {\n      self()->printNull(SS);\n      return;\n    }\n    if (Sub && E->block() && E->opcode() != COP_Variable) {\n      SS << \"_x\" << E->id();\n      return;\n    }\n    if (self()->precedence(E) > P) {\n      // Wrap expr in () if necessary.\n      SS << \"(\";\n      self()->printSExpr(E, SS, Prec_MAX);\n      SS << \")\";\n      return;\n    }\n\n    switch (E->opcode()) {\n#define TIL_OPCODE_DEF(X)                                                  \\\n    case COP_##X:                                                          \\\n      self()->print##X(cast<X>(E), SS);                                    \\\n      return;\n#include \"ThreadSafetyOps.def\"\n#undef TIL_OPCODE_DEF\n    }\n  }\n\n  void printNull(StreamType &SS) {\n    SS << \"#null\";\n  }\n\n  void printFuture(const Future *E, StreamType &SS) {\n    self()->printSExpr(E->maybeGetResult(), SS, Prec_Atom);\n  }\n\n  void printUndefined(const Undefined *E, StreamType &SS) {\n    SS << \"#undefined\";\n  }\n\n  void printWildcard(const Wildcard *E, StreamType &SS) {\n    SS << \"*\";\n  }\n\n  template<class T>\n  void printLiteralT(const LiteralT<T> *E, StreamType &SS) {\n    SS << E->value();\n  }\n\n  void printLiteralT(const LiteralT<uint8_t> *E, StreamType &SS) {\n    SS << \"'\" << E->value() << \"'\";\n  }\n\n  void printLiteral(const Literal *E, StreamType &SS) {\n    if (E->clangExpr()) {\n      SS << getSourceLiteralString(E->clangExpr());\n      return;\n    }\n    else {\n      ValueType VT = E->valueType();\n      switch (VT.Base) {\n      case ValueType::BT_Void:\n        SS << \"void\";\n        return;\n      case ValueType::BT_Bool:\n        if (E->as<bool>().value())\n          SS << \"true\";\n        else\n          SS << \"false\";\n        return;\n      case ValueType::BT_Int:\n        switch (VT.Size) {\n        case ValueType::ST_8:\n          if (VT.Signed)\n            printLiteralT(&E->as<int8_t>(), SS);\n          else\n            printLiteralT(&E->as<uint8_t>(), SS);\n          return;\n        case ValueType::ST_16:\n          if (VT.Signed)\n            printLiteralT(&E->as<int16_t>(), SS);\n          else\n            printLiteralT(&E->as<uint16_t>(), SS);\n          return;\n        case ValueType::ST_32:\n          if (VT.Signed)\n            printLiteralT(&E->as<int32_t>(), SS);\n          else\n            printLiteralT(&E->as<uint32_t>(), SS);\n          return;\n        case ValueType::ST_64:\n          if (VT.Signed)\n            printLiteralT(&E->as<int64_t>(), SS);\n          else\n            printLiteralT(&E->as<uint64_t>(), SS);\n          return;\n        default:\n          break;\n        }\n        break;\n      case ValueType::BT_Float:\n        switch (VT.Size) {\n        case ValueType::ST_32:\n          printLiteralT(&E->as<float>(), SS);\n          return;\n        case ValueType::ST_64:\n          printLiteralT(&E->as<double>(), SS);\n          return;\n        default:\n          break;\n        }\n        break;\n      case ValueType::BT_String:\n        SS << \"\\\"\";\n        printLiteralT(&E->as<StringRef>(), SS);\n        SS << \"\\\"\";\n        return;\n      case ValueType::BT_Pointer:\n        SS << \"#ptr\";\n        return;\n      case ValueType::BT_ValueRef:\n        SS << \"#vref\";\n        return;\n      }\n    }\n    SS << \"#lit\";\n  }\n\n  void printLiteralPtr(const LiteralPtr *E, StreamType &SS) {\n    if (const NamedDecl *D = E->clangDecl())\n      SS << D->getNameAsString();\n    else\n      SS << \"<temporary>\";\n  }\n\n  void printVariable(const Variable *V, StreamType &SS, bool IsVarDecl=false) {\n    if (CStyle && V->kind() == Variable::VK_SFun)\n      SS << \"this\";\n    else\n      SS << V->name() << V->id();\n  }\n\n  void printFunction(const Function *E, StreamType &SS, unsigned sugared = 0) {\n    switch (sugared) {\n      default:\n        SS << \"\\\\(\";   // Lambda\n        break;\n      case 1:\n        SS << \"(\";     // Slot declarations\n        break;\n      case 2:\n        SS << \", \";    // Curried functions\n        break;\n    }\n    self()->printVariable(E->variableDecl(), SS, true);\n    SS << \": \";\n    self()->printSExpr(E->variableDecl()->definition(), SS, Prec_MAX);\n\n    const SExpr *B = E->body();\n    if (B && B->opcode() == COP_Function)\n      self()->printFunction(cast<Function>(B), SS, 2);\n    else {\n      SS << \")\";\n      self()->printSExpr(B, SS, Prec_Decl);\n    }\n  }\n\n  void printSFunction(const SFunction *E, StreamType &SS) {\n    SS << \"@\";\n    self()->printVariable(E->variableDecl(), SS, true);\n    SS << \" \";\n    self()->printSExpr(E->body(), SS, Prec_Decl);\n  }\n\n  void printCode(const Code *E, StreamType &SS) {\n    SS << \": \";\n    self()->printSExpr(E->returnType(), SS, Prec_Decl-1);\n    SS << \" -> \";\n    self()->printSExpr(E->body(), SS, Prec_Decl);\n  }\n\n  void printField(const Field *E, StreamType &SS) {\n    SS << \": \";\n    self()->printSExpr(E->range(), SS, Prec_Decl-1);\n    SS << \" = \";\n    self()->printSExpr(E->body(), SS, Prec_Decl);\n  }\n\n  void printApply(const Apply *E, StreamType &SS, bool sugared = false) {\n    const SExpr *F = E->fun();\n    if (F->opcode() == COP_Apply) {\n      printApply(cast<Apply>(F), SS, true);\n      SS << \", \";\n    } else {\n      self()->printSExpr(F, SS, Prec_Postfix);\n      SS << \"(\";\n    }\n    self()->printSExpr(E->arg(), SS, Prec_MAX);\n    if (!sugared)\n      SS << \")$\";\n  }\n\n  void printSApply(const SApply *E, StreamType &SS) {\n    self()->printSExpr(E->sfun(), SS, Prec_Postfix);\n    if (E->isDelegation()) {\n      SS << \"@(\";\n      self()->printSExpr(E->arg(), SS, Prec_MAX);\n      SS << \")\";\n    }\n  }\n\n  void printProject(const Project *E, StreamType &SS) {\n    if (CStyle) {\n      // Omit the  this->\n      if (const auto *SAP = dyn_cast<SApply>(E->record())) {\n        if (const auto *V = dyn_cast<Variable>(SAP->sfun())) {\n          if (!SAP->isDelegation() && V->kind() == Variable::VK_SFun) {\n            SS << E->slotName();\n            return;\n          }\n        }\n      }\n      if (isa<Wildcard>(E->record())) {\n        // handle existentials\n        SS << \"&\";\n        SS << E->clangDecl()->getQualifiedNameAsString();\n        return;\n      }\n    }\n    self()->printSExpr(E->record(), SS, Prec_Postfix);\n    if (CStyle && E->isArrow())\n      SS << \"->\";\n    else\n      SS << \".\";\n    SS << E->slotName();\n  }\n\n  void printCall(const Call *E, StreamType &SS) {\n    const SExpr *T = E->target();\n    if (T->opcode() == COP_Apply) {\n      self()->printApply(cast<Apply>(T), SS, true);\n      SS << \")\";\n    }\n    else {\n      self()->printSExpr(T, SS, Prec_Postfix);\n      SS << \"()\";\n    }\n  }\n\n  void printAlloc(const Alloc *E, StreamType &SS) {\n    SS << \"new \";\n    self()->printSExpr(E->dataType(), SS, Prec_Other-1);\n  }\n\n  void printLoad(const Load *E, StreamType &SS) {\n    self()->printSExpr(E->pointer(), SS, Prec_Postfix);\n    if (!CStyle)\n      SS << \"^\";\n  }\n\n  void printStore(const Store *E, StreamType &SS) {\n    self()->printSExpr(E->destination(), SS, Prec_Other-1);\n    SS << \" := \";\n    self()->printSExpr(E->source(), SS, Prec_Other-1);\n  }\n\n  void printArrayIndex(const ArrayIndex *E, StreamType &SS) {\n    self()->printSExpr(E->array(), SS, Prec_Postfix);\n    SS << \"[\";\n    self()->printSExpr(E->index(), SS, Prec_MAX);\n    SS << \"]\";\n  }\n\n  void printArrayAdd(const ArrayAdd *E, StreamType &SS) {\n    self()->printSExpr(E->array(), SS, Prec_Postfix);\n    SS << \" + \";\n    self()->printSExpr(E->index(), SS, Prec_Atom);\n  }\n\n  void printUnaryOp(const UnaryOp *E, StreamType &SS) {\n    SS << getUnaryOpcodeString(E->unaryOpcode());\n    self()->printSExpr(E->expr(), SS, Prec_Unary);\n  }\n\n  void printBinaryOp(const BinaryOp *E, StreamType &SS) {\n    self()->printSExpr(E->expr0(), SS, Prec_Binary-1);\n    SS << \" \" << getBinaryOpcodeString(E->binaryOpcode()) << \" \";\n    self()->printSExpr(E->expr1(), SS, Prec_Binary-1);\n  }\n\n  void printCast(const Cast *E, StreamType &SS) {\n    if (!CStyle) {\n      SS << \"cast[\";\n      switch (E->castOpcode()) {\n      case CAST_none:\n        SS << \"none\";\n        break;\n      case CAST_extendNum:\n        SS << \"extendNum\";\n        break;\n      case CAST_truncNum:\n        SS << \"truncNum\";\n        break;\n      case CAST_toFloat:\n        SS << \"toFloat\";\n        break;\n      case CAST_toInt:\n        SS << \"toInt\";\n        break;\n      case CAST_objToPtr:\n        SS << \"objToPtr\";\n        break;\n      }\n      SS << \"](\";\n      self()->printSExpr(E->expr(), SS, Prec_Unary);\n      SS << \")\";\n      return;\n    }\n    self()->printSExpr(E->expr(), SS, Prec_Unary);\n  }\n\n  void printSCFG(const SCFG *E, StreamType &SS) {\n    SS << \"CFG {\\n\";\n    for (const auto *BBI : *E)\n      printBasicBlock(BBI, SS);\n    SS << \"}\";\n    newline(SS);\n  }\n\n  void printBBInstr(const SExpr *E, StreamType &SS) {\n    bool Sub = false;\n    if (E->opcode() == COP_Variable) {\n      const auto *V = cast<Variable>(E);\n      SS << \"let \" << V->name() << V->id() << \" = \";\n      E = V->definition();\n      Sub = true;\n    }\n    else if (E->opcode() != COP_Store) {\n      SS << \"let _x\" << E->id() << \" = \";\n    }\n    self()->printSExpr(E, SS, Prec_MAX, Sub);\n    SS << \";\";\n    newline(SS);\n  }\n\n  void printBasicBlock(const BasicBlock *E, StreamType &SS) {\n    SS << \"BB_\" << E->blockID() << \":\";\n    if (E->parent())\n      SS << \" BB_\" << E->parent()->blockID();\n    newline(SS);\n\n    for (const auto *A : E->arguments())\n      printBBInstr(A, SS);\n\n    for (const auto *I : E->instructions())\n      printBBInstr(I, SS);\n\n    const SExpr *T = E->terminator();\n    if (T) {\n      self()->printSExpr(T, SS, Prec_MAX, false);\n      SS << \";\";\n      newline(SS);\n    }\n    newline(SS);\n  }\n\n  void printPhi(const Phi *E, StreamType &SS) {\n    SS << \"phi(\";\n    if (E->status() == Phi::PH_SingleVal)\n      self()->printSExpr(E->values()[0], SS, Prec_MAX);\n    else {\n      unsigned i = 0;\n      for (const auto *V : E->values()) {\n        if (i++ > 0)\n          SS << \", \";\n        self()->printSExpr(V, SS, Prec_MAX);\n      }\n    }\n    SS << \")\";\n  }\n\n  void printGoto(const Goto *E, StreamType &SS) {\n    SS << \"goto \";\n    printBlockLabel(SS, E->targetBlock(), E->index());\n  }\n\n  void printBranch(const Branch *E, StreamType &SS) {\n    SS << \"branch (\";\n    self()->printSExpr(E->condition(), SS, Prec_MAX);\n    SS << \") \";\n    printBlockLabel(SS, E->thenBlock(), -1);\n    SS << \" \";\n    printBlockLabel(SS, E->elseBlock(), -1);\n  }\n\n  void printReturn(const Return *E, StreamType &SS) {\n    SS << \"return \";\n    self()->printSExpr(E->returnValue(), SS, Prec_Other);\n  }\n\n  void printIdentifier(const Identifier *E, StreamType &SS) {\n    SS << E->name();\n  }\n\n  void printIfThenElse(const IfThenElse *E, StreamType &SS) {\n    if (CStyle) {\n      printSExpr(E->condition(), SS, Prec_Unary);\n      SS << \" ? \";\n      printSExpr(E->thenExpr(), SS, Prec_Unary);\n      SS << \" : \";\n      printSExpr(E->elseExpr(), SS, Prec_Unary);\n      return;\n    }\n    SS << \"if (\";\n    printSExpr(E->condition(), SS, Prec_MAX);\n    SS << \") then \";\n    printSExpr(E->thenExpr(), SS, Prec_Other);\n    SS << \" else \";\n    printSExpr(E->elseExpr(), SS, Prec_Other);\n  }\n\n  void printLet(const Let *E, StreamType &SS) {\n    SS << \"let \";\n    printVariable(E->variableDecl(), SS, true);\n    SS << \" = \";\n    printSExpr(E->variableDecl()->definition(), SS, Prec_Decl-1);\n    SS << \"; \";\n    printSExpr(E->body(), SS, Prec_Decl-1);\n  }\n}",
  "id": "BLOCK-CPP-21801",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h",
  "source_line": 404,
  "validation_status": "validated"
}