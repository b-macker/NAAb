{
  "code": "#include \"absl/base/config.h\"   // TODO(calabrese) IWYU removal?\n#include \"absl/utility/utility.h\"\n#include <optional>  // IWYU pragma: export\n#include <cassert>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/internal/inline_variable.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/types/bad_optional_access.h\"\n#include \"absl/types/internal/optional.h\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04491_execute() {\n    {\n  //     Foo(std::initializer_list<int>);\n  //   };\n  //\n  //   optional<Foo> opt;\n  //   opt.emplace({1,2,3});  // Constructs Foo({1,2,3})\n  template <typename U, typename... Args,\n            typename = typename std::enable_if<std::is_constructible<\n                T, std::initializer_list<U>&, Args&&...>::value>::type>\n  T& emplace(std::initializer_list<U> il,\n             Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    this->destruct();\n    this->construct(il, std::forward<Args>(args)...);\n    return reference();\n  }\n\n  // Swaps\n\n  // Swap, standard semantics\n  void swap(optional& rhs) noexcept(\n      std::is_nothrow_move_constructible<T>::value&&\n          type_traits_internal::IsNothrowSwappable<T>::value) {\n    if (*this) {\n      if (rhs) {\n        type_traits_internal::Swap(**this, *rhs);\n      } else {\n        rhs.construct(std::move(**this));\n        this->destruct();\n      }\n    } else {\n      if (rhs) {\n        this->construct(std::move(*rhs));\n        rhs.destruct();\n      } else {\n        // No effect (swap(disengaged, disengaged)).\n      }\n    }\n  }\n\n  // Observers\n\n  // optional::operator->()\n  //\n  // Accesses the underlying `T` value's member `m` of an `optional`. If the\n  // `optional` is empty, behavior is undefined.\n  //\n  // If you need myOpt->foo in constexpr, use (*myOpt).foo instead.\n  absl::Nonnull<const T*> operator->() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(this->engaged_);\n    return std::addressof(this->data_);\n  }\n  absl::Nonnull<T*> operator->() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(this->engaged_);\n    return std::addressof(this->data_);\n  }\n\n  // optional::operator*()\n  //\n  // Accesses the underlying `T` value of an `optional`. If the `optional` is\n  // empty, behavior is undefined.\n  constexpr const T& operator*() const& ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ABSL_HARDENING_ASSERT(this->engaged_), reference();\n  }\n  T& operator*() & ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(this->engaged_);\n    return reference();\n  }\n  constexpr const T&& operator*() const&& ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ABSL_HARDENING_ASSERT(this->engaged_), absl::move(reference());\n  }\n  T&& operator*() && ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(this->engaged_);\n    return std::move(reference());\n  }\n\n  // optional::operator bool()\n  //\n  // Returns false if and only if the `optional` is empty.\n  //\n  //   if (opt) {\n  //     // do something with *opt or opt->;\n  //   } else {\n  //     // opt is empty.\n  //   }\n  //\n  constexpr explicit operator bool() const noexcept { return this->engaged_; }\n\n  // optional::has_value()\n  //\n  // Determines whether the `optional` contains a value. Returns `false` if and\n  // only if `*this` is empty.\n  constexpr bool has_value() const noexcept { return this->engaged_; }\n\n// Suppress bogus warning on MSVC: MSVC complains call to reference() after\n// throw_bad_optional_access() is unreachable.\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4702)\n#endif  // _MSC_VER\n  // optional::value()\n  //\n  // Returns a reference to an `optional`s underlying value. The constness\n  // and lvalue/rvalue-ness of the `optional` is preserved to the view of\n  // the `T` sub-object. Throws `absl::bad_optional_access` when the `optional`\n  // is empty.\n  constexpr const T& value() const& ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return static_cast<bool>(*this)\n               ? reference()\n               : (optional_internal::throw_bad_optional_access(), reference());\n  }\n  T& value() & ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return static_cast<bool>(*this)\n               ? reference()\n               : (optional_internal::throw_bad_optional_access(), reference());\n  }\n  T&& value() && ABSL_ATTRIBUTE_LIFETIME_BOUND {  // NOLINT(build/c++11)\n    return std::move(\n        static_cast<bool>(*this)\n            ? reference()\n            : (optional_internal::throw_bad_optional_access(), reference()));\n  }\n  constexpr const T&& value()\n      const&& ABSL_ATTRIBUTE_LIFETIME_BOUND {  // NOLINT(build/c++11)\n    return absl::move(\n        static_cast<bool>(*this)\n            ? reference()\n            : (optional_internal::throw_bad_optional_access(), reference()));\n  }\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif  // _MSC_VER\n\n  // optional::value_or()\n  //\n  // Returns either the value of `T` or a passed default `v` if the `optional`\n  // is empty.\n  template <typename U>\n  constexpr T value_or(U&& v) const& {\n    static_assert(std::is_copy_constructible<value_type>::value,\n                  \"optional<T>::value_or: T must be copy constructible\");\n    static_assert(std::is_convertible<U&&, value_type>::value,\n                  \"optional<T>::value_or: U must be convertible to T\");\n    return static_cast<bool>(*this)\n               ? **this\n               : static_cast<T>(absl::forward<U>(v));\n  }\n  template <typename U>\n  T value_or(U&& v) && {  // NOLINT(build/c++11)\n    static_assert(std::is_move_constructible<value_type>::value,\n                  \"optional<T>::value_or: T must be move constructible\");\n    static_assert(std::is_convertible<U&&, value_type>::value,\n                  \"optional<T>::value_or: U must be convertible to T\");\n    return static_cast<bool>(*this) ? std::move(**this)\n                                    : static_cast<T>(std::forward<U>(v));\n  }\n\n private:\n  // Private accessors for internal storage viewed as reference to T.\n  constexpr const T& reference() const { return this->data_; }\n  T& reference() { return this->data_; }\n\n  // T constraint checks.  You can't have an optional of nullopt_t, in_place_t\n  // or a reference.\n  static_assert(\n      !std::is_same<nullopt_t, typename std::remove_cv<T>::type>::value,\n      \"optional<nullopt_t> is not allowed.\");\n  static_assert(\n      !std::is_same<in_place_t, typename std::remove_cv<T>::type>::value,\n      \"optional<in_place_t> is not allowed.\");\n  static_assert(!std::is_reference<T>::value,\n                \"optional<reference> is not allowed.\");\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04491",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/optional.h",
  "source_line": 372,
  "validation_status": "validated"
}