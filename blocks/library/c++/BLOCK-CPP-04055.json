{
  "code": "{\n  //     absl::Cord cord;\n  //     while (n > 0) {\n  //       CordBuffer buffer = CordBuffer::CreateWithCustomLimit(64 << 10, n);\n  //       absl::Span<char> data = buffer.available_up_to(n);\n  //       ReadFileDataOrDie(fd, data.data(), data.size());\n  //       buffer.IncreaseLengthBy(data.size());\n  //       cord.Append(std::move(buffer));\n  //       n -= data.size();\n  //     }\n  //     return cord;\n  //   }\n  //\n  // If we'd use this function to read a file of 659KiB, we may get the\n  // following pattern of allocated cord buffer sizes:\n  //\n  //   CreateWithCustomLimit(64KiB, 674816) --> ~64KiB (65523)\n  //   CreateWithCustomLimit(64KiB, 674816) --> ~64KiB (65523)\n  //   ...\n  //   CreateWithCustomLimit(64KiB,  19586) --> ~16KiB (16371)\n  //   CreateWithCustomLimit(64KiB,   3215) -->   3215 (at least 3215)\n  //\n  // The reason the method returns a 16K buffer instead of a roughly 19K buffer\n  // is to reduce memory overhead and fragmentation risks. Using carefully\n  // chosen power of 2 values reduces the entropy of allocated memory sizes.\n  //\n  // Additionally, let's assume we'd use the above function on files that are\n  // generally smaller than 64K. If we'd use 'precise' sized buffers for such\n  // files, than we'd get a very wide distribution of allocated memory sizes\n  // rounded to 4K page sizes, and we'd end up with a lot of unused capacity.\n  //\n  // In general, application should only use custom sizes if the data they are\n  // consuming or storing is expected to be many times the chosen block size,\n  // and be based on objective data and performance metrics. For example, a\n  // compress function may work faster and consume less CPU when using larger\n  // buffers. Such an application should pick a size offering a reasonable\n  // trade-off between expected data size, compute savings with larger buffers,\n  // and the cost or fragmentation effect of larger buffers.\n  // Applications must pick a reasonable spot on that curve, and make sure their\n  // data meets their expectations in size distributions such as \"mostly large\".\n  static CordBuffer CreateWithCustomLimit(size_t block_size, size_t capacity);\n\n  // CordBuffer::available()\n  //\n  // Returns the span delineating the available capacity in this buffer\n  // which is defined as `{ data() + length(), capacity() - length() }`.\n  absl::Span<char> available();\n\n  // CordBuffer::available_up_to()\n  //\n  // Returns the span delineating the available capacity in this buffer limited\n  // to `size` bytes. This is equivalent to `available().subspan(0, size)`.\n  absl::Span<char> available_up_to(size_t size);\n\n  // CordBuffer::data()\n  //\n  // Returns a non-null reference to the data managed by this instance.\n  // Applications are allowed to write up to `capacity` bytes of instance data.\n  // CordBuffer data is uninitialized by default. Reading data from an instance\n  // that has not yet been initialized will lead to undefined behavior.\n  char* data();\n  const char* data() const;\n\n  // CordBuffer::length()\n  //\n  // Returns the length of this instance. The default length of a CordBuffer is\n  // 0, indicating an 'empty' CordBuffer. Applications must specify the length\n  // of the data in a CordBuffer before adding it to a Cord.\n  size_t length() const;\n\n  // CordBuffer::capacity()\n  //\n  // Returns the capacity of this instance. All instances have a non-zero\n  // capacity: default and `moved from` instances have a small internal buffer.\n  size_t capacity() const;\n\n  // CordBuffer::IncreaseLengthBy()\n  //\n  // Increases the length of this buffer by the specified 'n' bytes.\n  // Applications must make sure all data in this buffer up to the new length\n  // has been initialized before adding a CordBuffer to a Cord: failure to do so\n  // will lead to undefined behavior.  Requires `length() + n <= capacity()`.\n  // Typically, applications will use 'available_up_to()` to get a span of the\n  // desired capacity, and use `span.size()` to increase the length as in:\n  //   absl::Span<char> span = buffer.available_up_to(desired);\n  //   buffer.IncreaseLengthBy(span.size());\n  //   memcpy(span.data(), src, span.size());\n  //   etc...\n  void IncreaseLengthBy(size_t n);\n\n  // CordBuffer::SetLength()\n  //\n  // Sets the data length of this instance. Applications must make sure all data\n  // of the specified length has been initialized before adding a CordBuffer to\n  // a Cord: failure to do so will lead to undefined behavior.\n  // Setting the length to a small value or zero does not release any memory\n  // held by this CordBuffer instance. Requires `length <= capacity()`.\n  // Applications should preferably use the `IncreaseLengthBy()` method above\n  // in combination with the 'available()` or `available_up_to()` methods.\n  void SetLength(size_t length);\n\n private:\n  // Make sure we don't accidentally over promise.\n  static_assert(kCustomLimit <= cord_internal::kMaxLargeFlatSize, \"\");\n\n  // Assume the cost of an 'uprounded' allocation to CeilPow2(size) versus\n  // the cost of allocating at least 1 extra flat <= 4KB:\n  // - Flat overhead = 13 bytes\n  // - Btree amortized cost / node =~ 13 bytes\n  // - 64 byte granularity of tcmalloc at 4K =~ 32 byte average\n  // CPU cost and efficiency requires we should at least 'save' something by\n  // splitting, as a poor man's measure, we say the slop needs to be\n  // at least double the cost offset to make it worth splitting: ~128 bytes.\n  static constexpr size_t kMaxPageSlop = 128;\n\n  // Overhead for allocation a flat.\n  static constexpr size_t kOverhead = cord_internal::kFlatOverhead;\n\n  using CordRepFlat = cord_internal::CordRepFlat;\n\n  // `Rep` is the internal data representation of a CordBuffer. The internal\n  // representation has an internal small size optimization similar to\n  // std::string (SSO).\n  struct Rep {\n    // Inline SSO size of a CordBuffer\n    static constexpr size_t kInlineCapacity = sizeof(intptr_t) * 2 - 1;\n\n    // Creates a default instance with kInlineCapacity.\n    Rep() : short_rep{} {}\n\n    // Creates an instance managing an allocated non zero CordRep.\n    explicit Rep(cord_internal::CordRepFlat* rep) : long_rep{rep} {\n      assert(rep != nullptr);\n    }\n\n    // Returns true if this instance manages the SSO internal buffer.\n    bool is_short() const {\n      constexpr size_t offset = offsetof(Short, raw_size);\n      return (reinterpret_cast<const char*>(this)[offset] & 1) != 0;\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> short_available() {\n      const size_t length = short_length();\n      return absl::Span<char>(short_rep.data + length,\n                              kInlineCapacity - length);\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> long_available() const {\n      assert(!is_short());\n      const size_t length = long_rep.rep->length;\n      return absl::Span<char>(long_rep.rep->Data() + length,\n                              long_rep.rep->Capacity() - length);\n    }\n\n    // Returns the length of the internal SSO data.\n    size_t short_length() const {\n      assert(is_short());\n      return static_cast<size_t>(short_rep.raw_size >> 1);\n    }\n\n    // Sets the length of the internal SSO data.\n    // Disregards any previously set CordRep instance.\n    void set_short_length(size_t length) {\n      short_rep.raw_size = static_cast<char>((length << 1) + 1);\n    }\n\n    // Adds `n` to the current short length.\n    void add_short_length(size_t n) {\n      assert(is_short());\n      short_rep.raw_size += static_cast<char>(n << 1);\n    }\n\n    // Returns reference to the internal SSO data buffer.\n    char* data() {\n      assert(is_short());\n      return short_rep.data;\n    }\n    const char* data() const {\n      assert(is_short());\n      return short_rep.data;\n    }\n\n    // Returns a pointer the external CordRep managed by this instance.\n    cord_internal::CordRepFlat* rep() const {\n      assert(!is_short());\n      return long_rep.rep;\n    }\n\n    // The internal representation takes advantage of the fact that allocated\n    // memory is always on an even address, and uses the least significant bit\n    // of the first or last byte (depending on endianness) as the inline size\n    // indicator overlapping with the least significant byte of the CordRep*.\n#if defined(ABSL_IS_BIG_ENDIAN)\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      void* padding;\n      cord_internal::CordRepFlat* rep;\n    };\n    struct Short {\n      char data[sizeof(Long) - 1];\n      char raw_size = 1;\n    };\n#else\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      cord_internal::CordRepFlat* rep;\n      void* padding;\n    };\n    struct Short {\n      char raw_size = 1;\n      char data[sizeof(Long) - 1];\n    };\n#endif\n\n    union {\n      Long long_rep;\n      Short short_rep;\n    };\n  };\n\n  // Power2 functions\n  static bool IsPow2(size_t size) { return absl::has_single_bit(size); }\n  static size_t Log2Floor(size_t size) {\n    return static_cast<size_t>(absl::bit_width(size) - 1);\n  }\n  static size_t Log2Ceil(size_t size) {\n    return static_cast<size_t>(absl::bit_width(size - 1));\n  }\n\n  // Implementation of `CreateWithCustomLimit()`.\n  // This implementation allows for future memory allocation hints to\n  // be passed down into the CordRepFlat allocation function.\n  template <typename... AllocationHints>\n  static CordBuffer CreateWithCustomLimitImpl(size_t block_size,\n                                              size_t capacity,\n                                              AllocationHints... hints);\n\n  // Consumes the value contained in this instance and resets the instance.\n  // This method returns a non-null Cordrep* if the current instances manages a\n  // CordRep*, and resets the instance to an empty SSO instance. If the current\n  // instance is an SSO instance, then this method returns nullptr and sets\n  // `short_value` to the inlined data value. In either case, the current\n  // instance length is reset to zero.\n  // This method is intended to be used by Cord internal functions only.\n  cord_internal::CordRep* ConsumeValue(absl::string_view& short_value) {\n    cord_internal::CordRep* rep = nullptr;\n    if (rep_.is_short()) {\n      short_value = absl::string_view(rep_.data(), rep_.short_length());\n    } else {\n      rep = rep_.rep();\n    }\n    rep_.set_short_length(0);\n    return rep;\n  }\n\n  // Internal constructor.\n  explicit CordBuffer(cord_internal::CordRepFlat* rep) : rep_(rep) {\n    assert(rep != nullptr);\n  }\n\n  Rep rep_;\n\n  friend class Cord;\n  friend class CordBufferTestPeer;\n}",
  "id": "BLOCK-CPP-04055",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord_buffer.h",
  "source_line": 189,
  "validation_status": "validated"
}