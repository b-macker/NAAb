{
  "code": "#include \"clang/AST/DeclBase.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include <optional>\n#include <queue>\n#include <utility>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-07258_execute() {\n    {\n  /// AST contexts for which we are checking structural equivalence.\n  ASTContext &FromCtx, &ToCtx;\n\n  // Queue of from-to Decl pairs that are to be checked to determine the final\n  // result of equivalence of a starting Decl pair.\n  std::queue<std::pair<Decl *, Decl *>> DeclsToCheck;\n\n  // Set of from-to Decl pairs that are already visited during the check\n  // (are in or were once in \\c DeclsToCheck) of a starting Decl pair.\n  llvm::DenseSet<std::pair<Decl *, Decl *>> VisitedDecls;\n\n  /// Declaration (from, to) pairs that are known not to be equivalent\n  /// (which we have already complained about).\n  llvm::DenseSet<std::pair<Decl *, Decl *>> &NonEquivalentDecls;\n\n  StructuralEquivalenceKind EqKind;\n\n  /// Whether we're being strict about the spelling of types when\n  /// unifying two types.\n  bool StrictTypeSpelling;\n\n  /// Whether warn or error on tag type mismatches.\n  bool ErrorOnTagTypeMismatch;\n\n  /// Whether to complain about failures.\n  bool Complain;\n\n  /// \\c true if the last diagnostic came from ToCtx.\n  bool LastDiagFromC2 = false;\n\n  StructuralEquivalenceContext(\n      ASTContext &FromCtx, ASTContext &ToCtx,\n      llvm::DenseSet<std::pair<Decl *, Decl *>> &NonEquivalentDecls,\n      StructuralEquivalenceKind EqKind,\n      bool StrictTypeSpelling = false, bool Complain = true,\n      bool ErrorOnTagTypeMismatch = false)\n      : FromCtx(FromCtx), ToCtx(ToCtx), NonEquivalentDecls(NonEquivalentDecls),\n        EqKind(EqKind), StrictTypeSpelling(StrictTypeSpelling),\n        ErrorOnTagTypeMismatch(ErrorOnTagTypeMismatch), Complain(Complain) {}\n\n  DiagnosticBuilder Diag1(SourceLocation Loc, unsigned DiagID);\n  DiagnosticBuilder Diag2(SourceLocation Loc, unsigned DiagID);\n\n  /// Determine whether the two declarations are structurally\n  /// equivalent.\n  /// Implementation functions (all static functions in\n  /// ASTStructuralEquivalence.cpp) must never call this function because that\n  /// will wreak havoc the internal state (\\c DeclsToCheck and\n  /// \\c VisitedDecls members) and can cause faulty equivalent results.\n  bool IsEquivalent(Decl *D1, Decl *D2);\n\n  /// Determine whether the two types are structurally equivalent.\n  /// Implementation functions (all static functions in\n  /// ASTStructuralEquivalence.cpp) must never call this function because that\n  /// will wreak havoc the internal state (\\c DeclsToCheck and\n  /// \\c VisitedDecls members) and can cause faulty equivalent results.\n  bool IsEquivalent(QualType T1, QualType T2);\n\n  /// Determine whether the two statements are structurally equivalent.\n  /// Implementation functions (all static functions in\n  /// ASTStructuralEquivalence.cpp) must never call this function because that\n  /// will wreak havoc the internal state (\\c DeclsToCheck and\n  /// \\c VisitedDecls members) and can cause faulty equivalent results.\n  bool IsEquivalent(Stmt *S1, Stmt *S2);\n\n  /// Find the index of the given anonymous struct/union within its\n  /// context.\n  ///\n  /// \\returns Returns the index of this anonymous struct/union in its context,\n  /// including the next assigned index (if none of them match). Returns an\n  /// empty option if the context is not a record, i.e.. if the anonymous\n  /// struct/union is at namespace or block scope.\n  ///\n  /// FIXME: This is needed by ASTImporter and ASTStructureEquivalence. It\n  /// probably makes more sense in some other common place then here.\n  static std::optional<unsigned>\n  findUntaggedStructOrUnionIndex(RecordDecl *Anon);\n\n  // If ErrorOnTagTypeMismatch is set, return the error, otherwise get the\n  // relevant warning for the input error diagnostic.\n  unsigned getApplicableDiagnostic(unsigned ErrorDiagnostic);\n\nprivate:\n  /// Finish checking all of the structural equivalences.\n  ///\n  /// \\returns true if the equivalence check failed (non-equivalence detected),\n  /// false if equivalence was detected.\n  bool Finish();\n\n  /// Check for common properties at Finish.\n  /// \\returns true if D1 and D2 may be equivalent,\n  /// false if they are for sure not.\n  bool CheckCommonEquivalence(Decl *D1, Decl *D2);\n\n  /// Check for class dependent properties at Finish.\n  /// \\returns true if D1 and D2 may be equivalent,\n  /// false if they are for sure not.\n  bool CheckKindSpecificEquivalence(Decl *D1, Decl *D2);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-07258",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTStructuralEquivalence.h",
  "source_line": 41,
  "validation_status": "validated"
}