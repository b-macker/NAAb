{
  "code": "{\n\n/// Class representing optional flags with location and representation\n/// information.\nclass OptionalFlag {\npublic:\n  OptionalFlag(const char *Representation)\n      : representation(Representation), flag(false) {}\n  bool isSet() const { return flag; }\n  void set() { flag = true; }\n  void clear() { flag = false; }\n  void setPosition(const char *position) {\n    assert(position);\n    flag = true;\n    this->position = position;\n  }\n  const char *getPosition() const {\n    assert(position);\n    return position;\n  }\n  const char *toString() const { return representation; }\n\n  // Overloaded operators for bool like qualities\n  explicit operator bool() const { return flag; }\n  OptionalFlag& operator=(const bool &rhs) {\n    flag = rhs;\n    return *this;  // Return a reference to myself.\n  }\nprivate:\n  const char *representation;\n  const char *position;\n  bool flag;\n};\n\n/// Represents the length modifier in a format string in scanf/printf.\nclass LengthModifier {\npublic:\n  enum Kind {\n    None,\n    AsChar,       // 'hh'\n    AsShort,      // 'h'\n    AsShortLong,  // 'hl' (OpenCL float/int vector element)\n    AsLong,       // 'l'\n    AsLongLong,   // 'll'\n    AsQuad,       // 'q' (BSD, deprecated, for 64-bit integer types)\n    AsIntMax,     // 'j'\n    AsSizeT,      // 'z'\n    AsPtrDiff,    // 't'\n    AsInt32,      // 'I32' (MSVCRT, like __int32)\n    AsInt3264,    // 'I'   (MSVCRT, like __int3264 from MIDL)\n    AsInt64,      // 'I64' (MSVCRT, like __int64)\n    AsLongDouble, // 'L'\n    AsAllocate,   // for '%as', GNU extension to C90 scanf\n    AsMAllocate,  // for '%ms', GNU extension to scanf\n    AsWide,       // 'w' (MSVCRT, like l but only for c, C, s, S, or Z\n    AsWideChar = AsLong // for '%ls', only makes sense for printf\n  };\n\n  LengthModifier()\n    : Position(nullptr), kind(None) {}\n  LengthModifier(const char *pos, Kind k)\n    : Position(pos), kind(k) {}\n\n  const char *getStart() const {\n    return Position;\n  }\n\n  unsigned getLength() const {\n    switch (kind) {\n      default:\n        return 1;\n      case AsLongLong:\n      case AsChar:\n        return 2;\n      case AsInt32:\n      case AsInt64:\n        return 3;\n      case None:\n        return 0;\n    }\n  }\n\n  Kind getKind() const { return kind; }\n  void setKind(Kind k) { kind = k; }\n\n  const char *toString() const;\n\nprivate:\n  const char *Position;\n  Kind kind;\n};\n\nclass ConversionSpecifier {\npublic:\n  enum Kind {\n    InvalidSpecifier = 0,\n    // C99 conversion specifiers.\n    cArg,\n    dArg,\n    DArg, // Apple extension\n    iArg,\n    // C23 conversion specifiers.\n    bArg,\n    BArg,\n\n    IntArgBeg = dArg,\n    IntArgEnd = BArg,\n\n    oArg,\n    OArg, // Apple extension\n    uArg,\n    UArg, // Apple extension\n    xArg,\n    XArg,\n    UIntArgBeg = oArg,\n    UIntArgEnd = XArg,\n\n    fArg,\n    FArg,\n    eArg,\n    EArg,\n    gArg,\n    GArg,\n    aArg,\n    AArg,\n    DoubleArgBeg = fArg,\n    DoubleArgEnd = AArg,\n\n    sArg,\n    pArg,\n    nArg,\n    PercentArg,\n    CArg,\n    SArg,\n\n    // Apple extension: P specifies to os_log that the data being pointed to is\n    // to be copied by os_log. The precision indicates the number of bytes to\n    // copy.\n    PArg,\n\n    // ** Printf-specific **\n\n    ZArg, // MS extension\n\n    // Objective-C specific specifiers.\n    ObjCObjArg, // '@'\n    ObjCBeg = ObjCObjArg,\n    ObjCEnd = ObjCObjArg,\n\n    // FreeBSD kernel specific specifiers.\n    FreeBSDbArg,\n    FreeBSDDArg,\n    FreeBSDrArg,\n    FreeBSDyArg,\n\n    // GlibC specific specifiers.\n    PrintErrno, // 'm'\n\n    PrintfConvBeg = ObjCObjArg,\n    PrintfConvEnd = PrintErrno,\n\n    // ** Scanf-specific **\n    ScanListArg, // '['\n    ScanfConvBeg = ScanListArg,\n    ScanfConvEnd = ScanListArg\n  };\n\n  ConversionSpecifier(bool isPrintf = true)\n    : IsPrintf(isPrintf), Position(nullptr), EndScanList(nullptr),\n      kind(InvalidSpecifier) {}\n\n  ConversionSpecifier(bool isPrintf, const char *pos, Kind k)\n    : IsPrintf(isPrintf), Position(pos), EndScanList(nullptr), kind(k) {}\n\n  const char *getStart() const {\n    return Position;\n  }\n\n  StringRef getCharacters() const {\n    return StringRef(getStart(), getLength());\n  }\n\n  bool consumesDataArgument() const {\n    switch (kind) {\n      case PrintErrno:\n        assert(IsPrintf);\n        return false;\n      case PercentArg:\n        return false;\n      case InvalidSpecifier:\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  Kind getKind() const { return kind; }\n  void setKind(Kind k) { kind = k; }\n  unsigned getLength() const {\n    return EndScanList ? EndScanList - Position : 1;\n  }\n  void setEndScanList(const char *pos) { EndScanList = pos; }\n\n  bool isIntArg() const { return (kind >= IntArgBeg && kind <= IntArgEnd) ||\n    kind == FreeBSDrArg || kind == FreeBSDyArg; }\n  bool isUIntArg() const { return kind >= UIntArgBeg && kind <= UIntArgEnd; }\n  bool isAnyIntArg() const { return kind >= IntArgBeg && kind <= UIntArgEnd; }\n  bool isDoubleArg() const {\n    return kind >= DoubleArgBeg && kind <= DoubleArgEnd;\n  }\n\n  const char *toString() const;\n\n  bool isPrintfKind() const { return IsPrintf; }\n\n  std::optional<ConversionSpecifier> getStandardSpecifier() const;\n\nprotected:\n  bool IsPrintf;\n  const char *Position;\n  const char *EndScanList;\n  Kind kind;\n};\n\nclass ArgType {\npublic:\n  enum Kind { UnknownTy, InvalidTy, SpecificTy, ObjCPointerTy, CPointerTy,\n              AnyCharTy, CStrTy, WCStrTy, WIntTy };\n\n  /// How well a given conversion specifier matches its argument.\n  enum MatchKind {\n    /// The conversion specifier and the argument types are incompatible. For\n    /// instance, \"%d\" and float.\n    NoMatch = 0,\n    /// The conversion specifier and the argument type are compatible. For\n    /// instance, \"%d\" and int.\n    Match = 1,\n    /// The conversion specifier and the argument type are compatible because of\n    /// default argument promotions. For instance, \"%hhd\" and int.\n    MatchPromotion,\n    /// The conversion specifier and the argument type are compatible but still\n    /// seems likely to be an error. For instanace, \"%hhd\" and short.\n    NoMatchPromotionTypeConfusion,\n    /// The conversion specifier and the argument type are disallowed by the C\n    /// standard, but are in practice harmless. For instance, \"%p\" and int*.\n    NoMatchPedantic,\n    /// The conversion specifier and the argument type are compatible, but still\n    /// seems likely to be an error. For instance, \"%hd\" and _Bool.\n    NoMatchTypeConfusion,\n  };\n\nprivate:\n  const Kind K;\n  QualType T;\n  const char *Name = nullptr;\n  bool Ptr = false;\n\n  /// The TypeKind identifies certain well-known types like size_t and\n  /// ptrdiff_t.\n  enum class TypeKind { DontCare, SizeT, PtrdiffT };\n  TypeKind TK = TypeKind::DontCare;\n\npublic:\n  ArgType(Kind K = UnknownTy, const char *N = nullptr) : K(K), Name(N) {}\n  ArgType(QualType T, const char *N = nullptr) : K(SpecificTy), T(T), Name(N) {}\n  ArgType(CanQualType T) : K(SpecificTy), T(T) {}\n\n  static ArgType Invalid() { return ArgType(InvalidTy); }\n  bool isValid() const { return K != InvalidTy; }\n\n  bool isSizeT() const { return TK == TypeKind::SizeT; }\n\n  bool isPtrdiffT() const { return TK == TypeKind::PtrdiffT; }\n\n  /// Create an ArgType which corresponds to the type pointer to A.\n  static ArgType PtrTo(const ArgType& A) {\n    assert(A.K >= InvalidTy && \"ArgType cannot be pointer to invalid/unknown\");\n    ArgType Res = A;\n    Res.Ptr = true;\n    return Res;\n  }\n\n  /// Create an ArgType which corresponds to the size_t/ssize_t type.\n  static ArgType makeSizeT(const ArgType &A) {\n    ArgType Res = A;\n    Res.TK = TypeKind::SizeT;\n    return Res;\n  }\n\n  /// Create an ArgType which corresponds to the ptrdiff_t/unsigned ptrdiff_t\n  /// type.\n  static ArgType makePtrdiffT(const ArgType &A) {\n    ArgType Res = A;\n    Res.TK = TypeKind::PtrdiffT;\n    return Res;\n  }\n\n  MatchKind matchesType(ASTContext &C, QualType argTy) const;\n\n  QualType getRepresentativeType(ASTContext &C) const;\n\n  ArgType makeVectorType(ASTContext &C, unsigned NumElts) const;\n\n  std::string getRepresentativeTypeName(ASTContext &C) const;\n};\n\nclass OptionalAmount {\npublic:\n  enum HowSpecified { NotSpecified, Constant, Arg, Invalid };\n\n  OptionalAmount(HowSpecified howSpecified,\n                 unsigned amount,\n                 const char *amountStart,\n                 unsigned amountLength,\n                 bool usesPositionalArg)\n  : start(amountStart), length(amountLength), hs(howSpecified), amt(amount),\n  UsesPositionalArg(usesPositionalArg), UsesDotPrefix(false) {}\n\n  OptionalAmount(bool valid = true)\n  : start(nullptr),length(0), hs(valid ? NotSpecified : Invalid), amt(0),\n  UsesPositionalArg(false), UsesDotPrefix(false) {}\n\n  explicit OptionalAmount(unsigned Amount)\n    : start(nullptr), length(0), hs(Constant), amt(Amount),\n    UsesPositionalArg(false), UsesDotPrefix(false) {}\n\n  bool isInvalid() const {\n    return hs == Invalid;\n  }\n\n  HowSpecified getHowSpecified() const { return hs; }\n  void setHowSpecified(HowSpecified h) { hs = h; }\n\n  bool hasDataArgument() const { return hs == Arg; }\n\n  unsigned getArgIndex() const {\n    assert(hasDataArgument());\n    return amt;\n  }\n\n  unsigned getConstantAmount() const {\n    assert(hs == Constant);\n    return amt;\n  }\n\n  const char *getStart() const {\n      // We include the . character if it is given.\n    return start - UsesDotPrefix;\n  }\n\n  unsigned getConstantLength() const {\n    assert(hs == Constant);\n    return length + UsesDotPrefix;\n  }\n\n  ArgType getArgType(ASTContext &Ctx) const;\n\n  void toString(raw_ostream &os) const;\n\n  bool usesPositionalArg() const { return (bool) UsesPositionalArg; }\n  unsigned getPositionalArgIndex() const {\n    assert(hasDataArgument());\n    return amt + 1;\n  }\n\n  bool usesDotPrefix() const { return UsesDotPrefix; }\n  void setUsesDotPrefix() { UsesDotPrefix = true; }\n\nprivate:\n  const char *start;\n  unsigned length;\n  HowSpecified hs;\n  unsigned amt;\n  bool UsesPositionalArg : 1;\n  bool UsesDotPrefix;\n};\n\n\nclass FormatSpecifier {\nprotected:\n  LengthModifier LM;\n  OptionalAmount FieldWidth;\n  ConversionSpecifier CS;\n  OptionalAmount VectorNumElts;\n\n  /// Positional arguments, an IEEE extension:\n  ///  IEEE Std 1003.1, 2004 Edition\n  ///  http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\n  bool UsesPositionalArg;\n  unsigned argIndex;\npublic:\n  FormatSpecifier(bool isPrintf)\n    : CS(isPrintf), VectorNumElts(false),\n      UsesPositionalArg(false), argIndex(0) {}\n\n  void setLengthModifier(LengthModifier lm) {\n    LM = lm;\n  }\n\n  void setUsesPositionalArg() { UsesPositionalArg = true; }\n\n  void setArgIndex(unsigned i) {\n    argIndex = i;\n  }\n\n  unsigned getArgIndex() const {\n    return argIndex;\n  }\n\n  unsigned getPositionalArgIndex() const {\n    return argIndex + 1;\n  }\n\n  const LengthModifier &getLengthModifier() const {\n    return LM;\n  }\n\n  const OptionalAmount &getFieldWidth() const {\n    return FieldWidth;\n  }\n\n  void setVectorNumElts(const OptionalAmount &Amt) {\n    VectorNumElts = Amt;\n  }\n\n  const OptionalAmount &getVectorNumElts() const {\n    return VectorNumElts;\n  }\n\n  void setFieldWidth(const OptionalAmount &Amt) {\n    FieldWidth = Amt;\n  }\n\n  bool usesPositionalArg() const { return UsesPositionalArg; }\n\n  bool hasValidLengthModifier(const TargetInfo &Target,\n                              const LangOptions &LO) const;\n\n  bool hasStandardLengthModifier() const;\n\n  std::optional<LengthModifier> getCorrectedLengthModifier() const;\n\n  bool hasStandardConversionSpecifier(const LangOptions &LangOpt) const;\n\n  bool hasStandardLengthConversionCombination() const;\n\n  /// For a TypedefType QT, if it is a named integer type such as size_t,\n  /// assign the appropriate value to LM and return true.\n  static bool namedTypeToLengthModifier(QualType QT, LengthModifier &LM);\n};\n\n}",
  "id": "BLOCK-CPP-11210",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/FormatString.h",
  "source_line": 30,
  "validation_status": "validated"
}