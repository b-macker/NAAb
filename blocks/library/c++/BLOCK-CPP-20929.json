{
  "code": "{\nclass OMPTraitInfo;\nclass OMPChildren;\n\n/// An object for streaming information from a record.\nclass ASTRecordReader\n    : public serialization::DataStreamBasicReader<ASTRecordReader> {\n  using ModuleFile = serialization::ModuleFile;\n  using LocSeq = SourceLocationSequence;\n\n  ASTReader *Reader;\n  ModuleFile *F;\n  unsigned Idx = 0;\n  ASTReader::RecordData Record;\n\n  using RecordData = ASTReader::RecordData;\n  using RecordDataImpl = ASTReader::RecordDataImpl;\n\npublic:\n  /// Construct an ASTRecordReader that uses the default encoding scheme.\n  ASTRecordReader(ASTReader &Reader, ModuleFile &F)\n    : DataStreamBasicReader(Reader.getContext()), Reader(&Reader), F(&F) {}\n\n  /// Reads a record with id AbbrevID from Cursor, resetting the\n  /// internal state.\n  Expected<unsigned> readRecord(llvm::BitstreamCursor &Cursor,\n                                unsigned AbbrevID);\n\n  /// Is this a module file for a module (rather than a PCH or similar).\n  bool isModule() const { return F->isModule(); }\n\n  /// Retrieve the AST context that this AST reader supplements.\n  ASTContext &getContext() { return Reader->getContext(); }\n\n  /// The current position in this record.\n  unsigned getIdx() const { return Idx; }\n\n  /// The length of this record.\n  size_t size() const { return Record.size(); }\n\n  /// An arbitrary index in this record.\n  const uint64_t &operator[](size_t N) { return Record[N]; }\n\n  /// Returns the last value in this record.\n  uint64_t back() { return Record.back(); }\n\n  /// Returns the current value in this record, and advances to the\n  /// next value.\n  uint64_t readInt() { return Record[Idx++]; }\n\n  ArrayRef<uint64_t> readIntArray(unsigned Len) {\n    auto Array = llvm::ArrayRef(Record).slice(Idx, Len);\n    Idx += Len;\n    return Array;\n  }\n\n  /// Returns the current value in this record, without advancing.\n  uint64_t peekInt() { return Record[Idx]; }\n\n  /// Skips the specified number of values.\n  void skipInts(unsigned N) { Idx += N; }\n\n  /// Retrieve the global submodule ID its local ID number.\n  serialization::SubmoduleID\n  getGlobalSubmoduleID(unsigned LocalID) {\n    return Reader->getGlobalSubmoduleID(*F, LocalID);\n  }\n\n  /// Retrieve the submodule that corresponds to a global submodule ID.\n  Module *getSubmodule(serialization::SubmoduleID GlobalID) {\n    return Reader->getSubmodule(GlobalID);\n  }\n\n  /// Read the record that describes the lexical contents of a DC.\n  bool readLexicalDeclContextStorage(uint64_t Offset, DeclContext *DC) {\n    return Reader->ReadLexicalDeclContextStorage(*F, F->DeclsCursor, Offset,\n                                                 DC);\n  }\n\n  /// Read the record that describes the visible contents of a DC.\n  bool readVisibleDeclContextStorage(uint64_t Offset,\n                                     serialization::DeclID ID) {\n    return Reader->ReadVisibleDeclContextStorage(*F, F->DeclsCursor, Offset,\n                                                 ID);\n  }\n\n  ExplicitSpecifier readExplicitSpec() {\n    uint64_t Kind = readInt();\n    bool HasExpr = Kind & 0x1;\n    Kind = Kind >> 1;\n    return ExplicitSpecifier(HasExpr ? readExpr() : nullptr,\n                             static_cast<ExplicitSpecKind>(Kind));\n  }\n\n  /// Read information about an exception specification (inherited).\n  //FunctionProtoType::ExceptionSpecInfo\n  //readExceptionSpecInfo(SmallVectorImpl<QualType> &ExceptionStorage);\n\n  /// Get the global offset corresponding to a local offset.\n  uint64_t getGlobalBitOffset(uint64_t LocalOffset) {\n    return Reader->getGlobalBitOffset(*F, LocalOffset);\n  }\n\n  /// Reads a statement.\n  Stmt *readStmt() { return Reader->ReadStmt(*F); }\n  Stmt *readStmtRef() { return readStmt(); /* FIXME: readSubStmt? */ }\n\n  /// Reads an expression.\n  Expr *readExpr() { return Reader->ReadExpr(*F); }\n\n  /// Reads a sub-statement operand during statement reading.\n  Stmt *readSubStmt() { return Reader->ReadSubStmt(); }\n\n  /// Reads a sub-expression operand during statement reading.\n  Expr *readSubExpr() { return Reader->ReadSubExpr(); }\n\n  /// Reads a declaration with the given local ID in the given module.\n  ///\n  /// \\returns The requested declaration, casted to the given return type.\n  template<typename T>\n  T *GetLocalDeclAs(uint32_t LocalID) {\n    return cast_or_null<T>(Reader->GetLocalDecl(*F, LocalID));\n  }\n\n  /// Reads a TemplateArgumentLocInfo appropriate for the\n  /// given TemplateArgument kind, advancing Idx.\n  TemplateArgumentLocInfo\n  readTemplateArgumentLocInfo(TemplateArgument::ArgKind Kind);\n\n  /// Reads a TemplateArgumentLoc, advancing Idx.\n  TemplateArgumentLoc readTemplateArgumentLoc();\n\n  const ASTTemplateArgumentListInfo*\n  readASTTemplateArgumentListInfo();\n\n  /// Reads a declarator info from the given record, advancing Idx.\n  TypeSourceInfo *readTypeSourceInfo();\n\n  /// Reads the location information for a type.\n  void readTypeLoc(TypeLoc TL, LocSeq *Seq = nullptr);\n\n  /// Map a local type ID within a given AST file to a global type ID.\n  serialization::TypeID getGlobalTypeID(unsigned LocalID) const {\n    return Reader->getGlobalTypeID(*F, LocalID);\n  }\n\n  Qualifiers readQualifiers() {\n    return Qualifiers::fromOpaqueValue(readInt());\n  }\n\n  /// Read a type from the current position in the record.\n  QualType readType() {\n    return Reader->readType(*F, Record, Idx);\n  }\n  QualType readQualType() {\n    return readType();\n  }\n\n  /// Reads a declaration ID from the given position in this record.\n  ///\n  /// \\returns The declaration ID read from the record, adjusted to a global ID.\n  serialization::DeclID readDeclID() {\n    return Reader->ReadDeclID(*F, Record, Idx);\n  }\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module, advancing Idx.\n  Decl *readDecl() {\n    return Reader->ReadDecl(*F, Record, Idx);\n  }\n  Decl *readDeclRef() {\n    return readDecl();\n  }\n\n  /// Reads a declaration from the given position in the record,\n  /// advancing Idx.\n  ///\n  /// \\returns The declaration read from this location, casted to the given\n  /// result type.\n  template<typename T>\n  T *readDeclAs() {\n    return Reader->ReadDeclAs<T>(*F, Record, Idx);\n  }\n\n  IdentifierInfo *readIdentifier() {\n    return Reader->readIdentifier(*F, Record, Idx);\n  }\n\n  /// Read a selector from the Record, advancing Idx.\n  Selector readSelector() {\n    return Reader->ReadSelector(*F, Record, Idx);\n  }\n\n  /// Read a declaration name, advancing Idx.\n  // DeclarationName readDeclarationName(); (inherited)\n  DeclarationNameLoc readDeclarationNameLoc(DeclarationName Name);\n  DeclarationNameInfo readDeclarationNameInfo();\n\n  void readQualifierInfo(QualifierInfo &Info);\n\n  /// Return a nested name specifier, advancing Idx.\n  // NestedNameSpecifier *readNestedNameSpecifier(); (inherited)\n\n  NestedNameSpecifierLoc readNestedNameSpecifierLoc();\n\n  /// Read a template name, advancing Idx.\n  // TemplateName readTemplateName(); (inherited)\n\n  /// Read a template argument, advancing Idx. (inherited)\n  // TemplateArgument readTemplateArgument();\n  using DataStreamBasicReader::readTemplateArgument;\n  TemplateArgument readTemplateArgument(bool Canonicalize) {\n    TemplateArgument Arg = readTemplateArgument();\n    if (Canonicalize) {\n      Arg = getContext().getCanonicalTemplateArgument(Arg);\n    }\n    return Arg;\n  }\n\n  /// Read a template parameter list, advancing Idx.\n  TemplateParameterList *readTemplateParameterList();\n\n  /// Read a template argument array, advancing Idx.\n  void readTemplateArgumentList(SmallVectorImpl<TemplateArgument> &TemplArgs,\n                                bool Canonicalize = false);\n\n  /// Read a UnresolvedSet structure, advancing Idx.\n  void readUnresolvedSet(LazyASTUnresolvedSet &Set);\n\n  /// Read a C++ base specifier, advancing Idx.\n  CXXBaseSpecifier readCXXBaseSpecifier();\n\n  /// Read a CXXCtorInitializer array, advancing Idx.\n  CXXCtorInitializer **readCXXCtorInitializers();\n\n  CXXTemporary *readCXXTemporary() {\n    return Reader->ReadCXXTemporary(*F, Record, Idx);\n  }\n\n  /// Read an OMPTraitInfo object, advancing Idx.\n  OMPTraitInfo *readOMPTraitInfo();\n\n  /// Read an OpenMP clause, advancing Idx.\n  OMPClause *readOMPClause();\n\n  /// Read an OpenMP children, advancing Idx.\n  void readOMPChildren(OMPChildren *Data);\n\n  /// Read a source location, advancing Idx.\n  SourceLocation readSourceLocation(LocSeq *Seq = nullptr) {\n    return Reader->ReadSourceLocation(*F, Record, Idx, Seq);\n  }\n\n  /// Read a source range, advancing Idx.\n  SourceRange readSourceRange(LocSeq *Seq = nullptr) {\n    return Reader->ReadSourceRange(*F, Record, Idx, Seq);\n  }\n\n  /// Read an arbitrary constant value, advancing Idx.\n  // APValue readAPValue(); (inherited)\n\n  /// Read an integral value, advancing Idx.\n  // llvm::APInt readAPInt(); (inherited)\n\n  /// Read a signed integral value, advancing Idx.\n  // llvm::APSInt readAPSInt(); (inherited)\n\n  /// Read a floating-point value, advancing Idx.\n  llvm::APFloat readAPFloat(const llvm::fltSemantics &Sem);\n\n  /// Read a boolean value, advancing Idx.\n  bool readBool() { return readInt() != 0; }\n\n  /// Read a 32-bit unsigned value; required to satisfy BasicReader.\n  uint32_t readUInt32() {\n    return uint32_t(readInt());\n  }\n\n  /// Read a 64-bit unsigned value; required to satisfy BasicReader.\n  uint64_t readUInt64() {\n    return readInt();\n  }\n\n  /// Read a string, advancing Idx.\n  std::string readString() {\n    return Reader->ReadString(Record, Idx);\n  }\n\n  /// Read a path, advancing Idx.\n  std::string readPath() {\n    return Reader->ReadPath(*F, Record, Idx);\n  }\n\n  /// Read a version tuple, advancing Idx.\n  VersionTuple readVersionTuple() {\n    return ASTReader::ReadVersionTuple(Record, Idx);\n  }\n\n  /// Reads one attribute from the current stream position, advancing Idx.\n  Attr *readAttr();\n\n  /// Reads attributes from the current stream position, advancing Idx.\n  void readAttributes(AttrVec &Attrs);\n\n  /// Read an BTFTypeTagAttr object.\n  BTFTypeTagAttr *readBTFTypeTagAttr() {\n    return cast<BTFTypeTagAttr>(readAttr());\n  }\n\n  /// Reads a token out of a record, advancing Idx.\n  Token readToken() {\n    return Reader->ReadToken(*F, Record, Idx);\n  }\n\n  void recordSwitchCaseID(SwitchCase *SC, unsigned ID) {\n    Reader->RecordSwitchCaseID(SC, ID);\n  }\n\n  /// Retrieve the switch-case statement with the given ID.\n  SwitchCase *getSwitchCaseWithID(unsigned ID) {\n    return Reader->getSwitchCaseWithID(ID);\n  }\n};\n\n/// Helper class that saves the current stream position and\n/// then restores it when destroyed.\nstruct SavedStreamPosition {\n  explicit SavedStreamPosition(llvm::BitstreamCursor &Cursor)\n      : Cursor(Cursor), Offset(Cursor.GetCurrentBitNo()) {}\n\n  ~SavedStreamPosition() {\n    if (llvm::Error Err = Cursor.JumpToBit(Offset))\n      llvm::report_fatal_error(\n          llvm::Twine(\"Cursor should always be able to go back, failed: \") +\n          toString(std::move(Err)));\n  }\n\nprivate:\n  llvm::BitstreamCursor &Cursor;\n  uint64_t Offset;\n};\n\ninline void PCHValidator::Error(const char *Msg) {\n  Reader.Error(Msg);\n}\n\n}",
  "id": "BLOCK-CPP-20929",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ASTRecordReader.h",
  "source_line": 26,
  "validation_status": "validated"
}