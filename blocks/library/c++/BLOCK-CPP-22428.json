{
  "code": "{\npublic:\n  using VisitorList = SmallVector<std::unique_ptr<BugReporterVisitor>, 8>;\n  using visitor_iterator = VisitorList::iterator;\n  using visitor_range = llvm::iterator_range<visitor_iterator>;\n\nprotected:\n  /// The ExplodedGraph node against which the report was thrown. It corresponds\n  /// to the end of the execution path that demonstrates the bug.\n  const ExplodedNode *ErrorNode = nullptr;\n\n  /// The range that corresponds to ErrorNode's program point. It is usually\n  /// highlighted in the report.\n  const SourceRange ErrorNodeRange;\n\n  /// Profile to identify equivalent bug reports for error report coalescing.\n\n  /// A (stack of) a set of symbols that are registered with this\n  /// report as being \"interesting\", and thus used to help decide which\n  /// diagnostics to include when constructing the final path diagnostic.\n  /// The stack is largely used by BugReporter when generating PathDiagnostics\n  /// for multiple PathDiagnosticConsumers.\n  llvm::DenseMap<SymbolRef, bugreporter::TrackingKind> InterestingSymbols;\n\n  /// A (stack of) set of regions that are registered with this report as being\n  /// \"interesting\", and thus used to help decide which diagnostics\n  /// to include when constructing the final path diagnostic.\n  /// The stack is largely used by BugReporter when generating PathDiagnostics\n  /// for multiple PathDiagnosticConsumers.\n  llvm::DenseMap<const MemRegion *, bugreporter::TrackingKind>\n      InterestingRegions;\n\n  /// A set of location contexts that correspoind to call sites which should be\n  /// considered \"interesting\".\n  llvm::SmallSet<const LocationContext *, 2> InterestingLocationContexts;\n\n  /// A set of custom visitors which generate \"event\" diagnostics at\n  /// interesting points in the path.\n  VisitorList Callbacks;\n\n  /// Used for ensuring the visitors are only added once.\n  llvm::FoldingSet<BugReporterVisitor> CallbacksSet;\n\n  /// When set, this flag disables all callstack pruning from a diagnostic\n  /// path.  This is useful for some reports that want maximum fidelty\n  /// when reporting an issue.\n  bool DoNotPrunePath = false;\n\n  /// Used to track unique reasons why a bug report might be invalid.\n  ///\n  /// \\sa markInvalid\n  /// \\sa removeInvalidation\n  using InvalidationRecord = std::pair<const void *, const void *>;\n\n  /// If non-empty, this bug report is likely a false positive and should not be\n  /// shown to the user.\n  ///\n  /// \\sa markInvalid\n  /// \\sa removeInvalidation\n  llvm::SmallSet<InvalidationRecord, 4> Invalidations;\n\n  /// Conditions we're already tracking.\n  llvm::SmallSet<const ExplodedNode *, 4> TrackedConditions;\n\n  /// Reports with different uniqueing locations are considered to be different\n  /// for the purposes of deduplication.\n  PathDiagnosticLocation UniqueingLocation;\n  const Decl *UniqueingDecl;\n\n  const Stmt *getStmt() const;\n\n  /// If an event occurs in a different frame than the final diagnostic,\n  /// supply a message that will be used to construct an extra hint on the\n  /// returns from all the calls on the stack from this event to the final\n  /// diagnostic.\n  // FIXME: Allow shared_ptr keys in DenseMap?\n  std::map<PathDiagnosticPieceRef, std::unique_ptr<StackHintGenerator>>\n      StackHints;\n\npublic:\n  PathSensitiveBugReport(const BugType &bt, StringRef desc,\n                         const ExplodedNode *errorNode)\n      : PathSensitiveBugReport(bt, desc, desc, errorNode) {}\n\n  PathSensitiveBugReport(const BugType &bt, StringRef shortDesc, StringRef desc,\n                         const ExplodedNode *errorNode)\n      : PathSensitiveBugReport(bt, shortDesc, desc, errorNode,\n                               /*LocationToUnique*/ {},\n                               /*DeclToUnique*/ nullptr) {}\n\n  /// Create a PathSensitiveBugReport with a custom uniqueing location.\n  ///\n  /// The reports that have the same report location, description, bug type, and\n  /// ranges are uniqued - only one of the equivalent reports will be presented\n  /// to the user. This method allows to rest the location which should be used\n  /// for uniquing reports. For example, memory leaks checker, could set this to\n  /// the allocation site, rather then the location where the bug is reported.\n  PathSensitiveBugReport(const BugType &bt, StringRef desc,\n                         const ExplodedNode *errorNode,\n                         PathDiagnosticLocation LocationToUnique,\n                         const Decl *DeclToUnique)\n      : PathSensitiveBugReport(bt, desc, desc, errorNode, LocationToUnique,\n                               DeclToUnique) {}\n\n  PathSensitiveBugReport(const BugType &bt, StringRef shortDesc, StringRef desc,\n                         const ExplodedNode *errorNode,\n                         PathDiagnosticLocation LocationToUnique,\n                         const Decl *DeclToUnique);\n\n  static bool classof(const BugReport *R) {\n    return R->getKind() == Kind::PathSensitive;\n  }\n\n  const ExplodedNode *getErrorNode() const { return ErrorNode; }\n\n  /// Indicates whether or not any path pruning should take place\n  /// when generating a PathDiagnostic from this BugReport.\n  bool shouldPrunePath() const { return !DoNotPrunePath; }\n\n  /// Disable all path pruning when generating a PathDiagnostic.\n  void disablePathPruning() { DoNotPrunePath = true; }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLocation() const override {\n    return UniqueingLocation;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const override {\n    return UniqueingDecl;\n  }\n\n  const Decl *getDeclWithIssue() const override;\n\n  ArrayRef<SourceRange> getRanges() const override;\n\n  PathDiagnosticLocation getLocation() const override;\n\n  /// Marks a symbol as interesting. Different kinds of interestingness will\n  /// be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(SymbolRef sym, bugreporter::TrackingKind TKind =\n                                          bugreporter::TrackingKind::Thorough);\n\n  void markNotInteresting(SymbolRef sym);\n\n  /// Marks a region as interesting. Different kinds of interestingness will\n  /// be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(\n      const MemRegion *R,\n      bugreporter::TrackingKind TKind = bugreporter::TrackingKind::Thorough);\n\n  void markNotInteresting(const MemRegion *R);\n\n  /// Marks a symbolic value as interesting. Different kinds of interestingness\n  /// will be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(SVal V, bugreporter::TrackingKind TKind =\n                                   bugreporter::TrackingKind::Thorough);\n  void markInteresting(const LocationContext *LC);\n\n  bool isInteresting(SymbolRef sym) const;\n  bool isInteresting(const MemRegion *R) const;\n  bool isInteresting(SVal V) const;\n  bool isInteresting(const LocationContext *LC) const;\n\n  std::optional<bugreporter::TrackingKind>\n  getInterestingnessKind(SymbolRef sym) const;\n\n  std::optional<bugreporter::TrackingKind>\n  getInterestingnessKind(const MemRegion *R) const;\n\n  std::optional<bugreporter::TrackingKind> getInterestingnessKind(SVal V) const;\n\n  /// Returns whether or not this report should be considered valid.\n  ///\n  /// Invalid reports are those that have been classified as likely false\n  /// positives after the fact.\n  bool isValid() const {\n    return Invalidations.empty();\n  }\n\n  /// Marks the current report as invalid, meaning that it is probably a false\n  /// positive and should not be reported to the user.\n  ///\n  /// The \\p Tag and \\p Data arguments are intended to be opaque identifiers for\n  /// this particular invalidation, where \\p Tag represents the visitor\n  /// responsible for invalidation, and \\p Data represents the reason this\n  /// visitor decided to invalidate the bug report.\n  ///\n  /// \\sa removeInvalidation\n  void markInvalid(const void *Tag, const void *Data) {\n    Invalidations.insert(std::make_pair(Tag, Data));\n  }\n\n  /// Profile to identify equivalent bug reports for error report coalescing.\n  /// Reports are uniqued to ensure that we do not emit multiple diagnostics\n  /// for each bug.\n  void Profile(llvm::FoldingSetNodeID &hash) const override;\n\n  /// Add custom or predefined bug report visitors to this report.\n  ///\n  /// The visitors should be used when the default trace is not sufficient.\n  /// For example, they allow constructing a more elaborate trace.\n  /// @{\n  void addVisitor(std::unique_ptr<BugReporterVisitor> visitor);\n\n  template <class VisitorType, class... Args>\n  void addVisitor(Args &&... ConstructorArgs) {\n    addVisitor(\n        std::make_unique<VisitorType>(std::forward<Args>(ConstructorArgs)...));\n  }\n  /// @}\n\n  /// Remove all visitors attached to this bug report.\n  void clearVisitors();\n\n  /// Iterators through the custom diagnostic visitors.\n  visitor_iterator visitor_begin() { return Callbacks.begin(); }\n  visitor_iterator visitor_end() { return Callbacks.end(); }\n  visitor_range visitors() { return {visitor_begin(), visitor_end()}; }\n\n  /// Notes that the condition of the CFGBlock associated with \\p Cond is\n  /// being tracked.\n  /// \\returns false if the condition is already being tracked.\n  bool addTrackedCondition(const ExplodedNode *Cond) {\n    return TrackedConditions.insert(Cond).second;\n  }\n\n  void addCallStackHint(PathDiagnosticPieceRef Piece,\n                        std::unique_ptr<StackHintGenerator> StackHint) {\n    StackHints[Piece] = std::move(StackHint);\n  }\n\n  bool hasCallStackHint(PathDiagnosticPieceRef Piece) const {\n    return StackHints.count(Piece) > 0;\n  }\n\n  /// Produce the hint for the given node. The node contains\n  /// information about the call for which the diagnostic can be generated.\n  std::string\n  getCallStackMessage(PathDiagnosticPieceRef Piece,\n                      const ExplodedNode *N) const {\n    auto I = StackHints.find(Piece);\n    if (I != StackHints.end())\n      return I->second->getMessage(N);\n    return \"\";\n  }\n}",
  "id": "BLOCK-CPP-22428",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h",
  "source_line": 289,
  "validation_status": "validated"
}