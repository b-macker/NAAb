{
  "code": "{\n\nclass Decl;\nclass Stmt;\nclass VariableArrayType;\n\nclass StmtIteratorBase {\nprotected:\n  enum {\n    StmtMode = 0x0,\n    SizeOfTypeVAMode = 0x1,\n    DeclGroupMode = 0x2,\n    Flags = 0x3\n  };\n\n  union {\n    Stmt **stmt;\n    Decl **DGI;\n  };\n  uintptr_t RawVAPtr = 0;\n  Decl **DGE;\n\n  StmtIteratorBase(Stmt **s) : stmt(s) {}\n  StmtIteratorBase(const VariableArrayType *t);\n  StmtIteratorBase(Decl **dgi, Decl **dge);\n  StmtIteratorBase() : stmt(nullptr) {}\n\n  bool inDeclGroup() const {\n    return (RawVAPtr & Flags) == DeclGroupMode;\n  }\n\n  bool inSizeOfTypeVA() const {\n    return (RawVAPtr & Flags) == SizeOfTypeVAMode;\n  }\n\n  bool inStmt() const {\n    return (RawVAPtr & Flags) == StmtMode;\n  }\n\n  const VariableArrayType *getVAPtr() const {\n    return reinterpret_cast<const VariableArrayType*>(RawVAPtr & ~Flags);\n  }\n\n  void setVAPtr(const VariableArrayType *P) {\n    assert(inDeclGroup() || inSizeOfTypeVA());\n    RawVAPtr = reinterpret_cast<uintptr_t>(P) | (RawVAPtr & Flags);\n  }\n\n  void NextDecl(bool ImmediateAdvance = true);\n  bool HandleDecl(Decl* D);\n  void NextVA();\n\n  Stmt*& GetDeclExpr() const;\n};\n\ntemplate <typename DERIVED, typename REFERENCE>\nclass StmtIteratorImpl : public StmtIteratorBase {\nprotected:\n  StmtIteratorImpl(const StmtIteratorBase& RHS) : StmtIteratorBase(RHS) {}\n\npublic:\n  using iterator_category = std::forward_iterator_tag;\n  using value_type = REFERENCE;\n  using difference_type = std::ptrdiff_t;\n  using pointer = REFERENCE;\n  using reference = REFERENCE;\n\n  StmtIteratorImpl() = default;\n  StmtIteratorImpl(Stmt **s) : StmtIteratorBase(s) {}\n  StmtIteratorImpl(Decl **dgi, Decl **dge) : StmtIteratorBase(dgi, dge) {}\n  StmtIteratorImpl(const VariableArrayType *t) : StmtIteratorBase(t) {}\n\n  DERIVED& operator++() {\n    if (inStmt())\n      ++stmt;\n    else if (getVAPtr())\n      NextVA();\n    else\n      NextDecl();\n\n    return static_cast<DERIVED&>(*this);\n  }\n\n  DERIVED operator++(int) {\n    DERIVED tmp = static_cast<DERIVED&>(*this);\n    operator++();\n    return tmp;\n  }\n\n  friend bool operator==(const DERIVED &LHS, const DERIVED &RHS) {\n    return LHS.stmt == RHS.stmt && LHS.DGI == RHS.DGI &&\n           LHS.RawVAPtr == RHS.RawVAPtr;\n  }\n\n  friend bool operator!=(const DERIVED &LHS, const DERIVED &RHS) {\n    return !(LHS == RHS);\n  }\n\n  REFERENCE operator*() const {\n    return inStmt() ? *stmt : GetDeclExpr();\n  }\n\n  REFERENCE operator->() const { return operator*(); }\n};\n\nstruct ConstStmtIterator;\n\nstruct StmtIterator : public StmtIteratorImpl<StmtIterator, Stmt*&> {\n  explicit StmtIterator() = default;\n  StmtIterator(Stmt** S) : StmtIteratorImpl<StmtIterator, Stmt*&>(S) {}\n  StmtIterator(Decl** dgi, Decl** dge)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(dgi, dge) {}\n  StmtIterator(const VariableArrayType *t)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(t) {}\n\nprivate:\n  StmtIterator(const StmtIteratorBase &RHS)\n      : StmtIteratorImpl<StmtIterator, Stmt *&>(RHS) {}\n\n  inline friend StmtIterator\n  cast_away_const(const ConstStmtIterator &RHS);\n};\n\nstruct ConstStmtIterator : public StmtIteratorImpl<ConstStmtIterator,\n                                                   const Stmt*> {\n  explicit ConstStmtIterator() = default;\n  ConstStmtIterator(const StmtIterator& RHS)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt*>(RHS) {}\n\n  ConstStmtIterator(Stmt * const *S)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt *>(\n            const_cast<Stmt **>(S)) {}\n};\n\ninline StmtIterator cast_away_const(const ConstStmtIterator &RHS) {\n  return RHS;\n}\n\n}",
  "id": "BLOCK-CPP-12980",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtIterator.h",
  "source_line": 21,
  "validation_status": "validated"
}