{
  "code": "{\n\n  class ConsumedStmtVisitor;\n\n  enum ConsumedState {\n    // No state information for the given variable.\n    CS_None,\n\n    CS_Unknown,\n    CS_Unconsumed,\n    CS_Consumed\n  };\n\n  using OptionalNotes = SmallVector<PartialDiagnosticAt, 1>;\n  using DelayedDiag = std::pair<PartialDiagnosticAt, OptionalNotes>;\n  using DiagList = std::list<DelayedDiag>;\n\n  class ConsumedWarningsHandlerBase {\n  public:\n    virtual ~ConsumedWarningsHandlerBase();\n\n    /// Emit the warnings and notes left by the analysis.\n    virtual void emitDiagnostics() {}\n\n    /// Warn that a variable's state doesn't match at the entry and exit\n    /// of a loop.\n    ///\n    /// \\param Loc -- The location of the end of the loop.\n    ///\n    /// \\param VariableName -- The name of the variable that has a mismatched\n    /// state.\n    virtual void warnLoopStateMismatch(SourceLocation Loc,\n                                       StringRef VariableName) {}\n\n    /// Warn about parameter typestate mismatches upon return.\n    ///\n    /// \\param Loc -- The SourceLocation of the return statement.\n    ///\n    /// \\param ExpectedState -- The state the return value was expected to be\n    /// in.\n    ///\n    /// \\param ObservedState -- The state the return value was observed to be\n    /// in.\n    virtual void warnParamReturnTypestateMismatch(SourceLocation Loc,\n                                                  StringRef VariableName,\n                                                  StringRef ExpectedState,\n                                                  StringRef ObservedState) {}\n\n    // FIXME: Add documentation.\n    virtual void warnParamTypestateMismatch(SourceLocation LOC,\n                                            StringRef ExpectedState,\n                                            StringRef ObservedState) {}\n\n    // FIXME: This can be removed when the attr propagation fix for templated\n    //        classes lands.\n    /// Warn about return typestates set for unconsumable types.\n    ///\n    /// \\param Loc -- The location of the attributes.\n    ///\n    /// \\param TypeName -- The name of the unconsumable type.\n    virtual void warnReturnTypestateForUnconsumableType(SourceLocation Loc,\n                                                        StringRef TypeName) {}\n\n    /// Warn about return typestate mismatches.\n    ///\n    /// \\param Loc -- The SourceLocation of the return statement.\n    ///\n    /// \\param ExpectedState -- The state the return value was expected to be\n    /// in.\n    ///\n    /// \\param ObservedState -- The state the return value was observed to be\n    /// in.\n    virtual void warnReturnTypestateMismatch(SourceLocation Loc,\n                                             StringRef ExpectedState,\n                                             StringRef ObservedState) {}\n\n    /// Warn about use-while-consumed errors.\n    /// \\param MethodName -- The name of the method that was incorrectly\n    /// invoked.\n    ///\n    /// \\param State -- The state the object was used in.\n    ///\n    /// \\param Loc -- The SourceLocation of the method invocation.\n    virtual void warnUseOfTempInInvalidState(StringRef MethodName,\n                                             StringRef State,\n                                             SourceLocation Loc) {}\n\n    /// Warn about use-while-consumed errors.\n    /// \\param MethodName -- The name of the method that was incorrectly\n    /// invoked.\n    ///\n    /// \\param State -- The state the object was used in.\n    ///\n    /// \\param VariableName -- The name of the variable that holds the unique\n    /// value.\n    ///\n    /// \\param Loc -- The SourceLocation of the method invocation.\n    virtual void warnUseInInvalidState(StringRef MethodName,\n                                       StringRef VariableName,\n                                       StringRef State,\n                                       SourceLocation Loc) {}\n  };\n\n  class ConsumedStateMap {\n    using VarMapType = llvm::DenseMap<const VarDecl *, ConsumedState>;\n    using TmpMapType =\n        llvm::DenseMap<const CXXBindTemporaryExpr *, ConsumedState>;\n\n  protected:\n    bool Reachable = true;\n    const Stmt *From = nullptr;\n    VarMapType VarMap;\n    TmpMapType TmpMap;\n\n  public:\n    ConsumedStateMap() = default;\n    ConsumedStateMap(const ConsumedStateMap &Other)\n        : Reachable(Other.Reachable), From(Other.From), VarMap(Other.VarMap) {}\n\n    // The copy assignment operator is defined as deleted pending further\n    // motivation.\n    ConsumedStateMap &operator=(const ConsumedStateMap &) = delete;\n\n    /// Warn if any of the parameters being tracked are not in the state\n    /// they were declared to be in upon return from a function.\n    void checkParamsForReturnTypestate(SourceLocation BlameLoc,\n      ConsumedWarningsHandlerBase &WarningsHandler) const;\n\n    /// Clear the TmpMap.\n    void clearTemporaries();\n\n    /// Get the consumed state of a given variable.\n    ConsumedState getState(const VarDecl *Var) const;\n\n    /// Get the consumed state of a given temporary value.\n    ConsumedState getState(const CXXBindTemporaryExpr *Tmp) const;\n\n    /// Merge this state map with another map.\n    void intersect(const ConsumedStateMap &Other);\n\n    void intersectAtLoopHead(const CFGBlock *LoopHead, const CFGBlock *LoopBack,\n      const ConsumedStateMap *LoopBackStates,\n      ConsumedWarningsHandlerBase &WarningsHandler);\n\n    /// Return true if this block is reachable.\n    bool isReachable() const { return Reachable; }\n\n    /// Mark the block as unreachable.\n    void markUnreachable();\n\n    /// Set the source for a decision about the branching of states.\n    /// \\param Source -- The statement that was the origin of a branching\n    /// decision.\n    void setSource(const Stmt *Source) { this->From = Source; }\n\n    /// Set the consumed state of a given variable.\n    void setState(const VarDecl *Var, ConsumedState State);\n\n    /// Set the consumed state of a given temporary value.\n    void setState(const CXXBindTemporaryExpr *Tmp, ConsumedState State);\n\n    /// Remove the temporary value from our state map.\n    void remove(const CXXBindTemporaryExpr *Tmp);\n\n    /// Tests to see if there is a mismatch in the states stored in two\n    /// maps.\n    ///\n    /// \\param Other -- The second map to compare against.\n    bool operator!=(const ConsumedStateMap *Other) const;\n  };\n\n  class ConsumedBlockInfo {\n    std::vector<std::unique_ptr<ConsumedStateMap>> StateMapsArray;\n    std::vector<unsigned int> VisitOrder;\n\n  public:\n    ConsumedBlockInfo() = default;\n\n    ConsumedBlockInfo(unsigned int NumBlocks, PostOrderCFGView *SortedGraph)\n        : StateMapsArray(NumBlocks), VisitOrder(NumBlocks, 0) {\n      unsigned int VisitOrderCounter = 0;\n      for (const auto BI : *SortedGraph)\n        VisitOrder[BI->getBlockID()] = VisitOrderCounter++;\n    }\n\n    bool allBackEdgesVisited(const CFGBlock *CurrBlock,\n                             const CFGBlock *TargetBlock);\n\n    void addInfo(const CFGBlock *Block, ConsumedStateMap *StateMap,\n                 std::unique_ptr<ConsumedStateMap> &OwnedStateMap);\n    void addInfo(const CFGBlock *Block,\n                 std::unique_ptr<ConsumedStateMap> StateMap);\n\n    ConsumedStateMap* borrowInfo(const CFGBlock *Block);\n\n    void discardInfo(const CFGBlock *Block);\n\n    std::unique_ptr<ConsumedStateMap> getInfo(const CFGBlock *Block);\n\n    bool isBackEdge(const CFGBlock *From, const CFGBlock *To);\n    bool isBackEdgeTarget(const CFGBlock *Block);\n  };\n\n  /// A class that handles the analysis of uniqueness violations.\n  class ConsumedAnalyzer {\n    ConsumedBlockInfo BlockInfo;\n    std::unique_ptr<ConsumedStateMap> CurrStates;\n\n    ConsumedState ExpectedReturnState = CS_None;\n\n    void determineExpectedReturnState(AnalysisDeclContext &AC,\n                                      const FunctionDecl *D);\n    bool splitState(const CFGBlock *CurrBlock,\n                    const ConsumedStmtVisitor &Visitor);\n\n  public:\n    ConsumedWarningsHandlerBase &WarningsHandler;\n\n    ConsumedAnalyzer(ConsumedWarningsHandlerBase &WarningsHandler)\n        : WarningsHandler(WarningsHandler) {}\n\n    ConsumedState getExpectedReturnState() const { return ExpectedReturnState; }\n\n    /// Check a function's CFG for consumed violations.\n    ///\n    /// We traverse the blocks in the CFG, keeping track of the state of each\n    /// value who's type has uniqueness annotations.  If methods are invoked in\n    /// the wrong state a warning is issued.  Each block in the CFG is traversed\n    /// exactly once.\n    void run(AnalysisDeclContext &AC);\n  };\n\n}",
  "id": "BLOCK-CPP-21334",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/Consumed.h",
  "source_line": 39,
  "validation_status": "validated"
}