{
  "code": "{\nnamespace sinks {\n\n/*\n * Generator of Hourly log file names in format basename.YYYY-MM-DD-HH.ext\n */\nstruct hourly_filename_calculator {\n    // Create filename for the form basename.YYYY-MM-DD-H\n    static filename_t calc_filename(const filename_t &filename, const tm &now_tm) {\n        filename_t basename, ext;\n        std::tie(basename, ext) = details::file_helper::split_by_extension(filename);\n        return fmt_lib::format(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}_{:02d}{}\"), basename,\n                               now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday,\n                               now_tm.tm_hour, ext);\n    }\n};\n\n/*\n * Rotating file sink based on time.\n * If truncate != false , the created file will be truncated.\n * If max_files > 0, retain only the last max_files and delete previous.\n */\ntemplate <typename Mutex, typename FileNameCalc = hourly_filename_calculator>\nclass hourly_file_sink final : public base_sink<Mutex> {\npublic:\n    // create hourly file sink which rotates on given time\n    hourly_file_sink(filename_t base_filename,\n                     bool truncate = false,\n                     uint16_t max_files = 0,\n                     const file_event_handlers &event_handlers = {})\n        : base_filename_(std::move(base_filename)),\n          file_helper_{event_handlers},\n          truncate_(truncate),\n          max_files_(max_files),\n          filenames_q_() {\n        auto now = log_clock::now();\n        auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));\n        file_helper_.open(filename, truncate_);\n        remove_init_file_ = file_helper_.size() == 0;\n        rotation_tp_ = next_rotation_tp_();\n\n        if (max_files_ > 0) {\n            init_filenames_q_();\n        }\n    }\n\n    filename_t filename() {\n        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        return file_helper_.filename();\n    }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        auto time = msg.time;\n        bool should_rotate = time >= rotation_tp_;\n        if (should_rotate) {\n            if (remove_init_file_) {\n                file_helper_.close();\n                details::os::remove(file_helper_.filename());\n            }\n            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(time));\n            file_helper_.open(filename, truncate_);\n            rotation_tp_ = next_rotation_tp_();\n        }\n        remove_init_file_ = false;\n        memory_buf_t formatted;\n        base_sink<Mutex>::formatter_->format(msg, formatted);\n        file_helper_.write(formatted);\n\n        // Do the cleaning only at the end because it might throw on failure.\n        if (should_rotate && max_files_ > 0) {\n            delete_old_();\n        }\n    }\n\n    void flush_() override { file_helper_.flush(); }\n\nprivate:\n    void init_filenames_q_() {\n        using details::os::path_exists;\n\n        filenames_q_ = details::circular_q<filename_t>(static_cast<size_t>(max_files_));\n        std::vector<filename_t> filenames;\n        auto now = log_clock::now();\n        while (filenames.size() < max_files_) {\n            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));\n            if (!path_exists(filename)) {\n                break;\n            }\n            filenames.emplace_back(filename);\n            now -= std::chrono::hours(1);\n        }\n        for (auto iter = filenames.rbegin(); iter != filenames.rend(); ++iter) {\n            filenames_q_.push_back(std::move(*iter));\n        }\n    }\n\n    tm now_tm(log_clock::time_point tp) {\n        time_t tnow = log_clock::to_time_t(tp);\n        return spdlog::details::os::localtime(tnow);\n    }\n\n    log_clock::time_point next_rotation_tp_() {\n        auto now = log_clock::now();\n        tm date = now_tm(now);\n        date.tm_min = 0;\n        date.tm_sec = 0;\n        auto rotation_time = log_clock::from_time_t(std::mktime(&date));\n        if (rotation_time > now) {\n            return rotation_time;\n        }\n        return {rotation_time + std::chrono::hours(1)};\n    }\n\n    // Delete the file N rotations ago.\n    // Throw spdlog_ex on failure to delete the old file.\n    void delete_old_() {\n        using details::os::filename_to_str;\n        using details::os::remove_if_exists;\n\n        filename_t current_file = file_helper_.filename();\n        if (filenames_q_.full()) {\n            auto old_filename = std::move(filenames_q_.front());\n            filenames_q_.pop_front();\n            bool ok = remove_if_exists(old_filename) == 0;\n            if (!ok) {\n                filenames_q_.push_back(std::move(current_file));\n                SPDLOG_THROW(spdlog_ex(\n                    \"Failed removing hourly file \" + filename_to_str(old_filename), errno));\n            }\n        }\n        filenames_q_.push_back(std::move(current_file));\n    }\n\n    filename_t base_filename_;\n    log_clock::time_point rotation_tp_;\n    details::file_helper file_helper_;\n    bool truncate_;\n    uint16_t max_files_;\n    details::circular_q<filename_t> filenames_q_;\n    bool remove_init_file_;\n};\n\nusing hourly_file_sink_mt = hourly_file_sink<std::mutex>;\nusing hourly_file_sink_st = hourly_file_sink<details::null_mutex>;\n\n}  // namespace sinks\n\n//\n// factory functions\n//\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> hourly_logger_mt(const std::string &logger_name,\n                                                const filename_t &filename,\n                                                bool truncate = false,\n                                                uint16_t max_files = 0,\n                                                const file_event_handlers &event_handlers = {}) {\n    return Factory::template create<sinks::hourly_file_sink_mt>(logger_name, filename, truncate,\n                                                                max_files, event_handlers);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> hourly_logger_st(const std::string &logger_name,\n                                                const filename_t &filename,\n                                                bool truncate = false,\n                                                uint16_t max_files = 0,\n                                                const file_event_handlers &event_handlers = {}) {\n    return Factory::template create<sinks::hourly_file_sink_st>(logger_name, filename, truncate,\n                                                                max_files, event_handlers);\n}\n}",
  "id": "BLOCK-CPP-00414",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/hourly_file_sink.h",
  "source_line": 21,
  "validation_status": "validated"
}