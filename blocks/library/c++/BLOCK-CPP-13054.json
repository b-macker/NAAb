{
  "code": "{\n\n/// Represents Objective-C's collection statement.\n///\n/// This is represented as 'for (element 'in' collection-expression)' stmt.\nclass ObjCForCollectionStmt : public Stmt {\n  enum { ELEM, COLLECTION, BODY, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // SubExprs[ELEM] is an expression or declstmt.\n  SourceLocation ForLoc;\n  SourceLocation RParenLoc;\npublic:\n  ObjCForCollectionStmt(Stmt *Elem, Expr *Collect, Stmt *Body,\n                        SourceLocation FCL, SourceLocation RPL);\n  explicit ObjCForCollectionStmt(EmptyShell Empty) :\n    Stmt(ObjCForCollectionStmtClass, Empty) { }\n\n  Stmt *getElement() { return SubExprs[ELEM]; }\n  Expr *getCollection() {\n    return reinterpret_cast<Expr*>(SubExprs[COLLECTION]);\n  }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const Stmt *getElement() const { return SubExprs[ELEM]; }\n  const Expr *getCollection() const {\n    return reinterpret_cast<Expr*>(SubExprs[COLLECTION]);\n  }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setElement(Stmt *S) { SubExprs[ELEM] = S; }\n  void setCollection(Expr *E) {\n    SubExprs[COLLECTION] = reinterpret_cast<Stmt*>(E);\n  }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForLoc; }\n  void setForLoc(SourceLocation Loc) { ForLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return ForLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExprs[BODY]->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCForCollectionStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[END_EXPR]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[END_EXPR]);\n  }\n};\n\n/// Represents Objective-C's \\@catch statement.\nclass ObjCAtCatchStmt : public Stmt {\nprivate:\n  VarDecl *ExceptionDecl;\n  Stmt *Body;\n  SourceLocation AtCatchLoc, RParenLoc;\n\npublic:\n  ObjCAtCatchStmt(SourceLocation atCatchLoc, SourceLocation rparenloc,\n                  VarDecl *catchVarDecl,\n                  Stmt *atCatchStmt)\n    : Stmt(ObjCAtCatchStmtClass), ExceptionDecl(catchVarDecl),\n    Body(atCatchStmt), AtCatchLoc(atCatchLoc), RParenLoc(rparenloc) { }\n\n  explicit ObjCAtCatchStmt(EmptyShell Empty) :\n    Stmt(ObjCAtCatchStmtClass, Empty) { }\n\n  const Stmt *getCatchBody() const { return Body; }\n  Stmt *getCatchBody() { return Body; }\n  void setCatchBody(Stmt *S) { Body = S; }\n\n  const VarDecl *getCatchParamDecl() const {\n    return ExceptionDecl;\n  }\n  VarDecl *getCatchParamDecl() {\n    return ExceptionDecl;\n  }\n  void setCatchParamDecl(VarDecl *D) { ExceptionDecl = D; }\n\n  SourceLocation getAtCatchLoc() const { return AtCatchLoc; }\n  void setAtCatchLoc(SourceLocation Loc) { AtCatchLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtCatchLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Body->getEndLoc(); }\n\n  bool hasEllipsis() const { return getCatchParamDecl() == nullptr; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtCatchStmtClass;\n  }\n\n  child_range children() { return child_range(&Body, &Body + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Body, &Body + 1);\n  }\n};\n\n/// Represents Objective-C's \\@finally statement\nclass ObjCAtFinallyStmt : public Stmt {\n  SourceLocation AtFinallyLoc;\n  Stmt *AtFinallyStmt;\n\npublic:\n  ObjCAtFinallyStmt(SourceLocation atFinallyLoc, Stmt *atFinallyStmt)\n      : Stmt(ObjCAtFinallyStmtClass), AtFinallyLoc(atFinallyLoc),\n        AtFinallyStmt(atFinallyStmt) {}\n\n  explicit ObjCAtFinallyStmt(EmptyShell Empty) :\n    Stmt(ObjCAtFinallyStmtClass, Empty) { }\n\n  const Stmt *getFinallyBody() const { return AtFinallyStmt; }\n  Stmt *getFinallyBody() { return AtFinallyStmt; }\n  void setFinallyBody(Stmt *S) { AtFinallyStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtFinallyLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return AtFinallyStmt->getEndLoc();\n  }\n\n  SourceLocation getAtFinallyLoc() const { return AtFinallyLoc; }\n  void setAtFinallyLoc(SourceLocation Loc) { AtFinallyLoc = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtFinallyStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&AtFinallyStmt, &AtFinallyStmt+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&AtFinallyStmt, &AtFinallyStmt + 1);\n  }\n};\n\n/// Represents Objective-C's \\@try ... \\@catch ... \\@finally statement.\nclass ObjCAtTryStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<ObjCAtTryStmt, Stmt *> {\n  friend TrailingObjects;\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const {\n    return 1 + NumCatchStmts + HasFinally;\n  }\n\n  // The location of the @ in the \\@try.\n  SourceLocation AtTryLoc;\n\n  // The number of catch blocks in this statement.\n  unsigned NumCatchStmts : 16;\n\n  // Whether this statement has a \\@finally statement.\n  bool HasFinally : 1;\n\n  /// Retrieve the statements that are stored after this \\@try statement.\n  ///\n  /// The order of the statements in memory follows the order in the source,\n  /// with the \\@try body first, followed by the \\@catch statements (if any)\n  /// and, finally, the \\@finally (if it exists).\n  Stmt **getStmts() { return getTrailingObjects<Stmt *>(); }\n  Stmt *const *getStmts() const { return getTrailingObjects<Stmt *>(); }\n\n  ObjCAtTryStmt(SourceLocation atTryLoc, Stmt *atTryStmt,\n                Stmt **CatchStmts, unsigned NumCatchStmts,\n                Stmt *atFinallyStmt);\n\n  explicit ObjCAtTryStmt(EmptyShell Empty, unsigned NumCatchStmts,\n                         bool HasFinally)\n    : Stmt(ObjCAtTryStmtClass, Empty), NumCatchStmts(NumCatchStmts),\n      HasFinally(HasFinally) { }\n\npublic:\n  static ObjCAtTryStmt *Create(const ASTContext &Context,\n                               SourceLocation atTryLoc, Stmt *atTryStmt,\n                               Stmt **CatchStmts, unsigned NumCatchStmts,\n                               Stmt *atFinallyStmt);\n  static ObjCAtTryStmt *CreateEmpty(const ASTContext &Context,\n                                    unsigned NumCatchStmts, bool HasFinally);\n\n  /// Retrieve the location of the @ in the \\@try.\n  SourceLocation getAtTryLoc() const { return AtTryLoc; }\n  void setAtTryLoc(SourceLocation Loc) { AtTryLoc = Loc; }\n\n  /// Retrieve the \\@try body.\n  const Stmt *getTryBody() const { return getStmts()[0]; }\n  Stmt *getTryBody() { return getStmts()[0]; }\n  void setTryBody(Stmt *S) { getStmts()[0] = S; }\n\n  /// Retrieve the number of \\@catch statements in this try-catch-finally\n  /// block.\n  unsigned getNumCatchStmts() const { return NumCatchStmts; }\n\n  /// Retrieve a \\@catch statement.\n  const ObjCAtCatchStmt *getCatchStmt(unsigned I) const {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    return cast_or_null<ObjCAtCatchStmt>(getStmts()[I + 1]);\n  }\n\n  /// Retrieve a \\@catch statement.\n  ObjCAtCatchStmt *getCatchStmt(unsigned I) {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    return cast_or_null<ObjCAtCatchStmt>(getStmts()[I + 1]);\n  }\n\n  /// Set a particular catch statement.\n  void setCatchStmt(unsigned I, ObjCAtCatchStmt *S) {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    getStmts()[I + 1] = S;\n  }\n\n  /// Retrieve the \\@finally statement, if any.\n  const ObjCAtFinallyStmt *getFinallyStmt() const {\n    if (!HasFinally)\n      return nullptr;\n\n    return cast_or_null<ObjCAtFinallyStmt>(getStmts()[1 + NumCatchStmts]);\n  }\n  ObjCAtFinallyStmt *getFinallyStmt() {\n    if (!HasFinally)\n      return nullptr;\n\n    return cast_or_null<ObjCAtFinallyStmt>(getStmts()[1 + NumCatchStmts]);\n  }\n  void setFinallyStmt(Stmt *S) {\n    assert(HasFinally && \"@try does not have a @finally slot!\");\n    getStmts()[1 + NumCatchStmts] = S;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtTryLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtTryStmtClass;\n  }\n\n  child_range children() {\n    return child_range(\n        getStmts(), getStmts() + numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_cast<ObjCAtTryStmt *>(this)->children());\n  }\n\n  using catch_stmt_iterator = CastIterator<ObjCAtCatchStmt>;\n  using const_catch_stmt_iterator = ConstCastIterator<ObjCAtCatchStmt>;\n  using catch_range = llvm::iterator_range<catch_stmt_iterator>;\n  using catch_const_range = llvm::iterator_range<const_catch_stmt_iterator>;\n\n  catch_stmt_iterator catch_stmts_begin() { return getStmts() + 1; }\n  catch_stmt_iterator catch_stmts_end() {\n    return catch_stmts_begin() + NumCatchStmts;\n  }\n  catch_range catch_stmts() {\n    return catch_range(catch_stmts_begin(), catch_stmts_end());\n  }\n\n  const_catch_stmt_iterator catch_stmts_begin() const { return getStmts() + 1; }\n  const_catch_stmt_iterator catch_stmts_end() const {\n    return catch_stmts_begin() + NumCatchStmts;\n  }\n  catch_const_range catch_stmts() const {\n    return catch_const_range(catch_stmts_begin(), catch_stmts_end());\n  }\n};\n\n/// Represents Objective-C's \\@synchronized statement.\n///\n/// Example:\n/// \\code\n///   @synchronized (sem) {\n///     do-something;\n///   }\n/// \\endcode\nclass ObjCAtSynchronizedStmt : public Stmt {\nprivate:\n  SourceLocation AtSynchronizedLoc;\n  enum { SYNC_EXPR, SYNC_BODY, END_EXPR };\n  Stmt* SubStmts[END_EXPR];\n\npublic:\n  ObjCAtSynchronizedStmt(SourceLocation atSynchronizedLoc, Stmt *synchExpr,\n                         Stmt *synchBody)\n  : Stmt(ObjCAtSynchronizedStmtClass) {\n    SubStmts[SYNC_EXPR] = synchExpr;\n    SubStmts[SYNC_BODY] = synchBody;\n    AtSynchronizedLoc = atSynchronizedLoc;\n  }\n  explicit ObjCAtSynchronizedStmt(EmptyShell Empty) :\n    Stmt(ObjCAtSynchronizedStmtClass, Empty) { }\n\n  SourceLocation getAtSynchronizedLoc() const { return AtSynchronizedLoc; }\n  void setAtSynchronizedLoc(SourceLocation Loc) { AtSynchronizedLoc = Loc; }\n\n  const CompoundStmt *getSynchBody() const {\n    return reinterpret_cast<CompoundStmt*>(SubStmts[SYNC_BODY]);\n  }\n  CompoundStmt *getSynchBody() {\n    return reinterpret_cast<CompoundStmt*>(SubStmts[SYNC_BODY]);\n  }\n  void setSynchBody(Stmt *S) { SubStmts[SYNC_BODY] = S; }\n\n  const Expr *getSynchExpr() const {\n    return reinterpret_cast<Expr*>(SubStmts[SYNC_EXPR]);\n  }\n  Expr *getSynchExpr() {\n    return reinterpret_cast<Expr*>(SubStmts[SYNC_EXPR]);\n  }\n  void setSynchExpr(Stmt *S) { SubStmts[SYNC_EXPR] = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtSynchronizedLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSynchBody()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtSynchronizedStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0]+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + END_EXPR);\n  }\n};\n\n/// Represents Objective-C's \\@throw statement.\nclass ObjCAtThrowStmt : public Stmt {\n  SourceLocation AtThrowLoc;\n  Stmt *Throw;\n\npublic:\n  ObjCAtThrowStmt(SourceLocation atThrowLoc, Stmt *throwExpr)\n  : Stmt(ObjCAtThrowStmtClass), Throw(throwExpr) {\n    AtThrowLoc = atThrowLoc;\n  }\n  explicit ObjCAtThrowStmt(EmptyShell Empty) :\n    Stmt(ObjCAtThrowStmtClass, Empty) { }\n\n  const Expr *getThrowExpr() const { return reinterpret_cast<Expr*>(Throw); }\n  Expr *getThrowExpr() { return reinterpret_cast<Expr*>(Throw); }\n  void setThrowExpr(Stmt *S) { Throw = S; }\n\n  SourceLocation getThrowLoc() const LLVM_READONLY { return AtThrowLoc; }\n  void setThrowLoc(SourceLocation Loc) { AtThrowLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtThrowLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Throw ? Throw->getEndLoc() : AtThrowLoc;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtThrowStmtClass;\n  }\n\n  child_range children() { return child_range(&Throw, &Throw+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Throw, &Throw + 1);\n  }\n};\n\n/// Represents Objective-C's \\@autoreleasepool Statement\nclass ObjCAutoreleasePoolStmt : public Stmt {\n  SourceLocation AtLoc;\n  Stmt *SubStmt;\n\npublic:\n  ObjCAutoreleasePoolStmt(SourceLocation atLoc, Stmt *subStmt)\n      : Stmt(ObjCAutoreleasePoolStmtClass), AtLoc(atLoc), SubStmt(subStmt) {}\n\n  explicit ObjCAutoreleasePoolStmt(EmptyShell Empty) :\n    Stmt(ObjCAutoreleasePoolStmtClass, Empty) { }\n\n  const Stmt *getSubStmt() const { return SubStmt; }\n  Stmt *getSubStmt() { return SubStmt; }\n  void setSubStmt(Stmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAutoreleasePoolStmtClass;\n  }\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-13054",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtObjC.h",
  "source_line": 18,
  "validation_status": "validated"
}