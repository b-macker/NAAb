{
  "code": "#include \"clang/AST/ASTTypeTraits.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include <set>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21198_execute() {\n    {\n\nclass Stmt;\nclass Decl;\nclass CXXCtorInitializer;\nclass NestedNameSpecifierLoc;\nclass TemplateArgumentLoc;\nclass CXXBaseSpecifier;\nstruct DeclarationNameInfo;\n\nnamespace tooling {\n\nclass LocationCall;\nusing SharedLocationCall = llvm::IntrusiveRefCntPtr<LocationCall>;\n\nclass LocationCall : public llvm::ThreadSafeRefCountedBase<LocationCall> {\npublic:\n  enum LocationCallFlags { NoFlags, ReturnsPointer, IsCast };\n  LocationCall(SharedLocationCall on, std::string name,\n               LocationCallFlags flags = NoFlags)\n      : m_flags(flags), m_on(std::move(on)), m_name(std::move(name)) {}\n\n  LocationCall *on() const { return m_on.get(); }\n  StringRef name() const { return m_name; }\n  bool returnsPointer() const { return m_flags & ReturnsPointer; }\n  bool isCast() const { return m_flags & IsCast; }\n\nprivate:\n  LocationCallFlags m_flags;\n  SharedLocationCall m_on;\n  std::string m_name;\n};\n\nclass LocationCallFormatterCpp {\npublic:\n  static void print(const LocationCall &Call, llvm::raw_ostream &OS);\n  static std::string format(const LocationCall &Call);\n};\n\nnamespace internal {\nstruct RangeLessThan {\n  bool operator()(std::pair<SourceRange, SharedLocationCall> const &LHS,\n                  std::pair<SourceRange, SharedLocationCall> const &RHS) const;\n  bool\n  operator()(std::pair<SourceLocation, SharedLocationCall> const &LHS,\n             std::pair<SourceLocation, SharedLocationCall> const &RHS) const;\n};\n\n} // namespace internal\n\n// Note that this container stores unique results in a deterministic, but\n// the location calls are in an unspecified order.  Clients which desire\n// a particular order for the location calls, such as alphabetical,\n// should sort results after retrieval, because the order is dependent\n// on how the LocationCalls are formatted.\ntemplate <typename T, typename U>\nusing UniqueMultiMap = std::set<std::pair<T, U>, internal::RangeLessThan>;\n\nusing SourceLocationMap = UniqueMultiMap<SourceLocation, SharedLocationCall>;\nusing SourceRangeMap = UniqueMultiMap<SourceRange, SharedLocationCall>;\n\nstruct NodeLocationAccessors {\n  SourceLocationMap LocationAccessors;\n  SourceRangeMap RangeAccessors;\n};\n\nnamespace NodeIntrospection {\nbool hasIntrospectionSupport();\nNodeLocationAccessors GetLocations(clang::Stmt const *Object);\nNodeLocationAccessors GetLocations(clang::Decl const *Object);\nNodeLocationAccessors GetLocations(clang::CXXCtorInitializer const *Object);\nNodeLocationAccessors GetLocations(clang::NestedNameSpecifierLoc const &);\nNodeLocationAccessors GetLocations(clang::TemplateArgumentLoc const &);\nNodeLocationAccessors GetLocations(clang::CXXBaseSpecifier const *);\nNodeLocationAccessors GetLocations(clang::TypeLoc const &);\nNodeLocationAccessors GetLocations(clang::DeclarationNameInfo const &);\nNodeLocationAccessors GetLocations(clang::DynTypedNode const &Node);\n} // namespace NodeIntrospection\n} // namespace tooling\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21198",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/NodeIntrospection.h",
  "source_line": 21,
  "validation_status": "validated"
}