{
  "code": "{\n  // There are three categories of capture: capturing 'this', capturing\n  // local variables, and C++1y initialized captures (which can have an\n  // arbitrary initializer, and don't really capture in the traditional\n  // sense at all).\n  //\n  // There are three ways to capture a local variable:\n  //  - capture by copy in the C++11 sense,\n  //  - capture by reference in the C++11 sense, and\n  //  - __block capture.\n  // Lambdas explicitly specify capture by copy or capture by reference.\n  // For blocks, __block capture applies to variables with that annotation,\n  // variables of reference type are captured by reference, and other\n  // variables are captured by copy.\n  enum CaptureKind {\n    Cap_ByCopy, Cap_ByRef, Cap_Block, Cap_VLA\n  };\n\n  union {\n    /// If Kind == Cap_VLA, the captured type.\n    const VariableArrayType *CapturedVLA;\n\n    /// Otherwise, the captured variable (if any).\n    ValueDecl *CapturedVar;\n  };\n\n  /// The source location at which the first capture occurred.\n  SourceLocation Loc;\n\n  /// The location of the ellipsis that expands a parameter pack.\n  SourceLocation EllipsisLoc;\n\n  /// The type as it was captured, which is the type of the non-static data\n  /// member that would hold the capture.\n  QualType CaptureType;\n\n  /// The CaptureKind of this capture.\n  unsigned Kind : 2;\n\n  /// Whether this is a nested capture (a capture of an enclosing capturing\n  /// scope's capture).\n  unsigned Nested : 1;\n\n  /// Whether this is a capture of '*this'.\n  unsigned CapturesThis : 1;\n\n  /// Whether an explicit capture has been odr-used in the body of the\n  /// lambda.\n  unsigned ODRUsed : 1;\n\n  /// Whether an explicit capture has been non-odr-used in the body of\n  /// the lambda.\n  unsigned NonODRUsed : 1;\n\n  /// Whether the capture is invalid (a capture was required but the entity is\n  /// non-capturable).\n  unsigned Invalid : 1;\n\npublic:\n  Capture(ValueDecl *Var, bool Block, bool ByRef, bool IsNested,\n          SourceLocation Loc, SourceLocation EllipsisLoc, QualType CaptureType,\n          bool Invalid)\n      : CapturedVar(Var), Loc(Loc), EllipsisLoc(EllipsisLoc),\n        CaptureType(CaptureType), Kind(Block   ? Cap_Block\n                                       : ByRef ? Cap_ByRef\n                                               : Cap_ByCopy),\n        Nested(IsNested), CapturesThis(false), ODRUsed(false),\n        NonODRUsed(false), Invalid(Invalid) {}\n\n  enum IsThisCapture { ThisCapture };\n  Capture(IsThisCapture, bool IsNested, SourceLocation Loc,\n          QualType CaptureType, const bool ByCopy, bool Invalid)\n      : Loc(Loc), CaptureType(CaptureType),\n        Kind(ByCopy ? Cap_ByCopy : Cap_ByRef), Nested(IsNested),\n        CapturesThis(true), ODRUsed(false), NonODRUsed(false),\n        Invalid(Invalid) {}\n\n  enum IsVLACapture { VLACapture };\n  Capture(IsVLACapture, const VariableArrayType *VLA, bool IsNested,\n          SourceLocation Loc, QualType CaptureType)\n      : CapturedVLA(VLA), Loc(Loc), CaptureType(CaptureType), Kind(Cap_VLA),\n        Nested(IsNested), CapturesThis(false), ODRUsed(false),\n        NonODRUsed(false), Invalid(false) {}\n\n  bool isThisCapture() const { return CapturesThis; }\n  bool isVariableCapture() const {\n    return !isThisCapture() && !isVLATypeCapture();\n  }\n\n  bool isCopyCapture() const { return Kind == Cap_ByCopy; }\n  bool isReferenceCapture() const { return Kind == Cap_ByRef; }\n  bool isBlockCapture() const { return Kind == Cap_Block; }\n  bool isVLATypeCapture() const { return Kind == Cap_VLA; }\n\n  bool isNested() const { return Nested; }\n\n  bool isInvalid() const { return Invalid; }\n\n  /// Determine whether this capture is an init-capture.\n  bool isInitCapture() const;\n\n  bool isODRUsed() const { return ODRUsed; }\n  bool isNonODRUsed() const { return NonODRUsed; }\n  void markUsed(bool IsODRUse) {\n    if (IsODRUse)\n      ODRUsed = true;\n    else\n      NonODRUsed = true;\n  }\n\n  ValueDecl *getVariable() const {\n    assert(isVariableCapture());\n    return CapturedVar;\n  }\n\n  const VariableArrayType *getCapturedVLAType() const {\n    assert(isVLATypeCapture());\n    return CapturedVLA;\n  }\n\n  /// Retrieve the location at which this variable was captured.\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Retrieve the source location of the ellipsis, whose presence\n  /// indicates that the capture is a pack expansion.\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// Retrieve the capture type for this capture, which is effectively\n  /// the type of the non-static data member in the lambda/block structure\n  /// that would store this capture.\n  QualType getCaptureType() const { return CaptureType; }\n}",
  "id": "BLOCK-CPP-20303",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ScopeInfo.h",
  "source_line": 540,
  "validation_status": "validated"
}