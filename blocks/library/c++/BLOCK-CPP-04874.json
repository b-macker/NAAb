{
  "code": "{\n//    public:\n//     using absl_btree_prefer_linear_node_search = std::true_type;\n//     ...\n//    private:\n//     friend bool operator<(K a, K b) { return a.k_ < b.k_; }\n//     int k_;\n//   };\n//\n//   btree_map<K, V> m;  // Uses linear search\n//\n// If T has the preference tag, then it has a preference.\n// Btree will use the tag's truth value.\ntemplate <typename T, typename = void>\nstruct has_linear_node_search_preference : std::false_type {};\ntemplate <typename T, typename = void>\nstruct prefers_linear_node_search : std::false_type {};\ntemplate <typename T>\nstruct has_linear_node_search_preference<\n    T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>\n    : std::true_type {};\ntemplate <typename T>\nstruct prefers_linear_node_search<\n    T, absl::void_t<typename T::absl_btree_prefer_linear_node_search>>\n    : T::absl_btree_prefer_linear_node_search {};\n\ntemplate <typename Compare, typename Key>\nconstexpr bool compare_has_valid_result_type() {\n  using compare_result_type = compare_result_t<Compare, Key, Key>;\n  return std::is_same<compare_result_type, bool>::value ||\n         std::is_convertible<compare_result_type, absl::weak_ordering>::value;\n}\n\ntemplate <typename original_key_compare, typename value_type>\nclass map_value_compare {\n  template <typename Params>\n  friend class btree;\n\n  // Note: this `protected` is part of the API of std::map::value_compare. See\n  // https://en.cppreference.com/w/cpp/container/map/value_compare.\n protected:\n  explicit map_value_compare(original_key_compare c) : comp(std::move(c)) {}\n\n  original_key_compare comp;  // NOLINT\n\n public:\n  auto operator()(const value_type &lhs, const value_type &rhs) const\n      -> decltype(comp(lhs.first, rhs.first)) {\n    return comp(lhs.first, rhs.first);\n  }\n};\n\ntemplate <typename Key, typename Compare, typename Alloc, int TargetNodeSize,\n          bool IsMulti, bool IsMap, typename SlotPolicy>\nstruct common_params : common_policy_traits<SlotPolicy> {\n  using original_key_compare = Compare;\n\n  // If Compare is a common comparator for a string-like type, then we adapt it\n  // to use heterogeneous lookup and to be a key-compare-to comparator.\n  // We also adapt the comparator to diagnose invalid comparators in debug mode.\n  // We disable this when `Compare` is invalid in a way that will cause\n  // adaptation to fail (having invalid return type) so that we can give a\n  // better compilation failure in static_assert_validation. If we don't do\n  // this, then there will be cascading compilation failures that are confusing\n  // for users.\n  using key_compare =\n      absl::conditional_t<!compare_has_valid_result_type<Compare, Key>(),\n                          Compare,\n                          typename key_compare_adapter<Compare, Key>::type>;\n\n  static constexpr bool kIsKeyCompareStringAdapted =\n      std::is_same<key_compare, StringBtreeDefaultLess>::value ||\n      std::is_same<key_compare, StringBtreeDefaultGreater>::value;\n  static constexpr bool kIsKeyCompareTransparent =\n      IsTransparent<original_key_compare>::value || kIsKeyCompareStringAdapted;\n\n  // A type which indicates if we have a key-compare-to functor or a plain old\n  // key-compare functor.\n  using is_key_compare_to = btree_is_key_compare_to<key_compare, Key>;\n\n  using allocator_type = Alloc;\n  using key_type = Key;\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n\n  using slot_policy = SlotPolicy;\n  using slot_type = typename slot_policy::slot_type;\n  using value_type = typename slot_policy::value_type;\n  using init_type = typename slot_policy::mutable_value_type;\n  using pointer = value_type *;\n  using const_pointer = const value_type *;\n  using reference = value_type &;\n  using const_reference = const value_type &;\n\n  using value_compare =\n      absl::conditional_t<IsMap,\n                          map_value_compare<original_key_compare, value_type>,\n                          original_key_compare>;\n  using is_map_container = std::integral_constant<bool, IsMap>;\n\n  // For the given lookup key type, returns whether we can have multiple\n  // equivalent keys in the btree. If this is a multi-container, then we can.\n  // Otherwise, we can have multiple equivalent keys only if all of the\n  // following conditions are met:\n  // - The comparator is transparent.\n  // - The lookup key type is not the same as key_type.\n  // - The comparator is not a StringBtreeDefault{Less,Greater} comparator\n  //   that we know has the same equivalence classes for all lookup types.\n  template <typename LookupKey>\n  constexpr static bool can_have_multiple_equivalent_keys() {\n    return IsMulti || (IsTransparent<key_compare>::value &&\n                       !std::is_same<LookupKey, Key>::value &&\n                       !kIsKeyCompareStringAdapted);\n  }\n\n  enum {\n    kTargetNodeSize = TargetNodeSize,\n\n    // Upper bound for the available space for slots. This is largest for leaf\n    // nodes, which have overhead of at least a pointer + 4 bytes (for storing\n    // 3 field_types and an enum).\n    kNodeSlotSpace = TargetNodeSize - /*minimum overhead=*/(sizeof(void *) + 4),\n  };\n\n  // This is an integral type large enough to hold as many slots as will fit a\n  // node of TargetNodeSize bytes.\n  using node_count_type =\n      absl::conditional_t<(kNodeSlotSpace / sizeof(slot_type) >\n                           (std::numeric_limits<uint8_t>::max)()),\n                          uint16_t, uint8_t>;  // NOLINT\n};\n\n// An adapter class that converts a lower-bound compare into an upper-bound\n// compare. Note: there is no need to make a version of this adapter specialized\n// for key-compare-to functors because the upper-bound (the first value greater\n// than the input) is never an exact match.\ntemplate <typename Compare>\nstruct upper_bound_adapter {\n  explicit upper_bound_adapter(const Compare &c) : comp(c) {}\n  template <typename K1, typename K2>\n  bool operator()(const K1 &a, const K2 &b) const {\n    // Returns true when a is not greater than b.\n    return !compare_internal::compare_result_as_less_than(comp(b, a));\n  }\n\n private:\n  Compare comp;\n};\n\nenum class MatchKind : uint8_t { kEq, kNe };\n\ntemplate <typename V, bool IsCompareTo>\nstruct SearchResult {\n  V value;\n  MatchKind match;\n\n  static constexpr bool HasMatch() { return true; }\n  bool IsEq() const { return match == MatchKind::kEq; }\n};\n\n// When we don't use CompareTo, `match` is not present.\n// This ensures that callers can't use it accidentally when it provides no\n// useful information.\ntemplate <typename V>\nstruct SearchResult<V, false> {\n  SearchResult() {}\n  explicit SearchResult(V v) : value(v) {}\n  SearchResult(V v, MatchKind /*match*/) : value(v) {}\n\n  V value;\n\n  static constexpr bool HasMatch() { return false; }\n  static constexpr bool IsEq() { return false; }\n};\n\n// A node in the btree holding. The same node type is used for both internal\n// and leaf nodes in the btree, though the nodes are allocated in such a way\n// that the children array is only valid in internal nodes.\ntemplate <typename Params>\nclass btree_node {\n  using is_key_compare_to = typename Params::is_key_compare_to;\n  using field_type = typename Params::node_count_type;\n  using allocator_type = typename Params::allocator_type;\n  using slot_type = typename Params::slot_type;\n  using original_key_compare = typename Params::original_key_compare;\n\n public:\n  using params_type = Params;\n  using key_type = typename Params::key_type;\n  using value_type = typename Params::value_type;\n  using pointer = typename Params::pointer;\n  using const_pointer = typename Params::const_pointer;\n  using reference = typename Params::reference;\n  using const_reference = typename Params::const_reference;\n  using key_compare = typename Params::key_compare;\n  using size_type = typename Params::size_type;\n  using difference_type = typename Params::difference_type;\n\n  // Btree decides whether to use linear node search as follows:\n  //   - If the comparator expresses a preference, use that.\n  //   - If the key expresses a preference, use that.\n  //   - If the key is arithmetic and the comparator is std::less or\n  //     std::greater, choose linear.\n  //   - Otherwise, choose binary.\n  // TODO(ezb): Might make sense to add condition(s) based on node-size.\n  using use_linear_search = std::integral_constant<\n      bool, has_linear_node_search_preference<original_key_compare>::value\n                ? prefers_linear_node_search<original_key_compare>::value\n            : has_linear_node_search_preference<key_type>::value\n                ? prefers_linear_node_search<key_type>::value\n                : std::is_arithmetic<key_type>::value &&\n                      (std::is_same<std::less<key_type>,\n                                    original_key_compare>::value ||\n                       std::is_same<std::greater<key_type>,\n                                    original_key_compare>::value)>;\n\n  // This class is organized by absl::container_internal::Layout as if it had\n  // the following structure:\n  //   // A pointer to the node's parent.\n  //   btree_node *parent;\n  //\n  //   // When ABSL_BTREE_ENABLE_GENERATIONS is defined, we also have a\n  //   // generation integer in order to check that when iterators are\n  //   // used, they haven't been invalidated already. Only the generation on\n  //   // the root is used, but we have one on each node because whether a node\n  //   // is root or not can change.\n  //   uint32_t generation;\n  //\n  //   // The position of the node in the node's parent.\n  //   field_type position;\n  //   // The index of the first populated value in `values`.\n  //   // TODO(ezb): right now, `start` is always 0. Update insertion/merge\n  //   // logic to allow for floating storage within nodes.\n  //   field_type start;\n  //   // The index after the last populated value in `values`. Currently, this\n  //   // is the same as the count of values.\n  //   field_type finish;\n  //   // The maximum number of values the node can hold. This is an integer in\n  //   // [1, kNodeSlots] for root leaf nodes, kNodeSlots for non-root leaf\n  //   // nodes, and kInternalNodeMaxCount (as a sentinel value) for internal\n  //   // nodes (even though there are still kNodeSlots values in the node).\n  //   // TODO(ezb): make max_count use only 4 bits and record log2(capacity)\n  //   // to free extra bits for is_root, etc.\n  //   field_type max_count;\n  //\n  //   // The array of values. The capacity is `max_count` for leaf nodes and\n  //   // kNodeSlots for internal nodes. Only the values in\n  //   // [start, finish) have been initialized and are valid.\n  //   slot_type values[max_count];\n  //\n  //   // The array of child pointers. The keys in children[i] are all less\n  //   // than key(i). The keys in children[i + 1] are all greater than key(i).\n  //   // There are 0 children for leaf nodes and kNodeSlots + 1 children for\n  //   // internal nodes.\n  //   btree_node *children[kNodeSlots + 1];\n  //\n  // This class is only constructed by EmptyNodeType. Normally, pointers to the\n  // layout above are allocated, cast to btree_node*, and de-allocated within\n  // the btree implementation.\n  ~btree_node() = default;\n  btree_node(btree_node const &) = delete;\n  btree_node &operator=(btree_node const &) = delete;\n\n protected:\n  btree_node() = default;\n\n private:\n  using layout_type =\n      absl::container_internal::Layout<btree_node *, uint32_t, field_type,\n                                       slot_type, btree_node *>;\n  constexpr static size_type SizeWithNSlots(size_type n) {\n    return layout_type(\n               /*parent*/ 1,\n               /*generation*/ BtreeGenerationsEnabled() ? 1 : 0,\n               /*position, start, finish, max_count*/ 4,\n               /*slots*/ n,\n               /*children*/ 0)\n        .AllocSize();\n  }\n  // A lower bound for the overhead of fields other than slots in a leaf node.\n  constexpr static size_type MinimumOverhead() {\n    return SizeWithNSlots(1) - sizeof(slot_type);\n  }\n\n  // Compute how many values we can fit onto a leaf node taking into account\n  // padding.\n  constexpr static size_type NodeTargetSlots(const size_type begin,\n                                             const size_type end) {\n    return begin == end ? begin\n           : SizeWithNSlots((begin + end) / 2 + 1) >\n                   params_type::kTargetNodeSize\n               ? NodeTargetSlots(begin, (begin + end) / 2)\n               : NodeTargetSlots((begin + end) / 2 + 1, end);\n  }\n\n  constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;\n  constexpr static size_type kNodeTargetSlots =\n      NodeTargetSlots(0, kTargetNodeSize);\n\n  // We need a minimum of 3 slots per internal node in order to perform\n  // splitting (1 value for the two nodes involved in the split and 1 value\n  // propagated to the parent as the delimiter for the split). For performance\n  // reasons, we don't allow 3 slots-per-node due to bad worst case occupancy of\n  // 1/3 (for a node, not a b-tree).\n  constexpr static size_type kMinNodeSlots = 4;\n\n  constexpr static size_type kNodeSlots =\n      kNodeTargetSlots >= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;\n\n  // The node is internal (i.e. is not a leaf node) if and only if `max_count`\n  // has this value.\n  constexpr static field_type kInternalNodeMaxCount = 0;\n\n  constexpr static layout_type Layout(const size_type slot_count,\n                                      const size_type child_count) {\n    return layout_type(\n        /*parent*/ 1,\n        /*generation*/ BtreeGenerationsEnabled() ? 1 : 0,\n        /*position, start, finish, max_count*/ 4,\n        /*slots*/ slot_count,\n        /*children*/ child_count);\n  }\n  // Leaves can have less than kNodeSlots values.\n  constexpr static layout_type LeafLayout(\n      const size_type slot_count = kNodeSlots) {\n    return Layout(slot_count, 0);\n  }\n  constexpr static layout_type InternalLayout() {\n    return Layout(kNodeSlots, kNodeSlots + 1);\n  }\n  constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {\n    return LeafLayout(slot_count).AllocSize();\n  }\n  constexpr static size_type InternalSize() {\n    return InternalLayout().AllocSize();\n  }\n\n  constexpr static size_type Alignment() {\n    static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),\n                  \"Alignment of all nodes must be equal.\");\n    return InternalLayout().Alignment();\n  }\n\n  // N is the index of the type in the Layout definition.\n  // ElementType<N> is the Nth type in the Layout definition.\n  template <size_type N>\n  inline typename layout_type::template ElementType<N> *GetField() {\n    // We assert that we don't read from values that aren't there.\n    assert(N < 4 || is_internal());\n    return InternalLayout().template Pointer<N>(reinterpret_cast<char *>(this));\n  }\n  template <size_type N>\n  inline const typename layout_type::template ElementType<N> *GetField() const {\n    assert(N < 4 || is_internal());\n    return InternalLayout().template Pointer<N>(\n        reinterpret_cast<const char *>(this));\n  }\n  void set_parent(btree_node *p) { *GetField<0>() = p; }\n  field_type &mutable_finish() { return GetField<2>()[2]; }\n  slot_type *slot(size_type i) { return &GetField<3>()[i]; }\n  slot_type *start_slot() { return slot(start()); }\n  slot_type *finish_slot() { return slot(finish()); }\n  const slot_type *slot(size_type i) const { return &GetField<3>()[i]; }\n  void set_position(field_type v) { GetField<2>()[0] = v; }\n  void set_start(field_type v) { GetField<2>()[1] = v; }\n  void set_finish(field_type v) { GetField<2>()[2] = v; }\n  // This method is only called by the node init methods.\n  void set_max_count(field_type v) { GetField<2>()[3] = v; }\n\n public:\n  // Whether this is a leaf node or not. This value doesn't change after the\n  // node is created.\n  bool is_leaf() const { return GetField<2>()[3] != kInternalNodeMaxCount; }\n  // Whether this is an internal node or not. This value doesn't change after\n  // the node is created.\n  bool is_internal() const { return !is_leaf(); }\n\n  // Getter for the position of this node in its parent.\n  field_type position() const { return GetField<2>()[0]; }\n\n  // Getter for the offset of the first value in the `values` array.\n  field_type start() const {\n    // TODO(ezb): when floating storage is implemented, return GetField<2>()[1];\n    assert(GetField<2>()[1] == 0);\n    return 0;\n  }\n\n  // Getter for the offset after the last value in the `values` array.\n  field_type finish() const { return GetField<2>()[2]; }\n\n  // Getters for the number of values stored in this node.\n  field_type count() const {\n    assert(finish() >= start());\n    return finish() - start();\n  }\n  field_type max_count() const {\n    // Internal nodes have max_count==kInternalNodeMaxCount.\n    // Leaf nodes have max_count in [1, kNodeSlots].\n    const field_type max_count = GetField<2>()[3];\n    return max_count == field_type{kInternalNodeMaxCount}\n               ? field_type{kNodeSlots}\n               : max_count;\n  }\n\n  // Getter for the parent of this node.\n  btree_node *parent() const { return *GetField<0>(); }\n  // Getter for whether the node is the root of the tree. The parent of the\n  // root of the tree is the leftmost node in the tree which is guaranteed to\n  // be a leaf.\n  bool is_root() const { return parent()->is_leaf(); }\n  void make_root() {\n    assert(parent()->is_root());\n    set_generation(parent()->generation());\n    set_parent(parent()->parent());\n  }\n\n  // Gets the root node's generation integer, which is the one used by the tree.\n  uint32_t *get_root_generation() const {\n    assert(BtreeGenerationsEnabled());\n    const btree_node *curr = this;\n    for (; !curr->is_root(); curr = curr->parent()) continue;\n    return const_cast<uint32_t *>(&curr->GetField<1>()[0]);\n  }\n\n  // Returns the generation for iterator validation.\n  uint32_t generation() const {\n    return BtreeGenerationsEnabled() ? *get_root_generation() : 0;\n  }\n  // Updates generation. Should only be called on a root node or during node\n  // initialization.\n  void set_generation(uint32_t generation) {\n    if (BtreeGenerationsEnabled()) GetField<1>()[0] = generation;\n  }\n  // Updates the generation. We do this whenever the node is mutated.\n  void next_generation() {\n    if (BtreeGenerationsEnabled()) ++*get_root_generation();\n  }\n\n  // Getters for the key/value at position i in the node.\n  const key_type &key(size_type i) const { return params_type::key(slot(i)); }\n  reference value(size_type i) { return params_type::element(slot(i)); }\n  const_reference value(size_type i) const {\n    return params_type::element(slot(i));\n  }\n\n  // Getters/setter for the child at position i in the node.\n  btree_node *child(field_type i) const { return GetField<4>()[i]; }\n  btree_node *start_child() const { return child(start()); }\n  btree_node *&mutable_child(field_type i) { return GetField<4>()[i]; }\n  void clear_child(field_type i) {\n    absl::container_internal::SanitizerPoisonObject(&mutable_child(i));\n  }\n  void set_child_noupdate_position(field_type i, btree_node *c) {\n    absl::container_internal::SanitizerUnpoisonObject(&mutable_child(i));\n    mutable_child(i) = c;\n  }\n  void set_child(field_type i, btree_node *c) {\n    set_child_noupdate_position(i, c);\n    c->set_position(i);\n  }\n  void init_child(field_type i, btree_node *c) {\n    set_child(i, c);\n    c->set_parent(this);\n  }\n\n  // Returns the position of the first value whose key is not less than k.\n  template <typename K>\n  SearchResult<size_type, is_key_compare_to::value> lower_bound(\n      const K &k, const key_compare &comp) const {\n    return use_linear_search::value ? linear_search(k, comp)\n                                    : binary_search(k, comp);\n  }\n  // Returns the position of the first value whose key is greater than k.\n  template <typename K>\n  size_type upper_bound(const K &k, const key_compare &comp) const {\n    auto upper_compare = upper_bound_adapter<key_compare>(comp);\n    return use_linear_search::value ? linear_search(k, upper_compare).value\n                                    : binary_search(k, upper_compare).value;\n  }\n\n  template <typename K, typename Compare>\n  SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>\n  linear_search(const K &k, const Compare &comp) const {\n    return linear_search_impl(k, start(), finish(), comp,\n                              btree_is_key_compare_to<Compare, key_type>());\n  }\n\n  template <typename K, typename Compare>\n  SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>\n  binary_search(const K &k, const Compare &comp) const {\n    return binary_search_impl(k, start(), finish(), comp,\n                              btree_is_key_compare_to<Compare, key_type>());\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // linear search performed using plain compare.\n  template <typename K, typename Compare>\n  SearchResult<size_type, false> linear_search_impl(\n      const K &k, size_type s, const size_type e, const Compare &comp,\n      std::false_type /* IsCompareTo */) const {\n    while (s < e) {\n      if (!comp(key(s), k)) {\n        break;\n      }\n      ++s;\n    }\n    return SearchResult<size_type, false>{s};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // linear search performed using compare-to.\n  template <typename K, typename Compare>\n  SearchResult<size_type, true> linear_search_impl(\n      const K &k, size_type s, const size_type e, const Compare &comp,\n      std::true_type /* IsCompareTo */) const {\n    while (s < e) {\n      const absl::weak_ordering c = comp(key(s), k);\n      if (c == 0) {\n        return {s, MatchKind::kEq};\n      } else if (c > 0) {\n        break;\n      }\n      ++s;\n    }\n    return {s, MatchKind::kNe};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // binary search performed using plain compare.\n  template <typename K, typename Compare>\n  SearchResult<size_type, false> binary_search_impl(\n      const K &k, size_type s, size_type e, const Compare &comp,\n      std::false_type /* IsCompareTo */) const {\n    while (s != e) {\n      const size_type mid = (s + e) >> 1;\n      if (comp(key(mid), k)) {\n        s = mid + 1;\n      } else {\n        e = mid;\n      }\n    }\n    return SearchResult<size_type, false>{s};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // binary search performed using compare-to.\n  template <typename K, typename CompareTo>\n  SearchResult<size_type, true> binary_search_impl(\n      const K &k, size_type s, size_type e, const CompareTo &comp,\n      std::true_type /* IsCompareTo */) const {\n    if (params_type::template can_have_multiple_equivalent_keys<K>()) {\n      MatchKind exact_match = MatchKind::kNe;\n      while (s != e) {\n        const size_type mid = (s + e) >> 1;\n        const absl::weak_ordering c = comp(key(mid), k);\n        if (c < 0) {\n          s = mid + 1;\n        } else {\n          e = mid;\n          if (c == 0) {\n            // Need to return the first value whose key is not less than k,\n            // which requires continuing the binary search if there could be\n            // multiple equivalent keys.\n            exact_match = MatchKind::kEq;\n          }\n        }\n      }\n      return {s, exact_match};\n    } else {  // Can't have multiple equivalent keys.\n      while (s != e) {\n        const size_type mid = (s + e) >> 1;\n        const absl::weak_ordering c = comp(key(mid), k);\n        if (c < 0) {\n          s = mid + 1;\n        } else if (c > 0) {\n          e = mid;\n        } else {\n          return {mid, MatchKind::kEq};\n        }\n      }\n      return {s, MatchKind::kNe};\n    }\n  }\n\n  // Returns whether key i is ordered correctly with respect to the other keys\n  // in the node. The motivation here is to detect comparators that violate\n  // transitivity. Note: we only do comparisons of keys on this node rather than\n  // the whole tree so that this is constant time.\n  template <typename Compare>\n  bool is_ordered_correctly(field_type i, const Compare &comp) const {\n    if (std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase,\n                        Compare>::value ||\n        params_type::kIsKeyCompareStringAdapted) {\n      return true;\n    }\n\n    const auto compare = [&](field_type a, field_type b) {\n      const absl::weak_ordering cmp =\n          compare_internal::do_three_way_comparison(comp, key(a), key(b));\n      return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;\n    };\n    int cmp = -1;\n    constexpr bool kCanHaveEquivKeys =\n        params_type::template can_have_multiple_equivalent_keys<key_type>();\n    for (field_type j = start(); j < finish(); ++j) {\n      if (j == i) {\n        if (cmp > 0) return false;\n        continue;\n      }\n      int new_cmp = compare(j, i);\n      if (new_cmp < cmp || (!kCanHaveEquivKeys && new_cmp == 0)) return false;\n      cmp = new_cmp;\n    }\n    return true;\n  }\n\n  // Emplaces a value at position i, shifting all existing values and\n  // children at positions >= i to the right by 1.\n  template <typename... Args>\n  void emplace_value(field_type i, allocator_type *alloc, Args &&...args);\n\n  // Removes the values at positions [i, i + to_erase), shifting all existing\n  // values and children after that range to the left by to_erase. Clears all\n  // children between [i, i + to_erase).\n  void remove_values(field_type i, field_type to_erase, allocator_type *alloc);\n\n  // Rebalances a node with its right sibling.\n  void rebalance_right_to_left(field_type to_move, btree_node *right,\n                               allocator_type *alloc);\n  void rebalance_left_to_right(field_type to_move, btree_node *right,\n                               allocator_type *alloc);\n\n  // Splits a node, moving a portion of the node's values to its right sibling.\n  void split(int insert_position, btree_node *dest, allocator_type *alloc);\n\n  // Merges a node with its right sibling, moving all of the values and the\n  // delimiting key in the parent node onto itself, and deleting the src node.\n  void merge(btree_node *src, allocator_type *alloc);\n\n  // Node allocation/deletion routines.\n  void init_leaf(field_type position, field_type max_count,\n                 btree_node *parent) {\n    set_generation(0);\n    set_parent(parent);\n    set_position(position);\n    set_start(0);\n    set_finish(0);\n    set_max_count(max_count);\n    absl::container_internal::SanitizerPoisonMemoryRegion(\n        start_slot(), max_count * sizeof(slot_type));\n  }\n  void init_internal(field_type position, btree_node *parent) {\n    init_leaf(position, kNodeSlots, parent);\n    // Set `max_count` to a sentinel value to indicate that this node is\n    // internal.\n    set_max_count(kInternalNodeMaxCount);\n    absl::container_internal::SanitizerPoisonMemoryRegion(\n        &mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));\n  }\n\n  static void deallocate(const size_type size, btree_node *node,\n                         allocator_type *alloc) {\n    absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);\n    absl::container_internal::Deallocate<Alignment()>(alloc, node, size);\n  }\n\n  // Deletes a node and all of its children.\n  static void clear_and_delete(btree_node *node, allocator_type *alloc);\n\n private:\n  template <typename... Args>\n  void value_init(const field_type i, allocator_type *alloc, Args &&...args) {\n    next_generation();\n    absl::container_internal::SanitizerUnpoisonObject(slot(i));\n    params_type::construct(alloc, slot(i), std::forward<Args>(args)...);\n  }\n  void value_destroy(const field_type i, allocator_type *alloc) {\n    next_generation();\n    params_type::destroy(alloc, slot(i));\n    absl::container_internal::SanitizerPoisonObject(slot(i));\n  }\n  void value_destroy_n(const field_type i, const field_type n,\n                       allocator_type *alloc) {\n    next_generation();\n    for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {\n      params_type::destroy(alloc, s);\n      absl::container_internal::SanitizerPoisonObject(s);\n    }\n  }\n\n  static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {\n    absl::container_internal::SanitizerUnpoisonObject(dest);\n    params_type::transfer(alloc, dest, src);\n    absl::container_internal::SanitizerPoisonObject(src);\n  }\n\n  // Transfers value from slot `src_i` in `src_node` to slot `dest_i` in `this`.\n  void transfer(const size_type dest_i, const size_type src_i,\n                btree_node *src_node, allocator_type *alloc) {\n    next_generation();\n    transfer(slot(dest_i), src_node->slot(src_i), alloc);\n  }\n\n  // Transfers `n` values starting at value `src_i` in `src_node` into the\n  // values starting at value `dest_i` in `this`.\n  void transfer_n(const size_type n, const size_type dest_i,\n                  const size_type src_i, btree_node *src_node,\n                  allocator_type *alloc) {\n    next_generation();\n    for (slot_type *src = src_node->slot(src_i), *end = src + n,\n                   *dest = slot(dest_i);\n         src != end; ++src, ++dest) {\n      transfer(dest, src, alloc);\n    }\n  }\n\n  // Same as above, except that we start at the end and work our way to the\n  // beginning.\n  void transfer_n_backward(const size_type n, const size_type dest_i,\n                           const size_type src_i, btree_node *src_node,\n                           allocator_type *alloc) {\n    next_generation();\n    for (slot_type *src = src_node->slot(src_i + n), *end = src - n,\n                   *dest = slot(dest_i + n);\n         src != end; --src, --dest) {\n      // If we modified the loop index calculations above to avoid the -1s here,\n      // it would result in UB in the computation of `end` (and possibly `src`\n      // as well, if n == 0), since slot() is effectively an array index and it\n      // is UB to compute the address of any out-of-bounds array element except\n      // for one-past-the-end.\n      transfer(dest - 1, src - 1, alloc);\n    }\n  }\n\n  template <typename P>\n  friend class btree;\n  template <typename N, typename R, typename P>\n  friend class btree_iterator;\n  friend class BtreeNodePeer;\n  friend struct btree_access;\n};\n\ntemplate <typename Node>\nbool AreNodesFromSameContainer(const Node *node_a, const Node *node_b) {\n  // If either node is null, then give up on checking whether they're from the\n  // same container. (If exactly one is null, then we'll trigger the\n  // default-constructed assert in Equals.)\n  if (node_a == nullptr || node_b == nullptr) return true;\n  while (!node_a->is_root()) node_a = node_a->parent();\n  while (!node_b->is_root()) node_b = node_b->parent();\n  return node_a == node_b;\n}\n\nclass btree_iterator_generation_info_enabled {\n public:\n  explicit btree_iterator_generation_info_enabled(uint32_t g)\n      : generation_(g) {}\n\n  // Updates the generation. For use internally right before we return an\n  // iterator to the user.\n  template <typename Node>\n  void update_generation(const Node *node) {\n    if (node != nullptr) generation_ = node->generation();\n  }\n  uint32_t generation() const { return generation_; }\n\n  template <typename Node>\n  void assert_valid_generation(const Node *node) const {\n    if (node != nullptr && node->generation() != generation_) {\n      ABSL_INTERNAL_LOG(\n          FATAL,\n          \"Attempting to use an invalidated iterator. The corresponding b-tree \"\n          \"container has been mutated since this iterator was constructed.\");\n    }\n  }\n\n private:\n  // Used to check that the iterator hasn't been invalidated.\n  uint32_t generation_;\n};\n\nclass btree_iterator_generation_info_disabled {\n public:\n  explicit btree_iterator_generation_info_disabled(uint32_t) {}\n  static void update_generation(const void *) {}\n  static uint32_t generation() { return 0; }\n  static void assert_valid_generation(const void *) {}\n};\n\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\nusing btree_iterator_generation_info = btree_iterator_generation_info_enabled;\n#else\nusing btree_iterator_generation_info = btree_iterator_generation_info_disabled;\n#endif\n\ntemplate <typename Node, typename Reference, typename Pointer>\nclass btree_iterator : private btree_iterator_generation_info {\n  using field_type = typename Node::field_type;\n  using key_type = typename Node::key_type;\n  using size_type = typename Node::size_type;\n  using params_type = typename Node::params_type;\n  using is_map_container = typename params_type::is_map_container;\n\n  using node_type = Node;\n  using normal_node = typename std::remove_const<Node>::type;\n  using const_node = const Node;\n  using normal_pointer = typename params_type::pointer;\n  using normal_reference = typename params_type::reference;\n  using const_pointer = typename params_type::const_pointer;\n  using const_reference = typename params_type::const_reference;\n  using slot_type = typename params_type::slot_type;\n\n  // In sets, all iterators are const.\n  using iterator = absl::conditional_t<\n      is_map_container::value,\n      btree_iterator<normal_node, normal_reference, normal_pointer>,\n      btree_iterator<normal_node, const_reference, const_pointer>>;\n  using const_iterator =\n      btree_iterator<const_node, const_reference, const_pointer>;\n\n public:\n  // These aliases are public for std::iterator_traits.\n  using difference_type = typename Node::difference_type;\n  using value_type = typename params_type::value_type;\n  using pointer = Pointer;\n  using reference = Reference;\n  using iterator_category = std::bidirectional_iterator_tag;\n\n  btree_iterator() : btree_iterator(nullptr, -1) {}\n  explicit btree_iterator(Node *n) : btree_iterator(n, n->start()) {}\n  btree_iterator(Node *n, int p)\n      : btree_iterator_generation_info(n != nullptr ? n->generation()\n                                                    : ~uint32_t{}),\n        node_(n),\n        position_(p) {}\n\n  // NOTE: this SFINAE allows for implicit conversions from iterator to\n  // const_iterator, but it specifically avoids hiding the copy constructor so\n  // that the trivial one will be used when possible.\n  template <typename N, typename R, typename P,\n            absl::enable_if_t<\n                std::is_same<btree_iterator<N, R, P>, iterator>::value &&\n                    std::is_same<btree_iterator, const_iterator>::value,\n                int> = 0>\n  btree_iterator(const btree_iterator<N, R, P> other)  // NOLINT\n      : btree_iterator_generation_info(other),\n        node_(other.node_),\n        position_(other.position_) {}\n\n  bool operator==(const iterator &other) const {\n    return Equals(other);\n  }\n  bool operator==(const const_iterator &other) const {\n    return Equals(other);\n  }\n  bool operator!=(const iterator &other) const {\n    return !Equals(other);\n  }\n  bool operator!=(const const_iterator &other) const {\n    return !Equals(other);\n  }\n\n  // Returns n such that n calls to ++other yields *this.\n  // Precondition: n exists.\n  difference_type operator-(const_iterator other) const {\n    if (node_ == other.node_) {\n      if (node_->is_leaf()) return position_ - other.position_;\n      if (position_ == other.position_) return 0;\n    }\n    return distance_slow(other);\n  }\n\n  // Accessors for the key/value the iterator is pointing at.\n  reference operator*() const {\n    ABSL_HARDENING_ASSERT(node_ != nullptr);\n    assert_valid_generation(node_);\n    ABSL_HARDENING_ASSERT(position_ >= node_->start());\n    if (position_ >= node_->finish()) {\n      ABSL_HARDENING_ASSERT(!IsEndIterator() && \"Dereferencing end() iterator\");\n      ABSL_HARDENING_ASSERT(position_ < node_->finish());\n    }\n    return node_->value(static_cast<field_type>(position_));\n  }\n  pointer operator->() const { return &operator*(); }\n\n  btree_iterator &operator++() {\n    increment();\n    return *this;\n  }\n  btree_iterator &operator--() {\n    decrement();\n    return *this;\n  }\n  btree_iterator operator++(int) {\n    btree_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n  btree_iterator operator--(int) {\n    btree_iterator tmp = *this;\n    --*this;\n    return tmp;\n  }\n\n private:\n  friend iterator;\n  friend const_iterator;\n  template <typename Params>\n  friend class btree;\n  template <typename Tree>\n  friend class btree_container;\n  template <typename Tree>\n  friend class btree_set_container;\n  template <typename Tree>\n  friend class btree_map_container;\n  template <typename Tree>\n  friend class btree_multiset_container;\n  template <typename TreeType, typename CheckerType>\n  friend class base_checker;\n  friend struct btree_access;\n\n  // This SFINAE allows explicit conversions from const_iterator to\n  // iterator, but also avoids hiding the copy constructor.\n  // NOTE: the const_cast is safe because this constructor is only called by\n  // non-const methods and the container owns the nodes.\n  template <typename N, typename R, typename P,\n            absl::enable_if_t<\n                std::is_same<btree_iterator<N, R, P>, const_iterator>::value &&\n                    std::is_same<btree_iterator, iterator>::value,\n                int> = 0>\n  explicit btree_iterator(const btree_iterator<N, R, P> other)\n      : btree_iterator_generation_info(other.generation()),\n        node_(const_cast<node_type *>(other.node_)),\n        position_(other.position_) {}\n\n  bool Equals(const const_iterator other) const {\n    ABSL_HARDENING_ASSERT(((node_ == nullptr && other.node_ == nullptr) ||\n                           (node_ != nullptr && other.node_ != nullptr)) &&\n                          \"Comparing default-constructed iterator with \"\n                          \"non-default-constructed iterator.\");\n    // Note: we use assert instead of ABSL_HARDENING_ASSERT here because this\n    // changes the complexity of Equals from O(1) to O(log(N) + log(M)) where\n    // N/M are sizes of the containers containing node_/other.node_.\n    assert(AreNodesFromSameContainer(node_, other.node_) &&\n           \"Comparing iterators from different containers.\");\n    assert_valid_generation(node_);\n    other.assert_valid_generation(other.node_);\n    return node_ == other.node_ && position_ == other.position_;\n  }\n\n  bool IsEndIterator() const {\n    if (position_ != node_->finish()) return false;\n    node_type *node = node_;\n    while (!node->is_root()) {\n      if (node->position() != node->parent()->finish()) return false;\n      node = node->parent();\n    }\n    return true;\n  }\n\n  // Returns n such that n calls to ++other yields *this.\n  // Precondition: n exists && (this->node_ != other.node_ ||\n  // !this->node_->is_leaf() || this->position_ != other.position_).\n  difference_type distance_slow(const_iterator other) const;\n\n  // Increment/decrement the iterator.\n  void increment() {\n    assert_valid_generation(node_);\n    if (node_->is_leaf() && ++position_ < node_->finish()) {\n      return;\n    }\n    increment_slow();\n  }\n  void increment_slow();\n\n  void decrement() {\n    assert_valid_generation(node_);\n    if (node_->is_leaf() && --position_ >= node_->start()) {\n      return;\n    }\n    decrement_slow();\n  }\n  void decrement_slow();\n\n  const key_type &key() const {\n    return node_->key(static_cast<size_type>(position_));\n  }\n  decltype(std::declval<Node *>()->slot(0)) slot() {\n    return node_->slot(static_cast<size_type>(position_));\n  }\n\n  void update_generation() {\n    btree_iterator_generation_info::update_generation(node_);\n  }\n\n  // The node in the tree the iterator is pointing at.\n  Node *node_;\n  // The position within the node of the tree the iterator is pointing at.\n  // NOTE: this is an int rather than a field_type because iterators can point\n  // to invalid positions (such as -1) in certain circumstances.\n  int position_;\n};\n\ntemplate <typename Params>\nclass btree {\n  using node_type = btree_node<Params>;\n  using is_key_compare_to = typename Params::is_key_compare_to;\n  using field_type = typename node_type::field_type;\n\n  // We use a static empty node for the root/leftmost/rightmost of empty btrees\n  // in order to avoid branching in begin()/end().\n  struct EmptyNodeType : node_type {\n    using field_type = typename node_type::field_type;\n    node_type *parent;\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\n    uint32_t generation = 0;\n#endif\n    field_type position = 0;\n    field_type start = 0;\n    field_type finish = 0;\n    // max_count must be != kInternalNodeMaxCount (so that this node is regarded\n    // as a leaf node). max_count() is never called when the tree is empty.\n    field_type max_count = node_type::kInternalNodeMaxCount + 1;\n\n    constexpr EmptyNodeType() : parent(this) {}\n  };\n\n  static node_type *EmptyNode() {\n    alignas(node_type::Alignment()) static constexpr EmptyNodeType empty_node;\n    return const_cast<EmptyNodeType *>(&empty_node);\n  }\n\n  enum : uint32_t {\n    kNodeSlots = node_type::kNodeSlots,\n    kMinNodeValues = kNodeSlots / 2,\n  };\n\n  struct node_stats {\n    using size_type = typename Params::size_type;\n\n    node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}\n\n    node_stats &operator+=(const node_stats &other) {\n      leaf_nodes += other.leaf_nodes;\n      internal_nodes += other.internal_nodes;\n      return *this;\n    }\n\n    size_type leaf_nodes;\n    size_type internal_nodes;\n  };\n\n public:\n  using key_type = typename Params::key_type;\n  using value_type = typename Params::value_type;\n  using size_type = typename Params::size_type;\n  using difference_type = typename Params::difference_type;\n  using key_compare = typename Params::key_compare;\n  using original_key_compare = typename Params::original_key_compare;\n  using value_compare = typename Params::value_compare;\n  using allocator_type = typename Params::allocator_type;\n  using reference = typename Params::reference;\n  using const_reference = typename Params::const_reference;\n  using pointer = typename Params::pointer;\n  using const_pointer = typename Params::const_pointer;\n  using iterator =\n      typename btree_iterator<node_type, reference, pointer>::iterator;\n  using const_iterator = typename iterator::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using node_handle_type = node_handle<Params, Params, allocator_type>;\n\n  // Internal types made public for use by btree_container types.\n  using params_type = Params;\n  using slot_type = typename Params::slot_type;\n\n private:\n  // Copies or moves (depending on the template parameter) the values in\n  // other into this btree in their order in other. This btree must be empty\n  // before this method is called. This method is used in copy construction,\n  // copy assignment, and move assignment.\n  template <typename Btree>\n  void copy_or_move_values_in_order(Btree &other);\n\n  // Validates that various assumptions/requirements are true at compile time.\n  constexpr static bool static_assert_validation();\n\n public:\n  btree(const key_compare &comp, const allocator_type &alloc)\n      : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}\n\n  btree(const btree &other) : btree(other, other.allocator()) {}\n  btree(const btree &other, const allocator_type &alloc)\n      : btree(other.key_comp(), alloc) {\n    copy_or_move_values_in_order(other);\n  }\n  btree(btree &&other) noexcept\n      : root_(absl::exchange(other.root_, EmptyNode())),\n        rightmost_(std::move(other.rightmost_)),\n        size_(absl::exchange(other.size_, 0u)) {\n    other.mutable_rightmost() = EmptyNode();\n  }\n  btree(btree &&other, const allocator_type &alloc)\n      : btree(other.key_comp(), alloc) {\n    if (alloc == other.allocator()) {\n      swap(other);\n    } else {\n      // Move values from `other` one at a time when allocators are different.\n      copy_or_move_values_in_order(other);\n    }\n  }\n\n  ~btree() {\n    // Put static_asserts in destructor to avoid triggering them before the type\n    // is complete.\n    static_assert(static_assert_validation(), \"This call must be elided.\");\n    clear();\n  }\n\n  // Assign the contents of other to *this.\n  btree &operator=(const btree &other);\n  btree &operator=(btree &&other) noexcept;\n\n  iterator begin() { return iterator(leftmost()); }\n  const_iterator begin() const { return const_iterator(leftmost()); }\n  iterator end() { return iterator(rightmost(), rightmost()->finish()); }\n  const_iterator end() const {\n    return const_iterator(rightmost(), rightmost()->finish());\n  }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  // Finds the first element whose key is not less than `key`.\n  template <typename K>\n  iterator lower_bound(const K &key) {\n    return internal_end(internal_lower_bound(key).value);\n  }\n  template <typename K>\n  const_iterator lower_bound(const K &key) const {\n    return internal_end(internal_lower_bound(key).value);\n  }\n\n  // Finds the first element whose key is not less than `key` and also returns\n  // whether that element is equal to `key`.\n  template <typename K>\n  std::pair<iterator, bool> lower_bound_equal(const K &key) const;\n\n  // Finds the first element whose key is greater than `key`.\n  template <typename K>\n  iterator upper_bound(const K &key) {\n    return internal_end(internal_upper_bound(key));\n  }\n  template <typename K>\n  const_iterator upper_bound(const K &key) const {\n    return internal_end(internal_upper_bound(key));\n  }\n\n  // Finds the range of values which compare equal to key. The first member of\n  // the returned pair is equal to lower_bound(key). The second member of the\n  // pair is equal to upper_bound(key).\n  template <typename K>\n  std::pair<iterator, iterator> equal_range(const K &key);\n  template <typename K>\n  std::pair<const_iterator, const_iterator> equal_range(const K &key) const {\n    return const_cast<btree *>(this)->equal_range(key);\n  }\n\n  // Inserts a value into the btree only if it does not already exist. The\n  // boolean return value indicates whether insertion succeeded or failed.\n  // Requirement: if `key` already exists in the btree, does not consume `args`.\n  // Requirement: `key` is never referenced after consuming `args`.\n  template <typename K, typename... Args>\n  std::pair<iterator, bool> insert_unique(const K &key, Args &&...args);\n\n  // Inserts with hint. Checks to see if the value should be placed immediately\n  // before `position` in the tree. If so, then the insertion will take\n  // amortized constant time. If not, the insertion will take amortized\n  // logarithmic time as if a call to insert_unique() were made.\n  // Requirement: if `key` already exists in the btree, does not consume `args`.\n  // Requirement: `key` is never referenced after consuming `args`.\n  template <typename K, typename... Args>\n  std::pair<iterator, bool> insert_hint_unique(iterator position, const K &key,\n                                               Args &&...args);\n\n  // Insert a range of values into the btree.\n  // Note: the first overload avoids constructing a value_type if the key\n  // already exists in the btree.\n  template <typename InputIterator,\n            typename = decltype(std::declval<const key_compare &>()(\n                params_type::key(*std::declval<InputIterator>()),\n                std::declval<const key_type &>()))>\n  void insert_iterator_unique(InputIterator b, InputIterator e, int);\n  // We need the second overload for cases in which we need to construct a\n  // value_type in order to compare it with the keys already in the btree.\n  template <typename InputIterator>\n  void insert_iterator_unique(InputIterator b, InputIterator e, char);\n\n  // Inserts a value into the btree.\n  template <typename ValueType>\n  iterator insert_multi(const key_type &key, ValueType &&v);\n\n  // Inserts a value into the btree.\n  template <typename ValueType>\n  iterator insert_multi(ValueType &&v) {\n    return insert_multi(params_type::key(v), std::forward<ValueType>(v));\n  }\n\n  // Insert with hint. Check to see if the value should be placed immediately\n  // before position in the tree. If it does, then the insertion will take\n  // amortized constant time. If not, the insertion will take amortized\n  // logarithmic time as if a call to insert_multi(v) were made.\n  template <typename ValueType>\n  iterator insert_hint_multi(iterator position, ValueType &&v);\n\n  // Insert a range of values into the btree.\n  template <typename InputIterator>\n  void insert_iterator_multi(InputIterator b,\n                             InputIterator e);\n\n  // Erase the specified iterator from the btree. The iterator must be valid\n  // (i.e. not equal to end()).  Return an iterator pointing to the node after\n  // the one that was erased (or end() if none exists).\n  // Requirement: does not read the value at `*iter`.\n  iterator erase(iterator iter);\n\n  // Erases range. Returns the number of keys erased and an iterator pointing\n  // to the element after the last erased element.\n  std::pair<size_type, iterator> erase_range(iterator begin, iterator end);\n\n  // Finds an element with key equivalent to `key` or returns `end()` if `key`\n  // is not present.\n  template <typename K>\n  iterator find(const K &key) {\n    return internal_end(internal_find(key));\n  }\n  template <typename K>\n  const_iterator find(const K &key) const {\n    return internal_end(internal_find(key));\n  }\n\n  // Clear the btree, deleting all of the values it contains.\n  void clear();\n\n  // Swaps the contents of `this` and `other`.\n  void swap(btree &other);\n\n  const key_compare &key_comp() const noexcept {\n    return rightmost_.template get<0>();\n  }\n  template <typename K1, typename K2>\n  bool compare_keys(const K1 &a, const K2 &b) const {\n    return compare_internal::compare_result_as_less_than(key_comp()(a, b));\n  }\n\n  value_compare value_comp() const {\n    return value_compare(original_key_compare(key_comp()));\n  }\n\n  // Verifies the structure of the btree.\n  void verify() const;\n\n  // Size routines.\n  size_type size() const { return size_; }\n  size_type max_size() const { return (std::numeric_limits<size_type>::max)(); }\n  bool empty() const { return size_ == 0; }\n\n  // The height of the btree. An empty tree will have height 0.\n  size_type height() const {\n    size_type h = 0;\n    if (!empty()) {\n      // Count the length of the chain from the leftmost node up to the\n      // root. We actually count from the root back around to the level below\n      // the root, but the calculation is the same because of the circularity\n      // of that traversal.\n      const node_type *n = root();\n      do {\n        ++h;\n        n = n->parent();\n      } while (n != root());\n    }\n    return h;\n  }\n\n  // The number of internal, leaf and total nodes used by the btree.\n  size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }\n  size_type internal_nodes() const {\n    return internal_stats(root()).internal_nodes;\n  }\n  size_type nodes() const {\n    node_stats stats = internal_stats(root());\n    return stats.leaf_nodes + stats.internal_nodes;\n  }\n\n  // The total number of bytes used by the btree.\n  // TODO(b/169338300): update to support node_btree_*.\n  size_type bytes_used() const {\n    node_stats stats = internal_stats(root());\n    if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {\n      return sizeof(*this) + node_type::LeafSize(root()->max_count());\n    } else {\n      return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +\n             stats.internal_nodes * node_type::InternalSize();\n    }\n  }\n\n  // The average number of bytes used per value stored in the btree assuming\n  // random insertion order.\n  static double average_bytes_per_value() {\n    // The expected number of values per node with random insertion order is the\n    // average of the maximum and minimum numbers of values per node.\n    const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;\n    return node_type::LeafSize() / expected_values_per_node;\n  }\n\n  // The fullness of the btree. Computed as the number of elements in the btree\n  // divided by the maximum number of elements a tree with the current number\n  // of nodes could hold. A value of 1 indicates perfect space\n  // utilization. Smaller values indicate space wastage.\n  // Returns 0 for empty trees.\n  double fullness() const {\n    if (empty()) return 0.0;\n    return static_cast<double>(size()) / (nodes() * kNodeSlots);\n  }\n  // The overhead of the btree structure in bytes per node. Computed as the\n  // total number of bytes used by the btree minus the number of bytes used for\n  // storing elements divided by the number of elements.\n  // Returns 0 for empty trees.\n  double overhead() const {\n    if (empty()) return 0.0;\n    return (bytes_used() - size() * sizeof(value_type)) /\n           static_cast<double>(size());\n  }\n\n  // The allocator used by the btree.\n  allocator_type get_allocator() const { return allocator(); }\n\n private:\n  friend struct btree_access;\n\n  // Internal accessor routines.\n  node_type *root() { return root_; }\n  const node_type *root() const { return root_; }\n  node_type *&mutable_root() noexcept { return root_; }\n  node_type *rightmost() { return rightmost_.template get<2>(); }\n  const node_type *rightmost() const { return rightmost_.template get<2>(); }\n  node_type *&mutable_rightmost() noexcept {\n    return rightmost_.template get<2>();\n  }\n  key_compare *mutable_key_comp() noexcept {\n    return &rightmost_.template get<0>();\n  }\n\n  // The leftmost node is stored as the parent of the root node.\n  node_type *leftmost() { return root()->parent(); }\n  const node_type *leftmost() const { return root()->parent(); }\n\n  // Allocator routines.\n  allocator_type *mutable_allocator() noexcept {\n    return &rightmost_.template get<1>();\n  }\n  const allocator_type &allocator() const noexcept {\n    return rightmost_.template get<1>();\n  }\n\n  // Allocates a correctly aligned node of at least size bytes using the\n  // allocator.\n  node_type *allocate(size_type size) {\n    return reinterpret_cast<node_type *>(\n        absl::container_internal::Allocate<node_type::Alignment()>(\n            mutable_allocator(), size));\n  }\n\n  // Node creation/deletion routines.\n  node_type *new_internal_node(field_type position, node_type *parent) {\n    node_type *n = allocate(node_type::InternalSize());\n    n->init_internal(position, parent);\n    return n;\n  }\n  node_type *new_leaf_node(field_type position, node_type *parent) {\n    node_type *n = allocate(node_type::LeafSize());\n    n->init_leaf(position, kNodeSlots, parent);\n    return n;\n  }\n  node_type *new_leaf_root_node(field_type max_count) {\n    node_type *n = allocate(node_type::LeafSize(max_count));\n    n->init_leaf(/*position=*/0, max_count, /*parent=*/n);\n    return n;\n  }\n\n  // Deletion helper routines.\n  iterator rebalance_after_delete(iterator iter);\n\n  // Rebalances or splits the node iter points to.\n  void rebalance_or_split(iterator *iter);\n\n  // Merges the values of left, right and the delimiting key on their parent\n  // onto left, removing the delimiting key and deleting right.\n  void merge_nodes(node_type *left, node_type *right);\n\n  // Tries to merge node with its left or right sibling, and failing that,\n  // rebalance with its left or right sibling. Returns true if a merge\n  // occurred, at which point it is no longer valid to access node. Returns\n  // false if no merging took place.\n  bool try_merge_or_rebalance(iterator *iter);\n\n  // Tries to shrink the height of the tree by 1.\n  void try_shrink();\n\n  iterator internal_end(iterator iter) {\n    return iter.node_ != nullptr ? iter : end();\n  }\n  const_iterator internal_end(const_iterator iter) const {\n    return iter.node_ != nullptr ? iter : end();\n  }\n\n  // Emplaces a value into the btree immediately before iter. Requires that\n  // key(v) <= iter.key() and (--iter).key() <= key(v).\n  template <typename... Args>\n  iterator internal_emplace(iterator iter, Args &&...args);\n\n  // Returns an iterator pointing to the first value >= the value \"iter\" is\n  // pointing at. Note that \"iter\" might be pointing to an invalid location such\n  // as iter.position_ == iter.node_->finish(). This routine simply moves iter\n  // up in the tree to a valid location. Requires: iter.node_ is non-null.\n  template <typename IterType>\n  static IterType internal_last(IterType iter);\n\n  // Returns an iterator pointing to the leaf position at which key would\n  // reside in the tree, unless there is an exact match - in which case, the\n  // result may not be on a leaf. When there's a three-way comparator, we can\n  // return whether there was an exact match. This allows the caller to avoid a\n  // subsequent comparison to determine if an exact match was made, which is\n  // important for keys with expensive comparison, such as strings.\n  template <typename K>\n  SearchResult<iterator, is_key_compare_to::value> internal_locate(\n      const K &key) const;\n\n  // Internal routine which implements lower_bound().\n  template <typename K>\n  SearchResult<iterator, is_key_compare_to::value> internal_lower_bound(\n      const K &key) const;\n\n  // Internal routine which implements upper_bound().\n  template <typename K>\n  iterator internal_upper_bound(const K &key) const;\n\n  // Internal routine which implements find().\n  template <typename K>\n  iterator internal_find(const K &key) const;\n\n  // Verifies the tree structure of node.\n  size_type internal_verify(const node_type *node, const key_type *lo,\n                            const key_type *hi) const;\n\n  node_stats internal_stats(const node_type *node) const {\n    // The root can be a static empty node.\n    if (node == nullptr || (node == root() && empty())) {\n      return node_stats(0, 0);\n    }\n    if (node->is_leaf()) {\n      return node_stats(1, 0);\n    }\n    node_stats res(0, 1);\n    for (int i = node->start(); i <= node->finish(); ++i) {\n      res += internal_stats(node->child(i));\n    }\n    return res;\n  }\n\n  node_type *root_;\n\n  // A pointer to the rightmost node. Note that the leftmost node is stored as\n  // the root's parent. We use compressed tuple in order to save space because\n  // key_compare and allocator_type are usually empty.\n  absl::container_internal::CompressedTuple<key_compare, allocator_type,\n                                            node_type *>\n      rightmost_;\n\n  // Number of values.\n  size_type size_;\n};\n\n////\n// btree_node methods\ntemplate <typename P>\ntemplate <typename... Args>\ninline void btree_node<P>::emplace_value(const field_type i,\n                                         allocator_type *alloc,\n                                         Args &&...args) {\n  assert(i >= start());\n  assert(i <= finish());\n  // Shift old values to create space for new value and then construct it in\n  // place.\n  if (i < finish()) {\n    transfer_n_backward(finish() - i, /*dest_i=*/i + 1, /*src_i=*/i, this,\n                        alloc);\n  }\n  value_init(static_cast<field_type>(i), alloc, std::forward<Args>(args)...);\n  set_finish(finish() + 1);\n\n  if (is_internal() && finish() > i + 1) {\n    for (field_type j = finish(); j > i + 1; --j) {\n      set_child(j, child(j - 1));\n    }\n    clear_child(i + 1);\n  }\n}\n\ntemplate <typename P>\ninline void btree_node<P>::remove_values(const field_type i,\n                                         const field_type to_erase,\n                                         allocator_type *alloc) {\n  // Transfer values after the removed range into their new places.\n  value_destroy_n(i, to_erase, alloc);\n  const field_type orig_finish = finish();\n  const field_type src_i = i + to_erase;\n  transfer_n(orig_finish - src_i, i, src_i, this, alloc);\n\n  if (is_internal()) {\n    // Delete all children between begin and end.\n    for (field_type j = 0; j < to_erase; ++j) {\n      clear_and_delete(child(i + j + 1), alloc);\n    }\n    // Rotate children after end into new positions.\n    for (field_type j = i + to_erase + 1; j <= orig_finish; ++j) {\n      set_child(j - to_erase, child(j));\n      clear_child(j);\n    }\n  }\n  set_finish(orig_finish - to_erase);\n}\n\ntemplate <typename P>\nvoid btree_node<P>::rebalance_right_to_left(field_type to_move,\n                                            btree_node *right,\n                                            allocator_type *alloc) {\n  assert(parent() == right->parent());\n  assert(position() + 1 == right->position());\n  assert(right->count() >= count());\n  assert(to_move >= 1);\n  assert(to_move <= right->count());\n\n  // 1) Move the delimiting value in the parent to the left node.\n  transfer(finish(), position(), parent(), alloc);\n\n  // 2) Move the (to_move - 1) values from the right node to the left node.\n  transfer_n(to_move - 1, finish() + 1, right->start(), right, alloc);\n\n  // 3) Move the new delimiting value to the parent from the right node.\n  parent()->transfer(position(), right->start() + to_move - 1, right, alloc);\n\n  // 4) Shift the values in the right node to their correct positions.\n  right->transfer_n(right->count() - to_move, right->start(),\n                    right->start() + to_move, right, alloc);\n\n  if (is_internal()) {\n    // Move the child pointers from the right to the left node.\n    for (field_type i = 0; i < to_move; ++i) {\n      init_child(finish() + i + 1, right->child(i));\n    }\n    for (field_type i = right->start(); i <= right->finish() - to_move; ++i) {\n      assert(i + to_move <= right->max_count());\n      right->init_child(i, right->child(i + to_move));\n      right->clear_child(i + to_move);\n    }\n  }\n\n  // Fixup `finish` on the left and right nodes.\n  set_finish(finish() + to_move);\n  right->set_finish(right->finish() - to_move);\n}\n\ntemplate <typename P>\nvoid btree_node<P>::rebalance_left_to_right(field_type to_move,\n                                            btree_node *right,\n                                            allocator_type *alloc) {\n  assert(parent() == right->parent());\n  assert(position() + 1 == right->position());\n  assert(count() >= right->count());\n  assert(to_move >= 1);\n  assert(to_move <= count());\n\n  // Values in the right node are shifted to the right to make room for the\n  // new to_move values. Then, the delimiting value in the parent and the\n  // other (to_move - 1) values in the left node are moved into the right node.\n  // Lastly, a new delimiting value is moved from the left node into the\n  // parent, and the remaining empty left node entries are destroyed.\n\n  // 1) Shift existing values in the right node to their correct positions.\n  right->transfer_n_backward(right->count(), right->start() + to_move,\n                             right->start(), right, alloc);\n\n  // 2) Move the delimiting value in the parent to the right node.\n  right->transfer(right->start() + to_move - 1, position(), parent(), alloc);\n\n  // 3) Move the (to_move - 1) values from the left node to the right node.\n  right->transfer_n(to_move - 1, right->start(), finish() - (to_move - 1), this,\n                    alloc);\n\n  // 4) Move the new delimiting value to the parent from the left node.\n  parent()->transfer(position(), finish() - to_move, this, alloc);\n\n  if (is_internal()) {\n    // Move the child pointers from the left to the right node.\n    for (field_type i = right->finish() + 1; i > right->start(); --i) {\n      right->init_child(i - 1 + to_move, right->child(i - 1));\n      right->clear_child(i - 1);\n    }\n    for (field_type i = 1; i <= to_move; ++i) {\n      right->init_child(i - 1, child(finish() - to_move + i));\n      clear_child(finish() - to_move + i);\n    }\n  }\n\n  // Fixup the counts on the left and right nodes.\n  set_finish(finish() - to_move);\n  right->set_finish(right->finish() + to_move);\n}\n\ntemplate <typename P>\nvoid btree_node<P>::split(const int insert_position, btree_node *dest,\n                          allocator_type *alloc) {\n  assert(dest->count() == 0);\n  assert(max_count() == kNodeSlots);\n  assert(position() + 1 == dest->position());\n  assert(parent() == dest->parent());\n\n  // We bias the split based on the position being inserted. If we're\n  // inserting at the beginning of the left node then bias the split to put\n  // more values on the right node. If we're inserting at the end of the\n  // right node then bias the split to put more values on the left node.\n  if (insert_position == start()) {\n    dest->set_finish(dest->start() + finish() - 1);\n  } else if (insert_position == kNodeSlots) {\n    dest->set_finish(dest->start());\n  } else {\n    dest->set_finish(dest->start() + count() / 2);\n  }\n  set_finish(finish() - dest->count());\n  assert(count() >= 1);\n\n  // Move values from the left sibling to the right sibling.\n  dest->transfer_n(dest->count(), dest->start(), finish(), this, alloc);\n\n  // The split key is the largest value in the left sibling.\n  --mutable_finish();\n  parent()->emplace_value(position(), alloc, finish_slot());\n  value_destroy(finish(), alloc);\n  parent()->set_child_noupdate_position(position() + 1, dest);\n\n  if (is_internal()) {\n    for (field_type i = dest->start(), j = finish() + 1; i <= dest->finish();\n         ++i, ++j) {\n      assert(child(j) != nullptr);\n      dest->init_child(i, child(j));\n      clear_child(j);\n    }\n  }\n}\n\ntemplate <typename P>\nvoid btree_node<P>::merge(btree_node *src, allocator_type *alloc) {\n  assert(parent() == src->parent());\n  assert(position() + 1 == src->position());\n\n  // Move the delimiting value to the left node.\n  value_init(finish(), alloc, parent()->slot(position()));\n\n  // Move the values from the right to the left node.\n  transfer_n(src->count(), finish() + 1, src->start(), src, alloc);\n\n  if (is_internal()) {\n    // Move the child pointers from the right to the left node.\n    for (field_type i = src->start(), j = finish() + 1; i <= src->finish();\n         ++i, ++j) {\n      init_child(j, src->child(i));\n      src->clear_child(i);\n    }\n  }\n\n  // Fixup `finish` on the src and dest nodes.\n  set_finish(start() + 1 + count() + src->count());\n  src->set_finish(src->start());\n\n  // Remove the value on the parent node and delete the src node.\n  parent()->remove_values(position(), /*to_erase=*/1, alloc);\n}\n\ntemplate <typename P>\nvoid btree_node<P>::clear_and_delete(btree_node *node, allocator_type *alloc) {\n  if (node->is_leaf()) {\n    node->value_destroy_n(node->start(), node->count(), alloc);\n    deallocate(LeafSize(node->max_count()), node, alloc);\n    return;\n  }\n  if (node->count() == 0) {\n    deallocate(InternalSize(), node, alloc);\n    return;\n  }\n\n  // The parent of the root of the subtree we are deleting.\n  btree_node *delete_root_parent = node->parent();\n\n  // Navigate to the leftmost leaf under node, and then delete upwards.\n  while (node->is_internal()) node = node->start_child();\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\n  // When generations are enabled, we delete the leftmost leaf last in case it's\n  // the parent of the root and we need to check whether it's a leaf before we\n  // can update the root's generation.\n  // TODO(ezb): if we change btree_node::is_root to check a bool inside the node\n  // instead of checking whether the parent is a leaf, we can remove this logic.\n  btree_node *leftmost_leaf = node;\n#endif\n  // Use `size_type` because `pos` needs to be able to hold `kNodeSlots+1`,\n  // which isn't guaranteed to be a valid `field_type`.\n  size_type pos = node->position();\n  btree_node *parent = node->parent();\n  for (;;) {\n    // In each iteration of the next loop, we delete one leaf node and go right.\n    assert(pos <= parent->finish());\n    do {\n      node = parent->child(static_cast<field_type>(pos));\n      if (node->is_internal()) {\n        // Navigate to the leftmost leaf under node.\n        while (node->is_internal()) node = node->start_child();\n        pos = node->position();\n        parent = node->parent();\n      }\n      node->value_destroy_n(node->start(), node->count(), alloc);\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\n      if (leftmost_leaf != node)\n#endif\n        deallocate(LeafSize(node->max_count()), node, alloc);\n      ++pos;\n    } while (pos <= parent->finish());\n\n    // Once we've deleted all children of parent, delete parent and go up/right.\n    assert(pos > parent->finish());\n    do {\n      node = parent;\n      pos = node->position();\n      parent = node->parent();\n      node->value_destroy_n(node->start(), node->count(), alloc);\n      deallocate(InternalSize(), node, alloc);\n      if (parent == delete_root_parent) {\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\n        deallocate(LeafSize(leftmost_leaf->max_count()), leftmost_leaf, alloc);\n#endif\n        return;\n      }\n      ++pos;\n    } while (pos > parent->finish());\n  }\n}\n\n////\n// btree_iterator methods\n\n// Note: the implementation here is based on btree_node::clear_and_delete.\ntemplate <typename N, typename R, typename P>\nauto btree_iterator<N, R, P>::distance_slow(const_iterator other) const\n    -> difference_type {\n  const_iterator begin = other;\n  const_iterator end = *this;\n  assert(begin.node_ != end.node_ || !begin.node_->is_leaf() ||\n         begin.position_ != end.position_);\n\n  const node_type *node = begin.node_;\n  // We need to compensate for double counting if begin.node_ is a leaf node.\n  difference_type count = node->is_leaf() ? -begin.position_ : 0;\n\n  // First navigate to the leftmost leaf node past begin.\n  if (node->is_internal()) {\n    ++count;\n    node = node->child(begin.position_ + 1);\n  }\n  while (node->is_internal()) node = node->start_child();\n\n  // Use `size_type` because `pos` needs to be able to hold `kNodeSlots+1`,\n  // which isn't guaranteed to be a valid `field_type`.\n  size_type pos = node->position();\n  const node_type *parent = node->parent();\n  for (;;) {\n    // In each iteration of the next loop, we count one leaf node and go right.\n    assert(pos <= parent->finish());\n    do {\n      node = parent->child(static_cast<field_type>(pos));\n      if (node->is_internal()) {\n        // Navigate to the leftmost leaf under node.\n        while (node->is_internal()) node = node->start_child();\n        pos = node->position();\n        parent = node->parent();\n      }\n      if (node == end.node_) return count + end.position_;\n      if (parent == end.node_ && pos == static_cast<size_type>(end.position_))\n        return count + node->count();\n      // +1 is for the next internal node value.\n      count += node->count() + 1;\n      ++pos;\n    } while (pos <= parent->finish());\n\n    // Once we've counted all children of parent, go up/right.\n    assert(pos > parent->finish());\n    do {\n      node = parent;\n      pos = node->position();\n      parent = node->parent();\n      // -1 because we counted the value at end and shouldn't.\n      if (parent == end.node_ && pos == static_cast<size_type>(end.position_))\n        return count - 1;\n      ++pos;\n    } while (pos > parent->finish());\n  }\n}\n\ntemplate <typename N, typename R, typename P>\nvoid btree_iterator<N, R, P>::increment_slow() {\n  if (node_->is_leaf()) {\n    assert(position_ >= node_->finish());\n    btree_iterator save(*this);\n    while (position_ == node_->finish() && !node_->is_root()) {\n      assert(node_->parent()->child(node_->position()) == node_);\n      position_ = node_->position();\n      node_ = node_->parent();\n    }\n    // TODO(ezb): assert we aren't incrementing end() instead of handling.\n    if (position_ == node_->finish()) {\n      *this = save;\n    }\n  } else {\n    assert(position_ < node_->finish());\n    node_ = node_->child(static_cast<field_type>(position_ + 1));\n    while (node_->is_internal()) {\n      node_ = node_->start_child();\n    }\n    position_ = node_->start();\n  }\n}\n\ntemplate <typename N, typename R, typename P>\nvoid btree_iterator<N, R, P>::decrement_slow() {\n  if (node_->is_leaf()) {\n    assert(position_ <= -1);\n    btree_iterator save(*this);\n    while (position_ < node_->start() && !node_->is_root()) {\n      assert(node_->parent()->child(node_->position()) == node_);\n      position_ = node_->position() - 1;\n      node_ = node_->parent();\n    }\n    // TODO(ezb): assert we aren't decrementing begin() instead of handling.\n    if (position_ < node_->start()) {\n      *this = save;\n    }\n  } else {\n    assert(position_ >= node_->start());\n    node_ = node_->child(static_cast<field_type>(position_));\n    while (node_->is_internal()) {\n      node_ = node_->child(node_->finish());\n    }\n    position_ = node_->finish() - 1;\n  }\n}\n\n////\n// btree methods\ntemplate <typename P>\ntemplate <typename Btree>\nvoid btree<P>::copy_or_move_values_in_order(Btree &other) {\n  static_assert(std::is_same<btree, Btree>::value ||\n                    std::is_same<const btree, Btree>::value,\n                \"Btree type must be same or const.\");\n  assert(empty());\n\n  // We can avoid key comparisons because we know the order of the\n  // values is the same order we'll store them in.\n  auto iter = other.begin();\n  if (iter == other.end()) return;\n  insert_multi(iter.slot());\n  ++iter;\n  for (; iter != other.end(); ++iter) {\n    // If the btree is not empty, we can just insert the new value at the end\n    // of the tree.\n    internal_emplace(end(), iter.slot());\n  }\n}\n\ntemplate <typename P>\nconstexpr bool btree<P>::static_assert_validation() {\n  static_assert(std::is_nothrow_copy_constructible<key_compare>::value,\n                \"Key comparison must be nothrow copy constructible\");\n  static_assert(std::is_nothrow_copy_constructible<allocator_type>::value,\n                \"Allocator must be nothrow copy constructible\");\n  static_assert(std::is_trivially_copyable<iterator>::value,\n                \"iterator not trivially copyable.\");\n\n  // Note: We assert that kTargetValues, which is computed from\n  // Params::kTargetNodeSize, must fit the node_type::field_type.\n  static_assert(\n      kNodeSlots < (1 << (8 * sizeof(typename node_type::field_type))),\n      \"target node size too large\");\n\n  // Verify that key_compare returns an absl::{weak,strong}_ordering or bool.\n  static_assert(\n      compare_has_valid_result_type<key_compare, key_type>(),\n      \"key comparison function must return absl::{weak,strong}_ordering or \"\n      \"bool.\");\n\n  // Test the assumption made in setting kNodeSlotSpace.\n  static_assert(node_type::MinimumOverhead() >= sizeof(void *) + 4,\n                \"node space assumption incorrect\");\n\n  return true;\n}\n\ntemplate <typename P>\ntemplate <typename K>\nauto btree<P>::lower_bound_equal(const K &key) const\n    -> std::pair<iterator, bool> {\n  const SearchResult<iterator, is_key_compare_to::value> res =\n      internal_lower_bound(key);\n  const iterator lower = iterator(internal_end(res.value));\n  const bool equal = res.HasMatch()\n                         ? res.IsEq()\n                         : lower != end() && !compare_keys(key, lower.key());\n  return {lower, equal};\n}\n\ntemplate <typename P>\ntemplate <typename K>\nauto btree<P>::equal_range(const K &key) -> std::pair<iterator, iterator> {\n  const std::pair<iterator, bool> lower_and_equal = lower_bound_equal(key);\n  const iterator lower = lower_and_equal.first;\n  if (!lower_and_equal.second) {\n    return {lower, lower};\n  }\n\n  const iterator next = std::next(lower);\n  if (!params_type::template can_have_multiple_equivalent_keys<K>()) {\n    // The next iterator after lower must point to a key greater than `key`.\n    // Note: if this assert fails, then it may indicate that the comparator does\n    // not meet the equivalence requirements for Compare\n    // (see https://en.cppreference.com/w/cpp/named_req/Compare).\n    assert(next == end() || compare_keys(key, next.key()));\n    return {lower, next};\n  }\n  // Try once more to avoid the call to upper_bound() if there's only one\n  // equivalent key. This should prevent all calls to upper_bound() in cases of\n  // unique-containers with heterogeneous comparators in which all comparison\n  // operators have the same equivalence classes.\n  if (next == end() || compare_keys(key, next.key())) return {lower, next};\n\n  // In this case, we need to call upper_bound() to avoid worst case O(N)\n  // behavior if we were to iterate over equal keys.\n  return {lower, upper_bound(key)};\n}\n\ntemplate <typename P>\ntemplate <typename K, typename... Args>\nauto btree<P>::insert_unique(const K &key, Args &&...args)\n    -> std::pair<iterator, bool> {\n  if (empty()) {\n    mutable_root() = mutable_rightmost() = new_leaf_root_node(1);\n  }\n\n  SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);\n  iterator iter = res.value;\n\n  if (res.HasMatch()) {\n    if (res.IsEq()) {\n      // The key already exists in the tree, do nothing.\n      return {iter, false};\n    }\n  } else {\n    iterator last = internal_last(iter);\n    if (last.node_ && !compare_keys(key, last.key())) {\n      // The key already exists in the tree, do nothing.\n      return {last, false};\n    }\n  }\n  return {internal_emplace(iter, std::forward<Args>(args)...), true};\n}\n\ntemplate <typename P>\ntemplate <typename K, typename... Args>\ninline auto btree<P>::insert_hint_unique(iterator position, const K &key,\n                                         Args &&...args)\n    -> std::pair<iterator, bool> {\n  if (!empty()) {\n    if (position == end() || compare_keys(key, position.key())) {\n      if (position == begin() || compare_keys(std::prev(position).key(), key)) {\n        // prev.key() < key < position.key()\n        return {internal_emplace(position, std::forward<Args>(args)...), true};\n      }\n    } else if (compare_keys(position.key(), key)) {\n      ++position;\n      if (position == end() || compare_keys(key, position.key())) {\n        // {original `position`}.key() < key < {current `position`}.key()\n        return {internal_emplace(position, std::forward<Args>(args)...), true};\n      }\n    } else {\n      // position.key() == key\n      return {position, false};\n    }\n  }\n  return insert_unique(key, std::forward<Args>(args)...);\n}\n\ntemplate <typename P>\ntemplate <typename InputIterator, typename>\nvoid btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, int) {\n  for (; b != e; ++b) {\n    insert_hint_unique(end(), params_type::key(*b), *b);\n  }\n}\n\ntemplate <typename P>\ntemplate <typename InputIterator>\nvoid btree<P>::insert_iterator_unique(InputIterator b, InputIterator e, char) {\n  for (; b != e; ++b) {\n    // Use a node handle to manage a temp slot.\n    auto node_handle =\n        CommonAccess::Construct<node_handle_type>(get_allocator(), *b);\n    slot_type *slot = CommonAccess::GetSlot(node_handle);\n    insert_hint_unique(end(), params_type::key(slot), slot);\n  }\n}\n\ntemplate <typename P>\ntemplate <typename ValueType>\nauto btree<P>::insert_multi(const key_type &key, ValueType &&v) -> iterator {\n  if (empty()) {\n    mutable_root() = mutable_rightmost() = new_leaf_root_node(1);\n  }\n\n  iterator iter = internal_upper_bound(key);\n  if (iter.node_ == nullptr) {\n    iter = end();\n  }\n  return internal_emplace(iter, std::forward<ValueType>(v));\n}\n\ntemplate <typename P>\ntemplate <typename ValueType>\nauto btree<P>::insert_hint_multi(iterator position, ValueType &&v) -> iterator {\n  if (!empty()) {\n    const key_type &key = params_type::key(v);\n    if (position == end() || !compare_keys(position.key(), key)) {\n      if (position == begin() ||\n          !compare_keys(key, std::prev(position).key())) {\n        // prev.key() <= key <= position.key()\n        return internal_emplace(position, std::forward<ValueType>(v));\n      }\n    } else {\n      ++position;\n      if (position == end() || !compare_keys(position.key(), key)) {\n        // {original `position`}.key() < key < {current `position`}.key()\n        return internal_emplace(position, std::forward<ValueType>(v));\n      }\n    }\n  }\n  return insert_multi(std::forward<ValueType>(v));\n}\n\ntemplate <typename P>\ntemplate <typename InputIterator>\nvoid btree<P>::insert_iterator_multi(InputIterator b, InputIterator e) {\n  for (; b != e; ++b) {\n    insert_hint_multi(end(), *b);\n  }\n}\n\ntemplate <typename P>\nauto btree<P>::operator=(const btree &other) -> btree & {\n  if (this != &other) {\n    clear();\n\n    *mutable_key_comp() = other.key_comp();\n    if (absl::allocator_traits<\n            allocator_type>::propagate_on_container_copy_assignment::value) {\n      *mutable_allocator() = other.allocator();\n    }\n\n    copy_or_move_values_in_order(other);\n  }\n  return *this;\n}\n\ntemplate <typename P>\nauto btree<P>::operator=(btree &&other) noexcept -> btree & {\n  if (this != &other) {\n    clear();\n\n    using std::swap;\n    if (absl::allocator_traits<\n            allocator_type>::propagate_on_container_move_assignment::value) {\n      swap(root_, other.root_);\n      // Note: `rightmost_` also contains the allocator and the key comparator.\n      swap(rightmost_, other.rightmost_);\n      swap(size_, other.size_);\n    } else {\n      if (allocator() == other.allocator()) {\n        swap(mutable_root(), other.mutable_root());\n        swap(*mutable_key_comp(), *other.mutable_key_comp());\n        swap(mutable_rightmost(), other.mutable_rightmost());\n        swap(size_, other.size_);\n      } else {\n        // We aren't allowed to propagate the allocator and the allocator is\n        // different so we can't take over its memory. We must move each element\n        // individually. We need both `other` and `this` to have `other`s key\n        // comparator while moving the values so we can't swap the key\n        // comparators.\n        *mutable_key_comp() = other.key_comp();\n        copy_or_move_values_in_order(other);\n      }\n    }\n  }\n  return *this;\n}\n\ntemplate <typename P>\nauto btree<P>::erase(iterator iter) -> iterator {\n  iter.node_->value_destroy(static_cast<field_type>(iter.position_),\n                            mutable_allocator());\n  iter.update_generation();\n\n  const bool internal_delete = iter.node_->is_internal();\n  if (internal_delete) {\n    // Deletion of a value on an internal node. First, transfer the largest\n    // value from our left child here, then erase/rebalance from that position.\n    // We can get to the largest value from our left child by decrementing iter.\n    iterator internal_iter(iter);\n    --iter;\n    assert(iter.node_->is_leaf());\n    internal_iter.node_->transfer(\n        static_cast<size_type>(internal_iter.position_),\n        static_cast<size_type>(iter.position_), iter.node_,\n        mutable_allocator());\n  } else {\n    // Shift values after erased position in leaf. In the internal case, we\n    // don't need to do this because the leaf position is the end of the node.\n    const field_type transfer_from =\n        static_cast<field_type>(iter.position_ + 1);\n    const field_type num_to_transfer = iter.node_->finish() - transfer_from;\n    iter.node_->transfer_n(num_to_transfer,\n                           static_cast<size_type>(iter.position_),\n                           transfer_from, iter.node_, mutable_allocator());\n  }\n  // Update node finish and container size.\n  iter.node_->set_finish(iter.node_->finish() - 1);\n  --size_;\n\n  // We want to return the next value after the one we just erased. If we\n  // erased from an internal node (internal_delete == true), then the next\n  // value is ++(++iter). If we erased from a leaf node (internal_delete ==\n  // false) then the next value is ++iter. Note that ++iter may point to an\n  // internal node and the value in the internal node may move to a leaf node\n  // (iter.node_) when rebalancing is performed at the leaf level.\n\n  iterator res = rebalance_after_delete(iter);\n\n  // If we erased from an internal node, advance the iterator.\n  if (internal_delete) {\n    ++res;\n  }\n  return res;\n}\n\ntemplate <typename P>\nauto btree<P>::rebalance_after_delete(iterator iter) -> iterator {\n  // Merge/rebalance as we walk back up the tree.\n  iterator res(iter);\n  bool first_iteration = true;\n  for (;;) {\n    if (iter.node_ == root()) {\n      try_shrink();\n      if (empty()) {\n        return end();\n      }\n      break;\n    }\n    if (iter.node_->count() >= kMinNodeValues) {\n      break;\n    }\n    bool merged = try_merge_or_rebalance(&iter);\n    // On the first iteration, we should update `res` with `iter` because `res`\n    // may have been invalidated.\n    if (first_iteration) {\n      res = iter;\n      first_iteration = false;\n    }\n    if (!merged) {\n      break;\n    }\n    iter.position_ = iter.node_->position();\n    iter.node_ = iter.node_->parent();\n  }\n  res.update_generation();\n\n  // Adjust our return value. If we're pointing at the end of a node, advance\n  // the iterator.\n  if (res.position_ == res.node_->finish()) {\n    res.position_ = res.node_->finish() - 1;\n    ++res;\n  }\n\n  return res;\n}\n\n// Note: we tried implementing this more efficiently by erasing all of the\n// elements in [begin, end) at once and then doing rebalancing once at the end\n// (rather than interleaving deletion and rebalancing), but that adds a lot of\n// complexity, which seems to outweigh the performance win.\ntemplate <typename P>\nauto btree<P>::erase_range(iterator begin, iterator end)\n    -> std::pair<size_type, iterator> {\n  size_type count = static_cast<size_type>(end - begin);\n  assert(count >= 0);\n\n  if (count == 0) {\n    return {0, begin};\n  }\n\n  if (static_cast<size_type>(count) == size_) {\n    clear();\n    return {count, this->end()};\n  }\n\n  if (begin.node_ == end.node_) {\n    assert(end.position_ > begin.position_);\n    begin.node_->remove_values(\n        static_cast<field_type>(begin.position_),\n        static_cast<field_type>(end.position_ - begin.position_),\n        mutable_allocator());\n    size_ -= count;\n    return {count, rebalance_after_delete(begin)};\n  }\n\n  const size_type target_size = size_ - count;\n  while (size_ > target_size) {\n    if (begin.node_->is_leaf()) {\n      const size_type remaining_to_erase = size_ - target_size;\n      const size_type remaining_in_node =\n          static_cast<size_type>(begin.node_->finish() - begin.position_);\n      const field_type to_erase = static_cast<field_type>(\n          (std::min)(remaining_to_erase, remaining_in_node));\n      begin.node_->remove_values(static_cast<field_type>(begin.position_),\n                                 to_erase, mutable_allocator());\n      size_ -= to_erase;\n      begin = rebalance_after_delete(begin);\n    } else {\n      begin = erase(begin);\n    }\n  }\n  begin.update_generation();\n  return {count, begin};\n}\n\ntemplate <typename P>\nvoid btree<P>::clear() {\n  if (!empty()) {\n    node_type::clear_and_delete(root(), mutable_allocator());\n  }\n  mutable_root() = mutable_rightmost() = EmptyNode();\n  size_ = 0;\n}\n\ntemplate <typename P>\nvoid btree<P>::swap(btree &other) {\n  using std::swap;\n  if (absl::allocator_traits<\n          allocator_type>::propagate_on_container_swap::value) {\n    // Note: `rightmost_` also contains the allocator and the key comparator.\n    swap(rightmost_, other.rightmost_);\n  } else {\n    // It's undefined behavior if the allocators are unequal here.\n    assert(allocator() == other.allocator());\n    swap(mutable_rightmost(), other.mutable_rightmost());\n    swap(*mutable_key_comp(), *other.mutable_key_comp());\n  }\n  swap(mutable_root(), other.mutable_root());\n  swap(size_, other.size_);\n}\n\ntemplate <typename P>\nvoid btree<P>::verify() const {\n  assert(root() != nullptr);\n  assert(leftmost() != nullptr);\n  assert(rightmost() != nullptr);\n  assert(empty() || size() == internal_verify(root(), nullptr, nullptr));\n  assert(leftmost() == (++const_iterator(root(), -1)).node_);\n  assert(rightmost() == (--const_iterator(root(), root()->finish())).node_);\n  assert(leftmost()->is_leaf());\n  assert(rightmost()->is_leaf());\n}\n\ntemplate <typename P>\nvoid btree<P>::rebalance_or_split(iterator *iter) {\n  node_type *&node = iter->node_;\n  int &insert_position = iter->position_;\n  assert(node->count() == node->max_count());\n  assert(kNodeSlots == node->max_count());\n\n  // First try to make room on the node by rebalancing.\n  node_type *parent = node->parent();\n  if (node != root()) {\n    if (node->position() > parent->start()) {\n      // Try rebalancing with our left sibling.\n      node_type *left = parent->child(node->position() - 1);\n      assert(left->max_count() == kNodeSlots);\n      if (left->count() < kNodeSlots) {\n        // We bias rebalancing based on the position being inserted. If we're\n        // inserting at the end of the right node then we bias rebalancing to\n        // fill up the left node.\n        field_type to_move =\n            (kNodeSlots - left->count()) /\n            (1 + (static_cast<field_type>(insert_position) < kNodeSlots));\n        to_move = (std::max)(field_type{1}, to_move);\n\n        if (static_cast<field_type>(insert_position) - to_move >=\n                node->start() ||\n            left->count() + to_move < kNodeSlots) {\n          left->rebalance_right_to_left(to_move, node, mutable_allocator());\n\n          assert(node->max_count() - node->count() == to_move);\n          insert_position = static_cast<int>(\n              static_cast<field_type>(insert_position) - to_move);\n          if (insert_position < node->start()) {\n            insert_position = insert_position + left->count() + 1;\n            node = left;\n          }\n\n          assert(node->count() < node->max_count());\n          return;\n        }\n      }\n    }\n\n    if (node->position() < parent->finish()) {\n      // Try rebalancing with our right sibling.\n      node_type *right = parent->child(node->position() + 1);\n      assert(right->max_count() == kNodeSlots);\n      if (right->count() < kNodeSlots) {\n        // We bias rebalancing based on the position being inserted. If we're\n        // inserting at the beginning of the left node then we bias rebalancing\n        // to fill up the right node.\n        field_type to_move = (kNodeSlots - right->count()) /\n                             (1 + (insert_position > node->start()));\n        to_move = (std::max)(field_type{1}, to_move);\n\n        if (static_cast<field_type>(insert_position) <=\n                node->finish() - to_move ||\n            right->count() + to_move < kNodeSlots) {\n          node->rebalance_left_to_right(to_move, right, mutable_allocator());\n\n          if (insert_position > node->finish()) {\n            insert_position = insert_position - node->count() - 1;\n            node = right;\n          }\n\n          assert(node->count() < node->max_count());\n          return;\n        }\n      }\n    }\n\n    // Rebalancing failed, make sure there is room on the parent node for a new\n    // value.\n    assert(parent->max_count() == kNodeSlots);\n    if (parent->count() == kNodeSlots) {\n      iterator parent_iter(parent, node->position());\n      rebalance_or_split(&parent_iter);\n      parent = node->parent();\n    }\n  } else {\n    // Rebalancing not possible because this is the root node.\n    // Create a new root node and set the current root node as the child of the\n    // new root.\n    parent = new_internal_node(/*position=*/0, parent);\n    parent->set_generation(root()->generation());\n    parent->init_child(parent->start(), node);\n    mutable_root() = parent;\n    // If the former root was a leaf node, then it's now the rightmost node.\n    assert(parent->start_child()->is_internal() ||\n           parent->start_child() == rightmost());\n  }\n\n  // Split the node.\n  node_type *split_node;\n  if (node->is_leaf()) {\n    split_node = new_leaf_node(node->position() + 1, parent);\n    node->split(insert_position, split_node, mutable_allocator());\n    if (rightmost() == node) mutable_rightmost() = split_node;\n  } else {\n    split_node = new_internal_node(node->position() + 1, parent);\n    node->split(insert_position, split_node, mutable_allocator());\n  }\n\n  if (insert_position > node->finish()) {\n    insert_position = insert_position - node->count() - 1;\n    node = split_node;\n  }\n}\n\ntemplate <typename P>\nvoid btree<P>::merge_nodes(node_type *left, node_type *right) {\n  left->merge(right, mutable_allocator());\n  if (rightmost() == right) mutable_rightmost() = left;\n}\n\ntemplate <typename P>\nbool btree<P>::try_merge_or_rebalance(iterator *iter) {\n  node_type *parent = iter->node_->parent();\n  if (iter->node_->position() > parent->start()) {\n    // Try merging with our left sibling.\n    node_type *left = parent->child(iter->node_->position() - 1);\n    assert(left->max_count() == kNodeSlots);\n    if (1U + left->count() + iter->node_->count() <= kNodeSlots) {\n      iter->position_ += 1 + left->count();\n      merge_nodes(left, iter->node_);\n      iter->node_ = left;\n      return true;\n    }\n  }\n  if (iter->node_->position() < parent->finish()) {\n    // Try merging with our right sibling.\n    node_type *right = parent->child(iter->node_->position() + 1);\n    assert(right->max_count() == kNodeSlots);\n    if (1U + iter->node_->count() + right->count() <= kNodeSlots) {\n      merge_nodes(iter->node_, right);\n      return true;\n    }\n    // Try rebalancing with our right sibling. We don't perform rebalancing if\n    // we deleted the first element from iter->node_ and the node is not\n    // empty. This is a small optimization for the common pattern of deleting\n    // from the front of the tree.\n    if (right->count() > kMinNodeValues &&\n        (iter->node_->count() == 0 || iter->position_ > iter->node_->start())) {\n      field_type to_move = (right->count() - iter->node_->count()) / 2;\n      to_move =\n          (std::min)(to_move, static_cast<field_type>(right->count() - 1));\n      iter->node_->rebalance_right_to_left(to_move, right, mutable_allocator());\n      return false;\n    }\n  }\n  if (iter->node_->position() > parent->start()) {\n    // Try rebalancing with our left sibling. We don't perform rebalancing if\n    // we deleted the last element from iter->node_ and the node is not\n    // empty. This is a small optimization for the common pattern of deleting\n    // from the back of the tree.\n    node_type *left = parent->child(iter->node_->position() - 1);\n    if (left->count() > kMinNodeValues &&\n        (iter->node_->count() == 0 ||\n         iter->position_ < iter->node_->finish())) {\n      field_type to_move = (left->count() - iter->node_->count()) / 2;\n      to_move = (std::min)(to_move, static_cast<field_type>(left->count() - 1));\n      left->rebalance_left_to_right(to_move, iter->node_, mutable_allocator());\n      iter->position_ += to_move;\n      return false;\n    }\n  }\n  return false;\n}\n\ntemplate <typename P>\nvoid btree<P>::try_shrink() {\n  node_type *orig_root = root();\n  if (orig_root->count() > 0) {\n    return;\n  }\n  // Deleted the last item on the root node, shrink the height of the tree.\n  if (orig_root->is_leaf()) {\n    assert(size() == 0);\n    mutable_root() = mutable_rightmost() = EmptyNode();\n  } else {\n    node_type *child = orig_root->start_child();\n    child->make_root();\n    mutable_root() = child;\n  }\n  node_type::clear_and_delete(orig_root, mutable_allocator());\n}\n\ntemplate <typename P>\ntemplate <typename IterType>\ninline IterType btree<P>::internal_last(IterType iter) {\n  assert(iter.node_ != nullptr);\n  while (iter.position_ == iter.node_->finish()) {\n    iter.position_ = iter.node_->position();\n    iter.node_ = iter.node_->parent();\n    if (iter.node_->is_leaf()) {\n      iter.node_ = nullptr;\n      break;\n    }\n  }\n  iter.update_generation();\n  return iter;\n}\n\ntemplate <typename P>\ntemplate <typename... Args>\ninline auto btree<P>::internal_emplace(iterator iter, Args &&...args)\n    -> iterator {\n  if (iter.node_->is_internal()) {\n    // We can't insert on an internal node. Instead, we'll insert after the\n    // previous value which is guaranteed to be on a leaf node.\n    --iter;\n    ++iter.position_;\n  }\n  const field_type max_count = iter.node_->max_count();\n  allocator_type *alloc = mutable_allocator();\n\n  const auto transfer_and_delete = [&](node_type *old_node,\n                                       node_type *new_node) {\n    new_node->transfer_n(old_node->count(), new_node->start(),\n                         old_node->start(), old_node, alloc);\n    new_node->set_finish(old_node->finish());\n    old_node->set_finish(old_node->start());\n    new_node->set_generation(old_node->generation());\n    node_type::clear_and_delete(old_node, alloc);\n  };\n  const auto replace_leaf_root_node = [&](field_type new_node_size) {\n    assert(iter.node_ == root());\n    node_type *old_root = iter.node_;\n    node_type *new_root = iter.node_ = new_leaf_root_node(new_node_size);\n    transfer_and_delete(old_root, new_root);\n    mutable_root() = mutable_rightmost() = new_root;\n  };\n\n  bool replaced_node = false;\n  if (iter.node_->count() == max_count) {\n    // Make room in the leaf for the new item.\n    if (max_count < kNodeSlots) {\n      // Insertion into the root where the root is smaller than the full node\n      // size. Simply grow the size of the root node.\n      replace_leaf_root_node(static_cast<field_type>(\n          (std::min)(static_cast<int>(kNodeSlots), 2 * max_count)));\n      replaced_node = true;\n    } else {\n      rebalance_or_split(&iter);\n    }\n  }\n  (void)replaced_node;\n#if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \\\n    defined(ABSL_HAVE_HWADDRESS_SANITIZER)\n  if (!replaced_node) {\n    assert(iter.node_->is_leaf());\n    if (iter.node_->is_root()) {\n      replace_leaf_root_node(max_count);\n    } else {\n      node_type *old_node = iter.node_;\n      const bool was_rightmost = rightmost() == old_node;\n      const bool was_leftmost = leftmost() == old_node;\n      node_type *parent = old_node->parent();\n      const field_type position = old_node->position();\n      node_type *new_node = iter.node_ = new_leaf_node(position, parent);\n      parent->set_child_noupdate_position(position, new_node);\n      transfer_and_delete(old_node, new_node);\n      if (was_rightmost) mutable_rightmost() = new_node;\n      // The leftmost node is stored as the parent of the root node.\n      if (was_leftmost) root()->set_parent(new_node);\n    }\n  }\n#endif\n  iter.node_->emplace_value(static_cast<field_type>(iter.position_), alloc,\n                            std::forward<Args>(args)...);\n  assert(\n      iter.node_->is_ordered_correctly(static_cast<field_type>(iter.position_),\n                                       original_key_compare(key_comp())) &&\n      \"If this assert fails, then either (1) the comparator may violate \"\n      \"transitivity, i.e. comp(a,b) && comp(b,c) -> comp(a,c) (see \"\n      \"https://en.cppreference.com/w/cpp/named_req/Compare), or (2) a \"\n      \"key may have been mutated after it was inserted into the tree.\");\n  ++size_;\n  iter.update_generation();\n  return iter;\n}\n\ntemplate <typename P>\ntemplate <typename K>\ninline auto btree<P>::internal_locate(const K &key) const\n    -> SearchResult<iterator, is_key_compare_to::value> {\n  iterator iter(const_cast<node_type *>(root()));\n  for (;;) {\n    SearchResult<size_type, is_key_compare_to::value> res =\n        iter.node_->lower_bound(key, key_comp());\n    iter.position_ = static_cast<int>(res.value);\n    if (res.IsEq()) {\n      return {iter, MatchKind::kEq};\n    }\n    // Note: in the non-key-compare-to case, we don't need to walk all the way\n    // down the tree if the keys are equal, but determining equality would\n    // require doing an extra comparison on each node on the way down, and we\n    // will need to go all the way to the leaf node in the expected case.\n    if (iter.node_->is_leaf()) {\n      break;\n    }\n    iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));\n  }\n  // Note: in the non-key-compare-to case, the key may actually be equivalent\n  // here (and the MatchKind::kNe is ignored).\n  return {iter, MatchKind::kNe};\n}\n\ntemplate <typename P>\ntemplate <typename K>\nauto btree<P>::internal_lower_bound(const K &key) const\n    -> SearchResult<iterator, is_key_compare_to::value> {\n  if (!params_type::template can_have_multiple_equivalent_keys<K>()) {\n    SearchResult<iterator, is_key_compare_to::value> ret = internal_locate(key);\n    ret.value = internal_last(ret.value);\n    return ret;\n  }\n  iterator iter(const_cast<node_type *>(root()));\n  SearchResult<size_type, is_key_compare_to::value> res;\n  bool seen_eq = false;\n  for (;;) {\n    res = iter.node_->lower_bound(key, key_comp());\n    iter.position_ = static_cast<int>(res.value);\n    if (iter.node_->is_leaf()) {\n      break;\n    }\n    seen_eq = seen_eq || res.IsEq();\n    iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));\n  }\n  if (res.IsEq()) return {iter, MatchKind::kEq};\n  return {internal_last(iter), seen_eq ? MatchKind::kEq : MatchKind::kNe};\n}\n\ntemplate <typename P>\ntemplate <typename K>\nauto btree<P>::internal_upper_bound(const K &key) const -> iterator {\n  iterator iter(const_cast<node_type *>(root()));\n  for (;;) {\n    iter.position_ = static_cast<int>(iter.node_->upper_bound(key, key_comp()));\n    if (iter.node_->is_leaf()) {\n      break;\n    }\n    iter.node_ = iter.node_->child(static_cast<field_type>(iter.position_));\n  }\n  return internal_last(iter);\n}\n\ntemplate <typename P>\ntemplate <typename K>\nauto btree<P>::internal_find(const K &key) const -> iterator {\n  SearchResult<iterator, is_key_compare_to::value> res = internal_locate(key);\n  if (res.HasMatch()) {\n    if (res.IsEq()) {\n      return res.value;\n    }\n  } else {\n    const iterator iter = internal_last(res.value);\n    if (iter.node_ != nullptr && !compare_keys(key, iter.key())) {\n      return iter;\n    }\n  }\n  return {nullptr, 0};\n}\n\ntemplate <typename P>\ntypename btree<P>::size_type btree<P>::internal_verify(\n    const node_type *node, const key_type *lo, const key_type *hi) const {\n  assert(node->count() > 0);\n  assert(node->count() <= node->max_count());\n  if (lo) {\n    assert(!compare_keys(node->key(node->start()), *lo));\n  }\n  if (hi) {\n    assert(!compare_keys(*hi, node->key(node->finish() - 1)));\n  }\n  for (int i = node->start() + 1; i < node->finish(); ++i) {\n    assert(!compare_keys(node->key(i), node->key(i - 1)));\n  }\n  size_type count = node->count();\n  if (node->is_internal()) {\n    for (field_type i = node->start(); i <= node->finish(); ++i) {\n      assert(node->child(i) != nullptr);\n      assert(node->child(i)->parent() == node);\n      assert(node->child(i)->position() == i);\n      count += internal_verify(node->child(i),\n                               i == node->start() ? lo : &node->key(i - 1),\n                               i == node->finish() ? hi : &node->key(i));\n    }\n  }\n  return count;\n}\n\nstruct btree_access {\n  template <typename BtreeContainer, typename Pred>\n  static auto erase_if(BtreeContainer &container, Pred pred) ->\n      typename BtreeContainer::size_type {\n    const auto initial_size = container.size();\n    auto &tree = container.tree_;\n    auto *alloc = tree.mutable_allocator();\n    for (auto it = container.begin(); it != container.end();) {\n      if (!pred(*it)) {\n        ++it;\n        continue;\n      }\n      auto *node = it.node_;\n      if (node->is_internal()) {\n        // Handle internal nodes normally.\n        it = container.erase(it);\n        continue;\n      }\n      // If this is a leaf node, then we do all the erases from this node\n      // at once before doing rebalancing.\n\n      // The current position to transfer slots to.\n      int to_pos = it.position_;\n      node->value_destroy(it.position_, alloc);\n      while (++it.position_ < node->finish()) {\n        it.update_generation();\n        if (pred(*it)) {\n          node->value_destroy(it.position_, alloc);\n        } else {\n          node->transfer(node->slot(to_pos++), node->slot(it.position_), alloc);\n        }\n      }\n      const int num_deleted = node->finish() - to_pos;\n      tree.size_ -= num_deleted;\n      node->set_finish(to_pos);\n      it.position_ = to_pos;\n      it = tree.rebalance_after_delete(it);\n    }\n    return initial_size - container.size();\n  }\n};\n\n#undef ABSL_BTREE_ENABLE_GENERATIONS\n\n}",
  "id": "BLOCK-CPP-04874",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree.h",
  "source_line": 313,
  "validation_status": "validated"
}