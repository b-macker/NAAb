{
  "code": "{\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = discrete_distribution;\n\n    param_type() { init(); }\n\n    template <typename InputIterator>\n    explicit param_type(InputIterator begin, InputIterator end)\n        : p_(begin, end) {\n      init();\n    }\n\n    explicit param_type(std::initializer_list<double> weights) : p_(weights) {\n      init();\n    }\n\n    template <class UnaryOperation>\n    explicit param_type(size_t nw, double xmin, double xmax,\n                        UnaryOperation fw) {\n      if (nw > 0) {\n        p_.reserve(nw);\n        double delta = (xmax - xmin) / static_cast<double>(nw);\n        assert(delta > 0);\n        double t = delta * 0.5;\n        for (size_t i = 0; i < nw; ++i) {\n          p_.push_back(fw(xmin + i * delta + t));\n        }\n      }\n      init();\n    }\n\n    const std::vector<double>& probabilities() const { return p_; }\n    size_t n() const { return p_.size() - 1; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.probabilities() == b.probabilities();\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class discrete_distribution;\n\n    void init();\n\n    std::vector<double> p_;                     // normalized probabilities\n    std::vector<std::pair<double, size_t>> q_;  // (acceptance, alternate) pairs\n\n    static_assert(std::is_integral<result_type>::value,\n                  \"Class-template absl::discrete_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  discrete_distribution() : param_() {}\n\n  explicit discrete_distribution(const param_type& p) : param_(p) {}\n\n  template <typename InputIterator>\n  explicit discrete_distribution(InputIterator begin, InputIterator end)\n      : param_(begin, end) {}\n\n  explicit discrete_distribution(std::initializer_list<double> weights)\n      : param_(weights) {}\n\n  template <class UnaryOperation>\n  explicit discrete_distribution(size_t nw, double xmin, double xmax,\n                                 UnaryOperation fw)\n      : param_(nw, xmin, xmax, std::move(fw)) {}\n\n  void reset() {}\n\n  // generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  const param_type& param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const {\n    return static_cast<result_type>(param_.n());\n  }  // inclusive\n\n  // NOTE [rand.dist.sample.discrete] returns a std::vector<double> not a\n  // const std::vector<double>&.\n  const std::vector<double>& probabilities() const {\n    return param_.probabilities();\n  }\n\n  friend bool operator==(const discrete_distribution& a,\n                         const discrete_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const discrete_distribution& a,\n                         const discrete_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n}",
  "id": "BLOCK-CPP-03830",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/discrete_distribution.h",
  "source_line": 51,
  "validation_status": "validated"
}