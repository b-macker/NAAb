{
  "code": "#include \"clang/ExtractAPI/API.h\"\n#include \"clang/ExtractAPI/APIIgnoresList.h\"\n#include \"clang/ExtractAPI/Serialization/SerializerBase.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <optional>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-22109_execute() {\n    {\nnamespace extractapi {\n\nusing namespace llvm::json;\n\n/// Common options to customize the visitor output.\nstruct SymbolGraphSerializerOption {\n  /// Do not include unnecessary whitespaces to save space.\n  bool Compact;\n};\n\n/// The visitor that organizes API information in the Symbol Graph format.\n///\n/// The Symbol Graph format (https://github.com/apple/swift-docc-symbolkit)\n/// models an API set as a directed graph, where nodes are symbol declarations,\n/// and edges are relationships between the connected symbols.\nclass SymbolGraphSerializer : public APISetVisitor<SymbolGraphSerializer> {\n  /// A JSON array of formatted symbols in \\c APISet.\n  Array Symbols;\n\n  /// A JSON array of formatted symbol relationships in \\c APISet.\n  Array Relationships;\n\n  /// The Symbol Graph format version used by this serializer.\n  static const VersionTuple FormatVersion;\n\n  /// Indicates whether child symbols should be visited. This is mainly\n  /// useful for \\c serializeSingleSymbolSGF.\n  bool ShouldRecurse;\n\npublic:\n  /// Serialize the APIs in \\c APISet in the Symbol Graph format.\n  ///\n  /// \\returns a JSON object that contains the root of the formatted\n  /// Symbol Graph.\n  Object serialize();\n\n  ///  Wrap serialize(void) and write out the serialized JSON object to \\p os.\n  void serialize(raw_ostream &os);\n\n  /// Serialize a single symbol SGF. This is primarily used for libclang.\n  ///\n  /// \\returns an optional JSON Object representing the payload that libclang\n  /// expects for providing symbol information for a single symbol. If this is\n  /// not a known symbol returns \\c std::nullopt.\n  static std::optional<Object> serializeSingleSymbolSGF(StringRef USR,\n                                                        const APISet &API);\n\n  /// The kind of a relationship between two symbols.\n  enum RelationshipKind {\n    /// The source symbol is a member of the target symbol.\n    /// For example enum constants are members of the enum, class/instance\n    /// methods are members of the class, etc.\n    MemberOf,\n\n    /// The source symbol is inherited from the target symbol.\n    InheritsFrom,\n\n    /// The source symbol conforms to the target symbol.\n    /// For example Objective-C protocol conformances.\n    ConformsTo,\n  };\n\n  /// Get the string representation of the relationship kind.\n  static StringRef getRelationshipString(RelationshipKind Kind);\n\nprivate:\n  /// Just serialize the currently recorded objects in Symbol Graph format.\n  Object serializeCurrentGraph();\n\n  /// Synthesize the metadata section of the Symbol Graph format.\n  ///\n  /// The metadata section describes information about the Symbol Graph itself,\n  /// including the format version and the generator information.\n  Object serializeMetadata() const;\n\n  /// Synthesize the module section of the Symbol Graph format.\n  ///\n  /// The module section contains information about the product that is defined\n  /// by the given API set.\n  /// Note that \"module\" here is not to be confused with the Clang/C++ module\n  /// concept.\n  Object serializeModule() const;\n\n  /// Determine if the given \\p Record should be skipped during serialization.\n  bool shouldSkip(const APIRecord &Record) const;\n\n  /// Format the common API information for \\p Record.\n  ///\n  /// This handles the shared information of all kinds of API records,\n  /// for example identifier and source location. The resulting object is then\n  /// augmented with kind-specific symbol information by the caller.\n  /// This method also checks if the given \\p Record should be skipped during\n  /// serialization.\n  ///\n  /// \\returns \\c std::nullopt if this \\p Record should be skipped, or a JSON\n  /// object containing common symbol information of \\p Record.\n  template <typename RecordTy>\n  std::optional<Object> serializeAPIRecord(const RecordTy &Record) const;\n\n  /// Helper method to serialize second-level member records of \\p Record and\n  /// the member-of relationships.\n  template <typename MemberTy>\n  void serializeMembers(const APIRecord &Record,\n                        const SmallVector<std::unique_ptr<MemberTy>> &Members);\n\n  /// Serialize the \\p Kind relationship between \\p Source and \\p Target.\n  ///\n  /// Record the relationship between the two symbols in\n  /// SymbolGraphSerializer::Relationships.\n  void serializeRelationship(RelationshipKind Kind, SymbolReference Source,\n                             SymbolReference Target);\n\nprotected:\n  /// The list of symbols to ignore.\n  ///\n  /// Note: This should be consulted before emitting a symbol.\n  const APIIgnoresList &IgnoresList;\n\n  SymbolGraphSerializerOption Options;\n\npublic:\n  /// Visit a global function record.\n  void visitGlobalFunctionRecord(const GlobalFunctionRecord &Record);\n\n  /// Visit a global variable record.\n  void visitGlobalVariableRecord(const GlobalVariableRecord &Record);\n\n  /// Visit an enum record.\n  void visitEnumRecord(const EnumRecord &Record);\n\n  /// Visit a struct record.\n  void visitStructRecord(const StructRecord &Record);\n\n  /// Visit an Objective-C container record.\n  void visitObjCContainerRecord(const ObjCContainerRecord &Record);\n\n  /// Visit a macro definition record.\n  void visitMacroDefinitionRecord(const MacroDefinitionRecord &Record);\n\n  /// Visit a typedef record.\n  void visitTypedefRecord(const TypedefRecord &Record);\n\n  /// Serialize a single record.\n  void serializeSingleRecord(const APIRecord *Record);\n\n  SymbolGraphSerializer(const APISet &API, const APIIgnoresList &IgnoresList,\n                        SymbolGraphSerializerOption Options = {},\n                        bool ShouldRecurse = true)\n      : APISetVisitor(API), ShouldRecurse(ShouldRecurse),\n        IgnoresList(IgnoresList), Options(Options) {}\n};\n\n} // namespace extractapi\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-22109",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ExtractAPI/Serialization/SymbolGraphSerializer.h",
  "source_line": 29,
  "validation_status": "validated"
}