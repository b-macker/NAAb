{
  "code": "{\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *,TypeSourceInfo *>;\n\nprivate:\n  // The number of template parameters;  always non-zero.\n  unsigned NumParams = 0;\n\n  // The parameter list.\n  TemplateParameterList **Params = nullptr;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  FriendTemplateDecl(DeclContext *DC, SourceLocation Loc,\n                     TemplateParameterList **Params, unsigned NumParams,\n                     FriendUnion Friend, SourceLocation FriendLoc)\n      : Decl(Decl::FriendTemplate, DC, Loc), NumParams(NumParams),\n        Params(Params), Friend(Friend), FriendLoc(FriendLoc) {}\n\n  FriendTemplateDecl(EmptyShell Empty) : Decl(Decl::FriendTemplate, Empty) {}\n\npublic:\n  friend class ASTDeclReader;\n\n  static FriendTemplateDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation Loc,\n         MutableArrayRef<TemplateParameterList *> Params, FriendUnion Friend,\n         SourceLocation FriendLoc);\n\n  static FriendTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// If this friend declaration names a templated type (or\n  /// a dependent member type of a templated type), return that\n  /// type;  otherwise return null.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// If this friend declaration names a templated function (or\n  /// a member function of a templated type), return that type;\n  /// otherwise return null.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl*>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i <= NumParams);\n    return Params[i];\n  }\n\n  unsigned getNumTemplateParameters() const {\n    return NumParams;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::FriendTemplate; }\n}",
  "id": "BLOCK-CPP-09368",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 2475,
  "validation_status": "validated"
}