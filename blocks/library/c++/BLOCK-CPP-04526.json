{
  "code": "{\n//       return absl::variant_size<Variant>() > 1;\n//   }\n//\n// Note that the set of cv-qualified specializations of `variant_size` are\n// provided to ensure that those specializations compile (especially when passed\n// within template logic).\ntemplate <class T>\nstruct variant_size;\n\ntemplate <class... Ts>\nstruct variant_size<variant<Ts...>>\n    : std::integral_constant<std::size_t, sizeof...(Ts)> {};\n\n// Specialization of `variant_size` for const qualified variants.\ntemplate <class T>\nstruct variant_size<const T> : variant_size<T>::type {};\n\n// Specialization of `variant_size` for volatile qualified variants.\ntemplate <class T>\nstruct variant_size<volatile T> : variant_size<T>::type {};\n\n// Specialization of `variant_size` for const volatile qualified variants.\ntemplate <class T>\nstruct variant_size<const volatile T> : variant_size<T>::type {};\n\n// variant_alternative\n//\n// Returns the alternative type for a given `absl::variant` at the passed\n// index value as a compile-time constant expression. As this is a class\n// template resulting in a type, it is not useful for access of the run-time\n// value of any given `absl::variant` variable.\n//\n// Example:\n//\n//   // The type of the 0th alternative is \"int\".\n//   using alternative_type_0\n//     = absl::variant_alternative<0, absl::variant<int, std::string>>::type;\n//\n//   static_assert(std::is_same<alternative_type_0, int>::value, \"\");\n//\n//   // `absl::variant_alternative` is more valuable for use in generic code:\n//   template <typename Variant>\n//   constexpr bool IsFirstElementTrivial() {\n//       return std::is_trivial_v<variant_alternative<0, Variant>::type>;\n//   }\n//\n// Note that the set of cv-qualified specializations of `variant_alternative`\n// are provided to ensure that those specializations compile (especially when\n// passed within template logic).\ntemplate <std::size_t I, class T>\nstruct variant_alternative;\n\ntemplate <std::size_t I, class... Types>\nstruct variant_alternative<I, variant<Types...>> {\n  using type =\n      variant_internal::VariantAlternativeSfinaeT<I, variant<Types...>>;\n};\n\n// Specialization of `variant_alternative` for const qualified variants.\ntemplate <std::size_t I, class T>\nstruct variant_alternative<I, const T> {\n  using type = const typename variant_alternative<I, T>::type;\n};\n\n// Specialization of `variant_alternative` for volatile qualified variants.\ntemplate <std::size_t I, class T>\nstruct variant_alternative<I, volatile T> {\n  using type = volatile typename variant_alternative<I, T>::type;\n};\n\n// Specialization of `variant_alternative` for const volatile qualified\n// variants.\ntemplate <std::size_t I, class T>\nstruct variant_alternative<I, const volatile T> {\n  using type = const volatile typename variant_alternative<I, T>::type;\n};\n\n// Template type alias for variant_alternative<I, T>::type.\n//\n// Example:\n//\n//   using alternative_type_0\n//     = absl::variant_alternative_t<0, absl::variant<int, std::string>>;\n//   static_assert(std::is_same<alternative_type_0, int>::value, \"\");\ntemplate <std::size_t I, class T>\nusing variant_alternative_t = typename variant_alternative<I, T>::type;\n\n// holds_alternative()\n//\n// Checks whether the given variant currently holds a given alternative type,\n// returning `true` if so.\n//\n// Example:\n//\n//   absl::variant<int, std::string> foo = 42;\n//   if (absl::holds_alternative<int>(foo)) {\n//       std::cout << \"The variant holds an integer\";\n//   }\ntemplate <class T, class... Types>\nconstexpr bool holds_alternative(const variant<Types...>& v) noexcept {\n  static_assert(\n      variant_internal::UnambiguousIndexOfImpl<variant<Types...>, T,\n                                               0>::value != sizeof...(Types),\n      \"The type T must occur exactly once in Types...\");\n  return v.index() ==\n         variant_internal::UnambiguousIndexOf<variant<Types...>, T>::value;\n}\n\n// get()\n//\n// Returns a reference to the value currently within a given variant, using\n// either a unique alternative type amongst the variant's set of alternative\n// types, or the variant's index value. Attempting to get a variant's value\n// using a type that is not unique within the variant's set of alternative types\n// is a compile-time error. If the index of the alternative being specified is\n// different from the index of the alternative that is currently stored, throws\n// `absl::bad_variant_access`.\n//\n// Example:\n//\n//   auto a = absl::variant<int, std::string>;\n//\n//   // Get the value by type (if unique).\n//   int i = absl::get<int>(a);\n//\n//   auto b = absl::variant<int, int>;\n//\n//   // Getting the value by a type that is not unique is ill-formed.\n//   int j = absl::get<int>(b);     // Compile Error!\n//\n//   // Getting value by index not ambiguous and allowed.\n//   int k = absl::get<1>(b);\n\n// Overload for getting a variant's lvalue by type.\ntemplate <class T, class... Types>\nconstexpr T& get(variant<Types...>& v) {  // NOLINT\n  return variant_internal::VariantCoreAccess::CheckedAccess<\n      variant_internal::IndexOf<T, Types...>::value>(v);\n}\n\n// Overload for getting a variant's rvalue by type.\n// Note: `absl::move()` is required to allow use of constexpr in C++11.\ntemplate <class T, class... Types>\nconstexpr T&& get(variant<Types...>&& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<\n      variant_internal::IndexOf<T, Types...>::value>(absl::move(v));\n}\n\n// Overload for getting a variant's const lvalue by type.\ntemplate <class T, class... Types>\nconstexpr const T& get(const variant<Types...>& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<\n      variant_internal::IndexOf<T, Types...>::value>(v);\n}\n\n// Overload for getting a variant's const rvalue by type.\n// Note: `absl::move()` is required to allow use of constexpr in C++11.\ntemplate <class T, class... Types>\nconstexpr const T&& get(const variant<Types...>&& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<\n      variant_internal::IndexOf<T, Types...>::value>(absl::move(v));\n}\n\n// Overload for getting a variant's lvalue by index.\ntemplate <std::size_t I, class... Types>\nconstexpr variant_alternative_t<I, variant<Types...>>& get(\n    variant<Types...>& v) {  // NOLINT\n  return variant_internal::VariantCoreAccess::CheckedAccess<I>(v);\n}\n\n// Overload for getting a variant's rvalue by index.\n// Note: `absl::move()` is required to allow use of constexpr in C++11.\ntemplate <std::size_t I, class... Types>\nconstexpr variant_alternative_t<I, variant<Types...>>&& get(\n    variant<Types...>&& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<I>(absl::move(v));\n}\n\n// Overload for getting a variant's const lvalue by index.\ntemplate <std::size_t I, class... Types>\nconstexpr const variant_alternative_t<I, variant<Types...>>& get(\n    const variant<Types...>& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<I>(v);\n}\n\n// Overload for getting a variant's const rvalue by index.\n// Note: `absl::move()` is required to allow use of constexpr in C++11.\ntemplate <std::size_t I, class... Types>\nconstexpr const variant_alternative_t<I, variant<Types...>>&& get(\n    const variant<Types...>&& v) {\n  return variant_internal::VariantCoreAccess::CheckedAccess<I>(absl::move(v));\n}\n\n// get_if()\n//\n// Returns a pointer to the value currently stored within a given variant, if\n// present, using either a unique alternative type amongst the variant's set of\n// alternative types, or the variant's index value. If such a value does not\n// exist, returns `nullptr`.\n//\n// As with `get`, attempting to get a variant's value using a type that is not\n// unique within the variant's set of alternative types is a compile-time error.\n\n// Overload for getting a pointer to the value stored in the given variant by\n// index.\ntemplate <std::size_t I, class... Types>\nconstexpr absl::add_pointer_t<variant_alternative_t<I, variant<Types...>>>\nget_if(variant<Types...>* v) noexcept {\n  return (v != nullptr && v->index() == I)\n             ? std::addressof(\n                   variant_internal::VariantCoreAccess::Access<I>(*v))\n             : nullptr;\n}\n\n// Overload for getting a pointer to the const value stored in the given\n// variant by index.\ntemplate <std::size_t I, class... Types>\nconstexpr absl::add_pointer_t<const variant_alternative_t<I, variant<Types...>>>\nget_if(const variant<Types...>* v) noexcept {\n  return (v != nullptr && v->index() == I)\n             ? std::addressof(\n                   variant_internal::VariantCoreAccess::Access<I>(*v))\n             : nullptr;\n}\n\n// Overload for getting a pointer to the value stored in the given variant by\n// type.\ntemplate <class T, class... Types>\nconstexpr absl::add_pointer_t<T> get_if(variant<Types...>* v) noexcept {\n  return absl::get_if<variant_internal::IndexOf<T, Types...>::value>(v);\n}\n\n// Overload for getting a pointer to the const value stored in the given variant\n// by type.\ntemplate <class T, class... Types>\nconstexpr absl::add_pointer_t<const T> get_if(\n    const variant<Types...>* v) noexcept {\n  return absl::get_if<variant_internal::IndexOf<T, Types...>::value>(v);\n}\n\n// visit()\n//\n// Calls a provided functor on a given set of variants. `absl::visit()` is\n// commonly used to conditionally inspect the state of a given variant (or set\n// of variants).\n//\n// The functor must return the same type when called with any of the variants'\n// alternatives.\n//\n// Example:\n//\n//   // Define a visitor functor\n//   struct GetVariant {\n//       template<typename T>\n//       void operator()(const T& i) const {\n//         std::cout << \"The variant's value is: \" << i;\n//       }\n//   };\n//\n//   // Declare our variant, and call `absl::visit()` on it.\n//   // Note that `GetVariant()` returns void in either case.\n//   absl::variant<int, std::string> foo = std::string(\"foo\");\n//   GetVariant visitor;\n//   absl::visit(visitor, foo);  // Prints `The variant's value is: foo'\ntemplate <typename Visitor, typename... Variants>\nvariant_internal::VisitResult<Visitor, Variants...> visit(Visitor&& vis,\n                                                          Variants&&... vars) {\n  return variant_internal::\n      VisitIndices<variant_size<absl::decay_t<Variants> >::value...>::Run(\n          variant_internal::PerformVisitation<Visitor, Variants...>{\n              std::forward_as_tuple(absl::forward<Variants>(vars)...),\n              absl::forward<Visitor>(vis)},\n          vars.index()...);\n}\n\n// monostate\n//\n// The monostate class serves as a first alternative type for a variant for\n// which the first variant type is otherwise not default-constructible.\nstruct monostate {};\n\n// `absl::monostate` Relational Operators\n\nconstexpr bool operator<(monostate, monostate) noexcept { return false; }\nconstexpr bool operator>(monostate, monostate) noexcept { return false; }\nconstexpr bool operator<=(monostate, monostate) noexcept { return true; }\nconstexpr bool operator>=(monostate, monostate) noexcept { return true; }\nconstexpr bool operator==(monostate, monostate) noexcept { return true; }\nconstexpr bool operator!=(monostate, monostate) noexcept { return false; }\n\n\n//------------------------------------------------------------------------------\n// `absl::variant` Template Definition\n//------------------------------------------------------------------------------\ntemplate <typename T0, typename... Tn>\nclass variant<T0, Tn...> : private variant_internal::VariantBase<T0, Tn...> {\n  static_assert(absl::conjunction<std::is_object<T0>,\n                                  std::is_object<Tn>...>::value,\n                \"Attempted to instantiate a variant containing a non-object \"\n                \"type.\");\n  // Intentionally not qualifying `negation` with `absl::` to work around a bug\n  // in MSVC 2015 with inline namespace and variadic template.\n  static_assert(absl::conjunction<negation<std::is_array<T0> >,\n                                  negation<std::is_array<Tn> >...>::value,\n                \"Attempted to instantiate a variant containing an array type.\");\n  static_assert(absl::conjunction<std::is_nothrow_destructible<T0>,\n                                  std::is_nothrow_destructible<Tn>...>::value,\n                \"Attempted to instantiate a variant containing a non-nothrow \"\n                \"destructible type.\");\n\n  friend struct variant_internal::VariantCoreAccess;\n\n private:\n  using Base = variant_internal::VariantBase<T0, Tn...>;\n\n public:\n  // Constructors\n\n  // Constructs a variant holding a default-initialized value of the first\n  // alternative type.\n  constexpr variant() /*noexcept(see 111above)*/ = default;\n\n  // Copy constructor, standard semantics\n  variant(const variant& other) = default;\n\n  // Move constructor, standard semantics\n  variant(variant&& other) /*noexcept(see above)*/ = default;\n\n  // Constructs a variant of an alternative type specified by overload\n  // resolution of the provided forwarding arguments through\n  // direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  //\n  // NOTE: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r1.html\n  // has been voted passed the design phase in the C++ standard meeting in Mar\n  // 2018. It will be implemented and integrated into `absl::variant`.\n  template <\n      class T,\n      std::size_t I = std::enable_if<\n          variant_internal::IsNeitherSelfNorInPlace<variant,\n                                                    absl::decay_t<T>>::value,\n          variant_internal::IndexOfConstructedType<variant, T>>::type::value,\n      class Tj = absl::variant_alternative_t<I, variant>,\n      absl::enable_if_t<std::is_constructible<Tj, T>::value>* =\n          nullptr>\n  constexpr variant(T&& t) noexcept(std::is_nothrow_constructible<Tj, T>::value)\n      : Base(variant_internal::EmplaceTag<I>(), absl::forward<T>(t)) {}\n\n  // Constructs a variant of an alternative type from the arguments through\n  // direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  template <class T, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::UnambiguousTypeOfT<variant, T>,\n                Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_type_t<T>, Args&&... args)\n      : Base(variant_internal::EmplaceTag<\n                 variant_internal::UnambiguousIndexOf<variant, T>::value>(),\n             absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from an initializer list\n  // and other arguments through direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  template <class T, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::UnambiguousTypeOfT<variant, T>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_type_t<T>, std::initializer_list<U> il,\n                             Args&&... args)\n      : Base(variant_internal::EmplaceTag<\n                 variant_internal::UnambiguousIndexOf<variant, T>::value>(),\n             il, absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from a provided index,\n  // through value-initialization using the provided forwarded arguments.\n  template <std::size_t I, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::VariantAlternativeSfinaeT<I, variant>,\n                Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_index_t<I>, Args&&... args)\n      : Base(variant_internal::EmplaceTag<I>(), absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from a provided index,\n  // through value-initialization of an initializer list and the provided\n  // forwarded arguments.\n  template <std::size_t I, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::VariantAlternativeSfinaeT<I, variant>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_index_t<I>, std::initializer_list<U> il,\n                             Args&&... args)\n      : Base(variant_internal::EmplaceTag<I>(), il,\n             absl::forward<Args>(args)...) {}\n\n  // Destructors\n\n  // Destroys the variant's currently contained value, provided that\n  // `absl::valueless_by_exception()` is false.\n  ~variant() = default;\n\n  // Assignment Operators\n\n  // Copy assignment operator\n  variant& operator=(const variant& other) = default;\n\n  // Move assignment operator\n  variant& operator=(variant&& other) /*noexcept(see above)*/ = default;\n\n  // Converting assignment operator\n  //\n  // NOTE: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r1.html\n  // has been voted passed the design phase in the C++ standard meeting in Mar\n  // 2018. It will be implemented and integrated into `absl::variant`.\n  template <\n      class T,\n      std::size_t I = std::enable_if<\n          !std::is_same<absl::decay_t<T>, variant>::value,\n          variant_internal::IndexOfConstructedType<variant, T>>::type::value,\n      class Tj = absl::variant_alternative_t<I, variant>,\n      typename std::enable_if<std::is_assignable<Tj&, T>::value &&\n                              std::is_constructible<Tj, T>::value>::type* =\n          nullptr>\n  variant& operator=(T&& t) noexcept(\n      std::is_nothrow_assignable<Tj&, T>::value&&\n          std::is_nothrow_constructible<Tj, T>::value) {\n    variant_internal::VisitIndices<sizeof...(Tn) + 1>::Run(\n        variant_internal::VariantCoreAccess::MakeConversionAssignVisitor(\n            this, absl::forward<T>(t)),\n        index());\n\n    return *this;\n  }\n\n\n  // emplace() Functions\n\n  // Constructs a value of the given alternative type T within the variant. The\n  // existing value of the variant is destroyed first (provided that\n  // `absl::valueless_by_exception()` is false). Requires that T is unambiguous\n  // in the variant.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, std::string> v;\n  //   v.emplace<int>(99);\n  //   v.emplace<std::string>(\"abc\");\n  template <\n      class T, class... Args,\n      typename std::enable_if<std::is_constructible<\n          absl::variant_alternative_t<\n              variant_internal::UnambiguousIndexOf<variant, T>::value, variant>,\n          Args...>::value>::type* = nullptr>\n  T& emplace(Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<\n        variant_internal::UnambiguousIndexOf<variant, T>::value>(\n        this, absl::forward<Args>(args)...);\n  }\n\n  // Constructs a value of the given alternative type T within the variant using\n  // an initializer list. The existing value of the variant is destroyed first\n  // (provided that `absl::valueless_by_exception()` is false). Requires that T\n  // is unambiguous in the variant.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, std::string> v;\n  //   v.emplace<std::vector<int>>({0, 1, 2});\n  template <\n      class T, class U, class... Args,\n      typename std::enable_if<std::is_constructible<\n          absl::variant_alternative_t<\n              variant_internal::UnambiguousIndexOf<variant, T>::value, variant>,\n          std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  T& emplace(std::initializer_list<U> il, Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<\n        variant_internal::UnambiguousIndexOf<variant, T>::value>(\n        this, il, absl::forward<Args>(args)...);\n  }\n\n  // Destroys the current value of the variant (provided that\n  // `absl::valueless_by_exception()` is false) and constructs a new value at\n  // the given index.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, int> v;\n  //   v.emplace<1>(99);\n  //   v.emplace<2>(98);\n  //   v.emplace<int>(99);  // Won't compile. 'int' isn't a unique type.\n  template <std::size_t I, class... Args,\n            typename std::enable_if<\n                std::is_constructible<absl::variant_alternative_t<I, variant>,\n                                      Args...>::value>::type* = nullptr>\n  absl::variant_alternative_t<I, variant>& emplace(Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<I>(\n        this, absl::forward<Args>(args)...);\n  }\n\n  // Destroys the current value of the variant (provided that\n  // `absl::valueless_by_exception()` is false) and constructs a new value at\n  // the given index using an initializer list and the provided arguments.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, int> v;\n  //   v.emplace<0>({0, 1, 2});\n  template <std::size_t I, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                absl::variant_alternative_t<I, variant>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  absl::variant_alternative_t<I, variant>& emplace(std::initializer_list<U> il,\n                                                   Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<I>(\n        this, il, absl::forward<Args>(args)...);\n  }\n\n  // variant::valueless_by_exception()\n  //\n  // Returns false if and only if the variant currently holds a valid value.\n  constexpr bool valueless_by_exception() const noexcept {\n    return this->index_ == absl::variant_npos;\n  }\n\n  // variant::index()\n  //\n  // Returns the index value of the variant's currently selected alternative\n  // type.\n  constexpr std::size_t index() const noexcept { return this->index_; }\n\n  // variant::swap()\n  //\n  // Swaps the values of two variant objects.\n  //\n  void swap(variant& rhs) noexcept(\n      absl::conjunction<\n          std::is_nothrow_move_constructible<T0>,\n          std::is_nothrow_move_constructible<Tn>...,\n          type_traits_internal::IsNothrowSwappable<T0>,\n          type_traits_internal::IsNothrowSwappable<Tn>...>::value) {\n    return variant_internal::VisitIndices<sizeof...(Tn) + 1>::Run(\n        variant_internal::Swap<T0, Tn...>{this, &rhs}, rhs.index());\n  }\n};\n\n// We need a valid declaration of variant<> for SFINAE and overload resolution\n// to work properly above, but we don't need a full declaration since this type\n// will never be constructed. This declaration, though incomplete, suffices.\ntemplate <>\nclass variant<>;\n\n//------------------------------------------------------------------------------\n// Relational Operators\n//------------------------------------------------------------------------------\n//\n// If neither operand is in the `variant::valueless_by_exception` state:\n//\n//   * If the index of both variants is the same, the relational operator\n//     returns the result of the corresponding relational operator for the\n//     corresponding alternative type.\n//   * If the index of both variants is not the same, the relational operator\n//     returns the result of that operation applied to the value of the left\n//     operand's index and the value of the right operand's index.\n//   * If at least one operand is in the valueless_by_exception state:\n//     - A variant in the valueless_by_exception state is only considered equal\n//       to another variant in the valueless_by_exception state.\n//     - If exactly one operand is in the valueless_by_exception state, the\n//       variant in the valueless_by_exception state is less than the variant\n//       that is not in the valueless_by_exception state.\n//\n// Note: The value 1 is added to each index in the relational comparisons such\n// that the index corresponding to the valueless_by_exception state wraps around\n// to 0 (the lowest value for the index type), and the remaining indices stay in\n// the same relative order.\n\n// Equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveEqualT<Types...> operator==(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() == b.index()) &&\n         variant_internal::VisitIndices<sizeof...(Types)>::Run(\n             variant_internal::EqualsOp<Types...>{&a, &b}, a.index());\n}\n\n// Not equal operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveNotEqualT<Types...> operator!=(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index()) ||\n         variant_internal::VisitIndices<sizeof...(Types)>::Run(\n             variant_internal::NotEqualsOp<Types...>{&a, &b}, a.index());\n}\n\n// Less-than operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveLessThanT<Types...> operator<(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) < (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::LessThanOp<Types...>{&a, &b}, a.index());\n}\n\n// Greater-than operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveGreaterThanT<Types...> operator>(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) > (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::GreaterThanOp<Types...>{&a, &b},\n                   a.index());\n}\n\n// Less-than or equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveLessThanOrEqualT<Types...> operator<=(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) < (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::LessThanOrEqualsOp<Types...>{&a, &b},\n                   a.index());\n}\n\n// Greater-than or equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveGreaterThanOrEqualT<Types...>\noperator>=(const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) > (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::GreaterThanOrEqualsOp<Types...>{&a, &b},\n                   a.index());\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04526",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/variant.h",
  "source_line": 164,
  "validation_status": "validated"
}