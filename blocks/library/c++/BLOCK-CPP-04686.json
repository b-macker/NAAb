{
  "code": "#include \"absl/base/config.h\"\n#include <functional>\n#include <algorithm>\n#include <type_traits>\n#include <utility>\n#include \"absl/meta/type_traits.h\"\n\nusing namespace absl;\nusing namespace base_internal;\nusing namespace base_internal;\nusing namespace absl;\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04686_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\n// The five classes below each implement one of the clauses from the definition\n// of INVOKE. The inner class template Accept<F, Args...> checks whether the\n// clause is applicable; static function template Invoke(f, args...) does the\n// invocation.\n//\n// By separating the clause selection logic from invocation we make sure that\n// Invoke() does exactly what the standard says.\n\ntemplate <typename Derived>\nstruct StrippedAccept {\n  template <typename... Args>\n  struct Accept : Derived::template AcceptImpl<typename std::remove_cv<\n                      typename std::remove_reference<Args>::type>::type...> {};\n};\n\n// (t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T\n// and t1 is an object of type T or a reference to an object of type T or a\n// reference to an object of a type derived from T.\nstruct MemFunAndRef : StrippedAccept<MemFunAndRef> {\n  template <typename... Args>\n  struct AcceptImpl : std::false_type {};\n\n  template <typename MemFunType, typename C, typename Obj, typename... Args>\n  struct AcceptImpl<MemFunType C::*, Obj, Args...>\n      : std::integral_constant<bool, std::is_base_of<C, Obj>::value &&\n                                         absl::is_function<MemFunType>::value> {\n  };\n\n  template <typename MemFun, typename Obj, typename... Args>\n  static decltype((std::declval<Obj>().*\n                   std::declval<MemFun>())(std::declval<Args>()...))\n  Invoke(MemFun&& mem_fun, Obj&& obj, Args&&... args) {\n// Ignore bogus GCC warnings on this line.\n// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101436 for similar example.\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(11, 0)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n    return (std::forward<Obj>(obj).*\n            std::forward<MemFun>(mem_fun))(std::forward<Args>(args)...);\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(11, 0)\n#pragma GCC diagnostic pop\n#endif\n  }\n};\n\n// ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a\n// class T and t1 is not one of the types described in the previous item.\nstruct MemFunAndPtr : StrippedAccept<MemFunAndPtr> {\n  template <typename... Args>\n  struct AcceptImpl : std::false_type {};\n\n  template <typename MemFunType, typename C, typename Ptr, typename... Args>\n  struct AcceptImpl<MemFunType C::*, Ptr, Args...>\n      : std::integral_constant<bool, !std::is_base_of<C, Ptr>::value &&\n                                         absl::is_function<MemFunType>::value> {\n  };\n\n  template <typename MemFun, typename Ptr, typename... Args>\n  static decltype(((*std::declval<Ptr>()).*\n                   std::declval<MemFun>())(std::declval<Args>()...))\n  Invoke(MemFun&& mem_fun, Ptr&& ptr, Args&&... args) {\n    return ((*std::forward<Ptr>(ptr)).*\n            std::forward<MemFun>(mem_fun))(std::forward<Args>(args)...);\n  }\n};\n\n// t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is\n// an object of type T or a reference to an object of type T or a reference\n// to an object of a type derived from T.\nstruct DataMemAndRef : StrippedAccept<DataMemAndRef> {\n  template <typename... Args>\n  struct AcceptImpl : std::false_type {};\n\n  template <typename R, typename C, typename Obj>\n  struct AcceptImpl<R C::*, Obj>\n      : std::integral_constant<bool, std::is_base_of<C, Obj>::value &&\n                                         !absl::is_function<R>::value> {};\n\n  template <typename DataMem, typename Ref>\n  static decltype(std::declval<Ref>().*std::declval<DataMem>()) Invoke(\n      DataMem&& data_mem, Ref&& ref) {\n    return std::forward<Ref>(ref).*std::forward<DataMem>(data_mem);\n  }\n};\n\n// (*t1).*f when N == 1 and f is a pointer to member data of a class T and t1\n// is not one of the types described in the previous item.\nstruct DataMemAndPtr : StrippedAccept<DataMemAndPtr> {\n  template <typename... Args>\n  struct AcceptImpl : std::false_type {};\n\n  template <typename R, typename C, typename Ptr>\n  struct AcceptImpl<R C::*, Ptr>\n      : std::integral_constant<bool, !std::is_base_of<C, Ptr>::value &&\n                                         !absl::is_function<R>::value> {};\n\n  template <typename DataMem, typename Ptr>\n  static decltype((*std::declval<Ptr>()).*std::declval<DataMem>()) Invoke(\n      DataMem&& data_mem, Ptr&& ptr) {\n    return (*std::forward<Ptr>(ptr)).*std::forward<DataMem>(data_mem);\n  }\n};\n\n// f(t1, t2, ..., tN) in all other cases.\nstruct Callable {\n  // Callable doesn't have Accept because it's the last clause that gets picked\n  // when none of the previous clauses are applicable.\n  template <typename F, typename... Args>\n  static decltype(std::declval<F>()(std::declval<Args>()...)) Invoke(\n      F&& f, Args&&... args) {\n    return std::forward<F>(f)(std::forward<Args>(args)...);\n  }\n};\n\n// Resolves to the first matching clause.\ntemplate <typename... Args>\nstruct Invoker {\n  typedef typename std::conditional<\n      MemFunAndRef::Accept<Args...>::value, MemFunAndRef,\n      typename std::conditional<\n          MemFunAndPtr::Accept<Args...>::value, MemFunAndPtr,\n          typename std::conditional<\n              DataMemAndRef::Accept<Args...>::value, DataMemAndRef,\n              typename std::conditional<DataMemAndPtr::Accept<Args...>::value,\n                                        DataMemAndPtr, Callable>::type>::type>::\n          type>::type type;\n};\n\n// The result type of Invoke<F, Args...>.\ntemplate <typename F, typename... Args>\nusing invoke_result_t = decltype(Invoker<F, Args...>::type::Invoke(\n    std::declval<F>(), std::declval<Args>()...));\n\n// Invoke(f, args...) is an implementation of INVOKE(f, args...) from section\n// [func.require] of the C++ standard.\ntemplate <typename F, typename... Args>\ninvoke_result_t<F, Args...> invoke(F&& f, Args&&... args) {\n  return Invoker<F, Args...>::type::Invoke(std::forward<F>(f),\n                                           std::forward<Args>(args)...);\n}\n\ntemplate <typename AlwaysVoid, typename, typename, typename...>\nstruct IsInvocableRImpl : std::false_type {};\n\ntemplate <typename R, typename F, typename... Args>\nstruct IsInvocableRImpl<\n    absl::void_t<absl::base_internal::invoke_result_t<F, Args...> >, R, F,\n    Args...>\n    : std::integral_constant<\n          bool,\n          std::is_convertible<absl::base_internal::invoke_result_t<F, Args...>,\n                              R>::value ||\n              std::is_void<R>::value> {};\n\n// Type trait whose member `value` is true if invoking `F` with `Args` is valid,\n// and either the return type is convertible to `R`, or `R` is void.\n// C++11-compatible version of `std::is_invocable_r`.\ntemplate <typename R, typename F, typename... Args>\nusing is_invocable_r = IsInvocableRImpl<void, R, F, Args...>;\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04686",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/invoke.h",
  "source_line": 69,
  "validation_status": "validated"
}