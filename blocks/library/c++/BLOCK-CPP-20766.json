{
  "code": "{\npublic:\n  // \"Distance\" for unusable corrections\n  static const unsigned InvalidDistance = std::numeric_limits<unsigned>::max();\n\n  // The largest distance still considered valid (larger edit distances are\n  // mapped to InvalidDistance by getEditDistance).\n  static const unsigned MaximumDistance = 10000U;\n\n  // Relative weightings of the \"edit distance\" components. The higher the\n  // weight, the more of a penalty to fitness the component will give (higher\n  // weights mean greater contribution to the total edit distance, with the\n  // best correction candidates having the lowest edit distance).\n  static const unsigned CharDistanceWeight = 100U;\n  static const unsigned QualifierDistanceWeight = 110U;\n  static const unsigned CallbackDistanceWeight = 150U;\n\n  TypoCorrection(const DeclarationName &Name, NamedDecl *NameDecl,\n                 NestedNameSpecifier *NNS = nullptr, unsigned CharDistance = 0,\n                 unsigned QualifierDistance = 0)\n      : CorrectionName(Name), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance), QualifierDistance(QualifierDistance) {\n    if (NameDecl)\n      CorrectionDecls.push_back(NameDecl);\n  }\n\n  TypoCorrection(NamedDecl *Name, NestedNameSpecifier *NNS = nullptr,\n                 unsigned CharDistance = 0)\n      : CorrectionName(Name->getDeclName()), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance) {\n    if (Name)\n      CorrectionDecls.push_back(Name);\n  }\n\n  TypoCorrection(DeclarationName Name, NestedNameSpecifier *NNS = nullptr,\n                 unsigned CharDistance = 0)\n      : CorrectionName(Name), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance) {}\n\n  TypoCorrection() = default;\n\n  /// Gets the DeclarationName of the typo correction\n  DeclarationName getCorrection() const { return CorrectionName; }\n\n  IdentifierInfo *getCorrectionAsIdentifierInfo() const {\n    return CorrectionName.getAsIdentifierInfo();\n  }\n\n  /// Gets the NestedNameSpecifier needed to use the typo correction\n  NestedNameSpecifier *getCorrectionSpecifier() const {\n    return CorrectionNameSpec;\n  }\n\n  void setCorrectionSpecifier(NestedNameSpecifier *NNS) {\n    CorrectionNameSpec = NNS;\n    ForceSpecifierReplacement = (NNS != nullptr);\n  }\n\n  void WillReplaceSpecifier(bool ForceReplacement) {\n    ForceSpecifierReplacement = ForceReplacement;\n  }\n\n  bool WillReplaceSpecifier() const {\n    return ForceSpecifierReplacement;\n  }\n\n  void setQualifierDistance(unsigned ED) {\n    QualifierDistance = ED;\n  }\n\n  void setCallbackDistance(unsigned ED) {\n    CallbackDistance = ED;\n  }\n\n  // Convert the given weighted edit distance to a roughly equivalent number of\n  // single-character edits (typically for comparison to the length of the\n  // string being edited).\n  static unsigned NormalizeEditDistance(unsigned ED) {\n    if (ED > MaximumDistance)\n      return InvalidDistance;\n    return (ED + CharDistanceWeight / 2) / CharDistanceWeight;\n  }\n\n  /// Gets the \"edit distance\" of the typo correction from the typo.\n  /// If Normalized is true, scale the distance down by the CharDistanceWeight\n  /// to return the edit distance in terms of single-character edits.\n  unsigned getEditDistance(bool Normalized = true) const {\n    if (CharDistance > MaximumDistance || QualifierDistance > MaximumDistance ||\n        CallbackDistance > MaximumDistance)\n      return InvalidDistance;\n    unsigned ED =\n        CharDistance * CharDistanceWeight +\n        QualifierDistance * QualifierDistanceWeight +\n        CallbackDistance * CallbackDistanceWeight;\n    if (ED > MaximumDistance)\n      return InvalidDistance;\n    // Half the CharDistanceWeight is added to ED to simulate rounding since\n    // integer division truncates the value (i.e. round-to-nearest-int instead\n    // of round-to-zero).\n    return Normalized ? NormalizeEditDistance(ED) : ED;\n  }\n\n  /// Get the correction declaration found by name lookup (before we\n  /// looked through using shadow declarations and the like).\n  NamedDecl *getFoundDecl() const {\n    return hasCorrectionDecl() ? *(CorrectionDecls.begin()) : nullptr;\n  }\n\n  /// Gets the pointer to the declaration of the typo correction\n  NamedDecl *getCorrectionDecl() const {\n    auto *D = getFoundDecl();\n    return D ? D->getUnderlyingDecl() : nullptr;\n  }\n  template <class DeclClass>\n  DeclClass *getCorrectionDeclAs() const {\n    return dyn_cast_or_null<DeclClass>(getCorrectionDecl());\n  }\n\n  /// Clears the list of NamedDecls.\n  void ClearCorrectionDecls() {\n    CorrectionDecls.clear();\n  }\n\n  /// Clears the list of NamedDecls before adding the new one.\n  void setCorrectionDecl(NamedDecl *CDecl) {\n    CorrectionDecls.clear();\n    addCorrectionDecl(CDecl);\n  }\n\n  /// Clears the list of NamedDecls and adds the given set.\n  void setCorrectionDecls(ArrayRef<NamedDecl*> Decls) {\n    CorrectionDecls.clear();\n    CorrectionDecls.insert(CorrectionDecls.begin(), Decls.begin(), Decls.end());\n  }\n\n  /// Add the given NamedDecl to the list of NamedDecls that are the\n  /// declarations associated with the DeclarationName of this TypoCorrection\n  void addCorrectionDecl(NamedDecl *CDecl);\n\n  std::string getAsString(const LangOptions &LO) const;\n\n  std::string getQuoted(const LangOptions &LO) const {\n    return \"'\" + getAsString(LO) + \"'\";\n  }\n\n  /// Returns whether this TypoCorrection has a non-empty DeclarationName\n  explicit operator bool() const { return bool(CorrectionName); }\n\n  /// Mark this TypoCorrection as being a keyword.\n  /// Since addCorrectionDeclsand setCorrectionDecl don't allow NULL to be\n  /// added to the list of the correction's NamedDecl pointers, NULL is added\n  /// as the only element in the list to mark this TypoCorrection as a keyword.\n  void makeKeyword() {\n    CorrectionDecls.clear();\n    CorrectionDecls.push_back(nullptr);\n    ForceSpecifierReplacement = true;\n  }\n\n  // Check if this TypoCorrection is a keyword by checking if the first\n  // item in CorrectionDecls is NULL.\n  bool isKeyword() const {\n    return !CorrectionDecls.empty() && CorrectionDecls.front() == nullptr;\n  }\n\n  // Check if this TypoCorrection is the given keyword.\n  template<std::size_t StrLen>\n  bool isKeyword(const char (&Str)[StrLen]) const {\n    return isKeyword() && getCorrectionAsIdentifierInfo()->isStr(Str);\n  }\n\n  // Returns true if the correction either is a keyword or has a known decl.\n  bool isResolved() const { return !CorrectionDecls.empty(); }\n\n  bool isOverloaded() const {\n    return CorrectionDecls.size() > 1;\n  }\n\n  void setCorrectionRange(CXXScopeSpec *SS,\n                          const DeclarationNameInfo &TypoName) {\n    CorrectionRange = TypoName.getSourceRange();\n    if (ForceSpecifierReplacement && SS && !SS->isEmpty())\n      CorrectionRange.setBegin(SS->getBeginLoc());\n  }\n\n  SourceRange getCorrectionRange() const {\n    return CorrectionRange;\n  }\n\n  using decl_iterator = SmallVectorImpl<NamedDecl *>::iterator;\n\n  decl_iterator begin() {\n    return isKeyword() ? CorrectionDecls.end() : CorrectionDecls.begin();\n  }\n\n  decl_iterator end() { return CorrectionDecls.end(); }\n\n  using const_decl_iterator = SmallVectorImpl<NamedDecl *>::const_iterator;\n\n  const_decl_iterator begin() const {\n    return isKeyword() ? CorrectionDecls.end() : CorrectionDecls.begin();\n  }\n\n  const_decl_iterator end() const { return CorrectionDecls.end(); }\n\n  /// Returns whether this typo correction is correcting to a\n  /// declaration that was declared in a module that has not been imported.\n  bool requiresImport() const { return RequiresImport; }\n  void setRequiresImport(bool Req) { RequiresImport = Req; }\n\n  /// Extra diagnostics are printed after the first diagnostic for the typo.\n  /// This can be used to attach external notes to the diag.\n  void addExtraDiagnostic(PartialDiagnostic PD) {\n    ExtraDiagnostics.push_back(std::move(PD));\n  }\n  ArrayRef<PartialDiagnostic> getExtraDiagnostics() const {\n    return ExtraDiagnostics;\n  }\n\nprivate:\n  bool hasCorrectionDecl() const {\n    return (!isKeyword() && !CorrectionDecls.empty());\n  }\n\n  // Results.\n  DeclarationName CorrectionName;\n  NestedNameSpecifier *CorrectionNameSpec = nullptr;\n  SmallVector<NamedDecl *, 1> CorrectionDecls;\n  unsigned CharDistance = 0;\n  unsigned QualifierDistance = 0;\n  unsigned CallbackDistance = 0;\n  SourceRange CorrectionRange;\n  bool ForceSpecifierReplacement = false;\n  bool RequiresImport = false;\n\n  std::vector<PartialDiagnostic> ExtraDiagnostics;\n}",
  "id": "BLOCK-CPP-20766",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/TypoCorrection.h",
  "source_line": 42,
  "validation_status": "validated"
}