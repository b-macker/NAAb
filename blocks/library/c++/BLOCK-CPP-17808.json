{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <functional>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace driver;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17808_execute() {\n    {\npublic:\n  using multilib_list = std::vector<Multilib>;\n  using const_iterator = multilib_list::const_iterator;\n  using IncludeDirsFunc =\n      std::function<std::vector<std::string>(const Multilib &M)>;\n  using FilterCallback = llvm::function_ref<bool(const Multilib &)>;\n\n  /// Uses regular expressions to simplify flags used for multilib selection.\n  /// For example, we may wish both -mfloat-abi=soft and -mfloat-abi=softfp to\n  /// be treated as -mfloat-abi=soft.\n  struct FlagMatcher {\n    std::string Match;\n    std::vector<std::string> Flags;\n  };\n\nprivate:\n  multilib_list Multilibs;\n  std::vector<FlagMatcher> FlagMatchers;\n  IncludeDirsFunc IncludeCallback;\n  IncludeDirsFunc FilePathsCallback;\n\npublic:\n  MultilibSet() = default;\n  MultilibSet(multilib_list &&Multilibs,\n              std::vector<FlagMatcher> &&FlagMatchers = {})\n      : Multilibs(Multilibs), FlagMatchers(FlagMatchers) {}\n\n  const multilib_list &getMultilibs() { return Multilibs; }\n\n  /// Filter out some subset of the Multilibs using a user defined callback\n  MultilibSet &FilterOut(FilterCallback F);\n\n  /// Add a completed Multilib to the set\n  void push_back(const Multilib &M);\n\n  const_iterator begin() const { return Multilibs.begin(); }\n  const_iterator end() const { return Multilibs.end(); }\n\n  /// Select compatible variants, \\returns false if none are compatible\n  bool select(const Multilib::flags_list &Flags,\n              llvm::SmallVector<Multilib> &) const;\n\n  unsigned size() const { return Multilibs.size(); }\n\n  /// Get the given flags plus flags found by matching them against the\n  /// FlagMatchers and choosing the Flags of each accordingly. The select method\n  /// calls this method so in most cases it's not necessary to call it directly.\n  llvm::StringSet<> expandFlags(const Multilib::flags_list &) const;\n\n  LLVM_DUMP_METHOD void dump() const;\n  void print(raw_ostream &OS) const;\n\n  MultilibSet &setIncludeDirsCallback(IncludeDirsFunc F) {\n    IncludeCallback = std::move(F);\n    return *this;\n  }\n\n  const IncludeDirsFunc &includeDirsCallback() const { return IncludeCallback; }\n\n  MultilibSet &setFilePathsCallback(IncludeDirsFunc F) {\n    FilePathsCallback = std::move(F);\n    return *this;\n  }\n\n  const IncludeDirsFunc &filePathsCallback() const { return FilePathsCallback; }\n\n  static llvm::ErrorOr<MultilibSet>\n  parseYaml(llvm::MemoryBufferRef, llvm::SourceMgr::DiagHandlerTy = nullptr,\n            void *DiagHandlerCtxt = nullptr);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17808",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Multilib.h",
  "source_line": 80,
  "validation_status": "validated"
}