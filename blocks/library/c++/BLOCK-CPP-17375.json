{
  "code": "{\n\n/// Provides a simple uniform namespace for tokens from all C languages.\nenum TokenKind : unsigned short {\n#define TOK(X) X,\n#include \"clang/Basic/TokenKinds.def\"\n  NUM_TOKENS\n};\n\n/// Provides a namespace for preprocessor keywords which start with a\n/// '#' at the beginning of the line.\nenum PPKeywordKind {\n#define PPKEYWORD(X) pp_##X,\n#include \"clang/Basic/TokenKinds.def\"\n  NUM_PP_KEYWORDS\n};\n\n/// Provides a namespace for Objective-C keywords which start with\n/// an '@'.\nenum ObjCKeywordKind {\n#define OBJC_AT_KEYWORD(X) objc_##X,\n#include \"clang/Basic/TokenKinds.def\"\n  NUM_OBJC_KEYWORDS\n};\n\n/// Provides a namespace for interesting identifers such as float_t and\n/// double_t.\nenum InterestingIdentifierKind {\n#define INTERESTING_IDENTIFIER(X) X,\n#include \"clang/Basic/TokenKinds.def\"\n  NUM_INTERESTING_IDENTIFIERS\n};\n\n/// Defines the possible values of an on-off-switch (C99 6.10.6p2).\nenum OnOffSwitch {\n  OOS_ON, OOS_OFF, OOS_DEFAULT\n};\n\n/// Determines the name of a token as used within the front end.\n///\n/// The name of a token will be an internal name (such as \"l_square\")\n/// and should not be used as part of diagnostic messages.\nconst char *getTokenName(TokenKind Kind) LLVM_READNONE;\n\n/// Determines the spelling of simple punctuation tokens like\n/// '!' or '%', and returns NULL for literal and annotation tokens.\n///\n/// This routine only retrieves the \"simple\" spelling of the token,\n/// and will not produce any alternative spellings (e.g., a\n/// digraph). For the actual spelling of a given Token, use\n/// Preprocessor::getSpelling().\nconst char *getPunctuatorSpelling(TokenKind Kind) LLVM_READNONE;\n\n/// Determines the spelling of simple keyword and contextual keyword\n/// tokens like 'int' and 'dynamic_cast'. Returns NULL for other token kinds.\nconst char *getKeywordSpelling(TokenKind Kind) LLVM_READNONE;\n\n/// Returns the spelling of preprocessor keywords, such as \"else\".\nconst char *getPPKeywordSpelling(PPKeywordKind Kind) LLVM_READNONE;\n\n/// Return true if this is a raw identifier or an identifier kind.\ninline bool isAnyIdentifier(TokenKind K) {\n  return (K == tok::identifier) || (K == tok::raw_identifier);\n}\n\n/// Return true if this is a C or C++ string-literal (or\n/// C++11 user-defined-string-literal) token.\ninline bool isStringLiteral(TokenKind K) {\n  return K == tok::string_literal || K == tok::wide_string_literal ||\n         K == tok::utf8_string_literal || K == tok::utf16_string_literal ||\n         K == tok::utf32_string_literal;\n}\n\n/// Return true if this is a \"literal\" kind, like a numeric\n/// constant, string, etc.\ninline bool isLiteral(TokenKind K) {\n  return K == tok::numeric_constant || K == tok::char_constant ||\n         K == tok::wide_char_constant || K == tok::utf8_char_constant ||\n         K == tok::utf16_char_constant || K == tok::utf32_char_constant ||\n         isStringLiteral(K) || K == tok::header_name;\n}\n\n/// Return true if this is any of tok::annot_* kinds.\nbool isAnnotation(TokenKind K);\n\n/// Return true if this is an annotation token representing a pragma.\nbool isPragmaAnnotation(TokenKind K);\n\ninline constexpr bool isRegularKeywordAttribute(TokenKind K) {\n  return (false\n#define KEYWORD_ATTRIBUTE(X) || (K == tok::kw_##X)\n#include \"clang/Basic/AttrTokenKinds.inc\"\n  );\n}\n\n}",
  "id": "BLOCK-CPP-17375",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/TokenKinds.h",
  "source_line": 22,
  "validation_status": "validated"
}