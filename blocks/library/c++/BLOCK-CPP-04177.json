{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// Concept: Formatter\n// -----------------------------------------------------------------------------\n//\n// A Formatter is a function object that is responsible for formatting its\n// argument as a string and appending it to a given output std::string.\n// Formatters may be implemented as function objects, lambdas, or normal\n// functions. You may provide your own Formatter to enable `absl::StrJoin()` to\n// work with arbitrary types.\n//\n// The following is an example of a custom Formatter that uses\n// `absl::FormatDuration` to join a list of `absl::Duration`s.\n//\n//   std::vector<absl::Duration> v = {absl::Seconds(1), absl::Milliseconds(10)};\n//   std::string s =\n//       absl::StrJoin(v, \", \", [](std::string* out, absl::Duration dur) {\n//         absl::StrAppend(out, absl::FormatDuration(dur));\n//       });\n//   EXPECT_EQ(s, \"1s, 10ms\");\n//\n// The following standard formatters are provided within this file:\n//\n// - `AlphaNumFormatter()` (the default)\n// - `StreamFormatter()`\n// - `PairFormatter()`\n// - `DereferenceFormatter()`\n\n// AlphaNumFormatter()\n//\n// Default formatter used if none is specified. Uses `absl::AlphaNum` to convert\n// numeric arguments to strings.\ninline strings_internal::AlphaNumFormatterImpl AlphaNumFormatter() {\n  return strings_internal::AlphaNumFormatterImpl();\n}\n\n// StreamFormatter()\n//\n// Formats its argument using the << operator.\ninline strings_internal::StreamFormatterImpl StreamFormatter() {\n  return strings_internal::StreamFormatterImpl();\n}\n\n// Function Template: PairFormatter(Formatter, absl::string_view, Formatter)\n//\n// Formats a `std::pair` by putting a given separator between the pair's\n// `.first` and `.second` members. This formatter allows you to specify\n// custom Formatters for both the first and second member of each pair.\ntemplate <typename FirstFormatter, typename SecondFormatter>\ninline strings_internal::PairFormatterImpl<FirstFormatter, SecondFormatter>\nPairFormatter(FirstFormatter f1, absl::string_view sep, SecondFormatter f2) {\n  return strings_internal::PairFormatterImpl<FirstFormatter, SecondFormatter>(\n      std::move(f1), sep, std::move(f2));\n}\n\n// Function overload of PairFormatter() for using a default\n// `AlphaNumFormatter()` for each Formatter in the pair.\ninline strings_internal::PairFormatterImpl<\n    strings_internal::AlphaNumFormatterImpl,\n    strings_internal::AlphaNumFormatterImpl>\nPairFormatter(absl::string_view sep) {\n  return PairFormatter(AlphaNumFormatter(), sep, AlphaNumFormatter());\n}\n\n// Function Template: DereferenceFormatter(Formatter)\n//\n// Formats its argument by dereferencing it and then applying the given\n// formatter. This formatter is useful for formatting a container of\n// pointer-to-T. This pattern often shows up when joining repeated fields in\n// protocol buffers.\ntemplate <typename Formatter>\nstrings_internal::DereferenceFormatterImpl<Formatter> DereferenceFormatter(\n    Formatter&& f) {\n  return strings_internal::DereferenceFormatterImpl<Formatter>(\n      std::forward<Formatter>(f));\n}\n\n// Function overload of `DereferenceFormatter()` for using a default\n// `AlphaNumFormatter()`.\ninline strings_internal::DereferenceFormatterImpl<\n    strings_internal::AlphaNumFormatterImpl>\nDereferenceFormatter() {\n  return strings_internal::DereferenceFormatterImpl<\n      strings_internal::AlphaNumFormatterImpl>(AlphaNumFormatter());\n}\n\n// -----------------------------------------------------------------------------\n// StrJoin()\n// -----------------------------------------------------------------------------\n//\n// Joins a range of elements and returns the result as a std::string.\n// `absl::StrJoin()` takes a range, a separator string to use between the\n// elements joined, and an optional Formatter responsible for converting each\n// argument in the range to a string.\n//\n// If omitted, the default `AlphaNumFormatter()` is called on the elements to be\n// joined.\n//\n// Example 1:\n//   // Joins a collection of strings. This pattern also works with a collection\n//   // of `absl::string_view` or even `const char*`.\n//   std::vector<std::string> v = {\"foo\", \"bar\", \"baz\"};\n//   std::string s = absl::StrJoin(v, \"-\");\n//   EXPECT_EQ(s, \"foo-bar-baz\");\n//\n// Example 2:\n//   // Joins the values in the given `std::initializer_list<>` specified using\n//   // brace initialization. This pattern also works with an initializer_list\n//   // of ints or `absl::string_view` -- any `AlphaNum`-compatible type.\n//   std::string s = absl::StrJoin({\"foo\", \"bar\", \"baz\"}, \"-\");\n//   EXPECT_EQs, \"foo-bar-baz\");\n//\n// Example 3:\n//   // Joins a collection of ints. This pattern also works with floats,\n//   // doubles, int64s -- any `StrCat()`-compatible type.\n//   std::vector<int> v = {1, 2, 3, -4};\n//   std::string s = absl::StrJoin(v, \"-\");\n//   EXPECT_EQ(s, \"1-2-3--4\");\n//\n// Example 4:\n//   // Joins a collection of pointer-to-int. By default, pointers are\n//   // dereferenced and the pointee is formatted using the default format for\n//   // that type; such dereferencing occurs for all levels of indirection, so\n//   // this pattern works just as well for `std::vector<int**>` as for\n//   // `std::vector<int*>`.\n//   int x = 1, y = 2, z = 3;\n//   std::vector<int*> v = {&x, &y, &z};\n//   std::string s = absl::StrJoin(v, \"-\");\n//   EXPECT_EQ(s, \"1-2-3\");\n//\n// Example 5:\n//   // Dereferencing of `std::unique_ptr<>` is also supported:\n//   std::vector<std::unique_ptr<int>> v\n//   v.emplace_back(new int(1));\n//   v.emplace_back(new int(2));\n//   v.emplace_back(new int(3));\n//   std::string s = absl::StrJoin(v, \"-\");\n//   EXPECT_EQ(s, \"1-2-3\");\n//\n// Example 6:\n//   // Joins a `std::map`, with each key-value pair separated by an equals\n//   // sign. This pattern would also work with, say, a\n//   // `std::vector<std::pair<>>`.\n//   std::map<std::string, int> m = {\n//       {\"a\", 1},\n//       {\"b\", 2},\n//       {\"c\", 3}};\n//   std::string s = absl::StrJoin(m, \",\", absl::PairFormatter(\"=\"));\n//   EXPECT_EQ(s, \"a=1,b=2,c=3\");\n//\n// Example 7:\n//   // These examples show how `absl::StrJoin()` handles a few common edge\n//   // cases:\n//   std::vector<std::string> v_empty;\n//   EXPECT_EQ(absl::StrJoin(v_empty, \"-\"), \"\");\n//\n//   std::vector<std::string> v_one_item = {\"foo\"};\n//   EXPECT_EQ(absl::StrJoin(v_one_item, \"-\"), \"foo\");\n//\n//   std::vector<std::string> v_empty_string = {\"\"};\n//   EXPECT_EQ(absl::StrJoin(v_empty_string, \"-\"), \"\");\n//\n//   std::vector<std::string> v_one_item_empty_string = {\"a\", \"\"};\n//   EXPECT_EQ(absl::StrJoin(v_one_item_empty_string, \"-\"), \"a-\");\n//\n//   std::vector<std::string> v_two_empty_string = {\"\", \"\"};\n//   EXPECT_EQ(absl::StrJoin(v_two_empty_string, \"-\"), \"-\");\n//\n// Example 8:\n//   // Joins a `std::tuple<T...>` of heterogeneous types, converting each to\n//   // a std::string using the `absl::AlphaNum` class.\n//   std::string s = absl::StrJoin(std::make_tuple(123, \"abc\", 0.456), \"-\");\n//   EXPECT_EQ(s, \"123-abc-0.456\");\n\ntemplate <typename Iterator, typename Formatter>\nstd::string StrJoin(Iterator start, Iterator end, absl::string_view sep,\n                    Formatter&& fmt) {\n  return strings_internal::JoinAlgorithm(start, end, sep, fmt);\n}\n\ntemplate <typename Range, typename Formatter>\nstd::string StrJoin(const Range& range, absl::string_view separator,\n                    Formatter&& fmt) {\n  return strings_internal::JoinRange(range, separator, fmt);\n}\n\ntemplate <typename T, typename Formatter>\nstd::string StrJoin(std::initializer_list<T> il, absl::string_view separator,\n                    Formatter&& fmt) {\n  return strings_internal::JoinRange(il, separator, fmt);\n}\n\ntemplate <typename... T, typename Formatter>\nstd::string StrJoin(const std::tuple<T...>& value, absl::string_view separator,\n                    Formatter&& fmt) {\n  return strings_internal::JoinAlgorithm(value, separator, fmt);\n}\n\ntemplate <typename Iterator>\nstd::string StrJoin(Iterator start, Iterator end, absl::string_view separator) {\n  return strings_internal::JoinRange(start, end, separator);\n}\n\ntemplate <typename Range>\nstd::string StrJoin(const Range& range, absl::string_view separator) {\n  return strings_internal::JoinRange(range, separator);\n}\n\ntemplate <typename T>\nstd::string StrJoin(std::initializer_list<T> il,\n                    absl::string_view separator) {\n  return strings_internal::JoinRange(il, separator);\n}\n\ntemplate <typename... T>\nstd::string StrJoin(const std::tuple<T...>& value,\n                    absl::string_view separator) {\n  return strings_internal::JoinAlgorithm(value, separator, AlphaNumFormatter());\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04177",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_join.h",
  "source_line": 62,
  "validation_status": "validated"
}