{
  "code": "{\n\n// The existence of a CordzSampleToken guarantees that a reader can traverse the\n// global_cordz_infos_head linked-list without needing to hold a mutex. When a\n// CordzSampleToken exists, all CordzInfo objects that would be destroyed are\n// instead appended to a deletion queue. When the CordzSampleToken is destroyed,\n// it will also clean up any of these CordzInfo objects.\n//\n// E.g., ST are CordzSampleToken objects and CH are CordzHandle objects.\n//   ST1 <- CH1 <- CH2 <- ST2 <- CH3 <- global_delete_queue_tail\n//\n// This list tracks that CH1 and CH2 were created after ST1, so the thread\n// holding ST1 might have a reference to CH1, CH2, ST2, and CH3. However, ST2\n// was created later, so the thread holding the ST2 token cannot have a\n// reference to ST1, CH1, or CH2. If ST1 is cleaned up first, that thread will\n// delete ST1, CH1, and CH2. If instead ST2 is cleaned up first, that thread\n// will only delete ST2.\n//\n// If ST1 is cleaned up first, the new list will be:\n//   ST2 <- CH3 <- global_delete_queue_tail\n//\n// If ST2 is cleaned up first, the new list will be:\n//   ST1 <- CH1 <- CH2 <- CH3 <- global_delete_queue_tail\n//\n// All new CordzHandle objects are appended to the list, so if a new thread\n// comes along before either ST1 or ST2 are cleaned up, the new list will be:\n//   ST1 <- CH1 <- CH2 <- ST2 <- CH3 <- ST3 <- global_delete_queue_tail\n//\n// A thread must hold the global_delete_queue_mu mutex whenever it's altering\n// this list.\n//\n// It is safe for thread that holds a CordzSampleToken to read\n// global_cordz_infos at any time since the objects it is able to retrieve will\n// not be deleted while the CordzSampleToken exists.\nclass CordzSampleToken : public CordzSnapshot {\n public:\n  class Iterator {\n   public:\n    using iterator_category = std::input_iterator_tag;\n    using value_type = const CordzInfo&;\n    using difference_type = ptrdiff_t;\n    using pointer = const CordzInfo*;\n    using reference = value_type;\n\n    Iterator() = default;\n\n    Iterator& operator++();\n    Iterator operator++(int);\n    friend bool operator==(const Iterator& lhs, const Iterator& rhs);\n    friend bool operator!=(const Iterator& lhs, const Iterator& rhs);\n    reference operator*() const;\n    pointer operator->() const;\n\n   private:\n    friend class CordzSampleToken;\n    explicit Iterator(const CordzSampleToken* token);\n\n    const CordzSampleToken* token_ = nullptr;\n    pointer current_ = nullptr;\n  };\n\n  CordzSampleToken() = default;\n  CordzSampleToken(const CordzSampleToken&) = delete;\n  CordzSampleToken& operator=(const CordzSampleToken&) = delete;\n\n  Iterator begin() { return Iterator(this); }\n  Iterator end() { return Iterator(); }\n};\n\n}",
  "id": "BLOCK-CPP-06190",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_sample_token.h",
  "source_line": 24,
  "validation_status": "validated"
}