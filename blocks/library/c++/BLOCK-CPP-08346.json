{
  "code": "{\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  DeclContext *getLexicalDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->LexicalDC;\n  }\n  const DeclContext *getLexicalDeclContext() const {\n    return const_cast<Decl*>(this)->getLexicalDeclContext();\n  }\n\n  /// Determine whether this declaration is declared out of line (outside its\n  /// semantic context).\n  virtual bool isOutOfLine() const;\n\n  /// setDeclContext - Set both the semantic and lexical DeclContext\n  /// to DC.\n  void setDeclContext(DeclContext *DC);\n\n  void setLexicalDeclContext(DeclContext *DC);\n\n  /// Determine whether this declaration is a templated entity (whether it is\n  // within the scope of a template parameter).\n  bool isTemplated() const;\n\n  /// Determine the number of levels of template parameter surrounding this\n  /// declaration.\n  unsigned getTemplateDepth() const;\n\n  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this\n  /// scoped decl is defined outside the current function or method.  This is\n  /// roughly global variables and functions, but also handles enums (which\n  /// could be defined inside or outside a function etc).\n  bool isDefinedOutsideFunctionOrMethod() const {\n    return getParentFunctionOrMethod() == nullptr;\n  }\n\n  /// Determine whether a substitution into this declaration would occur as\n  /// part of a substitution into a dependent local scope. Such a substitution\n  /// transitively substitutes into all constructs nested within this\n  /// declaration.\n  ///\n  /// This recognizes non-defining declarations as well as members of local\n  /// classes and lambdas:\n  /// \\code\n  ///     template<typename T> void foo() { void bar(); }\n  ///     template<typename T> void foo2() { class ABC { void bar(); }; }\n  ///     template<typename T> inline int x = [](){ return 0; }();\n  /// \\endcode\n  bool isInLocalScopeForInstantiation() const;\n\n  /// If this decl is defined inside a function/method/block it returns\n  /// the corresponding DeclContext, otherwise it returns null.\n  const DeclContext *\n  getParentFunctionOrMethod(bool LexicalParent = false) const;\n  DeclContext *getParentFunctionOrMethod(bool LexicalParent = false) {\n    return const_cast<DeclContext *>(\n        const_cast<const Decl *>(this)->getParentFunctionOrMethod(\n            LexicalParent));\n  }\n\n  /// Retrieves the \"canonical\" declaration of the given declaration.\n  virtual Decl *getCanonicalDecl() { return this; }\n  const Decl *getCanonicalDecl() const {\n    return const_cast<Decl*>(this)->getCanonicalDecl();\n  }\n\n  /// Whether this particular Decl is a canonical one.\n  bool isCanonicalDecl() const { return getCanonicalDecl() == this; }\n\nprotected:\n  /// Returns the next redeclaration or itself if this is the only decl.\n  ///\n  /// Decl subclasses that can be redeclared should override this method so that\n  /// Decl::redecl_iterator can iterate over them.\n  virtual Decl *getNextRedeclarationImpl() { return this; }\n\n  /// Implementation of getPreviousDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getPreviousDeclImpl() { return nullptr; }\n\n  /// Implementation of getMostRecentDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getMostRecentDeclImpl() { return this; }\n\npublic:\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n    Decl *Starter;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(Decl *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    value_type operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Get either previous decl or latest decl.\n      Decl *Next = Current->getNextRedeclarationImpl();\n      assert(Next && \"Should return next redeclaration or itself, never null!\");\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecls_begin(), redecls_end());\n  }\n\n  redecl_iterator redecls_begin() const {\n    return redecl_iterator(const_cast<Decl *>(this));\n  }\n\n  redecl_iterator redecls_end() const { return redecl_iterator(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  Decl *getPreviousDecl() { return getPreviousDeclImpl(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  const Decl *getPreviousDecl() const {\n    return const_cast<Decl *>(this)->getPreviousDeclImpl();\n  }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const {\n    return getPreviousDecl() == nullptr;\n  }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  Decl *getMostRecentDecl() { return getMostRecentDeclImpl(); }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  const Decl *getMostRecentDecl() const {\n    return const_cast<Decl *>(this)->getMostRecentDeclImpl();\n  }\n\n  /// getBody - If this Decl represents a declaration for a body of code,\n  ///  such as a function or method definition, this method returns the\n  ///  top-level Stmt* of that body.  Otherwise this method returns null.\n  virtual Stmt* getBody() const { return nullptr; }\n\n  /// Returns true if this \\c Decl represents a declaration for a body of\n  /// code, such as a function or method definition.\n  /// Note that \\c hasBody can also return true if any redeclaration of this\n  /// \\c Decl represents a declaration for a body of code.\n  virtual bool hasBody() const { return getBody() != nullptr; }\n\n  /// getBodyRBrace - Gets the right brace of the body, if a body exists.\n  /// This works whether the body is a CompoundStmt or a CXXTryStmt.\n  SourceLocation getBodyRBrace() const;\n\n  // global temp stats (until we have a per-module visitor)\n  static void add(Kind k);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter.\n  bool isTemplateParameter() const;\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter pack.\n  bool isTemplateParameterPack() const;\n\n  /// Whether this declaration is a parameter pack.\n  bool isParameterPack() const;\n\n  /// returns true if this declaration is a template\n  bool isTemplateDecl() const;\n\n  /// Whether this declaration is a function or function template.\n  bool isFunctionOrFunctionTemplate() const {\n    return (DeclKind >= Decl::firstFunction &&\n            DeclKind <= Decl::lastFunction) ||\n           DeclKind == FunctionTemplate;\n  }\n\n  /// If this is a declaration that describes some template, this\n  /// method returns that template declaration.\n  ///\n  /// Note that this returns nullptr for partial specializations, because they\n  /// are not modeled as TemplateDecls. Use getDescribedTemplateParams to handle\n  /// those cases.\n  TemplateDecl *getDescribedTemplate() const;\n\n  /// If this is a declaration that describes some template or partial\n  /// specialization, this returns the corresponding template parameter list.\n  const TemplateParameterList *getDescribedTemplateParams() const;\n\n  /// Returns the function itself, or the templated function if this is a\n  /// function template.\n  FunctionDecl *getAsFunction() LLVM_READONLY;\n\n  const FunctionDecl *getAsFunction() const {\n    return const_cast<Decl *>(this)->getAsFunction();\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// a function-local extern declaration.\n  ///\n  /// These declarations appear in the lexical context of the extern\n  /// declaration, but in the semantic context of the enclosing namespace\n  /// scope.\n  void setLocalExternDecl() {\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~IDNS_Ordinary;\n\n    // It's OK for the declaration to still have the \"invisible friend\" flag or\n    // the \"conflicts with tag declarations in this scope\" flag for the outer\n    // scope.\n    assert((IdentifierNamespace & ~(IDNS_OrdinaryFriend | IDNS_Tag)) == 0 &&\n           \"namespace is not ordinary\");\n\n    IdentifierNamespace |= IDNS_LocalExtern;\n    if (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary)\n      IdentifierNamespace |= IDNS_Ordinary;\n  }\n\n  /// Determine whether this is a block-scope declaration with linkage.\n  /// This will either be a local variable declaration declared 'extern', or a\n  /// local function declaration.\n  bool isLocalExternDecl() const {\n    return IdentifierNamespace & IDNS_LocalExtern;\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// the object of a friend declaration.\n  ///\n  /// These declarations appear in the lexical context of the friending\n  /// class, but in the semantic context of the actual entity.  This property\n  /// applies only to a specific decl object;  other redeclarations of the\n  /// same entity may not (and probably don't) share this property.\n  void setObjectOfFriendDecl(bool PerformFriendInjection = false) {\n    unsigned OldNS = IdentifierNamespace;\n    assert((OldNS & (IDNS_Tag | IDNS_Ordinary |\n                     IDNS_TagFriend | IDNS_OrdinaryFriend |\n                     IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes neither ordinary nor tag\");\n    assert(!(OldNS & ~(IDNS_Tag | IDNS_Ordinary | IDNS_Type |\n                       IDNS_TagFriend | IDNS_OrdinaryFriend |\n                       IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes other than ordinary or tag\");\n\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~(IDNS_Ordinary | IDNS_Tag | IDNS_Type);\n\n    if (OldNS & (IDNS_Tag | IDNS_TagFriend)) {\n      IdentifierNamespace |= IDNS_TagFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Tag))\n        IdentifierNamespace |= IDNS_Tag | IDNS_Type;\n    }\n\n    if (OldNS & (IDNS_Ordinary | IDNS_OrdinaryFriend |\n                 IDNS_LocalExtern | IDNS_NonMemberOperator)) {\n      IdentifierNamespace |= IDNS_OrdinaryFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary))\n        IdentifierNamespace |= IDNS_Ordinary;\n    }\n  }\n\n  /// Clears the namespace of this declaration.\n  ///\n  /// This is useful if we want this declaration to be available for\n  /// redeclaration lookup but otherwise hidden for ordinary name lookups.\n  void clearIdentifierNamespace() { IdentifierNamespace = 0; }\n\n  enum FriendObjectKind {\n    FOK_None,      ///< Not a friend object.\n    FOK_Declared,  ///< A friend of a previously-declared entity.\n    FOK_Undeclared ///< A friend of a previously-undeclared entity.\n  };\n\n  /// Determines whether this declaration is the object of a\n  /// friend declaration and, if so, what kind.\n  ///\n  /// There is currently no direct way to find the associated FriendDecl.\n  FriendObjectKind getFriendObjectKind() const {\n    unsigned mask =\n        (IdentifierNamespace & (IDNS_TagFriend | IDNS_OrdinaryFriend));\n    if (!mask) return FOK_None;\n    return (IdentifierNamespace & (IDNS_Tag | IDNS_Ordinary) ? FOK_Declared\n                                                             : FOK_Undeclared);\n  }\n\n  /// Specifies that this declaration is a C++ overloaded non-member.\n  void setNonMemberOperator() {\n    assert(getKind() == Function || getKind() == FunctionTemplate);\n    assert((IdentifierNamespace & IDNS_Ordinary) &&\n           \"visible non-member operators should be in ordinary namespace\");\n    IdentifierNamespace |= IDNS_NonMemberOperator;\n  }\n\n  static bool classofKind(Kind K) { return true; }\n  static DeclContext *castToDeclContext(const Decl *);\n  static Decl *castFromDeclContext(const DeclContext *);\n\n  void print(raw_ostream &Out, unsigned Indentation = 0,\n             bool PrintInstantiation = false) const;\n  void print(raw_ostream &Out, const PrintingPolicy &Policy,\n             unsigned Indentation = 0, bool PrintInstantiation = false) const;\n  static void printGroup(Decl** Begin, unsigned NumDecls,\n                         raw_ostream &Out, const PrintingPolicy &Policy,\n                         unsigned Indentation = 0);\n\n  // Debuggers don't usually respect default arguments.\n  void dump() const;\n\n  // Same as dump(), but forces color printing.\n  void dumpColor() const;\n\n  void dump(raw_ostream &Out, bool Deserialize = false,\n            ASTDumpOutputFormat OutputFormat = ADOF_Default) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID() const;\n\n  /// Looks through the Decl's underlying type to extract a FunctionType\n  /// when possible. Will return null if the type underlying the Decl does not\n  /// have a FunctionType.\n  const FunctionType *getFunctionType(bool BlocksToo = true) const;\n\n  // Looks through the Decl's underlying type to determine if it's a\n  // function pointer type.\n  bool isFunctionPointerType() const;\n\nprivate:\n  void setAttrsImpl(const AttrVec& Attrs, ASTContext &Ctx);\n  void setDeclContextsImpl(DeclContext *SemaDC, DeclContext *LexicalDC,\n                           ASTContext &Ctx);\n\nprotected:\n  ASTMutationListener *getASTMutationListener() const;\n}",
  "id": "BLOCK-CPP-08346",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclBase.h",
  "source_line": 881,
  "validation_status": "validated"
}