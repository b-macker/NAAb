{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n// Some Android headers are missing these definitions even though they\n// support these futex operations.\n#ifdef __BIONIC__\n#ifndef SYS_futex\n#define SYS_futex __NR_futex\n#endif\n#ifndef FUTEX_WAIT_BITSET\n#define FUTEX_WAIT_BITSET 9\n#endif\n#ifndef FUTEX_PRIVATE_FLAG\n#define FUTEX_PRIVATE_FLAG 128\n#endif\n#ifndef FUTEX_CLOCK_REALTIME\n#define FUTEX_CLOCK_REALTIME 256\n#endif\n#ifndef FUTEX_BITSET_MATCH_ANY\n#define FUTEX_BITSET_MATCH_ANY 0xFFFFFFFF\n#endif\n#endif\n\n#if defined(__NR_futex_time64) && !defined(SYS_futex_time64)\n#define SYS_futex_time64 __NR_futex_time64\n#endif\n\n#if defined(SYS_futex_time64) && !defined(SYS_futex)\n#define SYS_futex SYS_futex_time64\nusing FutexTimespec = struct timespec;\n#else\n// Some libc implementations have switched to an unconditional 64-bit `time_t`\n// definition. This means that `struct timespec` may not match the layout\n// expected by the kernel ABI on 32-bit platforms. So we define the\n// FutexTimespec that matches the kernel timespec definition. It should be safe\n// to use this struct for 64-bit userspace builds too, since it will use another\n// SYS_futex kernel call with 64-bit tv_sec inside timespec.\nstruct FutexTimespec {\n  long tv_sec;   // NOLINT\n  long tv_nsec;  // NOLINT\n};\n#endif\n\nclass FutexImpl {\n public:\n  // Atomically check that `*v == val`, and if it is, then sleep until the until\n  // woken by `Wake()`.\n  static int Wait(std::atomic<int32_t>* v, int32_t val) {\n    return WaitAbsoluteTimeout(v, val, nullptr);\n  }\n\n  // Atomically check that `*v == val`, and if it is, then sleep until\n  // CLOCK_REALTIME reaches `*abs_timeout`, or until woken by `Wake()`.\n  static int WaitAbsoluteTimeout(std::atomic<int32_t>* v, int32_t val,\n                                 const struct timespec* abs_timeout) {\n    FutexTimespec ts;\n    // https://locklessinc.com/articles/futex_cheat_sheet/\n    // Unlike FUTEX_WAIT, FUTEX_WAIT_BITSET uses absolute time.\n    auto err = syscall(\n        SYS_futex, reinterpret_cast<int32_t*>(v),\n        FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME, val,\n        ToFutexTimespec(abs_timeout, &ts), nullptr, FUTEX_BITSET_MATCH_ANY);\n    if (err != 0) {\n      return -errno;\n    }\n    return 0;\n  }\n\n  // Atomically check that `*v == val`, and if it is, then sleep until\n  // `*rel_timeout` has elapsed, or until woken by `Wake()`.\n  static int WaitRelativeTimeout(std::atomic<int32_t>* v, int32_t val,\n                                 const struct timespec* rel_timeout) {\n    FutexTimespec ts;\n    // Atomically check that the futex value is still 0, and if it\n    // is, sleep until abs_timeout or until woken by FUTEX_WAKE.\n    auto err =\n        syscall(SYS_futex, reinterpret_cast<int32_t*>(v), FUTEX_PRIVATE_FLAG,\n                val, ToFutexTimespec(rel_timeout, &ts));\n    if (err != 0) {\n      return -errno;\n    }\n    return 0;\n  }\n\n  // Wakes at most `count` waiters that have entered the sleep state on `v`.\n  static int Wake(std::atomic<int32_t>* v, int32_t count) {\n    auto err = syscall(SYS_futex, reinterpret_cast<int32_t*>(v),\n                       FUTEX_WAKE | FUTEX_PRIVATE_FLAG, count);\n    if (ABSL_PREDICT_FALSE(err < 0)) {\n      return -errno;\n    }\n    return 0;\n  }\n\n private:\n  static FutexTimespec* ToFutexTimespec(const struct timespec* userspace_ts,\n                                        FutexTimespec* futex_ts) {\n    if (userspace_ts == nullptr) {\n      return nullptr;\n    }\n\n    using FutexSeconds = decltype(futex_ts->tv_sec);\n    using FutexNanoseconds = decltype(futex_ts->tv_nsec);\n\n    constexpr auto kMaxSeconds{(std::numeric_limits<FutexSeconds>::max)()};\n    if (userspace_ts->tv_sec > kMaxSeconds) {\n      futex_ts->tv_sec = kMaxSeconds;\n    } else {\n      futex_ts->tv_sec = static_cast<FutexSeconds>(userspace_ts->tv_sec);\n    }\n    futex_ts->tv_nsec = static_cast<FutexNanoseconds>(userspace_ts->tv_nsec);\n    return futex_ts;\n  }\n};\n\nclass Futex : public FutexImpl {};\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06449",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/futex.h",
  "source_line": 53,
  "validation_status": "validated"
}