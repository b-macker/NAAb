{
  "code": "{\n\nclass GlobalModuleIndex;\nclass IdentifierInfo;\n\n/// A sequence of identifier/location pairs used to describe a particular\n/// module or submodule, e.g., std.vector.\nusing ModuleIdPath = ArrayRef<std::pair<IdentifierInfo *, SourceLocation>>;\n\n/// Describes the result of attempting to load a module.\nclass ModuleLoadResult {\npublic:\n  enum LoadResultKind {\n    // We either succeeded or failed to load the named module.\n    Normal,\n\n    // The module exists, but does not actually contain the named submodule.\n    // This should only happen if the named submodule was inferred from an\n    // umbrella directory, but not actually part of the umbrella header.\n    MissingExpected,\n\n    // The module exists but cannot be imported due to a configuration mismatch.\n    ConfigMismatch,\n  };\n  llvm::PointerIntPair<Module *, 2, LoadResultKind> Storage;\n\n  ModuleLoadResult() = default;\n  ModuleLoadResult(Module *M) : Storage(M, Normal) {}\n  ModuleLoadResult(LoadResultKind Kind) : Storage(nullptr, Kind) {}\n  ModuleLoadResult(Module *M, LoadResultKind Kind) : Storage(M, Kind) {}\n\n  operator bool() const {\n    return Storage.getInt() == Normal && Storage.getPointer();\n  }\n\n  operator Module *() const { return Storage.getPointer(); }\n\n  /// Determines whether this is a normal return, whether or not loading the\n  /// module was successful.\n  bool isNormal() const { return Storage.getInt() == Normal; }\n\n  /// Determines whether the module, which failed to load, was\n  /// actually a submodule that we expected to see (based on implying the\n  /// submodule from header structure), but didn't materialize in the actual\n  /// module.\n  bool isMissingExpected() const { return Storage.getInt() == MissingExpected; }\n\n  /// Determines whether the module failed to load due to a configuration\n  /// mismatch with an explicitly-named .pcm file from the command line.\n  bool isConfigMismatch() const { return Storage.getInt() == ConfigMismatch; }\n};\n\n/// Abstract interface for a module loader.\n///\n/// This abstract interface describes a module loader, which is responsible\n/// for resolving a module name (e.g., \"std\") to an actual module file, and\n/// then loading that module.\nclass ModuleLoader {\n  // Building a module if true.\n  bool BuildingModule;\n\npublic:\n  explicit ModuleLoader(bool BuildingModule = false)\n      : BuildingModule(BuildingModule) {}\n\n  virtual ~ModuleLoader();\n\n  /// Returns true if this instance is building a module.\n  bool buildingModule() const {\n    return BuildingModule;\n  }\n\n  /// Flag indicating whether this instance is building a module.\n  void setBuildingModule(bool BuildingModuleFlag) {\n    BuildingModule = BuildingModuleFlag;\n  }\n\n  /// Attempt to load the given module.\n  ///\n  /// This routine attempts to load the module described by the given\n  /// parameters.  If there is a module cache, this may implicitly compile the\n  /// module before loading it.\n  ///\n  /// \\param ImportLoc The location of the 'import' keyword.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Visibility The visibility provided for the names in the loaded\n  /// module.\n  ///\n  /// \\param IsInclusionDirective Indicates that this module is being loaded\n  /// implicitly, due to the presence of an inclusion directive. Otherwise,\n  /// it is being loaded due to an import declaration.\n  ///\n  /// \\returns If successful, returns the loaded module. Otherwise, returns\n  /// NULL to indicate that the module could not be loaded.\n  virtual ModuleLoadResult loadModule(SourceLocation ImportLoc,\n                                      ModuleIdPath Path,\n                                      Module::NameVisibilityKind Visibility,\n                                      bool IsInclusionDirective) = 0;\n\n  /// Attempt to create the given module from the specified source buffer.\n  /// Does not load the module or make any submodule visible; for that, use\n  /// loadModule and makeModuleVisible.\n  ///\n  /// \\param Loc The location at which to create the module.\n  /// \\param ModuleName The name of the module to create.\n  /// \\param Source The source of the module: a (preprocessed) module map.\n  virtual void createModuleFromSource(SourceLocation Loc, StringRef ModuleName,\n                                      StringRef Source) = 0;\n\n  /// Make the given module visible.\n  virtual void makeModuleVisible(Module *Mod,\n                                 Module::NameVisibilityKind Visibility,\n                                 SourceLocation ImportLoc) = 0;\n\n  /// Load, create, or return global module.\n  /// This function returns an existing global module index, if one\n  /// had already been loaded or created, or loads one if it\n  /// exists, or creates one if it doesn't exist.\n  /// Also, importantly, if the index doesn't cover all the modules\n  /// in the module map, it will be update to do so here, because\n  /// of its use in searching for needed module imports and\n  /// associated fixit messages.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns null if load failed.\n  virtual GlobalModuleIndex *loadGlobalModuleIndex(\n                                                SourceLocation TriggerLoc) = 0;\n\n  /// Check global module index for missing imports.\n  /// \\param Name The symbol name to look for.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns true if any modules with that symbol found.\n  virtual bool lookupMissingImports(StringRef Name,\n                                    SourceLocation TriggerLoc) = 0;\n\n  bool HadFatalFailure = false;\n};\n\n/// A module loader that doesn't know how to create or load modules.\nclass TrivialModuleLoader : public ModuleLoader {\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override {\n    return {};\n  }\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override {}\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override {}\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override {\n    return nullptr;\n  }\n\n  bool lookupMissingImports(StringRef Name,\n                            SourceLocation TriggerLoc) override {\n    return false;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-18779",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/ModuleLoader.h",
  "source_line": 25,
  "validation_status": "validated"
}