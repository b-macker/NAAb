{
  "code": "#include <cstddef>\n#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/strings/string_view.h\"\n#include <elf.h>\n#include <link.h>  // For ElfW() macro.\n#include <functional>\n#include <string>\n\nusing namespace absl;\nusing namespace debugging_internal;\nusing namespace debugging_internal;\nusing namespace absl;\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05466_execute() {\n    {\n\nstruct SymbolDecoratorArgs {\n  // The program counter we are getting symbolic name for.\n  const void *pc;\n  // 0 for main executable, load address for shared libraries.\n  ptrdiff_t relocation;\n  // Read-only file descriptor for ELF image covering \"pc\",\n  // or -1 if no such ELF image exists in /proc/self/maps.\n  int fd;\n  // Output buffer, size.\n  // Note: the buffer may not be empty -- default symbolizer may have already\n  // produced some output, and earlier decorators may have adorned it in\n  // some way. You are free to replace or augment the contents (within the\n  // symbol_buf_size limit).\n  char *const symbol_buf;\n  size_t symbol_buf_size;\n  // Temporary scratch space, size.\n  // Use that space in preference to allocating your own stack buffer to\n  // conserve stack.\n  char *const tmp_buf;\n  size_t tmp_buf_size;\n  // User-provided argument\n  void* arg;\n};\nusing SymbolDecorator = void (*)(const SymbolDecoratorArgs *);\n\n// Installs a function-pointer as a decorator. Returns a value less than zero\n// if the system cannot install the decorator. Otherwise, returns a unique\n// identifier corresponding to the decorator. This identifier can be used to\n// uninstall the decorator - See RemoveSymbolDecorator() below.\nint InstallSymbolDecorator(SymbolDecorator decorator, void* arg);\n\n// Removes a previously installed function-pointer decorator. Parameter \"ticket\"\n// is the return-value from calling InstallSymbolDecorator().\nbool RemoveSymbolDecorator(int ticket);\n\n// Remove all installed decorators.  Returns true if successful, false if\n// symbolization is currently in progress.\nbool RemoveAllSymbolDecorators();\n\n// Registers an address range to a file mapping.\n//\n// Preconditions:\n//   start <= end\n//   filename != nullptr\n//\n// Returns true if the file was successfully registered.\nbool RegisterFileMappingHint(const void* start, const void* end,\n                             uint64_t offset, const char* filename);\n\n// Looks up the file mapping registered by RegisterFileMappingHint for an\n// address range. If there is one, the file name is stored in *filename and\n// *start and *end are modified to reflect the registered mapping. Returns\n// whether any hint was found.\nbool GetFileMappingHint(const void** start, const void** end, uint64_t* offset,\n                        const char** filename);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05466",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/symbolize.h",
  "source_line": 79,
  "validation_status": "validated"
}