{
  "code": "#include \"absl/base/internal/unscaledcycleclock.h\"\n#include <intrin.h>\n#include <sys/platform/ppc.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include \"absl/base/call_once.h\"\n#include \"absl/base/internal/sysinfo.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02400_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\n#if defined(__i386__)\n\nint64_t UnscaledCycleClock::Now() {\n  int64_t ret;\n  __asm__ volatile(\"rdtsc\" : \"=A\"(ret));\n  return ret;\n}\n\ndouble UnscaledCycleClock::Frequency() {\n  return base_internal::NominalCPUFrequency();\n}\n\n#elif defined(__x86_64__)\n\ndouble UnscaledCycleClock::Frequency() {\n  return base_internal::NominalCPUFrequency();\n}\n\n#elif defined(__powerpc__) || defined(__ppc__)\n\nint64_t UnscaledCycleClock::Now() {\n#ifdef __GLIBC__\n  return __ppc_get_timebase();\n#else\n#ifdef __powerpc64__\n  int64_t tbr;\n  asm volatile(\"mfspr %0, 268\" : \"=r\"(tbr));\n  return tbr;\n#else\n  int32_t tbu, tbl, tmp;\n  asm volatile(\n      \"mftbu %[hi32]\\n\"\n      \"mftb %[lo32]\\n\"\n      \"mftbu %[tmp]\\n\"\n      \"cmpw %[tmp],%[hi32]\\n\"\n      \"bne $-16\\n\"  // Retry on failure.\n      : [hi32] \"=r\"(tbu), [lo32] \"=r\"(tbl), [tmp] \"=r\"(tmp));\n  return (static_cast<int64_t>(tbu) << 32) | tbl;\n#endif\n#endif\n}\n\ndouble UnscaledCycleClock::Frequency() {\n#ifdef __GLIBC__\n  return __ppc_get_timebase_freq();\n#elif defined(_AIX)\n  // This is the same constant value as returned by\n  // __ppc_get_timebase_freq().\n  return static_cast<double>(512000000);\n#elif defined(__FreeBSD__)\n  static once_flag init_timebase_frequency_once;\n  static double timebase_frequency = 0.0;\n  base_internal::LowLevelCallOnce(&init_timebase_frequency_once, [&]() {\n    size_t length = sizeof(timebase_frequency);\n    sysctlbyname(\"kern.timecounter.tc.timebase.frequency\", &timebase_frequency,\n                 &length, nullptr, 0);\n  });\n  return timebase_frequency;\n#else\n#error Must implement UnscaledCycleClock::Frequency()\n#endif\n}\n\n#elif defined(__aarch64__)\n\n// System timer of ARMv8 runs at a different frequency than the CPU's.\n// The frequency is fixed, typically in the range 1-50MHz.  It can be\n// read at CNTFRQ special register.  We assume the OS has set up\n// the virtual timer properly.\nint64_t UnscaledCycleClock::Now() {\n  int64_t virtual_timer_value;\n  asm volatile(\"mrs %0, cntvct_el0\" : \"=r\"(virtual_timer_value));\n  return virtual_timer_value;\n}\n\ndouble UnscaledCycleClock::Frequency() {\n  uint64_t aarch64_timer_frequency;\n  asm volatile(\"mrs %0, cntfrq_el0\" : \"=r\"(aarch64_timer_frequency));\n  return aarch64_timer_frequency;\n}\n\n#elif defined(__riscv)\n\nint64_t UnscaledCycleClock::Now() {\n  int64_t virtual_timer_value;\n  asm volatile(\"rdcycle %0\" : \"=r\"(virtual_timer_value));\n  return virtual_timer_value;\n}\n\ndouble UnscaledCycleClock::Frequency() {\n  return base_internal::NominalCPUFrequency();\n}\n\n#elif defined(_M_IX86) || defined(_M_X64)\n\n#pragma intrinsic(__rdtsc)\n\nint64_t UnscaledCycleClock::Now() { return __rdtsc(); }\n\ndouble UnscaledCycleClock::Frequency() {\n  return base_internal::NominalCPUFrequency();\n}\n\n#endif\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02400",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/unscaledcycleclock.cc",
  "source_line": 39,
  "validation_status": "validated"
}