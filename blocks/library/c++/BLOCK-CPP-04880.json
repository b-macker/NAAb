{
  "code": "{\n  using node_type = btree_node<Params>;\n  using is_key_compare_to = typename Params::is_key_compare_to;\n  using field_type = typename node_type::field_type;\n\n  // We use a static empty node for the root/leftmost/rightmost of empty btrees\n  // in order to avoid branching in begin()/end().\n  struct EmptyNodeType : node_type {\n    using field_type = typename node_type::field_type;\n    node_type *parent;\n#ifdef ABSL_BTREE_ENABLE_GENERATIONS\n    uint32_t generation = 0;\n#endif\n    field_type position = 0;\n    field_type start = 0;\n    field_type finish = 0;\n    // max_count must be != kInternalNodeMaxCount (so that this node is regarded\n    // as a leaf node). max_count() is never called when the tree is empty.\n    field_type max_count = node_type::kInternalNodeMaxCount + 1;\n\n    constexpr EmptyNodeType() : parent(this) {}\n  };\n\n  static node_type *EmptyNode() {\n    alignas(node_type::Alignment()) static constexpr EmptyNodeType empty_node;\n    return const_cast<EmptyNodeType *>(&empty_node);\n  }\n\n  enum : uint32_t {\n    kNodeSlots = node_type::kNodeSlots,\n    kMinNodeValues = kNodeSlots / 2,\n  };\n\n  struct node_stats {\n    using size_type = typename Params::size_type;\n\n    node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i) {}\n\n    node_stats &operator+=(const node_stats &other) {\n      leaf_nodes += other.leaf_nodes;\n      internal_nodes += other.internal_nodes;\n      return *this;\n    }\n\n    size_type leaf_nodes;\n    size_type internal_nodes;\n  };\n\n public:\n  using key_type = typename Params::key_type;\n  using value_type = typename Params::value_type;\n  using size_type = typename Params::size_type;\n  using difference_type = typename Params::difference_type;\n  using key_compare = typename Params::key_compare;\n  using original_key_compare = typename Params::original_key_compare;\n  using value_compare = typename Params::value_compare;\n  using allocator_type = typename Params::allocator_type;\n  using reference = typename Params::reference;\n  using const_reference = typename Params::const_reference;\n  using pointer = typename Params::pointer;\n  using const_pointer = typename Params::const_pointer;\n  using iterator =\n      typename btree_iterator<node_type, reference, pointer>::iterator;\n  using const_iterator = typename iterator::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using node_handle_type = node_handle<Params, Params, allocator_type>;\n\n  // Internal types made public for use by btree_container types.\n  using params_type = Params;\n  using slot_type = typename Params::slot_type;\n\n private:\n  // Copies or moves (depending on the template parameter) the values in\n  // other into this btree in their order in other. This btree must be empty\n  // before this method is called. This method is used in copy construction,\n  // copy assignment, and move assignment.\n  template <typename Btree>\n  void copy_or_move_values_in_order(Btree &other);\n\n  // Validates that various assumptions/requirements are true at compile time.\n  constexpr static bool static_assert_validation();\n\n public:\n  btree(const key_compare &comp, const allocator_type &alloc)\n      : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0) {}\n\n  btree(const btree &other) : btree(other, other.allocator()) {}\n  btree(const btree &other, const allocator_type &alloc)\n      : btree(other.key_comp(), alloc) {\n    copy_or_move_values_in_order(other);\n  }\n  btree(btree &&other) noexcept\n      : root_(absl::exchange(other.root_, EmptyNode())),\n        rightmost_(std::move(other.rightmost_)),\n        size_(absl::exchange(other.size_, 0u)) {\n    other.mutable_rightmost() = EmptyNode();\n  }\n  btree(btree &&other, const allocator_type &alloc)\n      : btree(other.key_comp(), alloc) {\n    if (alloc == other.allocator()) {\n      swap(other);\n    } else {\n      // Move values from `other` one at a time when allocators are different.\n      copy_or_move_values_in_order(other);\n    }\n  }\n\n  ~btree() {\n    // Put static_asserts in destructor to avoid triggering them before the type\n    // is complete.\n    static_assert(static_assert_validation(), \"This call must be elided.\");\n    clear();\n  }\n\n  // Assign the contents of other to *this.\n  btree &operator=(const btree &other);\n  btree &operator=(btree &&other) noexcept;\n\n  iterator begin() { return iterator(leftmost()); }\n  const_iterator begin() const { return const_iterator(leftmost()); }\n  iterator end() { return iterator(rightmost(), rightmost()->finish()); }\n  const_iterator end() const {\n    return const_iterator(rightmost(), rightmost()->finish());\n  }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  // Finds the first element whose key is not less than `key`.\n  template <typename K>\n  iterator lower_bound(const K &key) {\n    return internal_end(internal_lower_bound(key).value);\n  }\n  template <typename K>\n  const_iterator lower_bound(const K &key) const {\n    return internal_end(internal_lower_bound(key).value);\n  }\n\n  // Finds the first element whose key is not less than `key` and also returns\n  // whether that element is equal to `key`.\n  template <typename K>\n  std::pair<iterator, bool> lower_bound_equal(const K &key) const;\n\n  // Finds the first element whose key is greater than `key`.\n  template <typename K>\n  iterator upper_bound(const K &key) {\n    return internal_end(internal_upper_bound(key));\n  }\n  template <typename K>\n  const_iterator upper_bound(const K &key) const {\n    return internal_end(internal_upper_bound(key));\n  }\n\n  // Finds the range of values which compare equal to key. The first member of\n  // the returned pair is equal to lower_bound(key). The second member of the\n  // pair is equal to upper_bound(key).\n  template <typename K>\n  std::pair<iterator, iterator> equal_range(const K &key);\n  template <typename K>\n  std::pair<const_iterator, const_iterator> equal_range(const K &key) const {\n    return const_cast<btree *>(this)->equal_range(key);\n  }\n\n  // Inserts a value into the btree only if it does not already exist. The\n  // boolean return value indicates whether insertion succeeded or failed.\n  // Requirement: if `key` already exists in the btree, does not consume `args`.\n  // Requirement: `key` is never referenced after consuming `args`.\n  template <typename K, typename... Args>\n  std::pair<iterator, bool> insert_unique(const K &key, Args &&...args);\n\n  // Inserts with hint. Checks to see if the value should be placed immediately\n  // before `position` in the tree. If so, then the insertion will take\n  // amortized constant time. If not, the insertion will take amortized\n  // logarithmic time as if a call to insert_unique() were made.\n  // Requirement: if `key` already exists in the btree, does not consume `args`.\n  // Requirement: `key` is never referenced after consuming `args`.\n  template <typename K, typename... Args>\n  std::pair<iterator, bool> insert_hint_unique(iterator position, const K &key,\n                                               Args &&...args);\n\n  // Insert a range of values into the btree.\n  // Note: the first overload avoids constructing a value_type if the key\n  // already exists in the btree.\n  template <typename InputIterator,\n            typename = decltype(std::declval<const key_compare &>()(\n                params_type::key(*std::declval<InputIterator>()),\n                std::declval<const key_type &>()))>\n  void insert_iterator_unique(InputIterator b, InputIterator e, int);\n  // We need the second overload for cases in which we need to construct a\n  // value_type in order to compare it with the keys already in the btree.\n  template <typename InputIterator>\n  void insert_iterator_unique(InputIterator b, InputIterator e, char);\n\n  // Inserts a value into the btree.\n  template <typename ValueType>\n  iterator insert_multi(const key_type &key, ValueType &&v);\n\n  // Inserts a value into the btree.\n  template <typename ValueType>\n  iterator insert_multi(ValueType &&v) {\n    return insert_multi(params_type::key(v), std::forward<ValueType>(v));\n  }\n\n  // Insert with hint. Check to see if the value should be placed immediately\n  // before position in the tree. If it does, then the insertion will take\n  // amortized constant time. If not, the insertion will take amortized\n  // logarithmic time as if a call to insert_multi(v) were made.\n  template <typename ValueType>\n  iterator insert_hint_multi(iterator position, ValueType &&v);\n\n  // Insert a range of values into the btree.\n  template <typename InputIterator>\n  void insert_iterator_multi(InputIterator b,\n                             InputIterator e);\n\n  // Erase the specified iterator from the btree. The iterator must be valid\n  // (i.e. not equal to end()).  Return an iterator pointing to the node after\n  // the one that was erased (or end() if none exists).\n  // Requirement: does not read the value at `*iter`.\n  iterator erase(iterator iter);\n\n  // Erases range. Returns the number of keys erased and an iterator pointing\n  // to the element after the last erased element.\n  std::pair<size_type, iterator> erase_range(iterator begin, iterator end);\n\n  // Finds an element with key equivalent to `key` or returns `end()` if `key`\n  // is not present.\n  template <typename K>\n  iterator find(const K &key) {\n    return internal_end(internal_find(key));\n  }\n  template <typename K>\n  const_iterator find(const K &key) const {\n    return internal_end(internal_find(key));\n  }\n\n  // Clear the btree, deleting all of the values it contains.\n  void clear();\n\n  // Swaps the contents of `this` and `other`.\n  void swap(btree &other);\n\n  const key_compare &key_comp() const noexcept {\n    return rightmost_.template get<0>();\n  }\n  template <typename K1, typename K2>\n  bool compare_keys(const K1 &a, const K2 &b) const {\n    return compare_internal::compare_result_as_less_than(key_comp()(a, b));\n  }\n\n  value_compare value_comp() const {\n    return value_compare(original_key_compare(key_comp()));\n  }\n\n  // Verifies the structure of the btree.\n  void verify() const;\n\n  // Size routines.\n  size_type size() const { return size_; }\n  size_type max_size() const { return (std::numeric_limits<size_type>::max)(); }\n  bool empty() const { return size_ == 0; }\n\n  // The height of the btree. An empty tree will have height 0.\n  size_type height() const {\n    size_type h = 0;\n    if (!empty()) {\n      // Count the length of the chain from the leftmost node up to the\n      // root. We actually count from the root back around to the level below\n      // the root, but the calculation is the same because of the circularity\n      // of that traversal.\n      const node_type *n = root();\n      do {\n        ++h;\n        n = n->parent();\n      } while (n != root());\n    }\n    return h;\n  }\n\n  // The number of internal, leaf and total nodes used by the btree.\n  size_type leaf_nodes() const { return internal_stats(root()).leaf_nodes; }\n  size_type internal_nodes() const {\n    return internal_stats(root()).internal_nodes;\n  }\n  size_type nodes() const {\n    node_stats stats = internal_stats(root());\n    return stats.leaf_nodes + stats.internal_nodes;\n  }\n\n  // The total number of bytes used by the btree.\n  // TODO(b/169338300): update to support node_btree_*.\n  size_type bytes_used() const {\n    node_stats stats = internal_stats(root());\n    if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {\n      return sizeof(*this) + node_type::LeafSize(root()->max_count());\n    } else {\n      return sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() +\n             stats.internal_nodes * node_type::InternalSize();\n    }\n  }\n\n  // The average number of bytes used per value stored in the btree assuming\n  // random insertion order.\n  static double average_bytes_per_value() {\n    // The expected number of values per node with random insertion order is the\n    // average of the maximum and minimum numbers of values per node.\n    const double expected_values_per_node = (kNodeSlots + kMinNodeValues) / 2.0;\n    return node_type::LeafSize() / expected_values_per_node;\n  }\n\n  // The fullness of the btree. Computed as the number of elements in the btree\n  // divided by the maximum number of elements a tree with the current number\n  // of nodes could hold. A value of 1 indicates perfect space\n  // utilization. Smaller values indicate space wastage.\n  // Returns 0 for empty trees.\n  double fullness() const {\n    if (empty()) return 0.0;\n    return static_cast<double>(size()) / (nodes() * kNodeSlots);\n  }\n  // The overhead of the btree structure in bytes per node. Computed as the\n  // total number of bytes used by the btree minus the number of bytes used for\n  // storing elements divided by the number of elements.\n  // Returns 0 for empty trees.\n  double overhead() const {\n    if (empty()) return 0.0;\n    return (bytes_used() - size() * sizeof(value_type)) /\n           static_cast<double>(size());\n  }\n\n  // The allocator used by the btree.\n  allocator_type get_allocator() const { return allocator(); }\n\n private:\n  friend struct btree_access;\n\n  // Internal accessor routines.\n  node_type *root() { return root_; }\n  const node_type *root() const { return root_; }\n  node_type *&mutable_root() noexcept { return root_; }\n  node_type *rightmost() { return rightmost_.template get<2>(); }\n  const node_type *rightmost() const { return rightmost_.template get<2>(); }\n  node_type *&mutable_rightmost() noexcept {\n    return rightmost_.template get<2>();\n  }\n  key_compare *mutable_key_comp() noexcept {\n    return &rightmost_.template get<0>();\n  }\n\n  // The leftmost node is stored as the parent of the root node.\n  node_type *leftmost() { return root()->parent(); }\n  const node_type *leftmost() const { return root()->parent(); }\n\n  // Allocator routines.\n  allocator_type *mutable_allocator() noexcept {\n    return &rightmost_.template get<1>();\n  }\n  const allocator_type &allocator() const noexcept {\n    return rightmost_.template get<1>();\n  }\n\n  // Allocates a correctly aligned node of at least size bytes using the\n  // allocator.\n  node_type *allocate(size_type size) {\n    return reinterpret_cast<node_type *>(\n        absl::container_internal::Allocate<node_type::Alignment()>(\n            mutable_allocator(), size));\n  }\n\n  // Node creation/deletion routines.\n  node_type *new_internal_node(field_type position, node_type *parent) {\n    node_type *n = allocate(node_type::InternalSize());\n    n->init_internal(position, parent);\n    return n;\n  }\n  node_type *new_leaf_node(field_type position, node_type *parent) {\n    node_type *n = allocate(node_type::LeafSize());\n    n->init_leaf(position, kNodeSlots, parent);\n    return n;\n  }\n  node_type *new_leaf_root_node(field_type max_count) {\n    node_type *n = allocate(node_type::LeafSize(max_count));\n    n->init_leaf(/*position=*/0, max_count, /*parent=*/n);\n    return n;\n  }\n\n  // Deletion helper routines.\n  iterator rebalance_after_delete(iterator iter);\n\n  // Rebalances or splits the node iter points to.\n  void rebalance_or_split(iterator *iter);\n\n  // Merges the values of left, right and the delimiting key on their parent\n  // onto left, removing the delimiting key and deleting right.\n  void merge_nodes(node_type *left, node_type *right);\n\n  // Tries to merge node with its left or right sibling, and failing that,\n  // rebalance with its left or right sibling. Returns true if a merge\n  // occurred, at which point it is no longer valid to access node. Returns\n  // false if no merging took place.\n  bool try_merge_or_rebalance(iterator *iter);\n\n  // Tries to shrink the height of the tree by 1.\n  void try_shrink();\n\n  iterator internal_end(iterator iter) {\n    return iter.node_ != nullptr ? iter : end();\n  }\n  const_iterator internal_end(const_iterator iter) const {\n    return iter.node_ != nullptr ? iter : end();\n  }\n\n  // Emplaces a value into the btree immediately before iter. Requires that\n  // key(v) <= iter.key() and (--iter).key() <= key(v).\n  template <typename... Args>\n  iterator internal_emplace(iterator iter, Args &&...args);\n\n  // Returns an iterator pointing to the first value >= the value \"iter\" is\n  // pointing at. Note that \"iter\" might be pointing to an invalid location such\n  // as iter.position_ == iter.node_->finish(). This routine simply moves iter\n  // up in the tree to a valid location. Requires: iter.node_ is non-null.\n  template <typename IterType>\n  static IterType internal_last(IterType iter);\n\n  // Returns an iterator pointing to the leaf position at which key would\n  // reside in the tree, unless there is an exact match - in which case, the\n  // result may not be on a leaf. When there's a three-way comparator, we can\n  // return whether there was an exact match. This allows the caller to avoid a\n  // subsequent comparison to determine if an exact match was made, which is\n  // important for keys with expensive comparison, such as strings.\n  template <typename K>\n  SearchResult<iterator, is_key_compare_to::value> internal_locate(\n      const K &key) const;\n\n  // Internal routine which implements lower_bound().\n  template <typename K>\n  SearchResult<iterator, is_key_compare_to::value> internal_lower_bound(\n      const K &key) const;\n\n  // Internal routine which implements upper_bound().\n  template <typename K>\n  iterator internal_upper_bound(const K &key) const;\n\n  // Internal routine which implements find().\n  template <typename K>\n  iterator internal_find(const K &key) const;\n\n  // Verifies the tree structure of node.\n  size_type internal_verify(const node_type *node, const key_type *lo,\n                            const key_type *hi) const;\n\n  node_stats internal_stats(const node_type *node) const {\n    // The root can be a static empty node.\n    if (node == nullptr || (node == root() && empty())) {\n      return node_stats(0, 0);\n    }\n    if (node->is_leaf()) {\n      return node_stats(1, 0);\n    }\n    node_stats res(0, 1);\n    for (int i = node->start(); i <= node->finish(); ++i) {\n      res += internal_stats(node->child(i));\n    }\n    return res;\n  }\n\n  node_type *root_;\n\n  // A pointer to the rightmost node. Note that the leftmost node is stored as\n  // the root's parent. We use compressed tuple in order to save space because\n  // key_compare and allocator_type are usually empty.\n  absl::container_internal::CompressedTuple<key_compare, allocator_type,\n                                            node_type *>\n      rightmost_;\n\n  // Number of values.\n  size_type size_;\n}",
  "id": "BLOCK-CPP-04880",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree.h",
  "source_line": 1316,
  "validation_status": "validated"
}