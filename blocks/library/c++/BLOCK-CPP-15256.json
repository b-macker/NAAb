{
  "code": "{\npublic:\n  /// Takes ownership of the provided implementation pointer.\n  template <typename T>\n  DynTypedMatcher(MatcherInterface<T> *Implementation)\n      : SupportedKind(ASTNodeKind::getFromNodeKind<T>()),\n        RestrictKind(SupportedKind), Implementation(Implementation) {}\n\n  /// Construct from a variadic function.\n  enum VariadicOperator {\n    /// Matches nodes for which all provided matchers match.\n    VO_AllOf,\n\n    /// Matches nodes for which at least one of the provided matchers\n    /// matches.\n    VO_AnyOf,\n\n    /// Matches nodes for which at least one of the provided matchers\n    /// matches, but doesn't stop at the first match.\n    VO_EachOf,\n\n    /// Matches any node but executes all inner matchers to find result\n    /// bindings.\n    VO_Optionally,\n\n    /// Matches nodes that do not match the provided matcher.\n    ///\n    /// Uses the variadic matcher interface, but fails if\n    /// InnerMatchers.size() != 1.\n    VO_UnaryNot\n  };\n\n  static DynTypedMatcher\n  constructVariadic(VariadicOperator Op, ASTNodeKind SupportedKind,\n                    std::vector<DynTypedMatcher> InnerMatchers);\n\n  static DynTypedMatcher\n  constructRestrictedWrapper(const DynTypedMatcher &InnerMatcher,\n                             ASTNodeKind RestrictKind);\n\n  /// Get a \"true\" matcher for \\p NodeKind.\n  ///\n  /// It only checks that the node is of the right kind.\n  static DynTypedMatcher trueMatcher(ASTNodeKind NodeKind);\n\n  void setAllowBind(bool AB) { AllowBind = AB; }\n\n  /// Check whether this matcher could ever match a node of kind \\p Kind.\n  /// \\return \\c false if this matcher will never match such a node. Otherwise,\n  /// return \\c true.\n  bool canMatchNodesOfKind(ASTNodeKind Kind) const;\n\n  /// Return a matcher that points to the same implementation, but\n  ///   restricts the node types for \\p Kind.\n  DynTypedMatcher dynCastTo(const ASTNodeKind Kind) const;\n\n  /// Return a matcher that points to the same implementation, but sets the\n  ///   traversal kind.\n  ///\n  /// If the traversal kind is already set, then \\c TK overrides it.\n  DynTypedMatcher withTraversalKind(TraversalKind TK);\n\n  /// Returns true if the matcher matches the given \\c DynNode.\n  bool matches(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const;\n\n  /// Same as matches(), but skips the kind check.\n  ///\n  /// It is faster, but the caller must ensure the node is valid for the\n  /// kind of this matcher.\n  bool matchesNoKindCheck(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const;\n\n  /// Bind the specified \\p ID to the matcher.\n  /// \\return A new matcher with the \\p ID bound to it if this matcher supports\n  ///   binding. Otherwise, returns an empty \\c std::optional<>.\n  std::optional<DynTypedMatcher> tryBind(StringRef ID) const;\n\n  /// Returns a unique \\p ID for the matcher.\n  ///\n  /// Casting a Matcher<T> to Matcher<U> creates a matcher that has the\n  /// same \\c Implementation pointer, but different \\c RestrictKind. We need to\n  /// include both in the ID to make it unique.\n  ///\n  /// \\c MatcherIDType supports operator< and provides strict weak ordering.\n  using MatcherIDType = std::pair<ASTNodeKind, uint64_t>;\n  MatcherIDType getID() const {\n    /// FIXME: Document the requirements this imposes on matcher\n    /// implementations (no new() implementation_ during a Matches()).\n    return std::make_pair(RestrictKind,\n                          reinterpret_cast<uint64_t>(Implementation.get()));\n  }\n\n  /// Returns the type this matcher works on.\n  ///\n  /// \\c matches() will always return false unless the node passed is of this\n  /// or a derived type.\n  ASTNodeKind getSupportedKind() const { return SupportedKind; }\n\n  /// Returns \\c true if the passed \\c DynTypedMatcher can be converted\n  ///   to a \\c Matcher<T>.\n  ///\n  /// This method verifies that the underlying matcher in \\c Other can process\n  /// nodes of types T.\n  template <typename T> bool canConvertTo() const {\n    return canConvertTo(ASTNodeKind::getFromNodeKind<T>());\n  }\n  bool canConvertTo(ASTNodeKind To) const;\n\n  /// Construct a \\c Matcher<T> interface around the dynamic matcher.\n  ///\n  /// This method asserts that \\c canConvertTo() is \\c true. Callers\n  /// should call \\c canConvertTo() first to make sure that \\c this is\n  /// compatible with T.\n  template <typename T> Matcher<T> convertTo() const {\n    assert(canConvertTo<T>());\n    return unconditionalConvertTo<T>();\n  }\n\n  /// Same as \\c convertTo(), but does not check that the underlying\n  ///   matcher can handle a value of T.\n  ///\n  /// If it is not compatible, then this matcher will never match anything.\n  template <typename T> Matcher<T> unconditionalConvertTo() const;\n\n  /// Returns the \\c TraversalKind respected by calls to `match()`, if any.\n  ///\n  /// Most matchers will not have a traversal kind set, instead relying on the\n  /// surrounding context. For those, \\c std::nullopt is returned.\n  std::optional<clang::TraversalKind> getTraversalKind() const {\n    return Implementation->TraversalKind();\n  }\n\nprivate:\n  DynTypedMatcher(ASTNodeKind SupportedKind, ASTNodeKind RestrictKind,\n                  IntrusiveRefCntPtr<DynMatcherInterface> Implementation)\n      : SupportedKind(SupportedKind), RestrictKind(RestrictKind),\n        Implementation(std::move(Implementation)) {}\n\n  bool AllowBind = false;\n  ASTNodeKind SupportedKind;\n\n  /// A potentially stricter node kind.\n  ///\n  /// It allows to perform implicit and dynamic cast of matchers without\n  /// needing to change \\c Implementation.\n  ASTNodeKind RestrictKind;\n  IntrusiveRefCntPtr<DynMatcherInterface> Implementation;\n}",
  "id": "BLOCK-CPP-15256",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchersInternal.h",
  "source_line": 410,
  "validation_status": "validated"
}