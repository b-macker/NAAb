{
  "code": "{\n  public:\n    /// Kind - The kind of implicit conversion sequence. BadConversion\n    /// specifies that there is no conversion from the source type to\n    /// the target type.  AmbiguousConversion represents the unique\n    /// ambiguous conversion (C++0x [over.best.ics]p10).\n    /// StaticObjectArgumentConversion represents the conversion rules for\n    /// the synthesized first argument of calls to static member functions\n    /// ([over.best.ics.general]p8).\n    enum Kind {\n      StandardConversion = 0,\n      StaticObjectArgumentConversion,\n      UserDefinedConversion,\n      AmbiguousConversion,\n      EllipsisConversion,\n      BadConversion\n    };\n\n  private:\n    enum {\n      Uninitialized = BadConversion + 1\n    };\n\n    /// ConversionKind - The kind of implicit conversion sequence.\n    unsigned ConversionKind : 31;\n\n    // Whether the initializer list was of an incomplete array.\n    unsigned InitializerListOfIncompleteArray : 1;\n\n    /// When initializing an array or std::initializer_list from an\n    /// initializer-list, this is the array or std::initializer_list type being\n    /// initialized. The remainder of the conversion sequence, including ToType,\n    /// describe the worst conversion of an initializer to an element of the\n    /// array or std::initializer_list. (Note, 'worst' is not well defined.)\n    QualType InitializerListContainerType;\n\n    void setKind(Kind K) {\n      destruct();\n      ConversionKind = K;\n    }\n\n    void destruct() {\n      if (ConversionKind == AmbiguousConversion) Ambiguous.destruct();\n    }\n\n  public:\n    union {\n      /// When ConversionKind == StandardConversion, provides the\n      /// details of the standard conversion sequence.\n      StandardConversionSequence Standard;\n\n      /// When ConversionKind == UserDefinedConversion, provides the\n      /// details of the user-defined conversion sequence.\n      UserDefinedConversionSequence UserDefined;\n\n      /// When ConversionKind == AmbiguousConversion, provides the\n      /// details of the ambiguous conversion.\n      AmbiguousConversionSequence Ambiguous;\n\n      /// When ConversionKind == BadConversion, provides the details\n      /// of the bad conversion.\n      BadConversionSequence Bad;\n    };\n\n    ImplicitConversionSequence()\n        : ConversionKind(Uninitialized),\n          InitializerListOfIncompleteArray(false) {\n      Standard.setAsIdentityConversion();\n    }\n\n    ImplicitConversionSequence(const ImplicitConversionSequence &Other)\n        : ConversionKind(Other.ConversionKind),\n          InitializerListOfIncompleteArray(\n              Other.InitializerListOfIncompleteArray),\n          InitializerListContainerType(Other.InitializerListContainerType) {\n      switch (ConversionKind) {\n      case Uninitialized: break;\n      case StandardConversion: Standard = Other.Standard; break;\n      case StaticObjectArgumentConversion:\n        break;\n      case UserDefinedConversion: UserDefined = Other.UserDefined; break;\n      case AmbiguousConversion: Ambiguous.copyFrom(Other.Ambiguous); break;\n      case EllipsisConversion: break;\n      case BadConversion: Bad = Other.Bad; break;\n      }\n    }\n\n    ImplicitConversionSequence &\n    operator=(const ImplicitConversionSequence &Other) {\n      destruct();\n      new (this) ImplicitConversionSequence(Other);\n      return *this;\n    }\n\n    ~ImplicitConversionSequence() {\n      destruct();\n    }\n\n    Kind getKind() const {\n      assert(isInitialized() && \"querying uninitialized conversion\");\n      return Kind(ConversionKind);\n    }\n\n    /// Return a ranking of the implicit conversion sequence\n    /// kind, where smaller ranks represent better conversion\n    /// sequences.\n    ///\n    /// In particular, this routine gives user-defined conversion\n    /// sequences and ambiguous conversion sequences the same rank,\n    /// per C++ [over.best.ics]p10.\n    unsigned getKindRank() const {\n      switch (getKind()) {\n      case StandardConversion:\n      case StaticObjectArgumentConversion:\n        return 0;\n\n      case UserDefinedConversion:\n      case AmbiguousConversion:\n        return 1;\n\n      case EllipsisConversion:\n        return 2;\n\n      case BadConversion:\n        return 3;\n      }\n\n      llvm_unreachable(\"Invalid ImplicitConversionSequence::Kind!\");\n    }\n\n    bool isBad() const { return getKind() == BadConversion; }\n    bool isStandard() const { return getKind() == StandardConversion; }\n    bool isStaticObjectArgument() const {\n      return getKind() == StaticObjectArgumentConversion;\n    }\n    bool isEllipsis() const { return getKind() == EllipsisConversion; }\n    bool isAmbiguous() const { return getKind() == AmbiguousConversion; }\n    bool isUserDefined() const { return getKind() == UserDefinedConversion; }\n    bool isFailure() const { return isBad() || isAmbiguous(); }\n\n    /// Determines whether this conversion sequence has been\n    /// initialized.  Most operations should never need to query\n    /// uninitialized conversions and should assert as above.\n    bool isInitialized() const { return ConversionKind != Uninitialized; }\n\n    /// Sets this sequence as a bad conversion for an explicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                Expr *FromExpr, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromExpr, ToType);\n    }\n\n    /// Sets this sequence as a bad conversion for an implicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                QualType FromType, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromType, ToType);\n    }\n\n    void setStandard() { setKind(StandardConversion); }\n    void setStaticObjectArgument() { setKind(StaticObjectArgumentConversion); }\n    void setEllipsis() { setKind(EllipsisConversion); }\n    void setUserDefined() { setKind(UserDefinedConversion); }\n\n    void setAmbiguous() {\n      if (ConversionKind == AmbiguousConversion) return;\n      ConversionKind = AmbiguousConversion;\n      Ambiguous.construct();\n    }\n\n    void setAsIdentityConversion(QualType T) {\n      setStandard();\n      Standard.setAsIdentityConversion();\n      Standard.setFromType(T);\n      Standard.setAllToTypes(T);\n    }\n\n    // True iff this is a conversion sequence from an initializer list to an\n    // array or std::initializer.\n    bool hasInitializerListContainerType() const {\n      return !InitializerListContainerType.isNull();\n    }\n    void setInitializerListContainerType(QualType T, bool IA) {\n      InitializerListContainerType = T;\n      InitializerListOfIncompleteArray = IA;\n    }\n    bool isInitializerListOfIncompleteArray() const {\n      return InitializerListOfIncompleteArray;\n    }\n    QualType getInitializerListContainerType() const {\n      assert(hasInitializerListContainerType() &&\n             \"not initializer list container\");\n      return InitializerListContainerType;\n    }\n\n    /// Form an \"implicit\" conversion sequence from nullptr_t to bool, for a\n    /// direct-initialization of a bool object from nullptr_t.\n    static ImplicitConversionSequence getNullptrToBool(QualType SourceType,\n                                                       QualType DestType,\n                                                       bool NeedLValToRVal) {\n      ImplicitConversionSequence ICS;\n      ICS.setStandard();\n      ICS.Standard.setAsIdentityConversion();\n      ICS.Standard.setFromType(SourceType);\n      if (NeedLValToRVal)\n        ICS.Standard.First = ICK_Lvalue_To_Rvalue;\n      ICS.Standard.setToType(0, SourceType);\n      ICS.Standard.Second = ICK_Boolean_Conversion;\n      ICS.Standard.setToType(1, DestType);\n      ICS.Standard.setToType(2, DestType);\n      return ICS;\n    }\n\n    // The result of a comparison between implicit conversion\n    // sequences. Use Sema::CompareImplicitConversionSequences to\n    // actually perform the comparison.\n    enum CompareKind {\n      Better = -1,\n      Indistinguishable = 0,\n      Worse = 1\n    };\n\n    void DiagnoseAmbiguousConversion(Sema &S,\n                                     SourceLocation CaretLoc,\n                                     const PartialDiagnostic &PDiag) const;\n\n    void dump() const;\n  }",
  "id": "BLOCK-CPP-20046",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Overload.h",
  "source_line": 520,
  "validation_status": "validated"
}