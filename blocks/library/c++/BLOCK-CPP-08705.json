{
  "code": "{\n///   float f;\n/// public:\n///   B(A& a) : A(a), f(3.14159) { }\n/// };\n/// \\endcode\nclass CXXCtorInitializer final {\n  /// Either the base class name/delegating constructor type (stored as\n  /// a TypeSourceInfo*), an normal field (FieldDecl), or an anonymous field\n  /// (IndirectFieldDecl*) being initialized.\n  llvm::PointerUnion<TypeSourceInfo *, FieldDecl *, IndirectFieldDecl *>\n      Initializee;\n\n  /// The argument used to initialize the base or member, which may\n  /// end up constructing an object (when multiple arguments are involved).\n  Stmt *Init;\n\n  /// The source location for the field name or, for a base initializer\n  /// pack expansion, the location of the ellipsis.\n  ///\n  /// In the case of a delegating\n  /// constructor, it will still include the type's source location as the\n  /// Initializee points to the CXXConstructorDecl (to allow loop detection).\n  SourceLocation MemberOrEllipsisLocation;\n\n  /// Location of the left paren of the ctor-initializer.\n  SourceLocation LParenLoc;\n\n  /// Location of the right paren of the ctor-initializer.\n  SourceLocation RParenLoc;\n\n  /// If the initializee is a type, whether that type makes this\n  /// a delegating initialization.\n  unsigned IsDelegating : 1;\n\n  /// If the initializer is a base initializer, this keeps track\n  /// of whether the base is virtual or not.\n  unsigned IsVirtual : 1;\n\n  /// Whether or not the initializer is explicitly written\n  /// in the sources.\n  unsigned IsWritten : 1;\n\n  /// If IsWritten is true, then this number keeps track of the textual order\n  /// of this initializer in the original sources, counting from 0.\n  unsigned SourceOrder : 13;\n\npublic:\n  /// Creates a new base-class initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo, bool IsVirtual,\n                     SourceLocation L, Expr *Init, SourceLocation R,\n                     SourceLocation EllipsisLoc);\n\n  /// Creates a new member initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, FieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new anonymous field initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, IndirectFieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new delegating initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo,\n                     SourceLocation L, Expr *Init, SourceLocation R);\n\n  /// \\return Unique reproducible object identifier.\n  int64_t getID(const ASTContext &Context) const;\n\n  /// Determine whether this initializer is initializing a base class.\n  bool isBaseInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && !IsDelegating;\n  }\n\n  /// Determine whether this initializer is initializing a non-static\n  /// data member.\n  bool isMemberInitializer() const { return Initializee.is<FieldDecl*>(); }\n\n  bool isAnyMemberInitializer() const {\n    return isMemberInitializer() || isIndirectMemberInitializer();\n  }\n\n  bool isIndirectMemberInitializer() const {\n    return Initializee.is<IndirectFieldDecl*>();\n  }\n\n  /// Determine whether this initializer is an implicit initializer\n  /// generated for a field with an initializer defined on the member\n  /// declaration.\n  ///\n  /// In-class member initializers (also known as \"non-static data member\n  /// initializations\", NSDMIs) were introduced in C++11.\n  bool isInClassMemberInitializer() const {\n    return Init->getStmtClass() == Stmt::CXXDefaultInitExprClass;\n  }\n\n  /// Determine whether this initializer is creating a delegating\n  /// constructor.\n  bool isDelegatingInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && IsDelegating;\n  }\n\n  /// Determine whether this initializer is a pack expansion.\n  bool isPackExpansion() const {\n    return isBaseInitializer() && MemberOrEllipsisLocation.isValid();\n  }\n\n  // For a pack expansion, returns the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    if (!isPackExpansion())\n      return {};\n    return MemberOrEllipsisLocation;\n  }\n\n  /// If this is a base class initializer, returns the type of the\n  /// base class with location information. Otherwise, returns an NULL\n  /// type location.\n  TypeLoc getBaseClassLoc() const;\n\n  /// If this is a base class initializer, returns the type of the base class.\n  /// Otherwise, returns null.\n  const Type *getBaseClass() const;\n\n  /// Returns whether the base is virtual or not.\n  bool isBaseVirtual() const {\n    assert(isBaseInitializer() && \"Must call this on base initializer!\");\n\n    return IsVirtual;\n  }\n\n  /// Returns the declarator information for a base class or delegating\n  /// initializer.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Initializee.dyn_cast<TypeSourceInfo *>();\n  }\n\n  /// If this is a member initializer, returns the declaration of the\n  /// non-static data member being initialized. Otherwise, returns null.\n  FieldDecl *getMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    return nullptr;\n  }\n\n  FieldDecl *getAnyMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>()->getAnonField();\n    return nullptr;\n  }\n\n  IndirectFieldDecl *getIndirectMember() const {\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>();\n    return nullptr;\n  }\n\n  SourceLocation getMemberLocation() const {\n    return MemberOrEllipsisLocation;\n  }\n\n  /// Determine the source location of the initializer.\n  SourceLocation getSourceLocation() const;\n\n  /// Determine the source range covering the entire initializer.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Determine whether this initializer is explicitly written\n  /// in the source code.\n  bool isWritten() const { return IsWritten; }\n\n  /// Return the source position of the initializer, counting from 0.\n  /// If the initializer was implicit, -1 is returned.\n  int getSourceOrder() const {\n    return IsWritten ? static_cast<int>(SourceOrder) : -1;\n  }\n\n  /// Set the source order of this initializer.\n  ///\n  /// This can only be called once for each initializer; it cannot be called\n  /// on an initializer having a positive number of (implicit) array indices.\n  ///\n  /// This assumes that the initializer was written in the source code, and\n  /// ensures that isWritten() returns true.\n  void setSourceOrder(int Pos) {\n    assert(!IsWritten &&\n           \"setSourceOrder() used on implicit initializer\");\n    assert(SourceOrder == 0 &&\n           \"calling twice setSourceOrder() on the same initializer\");\n    assert(Pos >= 0 &&\n           \"setSourceOrder() used to make an initializer implicit\");\n    IsWritten = true;\n    SourceOrder = static_cast<unsigned>(Pos);\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Get the initializer.\n  Expr *getInit() const { return static_cast<Expr *>(Init); }\n};\n\n/// Description of a constructor that was inherited from a base class.\nclass InheritedConstructor {\n  ConstructorUsingShadowDecl *Shadow = nullptr;\n  CXXConstructorDecl *BaseCtor = nullptr;\n\npublic:\n  InheritedConstructor() = default;\n  InheritedConstructor(ConstructorUsingShadowDecl *Shadow,\n                       CXXConstructorDecl *BaseCtor)\n      : Shadow(Shadow), BaseCtor(BaseCtor) {}\n\n  explicit operator bool() const { return Shadow; }\n\n  ConstructorUsingShadowDecl *getShadowDecl() const { return Shadow; }\n  CXXConstructorDecl *getConstructor() const { return BaseCtor; }\n};\n\n/// Represents a C++ constructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   explicit X(int); // represented by a CXXConstructorDecl.\n/// };\n/// \\endcode\nclass CXXConstructorDecl final\n    : public CXXMethodDecl,\n      private llvm::TrailingObjects<CXXConstructorDecl, InheritedConstructor,\n                                    ExplicitSpecifier> {\n  // This class stores some data in DeclContext::CXXConstructorDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// \\name Support for base and member initializers.\n  /// \\{\n  /// The arguments used to initialize the base or member.\n  LazyCXXCtorInitializersPtr CtorInitializers;\n\n  CXXConstructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                     const DeclarationNameInfo &NameInfo, QualType T,\n                     TypeSourceInfo *TInfo, ExplicitSpecifier ES,\n                     bool UsesFPIntrin, bool isInline,\n                     bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                     InheritedConstructor Inherited,\n                     Expr *TrailingRequiresClause);\n\n  void anchor() override;\n\n  size_t numTrailingObjects(OverloadToken<InheritedConstructor>) const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n  size_t numTrailingObjects(OverloadToken<ExplicitSpecifier>) const {\n    return CXXConstructorDeclBits.HasTrailingExplicitSpecifier;\n  }\n\n  ExplicitSpecifier getExplicitSpecifierInternal() const {\n    if (CXXConstructorDeclBits.HasTrailingExplicitSpecifier)\n      return *getTrailingObjects<ExplicitSpecifier>();\n    return ExplicitSpecifier(\n        nullptr, CXXConstructorDeclBits.IsSimpleExplicit\n                     ? ExplicitSpecKind::ResolvedTrue\n                     : ExplicitSpecKind::ResolvedFalse);\n  }\n\n  enum TrailingAllocKind {\n    TAKInheritsConstructor = 1,\n    TAKHasTailExplicit = 1 << 1,\n  };\n\n  uint64_t getTrailingAllocKind() const {\n    return numTrailingObjects(OverloadToken<InheritedConstructor>()) |\n           (numTrailingObjects(OverloadToken<ExplicitSpecifier>()) << 1);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CXXConstructorDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                uint64_t AllocKind);\n  static CXXConstructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         ExplicitSpecifier ES, bool UsesFPIntrin, bool isInline,\n         bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n         InheritedConstructor Inherited = InheritedConstructor(),\n         Expr *TrailingRequiresClause = nullptr);\n\n  void setExplicitSpecifier(ExplicitSpecifier ES) {\n    assert((!ES.getExpr() ||\n            CXXConstructorDeclBits.HasTrailingExplicitSpecifier) &&\n           \"cannot set this explicit specifier. no trail-allocated space for \"\n           \"explicit\");\n    if (ES.getExpr())\n      *getCanonicalDecl()->getTrailingObjects<ExplicitSpecifier>() = ES;\n    else\n      CXXConstructorDeclBits.IsSimpleExplicit = ES.isExplicit();\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n\n  /// Return true if the declaration is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n\n  /// Iterates through the member/base initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// Iterates through the member/base initializer list.\n  using init_const_iterator = CXXCtorInitializer *const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  /// Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  using init_reverse_iterator = std::reverse_iterator<init_iterator>;\n  using init_const_reverse_iterator =\n      std::reverse_iterator<init_const_iterator>;\n\n  init_reverse_iterator init_rbegin() {\n    return init_reverse_iterator(init_end());\n  }\n  init_const_reverse_iterator init_rbegin() const {\n    return init_const_reverse_iterator(init_end());\n  }\n\n  init_reverse_iterator init_rend() {\n    return init_reverse_iterator(init_begin());\n  }\n  init_const_reverse_iterator init_rend() const {\n    return init_const_reverse_iterator(init_begin());\n  }\n\n  /// Determine the number of arguments used to initialize the member\n  /// or base.\n  unsigned getNumCtorInitializers() const {\n      return CXXConstructorDeclBits.NumCtorInitializers;\n  }\n\n  void setNumCtorInitializers(unsigned numCtorInitializers) {\n    CXXConstructorDeclBits.NumCtorInitializers = numCtorInitializers;\n    // This assert added because NumCtorInitializers is stored\n    // in CXXConstructorDeclBits as a bitfield and its width has\n    // been shrunk from 32 bits to fit into CXXConstructorDeclBitfields.\n    assert(CXXConstructorDeclBits.NumCtorInitializers ==\n           numCtorInitializers && \"NumCtorInitializers overflow!\");\n  }\n\n  void setCtorInitializers(CXXCtorInitializer **Initializers) {\n    CtorInitializers = Initializers;\n  }\n\n  /// Determine whether this constructor is a delegating constructor.\n  bool isDelegatingConstructor() const {\n    return (getNumCtorInitializers() == 1) &&\n           init_begin()[0]->isDelegatingInitializer();\n  }\n\n  /// When this constructor delegates to another, retrieve the target.\n  CXXConstructorDecl *getTargetConstructor() const;\n\n  /// Whether this constructor is a default\n  /// constructor (C++ [class.ctor]p5), which can be used to\n  /// default-initialize a class of this type.\n  bool isDefaultConstructor() const;\n\n  /// Whether this constructor is a copy constructor (C++ [class.copy]p2,\n  /// which can be used to copy the class.\n  ///\n  /// \\p TypeQuals will be set to the qualifiers on the\n  /// argument type. For example, \\p TypeQuals would be set to \\c\n  /// Qualifiers::Const for the following copy constructor:\n  ///\n  /// \\code\n  /// class X {\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n};\n\n/// Represents a C++ destructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   ~X(); // represented by a CXXDestructorDecl.\n/// };\n/// \\endcode\nclass CXXDestructorDecl : public CXXMethodDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  // FIXME: Don't allocate storage for these except in the first declaration\n  // of a virtual destructor.\n  FunctionDecl *OperatorDelete = nullptr;\n  Expr *OperatorDeleteThisArg = nullptr;\n\n  CXXDestructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool UsesFPIntrin, bool isInline,\n                    bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXDestructor, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, UsesFPIntrin, isInline, ConstexprKind,\n                      SourceLocation(), TrailingRequiresClause) {\n    setImplicit(isImplicitlyDeclared);\n  }\n\n  void anchor() override;\n\npublic:\n  static CXXDestructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool UsesFPIntrin, bool isInline, bool isImplicitlyDeclared,\n         ConstexprSpecKind ConstexprKind,\n         Expr *TrailingRequiresClause = nullptr);\n  static CXXDestructorDecl *CreateDeserialized(ASTContext & C, unsigned ID);\n\n  void setOperatorDelete(FunctionDecl *OD, Expr *ThisArg);\n\n  const FunctionDecl *getOperatorDelete() const {\n    return getCanonicalDecl()->OperatorDelete;\n  }\n\n  Expr *getOperatorDeleteThisArg() const {\n    return getCanonicalDecl()->OperatorDeleteThisArg;\n  }\n\n  CXXDestructorDecl *getCanonicalDecl() override {\n    return cast<CXXDestructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXDestructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXDestructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDestructor; }\n};\n\n/// Represents a C++ conversion function within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   operator bool();\n/// };\n/// \\endcode\nclass CXXConversionDecl : public CXXMethodDecl {\n  CXXConversionDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool UsesFPIntrin, bool isInline,\n                    ExplicitSpecifier ES, ConstexprSpecKind ConstexprKind,\n                    SourceLocation EndLocation,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXConversion, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, UsesFPIntrin, isInline, ConstexprKind,\n                      EndLocation, TrailingRequiresClause),\n        ExplicitSpec(ES) {}\n  void anchor() override;\n\n  ExplicitSpecifier ExplicitSpec;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXConversionDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool UsesFPIntrin, bool isInline, ExplicitSpecifier ES,\n         ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n         Expr *TrailingRequiresClause = nullptr);\n  static CXXConversionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  /// Return true if the declaration is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\n  /// Returns the type that this conversion function is converting to.\n  QualType getConversionType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Determine whether this conversion function is a conversion from\n  /// a lambda closure type to a block pointer.\n  bool isLambdaToBlockPointerConversion() const;\n\n  CXXConversionDecl *getCanonicalDecl() override {\n    return cast<CXXConversionDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConversionDecl *getCanonicalDecl() const {\n    return const_cast<CXXConversionDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConversion; }\n};\n\n/// Represents a linkage specification.\n///\n/// For example:\n/// \\code\n///   extern \"C\" void foo();\n/// \\endcode\nclass LinkageSpecDecl : public Decl, public DeclContext {\n  virtual void anchor();\n  // This class stores some data in DeclContext::LinkageSpecDeclBits to save\n  // some space. Use the provided accessors to access it.\npublic:\n  /// Represents the language in a linkage specification.\n  ///\n  /// The values are part of the serialization ABI for\n  /// ASTs and cannot be changed without altering that ABI.\n  enum LanguageIDs { lang_c = 1, lang_cxx = 2 };\n\nprivate:\n  /// The source location for the extern keyword.\n  SourceLocation ExternLoc;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  LinkageSpecDecl(DeclContext *DC, SourceLocation ExternLoc,\n                  SourceLocation LangLoc, LanguageIDs lang, bool HasBraces);\n\npublic:\n  static LinkageSpecDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation ExternLoc,\n                                 SourceLocation LangLoc, LanguageIDs Lang,\n                                 bool HasBraces);\n  static LinkageSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the language specified by this linkage specification.\n  LanguageIDs getLanguage() const {\n    return static_cast<LanguageIDs>(LinkageSpecDeclBits.Language);\n  }\n\n  /// Set the language specified by this linkage specification.\n  void setLanguage(LanguageIDs L) { LinkageSpecDeclBits.Language = L; }\n\n  /// Determines whether this linkage specification had braces in\n  /// its syntactic form.\n  bool hasBraces() const {\n    assert(!RBraceLoc.isValid() || LinkageSpecDeclBits.HasBraces);\n    return LinkageSpecDeclBits.HasBraces;\n  }\n\n  SourceLocation getExternLoc() const { return ExternLoc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setExternLoc(SourceLocation L) { ExternLoc = L; }\n  void setRBraceLoc(SourceLocation L) {\n    RBraceLoc = L;\n    LinkageSpecDeclBits.HasBraces = RBraceLoc.isValid();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return getRBraceLoc();\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(ExternLoc, getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == LinkageSpec; }\n\n  static DeclContext *castToDeclContext(const LinkageSpecDecl *D) {\n    return static_cast<DeclContext *>(const_cast<LinkageSpecDecl*>(D));\n  }\n\n  static LinkageSpecDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<LinkageSpecDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents C++ using-directive.\n///\n/// For example:\n/// \\code\n///    using namespace std;\n/// \\endcode\n///\n/// \\note UsingDirectiveDecl should be Decl not NamedDecl, but we provide\n/// artificial names for all using-directives in order to store\n/// them in DeclContext effectively.\nclass UsingDirectiveDecl : public NamedDecl {\n  /// The location of the \\c using keyword.\n  SourceLocation UsingLoc;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The namespace nominated by this using-directive.\n  NamedDecl *NominatedNamespace;\n\n  /// Enclosing context containing both using-directive and nominated\n  /// namespace.\n  DeclContext *CommonAncestor;\n\n  UsingDirectiveDecl(DeclContext *DC, SourceLocation UsingLoc,\n                     SourceLocation NamespcLoc,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc,\n                     NamedDecl *Nominated,\n                     DeclContext *CommonAncestor)\n      : NamedDecl(UsingDirective, DC, IdentLoc, getName()), UsingLoc(UsingLoc),\n        NamespaceLoc(NamespcLoc), QualifierLoc(QualifierLoc),\n        NominatedNamespace(Nominated), CommonAncestor(CommonAncestor) {}\n\n  /// Returns special DeclarationName used by using-directives.\n  ///\n  /// This is only used by DeclContext for storing UsingDirectiveDecls in\n  /// its lookup structure.\n  static DeclarationName getName() {\n    return DeclarationName::getUsingDirectiveName();\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  // Friend for getUsingDirectiveName.\n  friend class DeclContext;\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  NamedDecl *getNominatedNamespaceAsWritten() { return NominatedNamespace; }\n  const NamedDecl *getNominatedNamespaceAsWritten() const {\n    return NominatedNamespace;\n  }\n\n  /// Returns the namespace nominated by this using-directive.\n  NamespaceDecl *getNominatedNamespace();\n\n  const NamespaceDecl *getNominatedNamespace() const {\n    return const_cast<UsingDirectiveDecl*>(this)->getNominatedNamespace();\n  }\n\n  /// Returns the common ancestor context of this using-directive and\n  /// its nominated namespace.\n  DeclContext *getCommonAncestor() { return CommonAncestor; }\n  const DeclContext *getCommonAncestor() const { return CommonAncestor; }\n\n  /// Return the location of the \\c using keyword.\n  SourceLocation getUsingLoc() const { return UsingLoc; }\n\n  // FIXME: Could omit 'Key' in name.\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceKeyLocation() const { return NamespaceLoc; }\n\n  /// Returns the location of this using declaration's identifier.\n  SourceLocation getIdentLocation() const { return getLocation(); }\n\n  static UsingDirectiveDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation UsingLoc,\n                                    SourceLocation NamespaceLoc,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Nominated,\n                                    DeclContext *CommonAncestor);\n  static UsingDirectiveDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(UsingLoc, getLocation());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingDirective; }\n};\n\n/// Represents a C++ namespace alias.\n///\n/// For example:\n///\n/// \\code\n/// namespace Foo = Bar;\n/// \\endcode\nclass NamespaceAliasDecl : public NamedDecl,\n                           public Redeclarable<NamespaceAliasDecl> {\n  friend class ASTDeclReader;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The location of the namespace's identifier.\n  ///\n  /// This is accessed by TargetNameLoc.\n  SourceLocation IdentLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The Decl that this alias points to, either a NamespaceDecl or\n  /// a NamespaceAliasDecl.\n  NamedDecl *Namespace;\n\n  NamespaceAliasDecl(ASTContext &C, DeclContext *DC,\n                     SourceLocation NamespaceLoc, SourceLocation AliasLoc,\n                     IdentifierInfo *Alias, NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc, NamedDecl *Namespace)\n      : NamedDecl(NamespaceAlias, DC, AliasLoc, Alias), redeclarable_base(C),\n        NamespaceLoc(NamespaceLoc), IdentLoc(IdentLoc),\n        QualifierLoc(QualifierLoc), Namespace(Namespace) {}\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<NamespaceAliasDecl>;\n\n  NamespaceAliasDecl *getNextRedeclarationImpl() override;\n  NamespaceAliasDecl *getPreviousDeclImpl() override;\n  NamespaceAliasDecl *getMostRecentDeclImpl() override;\n\npublic:\n  static NamespaceAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation NamespaceLoc,\n                                    SourceLocation AliasLoc,\n                                    IdentifierInfo *Alias,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Namespace);\n\n  static NamespaceAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n\n  NamespaceAliasDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const NamespaceAliasDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the namespace declaration aliased by this directive.\n  NamespaceDecl *getNamespace() {\n    if (auto *AD = dyn_cast<NamespaceAliasDecl>(Namespace))\n      return AD->getNamespace();\n\n    return cast<NamespaceDecl>(Namespace);\n  }\n\n  const NamespaceDecl *getNamespace() const {\n    return const_cast<NamespaceAliasDecl *>(this)->getNamespace();\n  }\n\n  /// Returns the location of the alias name, i.e. 'foo' in\n  /// \"namespace foo = ns::bar;\".\n  SourceLocation getAliasLoc() const { return getLocation(); }\n\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceLoc() const { return NamespaceLoc; }\n\n  /// Returns the location of the identifier in the named namespace.\n  SourceLocation getTargetNameLoc() const { return IdentLoc; }\n\n  /// Retrieve the namespace that this alias refers to, which\n  /// may either be a NamespaceDecl or a NamespaceAliasDecl.\n  NamedDecl *getAliasedNamespace() const { return Namespace; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(NamespaceLoc, IdentLoc);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NamespaceAlias; }\n};\n\n/// Implicit declaration of a temporary that was materialized by\n/// a MaterializeTemporaryExpr and lifetime-extended by a declaration\nclass LifetimeExtendedTemporaryDecl final\n    : public Decl,\n      public Mergeable<LifetimeExtendedTemporaryDecl> {\n  friend class MaterializeTemporaryExpr;\n  friend class ASTDeclReader;\n\n  Stmt *ExprWithTemporary = nullptr;\n\n  /// The declaration which lifetime-extended this reference, if any.\n  /// Either a VarDecl, or (for a ctor-initializer) a FieldDecl.\n  ValueDecl *ExtendingDecl = nullptr;\n  unsigned ManglingNumber;\n\n  mutable APValue *Value = nullptr;\n\n  virtual void anchor();\n\n  LifetimeExtendedTemporaryDecl(Expr *Temp, ValueDecl *EDecl, unsigned Mangling)\n      : Decl(Decl::LifetimeExtendedTemporary, EDecl->getDeclContext(),\n             EDecl->getLocation()),\n        ExprWithTemporary(Temp), ExtendingDecl(EDecl),\n        ManglingNumber(Mangling) {}\n\n  LifetimeExtendedTemporaryDecl(EmptyShell)\n      : Decl(Decl::LifetimeExtendedTemporary, EmptyShell{}) {}\n\npublic:\n  static LifetimeExtendedTemporaryDecl *Create(Expr *Temp, ValueDecl *EDec,\n                                               unsigned Mangling) {\n    return new (EDec->getASTContext(), EDec->getDeclContext())\n        LifetimeExtendedTemporaryDecl(Temp, EDec, Mangling);\n  }\n  static LifetimeExtendedTemporaryDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID) {\n    return new (C, ID) LifetimeExtendedTemporaryDecl(EmptyShell{});\n  }\n\n  ValueDecl *getExtendingDecl() { return ExtendingDecl; }\n  const ValueDecl *getExtendingDecl() const { return ExtendingDecl; }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const;\n\n  /// Retrieve the expression to which the temporary materialization conversion\n  /// was applied. This isn't necessarily the initializer of the temporary due\n  /// to the C++98 delayed materialization rules, but\n  /// skipRValueSubobjectAdjustments can be used to find said initializer within\n  /// the subexpression.\n  Expr *getTemporaryExpr() { return cast<Expr>(ExprWithTemporary); }\n  const Expr *getTemporaryExpr() const { return cast<Expr>(ExprWithTemporary); }\n\n  unsigned getManglingNumber() const { return ManglingNumber; }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const;\n\n  APValue *getValue() const { return Value; }\n\n  // Iterators\n  Stmt::child_range childrenExpr() {\n    return Stmt::child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  Stmt::const_child_range childrenExpr() const {\n    return Stmt::const_child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::LifetimeExtendedTemporary;\n  }\n};\n\n/// Represents a shadow declaration implicitly introduced into a scope by a\n/// (resolved) using-declaration or using-enum-declaration to achieve\n/// the desired lookup semantics.\n///\n/// For example:\n/// \\code\n/// namespace A {\n///   void foo();\n///   void foo(int);\n///   struct foo {};\n///   enum bar { bar1, bar2 };\n/// }\n/// namespace B {\n///   // add a UsingDecl and three UsingShadowDecls (named foo) to B.\n///   using A::foo;\n///   // adds UsingEnumDecl and two UsingShadowDecls (named bar1 and bar2) to B.\n///   using enum A::bar;\n/// }\n/// \\endcode\nclass UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl> {\n  friend class BaseUsingDecl;\n\n  /// The referenced declaration.\n  NamedDecl *Underlying = nullptr;\n\n  /// The using declaration which introduced this decl or the next using\n  /// shadow declaration contained in the aforementioned using declaration.\n  NamedDecl *UsingOrNextShadow = nullptr;\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<UsingShadowDecl>;\n\n  UsingShadowDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  UsingShadowDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  UsingShadowDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\nprotected:\n  UsingShadowDecl(Kind K, ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                  DeclarationName Name, BaseUsingDecl *Introducer,\n                  NamedDecl *Target);\n  UsingShadowDecl(Kind K, ASTContext &C, EmptyShell);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static UsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation Loc, DeclarationName Name,\n                                 BaseUsingDecl *Introducer, NamedDecl *Target) {\n    return new (C, DC)\n        UsingShadowDecl(UsingShadow, C, DC, Loc, Name, Introducer, Target);\n  }\n\n  static UsingShadowDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  UsingShadowDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UsingShadowDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Gets the underlying declaration which has been brought into the\n  /// local scope.\n  NamedDecl *getTargetDecl() const { return Underlying; }\n\n  /// Sets the underlying declaration which has been brought into the\n  /// local scope.\n  void setTargetDecl(NamedDecl *ND) {\n    assert(ND && \"Target decl is null!\");\n    Underlying = ND;\n    // A UsingShadowDecl is never a friend or local extern declaration, even\n    // if it is a shadow declaration for one.\n    IdentifierNamespace =\n        ND->getIdentifierNamespace() &\n        ~(IDNS_OrdinaryFriend | IDNS_TagFriend | IDNS_LocalExtern);\n  }\n\n  /// Gets the (written or instantiated) using declaration that introduced this\n  /// declaration.\n  BaseUsingDecl *getIntroducer() const;\n\n  /// The next using shadow declaration contained in the shadow decl\n  /// chain of the using declaration which introduced this decl.\n  UsingShadowDecl *getNextUsingShadowDecl() const {\n    return dyn_cast_or_null<UsingShadowDecl>(UsingOrNextShadow);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::UsingShadow || K == Decl::ConstructorUsingShadow;\n  }\n};\n\n/// Represents a C++ declaration that introduces decls from somewhere else. It\n/// provides a set of the shadow decls so introduced.\n\nclass BaseUsingDecl : public NamedDecl {\n  /// The first shadow declaration of the shadow decl chain associated\n  /// with this using declaration.\n  ///\n  /// The bool member of the pair is a bool flag a derived type may use\n  /// (UsingDecl makes use of it).\n  llvm::PointerIntPair<UsingShadowDecl *, 1, bool> FirstUsingShadow;\n\nprotected:\n  BaseUsingDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName N)\n      : NamedDecl(DK, DC, L, N), FirstUsingShadow(nullptr, false) {}\n\nprivate:\n  void anchor() override;\n\nprotected:\n  /// A bool flag for use by a derived type\n  bool getShadowFlag() const { return FirstUsingShadow.getInt(); }\n\n  /// A bool flag a derived type may set\n  void setShadowFlag(bool V) { FirstUsingShadow.setInt(V); }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Iterates through the using shadow declarations associated with\n  /// this using declaration.\n  class shadow_iterator {\n    /// The current using shadow declaration.\n    UsingShadowDecl *Current = nullptr;\n\n  public:\n    using value_type = UsingShadowDecl *;\n    using reference = UsingShadowDecl *;\n    using pointer = UsingShadowDecl *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    shadow_iterator() = default;\n    explicit shadow_iterator(UsingShadowDecl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    shadow_iterator &operator++() {\n      Current = Current->getNextUsingShadowDecl();\n      return *this;\n    }\n\n    shadow_iterator operator++(int) {\n      shadow_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(shadow_iterator x, shadow_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(shadow_iterator x, shadow_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using shadow_range = llvm::iterator_range<shadow_iterator>;\n\n  shadow_range shadows() const {\n    return shadow_range(shadow_begin(), shadow_end());\n  }\n\n  shadow_iterator shadow_begin() const {\n    return shadow_iterator(FirstUsingShadow.getPointer());\n  }\n\n  shadow_iterator shadow_end() const { return shadow_iterator(); }\n\n  /// Return the number of shadowed declarations associated with this\n  /// using declaration.\n  unsigned shadow_size() const {\n    return std::distance(shadow_begin(), shadow_end());\n  }\n\n  void addShadowDecl(UsingShadowDecl *S);\n  void removeShadowDecl(UsingShadowDecl *S);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using || K == UsingEnum; }\n};\n\n/// Represents a C++ using-declaration.\n///\n/// For example:\n/// \\code\n///    using someNameSpace::someIdentifier;\n/// \\endcode\nclass UsingDecl : public BaseUsingDecl, public Mergeable<UsingDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UsingDecl(DeclContext *DC, SourceLocation UL,\n            NestedNameSpecifierLoc QualifierLoc,\n            const DeclarationNameInfo &NameInfo, bool HasTypenameKeyword)\n      : BaseUsingDecl(Using, DC, NameInfo.getLoc(), NameInfo.getName()),\n        UsingLocation(UL), QualifierLoc(QualifierLoc),\n        DNLoc(NameInfo.getInfo()) {\n    setShadowFlag(HasTypenameKeyword);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Return the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Return true if the using declaration has 'typename'.\n  bool hasTypename() const { return getShadowFlag(); }\n\n  /// Sets whether the using declaration has 'typename'.\n  void setTypename(bool TN) { setShadowFlag(TN); }\n\n  static UsingDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation UsingL,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           bool HasTypenameKeyword);\n\n  static UsingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingDecl *getCanonicalDecl() override {\n    return cast<UsingDecl>(getFirstDecl());\n  }\n  const UsingDecl *getCanonicalDecl() const {\n    return cast<UsingDecl>(getFirstDecl());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using; }\n};\n\n/// Represents a shadow constructor declaration introduced into a\n/// class by a C++11 using-declaration that names a constructor.\n///\n/// For example:\n/// \\code\n/// struct Base { Base(int); };\n/// struct Derived {\n///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl\n/// };\n/// \\endcode\nclass ConstructorUsingShadowDecl final : public UsingShadowDecl {\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// in the named direct base class from which the declaration was inherited.\n  ConstructorUsingShadowDecl *NominatedBaseClassShadowDecl = nullptr;\n\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// that will be used to construct the unique direct or virtual base class\n  /// that receives the constructor arguments.\n  ConstructorUsingShadowDecl *ConstructedBaseClassShadowDecl = nullptr;\n\n  /// \\c true if the constructor ultimately named by this using shadow\n  /// declaration is within a virtual base class subobject of the class that\n  /// contains this declaration.\n  unsigned IsVirtual : 1;\n\n  ConstructorUsingShadowDecl(ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                             UsingDecl *Using, NamedDecl *Target,\n                             bool TargetInVirtualBase)\n      : UsingShadowDecl(ConstructorUsingShadow, C, DC, Loc,\n                        Using->getDeclName(), Using,\n                        Target->getUnderlyingDecl()),\n        NominatedBaseClassShadowDecl(\n            dyn_cast<ConstructorUsingShadowDecl>(Target)),\n        ConstructedBaseClassShadowDecl(NominatedBaseClassShadowDecl),\n        IsVirtual(TargetInVirtualBase) {\n    // If we found a constructor that chains to a constructor for a virtual\n    // base, we should directly call that virtual base constructor instead.\n    // FIXME: This logic belongs in Sema.\n    if (NominatedBaseClassShadowDecl &&\n        NominatedBaseClassShadowDecl->constructsVirtualBase()) {\n      ConstructedBaseClassShadowDecl =\n          NominatedBaseClassShadowDecl->ConstructedBaseClassShadowDecl;\n      IsVirtual = true;\n    }\n  }\n\n  ConstructorUsingShadowDecl(ASTContext &C, EmptyShell Empty)\n      : UsingShadowDecl(ConstructorUsingShadow, C, Empty), IsVirtual(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ConstructorUsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                            SourceLocation Loc,\n                                            UsingDecl *Using, NamedDecl *Target,\n                                            bool IsVirtual);\n  static ConstructorUsingShadowDecl *CreateDeserialized(ASTContext &C,\n                                                        unsigned ID);\n\n  /// Override the UsingShadowDecl's getIntroducer, returning the UsingDecl that\n  /// introduced this.\n  UsingDecl *getIntroducer() const {\n    return cast<UsingDecl>(UsingShadowDecl::getIntroducer());\n  }\n\n  /// Returns the parent of this using shadow declaration, which\n  /// is the class in which this is declared.\n  //@{\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  CXXRecordDecl *getParent() {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  //@}\n\n  /// Get the inheriting constructor declaration for the direct base\n  /// class from which this using shadow declaration was inherited, if there is\n  /// one. This can be different for each redeclaration of the same shadow decl.\n  ConstructorUsingShadowDecl *getNominatedBaseClassShadowDecl() const {\n    return NominatedBaseClassShadowDecl;\n  }\n\n  /// Get the inheriting constructor declaration for the base class\n  /// for which we don't have an explicit initializer, if there is one.\n  ConstructorUsingShadowDecl *getConstructedBaseClassShadowDecl() const {\n    return ConstructedBaseClassShadowDecl;\n  }\n\n  /// Get the base class that was named in the using declaration. This\n  /// can be different for each redeclaration of this same shadow decl.\n  CXXRecordDecl *getNominatedBaseClass() const;\n\n  /// Get the base class whose constructor or constructor shadow\n  /// declaration is passed the constructor arguments.\n  CXXRecordDecl *getConstructedBaseClass() const {\n    return cast<CXXRecordDecl>((ConstructedBaseClassShadowDecl\n                                    ? ConstructedBaseClassShadowDecl\n                                    : getTargetDecl())\n                                   ->getDeclContext());\n  }\n\n  /// Returns \\c true if the constructed base class is a virtual base\n  /// class subobject of this declaration's class.\n  bool constructsVirtualBase() const {\n    return IsVirtual;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ConstructorUsingShadow; }\n};\n\n/// Represents a C++ using-enum-declaration.\n///\n/// For example:\n/// \\code\n///    using enum SomeEnumTag ;\n/// \\endcode\n\nclass UsingEnumDecl : public BaseUsingDecl, public Mergeable<UsingEnumDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n  /// The source location of the 'enum' keyword.\n  SourceLocation EnumLocation;\n  /// 'qual::SomeEnum' as an EnumType, possibly with Elaborated/Typedef sugar.\n  TypeSourceInfo *EnumType;\n\n  UsingEnumDecl(DeclContext *DC, DeclarationName DN, SourceLocation UL,\n                SourceLocation EL, SourceLocation NL, TypeSourceInfo *EnumType)\n      : BaseUsingDecl(UsingEnum, DC, NL, DN), UsingLocation(UL), EnumLocation(EL),\n        EnumType(EnumType){}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// The source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// The source location of the 'enum' keyword.\n  SourceLocation getEnumLoc() const { return EnumLocation; }\n  void setEnumLoc(SourceLocation L) { EnumLocation = L; }\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (auto ETL = EnumType->getTypeLoc().getAs<ElaboratedTypeLoc>())\n      return ETL.getQualifierLoc();\n    return NestedNameSpecifierLoc();\n  }\n  // Returns the \"qualifier::Name\" part as a TypeLoc.\n  TypeLoc getEnumTypeLoc() const {\n    return EnumType->getTypeLoc();\n  }\n  TypeSourceInfo *getEnumType() const {\n    return EnumType;\n  }\n  void setEnumType(TypeSourceInfo *TSI) { EnumType = TSI; }\n\npublic:\n  EnumDecl *getEnumDecl() const { return cast<EnumDecl>(EnumType->getType()->getAsTagDecl()); }\n\n  static UsingEnumDecl *Create(ASTContext &C, DeclContext *DC,\n                               SourceLocation UsingL, SourceLocation EnumL,\n                               SourceLocation NameL, TypeSourceInfo *EnumType);\n\n  static UsingEnumDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingEnumDecl *getCanonicalDecl() override {\n    return cast<UsingEnumDecl>(getFirstDecl());\n  }\n  const UsingEnumDecl *getCanonicalDecl() const {\n    return cast<UsingEnumDecl>(getFirstDecl());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingEnum; }\n};\n\n/// Represents a pack of using declarations that a single\n/// using-declarator pack-expanded into.\n///\n/// \\code\n/// template<typename ...T> struct X : T... {\n///   using T::operator()...;\n///   using T::operator T...;\n/// };\n/// \\endcode\n///\n/// In the second case above, the UsingPackDecl will have the name\n/// 'operator T' (which contains an unexpanded pack), but the individual\n/// UsingDecls and UsingShadowDecls will have more reasonable names.\nclass UsingPackDecl final\n    : public NamedDecl, public Mergeable<UsingPackDecl>,\n      private llvm::TrailingObjects<UsingPackDecl, NamedDecl *> {\n  /// The UnresolvedUsingValueDecl or UnresolvedUsingTypenameDecl from\n  /// which this waas instantiated.\n  NamedDecl *InstantiatedFrom;\n\n  /// The number of using-declarations created by this pack expansion.\n  unsigned NumExpansions;\n\n  UsingPackDecl(DeclContext *DC, NamedDecl *InstantiatedFrom,\n                ArrayRef<NamedDecl *> UsingDecls)\n      : NamedDecl(UsingPack, DC,\n                  InstantiatedFrom ? InstantiatedFrom->getLocation()\n                                   : SourceLocation(),\n                  InstantiatedFrom ? InstantiatedFrom->getDeclName()\n                                   : DeclarationName()),\n        InstantiatedFrom(InstantiatedFrom), NumExpansions(UsingDecls.size()) {\n    std::uninitialized_copy(UsingDecls.begin(), UsingDecls.end(),\n                            getTrailingObjects<NamedDecl *>());\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  /// Get the using declaration from which this was instantiated. This will\n  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl\n  /// that is a pack expansion.\n  NamedDecl *getInstantiatedFromUsingDecl() const { return InstantiatedFrom; }\n\n  /// Get the set of using declarations that this pack expanded into. Note that\n  /// some of these may still be unresolved.\n  ArrayRef<NamedDecl *> expansions() const {\n    return llvm::ArrayRef(getTrailingObjects<NamedDecl *>(), NumExpansions);\n  }\n\n  static UsingPackDecl *Create(ASTContext &C, DeclContext *DC,\n                               NamedDecl *InstantiatedFrom,\n                               ArrayRef<NamedDecl *> UsingDecls);\n\n  static UsingPackDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                           unsigned NumExpansions);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return InstantiatedFrom->getSourceRange();\n  }\n\n  UsingPackDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingPackDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingPack; }\n};\n\n/// Represents a dependent using declaration which was not marked with\n/// \\c typename.\n///\n/// Unlike non-dependent using declarations, these *only* bring through\n/// non-types; otherwise they would break two-phase lookup.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using Base<T>::foo;\n/// };\n/// \\endcode\nclass UnresolvedUsingValueDecl : public ValueDecl,\n                                 public Mergeable<UnresolvedUsingValueDecl> {\n  /// The source location of the 'using' keyword\n  SourceLocation UsingLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UnresolvedUsingValueDecl(DeclContext *DC, QualType Ty,\n                           SourceLocation UsingLoc,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           SourceLocation EllipsisLoc)\n      : ValueDecl(UnresolvedUsingValue, DC,\n                  NameInfo.getLoc(), NameInfo.getName(), Ty),\n        UsingLocation(UsingLoc), EllipsisLoc(EllipsisLoc),\n        QualifierLoc(QualifierLoc), DNLoc(NameInfo.getInfo()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingValueDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           NestedNameSpecifierLoc QualifierLoc,\n           const DeclarationNameInfo &NameInfo, SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingValueDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingValueDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingValueDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingValue; }\n};\n\n/// Represents a dependent using declaration which was marked with\n/// \\c typename.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using typename Base<T>::foo;\n/// };\n/// \\endcode\n///\n/// The type associated with an unresolved using typename decl is\n/// currently always a typename type.\nclass UnresolvedUsingTypenameDecl\n    : public TypeDecl,\n      public Mergeable<UnresolvedUsingTypenameDecl> {\n  friend class ASTDeclReader;\n\n  /// The source location of the 'typename' keyword\n  SourceLocation TypenameLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  UnresolvedUsingTypenameDecl(DeclContext *DC, SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TargetNameLoc,\n                              IdentifierInfo *TargetName,\n                              SourceLocation EllipsisLoc)\n    : TypeDecl(UnresolvedUsingTypename, DC, TargetNameLoc, TargetName,\n               UsingLoc),\n      TypenameLocation(TypenameLoc), EllipsisLoc(EllipsisLoc),\n      QualifierLoc(QualifierLoc) {}\n\n  void anchor() override;\n\npublic:\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return getBeginLoc(); }\n\n  /// Returns the source location of the 'typename' keyword.\n  SourceLocation getTypenameLoc() const { return TypenameLocation; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation());\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingTypenameDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           SourceLocation TypenameLoc, NestedNameSpecifierLoc QualifierLoc,\n           SourceLocation TargetNameLoc, DeclarationName TargetName,\n           SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingTypenameDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingTypenameDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingTypenameDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingTypename; }\n};\n\n/// This node is generated when a using-declaration that was annotated with\n/// __attribute__((using_if_exists)) failed to resolve to a known declaration.\n/// In that case, Sema builds a UsingShadowDecl whose target is an instance of\n/// this declaration, adding it to the current scope. Referring to this\n/// declaration in any way is an error.\nclass UnresolvedUsingIfExistsDecl final : public NamedDecl {\n  UnresolvedUsingIfExistsDecl(DeclContext *DC, SourceLocation Loc,\n                              DeclarationName Name);\n\n  void anchor() override;\n\npublic:\n  static UnresolvedUsingIfExistsDecl *Create(ASTContext &Ctx, DeclContext *DC,\n                                             SourceLocation Loc,\n                                             DeclarationName Name);\n  static UnresolvedUsingIfExistsDecl *CreateDeserialized(ASTContext &Ctx,\n                                                         unsigned ID);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::UnresolvedUsingIfExists; }\n};\n\n/// Represents a C++11 static_assert declaration.\nclass StaticAssertDecl : public Decl {\n  llvm::PointerIntPair<Expr *, 1, bool> AssertExprAndFailed;\n  Expr *Message;\n  SourceLocation RParenLoc;\n\n  StaticAssertDecl(DeclContext *DC, SourceLocation StaticAssertLoc,\n                   Expr *AssertExpr, Expr *Message, SourceLocation RParenLoc,\n                   bool Failed)\n      : Decl(StaticAssert, DC, StaticAssertLoc),\n        AssertExprAndFailed(AssertExpr, Failed), Message(Message),\n        RParenLoc(RParenLoc) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n\n  static StaticAssertDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation StaticAssertLoc,\n                                  Expr *AssertExpr, Expr *Message,\n                                  SourceLocation RParenLoc, bool Failed);\n  static StaticAssertDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getAssertExpr() { return AssertExprAndFailed.getPointer(); }\n  const Expr *getAssertExpr() const { return AssertExprAndFailed.getPointer(); }\n\n  Expr *getMessage() { return Message; }\n  const Expr *getMessage() const { return Message; }\n\n  bool isFailed() const { return AssertExprAndFailed.getInt(); }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getRParenLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == StaticAssert; }\n};\n\n/// A binding in a decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// a, b, and c are BindingDecls, whose bindings are the expressions\n/// x[0], x[1], and x[2] respectively, where x is the implicit\n/// DecompositionDecl of type 'int (&)[3]'.\nclass BindingDecl : public ValueDecl {\n  /// The declaration that this binding binds to part of.\n  ValueDecl *Decomp;\n  /// The binding represented by this declaration. References to this\n  /// declaration are effectively equivalent to this expression (except\n  /// that it is only evaluated once at the point of declaration of the\n  /// binding).\n  Expr *Binding = nullptr;\n\n  BindingDecl(DeclContext *DC, SourceLocation IdLoc, IdentifierInfo *Id)\n      : ValueDecl(Decl::Binding, DC, IdLoc, Id, QualType()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static BindingDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation IdLoc, IdentifierInfo *Id);\n  static BindingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Get the expression to which this declaration is bound. This may be null\n  /// in two different cases: while parsing the initializer for the\n  /// decomposition declaration, and when the initializer is type-dependent.\n  Expr *getBinding() const { return Binding; }\n\n  /// Get the decomposition declaration that this binding represents a\n  /// decomposition of.\n  ValueDecl *getDecomposedDecl() const { return Decomp; }\n\n  /// Get the variable (if any) that holds the value of evaluating the binding.\n  /// Only present for user-defined bindings for tuple-like types.\n  VarDecl *getHoldingVar() const;\n\n  /// Set the binding for this BindingDecl, along with its declared type (which\n  /// should be a possibly-cv-qualified form of the type of the binding, or a\n  /// reference to such a type).\n  void setBinding(QualType DeclaredType, Expr *Binding) {\n    setType(DeclaredType);\n    this->Binding = Binding;\n  }\n\n  /// Set the decomposed variable for this BindingDecl.\n  void setDecomposedDecl(ValueDecl *Decomposed) { Decomp = Decomposed; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Binding; }\n};\n\n/// A decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// the second line declares a DecompositionDecl of type 'int (&)[3]', and\n/// three BindingDecls (named a, b, and c). An instance of this class is always\n/// unnamed, but behaves in almost all other respects like a VarDecl.\nclass DecompositionDecl final\n    : public VarDecl,\n      private llvm::TrailingObjects<DecompositionDecl, BindingDecl *> {\n  /// The number of BindingDecl*s following this object.\n  unsigned NumBindings;\n\n  DecompositionDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                    SourceLocation LSquareLoc, QualType T,\n                    TypeSourceInfo *TInfo, StorageClass SC,\n                    ArrayRef<BindingDecl *> Bindings)\n      : VarDecl(Decomposition, C, DC, StartLoc, LSquareLoc, nullptr, T, TInfo,\n                SC),\n        NumBindings(Bindings.size()) {\n    std::uninitialized_copy(Bindings.begin(), Bindings.end(),\n                            getTrailingObjects<BindingDecl *>());\n    for (auto *B : Bindings)\n      B->setDecomposedDecl(this);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  static DecompositionDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation StartLoc,\n                                   SourceLocation LSquareLoc,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   StorageClass S,\n                                   ArrayRef<BindingDecl *> Bindings);\n  static DecompositionDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned NumBindings);\n\n  ArrayRef<BindingDecl *> bindings() const {\n    return llvm::ArrayRef(getTrailingObjects<BindingDecl *>(), NumBindings);\n  }\n\n  void printName(raw_ostream &OS, const PrintingPolicy &Policy) const override;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decomposition; }\n};\n\n/// An instance of this class represents the declaration of a property\n/// member.  This is a Microsoft extension to C++, first introduced in\n/// Visual Studio .NET 2003 as a parallel to similar features in C#\n/// and Managed C++.\n///\n/// A property must always be a non-static class member.\n///\n/// A property member superficially resembles a non-static data\n/// member, except preceded by a property attribute:\n///   __declspec(property(get=GetX, put=PutX)) int x;\n/// Either (but not both) of the 'get' and 'put' names may be omitted.\n///\n/// A reference to a property is always an lvalue.  If the lvalue\n/// undergoes lvalue-to-rvalue conversion, then a getter name is\n/// required, and that member is called with no arguments.\n/// If the lvalue is assigned into, then a setter name is required,\n/// and that member is called with one argument, the value assigned.\n/// Both operations are potentially overloaded.  Compound assignments\n/// are permitted, as are the increment and decrement operators.\n///\n/// The getter and putter methods are permitted to be overloaded,\n/// although their return and parameter types are subject to certain\n/// restrictions according to the type of the property.\n///\n/// A property declared using an incomplete array type may\n/// additionally be subscripted, adding extra parameters to the getter\n/// and putter methods.\nclass MSPropertyDecl : public DeclaratorDecl {\n  IdentifierInfo *GetterId, *SetterId;\n\n  MSPropertyDecl(DeclContext *DC, SourceLocation L, DeclarationName N,\n                 QualType T, TypeSourceInfo *TInfo, SourceLocation StartL,\n                 IdentifierInfo *Getter, IdentifierInfo *Setter)\n      : DeclaratorDecl(MSProperty, DC, L, N, T, TInfo, StartL),\n        GetterId(Getter), SetterId(Setter) {}\n\n  void anchor() override;\npublic:\n  friend class ASTDeclReader;\n\n  static MSPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                SourceLocation L, DeclarationName N, QualType T,\n                                TypeSourceInfo *TInfo, SourceLocation StartL,\n                                IdentifierInfo *Getter, IdentifierInfo *Setter);\n  static MSPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return D->getKind() == MSProperty; }\n\n  bool hasGetter() const { return GetterId != nullptr; }\n  IdentifierInfo* getGetterId() const { return GetterId; }\n  bool hasSetter() const { return SetterId != nullptr; }\n  IdentifierInfo* getSetterId() const { return SetterId; }\n};\n\n/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary\n/// dependencies on DeclCXX.h.\nstruct MSGuidDeclParts {\n  /// {01234567-...\n  uint32_t Part1;\n  /// ...-89ab-...\n  uint16_t Part2;\n  /// ...-cdef-...\n  uint16_t Part3;\n  /// ...-0123-456789abcdef}\n  uint8_t Part4And5[8];\n\n  uint64_t getPart4And5AsUint64() const {\n    uint64_t Val;\n    memcpy(&Val, &Part4And5, sizeof(Part4And5));\n    return Val;\n  }\n};\n\n/// A global _GUID constant. These are implicitly created by UuidAttrs.\n///\n///   struct _declspec(uuid(\"01234567-89ab-cdef-0123-456789abcdef\")) X{};\n///\n/// X is a CXXRecordDecl that contains a UuidAttr that references the (unique)\n/// MSGuidDecl for the specified UUID.\nclass MSGuidDecl : public ValueDecl,\n                   public Mergeable<MSGuidDecl>,\n                   public llvm::FoldingSetNode {\npublic:\n  using Parts = MSGuidDeclParts;\n\nprivate:\n  /// The decomposed form of the UUID.\n  Parts PartVal;\n\n  /// The resolved value of the UUID as an APValue. Computed on demand and\n  /// cached.\n  mutable APValue APVal;\n\n  void anchor() override;\n\n  MSGuidDecl(DeclContext *DC, QualType T, Parts P);\n\n  static MSGuidDecl *Create(const ASTContext &C, QualType T, Parts P);\n  static MSGuidDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Only ASTContext::getMSGuidDecl and deserialization create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this UUID in a human-readable format.\n  void printName(llvm::raw_ostream &OS,\n                 const PrintingPolicy &Policy) const override;\n\n  /// Get the decomposed parts of this declaration.\n  Parts getParts() const { return PartVal; }\n\n  /// Get the value of this MSGuidDecl as an APValue. This may fail and return\n  /// an absent APValue if the type of the declaration is not of the expected\n  /// shape.\n  APValue &getAsAPValue() const;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Parts P) {\n    ID.AddInteger(P.Part1);\n    ID.AddInteger(P.Part2);\n    ID.AddInteger(P.Part3);\n    ID.AddInteger(P.getPart4And5AsUint64());\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, PartVal); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::MSGuid; }\n};\n\n/// An artificial decl, representing a global anonymous constant value which is\n/// uniquified by value within a translation unit.\n///\n/// These is currently only used to back the LValue returned by\n/// __builtin_source_location, but could potentially be used for other similar\n/// situations in the future.\nclass UnnamedGlobalConstantDecl : public ValueDecl,\n                                  public Mergeable<UnnamedGlobalConstantDecl>,\n                                  public llvm::FoldingSetNode {\n\n  // The constant value of this global.\n  APValue Value;\n\n  void anchor() override;\n\n  UnnamedGlobalConstantDecl(const ASTContext &C, DeclContext *DC, QualType T,\n                            const APValue &Val);\n\n  static UnnamedGlobalConstantDecl *Create(const ASTContext &C, QualType T,\n                                           const APValue &APVal);\n  static UnnamedGlobalConstantDecl *CreateDeserialized(ASTContext &C,\n                                                       unsigned ID);\n\n  // Only ASTContext::getUnnamedGlobalConstantDecl and deserialization create\n  // these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this in a human-readable format.\n  void printName(llvm::raw_ostream &OS,\n                 const PrintingPolicy &Policy) const override;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Ty,\n                      const APValue &APVal) {\n    Ty.Profile(ID);\n    APVal.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::UnnamedGlobalConstant; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending an AccessSpecifier\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      AccessSpecifier AS);\n\n}",
  "id": "BLOCK-CPP-08705",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 2253,
  "validation_status": "validated"
}