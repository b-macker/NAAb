{
  "code": "{\n\n// Like call_once, but uses KERNEL_ONLY scheduling. Intended to be used to\n// initialize entities used by the scheduler implementation.\ntemplate <typename Callable, typename... Args>\nvoid LowLevelCallOnce(absl::Nonnull<absl::once_flag*> flag, Callable&& fn,\n                      Args&&... args);\n\n// Disables scheduling while on stack when scheduling mode is non-cooperative.\n// No effect for cooperative scheduling modes.\nclass SchedulingHelper {\n public:\n  explicit SchedulingHelper(base_internal::SchedulingMode mode) : mode_(mode) {\n    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {\n      guard_result_ = base_internal::SchedulingGuard::DisableRescheduling();\n    }\n  }\n\n  ~SchedulingHelper() {\n    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {\n      base_internal::SchedulingGuard::EnableRescheduling(guard_result_);\n    }\n  }\n\n private:\n  base_internal::SchedulingMode mode_;\n  bool guard_result_ = false;\n};\n\n// Bit patterns for call_once state machine values.  Internal implementation\n// detail, not for use by clients.\n//\n// The bit patterns are arbitrarily chosen from unlikely values, to aid in\n// debugging.  However, kOnceInit must be 0, so that a zero-initialized\n// once_flag will be valid for immediate use.\nenum {\n  kOnceInit = 0,\n  kOnceRunning = 0x65C2937B,\n  kOnceWaiter = 0x05A308D2,\n  // A very small constant is chosen for kOnceDone so that it fit in a single\n  // compare with immediate instruction for most common ISAs.  This is verified\n  // for x86, POWER and ARM.\n  kOnceDone = 221,    // Random Number\n};\n\ntemplate <typename Callable, typename... Args>\nABSL_ATTRIBUTE_NOINLINE void CallOnceImpl(\n    absl::Nonnull<std::atomic<uint32_t>*> control,\n    base_internal::SchedulingMode scheduling_mode, Callable&& fn,\n    Args&&... args) {\n#ifndef NDEBUG\n  {\n    uint32_t old_control = control->load(std::memory_order_relaxed);\n    if (old_control != kOnceInit &&\n        old_control != kOnceRunning &&\n        old_control != kOnceWaiter &&\n        old_control != kOnceDone) {\n      ABSL_RAW_LOG(FATAL, \"Unexpected value for control word: 0x%lx\",\n                   static_cast<unsigned long>(old_control));  // NOLINT\n    }\n  }\n#endif  // NDEBUG\n  static const base_internal::SpinLockWaitTransition trans[] = {\n      {kOnceInit, kOnceRunning, true},\n      {kOnceRunning, kOnceWaiter, false},\n      {kOnceDone, kOnceDone, true}};\n\n  // Must do this before potentially modifying control word's state.\n  base_internal::SchedulingHelper maybe_disable_scheduling(scheduling_mode);\n  // Short circuit the simplest case to avoid procedure call overhead.\n  // The base_internal::SpinLockWait() call returns either kOnceInit or\n  // kOnceDone. If it returns kOnceDone, it must have loaded the control word\n  // with std::memory_order_acquire and seen a value of kOnceDone.\n  uint32_t old_control = kOnceInit;\n  if (control->compare_exchange_strong(old_control, kOnceRunning,\n                                       std::memory_order_relaxed) ||\n      base_internal::SpinLockWait(control, ABSL_ARRAYSIZE(trans), trans,\n                                  scheduling_mode) == kOnceInit) {\n    base_internal::invoke(std::forward<Callable>(fn),\n                          std::forward<Args>(args)...);\n    old_control =\n        control->exchange(base_internal::kOnceDone, std::memory_order_release);\n    if (old_control == base_internal::kOnceWaiter) {\n      base_internal::SpinLockWake(control, true);\n    }\n  }  // else *control is already kOnceDone\n}\n\ninline absl::Nonnull<std::atomic<uint32_t>*> ControlWord(\n    absl::Nonnull<once_flag*> flag) {\n  return &flag->control_;\n}\n\ntemplate <typename Callable, typename... Args>\nvoid LowLevelCallOnce(absl::Nonnull<absl::once_flag*> flag, Callable&& fn,\n                      Args&&... args) {\n  std::atomic<uint32_t>* once = base_internal::ControlWord(flag);\n  uint32_t s = once->load(std::memory_order_acquire);\n  if (ABSL_PREDICT_FALSE(s != base_internal::kOnceDone)) {\n    base_internal::CallOnceImpl(once, base_internal::SCHEDULE_KERNEL_ONLY,\n                                std::forward<Callable>(fn),\n                                std::forward<Args>(args)...);\n  }\n}\n\n}",
  "id": "BLOCK-CPP-03416",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/call_once.h",
  "source_line": 104,
  "validation_status": "validated"
}