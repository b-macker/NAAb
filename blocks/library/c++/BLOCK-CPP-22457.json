{
  "code": "{\nprivate:\n  /// Frames modifying the state as defined in \\c wasModifiedBeforeCallExit.\n  /// This visitor generates a note only if a function does *not* change the\n  /// state that way. This information is not immediately available\n  /// by looking at the node associated with the exit from the function\n  /// (usually the return statement). To avoid recomputing the same information\n  /// many times (going up the path for each node and checking whether the\n  /// region was written into) we instead lazily compute the stack frames\n  /// along the path.\n  // TODO: Can't we just use a map instead? This is likely not as cheap as it\n  // makes the code difficult to read.\n  llvm::SmallPtrSet<const StackFrameContext *, 32> FramesModifying;\n  llvm::SmallPtrSet<const StackFrameContext *, 32> FramesModifyingCalculated;\n\n  /// Check and lazily calculate whether the state is modified in the stack\n  /// frame to which \\p CallExitBeginN belongs.\n  /// The calculation is cached in FramesModifying.\n  bool isModifiedInFrame(const ExplodedNode *CallExitBeginN);\n\n  void markFrameAsModifying(const StackFrameContext *SCtx);\n\n  /// Write to \\c FramesModifying all stack frames along the path in the current\n  /// stack frame which modifies the state.\n  void findModifyingFrames(const ExplodedNode *const CallExitBeginN);\n\nprotected:\n  bugreporter::TrackingKind TKind;\n\n  /// \\return Whether the state was modified from the current node, \\p CurrN, to\n  /// the end of the stack frame, at \\p CallExitBeginN. \\p CurrN and\n  /// \\p CallExitBeginN are always in the same stack frame.\n  /// Clients should override this callback when a state change is important\n  /// not only on the entire function call, but inside of it as well.\n  /// Example: we may want to leave a note about the lack of locking/unlocking\n  /// on a particular mutex, but not if inside the function its state was\n  /// changed, but also restored. wasModifiedInFunction() wouldn't know of this\n  /// change.\n  virtual bool wasModifiedBeforeCallExit(const ExplodedNode *CurrN,\n                                         const ExplodedNode *CallExitBeginN) {\n    return false;\n  }\n\n  /// \\return Whether the state was modified in the inlined function call in\n  /// between \\p CallEnterN and \\p CallExitEndN. Mind that the stack frame\n  /// retrieved from a CallEnterN and CallExitEndN is the *caller's* stack\n  /// frame! The inlined function's stack should be retrieved from either the\n  /// immediate successor to \\p CallEnterN or immediate predecessor to\n  /// \\p CallExitEndN.\n  /// Clients should override this function if a state changes local to the\n  /// inlined function are not interesting, only the change occuring as a\n  /// result of it.\n  /// Example: we want to leave a not about a leaked resource object not being\n  /// deallocated / its ownership changed inside a function, and we don't care\n  /// if it was assigned to a local variable (its change in ownership is\n  /// inconsequential).\n  virtual bool wasModifiedInFunction(const ExplodedNode *CallEnterN,\n                                     const ExplodedNode *CallExitEndN) {\n    return false;\n  }\n\n  /// Consume the information on the non-modifying stack frame in order to\n  /// either emit a note or not. May suppress the report entirely.\n  /// \\return Diagnostics piece for the unmodified state in the current\n  /// function, if it decides to emit one. A good description might start with\n  /// \"Returning without...\".\n  virtual PathDiagnosticPieceRef\n  maybeEmitNoteForObjCSelf(PathSensitiveBugReport &R,\n                           const ObjCMethodCall &Call,\n                           const ExplodedNode *N) = 0;\n\n  /// Consume the information on the non-modifying stack frame in order to\n  /// either emit a note or not. May suppress the report entirely.\n  /// \\return Diagnostics piece for the unmodified state in the current\n  /// function, if it decides to emit one. A good description might start with\n  /// \"Returning without...\".\n  virtual PathDiagnosticPieceRef\n  maybeEmitNoteForCXXThis(PathSensitiveBugReport &R,\n                          const CXXConstructorCall &Call,\n                          const ExplodedNode *N) = 0;\n\n  /// Consume the information on the non-modifying stack frame in order to\n  /// either emit a note or not. May suppress the report entirely.\n  /// \\return Diagnostics piece for the unmodified state in the current\n  /// function, if it decides to emit one. A good description might start with\n  /// \"Returning without...\".\n  virtual PathDiagnosticPieceRef\n  maybeEmitNoteForParameters(PathSensitiveBugReport &R, const CallEvent &Call,\n                             const ExplodedNode *N) = 0;\n\npublic:\n  NoStateChangeFuncVisitor(bugreporter::TrackingKind TKind) : TKind(TKind) {}\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BR,\n                                   PathSensitiveBugReport &R) final;\n}",
  "id": "BLOCK-CPP-22457",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h",
  "source_line": 645,
  "validation_status": "validated"
}