{
  "code": "{\n\n// Creates a Duration with a given representation.\n// REQUIRES: hi,lo is a valid representation of a Duration as specified\n// in time/duration.cc.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration MakeDuration(int64_t hi,\n                                                              uint32_t lo = 0) {\n  return Duration(hi, lo);\n}\n\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration MakeDuration(int64_t hi,\n                                                              int64_t lo) {\n  return MakeDuration(hi, static_cast<uint32_t>(lo));\n}\n\n// Make a Duration value from a floating-point number, as long as that number\n// is in the range [ 0 .. numeric_limits<int64_t>::max ), that is, as long as\n// it's positive and can be converted to int64_t without risk of UB.\nABSL_ATTRIBUTE_CONST_FUNCTION inline Duration MakePosDoubleDuration(double n) {\n  const int64_t int_secs = static_cast<int64_t>(n);\n  const uint32_t ticks = static_cast<uint32_t>(\n      std::round((n - static_cast<double>(int_secs)) * kTicksPerSecond));\n  return ticks < kTicksPerSecond\n             ? MakeDuration(int_secs, ticks)\n             : MakeDuration(int_secs + 1, ticks - kTicksPerSecond);\n}\n\n// Creates a normalized Duration from an almost-normalized (sec,ticks)\n// pair. sec may be positive or negative.  ticks must be in the range\n// -kTicksPerSecond < *ticks < kTicksPerSecond.  If ticks is negative it\n// will be normalized to a positive value in the resulting Duration.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration MakeNormalizedDuration(\n    int64_t sec, int64_t ticks) {\n  return (ticks < 0) ? MakeDuration(sec - 1, ticks + kTicksPerSecond)\n                     : MakeDuration(sec, ticks);\n}\n\n// Provide access to the Duration representation.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr int64_t GetRepHi(Duration d) {\n  return d.rep_hi_.Get();\n}\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr uint32_t GetRepLo(Duration d) {\n  return d.rep_lo_;\n}\n\n// Returns true iff d is positive or negative infinity.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr bool IsInfiniteDuration(Duration d) {\n  return GetRepLo(d) == ~uint32_t{0};\n}\n\n// Returns an infinite Duration with the opposite sign.\n// REQUIRES: IsInfiniteDuration(d)\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration OppositeInfinity(Duration d) {\n  return GetRepHi(d) < 0\n             ? MakeDuration((std::numeric_limits<int64_t>::max)(), ~uint32_t{0})\n             : MakeDuration((std::numeric_limits<int64_t>::min)(),\n                            ~uint32_t{0});\n}\n\n// Returns (-n)-1 (equivalently -(n+1)) without avoidable overflow.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr int64_t NegateAndSubtractOne(\n    int64_t n) {\n  // Note: Good compilers will optimize this expression to ~n when using\n  // a two's-complement representation (which is required for int64_t).\n  return (n < 0) ? -(n + 1) : (-n) - 1;\n}\n\n// Map between a Time and a Duration since the Unix epoch.  Note that these\n// functions depend on the above mentioned choice of the Unix epoch for the\n// Time representation (and both need to be Time friends).  Without this\n// knowledge, we would need to add-in/subtract-out UnixEpoch() respectively.\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Time FromUnixDuration(Duration d) {\n  return Time(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration ToUnixDuration(Time t) {\n  return t.rep_;\n}\n\ntemplate <std::intmax_t N>\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration FromInt64(int64_t v,\n                                                           std::ratio<1, N>) {\n  static_assert(0 < N && N <= 1000 * 1000 * 1000, \"Unsupported ratio\");\n  // Subsecond ratios cannot overflow.\n  return MakeNormalizedDuration(\n      v / N, v % N * kTicksPerNanosecond * 1000 * 1000 * 1000 / N);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration FromInt64(int64_t v,\n                                                           std::ratio<60>) {\n  return (v <= (std::numeric_limits<int64_t>::max)() / 60 &&\n          v >= (std::numeric_limits<int64_t>::min)() / 60)\n             ? MakeDuration(v * 60)\n             : v > 0 ? InfiniteDuration() : -InfiniteDuration();\n}\nABSL_ATTRIBUTE_CONST_FUNCTION constexpr Duration FromInt64(int64_t v,\n                                                           std::ratio<3600>) {\n  return (v <= (std::numeric_limits<int64_t>::max)() / 3600 &&\n          v >= (std::numeric_limits<int64_t>::min)() / 3600)\n             ? MakeDuration(v * 3600)\n             : v > 0 ? InfiniteDuration() : -InfiniteDuration();\n}\n\n// IsValidRep64<T>(0) is true if the expression `int64_t{std::declval<T>()}` is\n// valid. That is, if a T can be assigned to an int64_t without narrowing.\ntemplate <typename T>\nconstexpr auto IsValidRep64(int) -> decltype(int64_t{std::declval<T>()} == 0) {\n  return true;\n}\ntemplate <typename T>\nconstexpr auto IsValidRep64(char) -> bool {\n  return false;\n}\n\n// Converts a std::chrono::duration to an absl::Duration.\ntemplate <typename Rep, typename Period>\nABSL_ATTRIBUTE_PURE_FUNCTION constexpr Duration FromChrono(\n    const std::chrono::duration<Rep, Period>& d) {\n  static_assert(IsValidRep64<Rep>(0), \"duration::rep is invalid\");\n  return FromInt64(int64_t{d.count()}, Period{});\n}\n\ntemplate <typename Ratio>\nABSL_ATTRIBUTE_CONST_FUNCTION int64_t ToInt64(Duration d, Ratio) {\n  // Note: This may be used on MSVC, which may have a system_clock period of\n  // std::ratio<1, 10 * 1000 * 1000>\n  return ToInt64Seconds(d * Ratio::den / Ratio::num);\n}\n// Fastpath implementations for the 6 common duration units.\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d, std::nano) {\n  return ToInt64Nanoseconds(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d, std::micro) {\n  return ToInt64Microseconds(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d, std::milli) {\n  return ToInt64Milliseconds(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d,\n                                                     std::ratio<1>) {\n  return ToInt64Seconds(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d,\n                                                     std::ratio<60>) {\n  return ToInt64Minutes(d);\n}\nABSL_ATTRIBUTE_CONST_FUNCTION inline int64_t ToInt64(Duration d,\n                                                     std::ratio<3600>) {\n  return ToInt64Hours(d);\n}\n\n// Converts an absl::Duration to a chrono duration of type T.\ntemplate <typename T>\nABSL_ATTRIBUTE_CONST_FUNCTION T ToChronoDuration(Duration d) {\n  using Rep = typename T::rep;\n  using Period = typename T::period;\n  static_assert(IsValidRep64<Rep>(0), \"duration::rep is invalid\");\n  if (time_internal::IsInfiniteDuration(d))\n    return d < ZeroDuration() ? (T::min)() : (T::max)();\n  const auto v = ToInt64(d, Period{});\n  if (v > (std::numeric_limits<Rep>::max)()) return (T::max)();\n  if (v < (std::numeric_limits<Rep>::min)()) return (T::min)();\n  return T{v};\n}\n\n}",
  "id": "BLOCK-CPP-04432",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 1555,
  "validation_status": "validated"
}