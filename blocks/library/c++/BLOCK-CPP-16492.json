{
  "code": "#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nusing namespace clang;\nusing namespace detail;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16492_execute() {\n    {\n\n/// DeclarationNameExtra is used as a base of various uncommon special names.\n/// This class is needed since DeclarationName has not enough space to store\n/// the kind of every possible names. Therefore the kind of common names is\n/// stored directly in DeclarationName, and the kind of uncommon names is\n/// stored in DeclarationNameExtra. It is aligned to 8 bytes because\n/// DeclarationName needs the lower 3 bits to store the kind of common names.\n/// DeclarationNameExtra is tightly coupled to DeclarationName and any change\n/// here is very likely to require changes in DeclarationName(Table).\nclass alignas(IdentifierInfoAlignment) DeclarationNameExtra {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\nprotected:\n  /// The kind of \"extra\" information stored in the DeclarationName. See\n  /// @c ExtraKindOrNumArgs for an explanation of how these enumerator values\n  /// are used. Note that DeclarationName depends on the numerical values\n  /// of the enumerators in this enum. See DeclarationName::StoredNameKind\n  /// for more info.\n  enum ExtraKind {\n    CXXDeductionGuideName,\n    CXXLiteralOperatorName,\n    CXXUsingDirective,\n    ObjCMultiArgSelector\n  };\n\n  /// ExtraKindOrNumArgs has one of the following meaning:\n  ///  * The kind of an uncommon C++ special name. This DeclarationNameExtra\n  ///    is in this case in fact either a CXXDeductionGuideNameExtra or\n  ///    a CXXLiteralOperatorIdName.\n  ///\n  ///  * It may be also name common to C++ using-directives (CXXUsingDirective),\n  ///\n  ///  * Otherwise it is ObjCMultiArgSelector+NumArgs, where NumArgs is\n  ///    the number of arguments in the Objective-C selector, in which\n  ///    case the DeclarationNameExtra is also a MultiKeywordSelector.\n  unsigned ExtraKindOrNumArgs;\n\n  DeclarationNameExtra(ExtraKind Kind) : ExtraKindOrNumArgs(Kind) {}\n  DeclarationNameExtra(unsigned NumArgs)\n      : ExtraKindOrNumArgs(ObjCMultiArgSelector + NumArgs) {}\n\n  /// Return the corresponding ExtraKind.\n  ExtraKind getKind() const {\n    return static_cast<ExtraKind>(ExtraKindOrNumArgs >\n                                          (unsigned)ObjCMultiArgSelector\n                                      ? (unsigned)ObjCMultiArgSelector\n                                      : ExtraKindOrNumArgs);\n  }\n\n  /// Return the number of arguments in an ObjC selector. Only valid when this\n  /// is indeed an ObjCMultiArgSelector.\n  unsigned getNumArgs() const {\n    assert(ExtraKindOrNumArgs >= (unsigned)ObjCMultiArgSelector &&\n           \"getNumArgs called but this is not an ObjC selector!\");\n    return ExtraKindOrNumArgs - (unsigned)ObjCMultiArgSelector;\n  }\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16492",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/IdentifierTable.h",
  "source_line": 991,
  "validation_status": "validated"
}