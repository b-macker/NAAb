{
  "code": "{\nprotected:\n  /// Word-like arguments.\n  ArrayRef<Argument> Args;\n\n  /// Paragraph argument.\n  ParagraphComment *Paragraph;\n\n  BlockCommandComment(CommentKind K,\n                      SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(K, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\npublic:\n  BlockCommandComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(BlockCommandCommentKind, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstBlockCommandCommentConstant &&\n           C->getCommentKind() <= LastBlockCommandCommentConstant;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(&Paragraph);\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(&Paragraph + 1);\n  }\n\n  unsigned getCommandID() const {\n    return BlockCommandCommentBits.CommandID;\n  }\n\n  StringRef getCommandName(const CommandTraits &Traits) const {\n    return Traits.getCommandInfo(getCommandID())->Name;\n  }\n\n  SourceLocation getCommandNameBeginLoc() const {\n    return getBeginLoc().getLocWithOffset(1);\n  }\n\n  SourceRange getCommandNameRange(const CommandTraits &Traits) const {\n    StringRef Name = getCommandName(Traits);\n    return SourceRange(getCommandNameBeginLoc(),\n                       getBeginLoc().getLocWithOffset(1 + Name.size()));\n  }\n\n  unsigned getNumArgs() const {\n    return Args.size();\n  }\n\n  StringRef getArgText(unsigned Idx) const {\n    return Args[Idx].Text;\n  }\n\n  SourceRange getArgRange(unsigned Idx) const {\n    return Args[Idx].Range;\n  }\n\n  void setArgs(ArrayRef<Argument> A) {\n    Args = A;\n    if (Args.size() > 0) {\n      SourceLocation NewLocEnd = Args.back().Range.getEnd();\n      if (NewLocEnd.isValid())\n        setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n    }\n  }\n\n  ParagraphComment *getParagraph() const LLVM_READONLY {\n    return Paragraph;\n  }\n\n  bool hasNonWhitespaceParagraph() const {\n    return Paragraph && !Paragraph->isWhitespace();\n  }\n\n  void setParagraph(ParagraphComment *PC) {\n    Paragraph = PC;\n    SourceLocation NewLocEnd = PC->getEndLoc();\n    if (NewLocEnd.isValid())\n      setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n  }\n\n  CommandMarkerKind getCommandMarker() const LLVM_READONLY {\n    return static_cast<CommandMarkerKind>(\n        BlockCommandCommentBits.CommandMarker);\n  }\n}",
  "id": "BLOCK-CPP-23404",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Comment.h",
  "source_line": 588,
  "validation_status": "validated"
}