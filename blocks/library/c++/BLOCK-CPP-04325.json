{
  "code": "{\n public:\n  // A Condition that returns the result of \"(*func)(arg)\"\n  Condition(bool (*func)(void*), void* arg);\n\n  // Templated version for people who are averse to casts.\n  //\n  // To use a lambda, prepend it with unary plus, which converts the lambda\n  // into a function pointer:\n  //     Condition(+[](T* t) { return ...; }, arg).\n  //\n  // Note: lambdas in this case must contain no bound variables.\n  //\n  // See class comment for performance advice.\n  template <typename T>\n  Condition(bool (*func)(T*), T* arg);\n\n  // Same as above, but allows for cases where `arg` comes from a pointer that\n  // is convertible to the function parameter type `T*` but not an exact match.\n  //\n  // For example, the argument might be `X*` but the function takes `const X*`,\n  // or the argument might be `Derived*` while the function takes `Base*`, and\n  // so on for cases where the argument pointer can be implicitly converted.\n  //\n  // Implementation notes: This constructor overload is required in addition to\n  // the one above to allow deduction of `T` from `arg` for cases such as where\n  // a function template is passed as `func`. Also, the dummy `typename = void`\n  // template parameter exists just to work around a MSVC mangling bug.\n  template <typename T, typename = void>\n  Condition(bool (*func)(T*),\n            typename absl::internal::type_identity<T>::type* arg);\n\n  // Templated version for invoking a method that returns a `bool`.\n  //\n  // `Condition(object, &Class::Method)` constructs a `Condition` that evaluates\n  // `object->Method()`.\n  //\n  // Implementation Note: `absl::internal::type_identity` is used to allow\n  // methods to come from base classes. A simpler signature like\n  // `Condition(T*, bool (T::*)())` does not suffice.\n  template <typename T>\n  Condition(T* object,\n            bool (absl::internal::type_identity<T>::type::*method)());\n\n  // Same as above, for const members\n  template <typename T>\n  Condition(const T* object,\n            bool (absl::internal::type_identity<T>::type::*method)() const);\n\n  // A Condition that returns the value of `*cond`\n  explicit Condition(const bool* cond);\n\n  // Templated version for invoking a functor that returns a `bool`.\n  // This approach accepts pointers to non-mutable lambdas, `std::function`,\n  // the result of` std::bind` and user-defined functors that define\n  // `bool F::operator()() const`.\n  //\n  // Example:\n  //\n  //   auto reached = [this, current]() {\n  //     mu_.AssertReaderHeld();                // For annotalysis.\n  //     return processed_ >= current;\n  //   };\n  //   mu_.Await(Condition(&reached));\n  //\n  // NOTE: never use \"mu_.AssertHeld()\" instead of \"mu_.AssertReaderHeld()\" in\n  // the lambda as it may be called when the mutex is being unlocked from a\n  // scope holding only a reader lock, which will make the assertion not\n  // fulfilled and crash the binary.\n\n  // See class comment for performance advice. In particular, if there\n  // might be more than one waiter for the same condition, make sure\n  // that all waiters construct the condition with the same pointers.\n\n  // Implementation note: The second template parameter ensures that this\n  // constructor doesn't participate in overload resolution if T doesn't have\n  // `bool operator() const`.\n  template <typename T, typename E = decltype(static_cast<bool (T::*)() const>(\n                            &T::operator()))>\n  explicit Condition(const T* obj)\n      : Condition(obj, static_cast<bool (T::*)() const>(&T::operator())) {}\n\n  // A Condition that always returns `true`.\n  // kTrue is only useful in a narrow set of circumstances, mostly when\n  // it's passed conditionally. For example:\n  //\n  //   mu.LockWhen(some_flag ? kTrue : SomeOtherCondition);\n  //\n  // Note: {LockWhen,Await}With{Deadline,Timeout} methods with kTrue condition\n  // don't return immediately when the timeout happens, they still block until\n  // the Mutex becomes available. The return value of these methods does\n  // not indicate if the timeout was reached; rather it indicates whether or\n  // not the condition is true.\n  ABSL_CONST_INIT static const Condition kTrue;\n\n  // Evaluates the condition.\n  bool Eval() const;\n\n  // Returns `true` if the two conditions are guaranteed to return the same\n  // value if evaluated at the same time, `false` if the evaluation *may* return\n  // different results.\n  //\n  // Two `Condition` values are guaranteed equal if both their `func` and `arg`\n  // components are the same. A null pointer is equivalent to a `true`\n  // condition.\n  static bool GuaranteedEqual(const Condition* a, const Condition* b);\n\n private:\n  // Sizing an allocation for a method pointer can be subtle. In the Itanium\n  // specifications, a method pointer has a predictable, uniform size. On the\n  // other hand, MSVC ABI, method pointer sizes vary based on the\n  // inheritance of the class. Specifically, method pointers from classes with\n  // multiple inheritance are bigger than those of classes with single\n  // inheritance. Other variations also exist.\n\n#ifndef _MSC_VER\n  // Allocation for a function pointer or method pointer.\n  // The {0} initializer ensures that all unused bytes of this buffer are\n  // always zeroed out.  This is necessary, because GuaranteedEqual() compares\n  // all of the bytes, unaware of which bytes are relevant to a given `eval_`.\n  using MethodPtr = bool (Condition::*)();\n  char callback_[sizeof(MethodPtr)] = {0};\n#else\n  // It is well known that the larget MSVC pointer-to-member is 24 bytes. This\n  // may be the largest known pointer-to-member of any platform. For this\n  // reason we will allocate 24 bytes for MSVC platform toolchains.\n  char callback_[24] = {0};\n#endif\n\n  // Function with which to evaluate callbacks and/or arguments.\n  bool (*eval_)(const Condition*) = nullptr;\n\n  // Either an argument for a function call or an object for a method call.\n  void* arg_ = nullptr;\n\n  // Various functions eval_ can point to:\n  static bool CallVoidPtrFunction(const Condition*);\n  template <typename T>\n  static bool CastAndCallFunction(const Condition* c);\n  template <typename T, typename ConditionMethodPtr>\n  static bool CastAndCallMethod(const Condition* c);\n\n  // Helper methods for storing, validating, and reading callback arguments.\n  template <typename T>\n  inline void StoreCallback(T callback) {\n    static_assert(\n        sizeof(callback) <= sizeof(callback_),\n        \"An overlarge pointer was passed as a callback to Condition.\");\n    std::memcpy(callback_, &callback, sizeof(callback));\n  }\n\n  template <typename T>\n  inline void ReadCallback(T* callback) const {\n    std::memcpy(callback, callback_, sizeof(*callback));\n  }\n\n  static bool AlwaysTrue(const Condition*) { return true; }\n\n  // Used only to create kTrue.\n  constexpr Condition() : eval_(AlwaysTrue), arg_(nullptr) {}\n}",
  "id": "BLOCK-CPP-04325",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/mutex.h",
  "source_line": 714,
  "validation_status": "validated"
}