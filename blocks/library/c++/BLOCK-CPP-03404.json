{
  "code": "#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include \"absl/algorithm/algorithm.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/meta/type_traits.h\"\n\nusing namespace absl;\nusing namespace container_algorithm_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03404_execute() {\n    {\n\n// NOTE: it is important to defer to ADL lookup for building with C++ modules,\n// especially for headers like <valarray> which are not visible from this file\n// but specialize std::begin and std::end.\nusing std::begin;\nusing std::end;\n\n// The type of the iterator given by begin(c) (possibly std::begin(c)).\n// ContainerIter<const vector<T>> gives vector<T>::const_iterator,\n// while ContainerIter<vector<T>> gives vector<T>::iterator.\ntemplate <typename C>\nusing ContainerIter = decltype(begin(std::declval<C&>()));\n\n// An MSVC bug involving template parameter substitution requires us to use\n// decltype() here instead of just std::pair.\ntemplate <typename C1, typename C2>\nusing ContainerIterPairType =\n    decltype(std::make_pair(ContainerIter<C1>(), ContainerIter<C2>()));\n\ntemplate <typename C>\nusing ContainerDifferenceType = decltype(std::distance(\n    std::declval<ContainerIter<C>>(), std::declval<ContainerIter<C>>()));\n\ntemplate <typename C>\nusing ContainerPointerType =\n    typename std::iterator_traits<ContainerIter<C>>::pointer;\n\n// container_algorithm_internal::c_begin and\n// container_algorithm_internal::c_end are abbreviations for proper ADL\n// lookup of std::begin and std::end, i.e.\n//   using std::begin;\n//   using std::end;\n//   std::foo(begin(c), end(c));\n// becomes\n//   std::foo(container_algorithm_internal::begin(c),\n//            container_algorithm_internal::end(c));\n// These are meant for internal use only.\n\ntemplate <typename C>\nContainerIter<C> c_begin(C& c) {\n  return begin(c);\n}\n\ntemplate <typename C>\nContainerIter<C> c_end(C& c) {\n  return end(c);\n}\n\ntemplate <typename T>\nstruct IsUnorderedContainer : std::false_type {};\n\ntemplate <class Key, class T, class Hash, class KeyEqual, class Allocator>\nstruct IsUnorderedContainer<\n    std::unordered_map<Key, T, Hash, KeyEqual, Allocator>> : std::true_type {};\n\ntemplate <class Key, class Hash, class KeyEqual, class Allocator>\nstruct IsUnorderedContainer<std::unordered_set<Key, Hash, KeyEqual, Allocator>>\n    : std::true_type {};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03404",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/algorithm/container.h",
  "source_line": 60,
  "validation_status": "validated"
}