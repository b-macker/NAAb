{
  "code": "{\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  }",
  "id": "BLOCK-CPP-08339",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclBase.h",
  "source_line": 2225,
  "validation_status": "validated"
}