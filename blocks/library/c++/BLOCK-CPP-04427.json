{
  "code": "{\n public:\n  explicit TimeZone(time_internal::cctz::time_zone tz) : cz_(tz) {}\n  TimeZone() = default;  // UTC, but prefer UTCTimeZone() to be explicit.\n\n  // Copyable.\n  TimeZone(const TimeZone&) = default;\n  TimeZone& operator=(const TimeZone&) = default;\n\n  explicit operator time_internal::cctz::time_zone() const { return cz_; }\n\n  std::string name() const { return cz_.name(); }\n\n  // TimeZone::CivilInfo\n  //\n  // Information about the civil time corresponding to an absolute time.\n  // This struct is not intended to represent an instant in time. So, rather\n  // than passing a `TimeZone::CivilInfo` to a function, pass an `absl::Time`\n  // and an `absl::TimeZone`.\n  struct CivilInfo {\n    CivilSecond cs;\n    Duration subsecond;\n\n    // Note: The following fields exist for backward compatibility\n    // with older APIs.  Accessing these fields directly is a sign of\n    // imprudent logic in the calling code.  Modern time-related code\n    // should only access this data indirectly by way of FormatTime().\n    // These fields are undefined for InfiniteFuture() and InfinitePast().\n    int offset;             // seconds east of UTC\n    bool is_dst;            // is offset non-standard?\n    const char* zone_abbr;  // time-zone abbreviation (e.g., \"PST\")\n  };\n\n  // TimeZone::At(Time)\n  //\n  // Returns the civil time for this TimeZone at a certain `absl::Time`.\n  // If the input time is infinite, the output civil second will be set to\n  // CivilSecond::max() or min(), and the subsecond will be infinite.\n  //\n  // Example:\n  //\n  //   const auto epoch = lax.At(absl::UnixEpoch());\n  //   // epoch.cs == 1969-12-31 16:00:00\n  //   // epoch.subsecond == absl::ZeroDuration()\n  //   // epoch.offset == -28800\n  //   // epoch.is_dst == false\n  //   // epoch.abbr == \"PST\"\n  CivilInfo At(Time t) const;\n\n  // TimeZone::TimeInfo\n  //\n  // Information about the absolute times corresponding to a civil time.\n  // (Subseconds must be handled separately.)\n  //\n  // It is possible for a caller to pass a civil-time value that does\n  // not represent an actual or unique instant in time (due to a shift\n  // in UTC offset in the TimeZone, which results in a discontinuity in\n  // the civil-time components). For example, a daylight-saving-time\n  // transition skips or repeats civil times---in the United States,\n  // March 13, 2011 02:15 never occurred, while November 6, 2011 01:15\n  // occurred twice---so requests for such times are not well-defined.\n  // To account for these possibilities, `absl::TimeZone::TimeInfo` is\n  // richer than just a single `absl::Time`.\n  struct TimeInfo {\n    enum CivilKind {\n      UNIQUE,    // the civil time was singular (pre == trans == post)\n      SKIPPED,   // the civil time did not exist (pre >= trans > post)\n      REPEATED,  // the civil time was ambiguous (pre < trans <= post)\n    } kind;\n    Time pre;    // time calculated using the pre-transition offset\n    Time trans;  // when the civil-time discontinuity occurred\n    Time post;   // time calculated using the post-transition offset\n  };\n\n  // TimeZone::At(CivilSecond)\n  //\n  // Returns an `absl::TimeInfo` containing the absolute time(s) for this\n  // TimeZone at an `absl::CivilSecond`. When the civil time is skipped or\n  // repeated, returns times calculated using the pre-transition and post-\n  // transition UTC offsets, plus the transition time itself.\n  //\n  // Examples:\n  //\n  //   // A unique civil time\n  //   const auto jan01 = lax.At(absl::CivilSecond(2011, 1, 1, 0, 0, 0));\n  //   // jan01.kind == TimeZone::TimeInfo::UNIQUE\n  //   // jan01.pre    is 2011-01-01 00:00:00 -0800\n  //   // jan01.trans  is 2011-01-01 00:00:00 -0800\n  //   // jan01.post   is 2011-01-01 00:00:00 -0800\n  //\n  //   // A Spring DST transition, when there is a gap in civil time\n  //   const auto mar13 = lax.At(absl::CivilSecond(2011, 3, 13, 2, 15, 0));\n  //   // mar13.kind == TimeZone::TimeInfo::SKIPPED\n  //   // mar13.pre   is 2011-03-13 03:15:00 -0700\n  //   // mar13.trans is 2011-03-13 03:00:00 -0700\n  //   // mar13.post  is 2011-03-13 01:15:00 -0800\n  //\n  //   // A Fall DST transition, when civil times are repeated\n  //   const auto nov06 = lax.At(absl::CivilSecond(2011, 11, 6, 1, 15, 0));\n  //   // nov06.kind == TimeZone::TimeInfo::REPEATED\n  //   // nov06.pre   is 2011-11-06 01:15:00 -0700\n  //   // nov06.trans is 2011-11-06 01:00:00 -0800\n  //   // nov06.post  is 2011-11-06 01:15:00 -0800\n  TimeInfo At(CivilSecond ct) const;\n\n  // TimeZone::NextTransition()\n  // TimeZone::PrevTransition()\n  //\n  // Finds the time of the next/previous offset change in this time zone.\n  //\n  // By definition, `NextTransition(t, &trans)` returns false when `t` is\n  // `InfiniteFuture()`, and `PrevTransition(t, &trans)` returns false\n  // when `t` is `InfinitePast()`. If the zone has no transitions, the\n  // result will also be false no matter what the argument.\n  //\n  // Otherwise, when `t` is `InfinitePast()`, `NextTransition(t, &trans)`\n  // returns true and sets `trans` to the first recorded transition. Chains\n  // of calls to `NextTransition()/PrevTransition()` will eventually return\n  // false, but it is unspecified exactly when `NextTransition(t, &trans)`\n  // jumps to false, or what time is set by `PrevTransition(t, &trans)` for\n  // a very distant `t`.\n  //\n  // Note: Enumeration of time-zone transitions is for informational purposes\n  // only. Modern time-related code should not care about when offset changes\n  // occur.\n  //\n  // Example:\n  //   absl::TimeZone nyc;\n  //   if (!absl::LoadTimeZone(\"America/New_York\", &nyc)) { ... }\n  //   const auto now = absl::Now();\n  //   auto t = absl::InfinitePast();\n  //   absl::TimeZone::CivilTransition trans;\n  //   while (t <= now && nyc.NextTransition(t, &trans)) {\n  //     // transition: trans.from -> trans.to\n  //     t = nyc.At(trans.to).trans;\n  //   }\n  struct CivilTransition {\n    CivilSecond from;  // the civil time we jump from\n    CivilSecond to;    // the civil time we jump to\n  };\n  bool NextTransition(Time t, CivilTransition* trans) const;\n  bool PrevTransition(Time t, CivilTransition* trans) const;\n\n  template <typename H>\n  friend H AbslHashValue(H h, TimeZone tz) {\n    return H::combine(std::move(h), tz.cz_);\n  }\n\n private:\n  friend bool operator==(TimeZone a, TimeZone b) { return a.cz_ == b.cz_; }\n  friend bool operator!=(TimeZone a, TimeZone b) { return a.cz_ != b.cz_; }\n  friend std::ostream& operator<<(std::ostream& os, TimeZone tz) {\n    return os << tz.name();\n  }\n\n  time_internal::cctz::time_zone cz_;\n}",
  "id": "BLOCK-CPP-04427",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 1064,
  "validation_status": "validated"
}