{
  "code": "#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-23242_execute() {\n    {\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {\n  ///     // look at Ptr's pointee type\n  ///   }\n  /// }\n  /// @endcode\n  ///\n  /// \\returns A proxy pointer to the same type, but with the specified\n  /// static type (@p U). If the dynamic type is not the specified static type\n  /// or a derived class thereof, a NULL canonical type.\n  template<typename U> CanProxy<U> getAs() const;\n\n  template<typename U> CanProxy<U> castAs() const;\n\n  /// Overloaded arrow operator that produces a canonical type\n  /// proxy.\n  CanProxy<T> operator->() const;\n\n  /// Retrieve all qualifiers.\n  Qualifiers getQualifiers() const { return Stored.getLocalQualifiers(); }\n\n  /// Retrieve the const/volatile/restrict qualifiers.\n  unsigned getCVRQualifiers() const { return Stored.getLocalCVRQualifiers(); }\n\n  /// Determines whether this type has any qualifiers\n  bool hasQualifiers() const { return Stored.hasLocalQualifiers(); }\n\n  bool isConstQualified() const {\n    return Stored.isLocalConstQualified();\n  }\n\n  bool isVolatileQualified() const {\n    return Stored.isLocalVolatileQualified();\n  }\n\n  bool isRestrictQualified() const {\n    return Stored.isLocalRestrictQualified();\n  }\n\n  /// Determines if this canonical type is furthermore\n  /// canonical as a parameter.  The parameter-canonicalization\n  /// process decays arrays to pointers and drops top-level qualifiers.\n  bool isCanonicalAsParam() const {\n    return Stored.isCanonicalAsParam();\n  }\n\n  /// Retrieve the unqualified form of this type.\n  CanQual<T> getUnqualifiedType() const;\n\n  /// Retrieves a version of this type with const applied.\n  /// Note that this does not always yield a canonical type.\n  QualType withConst() const {\n    return Stored.withConst();\n  }\n\n  /// Determines whether this canonical type is more qualified than\n  /// the @p Other canonical type.\n  bool isMoreQualifiedThan(CanQual<T> Other) const {\n    return Stored.isMoreQualifiedThan(Other.Stored);\n  }\n\n  /// Determines whether this canonical type is at least as qualified as\n  /// the @p Other canonical type.\n  bool isAtLeastAsQualifiedAs(CanQual<T> Other) const {\n    return Stored.isAtLeastAsQualifiedAs(Other.Stored);\n  }\n\n  /// If the canonical type is a reference type, returns the type that\n  /// it refers to; otherwise, returns the type itself.\n  CanQual<Type> getNonReferenceType() const;\n\n  /// Retrieve the internal representation of this canonical type.\n  void *getAsOpaquePtr() const { return Stored.getAsOpaquePtr(); }\n\n  /// Construct a canonical type from its internal representation.\n  static CanQual<T> getFromOpaquePtr(void *Ptr);\n\n  /// Builds a canonical type from a QualType.\n  ///\n  /// This routine is inherently unsafe, because it requires the user to\n  /// ensure that the given type is a canonical type with the correct\n  // (dynamic) type.\n  static CanQual<T> CreateUnsafe(QualType Other);\n\n  void dump() const { Stored.dump(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-23242",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CanonicalType.h",
  "source_line": 110,
  "validation_status": "validated"
}