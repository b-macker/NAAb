{
  "code": "{\n  // Print the sign or the sign column.\n  Float abs_v = v;\n  char sign_char = 0;\n  if (std::signbit(abs_v)) {\n    sign_char = '-';\n    abs_v = -abs_v;\n  } else if (conv.has_show_pos_flag()) {\n    sign_char = '+';\n  } else if (conv.has_sign_col_flag()) {\n    sign_char = ' ';\n  }\n\n  // Print nan/inf.\n  if (ConvertNonNumericFloats(sign_char, abs_v, conv, sink)) {\n    return true;\n  }\n\n  size_t precision =\n      conv.precision() < 0 ? 6 : static_cast<size_t>(conv.precision());\n\n  int exp = 0;\n\n  auto decomposed = Decompose(abs_v);\n\n  Buffer buffer;\n\n  FormatConversionChar c = conv.conversion_char();\n\n  if (c == FormatConversionCharInternal::f ||\n      c == FormatConversionCharInternal::F) {\n    FormatF(decomposed.mantissa, decomposed.exponent,\n            {sign_char, precision, conv, sink});\n    return true;\n  } else if (c == FormatConversionCharInternal::e ||\n             c == FormatConversionCharInternal::E) {\n    if (!FloatToBuffer<FormatStyle::Precision>(decomposed, precision, &buffer,\n                                               &exp)) {\n      return FallbackToSnprintf(v, conv, sink);\n    }\n    if (!conv.has_alt_flag() && buffer.back() == '.') buffer.pop_back();\n    PrintExponent(\n        exp, FormatConversionCharIsUpper(conv.conversion_char()) ? 'E' : 'e',\n        &buffer);\n  } else if (c == FormatConversionCharInternal::g ||\n             c == FormatConversionCharInternal::G) {\n    precision = std::max(precision, size_t{1}) - 1;\n    if (!FloatToBuffer<FormatStyle::Precision>(decomposed, precision, &buffer,\n                                               &exp)) {\n      return FallbackToSnprintf(v, conv, sink);\n    }\n    if ((exp < 0 || precision + 1 > static_cast<size_t>(exp)) && exp >= -4) {\n      if (exp < 0) {\n        // Have 1.23456, needs 0.00123456\n        // Move the first digit\n        buffer.begin[1] = *buffer.begin;\n        // Add some zeros\n        for (; exp < -1; ++exp) *buffer.begin-- = '0';\n        *buffer.begin-- = '.';\n        *buffer.begin = '0';\n      } else if (exp > 0) {\n        // Have 1.23456, needs 1234.56\n        // Move the '.' exp positions to the right.\n        std::rotate(buffer.begin + 1, buffer.begin + 2, buffer.begin + exp + 2);\n      }\n      exp = 0;\n    }\n    if (!conv.has_alt_flag()) {\n      while (buffer.back() == '0') buffer.pop_back();\n      if (buffer.back() == '.') buffer.pop_back();\n    }\n    if (exp) {\n      PrintExponent(\n          exp, FormatConversionCharIsUpper(conv.conversion_char()) ? 'E' : 'e',\n          &buffer);\n    }\n  } else if (c == FormatConversionCharInternal::a ||\n             c == FormatConversionCharInternal::A) {\n    bool uppercase = (c == FormatConversionCharInternal::A);\n    FormatA(HexFloatTypeParams(Float{}), decomposed.mantissa,\n            decomposed.exponent, uppercase, {sign_char, precision, conv, sink});\n    return true;\n  } else {\n    return false;\n  }\n\n  WriteBufferToSink(\n      sign_char,\n      absl::string_view(buffer.begin,\n                        static_cast<size_t>(buffer.end - buffer.begin)),\n      conv, sink);\n\n  return true;\n}",
  "id": "BLOCK-CPP-03092",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 1335,
  "validation_status": "validated"
}