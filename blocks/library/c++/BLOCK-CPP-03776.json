{
  "code": "{\n public:\n  int128() = default;\n\n  // Constructors from arithmetic types\n  constexpr int128(int v);                 // NOLINT(runtime/explicit)\n  constexpr int128(unsigned int v);        // NOLINT(runtime/explicit)\n  constexpr int128(long v);                // NOLINT(runtime/int)\n  constexpr int128(unsigned long v);       // NOLINT(runtime/int)\n  constexpr int128(long long v);           // NOLINT(runtime/int)\n  constexpr int128(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr int128(__int128 v);  // NOLINT(runtime/explicit)\n  constexpr explicit int128(unsigned __int128 v);\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  constexpr explicit int128(uint128 v);\n  explicit int128(float v);\n  explicit int128(double v);\n  explicit int128(long double v);\n\n  // Assignment operators from arithmetic types\n  int128& operator=(int v);\n  int128& operator=(unsigned int v);\n  int128& operator=(long v);                // NOLINT(runtime/int)\n  int128& operator=(unsigned long v);       // NOLINT(runtime/int)\n  int128& operator=(long long v);           // NOLINT(runtime/int)\n  int128& operator=(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  int128& operator=(__int128 v);\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n\n  // Conversion operators to other arithmetic types\n  constexpr explicit operator bool() const;\n  constexpr explicit operator char() const;\n  constexpr explicit operator signed char() const;\n  constexpr explicit operator unsigned char() const;\n  constexpr explicit operator char16_t() const;\n  constexpr explicit operator char32_t() const;\n  constexpr explicit operator ABSL_INTERNAL_WCHAR_T() const;\n  constexpr explicit operator short() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned short() const;\n  constexpr explicit operator int() const;\n  constexpr explicit operator unsigned int() const;\n  constexpr explicit operator long() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator long long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long long() const;\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr explicit operator __int128() const;\n  constexpr explicit operator unsigned __int128() const;\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  explicit operator float() const;\n  explicit operator double() const;\n  explicit operator long double() const;\n\n  // Trivial copy constructor, assignment operator and destructor.\n\n  // Arithmetic operators\n  int128& operator+=(int128 other);\n  int128& operator-=(int128 other);\n  int128& operator*=(int128 other);\n  int128& operator/=(int128 other);\n  int128& operator%=(int128 other);\n  int128 operator++(int);  // postfix increment: i++\n  int128 operator--(int);  // postfix decrement: i--\n  int128& operator++();    // prefix increment:  ++i\n  int128& operator--();    // prefix decrement:  --i\n  int128& operator&=(int128 other);\n  int128& operator|=(int128 other);\n  int128& operator^=(int128 other);\n  int128& operator<<=(int amount);\n  int128& operator>>=(int amount);\n\n  // Int128Low64()\n  //\n  // Returns the lower 64-bit value of a `int128` value.\n  friend constexpr uint64_t Int128Low64(int128 v);\n\n  // Int128High64()\n  //\n  // Returns the higher 64-bit value of a `int128` value.\n  friend constexpr int64_t Int128High64(int128 v);\n\n  // MakeInt128()\n  //\n  // Constructs a `int128` numeric value from two 64-bit integers. Note that\n  // signedness is conveyed in the upper `high` value.\n  //\n  //   (absl::int128(1) << 64) * high + low\n  //\n  // Note that this factory function is the only way to construct a `int128`\n  // from integer values greater than 2^64 or less than -2^64.\n  //\n  // Example:\n  //\n  //   absl::int128 big = absl::MakeInt128(1, 0);\n  //   absl::int128 big_n = absl::MakeInt128(-1, 0);\n  friend constexpr int128 MakeInt128(int64_t high, uint64_t low);\n\n  // Int128Max()\n  //\n  // Returns the maximum value for a 128-bit signed integer.\n  friend constexpr int128 Int128Max();\n\n  // Int128Min()\n  //\n  // Returns the minimum value for a 128-bit signed integer.\n  friend constexpr int128 Int128Min();\n\n  // Support for absl::Hash.\n  template <typename H>\n  friend H AbslHashValue(H h, int128 v) {\n    return H::combine(std::move(h), Int128High64(v), Int128Low64(v));\n  }\n\n  // Support for absl::StrCat() etc.\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, int128 v) {\n    sink.Append(v.ToString());\n  }\n\n private:\n  constexpr int128(int64_t high, uint64_t low);\n\n  std::string ToString() const;\n\n#if defined(ABSL_HAVE_INTRINSIC_INT128)\n  __int128 v_;\n#else  // ABSL_HAVE_INTRINSIC_INT128\n#if defined(ABSL_IS_LITTLE_ENDIAN)\n  uint64_t lo_;\n  int64_t hi_;\n#elif defined(ABSL_IS_BIG_ENDIAN)\n  int64_t hi_;\n  uint64_t lo_;\n#else  // byte order\n#error \"Unsupported byte order: must be little-endian or big-endian.\"\n#endif  // byte order\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n}",
  "id": "BLOCK-CPP-03776",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.h",
  "source_line": 347,
  "validation_status": "validated"
}