{
  "code": "{\n//     return H::combine(std::move(state), v.field1, ..., v.fieldN);\n//   }\n//\n// where `(field1, ..., fieldN)` are the members you would use on your\n// `operator==` to define equality.\n//\n// Notice that `AbslHashValue` is not a class member, but an ordinary function.\n// An `AbslHashValue` overload for a type should only be declared in the same\n// file and namespace as said type. The proper `AbslHashValue` implementation\n// for a given type will be discovered via ADL.\n//\n// Note: unlike `std::hash', `absl::Hash` should never be specialized. It must\n// only be extended by adding `AbslHashValue()` overloads.\n//\ntemplate <typename T>\nusing Hash = absl::hash_internal::Hash<T>;\n\n// HashOf\n//\n// absl::HashOf() is a helper that generates a hash from the values of its\n// arguments.  It dispatches to absl::Hash directly, as follows:\n//  * HashOf(t) == absl::Hash<T>{}(t)\n//  * HashOf(a, b, c) == HashOf(std::make_tuple(a, b, c))\n//\n// HashOf(a1, a2, ...) == HashOf(b1, b2, ...) is guaranteed when\n//  * The argument lists have pairwise identical C++ types\n//  * a1 == b1 && a2 == b2 && ...\n//\n// The requirement that the arguments match in both type and value is critical.\n// It means that `a == b` does not necessarily imply `HashOf(a) == HashOf(b)` if\n// `a` and `b` have different types. For example, `HashOf(2) != HashOf(2.0)`.\ntemplate <int&... ExplicitArgumentBarrier, typename... Types>\nsize_t HashOf(const Types&... values) {\n  auto tuple = std::tie(values...);\n  return absl::Hash<decltype(tuple)>{}(tuple);\n}\n\n// HashState\n//\n// A type erased version of the hash state concept, for use in user-defined\n// `AbslHashValue` implementations that can't use templates (such as PImpl\n// classes, virtual functions, etc.). The type erasure adds overhead so it\n// should be avoided unless necessary.\n//\n// Note: This wrapper will only erase calls to\n//     combine_contiguous(H, const unsigned char*, size_t)\n//     RunCombineUnordered(H, CombinerF)\n//\n// All other calls will be handled internally and will not invoke overloads\n// provided by the wrapped class.\n//\n// Users of this class should still define a template `AbslHashValue` function,\n// but can use `absl::HashState::Create(&state)` to erase the type of the hash\n// state and dispatch to their private hashing logic.\n//\n// This state can be used like any other hash state. In particular, you can call\n// `HashState::combine()` and `HashState::combine_contiguous()` on it.\n//\n// Example:\n//\n//   class Interface {\n//    public:\n//     template <typename H>\n//     friend H AbslHashValue(H state, const Interface& value) {\n//       state = H::combine(std::move(state), std::type_index(typeid(*this)));\n//       value.HashValue(absl::HashState::Create(&state));\n//       return state;\n//     }\n//    private:\n//     virtual void HashValue(absl::HashState state) const = 0;\n//   };\n//\n//   class Impl : Interface {\n//    private:\n//     void HashValue(absl::HashState state) const override {\n//       absl::HashState::combine(std::move(state), v1_, v2_);\n//     }\n//     int v1_;\n//     std::string v2_;\n//   };\nclass HashState : public hash_internal::HashStateBase<HashState> {\n public:\n  // HashState::Create()\n  //\n  // Create a new `HashState` instance that wraps `state`. All calls to\n  // `combine()` and `combine_contiguous()` on the new instance will be\n  // redirected to the original `state` object. The `state` object must outlive\n  // the `HashState` instance.\n  template <typename T>\n  static HashState Create(T* state) {\n    HashState s;\n    s.Init(state);\n    return s;\n  }\n\n  HashState(const HashState&) = delete;\n  HashState& operator=(const HashState&) = delete;\n  HashState(HashState&&) = default;\n  HashState& operator=(HashState&&) = default;\n\n  // HashState::combine()\n  //\n  // Combines an arbitrary number of values into a hash state, returning the\n  // updated state.\n  using HashState::HashStateBase::combine;\n\n  // HashState::combine_contiguous()\n  //\n  // Combines a contiguous array of `size` elements into a hash state, returning\n  // the updated state.\n  static HashState combine_contiguous(HashState hash_state,\n                                      const unsigned char* first, size_t size) {\n    hash_state.combine_contiguous_(hash_state.state_, first, size);\n    return hash_state;\n  }\n  using HashState::HashStateBase::combine_contiguous;\n\n private:\n  HashState() = default;\n\n  friend class HashState::HashStateBase;\n\n  template <typename T>\n  static void CombineContiguousImpl(void* p, const unsigned char* first,\n                                    size_t size) {\n    T& state = *static_cast<T*>(p);\n    state = T::combine_contiguous(std::move(state), first, size);\n  }\n\n  template <typename T>\n  void Init(T* state) {\n    state_ = state;\n    combine_contiguous_ = &CombineContiguousImpl<T>;\n    run_combine_unordered_ = &RunCombineUnorderedImpl<T>;\n  }\n\n  template <typename HS>\n  struct CombineUnorderedInvoker {\n    template <typename T, typename ConsumerT>\n    void operator()(T inner_state, ConsumerT inner_cb) {\n      f(HashState::Create(&inner_state),\n        [&](HashState& inner_erased) { inner_cb(inner_erased.Real<T>()); });\n    }\n\n    absl::FunctionRef<void(HS, absl::FunctionRef<void(HS&)>)> f;\n  };\n\n  template <typename T>\n  static HashState RunCombineUnorderedImpl(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>\n          f) {\n    // Note that this implementation assumes that inner_state and outer_state\n    // are the same type.  This isn't true in the SpyHash case, but SpyHash\n    // types are move-convertible to each other, so this still works.\n    T& real_state = state.Real<T>();\n    real_state = T::RunCombineUnordered(\n        std::move(real_state), CombineUnorderedInvoker<HashState>{f});\n    return state;\n  }\n\n  template <typename CombinerT>\n  static HashState RunCombineUnordered(HashState state, CombinerT combiner) {\n    auto* run = state.run_combine_unordered_;\n    return run(std::move(state), std::ref(combiner));\n  }\n\n  // Do not erase an already erased state.\n  void Init(HashState* state) {\n    state_ = state->state_;\n    combine_contiguous_ = state->combine_contiguous_;\n    run_combine_unordered_ = state->run_combine_unordered_;\n  }\n\n  template <typename T>\n  T& Real() {\n    return *static_cast<T*>(state_);\n  }\n\n  void* state_;\n  void (*combine_contiguous_)(void*, const unsigned char*, size_t);\n  HashState (*run_combine_unordered_)(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>);\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03639",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/hash.h",
  "source_line": 234,
  "validation_status": "validated"
}