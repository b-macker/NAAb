{
  "code": "{\n private:\n  using unsigned_type =\n      typename random_internal::make_unsigned_bits<IntType>::type;\n\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = uniform_int_distribution;\n\n    explicit param_type(\n        result_type lo = 0,\n        result_type hi = (std::numeric_limits<result_type>::max)())\n        : lo_(lo),\n          range_(static_cast<unsigned_type>(hi) -\n                 static_cast<unsigned_type>(lo)) {\n      // [rand.dist.uni.int] precondition 2\n      assert(lo <= hi);\n    }\n\n    result_type a() const { return lo_; }\n    result_type b() const {\n      return static_cast<result_type>(static_cast<unsigned_type>(lo_) + range_);\n    }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.lo_ == b.lo_ && a.range_ == b.range_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class uniform_int_distribution;\n    unsigned_type range() const { return range_; }\n\n    result_type lo_;\n    unsigned_type range_;\n\n    static_assert(random_internal::IsIntegral<result_type>::value,\n                  \"Class-template absl::uniform_int_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };  // param_type\n\n  uniform_int_distribution() : uniform_int_distribution(0) {}\n\n  explicit uniform_int_distribution(\n      result_type lo,\n      result_type hi = (std::numeric_limits<result_type>::max)())\n      : param_(lo, hi) {}\n\n  explicit uniform_int_distribution(const param_type& param) : param_(param) {}\n\n  // uniform_int_distribution<T>::reset()\n  //\n  // Resets the uniform int distribution. Note that this function has no effect\n  // because the distribution already produces independent values.\n  void reset() {}\n\n  template <typename URBG>\n  result_type operator()(URBG& gen) {  // NOLINT(runtime/references)\n    return (*this)(gen, param());\n  }\n\n  template <typename URBG>\n  result_type operator()(\n      URBG& gen, const param_type& param) {  // NOLINT(runtime/references)\n    return static_cast<result_type>(param.a() + Generate(gen, param.range()));\n  }\n\n  result_type a() const { return param_.a(); }\n  result_type b() const { return param_.b(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& params) { param_ = params; }\n\n  result_type(min)() const { return a(); }\n  result_type(max)() const { return b(); }\n\n  friend bool operator==(const uniform_int_distribution& a,\n                         const uniform_int_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const uniform_int_distribution& a,\n                         const uniform_int_distribution& b) {\n    return !(a == b);\n  }\n\n private:\n  // Generates a value in the *closed* interval [0, R]\n  template <typename URBG>\n  unsigned_type Generate(URBG& g,  // NOLINT(runtime/references)\n                         unsigned_type R);\n  param_type param_;\n}",
  "id": "BLOCK-CPP-03910",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/uniform_int_distribution.h",
  "source_line": 57,
  "validation_status": "validated"
}