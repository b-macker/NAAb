{
  "code": "{\n  using super = typename Traits::AggregateBuilderBase;\npublic:\n  using InitBuilder = typename Traits::InitBuilder;\n  using ArrayBuilder = typename Traits::ArrayBuilder;\n  using StructBuilder = typename Traits::StructBuilder;\n  using AggregateBuilderBase = typename Traits::AggregateBuilderBase;\n\nprotected:\n  ConstantAggregateBuilderTemplateBase(InitBuilder &builder,\n                                       AggregateBuilderBase *parent)\n    : super(builder, parent) {}\n\n  Impl &asImpl() { return *static_cast<Impl*>(this); }\n\npublic:\n  ArrayBuilder beginArray(llvm::Type *eltTy = nullptr) {\n    return ArrayBuilder(static_cast<InitBuilder&>(this->Builder), this, eltTy);\n  }\n\n  StructBuilder beginStruct(llvm::StructType *ty = nullptr) {\n    return StructBuilder(static_cast<InitBuilder&>(this->Builder), this, ty);\n  }\n\n  /// Given that this builder was created by beginning an array or struct\n  /// component on the given parent builder, finish the array/struct\n  /// component and add it to the parent.\n  ///\n  /// It is an intentional choice that the parent is passed in explicitly\n  /// despite it being redundant with information already kept in the\n  /// builder.  This aids in readability by making it easier to find the\n  /// places that add components to a builder, as well as \"bookending\"\n  /// the sub-builder more explicitly.\n  void finishAndAddTo(AggregateBuilderBase &parent) {\n    assert(this->Parent == &parent && \"adding to non-parent builder\");\n    parent.add(asImpl().finishImpl());\n  }\n\n  /// Given that this builder was created by beginning an array or struct\n  /// directly on a ConstantInitBuilder, finish the array/struct and\n  /// create a global variable with it as the initializer.\n  template <class... As>\n  llvm::GlobalVariable *finishAndCreateGlobal(As &&...args) {\n    assert(!this->Parent && \"finishing non-root builder\");\n    return this->Builder.createGlobal(asImpl().finishImpl(),\n                                      std::forward<As>(args)...);\n  }\n\n  /// Given that this builder was created by beginning an array or struct\n  /// directly on a ConstantInitBuilder, finish the array/struct and\n  /// set it as the initializer of the given global variable.\n  void finishAndSetAsInitializer(llvm::GlobalVariable *global) {\n    assert(!this->Parent && \"finishing non-root builder\");\n    return this->Builder.setGlobalInitializer(global, asImpl().finishImpl());\n  }\n\n  /// Given that this builder was created by beginning an array or struct\n  /// directly on a ConstantInitBuilder, finish the array/struct and\n  /// return a future which can be used to install the initializer in\n  /// a global later.\n  ///\n  /// This is useful for allowing a finished initializer to passed to\n  /// an API which will build the global.  However, the \"future\" preserves\n  /// a dependency on the original builder; it is an error to pass it aside.\n  ConstantInitFuture finishAndCreateFuture() {\n    assert(!this->Parent && \"finishing non-root builder\");\n    return this->Builder.createFuture(asImpl().finishImpl());\n  }\n}",
  "id": "BLOCK-CPP-17578",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/ConstantInitBuilder.h",
  "source_line": 344,
  "validation_status": "validated"
}