{
  "code": "{\n  /// The list of template parameters\n  TemplateParameterList* TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The class template partial specialization from which this\n  /// class template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this class template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<ClassTemplatePartialSpecializationDecl *, 1, bool>\n      InstantiatedFromMember;\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &Context, TagKind TK,\n                                         DeclContext *DC,\n                                         SourceLocation StartLoc,\n                                         SourceLocation IdLoc,\n                                         TemplateParameterList *Params,\n                                         ClassTemplateDecl *SpecializedTemplate,\n                                         ArrayRef<TemplateArgument> Args,\n                               const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                               ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &C)\n    : ClassTemplateSpecializationDecl(C, ClassTemplatePartialSpecialization),\n      InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         TemplateParameterList *Params,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos,\n         QualType CanonInjectedType,\n         ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  static ClassTemplatePartialSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ClassTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplatePartialSpecializationDecl>(\n             static_cast<ClassTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// Retrieve the member class template partial specialization from\n  /// which this particular class template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n}",
  "id": "BLOCK-CPP-09365",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 2100,
  "validation_status": "validated"
}