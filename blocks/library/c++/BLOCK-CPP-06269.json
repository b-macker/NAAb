{
  "code": "{\n\n// This class is implicitly constructible from everything that absl::string_view\n// is implicitly constructible from, except for rvalue strings.  This means it\n// can be used as a function parameter in places where passing a temporary\n// string might cause memory lifetime issues.\nclass ConvertibleToStringView {\n public:\n  ConvertibleToStringView(const char* s)  // NOLINT(runtime/explicit)\n      : value_(s) {}\n  ConvertibleToStringView(char* s) : value_(s) {}  // NOLINT(runtime/explicit)\n  ConvertibleToStringView(absl::string_view s)     // NOLINT(runtime/explicit)\n      : value_(s) {}\n  ConvertibleToStringView(const std::string& s)  // NOLINT(runtime/explicit)\n      : value_(s) {}\n\n  // Disable conversion from rvalue strings.\n  ConvertibleToStringView(std::string&& s) = delete;\n  ConvertibleToStringView(const std::string&& s) = delete;\n\n  absl::string_view value() const { return value_; }\n\n private:\n  absl::string_view value_;\n};\n\n// An iterator that enumerates the parts of a string from a Splitter. The text\n// to be split, the Delimiter, and the Predicate are all taken from the given\n// Splitter object. Iterators may only be compared if they refer to the same\n// Splitter instance.\n//\n// This class is NOT part of the public splitting API.\ntemplate <typename Splitter>\nclass SplitIterator {\n public:\n  using iterator_category = std::input_iterator_tag;\n  using value_type = absl::string_view;\n  using difference_type = ptrdiff_t;\n  using pointer = const value_type*;\n  using reference = const value_type&;\n\n  enum State { kInitState, kLastState, kEndState };\n  SplitIterator(State state, const Splitter* splitter)\n      : pos_(0),\n        state_(state),\n        splitter_(splitter),\n        delimiter_(splitter->delimiter()),\n        predicate_(splitter->predicate()) {\n    // Hack to maintain backward compatibility. This one block makes it so an\n    // empty absl::string_view whose .data() happens to be nullptr behaves\n    // *differently* from an otherwise empty absl::string_view whose .data() is\n    // not nullptr. This is an undesirable difference in general, but this\n    // behavior is maintained to avoid breaking existing code that happens to\n    // depend on this old behavior/bug. Perhaps it will be fixed one day. The\n    // difference in behavior is as follows:\n    //   Split(absl::string_view(\"\"), '-');  // {\"\"}\n    //   Split(absl::string_view(), '-');    // {}\n    if (splitter_->text().data() == nullptr) {\n      state_ = kEndState;\n      pos_ = splitter_->text().size();\n      return;\n    }\n\n    if (state_ == kEndState) {\n      pos_ = splitter_->text().size();\n    } else {\n      ++(*this);\n    }\n  }\n\n  bool at_end() const { return state_ == kEndState; }\n\n  reference operator*() const { return curr_; }\n  pointer operator->() const { return &curr_; }\n\n  SplitIterator& operator++() {\n    do {\n      if (state_ == kLastState) {\n        state_ = kEndState;\n        return *this;\n      }\n      const absl::string_view text = splitter_->text();\n      const absl::string_view d = delimiter_.Find(text, pos_);\n      if (d.data() == text.data() + text.size()) state_ = kLastState;\n      curr_ = text.substr(pos_,\n                          static_cast<size_t>(d.data() - (text.data() + pos_)));\n      pos_ += curr_.size() + d.size();\n    } while (!predicate_(curr_));\n    return *this;\n  }\n\n  SplitIterator operator++(int) {\n    SplitIterator old(*this);\n    ++(*this);\n    return old;\n  }\n\n  friend bool operator==(const SplitIterator& a, const SplitIterator& b) {\n    return a.state_ == b.state_ && a.pos_ == b.pos_;\n  }\n\n  friend bool operator!=(const SplitIterator& a, const SplitIterator& b) {\n    return !(a == b);\n  }\n\n private:\n  size_t pos_;\n  State state_;\n  absl::string_view curr_;\n  const Splitter* splitter_;\n  typename Splitter::DelimiterType delimiter_;\n  typename Splitter::PredicateType predicate_;\n};\n\n// HasMappedType<T>::value is true iff there exists a type T::mapped_type.\ntemplate <typename T, typename = void>\nstruct HasMappedType : std::false_type {};\ntemplate <typename T>\nstruct HasMappedType<T, absl::void_t<typename T::mapped_type>>\n    : std::true_type {};\n\n// HasValueType<T>::value is true iff there exists a type T::value_type.\ntemplate <typename T, typename = void>\nstruct HasValueType : std::false_type {};\ntemplate <typename T>\nstruct HasValueType<T, absl::void_t<typename T::value_type>> : std::true_type {\n};\n\n// HasConstIterator<T>::value is true iff there exists a type T::const_iterator.\ntemplate <typename T, typename = void>\nstruct HasConstIterator : std::false_type {};\ntemplate <typename T>\nstruct HasConstIterator<T, absl::void_t<typename T::const_iterator>>\n    : std::true_type {};\n\n// HasEmplace<T>::value is true iff there exists a method T::emplace().\ntemplate <typename T, typename = void>\nstruct HasEmplace : std::false_type {};\ntemplate <typename T>\nstruct HasEmplace<T, absl::void_t<decltype(std::declval<T>().emplace())>>\n    : std::true_type {};\n\n// IsInitializerList<T>::value is true iff T is an std::initializer_list. More\n// details below in Splitter<> where this is used.\nstd::false_type IsInitializerListDispatch(...);  // default: No\ntemplate <typename T>\nstd::true_type IsInitializerListDispatch(std::initializer_list<T>*);\ntemplate <typename T>\nstruct IsInitializerList\n    : decltype(IsInitializerListDispatch(static_cast<T*>(nullptr))) {};\n\n// A SplitterIsConvertibleTo<C>::type alias exists iff the specified condition\n// is true for type 'C'.\n//\n// Restricts conversion to container-like types (by testing for the presence of\n// a const_iterator member type) and also to disable conversion to an\n// std::initializer_list (which also has a const_iterator). Otherwise, code\n// compiled in C++11 will get an error due to ambiguous conversion paths (in\n// C++11 std::vector<T>::operator= is overloaded to take either a std::vector<T>\n// or an std::initializer_list<T>).\n\ntemplate <typename C, bool has_value_type, bool has_mapped_type>\nstruct SplitterIsConvertibleToImpl : std::false_type {};\n\ntemplate <typename C>\nstruct SplitterIsConvertibleToImpl<C, true, false>\n    : std::is_constructible<typename C::value_type, absl::string_view> {};\n\ntemplate <typename C>\nstruct SplitterIsConvertibleToImpl<C, true, true>\n    : absl::conjunction<\n          std::is_constructible<typename C::key_type, absl::string_view>,\n          std::is_constructible<typename C::mapped_type, absl::string_view>> {};\n\ntemplate <typename C>\nstruct SplitterIsConvertibleTo\n    : SplitterIsConvertibleToImpl<\n          C,\n#ifdef _GLIBCXX_DEBUG\n          !IsStrictlyBaseOfAndConvertibleToSTLContainer<C>::value &&\n#endif  // _GLIBCXX_DEBUG\n              !IsInitializerList<\n                  typename std::remove_reference<C>::type>::value &&\n              HasValueType<C>::value && HasConstIterator<C>::value,\n          HasMappedType<C>::value> {\n};\n\ntemplate <typename StringType, typename Container, typename = void>\nstruct ShouldUseLifetimeBound : std::false_type {};\n\ntemplate <typename StringType, typename Container>\nstruct ShouldUseLifetimeBound<\n    StringType, Container,\n    std::enable_if_t<\n        std::is_same<StringType, std::string>::value &&\n        std::is_same<typename Container::value_type, absl::string_view>::value>>\n    : std::true_type {};\n\ntemplate <typename StringType, typename First, typename Second>\nusing ShouldUseLifetimeBoundForPair = std::integral_constant<\n    bool, std::is_same<StringType, std::string>::value &&\n              (std::is_same<First, absl::string_view>::value ||\n               std::is_same<Second, absl::string_view>::value)>;\n\n\n// This class implements the range that is returned by absl::StrSplit(). This\n// class has templated conversion operators that allow it to be implicitly\n// converted to a variety of types that the caller may have specified on the\n// left-hand side of an assignment.\n//\n// The main interface for interacting with this class is through its implicit\n// conversion operators. However, this class may also be used like a container\n// in that it has .begin() and .end() member functions. It may also be used\n// within a range-for loop.\n//\n// Output containers can be collections of any type that is constructible from\n// an absl::string_view.\n//\n// An Predicate functor may be supplied. This predicate will be used to filter\n// the split strings: only strings for which the predicate returns true will be\n// kept. A Predicate object is any unary functor that takes an absl::string_view\n// and returns bool.\n//\n// The StringType parameter can be either string_view or string, depending on\n// whether the Splitter refers to a string stored elsewhere, or if the string\n// resides inside the Splitter itself.\ntemplate <typename Delimiter, typename Predicate, typename StringType>\nclass Splitter {\n public:\n  using DelimiterType = Delimiter;\n  using PredicateType = Predicate;\n  using const_iterator = strings_internal::SplitIterator<Splitter>;\n  using value_type = typename std::iterator_traits<const_iterator>::value_type;\n\n  Splitter(StringType input_text, Delimiter d, Predicate p)\n      : text_(std::move(input_text)),\n        delimiter_(std::move(d)),\n        predicate_(std::move(p)) {}\n\n  absl::string_view text() const { return text_; }\n  const Delimiter& delimiter() const { return delimiter_; }\n  const Predicate& predicate() const { return predicate_; }\n\n  // Range functions that iterate the split substrings as absl::string_view\n  // objects. These methods enable a Splitter to be used in a range-based for\n  // loop.\n  const_iterator begin() const { return {const_iterator::kInitState, this}; }\n  const_iterator end() const { return {const_iterator::kEndState, this}; }\n\n  // An implicit conversion operator that is restricted to only those containers\n  // that the splitter is convertible to.\n  template <\n      typename Container,\n      std::enable_if_t<ShouldUseLifetimeBound<StringType, Container>::value &&\n                           SplitterIsConvertibleTo<Container>::value,\n                       std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator Container() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ConvertToContainer<Container, typename Container::value_type,\n                              HasMappedType<Container>::value>()(*this);\n  }\n\n  template <\n      typename Container,\n      std::enable_if_t<!ShouldUseLifetimeBound<StringType, Container>::value &&\n                           SplitterIsConvertibleTo<Container>::value,\n                       std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator Container() const {\n    return ConvertToContainer<Container, typename Container::value_type,\n                              HasMappedType<Container>::value>()(*this);\n  }\n\n  // Returns a pair with its .first and .second members set to the first two\n  // strings returned by the begin() iterator. Either/both of .first and .second\n  // will be constructed with empty strings if the iterator doesn't have a\n  // corresponding value.\n  template <typename First, typename Second,\n            std::enable_if_t<\n                ShouldUseLifetimeBoundForPair<StringType, First, Second>::value,\n                std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator std::pair<First, Second>() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ConvertToPair<First, Second>();\n  }\n\n  template <typename First, typename Second,\n            std::enable_if_t<!ShouldUseLifetimeBoundForPair<StringType, First,\n                                                            Second>::value,\n                             std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator std::pair<First, Second>() const {\n    return ConvertToPair<First, Second>();\n  }\n\n private:\n  template <typename First, typename Second>\n  std::pair<First, Second> ConvertToPair() const {\n    absl::string_view first, second;\n    auto it = begin();\n    if (it != end()) {\n      first = *it;\n      if (++it != end()) {\n        second = *it;\n      }\n    }\n    return {First(first), Second(second)};\n  }\n\n  // ConvertToContainer is a functor converting a Splitter to the requested\n  // Container of ValueType. It is specialized below to optimize splitting to\n  // certain combinations of Container and ValueType.\n  //\n  // This base template handles the generic case of storing the split results in\n  // the requested non-map-like container and converting the split substrings to\n  // the requested type.\n  template <typename Container, typename ValueType, bool is_map = false>\n  struct ConvertToContainer {\n    Container operator()(const Splitter& splitter) const {\n      Container c;\n      auto it = std::inserter(c, c.end());\n      for (const auto& sp : splitter) {\n        *it++ = ValueType(sp);\n      }\n      return c;\n    }\n  };\n\n  // Partial specialization for a std::vector<absl::string_view>.\n  //\n  // Optimized for the common case of splitting to a\n  // std::vector<absl::string_view>. In this case we first split the results to\n  // a small array of absl::string_view on the stack, to reduce reallocations.\n  template <typename A>\n  struct ConvertToContainer<std::vector<absl::string_view, A>,\n                            absl::string_view, false> {\n    std::vector<absl::string_view, A> operator()(\n        const Splitter& splitter) const {\n      struct raw_view {\n        const char* data;\n        size_t size;\n        operator absl::string_view() const {  // NOLINT(runtime/explicit)\n          return {data, size};\n        }\n      };\n      std::vector<absl::string_view, A> v;\n      std::array<raw_view, 16> ar;\n      for (auto it = splitter.begin(); !it.at_end();) {\n        size_t index = 0;\n        do {\n          ar[index].data = it->data();\n          ar[index].size = it->size();\n          ++it;\n        } while (++index != ar.size() && !it.at_end());\n        v.insert(v.end(), ar.begin(), ar.begin() + index);\n      }\n      return v;\n    }\n  };\n\n  // Partial specialization for a std::vector<std::string>.\n  //\n  // Optimized for the common case of splitting to a std::vector<std::string>.\n  // In this case we first split the results to a std::vector<absl::string_view>\n  // so the returned std::vector<std::string> can have space reserved to avoid\n  // std::string moves.\n  template <typename A>\n  struct ConvertToContainer<std::vector<std::string, A>, std::string, false> {\n    std::vector<std::string, A> operator()(const Splitter& splitter) const {\n      const std::vector<absl::string_view> v = splitter;\n      return std::vector<std::string, A>(v.begin(), v.end());\n    }\n  };\n\n  // Partial specialization for containers of pairs (e.g., maps).\n  //\n  // The algorithm is to insert a new pair into the map for each even-numbered\n  // item, with the even-numbered item as the key with a default-constructed\n  // value. Each odd-numbered item will then be assigned to the last pair's\n  // value.\n  template <typename Container, typename First, typename Second>\n  struct ConvertToContainer<Container, std::pair<const First, Second>, true> {\n    using iterator = typename Container::iterator;\n\n    Container operator()(const Splitter& splitter) const {\n      Container m;\n      iterator it;\n      bool insert = true;\n      for (const absl::string_view sv : splitter) {\n        if (insert) {\n          it = InsertOrEmplace(&m, sv);\n        } else {\n          it->second = Second(sv);\n        }\n        insert = !insert;\n      }\n      return m;\n    }\n\n    // Inserts the key and an empty value into the map, returning an iterator to\n    // the inserted item. We use emplace() if available, otherwise insert().\n    template <typename M>\n    static absl::enable_if_t<HasEmplace<M>::value, iterator> InsertOrEmplace(\n        M* m, absl::string_view key) {\n      // Use piecewise_construct to support old versions of gcc in which pair\n      // constructor can't otherwise construct string from string_view.\n      return ToIter(m->emplace(std::piecewise_construct, std::make_tuple(key),\n                               std::tuple<>()));\n    }\n    template <typename M>\n    static absl::enable_if_t<!HasEmplace<M>::value, iterator> InsertOrEmplace(\n        M* m, absl::string_view key) {\n      return ToIter(m->insert(std::make_pair(First(key), Second(\"\"))));\n    }\n\n    static iterator ToIter(std::pair<iterator, bool> pair) {\n      return pair.first;\n    }\n    static iterator ToIter(iterator iter) { return iter; }\n  };\n\n  StringType text_;\n  Delimiter delimiter_;\n  Predicate predicate_;\n};\n\n}",
  "id": "BLOCK-CPP-06269",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_split_internal.h",
  "source_line": 51,
  "validation_status": "validated"
}