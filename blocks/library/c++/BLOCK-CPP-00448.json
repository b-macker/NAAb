{
  "code": "{\nnamespace sinks {\ntemplate <typename Mutex>\nclass qt_sink : public base_sink<Mutex> {\npublic:\n    qt_sink(QObject *qt_object, std::string meta_method)\n        : qt_object_(qt_object),\n          meta_method_(std::move(meta_method)) {\n        if (!qt_object_) {\n            throw_spdlog_ex(\"qt_sink: qt_object is null\");\n        }\n    }\n\n    ~qt_sink() { flush_(); }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        memory_buf_t formatted;\n        base_sink<Mutex>::formatter_->format(msg, formatted);\n        const string_view_t str = string_view_t(formatted.data(), formatted.size());\n        QMetaObject::invokeMethod(\n            qt_object_, meta_method_.c_str(), Qt::AutoConnection,\n            Q_ARG(QString, QString::fromUtf8(str.data(), static_cast<int>(str.size())).trimmed()));\n    }\n\n    void flush_() override {}\n\nprivate:\n    QObject *qt_object_ = nullptr;\n    std::string meta_method_;\n};\n\n// QT color sink to QTextEdit.\n// Color location is determined by the sink log pattern like in the rest of spdlog sinks.\n// Colors can be modified if needed using sink->set_color(level, qtTextCharFormat).\n// max_lines is the maximum number of lines that the sink will hold before removing the oldest\n// lines. By default, only ascii (latin1) is supported by this sink. Set is_utf8 to true if utf8\n// support is needed.\ntemplate <typename Mutex>\nclass qt_color_sink : public base_sink<Mutex> {\npublic:\n    qt_color_sink(QTextEdit *qt_text_edit,\n                  int max_lines,\n                  bool dark_colors = false,\n                  bool is_utf8 = false)\n        : qt_text_edit_(qt_text_edit),\n          max_lines_(max_lines),\n          is_utf8_(is_utf8) {\n        if (!qt_text_edit_) {\n            throw_spdlog_ex(\"qt_color_text_sink: text_edit is null\");\n        }\n\n        default_color_ = qt_text_edit_->currentCharFormat();\n        // set colors\n        QTextCharFormat format;\n        // trace\n        format.setForeground(dark_colors ? Qt::darkGray : Qt::gray);\n        colors_.at(level::trace) = format;\n        // debug\n        format.setForeground(dark_colors ? Qt::darkCyan : Qt::cyan);\n        colors_.at(level::debug) = format;\n        // info\n        format.setForeground(dark_colors ? Qt::darkGreen : Qt::green);\n        colors_.at(level::info) = format;\n        // warn\n        format.setForeground(dark_colors ? Qt::darkYellow : Qt::yellow);\n        colors_.at(level::warn) = format;\n        // err\n        format.setForeground(Qt::red);\n        colors_.at(level::err) = format;\n        // critical\n        format.setForeground(Qt::white);\n        format.setBackground(Qt::red);\n        colors_.at(level::critical) = format;\n    }\n\n    ~qt_color_sink() { flush_(); }\n\n    void set_default_color(QTextCharFormat format) {\n        // std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        default_color_ = format;\n    }\n\n    void set_level_color(level::level_enum color_level, QTextCharFormat format) {\n        // std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        colors_.at(static_cast<size_t>(color_level)) = format;\n    }\n\n    QTextCharFormat &get_level_color(level::level_enum color_level) {\n        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        return colors_.at(static_cast<size_t>(color_level));\n    }\n\n    QTextCharFormat &get_default_color() {\n        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        return default_color_;\n    }\n\nprotected:\n    struct invoke_params {\n        invoke_params(int max_lines,\n                      QTextEdit *q_text_edit,\n                      QString payload,\n                      QTextCharFormat default_color,\n                      QTextCharFormat level_color,\n                      int color_range_start,\n                      int color_range_end)\n            : max_lines(max_lines),\n              q_text_edit(q_text_edit),\n              payload(std::move(payload)),\n              default_color(default_color),\n              level_color(level_color),\n              color_range_start(color_range_start),\n              color_range_end(color_range_end) {}\n        int max_lines;\n        QTextEdit *q_text_edit;\n        QString payload;\n        QTextCharFormat default_color;\n        QTextCharFormat level_color;\n        int color_range_start;\n        int color_range_end;\n    };\n\n    void sink_it_(const details::log_msg &msg) override {\n        memory_buf_t formatted;\n        base_sink<Mutex>::formatter_->format(msg, formatted);\n\n        const string_view_t str = string_view_t(formatted.data(), formatted.size());\n        // apply the color to the color range in the formatted message.\n        QString payload;\n        int color_range_start = static_cast<int>(msg.color_range_start);\n        int color_range_end = static_cast<int>(msg.color_range_end);\n        if (is_utf8_) {\n            payload = QString::fromUtf8(str.data(), static_cast<int>(str.size()));\n            // convert color ranges from byte index to character index.\n            if (msg.color_range_start < msg.color_range_end) {\n                color_range_start = QString::fromUtf8(str.data(), msg.color_range_start).size();\n                color_range_end = QString::fromUtf8(str.data(), msg.color_range_end).size();\n            }\n        } else {\n            payload = QString::fromLatin1(str.data(), static_cast<int>(str.size()));\n        }\n\n        invoke_params params{max_lines_,             // max lines\n                             qt_text_edit_,          // text edit to append to\n                             std::move(payload),     // text to append\n                             default_color_,         // default color\n                             colors_.at(msg.level),  // color to apply\n                             color_range_start,      // color range start\n                             color_range_end};       // color range end\n\n        QMetaObject::invokeMethod(\n            qt_text_edit_, [params]() { invoke_method_(params); }, Qt::AutoConnection);\n    }\n\n    void flush_() override {}\n\n    // Add colored text to the text edit widget. This method is invoked in the GUI thread.\n    // It is a static method to ensure that it is handled correctly even if the sink is destroyed\n    // prematurely before it is invoked.\n\n    static void invoke_method_(invoke_params params) {\n        auto *document = params.q_text_edit->document();\n        QTextCursor cursor(document);\n\n        // remove first blocks if number of blocks exceeds max_lines\n        while (document->blockCount() > params.max_lines) {\n            cursor.select(QTextCursor::BlockUnderCursor);\n            cursor.removeSelectedText();\n            cursor.deleteChar();  // delete the newline after the block\n        }\n\n        cursor.movePosition(QTextCursor::End);\n        cursor.setCharFormat(params.default_color);\n\n        // if color range not specified or not not valid, just append the text with default color\n        if (params.color_range_end <= params.color_range_start) {\n            cursor.insertText(params.payload);\n            return;\n        }\n\n        // insert the text before the color range\n        cursor.insertText(params.payload.left(params.color_range_start));\n\n        // insert the colorized text\n        cursor.setCharFormat(params.level_color);\n        cursor.insertText(params.payload.mid(params.color_range_start,\n                                             params.color_range_end - params.color_range_start));\n\n        // insert the text after the color range with default format\n        cursor.setCharFormat(params.default_color);\n        cursor.insertText(params.payload.mid(params.color_range_end));\n    }\n\n    QTextEdit *qt_text_edit_;\n    int max_lines_;\n    bool is_utf8_;\n    QTextCharFormat default_color_;\n    std::array<QTextCharFormat, level::n_levels> colors_;\n};\n\n#include \"spdlog/details/null_mutex.h\"\n#include <mutex>\n\nusing qt_sink_mt = qt_sink<std::mutex>;\nusing qt_sink_st = qt_sink<details::null_mutex>;\nusing qt_color_sink_mt = qt_color_sink<std::mutex>;\nusing qt_color_sink_st = qt_color_sink<details::null_mutex>;\n}  // namespace sinks\n\n//\n// Factory functions\n//\n\n// log to QTextEdit\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_mt(const std::string &logger_name,\n                                            QTextEdit *qt_object,\n                                            const std::string &meta_method = \"append\") {\n    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_st(const std::string &logger_name,\n                                            QTextEdit *qt_object,\n                                            const std::string &meta_method = \"append\") {\n    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);\n}\n\n// log to QPlainTextEdit\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_mt(const std::string &logger_name,\n                                            QPlainTextEdit *qt_object,\n                                            const std::string &meta_method = \"appendPlainText\") {\n    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_st(const std::string &logger_name,\n                                            QPlainTextEdit *qt_object,\n                                            const std::string &meta_method = \"appendPlainText\") {\n    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);\n}\n// log to QObject\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_mt(const std::string &logger_name,\n                                            QObject *qt_object,\n                                            const std::string &meta_method) {\n    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_logger_st(const std::string &logger_name,\n                                            QObject *qt_object,\n                                            const std::string &meta_method) {\n    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);\n}\n\n// log to QTextEdit with colorize output\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_color_logger_mt(const std::string &logger_name,\n                                                  QTextEdit *qt_text_edit,\n                                                  int max_lines,\n                                                  bool is_utf8 = false) {\n    return Factory::template create<sinks::qt_color_sink_mt>(logger_name, qt_text_edit, max_lines,\n                                                             false, is_utf8);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> qt_color_logger_st(const std::string &logger_name,\n                                                  QTextEdit *qt_text_edit,\n                                                  int max_lines,\n                                                  bool is_utf8 = false) {\n    return Factory::template create<sinks::qt_color_sink_st>(logger_name, qt_text_edit, max_lines,\n                                                             false, is_utf8);\n}\n\n}",
  "id": "BLOCK-CPP-00448",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/qt_sinks.h",
  "source_line": 27,
  "validation_status": "validated"
}