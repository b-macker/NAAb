{
  "code": "{\n  // The index of the next lambda we encounter in this context.\n  unsigned LambdaIndex = 0;\n\npublic:\n  virtual ~MangleNumberingContext() {}\n\n  /// Retrieve the mangling number of a new lambda expression with the\n  /// given call operator within this context.\n  virtual unsigned getManglingNumber(const CXXMethodDecl *CallOperator) = 0;\n\n  /// Retrieve the mangling number of a new block literal within this\n  /// context.\n  virtual unsigned getManglingNumber(const BlockDecl *BD) = 0;\n\n  /// Static locals are numbered by source order.\n  virtual unsigned getStaticLocalNumber(const VarDecl *VD) = 0;\n\n  /// Retrieve the mangling number of a static local variable within\n  /// this context.\n  virtual unsigned getManglingNumber(const VarDecl *VD,\n                                     unsigned MSLocalManglingNumber) = 0;\n\n  /// Retrieve the mangling number of a static local variable within\n  /// this context.\n  virtual unsigned getManglingNumber(const TagDecl *TD,\n                                     unsigned MSLocalManglingNumber) = 0;\n\n  /// Retrieve the mangling number of a new lambda expression with the\n  /// given call operator within the device context. No device number is\n  /// assigned if there's no device numbering context is associated.\n  virtual unsigned getDeviceManglingNumber(const CXXMethodDecl *) { return 0; }\n\n  // Retrieve the index of the next lambda appearing in this context, which is\n  // used for deduplicating lambdas across modules. Note that this is a simple\n  // sequence number and is not ABI-dependent.\n  unsigned getNextLambdaIndex() { return LambdaIndex++; }\n}",
  "id": "BLOCK-CPP-11299",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/MangleNumberingContext.h",
  "source_line": 29,
  "validation_status": "validated"
}