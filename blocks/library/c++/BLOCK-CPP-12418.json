{
  "code": "{\nprotected:\n  class DeclLink {\n    /// A pointer to a known latest declaration, either statically known or\n    /// generationally updated as decls are added by an external source.\n    using KnownLatest =\n        LazyGenerationalUpdatePtr<const Decl *, Decl *,\n                                  &ExternalASTSource::CompleteRedeclChain>;\n\n    /// We store a pointer to the ASTContext in the UninitializedLatest\n    /// pointer, but to avoid circular type dependencies when we steal the low\n    /// bits of this pointer, we use a raw void* here.\n    using UninitializedLatest = const void *;\n\n    using Previous = Decl *;\n\n    /// A pointer to either an uninitialized latest declaration (where either\n    /// we've not yet set the previous decl or there isn't one), or to a known\n    /// previous declaration.\n    using NotKnownLatest = llvm::PointerUnion<Previous, UninitializedLatest>;\n\n    mutable llvm::PointerUnion<NotKnownLatest, KnownLatest> Link;\n\n  public:\n    enum PreviousTag { PreviousLink };\n    enum LatestTag { LatestLink };\n\n    DeclLink(LatestTag, const ASTContext &Ctx)\n        : Link(NotKnownLatest(reinterpret_cast<UninitializedLatest>(&Ctx))) {}\n    DeclLink(PreviousTag, decl_type *D) : Link(NotKnownLatest(Previous(D))) {}\n\n    bool isFirst() const {\n      return Link.is<KnownLatest>() ||\n             // FIXME: 'template' is required on the next line due to an\n             // apparent clang bug.\n             Link.get<NotKnownLatest>().template is<UninitializedLatest>();\n    }\n\n    decl_type *getPrevious(const decl_type *D) const {\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        if (NKL.is<Previous>())\n          return static_cast<decl_type*>(NKL.get<Previous>());\n\n        // Allocate the generational 'most recent' cache now, if needed.\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           const_cast<decl_type *>(D));\n      }\n\n      return static_cast<decl_type*>(Link.get<KnownLatest>().get(D));\n    }\n\n    void setPrevious(decl_type *D) {\n      assert(!isFirst() && \"decl became non-canonical unexpectedly\");\n      Link = Previous(D);\n    }\n\n    void setLatest(decl_type *D) {\n      assert(isFirst() && \"decl became canonical unexpectedly\");\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           D);\n      } else {\n        auto Latest = Link.get<KnownLatest>();\n        Latest.set(D);\n        Link = Latest;\n      }\n    }\n\n    void markIncomplete() { Link.get<KnownLatest>().markIncomplete(); }\n\n    Decl *getLatestNotUpdated() const {\n      assert(isFirst() && \"expected a canonical decl\");\n      if (Link.is<NotKnownLatest>())\n        return nullptr;\n      return Link.get<KnownLatest>().getNotUpdated();\n    }\n  };\n\n  static DeclLink PreviousDeclLink(decl_type *D) {\n    return DeclLink(DeclLink::PreviousLink, D);\n  }\n\n  static DeclLink LatestDeclLink(const ASTContext &Ctx) {\n    return DeclLink(DeclLink::LatestLink, Ctx);\n  }\n\n  /// Points to the next redeclaration in the chain.\n  ///\n  /// If isFirst() is false, this is a link to the previous declaration\n  /// of this same Decl. If isFirst() is true, this is the first\n  /// declaration and Link points to the latest declaration. For example:\n  ///\n  ///  #1 int f(int x, int y = 1); // <pointer to #3, true>\n  ///  #2 int f(int x = 0, int y); // <pointer to #1, false>\n  ///  #3 int f(int x, int y) { return x + y; } // <pointer to #2, false>\n  ///\n  /// If there is only one declaration, it is <pointer to self, true>\n  DeclLink RedeclLink;\n\n  decl_type *First;\n\n  decl_type *getNextRedeclaration() const {\n    return RedeclLink.getPrevious(static_cast<const decl_type *>(this));\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class IncrementalParser;\n\n  Redeclarable(const ASTContext &Ctx)\n      : RedeclLink(LatestDeclLink(Ctx)),\n        First(static_cast<decl_type *>(this)) {}\n\n  /// Return the previous declaration of this declaration or NULL if this\n  /// is the first declaration.\n  decl_type *getPreviousDecl() {\n    if (!RedeclLink.isFirst())\n      return getNextRedeclaration();\n    return nullptr;\n  }\n  const decl_type *getPreviousDecl() const {\n    return const_cast<decl_type *>(\n                 static_cast<const decl_type*>(this))->getPreviousDecl();\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() { return First; }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const { return First; }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const { return RedeclLink.isFirst(); }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  decl_type *getMostRecentDecl() {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  const decl_type *getMostRecentDecl() const {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Set the previous declaration. If PrevDecl is NULL, set this as the\n  /// first and only declaration.\n  void setPreviousDecl(decl_type *PrevDecl);\n\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    decl_type *Current = nullptr;\n    decl_type *Starter = nullptr;\n    bool PassedFirst = false;\n\n  public:\n    using value_type = decl_type *;\n    using reference = decl_type *;\n    using pointer = decl_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(decl_type *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Make sure we don't infinitely loop on an invalid redecl chain. This\n      // should never happen.\n      if (Current->isFirstDecl()) {\n        if (PassedFirst) {\n          assert(0 && \"Passed first decl twice, invalid redecl chain!\");\n          Current = nullptr;\n          return *this;\n        }\n        PassedFirst = true;\n      }\n\n      // Get either previous decl or latest decl.\n      decl_type *Next = Current->getNextRedeclaration();\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecl_iterator(const_cast<decl_type *>(\n                            static_cast<const decl_type *>(this))),\n                        redecl_iterator());\n  }\n\n  redecl_iterator redecls_begin() const { return redecls().begin(); }\n  redecl_iterator redecls_end() const { return redecls().end(); }\n}",
  "id": "BLOCK-CPP-12418",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Redeclarable.h",
  "source_line": 83,
  "validation_status": "validated"
}