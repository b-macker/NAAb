{
  "code": "{\n//     absl::Cord cord;\n//     while (length > 0) {\n//       CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(length);\n//       absl::Span<char> data = buffer.available_up_to(length);\n//       FillRandomValues(data.data(), data.size());\n//       buffer.IncreaseLengthBy(data.size());\n//       cord.Append(std::move(buffer));\n//       length -= data.size();\n//     }\n//     return cord;\n//   }\n//\n// CordBuffer instances are by default limited to a capacity of `kDefaultLimit`\n// bytes. `kDefaultLimit` is currently just under 4KiB, but this default may\n// change in the future and/or for specific architectures. The default limit is\n// aimed to provide a good trade-off between performance and memory overhead.\n// Smaller buffers typically incur more compute cost while larger buffers are\n// more CPU efficient but create significant memory overhead because of such\n// allocations being less granular. Using larger buffers may also increase the\n// risk of memory fragmentation.\n//\n// Applications create a buffer using one of the `CreateWithDefaultLimit()` or\n// `CreateWithCustomLimit()` methods. The returned instance will have a non-zero\n// capacity and a zero length. Applications use the `data()` method to set the\n// contents of the managed memory, and once done filling the buffer, use the\n// `IncreaseLengthBy()` or 'SetLength()' method to specify the length of the\n// initialized data before adding the buffer to a Cord.\n//\n// The `CreateWithCustomLimit()` method is intended for applications needing\n// larger buffers than the default memory limit, allowing the allocation of up\n// to a capacity of `kCustomLimit` bytes minus some minimum internal overhead.\n// The usage of `CreateWithCustomLimit()` should be limited to only those use\n// cases where the distribution of the input is relatively well known, and/or\n// where the trade-off between the efficiency gains outweigh the risk of memory\n// fragmentation. See the documentation for `CreateWithCustomLimit()` for more\n// information on using larger custom limits.\n//\n// The capacity of a `CordBuffer` returned by one of the `Create` methods may\n// be larger than the requested capacity due to rounding, alignment and\n// granularity of the memory allocator. Applications should use the `capacity`\n// method to obtain the effective capacity of the returned instance as\n// demonstrated in the provided example above.\n//\n// CordBuffer is a move-only class. All references into the managed memory are\n// invalidated when an instance is moved into either another CordBuffer instance\n// or a Cord. Writing to a location obtained by a previous call to `data()`\n// after an instance was moved will lead to undefined behavior.\n//\n// A `moved from` CordBuffer instance will have a valid, but empty state.\n// CordBuffer is thread compatible.\nclass CordBuffer {\n public:\n  // kDefaultLimit\n  //\n  // Default capacity limits of allocated CordBuffers.\n  // See the class comments for more information on allocation limits.\n  static constexpr size_t kDefaultLimit = cord_internal::kMaxFlatLength;\n\n  // kCustomLimit\n  //\n  // Maximum size for CreateWithCustomLimit() allocated buffers.\n  // Note that the effective capacity may be slightly less\n  // because of internal overhead of internal cord buffers.\n  static constexpr size_t kCustomLimit = 64U << 10;\n\n  // Constructors, Destructors and Assignment Operators\n\n  // Creates an empty CordBuffer.\n  CordBuffer() = default;\n\n  // Destroys this CordBuffer instance and, if not empty, releases any memory\n  // managed by this instance, invalidating previously returned references.\n  ~CordBuffer();\n\n  // CordBuffer is move-only\n  CordBuffer(CordBuffer&& rhs) noexcept;\n  CordBuffer& operator=(CordBuffer&&) noexcept;\n  CordBuffer(const CordBuffer&) = delete;\n  CordBuffer& operator=(const CordBuffer&) = delete;\n\n  // CordBuffer::MaximumPayload()\n  //\n  // Returns the guaranteed maximum payload for a CordBuffer returned by the\n  // `CreateWithDefaultLimit()` method. While small, each internal buffer inside\n  // a Cord incurs an overhead to manage the length, type and reference count\n  // for the buffer managed inside the cord tree. Applications can use this\n  // method to get approximate number of buffers required for a given byte\n  // size, etc.\n  //\n  // For example:\n  //   const size_t payload = absl::CordBuffer::MaximumPayload();\n  //   const size_t buffer_count = (total_size + payload - 1) / payload;\n  //   buffers.reserve(buffer_count);\n  static constexpr size_t MaximumPayload();\n\n  // Overload to the above `MaximumPayload()` except that it returns the\n  // maximum payload for a CordBuffer returned by the `CreateWithCustomLimit()`\n  // method given the provided `block_size`.\n  static constexpr size_t MaximumPayload(size_t block_size);\n\n  // CordBuffer::CreateWithDefaultLimit()\n  //\n  // Creates a CordBuffer instance of the desired `capacity`, capped at the\n  // default limit `kDefaultLimit`. The returned buffer has a guaranteed\n  // capacity of at least `min(kDefaultLimit, capacity)`. See the class comments\n  // for more information on buffer capacities and intended usage.\n  static CordBuffer CreateWithDefaultLimit(size_t capacity);\n\n  // CordBuffer::CreateWithCustomLimit()\n  //\n  // Creates a CordBuffer instance of the desired `capacity` rounded to an\n  // appropriate power of 2 size less than, or equal to `block_size`.\n  // Requires `block_size` to be a power of 2.\n  //\n  // If `capacity` is less than or equal to `kDefaultLimit`, then this method\n  // behaves identical to `CreateWithDefaultLimit`, which means that the caller\n  // is guaranteed to get a buffer of at least the requested capacity.\n  //\n  // If `capacity` is greater than or equal to `block_size`, then this method\n  // returns a buffer with an `allocated size` of `block_size` bytes. Otherwise,\n  // this methods returns a buffer with a suitable smaller power of 2 block size\n  // to satisfy the request. The actual size depends on a number of factors, and\n  // is typically (but not necessarily) the highest or second highest power of 2\n  // value less than or equal to `capacity`.\n  //\n  // The 'allocated size' includes a small amount of overhead required for\n  // internal state, which is currently 13 bytes on 64-bit platforms. For\n  // example: a buffer created with `block_size` and `capacity' set to 8KiB\n  // will have an allocated size of 8KiB, and an effective internal `capacity`\n  // of 8KiB - 13 = 8179 bytes.\n  //\n  // To demonstrate this in practice, let's assume we want to read data from\n  // somewhat larger files using approximately 64KiB buffers:\n  //\n  //   absl::Cord ReadFromFile(int fd, size_t n) {\n  //     absl::Cord cord;\n  //     while (n > 0) {\n  //       CordBuffer buffer = CordBuffer::CreateWithCustomLimit(64 << 10, n);\n  //       absl::Span<char> data = buffer.available_up_to(n);\n  //       ReadFileDataOrDie(fd, data.data(), data.size());\n  //       buffer.IncreaseLengthBy(data.size());\n  //       cord.Append(std::move(buffer));\n  //       n -= data.size();\n  //     }\n  //     return cord;\n  //   }\n  //\n  // If we'd use this function to read a file of 659KiB, we may get the\n  // following pattern of allocated cord buffer sizes:\n  //\n  //   CreateWithCustomLimit(64KiB, 674816) --> ~64KiB (65523)\n  //   CreateWithCustomLimit(64KiB, 674816) --> ~64KiB (65523)\n  //   ...\n  //   CreateWithCustomLimit(64KiB,  19586) --> ~16KiB (16371)\n  //   CreateWithCustomLimit(64KiB,   3215) -->   3215 (at least 3215)\n  //\n  // The reason the method returns a 16K buffer instead of a roughly 19K buffer\n  // is to reduce memory overhead and fragmentation risks. Using carefully\n  // chosen power of 2 values reduces the entropy of allocated memory sizes.\n  //\n  // Additionally, let's assume we'd use the above function on files that are\n  // generally smaller than 64K. If we'd use 'precise' sized buffers for such\n  // files, than we'd get a very wide distribution of allocated memory sizes\n  // rounded to 4K page sizes, and we'd end up with a lot of unused capacity.\n  //\n  // In general, application should only use custom sizes if the data they are\n  // consuming or storing is expected to be many times the chosen block size,\n  // and be based on objective data and performance metrics. For example, a\n  // compress function may work faster and consume less CPU when using larger\n  // buffers. Such an application should pick a size offering a reasonable\n  // trade-off between expected data size, compute savings with larger buffers,\n  // and the cost or fragmentation effect of larger buffers.\n  // Applications must pick a reasonable spot on that curve, and make sure their\n  // data meets their expectations in size distributions such as \"mostly large\".\n  static CordBuffer CreateWithCustomLimit(size_t block_size, size_t capacity);\n\n  // CordBuffer::available()\n  //\n  // Returns the span delineating the available capacity in this buffer\n  // which is defined as `{ data() + length(), capacity() - length() }`.\n  absl::Span<char> available();\n\n  // CordBuffer::available_up_to()\n  //\n  // Returns the span delineating the available capacity in this buffer limited\n  // to `size` bytes. This is equivalent to `available().subspan(0, size)`.\n  absl::Span<char> available_up_to(size_t size);\n\n  // CordBuffer::data()\n  //\n  // Returns a non-null reference to the data managed by this instance.\n  // Applications are allowed to write up to `capacity` bytes of instance data.\n  // CordBuffer data is uninitialized by default. Reading data from an instance\n  // that has not yet been initialized will lead to undefined behavior.\n  char* data();\n  const char* data() const;\n\n  // CordBuffer::length()\n  //\n  // Returns the length of this instance. The default length of a CordBuffer is\n  // 0, indicating an 'empty' CordBuffer. Applications must specify the length\n  // of the data in a CordBuffer before adding it to a Cord.\n  size_t length() const;\n\n  // CordBuffer::capacity()\n  //\n  // Returns the capacity of this instance. All instances have a non-zero\n  // capacity: default and `moved from` instances have a small internal buffer.\n  size_t capacity() const;\n\n  // CordBuffer::IncreaseLengthBy()\n  //\n  // Increases the length of this buffer by the specified 'n' bytes.\n  // Applications must make sure all data in this buffer up to the new length\n  // has been initialized before adding a CordBuffer to a Cord: failure to do so\n  // will lead to undefined behavior.  Requires `length() + n <= capacity()`.\n  // Typically, applications will use 'available_up_to()` to get a span of the\n  // desired capacity, and use `span.size()` to increase the length as in:\n  //   absl::Span<char> span = buffer.available_up_to(desired);\n  //   buffer.IncreaseLengthBy(span.size());\n  //   memcpy(span.data(), src, span.size());\n  //   etc...\n  void IncreaseLengthBy(size_t n);\n\n  // CordBuffer::SetLength()\n  //\n  // Sets the data length of this instance. Applications must make sure all data\n  // of the specified length has been initialized before adding a CordBuffer to\n  // a Cord: failure to do so will lead to undefined behavior.\n  // Setting the length to a small value or zero does not release any memory\n  // held by this CordBuffer instance. Requires `length <= capacity()`.\n  // Applications should preferably use the `IncreaseLengthBy()` method above\n  // in combination with the 'available()` or `available_up_to()` methods.\n  void SetLength(size_t length);\n\n private:\n  // Make sure we don't accidentally over promise.\n  static_assert(kCustomLimit <= cord_internal::kMaxLargeFlatSize, \"\");\n\n  // Assume the cost of an 'uprounded' allocation to CeilPow2(size) versus\n  // the cost of allocating at least 1 extra flat <= 4KB:\n  // - Flat overhead = 13 bytes\n  // - Btree amortized cost / node =~ 13 bytes\n  // - 64 byte granularity of tcmalloc at 4K =~ 32 byte average\n  // CPU cost and efficiency requires we should at least 'save' something by\n  // splitting, as a poor man's measure, we say the slop needs to be\n  // at least double the cost offset to make it worth splitting: ~128 bytes.\n  static constexpr size_t kMaxPageSlop = 128;\n\n  // Overhead for allocation a flat.\n  static constexpr size_t kOverhead = cord_internal::kFlatOverhead;\n\n  using CordRepFlat = cord_internal::CordRepFlat;\n\n  // `Rep` is the internal data representation of a CordBuffer. The internal\n  // representation has an internal small size optimization similar to\n  // std::string (SSO).\n  struct Rep {\n    // Inline SSO size of a CordBuffer\n    static constexpr size_t kInlineCapacity = sizeof(intptr_t) * 2 - 1;\n\n    // Creates a default instance with kInlineCapacity.\n    Rep() : short_rep{} {}\n\n    // Creates an instance managing an allocated non zero CordRep.\n    explicit Rep(cord_internal::CordRepFlat* rep) : long_rep{rep} {\n      assert(rep != nullptr);\n    }\n\n    // Returns true if this instance manages the SSO internal buffer.\n    bool is_short() const {\n      constexpr size_t offset = offsetof(Short, raw_size);\n      return (reinterpret_cast<const char*>(this)[offset] & 1) != 0;\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> short_available() {\n      const size_t length = short_length();\n      return absl::Span<char>(short_rep.data + length,\n                              kInlineCapacity - length);\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> long_available() const {\n      assert(!is_short());\n      const size_t length = long_rep.rep->length;\n      return absl::Span<char>(long_rep.rep->Data() + length,\n                              long_rep.rep->Capacity() - length);\n    }\n\n    // Returns the length of the internal SSO data.\n    size_t short_length() const {\n      assert(is_short());\n      return static_cast<size_t>(short_rep.raw_size >> 1);\n    }\n\n    // Sets the length of the internal SSO data.\n    // Disregards any previously set CordRep instance.\n    void set_short_length(size_t length) {\n      short_rep.raw_size = static_cast<char>((length << 1) + 1);\n    }\n\n    // Adds `n` to the current short length.\n    void add_short_length(size_t n) {\n      assert(is_short());\n      short_rep.raw_size += static_cast<char>(n << 1);\n    }\n\n    // Returns reference to the internal SSO data buffer.\n    char* data() {\n      assert(is_short());\n      return short_rep.data;\n    }\n    const char* data() const {\n      assert(is_short());\n      return short_rep.data;\n    }\n\n    // Returns a pointer the external CordRep managed by this instance.\n    cord_internal::CordRepFlat* rep() const {\n      assert(!is_short());\n      return long_rep.rep;\n    }\n\n    // The internal representation takes advantage of the fact that allocated\n    // memory is always on an even address, and uses the least significant bit\n    // of the first or last byte (depending on endianness) as the inline size\n    // indicator overlapping with the least significant byte of the CordRep*.\n#if defined(ABSL_IS_BIG_ENDIAN)\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      void* padding;\n      cord_internal::CordRepFlat* rep;\n    };\n    struct Short {\n      char data[sizeof(Long) - 1];\n      char raw_size = 1;\n    };\n#else\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      cord_internal::CordRepFlat* rep;\n      void* padding;\n    };\n    struct Short {\n      char raw_size = 1;\n      char data[sizeof(Long) - 1];\n    };\n#endif\n\n    union {\n      Long long_rep;\n      Short short_rep;\n    };\n  };\n\n  // Power2 functions\n  static bool IsPow2(size_t size) { return absl::has_single_bit(size); }\n  static size_t Log2Floor(size_t size) {\n    return static_cast<size_t>(absl::bit_width(size) - 1);\n  }\n  static size_t Log2Ceil(size_t size) {\n    return static_cast<size_t>(absl::bit_width(size - 1));\n  }\n\n  // Implementation of `CreateWithCustomLimit()`.\n  // This implementation allows for future memory allocation hints to\n  // be passed down into the CordRepFlat allocation function.\n  template <typename... AllocationHints>\n  static CordBuffer CreateWithCustomLimitImpl(size_t block_size,\n                                              size_t capacity,\n                                              AllocationHints... hints);\n\n  // Consumes the value contained in this instance and resets the instance.\n  // This method returns a non-null Cordrep* if the current instances manages a\n  // CordRep*, and resets the instance to an empty SSO instance. If the current\n  // instance is an SSO instance, then this method returns nullptr and sets\n  // `short_value` to the inlined data value. In either case, the current\n  // instance length is reset to zero.\n  // This method is intended to be used by Cord internal functions only.\n  cord_internal::CordRep* ConsumeValue(absl::string_view& short_value) {\n    cord_internal::CordRep* rep = nullptr;\n    if (rep_.is_short()) {\n      short_value = absl::string_view(rep_.data(), rep_.short_length());\n    } else {\n      rep = rep_.rep();\n    }\n    rep_.set_short_length(0);\n    return rep;\n  }\n\n  // Internal constructor.\n  explicit CordBuffer(cord_internal::CordRepFlat* rep) : rep_(rep) {\n    assert(rep != nullptr);\n  }\n\n  Rep rep_;\n\n  friend class Cord;\n  friend class CordBufferTestPeer;\n};\n\ninline constexpr size_t CordBuffer::MaximumPayload() {\n  return cord_internal::kMaxFlatLength;\n}\n\ninline constexpr size_t CordBuffer::MaximumPayload(size_t block_size) {\n  return (std::min)(kCustomLimit, block_size) - cord_internal::kFlatOverhead;\n}\n\ninline CordBuffer CordBuffer::CreateWithDefaultLimit(size_t capacity) {\n  if (capacity > Rep::kInlineCapacity) {\n    auto* rep = cord_internal::CordRepFlat::New(capacity);\n    rep->length = 0;\n    return CordBuffer(rep);\n  }\n  return CordBuffer();\n}\n\ntemplate <typename... AllocationHints>\ninline CordBuffer CordBuffer::CreateWithCustomLimitImpl(\n    size_t block_size, size_t capacity, AllocationHints... hints) {\n  assert(IsPow2(block_size));\n  capacity = (std::min)(capacity, kCustomLimit);\n  block_size = (std::min)(block_size, kCustomLimit);\n  if (capacity + kOverhead >= block_size) {\n    capacity = block_size;\n  } else if (capacity <= kDefaultLimit) {\n    capacity = capacity + kOverhead;\n  } else if (!IsPow2(capacity)) {\n    // Check if rounded up to next power 2 is a good enough fit\n    // with limited waste making it an acceptable direct fit.\n    const size_t rounded_up = size_t{1} << Log2Ceil(capacity);\n    const size_t slop = rounded_up - capacity;\n    if (slop >= kOverhead && slop <= kMaxPageSlop + kOverhead) {\n      capacity = rounded_up;\n    } else {\n      // Round down to highest power of 2 <= capacity.\n      // Consider a more aggressive step down if that may reduce the\n      // risk of fragmentation where 'people are holding it wrong'.\n      const size_t rounded_down = size_t{1} << Log2Floor(capacity);\n      capacity = rounded_down;\n    }\n  }\n  const size_t length = capacity - kOverhead;\n  auto* rep = CordRepFlat::New(CordRepFlat::Large(), length, hints...);\n  rep->length = 0;\n  return CordBuffer(rep);\n}\n\ninline CordBuffer CordBuffer::CreateWithCustomLimit(size_t block_size,\n                                                    size_t capacity) {\n  return CreateWithCustomLimitImpl(block_size, capacity);\n}\n\ninline CordBuffer::~CordBuffer() {\n  if (!rep_.is_short()) {\n    cord_internal::CordRepFlat::Delete(rep_.rep());\n  }\n}\n\ninline CordBuffer::CordBuffer(CordBuffer&& rhs) noexcept : rep_(rhs.rep_) {\n  rhs.rep_.set_short_length(0);\n}\n\ninline CordBuffer& CordBuffer::operator=(CordBuffer&& rhs) noexcept {\n  if (!rep_.is_short()) cord_internal::CordRepFlat::Delete(rep_.rep());\n  rep_ = rhs.rep_;\n  rhs.rep_.set_short_length(0);\n  return *this;\n}\n\ninline absl::Span<char> CordBuffer::available() {\n  return rep_.is_short() ? rep_.short_available() : rep_.long_available();\n}\n\ninline absl::Span<char> CordBuffer::available_up_to(size_t size) {\n  return available().subspan(0, size);\n}\n\ninline char* CordBuffer::data() {\n  return rep_.is_short() ? rep_.data() : rep_.rep()->Data();\n}\n\ninline const char* CordBuffer::data() const {\n  return rep_.is_short() ? rep_.data() : rep_.rep()->Data();\n}\n\ninline size_t CordBuffer::capacity() const {\n  return rep_.is_short() ? Rep::kInlineCapacity : rep_.rep()->Capacity();\n}\n\ninline size_t CordBuffer::length() const {\n  return rep_.is_short() ? rep_.short_length() : rep_.rep()->length;\n}\n\ninline void CordBuffer::SetLength(size_t length) {\n  ABSL_HARDENING_ASSERT(length <= capacity());\n  if (rep_.is_short()) {\n    rep_.set_short_length(length);\n  } else {\n    rep_.rep()->length = length;\n  }\n}\n\ninline void CordBuffer::IncreaseLengthBy(size_t n) {\n  ABSL_HARDENING_ASSERT(n <= capacity() && length() + n <= capacity());\n  if (rep_.is_short()) {\n    rep_.add_short_length(n);\n  } else {\n    rep_.rep()->length += n;\n  }\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04054",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord_buffer.h",
  "source_line": 54,
  "validation_status": "validated"
}