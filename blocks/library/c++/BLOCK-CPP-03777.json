{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nclass int128;\n\n// uint128\n//\n// An unsigned 128-bit integer type. The API is meant to mimic an intrinsic type\n// as closely as is practical, including exhibiting undefined behavior in\n// analogous cases (e.g. division by zero). This type is intended to be a\n// drop-in replacement once C++ supports an intrinsic `uint128_t` type; when\n// that occurs, existing well-behaved uses of `uint128` will continue to work\n// using that new type.\n//\n// Note: code written with this type will continue to compile once `uint128_t`\n// is introduced, provided the replacement helper functions\n// `Uint128(Low|High)64()` and `MakeUint128()` are made.\n//\n// A `uint128` supports the following:\n//\n//   * Implicit construction from integral types\n//   * Explicit conversion to integral types\n//\n// Additionally, if your compiler supports `__int128`, `uint128` is\n// interoperable with that type. (Abseil checks for this compatibility through\n// the `ABSL_HAVE_INTRINSIC_INT128` macro.)\n//\n// However, a `uint128` differs from intrinsic integral types in the following\n// ways:\n//\n//   * Errors on implicit conversions that do not preserve value (such as\n//     loss of precision when converting to float values).\n//   * Requires explicit construction from and conversion to floating point\n//     types.\n//   * Conversion to integral types requires an explicit static_cast() to\n//     mimic use of the `-Wnarrowing` compiler flag.\n//   * The alignment requirement of `uint128` may differ from that of an\n//     intrinsic 128-bit integer type depending on platform and build\n//     configuration.\n//\n// Example:\n//\n//     float y = absl::Uint128Max();  // Error. uint128 cannot be implicitly\n//                                    // converted to float.\n//\n//     absl::uint128 v;\n//     uint64_t i = v;                         // Error\n//     uint64_t i = static_cast<uint64_t>(v);  // OK\n//\nclass\n#if defined(ABSL_HAVE_INTRINSIC_INT128)\n    alignas(unsigned __int128)\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n        uint128 {\n public:\n  uint128() = default;\n\n  // Constructors from arithmetic types\n  constexpr uint128(int v);                 // NOLINT(runtime/explicit)\n  constexpr uint128(unsigned int v);        // NOLINT(runtime/explicit)\n  constexpr uint128(long v);                // NOLINT(runtime/int)\n  constexpr uint128(unsigned long v);       // NOLINT(runtime/int)\n  constexpr uint128(long long v);           // NOLINT(runtime/int)\n  constexpr uint128(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr uint128(__int128 v);           // NOLINT(runtime/explicit)\n  constexpr uint128(unsigned __int128 v);  // NOLINT(runtime/explicit)\n#endif                                     // ABSL_HAVE_INTRINSIC_INT128\n  constexpr uint128(int128 v);             // NOLINT(runtime/explicit)\n  explicit uint128(float v);\n  explicit uint128(double v);\n  explicit uint128(long double v);\n\n  // Assignment operators from arithmetic types\n  uint128& operator=(int v);\n  uint128& operator=(unsigned int v);\n  uint128& operator=(long v);                // NOLINT(runtime/int)\n  uint128& operator=(unsigned long v);       // NOLINT(runtime/int)\n  uint128& operator=(long long v);           // NOLINT(runtime/int)\n  uint128& operator=(unsigned long long v);  // NOLINT(runtime/int)\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  uint128& operator=(__int128 v);\n  uint128& operator=(unsigned __int128 v);\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  uint128& operator=(int128 v);\n\n  // Conversion operators to other arithmetic types\n  constexpr explicit operator bool() const;\n  constexpr explicit operator char() const;\n  constexpr explicit operator signed char() const;\n  constexpr explicit operator unsigned char() const;\n  constexpr explicit operator char16_t() const;\n  constexpr explicit operator char32_t() const;\n  constexpr explicit operator ABSL_INTERNAL_WCHAR_T() const;\n  constexpr explicit operator short() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned short() const;\n  constexpr explicit operator int() const;\n  constexpr explicit operator unsigned int() const;\n  constexpr explicit operator long() const;  // NOLINT(runtime/int)\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator long long() const;\n  // NOLINTNEXTLINE(runtime/int)\n  constexpr explicit operator unsigned long long() const;\n#ifdef ABSL_HAVE_INTRINSIC_INT128\n  constexpr explicit operator __int128() const;\n  constexpr explicit operator unsigned __int128() const;\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n  explicit operator float() const;\n  explicit operator double() const;\n  explicit operator long double() const;\n\n  // Trivial copy constructor, assignment operator and destructor.\n\n  // Arithmetic operators.\n  uint128& operator+=(uint128 other);\n  uint128& operator-=(uint128 other);\n  uint128& operator*=(uint128 other);\n  // Long division/modulo for uint128.\n  uint128& operator/=(uint128 other);\n  uint128& operator%=(uint128 other);\n  uint128 operator++(int);\n  uint128 operator--(int);\n  uint128& operator<<=(int);\n  uint128& operator>>=(int);\n  uint128& operator&=(uint128 other);\n  uint128& operator|=(uint128 other);\n  uint128& operator^=(uint128 other);\n  uint128& operator++();\n  uint128& operator--();\n\n  // Uint128Low64()\n  //\n  // Returns the lower 64-bit value of a `uint128` value.\n  friend constexpr uint64_t Uint128Low64(uint128 v);\n\n  // Uint128High64()\n  //\n  // Returns the higher 64-bit value of a `uint128` value.\n  friend constexpr uint64_t Uint128High64(uint128 v);\n\n  // MakeUInt128()\n  //\n  // Constructs a `uint128` numeric value from two 64-bit unsigned integers.\n  // Note that this factory function is the only way to construct a `uint128`\n  // from integer values greater than 2^64.\n  //\n  // Example:\n  //\n  //   absl::uint128 big = absl::MakeUint128(1, 0);\n  friend constexpr uint128 MakeUint128(uint64_t high, uint64_t low);\n\n  // Uint128Max()\n  //\n  // Returns the highest value for a 128-bit unsigned integer.\n  friend constexpr uint128 Uint128Max();\n\n  // Support for absl::Hash.\n  template <typename H>\n  friend H AbslHashValue(H h, uint128 v) {\n    return H::combine(std::move(h), Uint128High64(v), Uint128Low64(v));\n  }\n\n  // Support for absl::StrCat() etc.\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, uint128 v) {\n    sink.Append(v.ToString());\n  }\n\n private:\n  constexpr uint128(uint64_t high, uint64_t low);\n\n  std::string ToString() const;\n\n  // TODO(strel) Update implementation to use __int128 once all users of\n  // uint128 are fixed to not depend on alignof(uint128) == 8. Also add\n  // alignas(16) to class definition to keep alignment consistent across\n  // platforms.\n#if defined(ABSL_IS_LITTLE_ENDIAN)\n  uint64_t lo_;\n  uint64_t hi_;\n#elif defined(ABSL_IS_BIG_ENDIAN)\n  uint64_t hi_;\n  uint64_t lo_;\n#else  // byte order\n#error \"Unsupported byte order: must be little-endian or big-endian.\"\n#endif  // byte order\n};\n\n// Prefer to use the constexpr `Uint128Max()`.\n//\n// TODO(absl-team) deprecate kuint128max once migration tool is released.\nABSL_DLL extern const uint128 kuint128max;\n\n// allow uint128 to be logged\nstd::ostream& operator<<(std::ostream& os, uint128 v);\n\n// TODO(strel) add operator>>(std::istream&, uint128)\n\nconstexpr uint128 Uint128Max() {\n  return uint128((std::numeric_limits<uint64_t>::max)(),\n                 (std::numeric_limits<uint64_t>::max)());\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03777",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.h",
  "source_line": 56,
  "validation_status": "validated"
}