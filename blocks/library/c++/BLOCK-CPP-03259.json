{
  "code": "{\n\nnamespace {\n#if defined(__ANDROID__) && defined(__ANDROID_API__) && __ANDROID_API__ >= 21\n// Android 'L' removes __system_property_get() from the NDK, however\n// it is still a hidden symbol in libc so we use dlsym() to access it.\n// See Chromium's base/sys_info_android.cc for a similar example.\n\nusing property_get_func = int (*)(const char*, char*);\n\nproperty_get_func LoadSystemPropertyGet() {\n  int flag = RTLD_LAZY | RTLD_GLOBAL;\n#if defined(RTLD_NOLOAD)\n  flag |= RTLD_NOLOAD;  // libc.so should already be resident\n#endif\n  if (void* handle = dlopen(\"libc.so\", flag)) {\n    void* sym = dlsym(handle, \"__system_property_get\");\n    dlclose(handle);\n    return reinterpret_cast<property_get_func>(sym);\n  }\n  return nullptr;\n}\n\nint __system_property_get(const char* name, char* value) {\n  static property_get_func system_property_get = LoadSystemPropertyGet();\n  return system_property_get ? system_property_get(name, value) : -1;\n}\n#endif\n\n#if defined(USE_WIN32_LOCAL_TIME_ZONE)\n// Calls the WinRT Calendar.GetTimeZone method to obtain the IANA ID of the\n// local time zone. Returns an empty vector in case of an error.\nstd::string win32_local_time_zone(const HMODULE combase) {\n  std::string result;\n  const auto ro_activate_instance =\n      reinterpret_cast<decltype(&RoActivateInstance)>(\n          GetProcAddress(combase, \"RoActivateInstance\"));\n  if (!ro_activate_instance) {\n    return result;\n  }\n  const auto windows_create_string_reference =\n      reinterpret_cast<decltype(&WindowsCreateStringReference)>(\n          GetProcAddress(combase, \"WindowsCreateStringReference\"));\n  if (!windows_create_string_reference) {\n    return result;\n  }\n  const auto windows_delete_string =\n      reinterpret_cast<decltype(&WindowsDeleteString)>(\n          GetProcAddress(combase, \"WindowsDeleteString\"));\n  if (!windows_delete_string) {\n    return result;\n  }\n  const auto windows_get_string_raw_buffer =\n      reinterpret_cast<decltype(&WindowsGetStringRawBuffer)>(\n          GetProcAddress(combase, \"WindowsGetStringRawBuffer\"));\n  if (!windows_get_string_raw_buffer) {\n    return result;\n  }\n\n  // The string returned by WindowsCreateStringReference doesn't need to be\n  // deleted.\n  HSTRING calendar_class_id;\n  HSTRING_HEADER calendar_class_id_header;\n  HRESULT hr = windows_create_string_reference(\n      RuntimeClass_Windows_Globalization_Calendar,\n      sizeof(RuntimeClass_Windows_Globalization_Calendar) / sizeof(wchar_t) - 1,\n      &calendar_class_id_header, &calendar_class_id);\n  if (FAILED(hr)) {\n    return result;\n  }\n\n  IInspectable* calendar;\n  hr = ro_activate_instance(calendar_class_id, &calendar);\n  if (FAILED(hr)) {\n    return result;\n  }\n\n  ABI::Windows::Globalization::ITimeZoneOnCalendar* time_zone;\n  hr = calendar->QueryInterface(IID_PPV_ARGS(&time_zone));\n  if (FAILED(hr)) {\n    calendar->Release();\n    return result;\n  }\n\n  HSTRING tz_hstr;\n  hr = time_zone->GetTimeZone(&tz_hstr);\n  if (SUCCEEDED(hr)) {\n    UINT32 wlen;\n    const PCWSTR tz_wstr = windows_get_string_raw_buffer(tz_hstr, &wlen);\n    if (tz_wstr) {\n      const int size =\n          WideCharToMultiByte(CP_UTF8, 0, tz_wstr, static_cast<int>(wlen),\n                              nullptr, 0, nullptr, nullptr);\n      result.resize(static_cast<size_t>(size));\n      WideCharToMultiByte(CP_UTF8, 0, tz_wstr, static_cast<int>(wlen),\n                          &result[0], size, nullptr, nullptr);\n    }\n    windows_delete_string(tz_hstr);\n  }\n  time_zone->Release();\n  calendar->Release();\n  return result;\n}\n#endif\n}  // namespace\n\nstd::string time_zone::name() const { return effective_impl().Name(); }\n\ntime_zone::absolute_lookup time_zone::lookup(\n    const time_point<seconds>& tp) const {\n  return effective_impl().BreakTime(tp);\n}\n\ntime_zone::civil_lookup time_zone::lookup(const civil_second& cs) const {\n  return effective_impl().MakeTime(cs);\n}\n\nbool time_zone::next_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().NextTransition(tp, trans);\n}\n\nbool time_zone::prev_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().PrevTransition(tp, trans);\n}\n\nstd::string time_zone::version() const { return effective_impl().Version(); }\n\nstd::string time_zone::description() const {\n  return effective_impl().Description();\n}\n\nconst time_zone::Impl& time_zone::effective_impl() const {\n  if (impl_ == nullptr) {\n    // Dereferencing an implicit-UTC time_zone is expected to be\n    // rare, so we don't mind paying a small synchronization cost.\n    return *time_zone::Impl::UTC().impl_;\n  }\n  return *impl_;\n}\n\nbool load_time_zone(const std::string& name, time_zone* tz) {\n  return time_zone::Impl::LoadTimeZone(name, tz);\n}\n\ntime_zone utc_time_zone() {\n  return time_zone::Impl::UTC();  // avoid name lookup\n}\n\ntime_zone fixed_time_zone(const seconds& offset) {\n  time_zone tz;\n  load_time_zone(FixedOffsetToName(offset), &tz);\n  return tz;\n}\n\ntime_zone local_time_zone() {\n  const char* zone = \":localtime\";\n#if defined(__ANDROID__)\n  char sysprop[PROP_VALUE_MAX];\n  if (__system_property_get(\"persist.sys.timezone\", sysprop) > 0) {\n    zone = sysprop;\n  }\n#endif\n#if defined(__APPLE__)\n  std::vector<char> buffer;\n  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();\n  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {\n    CFStringEncoding encoding = kCFStringEncodingUTF8;\n    CFIndex length = CFStringGetLength(tz_name);\n    CFIndex max_size = CFStringGetMaximumSizeForEncoding(length, encoding) + 1;\n    buffer.resize(static_cast<size_t>(max_size));\n    if (CFStringGetCString(tz_name, &buffer[0], max_size, encoding)) {\n      zone = &buffer[0];\n    }\n  }\n  CFRelease(tz_default);\n#endif\n#if defined(__Fuchsia__)\n  std::string primary_tz;\n  [&]() {\n    // Note: We can't use the synchronous FIDL API here because it doesn't\n    // allow timeouts; if the FIDL call failed, local_time_zone() would never\n    // return.\n\n    const zx::duration kTimeout = zx::msec(500);\n\n    // Don't attach to the thread because otherwise the thread's dispatcher\n    // would be set to null when the loop is destroyed, causing any other FIDL\n    // code running on the same thread to crash.\n    async::Loop loop(&kAsyncLoopConfigNeverAttachToThread);\n\n    fuchsia::intl::PropertyProviderHandle handle;\n    zx_status_t status = fdio_service_connect_by_name(\n        fuchsia::intl::PropertyProvider::Name_,\n        handle.NewRequest().TakeChannel().release());\n    if (status != ZX_OK) {\n      return;\n    }\n\n    fuchsia::intl::PropertyProviderPtr intl_provider;\n    status = intl_provider.Bind(std::move(handle), loop.dispatcher());\n    if (status != ZX_OK) {\n      return;\n    }\n\n    intl_provider->GetProfile(\n        [&loop, &primary_tz](fuchsia::intl::Profile profile) {\n          if (!profile.time_zones().empty()) {\n            primary_tz = profile.time_zones()[0].id;\n          }\n          loop.Quit();\n        });\n    loop.Run(zx::deadline_after(kTimeout));\n  }();\n\n  if (!primary_tz.empty()) {\n    zone = primary_tz.c_str();\n  }\n#endif\n#if defined(USE_WIN32_LOCAL_TIME_ZONE)\n  // Use the WinRT Calendar class to get the local time zone. This feature is\n  // available on Windows 10 and later. The library is dynamically linked to\n  // maintain binary compatibility with Windows XP - Windows 7. On Windows 8,\n  // The combase.dll API functions are available but the RoActivateInstance\n  // call will fail for the Calendar class.\n  std::string winrt_tz;\n  const HMODULE combase =\n      LoadLibraryEx(_T(\"combase.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\n  if (combase) {\n    const auto ro_initialize = reinterpret_cast<decltype(&::RoInitialize)>(\n        GetProcAddress(combase, \"RoInitialize\"));\n    const auto ro_uninitialize = reinterpret_cast<decltype(&::RoUninitialize)>(\n        GetProcAddress(combase, \"RoUninitialize\"));\n    if (ro_initialize && ro_uninitialize) {\n      const HRESULT hr = ro_initialize(RO_INIT_MULTITHREADED);\n      // RPC_E_CHANGED_MODE means that a previous RoInitialize call specified\n      // a different concurrency model. The WinRT runtime is initialized and\n      // should work for our purpose here, but we should *not* call\n      // RoUninitialize because it's a failure.\n      if (SUCCEEDED(hr) || hr == RPC_E_CHANGED_MODE) {\n        winrt_tz = win32_local_time_zone(combase);\n        if (SUCCEEDED(hr)) {\n          ro_uninitialize();\n        }\n      }\n    }\n    FreeLibrary(combase);\n  }\n  if (!winrt_tz.empty()) {\n    zone = winrt_tz.c_str();\n  }\n#endif\n\n  // Allow ${TZ} to override to default zone.\n  char* tz_env = nullptr;\n#if defined(_MSC_VER)\n  _dupenv_s(&tz_env, nullptr, \"TZ\");\n#else\n  tz_env = std::getenv(\"TZ\");\n#endif\n  if (tz_env) zone = tz_env;\n\n  // We only support the \"[:]<zone-name>\" form.\n  if (*zone == ':') ++zone;\n\n  // Map \"localtime\" to a system-specific name, but\n  // allow ${LOCALTIME} to override the default name.\n  char* localtime_env = nullptr;\n  if (strcmp(zone, \"localtime\") == 0) {\n#if defined(_MSC_VER)\n    // System-specific default is just \"localtime\".\n    _dupenv_s(&localtime_env, nullptr, \"LOCALTIME\");\n#else\n    zone = \"/etc/localtime\";  // System-specific default.\n    localtime_env = std::getenv(\"LOCALTIME\");\n#endif\n    if (localtime_env) zone = localtime_env;\n  }\n\n  const std::string name = zone;\n#if defined(_MSC_VER)\n  free(localtime_env);\n  free(tz_env);\n#endif\n\n  time_zone tz;\n  load_time_zone(name, &tz);  // Falls back to UTC.\n  // TODO: Follow the RFC3339 \"Unknown Local Offset Convention\" and\n  // arrange for %z to generate \"-0000\" when we don't know the local\n  // offset because the load_time_zone() failed and we're using UTC.\n  return tz;\n}\n\n}",
  "id": "BLOCK-CPP-03259",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_lookup.cc",
  "source_line": 66,
  "validation_status": "validated"
}