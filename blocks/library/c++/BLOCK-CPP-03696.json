{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// Function Template: WrapUnique()\n// -----------------------------------------------------------------------------\n//\n// Adopts ownership from a raw pointer and transfers it to the returned\n// `std::unique_ptr`, whose type is deduced. Because of this deduction, *do not*\n// specify the template type `T` when calling `WrapUnique`.\n//\n// Example:\n//   X* NewX(int, int);\n//   auto x = WrapUnique(NewX(1, 2));  // 'x' is std::unique_ptr<X>.\n//\n// Do not call WrapUnique with an explicit type, as in\n// `WrapUnique<X>(NewX(1, 2))`.  The purpose of WrapUnique is to automatically\n// deduce the pointer type. If you wish to make the type explicit, just use\n// `std::unique_ptr` directly.\n//\n//   auto x = std::unique_ptr<X>(NewX(1, 2));\n//                  - or -\n//   std::unique_ptr<X> x(NewX(1, 2));\n//\n// While `absl::WrapUnique` is useful for capturing the output of a raw\n// pointer factory, prefer 'absl::make_unique<T>(args...)' over\n// 'absl::WrapUnique(new T(args...))'.\n//\n//   auto x = WrapUnique(new X(1, 2));  // works, but nonideal.\n//   auto x = make_unique<X>(1, 2);     // safer, standard, avoids raw 'new'.\n//\n// Note that `absl::WrapUnique(p)` is valid only if `delete p` is a valid\n// expression. In particular, `absl::WrapUnique()` cannot wrap pointers to\n// arrays, functions or void, and it must not be used to capture pointers\n// obtained from array-new expressions (even though that would compile!).\ntemplate <typename T>\nstd::unique_ptr<T> WrapUnique(T* ptr) {\n  static_assert(!std::is_array<T>::value, \"array types are unsupported\");\n  static_assert(std::is_object<T>::value, \"non-object types are unsupported\");\n  return std::unique_ptr<T>(ptr);\n}\n\n// -----------------------------------------------------------------------------\n// Function Template: make_unique<T>()\n// -----------------------------------------------------------------------------\n//\n// Creates a `std::unique_ptr<>`, while avoiding issues creating temporaries\n// during the construction process. `absl::make_unique<>` also avoids redundant\n// type declarations, by avoiding the need to explicitly use the `new` operator.\n//\n// https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\n//\n// For more background on why `std::unique_ptr<T>(new T(a,b))` is problematic,\n// see Herb Sutter's explanation on\n// (Exception-Safe Function Calls)[https://herbsutter.com/gotw/_102/].\n// (In general, reviewers should treat `new T(a,b)` with scrutiny.)\n//\n// Historical note: Abseil once provided a C++11 compatible implementation of\n// the C++14's `std::make_unique`. Now that C++11 support has been sunsetted,\n// `absl::make_unique` simply uses the STL-provided implementation. New code\n// should use `std::make_unique`.\nusing std::make_unique;\n\n// -----------------------------------------------------------------------------\n// Function Template: RawPtr()\n// -----------------------------------------------------------------------------\n//\n// Extracts the raw pointer from a pointer-like value `ptr`. `absl::RawPtr` is\n// useful within templates that need to handle a complement of raw pointers,\n// `std::nullptr_t`, and smart pointers.\ntemplate <typename T>\nauto RawPtr(T&& ptr) -> decltype(std::addressof(*ptr)) {\n  // ptr is a forwarding reference to support Ts with non-const operators.\n  return (ptr != nullptr) ? std::addressof(*ptr) : nullptr;\n}\ninline std::nullptr_t RawPtr(std::nullptr_t) { return nullptr; }\n\n// -----------------------------------------------------------------------------\n// Function Template: ShareUniquePtr()\n// -----------------------------------------------------------------------------\n//\n// Adopts a `std::unique_ptr` rvalue and returns a `std::shared_ptr` of deduced\n// type. Ownership (if any) of the held value is transferred to the returned\n// shared pointer.\n//\n// Example:\n//\n//     auto up = absl::make_unique<int>(10);\n//     auto sp = absl::ShareUniquePtr(std::move(up));  // shared_ptr<int>\n//     CHECK_EQ(*sp, 10);\n//     CHECK(up == nullptr);\n//\n// Note that this conversion is correct even when T is an array type, and more\n// generally it works for *any* deleter of the `unique_ptr` (single-object\n// deleter, array deleter, or any custom deleter), since the deleter is adopted\n// by the shared pointer as well. The deleter is copied (unless it is a\n// reference).\n//\n// Implements the resolution of [LWG 2415](http://wg21.link/lwg2415), by which a\n// null shared pointer does not attempt to call the deleter.\ntemplate <typename T, typename D>\nstd::shared_ptr<T> ShareUniquePtr(std::unique_ptr<T, D>&& ptr) {\n  return ptr ? std::shared_ptr<T>(std::move(ptr)) : std::shared_ptr<T>();\n}\n\n// -----------------------------------------------------------------------------\n// Function Template: WeakenPtr()\n// -----------------------------------------------------------------------------\n//\n// Creates a weak pointer associated with a given shared pointer. The returned\n// value is a `std::weak_ptr` of deduced type.\n//\n// Example:\n//\n//    auto sp = std::make_shared<int>(10);\n//    auto wp = absl::WeakenPtr(sp);\n//    CHECK_EQ(sp.get(), wp.lock().get());\n//    sp.reset();\n//    CHECK(wp.lock() == nullptr);\n//\ntemplate <typename T>\nstd::weak_ptr<T> WeakenPtr(const std::shared_ptr<T>& ptr) {\n  return std::weak_ptr<T>(ptr);\n}\n\n// -----------------------------------------------------------------------------\n// Class Template: pointer_traits\n// -----------------------------------------------------------------------------\n//\n// Historical note: Abseil once provided an implementation of\n// `std::pointer_traits` for platforms that had not yet provided it. Those\n// platforms are no longer supported. New code should simply use\n// `std::pointer_traits`.\nusing std::pointer_traits;\n\n// -----------------------------------------------------------------------------\n// Class Template: allocator_traits\n// -----------------------------------------------------------------------------\n//\n// Historical note: Abseil once provided an implementation of\n// `std::allocator_traits` for platforms that had not yet provided it. Those\n// platforms are no longer supported. New code should simply use\n// `std::allocator_traits`.\nusing std::allocator_traits;\n\nnamespace memory_internal {\n\n// ExtractOr<E, O, D>::type evaluates to E<O> if possible. Otherwise, D.\ntemplate <template <typename> class Extract, typename Obj, typename Default,\n          typename>\nstruct ExtractOr {\n  using type = Default;\n};\n\ntemplate <template <typename> class Extract, typename Obj, typename Default>\nstruct ExtractOr<Extract, Obj, Default, void_t<Extract<Obj>>> {\n  using type = Extract<Obj>;\n};\n\ntemplate <template <typename> class Extract, typename Obj, typename Default>\nusing ExtractOrT = typename ExtractOr<Extract, Obj, Default, void>::type;\n\n// This template alias transforms Alloc::is_nothrow into a metafunction with\n// Alloc as a parameter so it can be used with ExtractOrT<>.\ntemplate <typename Alloc>\nusing GetIsNothrow = typename Alloc::is_nothrow;\n\n}  // namespace memory_internal\n\n// ABSL_ALLOCATOR_NOTHROW is a build time configuration macro for user to\n// specify whether the default allocation function can throw or never throws.\n// If the allocation function never throws, user should define it to a non-zero\n// value (e.g. via `-DABSL_ALLOCATOR_NOTHROW`).\n// If the allocation function can throw, user should leave it undefined or\n// define it to zero.\n//\n// allocator_is_nothrow<Alloc> is a traits class that derives from\n// Alloc::is_nothrow if present, otherwise std::false_type. It's specialized\n// for Alloc = std::allocator<T> for any type T according to the state of\n// ABSL_ALLOCATOR_NOTHROW.\n//\n// default_allocator_is_nothrow is a class that derives from std::true_type\n// when the default allocator (global operator new) never throws, and\n// std::false_type when it can throw. It is a convenience shorthand for writing\n// allocator_is_nothrow<std::allocator<T>> (T can be any type).\n// NOTE: allocator_is_nothrow<std::allocator<T>> is guaranteed to derive from\n// the same type for all T, because users should specialize neither\n// allocator_is_nothrow nor std::allocator.\ntemplate <typename Alloc>\nstruct allocator_is_nothrow\n    : memory_internal::ExtractOrT<memory_internal::GetIsNothrow, Alloc,\n                                  std::false_type> {};\n\n#if defined(ABSL_ALLOCATOR_NOTHROW) && ABSL_ALLOCATOR_NOTHROW\ntemplate <typename T>\nstruct allocator_is_nothrow<std::allocator<T>> : std::true_type {};\nstruct default_allocator_is_nothrow : std::true_type {};\n#else\nstruct default_allocator_is_nothrow : std::false_type {};\n#endif\n\nnamespace memory_internal {\ntemplate <typename Allocator, typename Iterator, typename... Args>\nvoid ConstructRange(Allocator& alloc, Iterator first, Iterator last,\n                    const Args&... args) {\n  for (Iterator cur = first; cur != last; ++cur) {\n    ABSL_INTERNAL_TRY {\n      std::allocator_traits<Allocator>::construct(alloc, std::addressof(*cur),\n                                                  args...);\n    }\n    ABSL_INTERNAL_CATCH_ANY {\n      while (cur != first) {\n        --cur;\n        std::allocator_traits<Allocator>::destroy(alloc, std::addressof(*cur));\n      }\n      ABSL_INTERNAL_RETHROW;\n    }\n  }\n}\n\ntemplate <typename Allocator, typename Iterator, typename InputIterator>\nvoid CopyRange(Allocator& alloc, Iterator destination, InputIterator first,\n               InputIterator last) {\n  for (Iterator cur = destination; first != last;\n       static_cast<void>(++cur), static_cast<void>(++first)) {\n    ABSL_INTERNAL_TRY {\n      std::allocator_traits<Allocator>::construct(alloc, std::addressof(*cur),\n                                                  *first);\n    }\n    ABSL_INTERNAL_CATCH_ANY {\n      while (cur != destination) {\n        --cur;\n        std::allocator_traits<Allocator>::destroy(alloc, std::addressof(*cur));\n      }\n      ABSL_INTERNAL_RETHROW;\n    }\n  }\n}\n}  // namespace memory_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03696",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/memory/memory.h",
  "source_line": 36,
  "validation_status": "validated"
}