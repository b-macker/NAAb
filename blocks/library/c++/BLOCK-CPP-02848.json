{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\nnamespace {\n\n// Read OS Entropy for random number seeds.\n// TODO(absl-team): Possibly place a cap on how much entropy may be read at a\n// time.\n\n#if defined(ABSL_RANDOM_USE_BCRYPT)\n\n// On Windows potentially use the BCRYPT CNG API to read available entropy.\nbool ReadSeedMaterialFromOSEntropyImpl(absl::Span<uint32_t> values) {\n  BCRYPT_ALG_HANDLE hProvider;\n  NTSTATUS ret;\n  ret = BCryptOpenAlgorithmProvider(&hProvider, BCRYPT_RNG_ALGORITHM,\n                                    MS_PRIMITIVE_PROVIDER, 0);\n  if (!(BCRYPT_SUCCESS(ret))) {\n    ABSL_RAW_LOG(ERROR, \"Failed to open crypto provider.\");\n    return false;\n  }\n  ret = BCryptGenRandom(\n      hProvider,                                             // provider\n      reinterpret_cast<UCHAR*>(values.data()),               // buffer\n      static_cast<ULONG>(sizeof(uint32_t) * values.size()),  // bytes\n      0);                                                    // flags\n  BCryptCloseAlgorithmProvider(hProvider, 0);\n  return BCRYPT_SUCCESS(ret);\n}\n\n#elif defined(ABSL_RANDOM_USE_NACL_SECURE_RANDOM)\n\n// On NaCL use nacl_secure_random to acquire bytes.\nbool ReadSeedMaterialFromOSEntropyImpl(absl::Span<uint32_t> values) {\n  auto buffer = reinterpret_cast<uint8_t*>(values.data());\n  size_t buffer_size = sizeof(uint32_t) * values.size();\n\n  uint8_t* output_ptr = buffer;\n  while (buffer_size > 0) {\n    size_t nread = 0;\n    const int error = nacl_secure_random(output_ptr, buffer_size, &nread);\n    if (error != 0 || nread > buffer_size) {\n      ABSL_RAW_LOG(ERROR, \"Failed to read secure_random seed data: %d\", error);\n      return false;\n    }\n    output_ptr += nread;\n    buffer_size -= nread;\n  }\n  return true;\n}\n\n#elif defined(__Fuchsia__)\n\nbool ReadSeedMaterialFromOSEntropyImpl(absl::Span<uint32_t> values) {\n  auto buffer = reinterpret_cast<uint8_t*>(values.data());\n  size_t buffer_size = sizeof(uint32_t) * values.size();\n  zx_cprng_draw(buffer, buffer_size);\n  return true;\n}\n\n#else\n\n#if defined(ABSL_RANDOM_USE_GET_ENTROPY)\n// On *nix, use getentropy() if supported. Note that libc may support\n// getentropy(), but the kernel may not, in which case this function will return\n// false.\nbool ReadSeedMaterialFromGetEntropy(absl::Span<uint32_t> values) {\n  auto buffer = reinterpret_cast<uint8_t*>(values.data());\n  size_t buffer_size = sizeof(uint32_t) * values.size();\n  while (buffer_size > 0) {\n    // getentropy() has a maximum permitted length of 256.\n    size_t to_read = std::min<size_t>(buffer_size, 256);\n    int result = getentropy(buffer, to_read);\n    if (result < 0) {\n      return false;\n    }\n    // https://github.com/google/sanitizers/issues/1173\n    // MemorySanitizer can't see through getentropy().\n    ABSL_ANNOTATE_MEMORY_IS_INITIALIZED(buffer, to_read);\n    buffer += to_read;\n    buffer_size -= to_read;\n  }\n  return true;\n}\n#endif  // defined(ABSL_RANDOM_GETENTROPY)\n\n// On *nix, read entropy from /dev/urandom.\nbool ReadSeedMaterialFromDevURandom(absl::Span<uint32_t> values) {\n  const char kEntropyFile[] = \"/dev/urandom\";\n\n  auto buffer = reinterpret_cast<uint8_t*>(values.data());\n  size_t buffer_size = sizeof(uint32_t) * values.size();\n\n  int dev_urandom = open(kEntropyFile, O_RDONLY);\n  bool success = (-1 != dev_urandom);\n  if (!success) {\n    return false;\n  }\n\n  while (success && buffer_size > 0) {\n    ssize_t bytes_read = read(dev_urandom, buffer, buffer_size);\n    int read_error = errno;\n    success = (bytes_read > 0);\n    if (success) {\n      buffer += bytes_read;\n      buffer_size -= static_cast<size_t>(bytes_read);\n    } else if (bytes_read == -1 && read_error == EINTR) {\n      success = true;  // Need to try again.\n    }\n  }\n  close(dev_urandom);\n  return success;\n}\n\nbool ReadSeedMaterialFromOSEntropyImpl(absl::Span<uint32_t> values) {\n#if defined(ABSL_RANDOM_USE_GET_ENTROPY)\n  if (ReadSeedMaterialFromGetEntropy(values)) {\n    return true;\n  }\n#endif\n  // Libc may support getentropy, but the kernel may not, so we still have\n  // to fallback to ReadSeedMaterialFromDevURandom().\n  return ReadSeedMaterialFromDevURandom(values);\n}\n\n#endif\n\n}  // namespace\n\nbool ReadSeedMaterialFromOSEntropy(absl::Span<uint32_t> values) {\n  assert(values.data() != nullptr);\n  if (values.data() == nullptr) {\n    return false;\n  }\n  if (values.empty()) {\n    return true;\n  }\n  return ReadSeedMaterialFromOSEntropyImpl(values);\n}\n\nvoid MixIntoSeedMaterial(absl::Span<const uint32_t> sequence,\n                         absl::Span<uint32_t> seed_material) {\n  // Algorithm is based on code available at\n  // https://gist.github.com/imneme/540829265469e673d045\n  constexpr uint32_t kInitVal = 0x43b0d7e5;\n  constexpr uint32_t kHashMul = 0x931e8875;\n  constexpr uint32_t kMixMulL = 0xca01f9dd;\n  constexpr uint32_t kMixMulR = 0x4973f715;\n  constexpr uint32_t kShiftSize = sizeof(uint32_t) * 8 / 2;\n\n  uint32_t hash_const = kInitVal;\n  auto hash = [&](uint32_t value) {\n    value ^= hash_const;\n    hash_const *= kHashMul;\n    value *= hash_const;\n    value ^= value >> kShiftSize;\n    return value;\n  };\n\n  auto mix = [&](uint32_t x, uint32_t y) {\n    uint32_t result = kMixMulL * x - kMixMulR * y;\n    result ^= result >> kShiftSize;\n    return result;\n  };\n\n  for (const auto& seq_val : sequence) {\n    for (auto& elem : seed_material) {\n      elem = mix(elem, hash(seq_val));\n    }\n  }\n}\n\nabsl::optional<uint32_t> GetSaltMaterial() {\n  // Salt must be common for all generators within the same process so read it\n  // only once and store in static variable.\n  static const auto salt_material = []() -> absl::optional<uint32_t> {\n    uint32_t salt_value = 0;\n\n    if (random_internal::ReadSeedMaterialFromOSEntropy(\n            MakeSpan(&salt_value, 1))) {\n      return salt_value;\n    }\n\n    return absl::nullopt;\n  }();\n\n  return salt_material;\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02848",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/seed_material.cc",
  "source_line": 76,
  "validation_status": "validated"
}