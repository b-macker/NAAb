{
  "code": "{\n\n// Define the array for non-constexpr uses.\nconstexpr ConvTag ConvTagHolder::value[256];\n\nABSL_ATTRIBUTE_NOINLINE const char* ConsumeUnboundConversionNoInline(\n    const char* p, const char* end, UnboundConversion* conv, int* next_arg) {\n  return ConsumeUnboundConversion(p, end, conv, next_arg);\n}\n\nstd::string LengthModToString(LengthMod v) {\n  switch (v) {\n    case LengthMod::h:\n      return \"h\";\n    case LengthMod::hh:\n      return \"hh\";\n    case LengthMod::l:\n      return \"l\";\n    case LengthMod::ll:\n      return \"ll\";\n    case LengthMod::L:\n      return \"L\";\n    case LengthMod::j:\n      return \"j\";\n    case LengthMod::z:\n      return \"z\";\n    case LengthMod::t:\n      return \"t\";\n    case LengthMod::q:\n      return \"q\";\n    case LengthMod::none:\n      return \"\";\n  }\n  return \"\";\n}\n\nstruct ParsedFormatBase::ParsedFormatConsumer {\n  explicit ParsedFormatConsumer(ParsedFormatBase *parsedformat)\n      : parsed(parsedformat), data_pos(parsedformat->data_.get()) {}\n\n  bool Append(string_view s) {\n    if (s.empty()) return true;\n\n    size_t text_end = AppendText(s);\n\n    if (!parsed->items_.empty() && !parsed->items_.back().is_conversion) {\n      // Let's extend the existing text run.\n      parsed->items_.back().text_end = text_end;\n    } else {\n      // Let's make a new text run.\n      parsed->items_.push_back({false, text_end, {}});\n    }\n    return true;\n  }\n\n  bool ConvertOne(const UnboundConversion &conv, string_view s) {\n    size_t text_end = AppendText(s);\n    parsed->items_.push_back({true, text_end, conv});\n    return true;\n  }\n\n  size_t AppendText(string_view s) {\n    memcpy(data_pos, s.data(), s.size());\n    data_pos += s.size();\n    return static_cast<size_t>(data_pos - parsed->data_.get());\n  }\n\n  ParsedFormatBase *parsed;\n  char* data_pos;\n};\n\nParsedFormatBase::ParsedFormatBase(\n    string_view format, bool allow_ignored,\n    std::initializer_list<FormatConversionCharSet> convs)\n    : data_(format.empty() ? nullptr : new char[format.size()]) {\n  has_error_ = !ParseFormatString(format, ParsedFormatConsumer(this)) ||\n               !MatchesConversions(allow_ignored, convs);\n}\n\nbool ParsedFormatBase::MatchesConversions(\n    bool allow_ignored,\n    std::initializer_list<FormatConversionCharSet> convs) const {\n  std::unordered_set<int> used;\n  auto add_if_valid_conv = [&](int pos, char c) {\n    if (static_cast<size_t>(pos) > convs.size() ||\n        !Contains(convs.begin()[pos - 1], c))\n      return false;\n    used.insert(pos);\n    return true;\n  };\n  for (const ConversionItem &item : items_) {\n    if (!item.is_conversion) continue;\n    auto &conv = item.conv;\n    if (conv.precision.is_from_arg() &&\n        !add_if_valid_conv(conv.precision.get_from_arg(), '*'))\n      return false;\n    if (conv.width.is_from_arg() &&\n        !add_if_valid_conv(conv.width.get_from_arg(), '*'))\n      return false;\n    if (!add_if_valid_conv(conv.arg_position,\n                           FormatConversionCharToChar(conv.conv)))\n      return false;\n  }\n  return used.size() == convs.size() || allow_ignored;\n}\n\n}",
  "id": "BLOCK-CPP-03120",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/parser.cc",
  "source_line": 32,
  "validation_status": "validated"
}