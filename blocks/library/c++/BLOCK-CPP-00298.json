{
  "code": "{\nclass thread_pool;\n\nclass SPDLOG_API registry {\npublic:\n    using log_levels = std::unordered_map<std::string, level::level_enum>;\n    registry(const registry &) = delete;\n    registry &operator=(const registry &) = delete;\n\n    void register_logger(std::shared_ptr<logger> new_logger);\n    void initialize_logger(std::shared_ptr<logger> new_logger);\n    std::shared_ptr<logger> get(const std::string &logger_name);\n    std::shared_ptr<logger> default_logger();\n\n    // Return raw ptr to the default logger.\n    // To be used directly by the spdlog default api (e.g. spdlog::info)\n    // This make the default API faster, but cannot be used concurrently with set_default_logger().\n    // e.g do not call set_default_logger() from one thread while calling spdlog::info() from\n    // another.\n    logger *get_default_raw();\n\n    // set default logger.\n    // default logger is stored in default_logger_ (for faster retrieval) and in the loggers_ map.\n    void set_default_logger(std::shared_ptr<logger> new_default_logger);\n\n    void set_tp(std::shared_ptr<thread_pool> tp);\n\n    std::shared_ptr<thread_pool> get_tp();\n\n    // Set global formatter. Each sink in each logger will get a clone of this object\n    void set_formatter(std::unique_ptr<formatter> formatter);\n\n    void enable_backtrace(size_t n_messages);\n\n    void disable_backtrace();\n\n    void set_level(level::level_enum log_level);\n\n    void flush_on(level::level_enum log_level);\n\n    template <typename Rep, typename Period>\n    void flush_every(std::chrono::duration<Rep, Period> interval) {\n        std::lock_guard<std::mutex> lock(flusher_mutex_);\n        auto clbk = [this]() { this->flush_all(); };\n        periodic_flusher_ = details::make_unique<periodic_worker>(clbk, interval);\n    }\n\n    void set_error_handler(err_handler handler);\n\n    void apply_all(const std::function<void(const std::shared_ptr<logger>)> &fun);\n\n    void flush_all();\n\n    void drop(const std::string &logger_name);\n\n    void drop_all();\n\n    // clean all resources and threads started by the registry\n    void shutdown();\n\n    std::recursive_mutex &tp_mutex();\n\n    void set_automatic_registration(bool automatic_registration);\n\n    // set levels for all existing/future loggers. global_level can be null if should not set.\n    void set_levels(log_levels levels, level::level_enum *global_level);\n\n    static registry &instance();\n\n    void apply_logger_env_levels(std::shared_ptr<logger> new_logger);\n\nprivate:\n    registry();\n    ~registry();\n\n    void throw_if_exists_(const std::string &logger_name);\n    void register_logger_(std::shared_ptr<logger> new_logger);\n    bool set_level_from_cfg_(logger *logger);\n    std::mutex logger_map_mutex_, flusher_mutex_;\n    std::recursive_mutex tp_mutex_;\n    std::unordered_map<std::string, std::shared_ptr<logger>> loggers_;\n    log_levels log_levels_;\n    std::unique_ptr<formatter> formatter_;\n    spdlog::level::level_enum global_log_level_ = level::info;\n    level::level_enum flush_level_ = level::off;\n    err_handler err_handler_;\n    std::shared_ptr<thread_pool> tp_;\n    std::unique_ptr<periodic_worker> periodic_flusher_;\n    std::shared_ptr<logger> default_logger_;\n    bool automatic_registration_ = true;\n    size_t backtrace_n_messages_ = 0;\n};\n\n}",
  "id": "BLOCK-CPP-00298",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/registry.h",
  "source_line": 24,
  "validation_status": "validated"
}