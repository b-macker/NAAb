{
  "code": "#include \"clang/AST/DeclBase.h\"\n#include \"clang/Analysis/BodyFarm.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/CodeInjector.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <functional>\n#include <memory>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-15322_execute() {\n    {\n  // Backpoint to the AnalysisManager object that created this\n  // AnalysisDeclContext. This may be null.\n  AnalysisDeclContextManager *ADCMgr;\n\n  const Decl *const D;\n\n  std::unique_ptr<CFG> cfg, completeCFG;\n  std::unique_ptr<CFGStmtMap> cfgStmtMap;\n\n  CFG::BuildOptions cfgBuildOptions;\n  CFG::BuildOptions::ForcedBlkExprs *forcedBlkExprs = nullptr;\n\n  bool builtCFG = false;\n  bool builtCompleteCFG = false;\n  std::unique_ptr<ParentMap> PM;\n  std::unique_ptr<CFGReverseBlockReachabilityAnalysis> CFA;\n\n  llvm::BumpPtrAllocator A;\n\n  llvm::DenseMap<const BlockDecl *, void *> *ReferencedBlockVars = nullptr;\n\n  void *ManagedAnalyses = nullptr;\n\npublic:\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D);\n\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D,\n                      const CFG::BuildOptions &BuildOptions);\n\n  ~AnalysisDeclContext();\n\n  ASTContext &getASTContext() const { return D->getASTContext(); }\n\n  const Decl *getDecl() const { return D; }\n\n  AnalysisDeclContextManager *getManager() const { return ADCMgr; }\n\n  CFG::BuildOptions &getCFGBuildOptions() { return cfgBuildOptions; }\n\n  const CFG::BuildOptions &getCFGBuildOptions() const {\n    return cfgBuildOptions;\n  }\n\n  /// \\returns Whether we are adding exception handling edges from CallExprs.\n  /// If this is false, then try/catch statements and blocks reachable from them\n  /// can appear to be dead in the CFG, analysis passes must cope with that.\n  bool getAddEHEdges() const { return cfgBuildOptions.AddEHEdges; }\n  bool getUseUnoptimizedCFG() const {\n    return !cfgBuildOptions.PruneTriviallyFalseEdges;\n  }\n  bool getAddImplicitDtors() const { return cfgBuildOptions.AddImplicitDtors; }\n  bool getAddInitializers() const { return cfgBuildOptions.AddInitializers; }\n\n  void registerForcedBlockExpression(const Stmt *stmt);\n  const CFGBlock *getBlockForRegisteredExpression(const Stmt *stmt);\n\n  /// \\returns The body of the stored Decl \\c D.\n  Stmt *getBody() const;\n\n  /// \\copydoc AnalysisDeclContext::getBody()\n  /// \\param[out] IsAutosynthesized Specifies if the body is auto-generated\n  ///             by the BodyFarm.\n  Stmt *getBody(bool &IsAutosynthesized) const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesized() const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm\n  /// from a model file.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesizedFromModelFile() const;\n\n  CFG *getCFG();\n\n  CFGStmtMap *getCFGStmtMap();\n\n  CFGReverseBlockReachabilityAnalysis *getCFGReachablityAnalysis();\n\n  /// \\returns A version of the CFG without any edges pruned.\n  CFG *getUnoptimizedCFG();\n\n  void dumpCFG(bool ShowColors);\n\n  /// \\returns Whether we have built a CFG for this analysis context.\n  ///\n  /// \\note This doesn't correspond to whether or not a valid CFG exists, it\n  /// corresponds to whether we *attempted* to build one.\n  bool isCFGBuilt() const { return builtCFG; }\n\n  ParentMap &getParentMap();\n\n  using referenced_decls_iterator = const VarDecl *const *;\n\n  llvm::iterator_range<referenced_decls_iterator>\n  getReferencedBlockVars(const BlockDecl *BD);\n\n  /// \\returns The ImplicitParamDecl associated with \\c self if this\n  /// AnalysisDeclContext wraps an ObjCMethodDecl or nullptr otherwise.\n  const ImplicitParamDecl *getSelfDecl() const;\n\n  /// \\copydoc LocationContextManager::getStackFrame()\n  const StackFrameContext *getStackFrame(LocationContext const *ParentLC,\n                                         const Stmt *S, const CFGBlock *Blk,\n                                         unsigned BlockCount, unsigned Index);\n\n  /// \\copydoc LocationContextManager::getBlockInvocationContext()\n  const BlockInvocationContext *\n  getBlockInvocationContext(const LocationContext *ParentLC,\n                            const BlockDecl *BD, const void *Data);\n\n  /// \\returns The specified analysis object, lazily running the analysis if\n  /// necessary or nullptr if the analysis could not run.\n  template <typename T> T *getAnalysis() {\n    const void *tag = T::getTag();\n    std::unique_ptr<ManagedAnalysis> &data = getAnalysisImpl(tag);\n    if (!data)\n      data = T::create(*this);\n    return static_cast<T *>(data.get());\n  }\n\n  /// \\returns Whether the root namespace of \\p D is the \\c std C++ namespace.\n  static bool isInStdNamespace(const Decl *D);\n\n  static std::string getFunctionName(const Decl *D);\n\nprivate:\n  std::unique_ptr<ManagedAnalysis> &getAnalysisImpl(const void *tag);\n\n  LocationContextManager &getLocationContextManager();\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-15322",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/AnalysisDeclContext.h",
  "source_line": 72,
  "validation_status": "validated"
}