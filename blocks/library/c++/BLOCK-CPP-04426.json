{
  "code": "{\n public:\n  // Value semantics.\n\n  // Returns the Unix epoch.  However, those reading your code may not know\n  // or expect the Unix epoch as the default value, so make your code more\n  // readable by explicitly initializing all instances before use.\n  //\n  // Example:\n  //   absl::Time t = absl::UnixEpoch();\n  //   absl::Time t = absl::Now();\n  //   absl::Time t = absl::TimeFromTimeval(tv);\n  //   absl::Time t = absl::InfinitePast();\n  constexpr Time() = default;\n\n  // Copyable.\n  constexpr Time(const Time& t) = default;\n  Time& operator=(const Time& t) = default;\n\n  // Assignment operators.\n  Time& operator+=(Duration d) {\n    rep_ += d;\n    return *this;\n  }\n  Time& operator-=(Duration d) {\n    rep_ -= d;\n    return *this;\n  }\n\n  // Time::Breakdown\n  //\n  // The calendar and wall-clock (aka \"civil time\") components of an\n  // `absl::Time` in a certain `absl::TimeZone`. This struct is not\n  // intended to represent an instant in time. So, rather than passing\n  // a `Time::Breakdown` to a function, pass an `absl::Time` and an\n  // `absl::TimeZone`.\n  //\n  // Deprecated. Use `absl::TimeZone::CivilInfo`.\n  struct ABSL_DEPRECATED(\"Use `absl::TimeZone::CivilInfo`.\") Breakdown {\n    int64_t year;        // year (e.g., 2013)\n    int month;           // month of year [1:12]\n    int day;             // day of month [1:31]\n    int hour;            // hour of day [0:23]\n    int minute;          // minute of hour [0:59]\n    int second;          // second of minute [0:59]\n    Duration subsecond;  // [Seconds(0):Seconds(1)) if finite\n    int weekday;         // 1==Mon, ..., 7=Sun\n    int yearday;         // day of year [1:366]\n\n    // Note: The following fields exist for backward compatibility\n    // with older APIs.  Accessing these fields directly is a sign of\n    // imprudent logic in the calling code.  Modern time-related code\n    // should only access this data indirectly by way of FormatTime().\n    // These fields are undefined for InfiniteFuture() and InfinitePast().\n    int offset;             // seconds east of UTC\n    bool is_dst;            // is offset non-standard?\n    const char* zone_abbr;  // time-zone abbreviation (e.g., \"PST\")\n  };\n\n  // Time::In()\n  //\n  // Returns the breakdown of this instant in the given TimeZone.\n  //\n  // Deprecated. Use `absl::TimeZone::At(Time)`.\n  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING\n  ABSL_DEPRECATED(\"Use `absl::TimeZone::At(Time)`.\")\n  Breakdown In(TimeZone tz) const;\n  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING\n\n  template <typename H>\n  friend H AbslHashValue(H h, Time t) {\n    return H::combine(std::move(h), t.rep_);\n  }\n\n private:\n  friend constexpr Time time_internal::FromUnixDuration(Duration d);\n  friend constexpr Duration time_internal::ToUnixDuration(Time t);\n  friend constexpr bool operator<(Time lhs, Time rhs);\n  friend constexpr bool operator==(Time lhs, Time rhs);\n  friend Duration operator-(Time lhs, Time rhs);\n  friend constexpr Time UniversalEpoch();\n  friend constexpr Time InfiniteFuture();\n  friend constexpr Time InfinitePast();\n  constexpr explicit Time(Duration rep) : rep_(rep) {}\n  Duration rep_;\n}",
  "id": "BLOCK-CPP-04426",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 767,
  "validation_status": "validated"
}