{
  "code": "{\n    /// A pointer to a known latest declaration, either statically known or\n    /// generationally updated as decls are added by an external source.\n    using KnownLatest =\n        LazyGenerationalUpdatePtr<const Decl *, Decl *,\n                                  &ExternalASTSource::CompleteRedeclChain>;\n\n    /// We store a pointer to the ASTContext in the UninitializedLatest\n    /// pointer, but to avoid circular type dependencies when we steal the low\n    /// bits of this pointer, we use a raw void* here.\n    using UninitializedLatest = const void *;\n\n    using Previous = Decl *;\n\n    /// A pointer to either an uninitialized latest declaration (where either\n    /// we've not yet set the previous decl or there isn't one), or to a known\n    /// previous declaration.\n    using NotKnownLatest = llvm::PointerUnion<Previous, UninitializedLatest>;\n\n    mutable llvm::PointerUnion<NotKnownLatest, KnownLatest> Link;\n\n  public:\n    enum PreviousTag { PreviousLink };\n    enum LatestTag { LatestLink };\n\n    DeclLink(LatestTag, const ASTContext &Ctx)\n        : Link(NotKnownLatest(reinterpret_cast<UninitializedLatest>(&Ctx))) {}\n    DeclLink(PreviousTag, decl_type *D) : Link(NotKnownLatest(Previous(D))) {}\n\n    bool isFirst() const {\n      return Link.is<KnownLatest>() ||\n             // FIXME: 'template' is required on the next line due to an\n             // apparent clang bug.\n             Link.get<NotKnownLatest>().template is<UninitializedLatest>();\n    }\n\n    decl_type *getPrevious(const decl_type *D) const {\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        if (NKL.is<Previous>())\n          return static_cast<decl_type*>(NKL.get<Previous>());\n\n        // Allocate the generational 'most recent' cache now, if needed.\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           const_cast<decl_type *>(D));\n      }\n\n      return static_cast<decl_type*>(Link.get<KnownLatest>().get(D));\n    }\n\n    void setPrevious(decl_type *D) {\n      assert(!isFirst() && \"decl became non-canonical unexpectedly\");\n      Link = Previous(D);\n    }\n\n    void setLatest(decl_type *D) {\n      assert(isFirst() && \"decl became canonical unexpectedly\");\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           D);\n      } else {\n        auto Latest = Link.get<KnownLatest>();\n        Latest.set(D);\n        Link = Latest;\n      }\n    }\n\n    void markIncomplete() { Link.get<KnownLatest>().markIncomplete(); }\n\n    Decl *getLatestNotUpdated() const {\n      assert(isFirst() && \"expected a canonical decl\");\n      if (Link.is<NotKnownLatest>())\n        return nullptr;\n      return Link.get<KnownLatest>().getNotUpdated();\n    }\n  }",
  "id": "BLOCK-CPP-12419",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Redeclarable.h",
  "source_line": 86,
  "validation_status": "validated"
}