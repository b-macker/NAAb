{
  "code": "{\n//    public:\n//     void Bar(int);\n//   };\n//   void user_function1(int, std::string);\n//   void user_function2(std::unique_ptr<Foo>);\n//   auto user_lambda = [](int, int) {};\n//\n//   int main()\n//   {\n//       std::tuple<int, std::string> tuple1(42, \"bar\");\n//       // Invokes the first user function on int, std::string.\n//       absl::apply(&user_function1, tuple1);\n//\n//       std::tuple<std::unique_ptr<Foo>> tuple2(absl::make_unique<Foo>());\n//       // Invokes the user function that takes ownership of the unique\n//       // pointer.\n//       absl::apply(&user_function2, std::move(tuple2));\n//\n//       auto foo = absl::make_unique<Foo>();\n//       std::tuple<Foo*, int> tuple3(foo.get(), 42);\n//       // Invokes the method Bar on foo with one argument, 42.\n//       absl::apply(&Foo::Bar, tuple3);\n//\n//       std::tuple<int, int> tuple4(8, 9);\n//       // Invokes a lambda.\n//       absl::apply(user_lambda, tuple4);\n//   }\ntemplate <typename Functor, typename Tuple>\nauto apply(Functor&& functor, Tuple&& t)\n    -> decltype(utility_internal::apply_helper(\n        absl::forward<Functor>(functor), absl::forward<Tuple>(t),\n        absl::make_index_sequence<std::tuple_size<\n            typename std::remove_reference<Tuple>::type>::value>{})) {\n  return utility_internal::apply_helper(\n      absl::forward<Functor>(functor), absl::forward<Tuple>(t),\n      absl::make_index_sequence<std::tuple_size<\n          typename std::remove_reference<Tuple>::type>::value>{});\n}\n\n// exchange\n//\n// Replaces the value of `obj` with `new_value` and returns the old value of\n// `obj`.  `absl::exchange` is designed to be a drop-in replacement for C++14's\n// `std::exchange`.\n//\n// Example:\n//\n//   Foo& operator=(Foo&& other) {\n//     ptr1_ = absl::exchange(other.ptr1_, nullptr);\n//     int1_ = absl::exchange(other.int1_, -1);\n//     return *this;\n//   }\ntemplate <typename T, typename U = T>\nT exchange(T& obj, U&& new_value) {\n  T old_value = absl::move(obj);\n  obj = absl::forward<U>(new_value);\n  return old_value;\n}\n\nnamespace utility_internal {\ntemplate <typename T, typename Tuple, size_t... I>\nT make_from_tuple_impl(Tuple&& tup, absl::index_sequence<I...>) {\n  return T(std::get<I>(std::forward<Tuple>(tup))...);\n}\n}  // namespace utility_internal\n\n// make_from_tuple\n//\n// Given the template parameter type `T` and a tuple of arguments\n// `std::tuple(arg0, arg1, ..., argN)` constructs an object of type `T` as if by\n// calling `T(arg0, arg1, ..., argN)`.\n//\n// Example:\n//\n//   std::tuple<const char*, size_t> args(\"hello world\", 5);\n//   auto s = absl::make_from_tuple<std::string>(args);\n//   assert(s == \"hello\");\n//\ntemplate <typename T, typename Tuple>\nconstexpr T make_from_tuple(Tuple&& tup) {\n  return utility_internal::make_from_tuple_impl<T>(\n      std::forward<Tuple>(tup),\n      absl::make_index_sequence<\n          std::tuple_size<absl::decay_t<Tuple>>::value>{});\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04548",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/utility/utility.h",
  "source_line": 178,
  "validation_status": "validated"
}