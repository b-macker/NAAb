{
  "code": "#include <cstddef>\n#include <functional>\n#include <memory>\n#include <string>\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz;\nusing namespace cctz;\nusing namespace time_internal;\nusing namespace absl;\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz_extension;\nusing namespace cctz_extension;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06626_execute() {\n    {\n//   namespace {\n//   std::unique_ptr<cctz::ZoneInfoSource> CustomFactory(\n//       const std::string& name,\n//       const std::function<std::unique_ptr<cctz::ZoneInfoSource>(\n//           const std::string& name)>& fallback_factory) {\n//     if (auto zip = my_factory(name)) return zip;\n//     if (auto zip = fallback_factory(name)) return zip;\n//     if (auto zip = my_other_factory(name)) return zip;\n//     return nullptr;\n//   }\n//   }  // namespace\n//   ZoneInfoSourceFactory zone_info_source_factory = CustomFactory;\n//   }  // namespace cctz_extension\n//\n// This might be used, say, to use zoneinfo data embedded in the program,\n// or read from a (possibly compressed) file archive, or both.\n//\n// cctz_extension::zone_info_source_factory() will be called:\n//   (1) from the same thread as the cctz::load_time_zone() call,\n//   (2) only once for any zone name, and\n//   (3) serially (i.e., no concurrent execution).\n//\n// The fallback factory obtains zoneinfo data by reading files in ${TZDIR},\n// and it is used automatically when no zone_info_source_factory definition\n// is linked into the program.\nextern ZoneInfoSourceFactory zone_info_source_factory;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06626",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/zone_info_source.h",
  "source_line": 69,
  "validation_status": "validated"
}