{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n// A simple ThreadPool implementation for tests.\nclass ThreadPool {\n public:\n  explicit ThreadPool(int num_threads) {\n    threads_.reserve(num_threads);\n    for (int i = 0; i < num_threads; ++i) {\n      threads_.push_back(std::thread(&ThreadPool::WorkLoop, this));\n    }\n  }\n\n  ThreadPool(const ThreadPool &) = delete;\n  ThreadPool &operator=(const ThreadPool &) = delete;\n\n  ~ThreadPool() {\n    {\n      absl::MutexLock l(&mu_);\n      for (size_t i = 0; i < threads_.size(); i++) {\n        queue_.push(nullptr);  // Shutdown signal.\n      }\n    }\n    for (auto &t : threads_) {\n      t.join();\n    }\n  }\n\n  // Schedule a function to be run on a ThreadPool thread immediately.\n  void Schedule(absl::AnyInvocable<void()> func) {\n    assert(func != nullptr);\n    absl::MutexLock l(&mu_);\n    queue_.push(std::move(func));\n  }\n\n private:\n  bool WorkAvailable() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    return !queue_.empty();\n  }\n\n  void WorkLoop() {\n    while (true) {\n      absl::AnyInvocable<void()> func;\n      {\n        absl::MutexLock l(&mu_);\n        mu_.Await(absl::Condition(this, &ThreadPool::WorkAvailable));\n        func = std::move(queue_.front());\n        queue_.pop();\n      }\n      if (func == nullptr) {  // Shutdown signal.\n        break;\n      }\n      func();\n    }\n  }\n\n  absl::Mutex mu_;\n  std::queue<absl::AnyInvocable<void()>> queue_ ABSL_GUARDED_BY(mu_);\n  std::vector<std::thread> threads_;\n};\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06482",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/thread_pool.h",
  "source_line": 30,
  "validation_status": "validated"
}