{
  "code": "{\n public:\n  CommonFields() = default;\n\n  // Not copyable\n  CommonFields(const CommonFields&) = delete;\n  CommonFields& operator=(const CommonFields&) = delete;\n\n  // Movable\n  CommonFields(CommonFields&& that) = default;\n  CommonFields& operator=(CommonFields&&) = default;\n\n  ctrl_t* control() const { return control_; }\n  void set_control(ctrl_t* c) { control_ = c; }\n  void* backing_array_start() const {\n    // growth_left (and maybe infoz) is stored before control bytes.\n    assert(reinterpret_cast<uintptr_t>(control()) % alignof(size_t) == 0);\n    return control() - ControlOffset(has_infoz());\n  }\n\n  // Note: we can't use slots() because Qt defines \"slots\" as a macro.\n  void* slot_array() const { return slots_; }\n  void set_slots(void* s) { slots_ = s; }\n\n  // The number of filled slots.\n  size_t size() const { return size_ >> HasInfozShift(); }\n  void set_size(size_t s) {\n    size_ = (s << HasInfozShift()) | (size_ & HasInfozMask());\n  }\n  void increment_size() {\n    assert(size() < capacity());\n    size_ += size_t{1} << HasInfozShift();\n  }\n  void decrement_size() {\n    assert(size() > 0);\n    size_ -= size_t{1} << HasInfozShift();\n  }\n\n  // The total number of available slots.\n  size_t capacity() const { return capacity_; }\n  void set_capacity(size_t c) {\n    assert(c == 0 || IsValidCapacity(c));\n    capacity_ = c;\n  }\n\n  // The number of slots we can still fill without needing to rehash.\n  // This is stored in the heap allocation before the control bytes.\n  size_t growth_left() const {\n    const size_t* gl_ptr = reinterpret_cast<size_t*>(control()) - 1;\n    assert(reinterpret_cast<uintptr_t>(gl_ptr) % alignof(size_t) == 0);\n    return *gl_ptr;\n  }\n  void set_growth_left(size_t gl) {\n    size_t* gl_ptr = reinterpret_cast<size_t*>(control()) - 1;\n    assert(reinterpret_cast<uintptr_t>(gl_ptr) % alignof(size_t) == 0);\n    *gl_ptr = gl;\n  }\n\n  bool has_infoz() const {\n    return ABSL_PREDICT_FALSE((size_ & HasInfozMask()) != 0);\n  }\n  void set_has_infoz(bool has_infoz) {\n    size_ = (size() << HasInfozShift()) | static_cast<size_t>(has_infoz);\n  }\n\n  HashtablezInfoHandle infoz() {\n    return has_infoz()\n               ? *reinterpret_cast<HashtablezInfoHandle*>(backing_array_start())\n               : HashtablezInfoHandle();\n  }\n  void set_infoz(HashtablezInfoHandle infoz) {\n    assert(has_infoz());\n    *reinterpret_cast<HashtablezInfoHandle*>(backing_array_start()) = infoz;\n  }\n\n  bool should_rehash_for_bug_detection_on_insert() const {\n    return CommonFieldsGenerationInfo::\n        should_rehash_for_bug_detection_on_insert(control(), capacity());\n  }\n  bool should_rehash_for_bug_detection_on_move() const {\n    return CommonFieldsGenerationInfo::\n        should_rehash_for_bug_detection_on_move(control(), capacity());\n  }\n  void maybe_increment_generation_on_move() {\n    if (capacity() == 0) return;\n    increment_generation();\n  }\n  void reset_reserved_growth(size_t reservation) {\n    CommonFieldsGenerationInfo::reset_reserved_growth(reservation, size());\n  }\n\n  // The size of the backing array allocation.\n  size_t alloc_size(size_t slot_size, size_t slot_align) const {\n    return AllocSize(capacity(), slot_size, slot_align, has_infoz());\n  }\n\n  // Returns the number of control bytes set to kDeleted. For testing only.\n  size_t TombstonesCount() const {\n    return static_cast<size_t>(\n        std::count(control(), control() + capacity(), ctrl_t::kDeleted));\n  }\n\n private:\n  // We store the has_infoz bit in the lowest bit of size_.\n  static constexpr size_t HasInfozShift() { return 1; }\n  static constexpr size_t HasInfozMask() {\n    return (size_t{1} << HasInfozShift()) - 1;\n  }\n\n  // TODO(b/182800944): Investigate removing some of these fields:\n  // - control/slots can be derived from each other\n\n  // The control bytes (and, also, a pointer near to the base of the backing\n  // array).\n  //\n  // This contains `capacity + 1 + NumClonedBytes()` entries, even\n  // when the table is empty (hence EmptyGroup).\n  //\n  // Note that growth_left is stored immediately before this pointer.\n  ctrl_t* control_ = EmptyGroup();\n\n  // The beginning of the slots, located at `SlotOffset()` bytes after\n  // `control`. May be null for empty tables.\n  void* slots_ = nullptr;\n\n  // The number of slots in the backing array. This is always 2^N-1 for an\n  // integer N. NOTE: we tried experimenting with compressing the capacity and\n  // storing it together with size_: (a) using 6 bits to store the corresponding\n  // power (N in 2^N-1), and (b) storing 2^N as the most significant bit of\n  // size_ and storing size in the low bits. Both of these experiments were\n  // regressions, presumably because we need capacity to do find operations.\n  size_t capacity_ = 0;\n\n  // The size and also has one bit that stores whether we have infoz.\n  size_t size_ = 0;\n}",
  "id": "BLOCK-CPP-05340",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 1026,
  "validation_status": "validated"
}