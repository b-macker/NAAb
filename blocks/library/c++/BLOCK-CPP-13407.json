{
  "code": "#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <utility>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-13407_execute() {\n    {\n/// StmtVisitorBase - This class implements a simple visitor for Stmt\n/// subclasses. Since Expr derives from Stmt, this also includes support for\n/// visiting Exprs.\ntemplate<template <typename> class Ptr, typename ImplClass, typename RetTy=void,\n         class... ParamTys>\nclass StmtVisitorBase {\npublic:\n#define PTR(CLASS) typename Ptr<CLASS>::type\n#define DISPATCH(NAME, CLASS) \\\n  return static_cast<ImplClass*>(this)->Visit ## NAME( \\\n    static_cast<PTR(CLASS)>(S), std::forward<ParamTys>(P)...)\n\n  RetTy Visit(PTR(Stmt) S, ParamTys... P) {\n    // If we have a binary expr, dispatch to the subcode of the binop.  A smart\n    // optimizer (e.g. LLVM) will fold this comparison into the switch stmt\n    // below.\n    if (PTR(BinaryOperator) BinOp = dyn_cast<BinaryOperator>(S)) {\n      switch (BinOp->getOpcode()) {\n      case BO_PtrMemD:   DISPATCH(BinPtrMemD,   BinaryOperator);\n      case BO_PtrMemI:   DISPATCH(BinPtrMemI,   BinaryOperator);\n      case BO_Mul:       DISPATCH(BinMul,       BinaryOperator);\n      case BO_Div:       DISPATCH(BinDiv,       BinaryOperator);\n      case BO_Rem:       DISPATCH(BinRem,       BinaryOperator);\n      case BO_Add:       DISPATCH(BinAdd,       BinaryOperator);\n      case BO_Sub:       DISPATCH(BinSub,       BinaryOperator);\n      case BO_Shl:       DISPATCH(BinShl,       BinaryOperator);\n      case BO_Shr:       DISPATCH(BinShr,       BinaryOperator);\n\n      case BO_LT:        DISPATCH(BinLT,        BinaryOperator);\n      case BO_GT:        DISPATCH(BinGT,        BinaryOperator);\n      case BO_LE:        DISPATCH(BinLE,        BinaryOperator);\n      case BO_GE:        DISPATCH(BinGE,        BinaryOperator);\n      case BO_EQ:        DISPATCH(BinEQ,        BinaryOperator);\n      case BO_NE:        DISPATCH(BinNE,        BinaryOperator);\n      case BO_Cmp:       DISPATCH(BinCmp,       BinaryOperator);\n\n      case BO_And:       DISPATCH(BinAnd,       BinaryOperator);\n      case BO_Xor:       DISPATCH(BinXor,       BinaryOperator);\n      case BO_Or :       DISPATCH(BinOr,        BinaryOperator);\n      case BO_LAnd:      DISPATCH(BinLAnd,      BinaryOperator);\n      case BO_LOr :      DISPATCH(BinLOr,       BinaryOperator);\n      case BO_Assign:    DISPATCH(BinAssign,    BinaryOperator);\n      case BO_MulAssign: DISPATCH(BinMulAssign, CompoundAssignOperator);\n      case BO_DivAssign: DISPATCH(BinDivAssign, CompoundAssignOperator);\n      case BO_RemAssign: DISPATCH(BinRemAssign, CompoundAssignOperator);\n      case BO_AddAssign: DISPATCH(BinAddAssign, CompoundAssignOperator);\n      case BO_SubAssign: DISPATCH(BinSubAssign, CompoundAssignOperator);\n      case BO_ShlAssign: DISPATCH(BinShlAssign, CompoundAssignOperator);\n      case BO_ShrAssign: DISPATCH(BinShrAssign, CompoundAssignOperator);\n      case BO_AndAssign: DISPATCH(BinAndAssign, CompoundAssignOperator);\n      case BO_OrAssign:  DISPATCH(BinOrAssign,  CompoundAssignOperator);\n      case BO_XorAssign: DISPATCH(BinXorAssign, CompoundAssignOperator);\n      case BO_Comma:     DISPATCH(BinComma,     BinaryOperator);\n      }\n    } else if (PTR(UnaryOperator) UnOp = dyn_cast<UnaryOperator>(S)) {\n      switch (UnOp->getOpcode()) {\n      case UO_PostInc:   DISPATCH(UnaryPostInc,   UnaryOperator);\n      case UO_PostDec:   DISPATCH(UnaryPostDec,   UnaryOperator);\n      case UO_PreInc:    DISPATCH(UnaryPreInc,    UnaryOperator);\n      case UO_PreDec:    DISPATCH(UnaryPreDec,    UnaryOperator);\n      case UO_AddrOf:    DISPATCH(UnaryAddrOf,    UnaryOperator);\n      case UO_Deref:     DISPATCH(UnaryDeref,     UnaryOperator);\n      case UO_Plus:      DISPATCH(UnaryPlus,      UnaryOperator);\n      case UO_Minus:     DISPATCH(UnaryMinus,     UnaryOperator);\n      case UO_Not:       DISPATCH(UnaryNot,       UnaryOperator);\n      case UO_LNot:      DISPATCH(UnaryLNot,      UnaryOperator);\n      case UO_Real:      DISPATCH(UnaryReal,      UnaryOperator);\n      case UO_Imag:      DISPATCH(UnaryImag,      UnaryOperator);\n      case UO_Extension: DISPATCH(UnaryExtension, UnaryOperator);\n      case UO_Coawait:   DISPATCH(UnaryCoawait,   UnaryOperator);\n      }\n    }\n\n    // Top switch stmt: dispatch to VisitFooStmt for each FooStmt.\n    switch (S->getStmtClass()) {\n    default: llvm_unreachable(\"Unknown stmt kind!\");\n#define ABSTRACT_STMT(STMT)\n#define STMT(CLASS, PARENT)                              \\\n    case Stmt::CLASS ## Class: DISPATCH(CLASS, CLASS);\n#include \"clang/AST/StmtNodes.inc\"\n    }\n  }\n\n  // If the implementation chooses not to implement a certain visit method, fall\n  // back on VisitExpr or whatever else is the superclass.\n#define STMT(CLASS, PARENT)                                   \\\n  RetTy Visit ## CLASS(PTR(CLASS) S, ParamTys... P) { DISPATCH(PARENT, PARENT); }\n#include \"clang/AST/StmtNodes.inc\"\n\n  // If the implementation doesn't implement binary operator methods, fall back\n  // on VisitBinaryOperator.\n#define BINOP_FALLBACK(NAME) \\\n  RetTy VisitBin ## NAME(PTR(BinaryOperator) S, ParamTys... P) { \\\n    DISPATCH(BinaryOperator, BinaryOperator); \\\n  }\n  BINOP_FALLBACK(PtrMemD)                    BINOP_FALLBACK(PtrMemI)\n  BINOP_FALLBACK(Mul)   BINOP_FALLBACK(Div)  BINOP_FALLBACK(Rem)\n  BINOP_FALLBACK(Add)   BINOP_FALLBACK(Sub)  BINOP_FALLBACK(Shl)\n  BINOP_FALLBACK(Shr)\n\n  BINOP_FALLBACK(LT)    BINOP_FALLBACK(GT)   BINOP_FALLBACK(LE)\n  BINOP_FALLBACK(GE)    BINOP_FALLBACK(EQ)   BINOP_FALLBACK(NE)\n  BINOP_FALLBACK(Cmp)\n\n  BINOP_FALLBACK(And)   BINOP_FALLBACK(Xor)  BINOP_FALLBACK(Or)\n  BINOP_FALLBACK(LAnd)  BINOP_FALLBACK(LOr)\n\n  BINOP_FALLBACK(Assign)\n  BINOP_FALLBACK(Comma)\n#undef BINOP_FALLBACK\n\n  // If the implementation doesn't implement compound assignment operator\n  // methods, fall back on VisitCompoundAssignOperator.\n#define CAO_FALLBACK(NAME) \\\n  RetTy VisitBin ## NAME(PTR(CompoundAssignOperator) S, ParamTys... P) { \\\n    DISPATCH(CompoundAssignOperator, CompoundAssignOperator); \\\n  }\n  CAO_FALLBACK(MulAssign) CAO_FALLBACK(DivAssign) CAO_FALLBACK(RemAssign)\n  CAO_FALLBACK(AddAssign) CAO_FALLBACK(SubAssign) CAO_FALLBACK(ShlAssign)\n  CAO_FALLBACK(ShrAssign) CAO_FALLBACK(AndAssign) CAO_FALLBACK(OrAssign)\n  CAO_FALLBACK(XorAssign)\n#undef CAO_FALLBACK\n\n  // If the implementation doesn't implement unary operator methods, fall back\n  // on VisitUnaryOperator.\n#define UNARYOP_FALLBACK(NAME) \\\n  RetTy VisitUnary ## NAME(PTR(UnaryOperator) S, ParamTys... P) { \\\n    DISPATCH(UnaryOperator, UnaryOperator);    \\\n  }\n  UNARYOP_FALLBACK(PostInc)   UNARYOP_FALLBACK(PostDec)\n  UNARYOP_FALLBACK(PreInc)    UNARYOP_FALLBACK(PreDec)\n  UNARYOP_FALLBACK(AddrOf)    UNARYOP_FALLBACK(Deref)\n\n  UNARYOP_FALLBACK(Plus)      UNARYOP_FALLBACK(Minus)\n  UNARYOP_FALLBACK(Not)       UNARYOP_FALLBACK(LNot)\n  UNARYOP_FALLBACK(Real)      UNARYOP_FALLBACK(Imag)\n  UNARYOP_FALLBACK(Extension) UNARYOP_FALLBACK(Coawait)\n#undef UNARYOP_FALLBACK\n\n  // Base case, ignore it. :)\n  RetTy VisitStmt(PTR(Stmt) Node, ParamTys... P) { return RetTy(); }\n\n#undef PTR\n#undef DISPATCH\n};\n\n/// StmtVisitor - This class implements a simple visitor for Stmt subclasses.\n/// Since Expr derives from Stmt, this also includes support for visiting Exprs.\n///\n/// This class does not preserve constness of Stmt pointers (see also\n/// ConstStmtVisitor).\ntemplate <typename ImplClass, typename RetTy = void, typename... ParamTys>\nclass StmtVisitor\n    : public StmtVisitorBase<std::add_pointer, ImplClass, RetTy, ParamTys...> {\n};\n\n/// ConstStmtVisitor - This class implements a simple visitor for Stmt\n/// subclasses. Since Expr derives from Stmt, this also includes support for\n/// visiting Exprs.\n///\n/// This class preserves constness of Stmt pointers (see also StmtVisitor).\ntemplate <typename ImplClass, typename RetTy = void, typename... ParamTys>\nclass ConstStmtVisitor : public StmtVisitorBase<llvm::make_const_ptr, ImplClass,\n                                                RetTy, ParamTys...> {};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-13407",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtVisitor.h",
  "source_line": 30,
  "validation_status": "validated"
}