{
  "code": "{\n\nclass formatter;\n\nnamespace sinks {\nclass sink;\n}\n\n#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\nusing filename_t = std::wstring;\n    // allow macro expansion to occur in SPDLOG_FILENAME_T\n    #define SPDLOG_FILENAME_T_INNER(s) L##s\n    #define SPDLOG_FILENAME_T(s) SPDLOG_FILENAME_T_INNER(s)\n#else\nusing filename_t = std::string;\n    #define SPDLOG_FILENAME_T(s) s\n#endif\n\nusing log_clock = std::chrono::system_clock;\nusing sink_ptr = std::shared_ptr<sinks::sink>;\nusing sinks_init_list = std::initializer_list<sink_ptr>;\nusing err_handler = std::function<void(const std::string &err_msg)>;\n#ifdef SPDLOG_USE_STD_FORMAT\nnamespace fmt_lib = std;\n\nusing string_view_t = std::string_view;\nusing memory_buf_t = std::string;\n\ntemplate <typename... Args>\n    #if __cpp_lib_format >= 202207L\nusing format_string_t = std::format_string<Args...>;\n    #else\nusing format_string_t = std::string_view;\n    #endif\n\ntemplate <class T, class Char = char>\nstruct is_convertible_to_basic_format_string\n    : std::integral_constant<bool, std::is_convertible<T, std::basic_string_view<Char>>::value> {};\n\n    #if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\nusing wstring_view_t = std::wstring_view;\nusing wmemory_buf_t = std::wstring;\n\ntemplate <typename... Args>\n        #if __cpp_lib_format >= 202207L\nusing wformat_string_t = std::wformat_string<Args...>;\n        #else\nusing wformat_string_t = std::wstring_view;\n        #endif\n    #endif\n    #define SPDLOG_BUF_TO_STRING(x) x\n#else  // use fmt lib instead of std::format\nnamespace fmt_lib = fmt;\n\nusing string_view_t = fmt::basic_string_view<char>;\nusing memory_buf_t = fmt::basic_memory_buffer<char, 250>;\n\ntemplate <typename... Args>\nusing format_string_t = fmt::format_string<Args...>;\n\ntemplate <class T>\nusing remove_cvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n\ntemplate <typename Char>\n    #if FMT_VERSION >= 90101\nusing fmt_runtime_string = fmt::runtime_format_string<Char>;\n    #else\nusing fmt_runtime_string = fmt::basic_runtime<Char>;\n    #endif\n\n// clang doesn't like SFINAE disabled constructor in std::is_convertible<> so have to repeat the\n// condition from basic_format_string here, in addition, fmt::basic_runtime<Char> is only\n// convertible to basic_format_string<Char> but not basic_string_view<Char>\ntemplate <class T, class Char = char>\nstruct is_convertible_to_basic_format_string\n    : std::integral_constant<bool,\n                             std::is_convertible<T, fmt::basic_string_view<Char>>::value ||\n                                 std::is_same<remove_cvref_t<T>, fmt_runtime_string<Char>>::value> {\n};\n\n    #if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\nusing wstring_view_t = fmt::basic_string_view<wchar_t>;\nusing wmemory_buf_t = fmt::basic_memory_buffer<wchar_t, 250>;\n\ntemplate <typename... Args>\nusing wformat_string_t = fmt::wformat_string<Args...>;\n    #endif\n    #define SPDLOG_BUF_TO_STRING(x) fmt::to_string(x)\n#endif\n\n#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\n    #ifndef _WIN32\n        #error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows\n    #endif  // _WIN32\n#endif      // SPDLOG_WCHAR_TO_UTF8_SUPPORT\n\ntemplate <class T>\nstruct is_convertible_to_any_format_string\n    : std::integral_constant<bool,\n                             is_convertible_to_basic_format_string<T, char>::value ||\n                                 is_convertible_to_basic_format_string<T, wchar_t>::value> {};\n\n#if defined(SPDLOG_NO_ATOMIC_LEVELS)\nusing level_t = details::null_atomic_int;\n#else\nusing level_t = std::atomic<int>;\n#endif\n\n#define SPDLOG_LEVEL_TRACE 0\n#define SPDLOG_LEVEL_DEBUG 1\n#define SPDLOG_LEVEL_INFO 2\n#define SPDLOG_LEVEL_WARN 3\n#define SPDLOG_LEVEL_ERROR 4\n#define SPDLOG_LEVEL_CRITICAL 5\n#define SPDLOG_LEVEL_OFF 6\n\n#if !defined(SPDLOG_ACTIVE_LEVEL)\n    #define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO\n#endif\n\n// Log level enum\nnamespace level {\nenum level_enum : int {\n    trace = SPDLOG_LEVEL_TRACE,\n    debug = SPDLOG_LEVEL_DEBUG,\n    info = SPDLOG_LEVEL_INFO,\n    warn = SPDLOG_LEVEL_WARN,\n    err = SPDLOG_LEVEL_ERROR,\n    critical = SPDLOG_LEVEL_CRITICAL,\n    off = SPDLOG_LEVEL_OFF,\n    n_levels\n};\n\n#define SPDLOG_LEVEL_NAME_TRACE spdlog::string_view_t(\"trace\", 5)\n#define SPDLOG_LEVEL_NAME_DEBUG spdlog::string_view_t(\"debug\", 5)\n#define SPDLOG_LEVEL_NAME_INFO spdlog::string_view_t(\"info\", 4)\n#define SPDLOG_LEVEL_NAME_WARNING spdlog::string_view_t(\"warning\", 7)\n#define SPDLOG_LEVEL_NAME_ERROR spdlog::string_view_t(\"error\", 5)\n#define SPDLOG_LEVEL_NAME_CRITICAL spdlog::string_view_t(\"critical\", 8)\n#define SPDLOG_LEVEL_NAME_OFF spdlog::string_view_t(\"off\", 3)\n\n#if !defined(SPDLOG_LEVEL_NAMES)\n    #define SPDLOG_LEVEL_NAMES                                                                  \\\n        {                                                                                       \\\n            SPDLOG_LEVEL_NAME_TRACE, SPDLOG_LEVEL_NAME_DEBUG, SPDLOG_LEVEL_NAME_INFO,           \\\n                SPDLOG_LEVEL_NAME_WARNING, SPDLOG_LEVEL_NAME_ERROR, SPDLOG_LEVEL_NAME_CRITICAL, \\\n                SPDLOG_LEVEL_NAME_OFF                                                           \\\n        }\n#endif\n\n#if !defined(SPDLOG_SHORT_LEVEL_NAMES)\n\n    #define SPDLOG_SHORT_LEVEL_NAMES \\\n        { \"T\", \"D\", \"I\", \"W\", \"E\", \"C\", \"O\" }\n#endif\n\nSPDLOG_API const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;\nSPDLOG_API const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;\nSPDLOG_API spdlog::level::level_enum from_str(const std::string &name) SPDLOG_NOEXCEPT;\n\n}  // namespace level\n\n//\n// Color mode used by sinks with color support.\n//\nenum class color_mode { always, automatic, never };\n\n//\n// Pattern time - specific time getting to use for pattern_formatter.\n// local time by default\n//\nenum class pattern_time_type {\n    local,  // log localtime\n    utc     // log utc\n};\n\n//\n// Log exception\n//\nclass SPDLOG_API spdlog_ex : public std::exception {\npublic:\n    explicit spdlog_ex(std::string msg);\n    spdlog_ex(const std::string &msg, int last_errno);\n    const char *what() const SPDLOG_NOEXCEPT override;\n\nprivate:\n    std::string msg_;\n};\n\n[[noreturn]] SPDLOG_API void throw_spdlog_ex(const std::string &msg, int last_errno);\n[[noreturn]] SPDLOG_API void throw_spdlog_ex(std::string msg);\n\nstruct source_loc {\n    SPDLOG_CONSTEXPR source_loc() = default;\n    SPDLOG_CONSTEXPR source_loc(const char *filename_in, int line_in, const char *funcname_in)\n        : filename{filename_in},\n          line{line_in},\n          funcname{funcname_in} {}\n\n    SPDLOG_CONSTEXPR bool empty() const SPDLOG_NOEXCEPT { return line == 0; }\n    const char *filename{nullptr};\n    int line{0};\n    const char *funcname{nullptr};\n};\n\nstruct file_event_handlers {\n    file_event_handlers()\n        : before_open(nullptr),\n          after_open(nullptr),\n          before_close(nullptr),\n          after_close(nullptr) {}\n\n    std::function<void(const filename_t &filename)> before_open;\n    std::function<void(const filename_t &filename, std::FILE *file_stream)> after_open;\n    std::function<void(const filename_t &filename, std::FILE *file_stream)> before_close;\n    std::function<void(const filename_t &filename)> after_close;\n};\n\nnamespace details {\n\n// to_string_view\n\nSPDLOG_CONSTEXPR_FUNC spdlog::string_view_t to_string_view(const memory_buf_t &buf)\n    SPDLOG_NOEXCEPT {\n    return spdlog::string_view_t{buf.data(), buf.size()};\n}\n\nSPDLOG_CONSTEXPR_FUNC spdlog::string_view_t to_string_view(spdlog::string_view_t str)\n    SPDLOG_NOEXCEPT {\n    return str;\n}\n\n#if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\nSPDLOG_CONSTEXPR_FUNC spdlog::wstring_view_t to_string_view(const wmemory_buf_t &buf)\n    SPDLOG_NOEXCEPT {\n    return spdlog::wstring_view_t{buf.data(), buf.size()};\n}\n\nSPDLOG_CONSTEXPR_FUNC spdlog::wstring_view_t to_string_view(spdlog::wstring_view_t str)\n    SPDLOG_NOEXCEPT {\n    return str;\n}\n#endif\n\n#ifndef SPDLOG_USE_STD_FORMAT\ntemplate <typename T, typename... Args>\ninline fmt::basic_string_view<T> to_string_view(fmt::basic_format_string<T, Args...> fmt) {\n    return fmt;\n}\n#elif __cpp_lib_format >= 202207L\ntemplate <typename T, typename... Args>\nSPDLOG_CONSTEXPR_FUNC std::basic_string_view<T> to_string_view(\n    std::basic_format_string<T, Args...> fmt) SPDLOG_NOEXCEPT {\n    return fmt.get();\n}\n#endif\n\n// make_unique support for pre c++14\n#if __cplusplus >= 201402L  // C++14 and beyond\nusing std::enable_if_t;\nusing std::make_unique;\n#else\ntemplate <bool B, class T = void>\nusing enable_if_t = typename std::enable_if<B, T>::type;\n\ntemplate <typename T, typename... Args>\nstd::unique_ptr<T> make_unique(Args &&...args) {\n    static_assert(!std::is_array<T>::value, \"arrays not supported\");\n    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n}\n#endif\n\n// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)\ntemplate <typename T, typename U, enable_if_t<!std::is_same<T, U>::value, int> = 0>\nconstexpr T conditional_static_cast(U value) {\n    return static_cast<T>(value);\n}\n\ntemplate <typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>\nconstexpr T conditional_static_cast(U value) {\n    return value;\n}\n\n}  // namespace details\n}",
  "id": "BLOCK-CPP-00024",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/common.h",
  "source_line": 123,
  "validation_status": "validated"
}