{
  "code": "{\n\n// A simple fixed size array class that does not manage its own memory,\n// suitable for use with bump pointer allocation.\ntemplate <class T> class SimpleArray {\npublic:\n  SimpleArray() = default;\n  SimpleArray(T *Dat, size_t Cp, size_t Sz = 0)\n      : Data(Dat), Size(Sz), Capacity(Cp) {}\n  SimpleArray(MemRegionRef A, size_t Cp)\n      : Data(Cp == 0 ? nullptr : A.allocateT<T>(Cp)), Capacity(Cp) {}\n  SimpleArray(const SimpleArray<T> &A) = delete;\n\n  SimpleArray(SimpleArray<T> &&A)\n      : Data(A.Data), Size(A.Size), Capacity(A.Capacity) {\n    A.Data = nullptr;\n    A.Size = 0;\n    A.Capacity = 0;\n  }\n\n  SimpleArray &operator=(SimpleArray &&RHS) {\n    if (this != &RHS) {\n      Data = RHS.Data;\n      Size = RHS.Size;\n      Capacity = RHS.Capacity;\n\n      RHS.Data = nullptr;\n      RHS.Size = RHS.Capacity = 0;\n    }\n    return *this;\n  }\n\n  // Reserve space for at least Ncp items, reallocating if necessary.\n  void reserve(size_t Ncp, MemRegionRef A) {\n    if (Ncp <= Capacity)\n      return;\n    T *Odata = Data;\n    Data = A.allocateT<T>(Ncp);\n    Capacity = Ncp;\n    memcpy(Data, Odata, sizeof(T) * Size);\n  }\n\n  // Reserve space for at least N more items.\n  void reserveCheck(size_t N, MemRegionRef A) {\n    if (Capacity == 0)\n      reserve(u_max(InitialCapacity, N), A);\n    else if (Size + N < Capacity)\n      reserve(u_max(Size + N, Capacity * 2), A);\n  }\n\n  using iterator = T *;\n  using const_iterator = const T *;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  size_t size() const { return Size; }\n  size_t capacity() const { return Capacity; }\n\n  T &operator[](unsigned i) {\n    assert(i < Size && \"Array index out of bounds.\");\n    return Data[i];\n  }\n\n  const T &operator[](unsigned i) const {\n    assert(i < Size && \"Array index out of bounds.\");\n    return Data[i];\n  }\n\n  T &back() {\n    assert(Size && \"No elements in the array.\");\n    return Data[Size - 1];\n  }\n\n  const T &back() const {\n    assert(Size && \"No elements in the array.\");\n    return Data[Size - 1];\n  }\n\n  iterator begin() { return Data; }\n  iterator end() { return Data + Size; }\n\n  const_iterator begin() const { return Data; }\n  const_iterator end() const { return Data + Size; }\n\n  const_iterator cbegin() const { return Data; }\n  const_iterator cend() const { return Data + Size; }\n\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  void push_back(const T &Elem) {\n    assert(Size < Capacity);\n    Data[Size++] = Elem;\n  }\n\n  // drop last n elements from array\n  void drop(unsigned n = 0) {\n    assert(Size > n);\n    Size -= n;\n  }\n\n  void setValues(unsigned Sz, const T& C) {\n    assert(Sz <= Capacity);\n    Size = Sz;\n    for (unsigned i = 0; i < Sz; ++i) {\n      Data[i] = C;\n    }\n  }\n\n  template <class Iter> unsigned append(Iter I, Iter E) {\n    size_t Osz = Size;\n    size_t J = Osz;\n    for (; J < Capacity && I != E; ++J, ++I)\n      Data[J] = *I;\n    Size = J;\n    return J - Osz;\n  }\n\n  llvm::iterator_range<reverse_iterator> reverse() {\n    return llvm::reverse(*this);\n  }\n\n  llvm::iterator_range<const_reverse_iterator> reverse() const {\n    return llvm::reverse(*this);\n  }\n\nprivate:\n  // std::max is annoying here, because it requires a reference,\n  // thus forcing InitialCapacity to be initialized outside the .h file.\n  size_t u_max(size_t i, size_t j) { return (i < j) ? j : i; }\n\n  static const size_t InitialCapacity = 4;\n\n  T *Data = nullptr;\n  size_t Size = 0;\n  size_t Capacity = 0;\n};\n\n}",
  "id": "BLOCK-CPP-21850",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h",
  "source_line": 80,
  "validation_status": "validated"
}