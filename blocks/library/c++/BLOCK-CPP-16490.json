{
  "code": "{\n  friend class Diagnostic;\n  friend class SelectorTable; // only the SelectorTable can create these\n  friend class DeclarationName; // and the AST's DeclarationName.\n\n  enum IdentifierInfoFlag {\n    // Empty selector = 0. Note that these enumeration values must\n    // correspond to the enumeration values of DeclarationName::StoredNameKind\n    ZeroArg  = 0x01,\n    OneArg   = 0x02,\n    MultiArg = 0x07,\n    ArgFlags = 0x07\n  };\n\n  /// A pointer to the MultiKeywordSelector or IdentifierInfo. We use the low\n  /// three bits of InfoPtr to store an IdentifierInfoFlag. Note that in any\n  /// case IdentifierInfo and MultiKeywordSelector are already aligned to\n  /// 8 bytes even on 32 bits archs because of DeclarationName.\n  uintptr_t InfoPtr = 0;\n\n  Selector(IdentifierInfo *II, unsigned nArgs) {\n    InfoPtr = reinterpret_cast<uintptr_t>(II);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    assert(nArgs < 2 && \"nArgs not equal to 0/1\");\n    InfoPtr |= nArgs+1;\n  }\n\n  Selector(MultiKeywordSelector *SI) {\n    InfoPtr = reinterpret_cast<uintptr_t>(SI);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    InfoPtr |= MultiArg;\n  }\n\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (getIdentifierInfoFlag() < MultiArg)\n      return reinterpret_cast<IdentifierInfo *>(InfoPtr & ~ArgFlags);\n    return nullptr;\n  }\n\n  MultiKeywordSelector *getMultiKeywordSelector() const {\n    return reinterpret_cast<MultiKeywordSelector *>(InfoPtr & ~ArgFlags);\n  }\n\n  unsigned getIdentifierInfoFlag() const {\n    return InfoPtr & ArgFlags;\n  }\n\n  static ObjCMethodFamily getMethodFamilyImpl(Selector sel);\n\n  static ObjCStringFormatFamily getStringFormatFamilyImpl(Selector sel);\n\npublic:\n  /// The default ctor should only be used when creating data structures that\n  ///  will contain selectors.\n  Selector() = default;\n  explicit Selector(uintptr_t V) : InfoPtr(V) {}\n\n  /// operator==/!= - Indicate whether the specified selectors are identical.\n  bool operator==(Selector RHS) const {\n    return InfoPtr == RHS.InfoPtr;\n  }\n  bool operator!=(Selector RHS) const {\n    return InfoPtr != RHS.InfoPtr;\n  }\n\n  void *getAsOpaquePtr() const {\n    return reinterpret_cast<void*>(InfoPtr);\n  }\n\n  /// Determine whether this is the empty selector.\n  bool isNull() const { return InfoPtr == 0; }\n\n  // Predicates to identify the selector type.\n  bool isKeywordSelector() const {\n    return getIdentifierInfoFlag() != ZeroArg;\n  }\n\n  bool isUnarySelector() const {\n    return getIdentifierInfoFlag() == ZeroArg;\n  }\n\n  /// If this selector is the specific keyword selector described by Names.\n  bool isKeywordSelector(ArrayRef<StringRef> Names) const;\n\n  /// If this selector is the specific unary selector described by Name.\n  bool isUnarySelector(StringRef Name) const;\n\n  unsigned getNumArgs() const;\n\n  /// Retrieve the identifier at a given position in the selector.\n  ///\n  /// Note that the identifier pointer returned may be NULL. Clients that only\n  /// care about the text of the identifier string, and not the specific,\n  /// uniqued identifier pointer, should use \\c getNameForSlot(), which returns\n  /// an empty string when the identifier pointer would be NULL.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the identifier.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the uniqued identifier for this slot, or NULL if this slot has\n  /// no corresponding identifier.\n  IdentifierInfo *getIdentifierInfoForSlot(unsigned argIndex) const;\n\n  /// Retrieve the name at a given position in the selector.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the name.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the name for this slot, which may be the empty string if no\n  /// name was supplied.\n  StringRef getNameForSlot(unsigned argIndex) const;\n\n  /// Derive the full selector name (e.g. \"foo:bar:\") and return\n  /// it as an std::string.\n  std::string getAsString() const;\n\n  /// Prints the full selector name (e.g. \"foo:bar:\").\n  void print(llvm::raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Derive the conventional family of this method.\n  ObjCMethodFamily getMethodFamily() const {\n    return getMethodFamilyImpl(*this);\n  }\n\n  ObjCStringFormatFamily getStringFormatFamily() const {\n    return getStringFormatFamilyImpl(*this);\n  }\n\n  static Selector getEmptyMarker() {\n    return Selector(uintptr_t(-1));\n  }\n\n  static Selector getTombstoneMarker() {\n    return Selector(uintptr_t(-2));\n  }\n\n  static ObjCInstanceTypeFamily getInstTypeMethodFamily(Selector sel);\n}",
  "id": "BLOCK-CPP-16490",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/IdentifierTable.h",
  "source_line": 801,
  "validation_status": "validated"
}