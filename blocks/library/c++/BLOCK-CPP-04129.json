{
  "code": "{\n//     if (use_hex) return MyFormat(\"foo %x bar\");\n//     return MyFormat(\"foo %d bar\");\n//   }\n//   // `format` can be used with any value that supports 'd' and 'x',\n//   // like `int`.\n//   auto format = GetFormat(use_hex);\n//   value = StringF(format, i);\ntemplate <auto... Conv>\nusing ParsedFormat = absl::str_format_internal::ExtendedParsedFormat<\n    absl::str_format_internal::ToFormatConversionCharSet(Conv)...>;\n#else\ntemplate <char... Conv>\nusing ParsedFormat = str_format_internal::ExtendedParsedFormat<\n    absl::str_format_internal::ToFormatConversionCharSet(Conv)...>;\n#endif  // defined(__cpp_nontype_template_parameter_auto)\n\n// StrFormat()\n//\n// Returns a `string` given a `printf()`-style format string and zero or more\n// additional arguments. Use it as you would `sprintf()`. `StrFormat()` is the\n// primary formatting function within the `str_format` library, and should be\n// used in most cases where you need type-safe conversion of types into\n// formatted strings.\n//\n// The format string generally consists of ordinary character data along with\n// one or more format conversion specifiers (denoted by the `%` character).\n// Ordinary character data is returned unchanged into the result string, while\n// each conversion specification performs a type substitution from\n// `StrFormat()`'s other arguments. See the comments for `FormatSpec` for full\n// information on the makeup of this format string.\n//\n// Example:\n//\n//   std::string s = absl::StrFormat(\n//       \"Welcome to %s, Number %d!\", \"The Village\", 6);\n//   EXPECT_EQ(\"Welcome to The Village, Number 6!\", s);\n//\n// Returns an empty string in case of error.\ntemplate <typename... Args>\nABSL_MUST_USE_RESULT std::string StrFormat(const FormatSpec<Args...>& format,\n                                           const Args&... args) {\n  return str_format_internal::FormatPack(\n      str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// StrAppendFormat()\n//\n// Appends to a `dst` string given a format string, and zero or more additional\n// arguments, returning `*dst` as a convenience for chaining purposes. Appends\n// nothing in case of error (but possibly alters its capacity).\n//\n// Example:\n//\n//   std::string orig(\"For example PI is approximately \");\n//   std::cout << StrAppendFormat(&orig, \"%12.6f\", 3.14);\ntemplate <typename... Args>\nstd::string& StrAppendFormat(absl::Nonnull<std::string*> dst,\n                             const FormatSpec<Args...>& format,\n                             const Args&... args) {\n  return str_format_internal::AppendPack(\n      dst, str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// StreamFormat()\n//\n// Writes to an output stream given a format string and zero or more arguments,\n// generally in a manner that is more efficient than streaming the result of\n// `absl::StrFormat()`. The returned object must be streamed before the full\n// expression ends.\n//\n// Example:\n//\n//   std::cout << StreamFormat(\"%12.6f\", 3.14);\ntemplate <typename... Args>\nABSL_MUST_USE_RESULT str_format_internal::Streamable StreamFormat(\n    const FormatSpec<Args...>& format, const Args&... args) {\n  return str_format_internal::Streamable(\n      str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// PrintF()\n//\n// Writes to stdout given a format string and zero or more arguments. This\n// function is functionally equivalent to `std::printf()` (and type-safe);\n// prefer `absl::PrintF()` over `std::printf()`.\n//\n// Example:\n//\n//   std::string_view s = \"Ulaanbaatar\";\n//   absl::PrintF(\"The capital of Mongolia is %s\", s);\n//\n//   Outputs: \"The capital of Mongolia is Ulaanbaatar\"\n//\ntemplate <typename... Args>\nint PrintF(const FormatSpec<Args...>& format, const Args&... args) {\n  return str_format_internal::FprintF(\n      stdout, str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// FPrintF()\n//\n// Writes to a file given a format string and zero or more arguments. This\n// function is functionally equivalent to `std::fprintf()` (and type-safe);\n// prefer `absl::FPrintF()` over `std::fprintf()`.\n//\n// Example:\n//\n//   std::string_view s = \"Ulaanbaatar\";\n//   absl::FPrintF(stdout, \"The capital of Mongolia is %s\", s);\n//\n//   Outputs: \"The capital of Mongolia is Ulaanbaatar\"\n//\ntemplate <typename... Args>\nint FPrintF(absl::Nonnull<std::FILE*> output, const FormatSpec<Args...>& format,\n            const Args&... args) {\n  return str_format_internal::FprintF(\n      output, str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// SNPrintF()\n//\n// Writes to a sized buffer given a format string and zero or more arguments.\n// This function is functionally equivalent to `std::snprintf()` (and\n// type-safe); prefer `absl::SNPrintF()` over `std::snprintf()`.\n//\n// In particular, a successful call to `absl::SNPrintF()` writes at most `size`\n// bytes of the formatted output to `output`, including a NUL-terminator, and\n// returns the number of bytes that would have been written if truncation did\n// not occur. In the event of an error, a negative value is returned and `errno`\n// is set.\n//\n// Example:\n//\n//   std::string_view s = \"Ulaanbaatar\";\n//   char output[128];\n//   absl::SNPrintF(output, sizeof(output),\n//                  \"The capital of Mongolia is %s\", s);\n//\n//   Post-condition: output == \"The capital of Mongolia is Ulaanbaatar\"\n//\ntemplate <typename... Args>\nint SNPrintF(absl::Nonnull<char*> output, std::size_t size,\n             const FormatSpec<Args...>& format, const Args&... args) {\n  return str_format_internal::SnprintF(\n      output, size, str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// -----------------------------------------------------------------------------\n// Custom Output Formatting Functions\n// -----------------------------------------------------------------------------\n\n// FormatRawSink\n//\n// FormatRawSink is a type erased wrapper around arbitrary sink objects\n// specifically used as an argument to `Format()`.\n//\n// All the object has to do define an overload of `AbslFormatFlush()` for the\n// sink, usually by adding a ADL-based free function in the same namespace as\n// the sink:\n//\n//   void AbslFormatFlush(MySink* dest, absl::string_view part);\n//\n// where `dest` is the pointer passed to `absl::Format()`. The function should\n// append `part` to `dest`.\n//\n// FormatRawSink does not own the passed sink object. The passed object must\n// outlive the FormatRawSink.\nclass FormatRawSink {\n public:\n  // Implicitly convert from any type that provides the hook function as\n  // described above.\n  template <typename T,\n            typename = typename std::enable_if<std::is_constructible<\n                str_format_internal::FormatRawSinkImpl, T*>::value>::type>\n  FormatRawSink(absl::Nonnull<T*> raw)  // NOLINT\n      : sink_(raw) {}\n\n private:\n  friend str_format_internal::FormatRawSinkImpl;\n  str_format_internal::FormatRawSinkImpl sink_;\n};\n\n// Format()\n//\n// Writes a formatted string to an arbitrary sink object (implementing the\n// `absl::FormatRawSink` interface), using a format string and zero or more\n// additional arguments.\n//\n// By default, `std::string`, `std::ostream`, and `absl::Cord` are supported as\n// destination objects. If a `std::string` is used the formatted string is\n// appended to it.\n//\n// `absl::Format()` is a generic version of `absl::StrAppendFormat()`, for\n// custom sinks. The format string, like format strings for `StrFormat()`, is\n// checked at compile-time.\n//\n// On failure, this function returns `false` and the state of the sink is\n// unspecified.\ntemplate <typename... Args>\nbool Format(FormatRawSink raw_sink, const FormatSpec<Args...>& format,\n            const Args&... args) {\n  return str_format_internal::FormatUntyped(\n      str_format_internal::FormatRawSinkImpl::Extract(raw_sink),\n      str_format_internal::UntypedFormatSpecImpl::Extract(format),\n      {str_format_internal::FormatArgImpl(args)...});\n}\n\n// FormatArg\n//\n// A type-erased handle to a format argument specifically used as an argument to\n// `FormatUntyped()`. You may construct `FormatArg` by passing\n// reference-to-const of any printable type. `FormatArg` is both copyable and\n// assignable. The source data must outlive the `FormatArg` instance. See\n// example below.\n//\nusing FormatArg = str_format_internal::FormatArgImpl;\n\n// FormatUntyped()\n//\n// Writes a formatted string to an arbitrary sink object (implementing the\n// `absl::FormatRawSink` interface), using an `UntypedFormatSpec` and zero or\n// more additional arguments.\n//\n// This function acts as the most generic formatting function in the\n// `str_format` library. The caller provides a raw sink, an unchecked format\n// string, and (usually) a runtime specified list of arguments; no compile-time\n// checking of formatting is performed within this function. As a result, a\n// caller should check the return value to verify that no error occurred.\n// On failure, this function returns `false` and the state of the sink is\n// unspecified.\n//\n// The arguments are provided in an `absl::Span<const absl::FormatArg>`.\n// Each `absl::FormatArg` object binds to a single argument and keeps a\n// reference to it. The values used to create the `FormatArg` objects must\n// outlive this function call.\n//\n// Example:\n//\n//   std::optional<std::string> FormatDynamic(\n//       const std::string& in_format,\n//       const vector<std::string>& in_args) {\n//     std::string out;\n//     std::vector<absl::FormatArg> args;\n//     for (const auto& v : in_args) {\n//       // It is important that 'v' is a reference to the objects in in_args.\n//       // The values we pass to FormatArg must outlive the call to\n//       // FormatUntyped.\n//       args.emplace_back(v);\n//     }\n//     absl::UntypedFormatSpec format(in_format);\n//     if (!absl::FormatUntyped(&out, format, args)) {\n//       return std::nullopt;\n//     }\n//     return std::move(out);\n//   }\n//\nABSL_MUST_USE_RESULT inline bool FormatUntyped(\n    FormatRawSink raw_sink, const UntypedFormatSpec& format,\n    absl::Span<const FormatArg> args) {\n  return str_format_internal::FormatUntyped(\n      str_format_internal::FormatRawSinkImpl::Extract(raw_sink),\n      str_format_internal::UntypedFormatSpecImpl::Extract(format), args);\n}\n\n//------------------------------------------------------------------------------\n// StrFormat Extensions\n//------------------------------------------------------------------------------\n//\n// AbslStringify()\n//\n// A simpler customization API for formatting user-defined types using\n// absl::StrFormat(). The API relies on detecting an overload in the\n// user-defined type's namespace of a free (non-member) `AbslStringify()`\n// function as a friend definition with the following signature:\n//\n// template <typename Sink>\n// void AbslStringify(Sink& sink, const X& value);\n//\n// An `AbslStringify()` overload for a type should only be declared in the same\n// file and namespace as said type.\n//\n// Note that unlike with AbslFormatConvert(), AbslStringify() does not allow\n// customization of allowed conversion characters. AbslStringify() uses `%v` as\n// the underlying conversion specififer. Additionally, AbslStringify() supports\n// use with absl::StrCat while AbslFormatConvert() does not.\n//\n// Example:\n//\n// struct Point {\n//   // To add formatting support to `Point`, we simply need to add a free\n//   // (non-member) function `AbslStringify()`. This method prints in the\n//   // request format using the underlying `%v` specifier. You can add such a\n//   // free function using a friend declaration within the body of the class.\n//   // The sink parameter is a templated type to avoid requiring dependencies.\n//   template <typename Sink>\n//   friend void AbslStringify(Sink& sink, const Point& p) {\n//     absl::Format(&sink, \"(%v, %v)\", p.x, p.y);\n//   }\n//\n//   int x;\n//   int y;\n// };\n//\n// AbslFormatConvert()\n//\n// The StrFormat library provides a customization API for formatting\n// user-defined types using absl::StrFormat(). The API relies on detecting an\n// overload in the user-defined type's namespace of a free (non-member)\n// `AbslFormatConvert()` function, usually as a friend definition with the\n// following signature:\n//\n// absl::FormatConvertResult<...> AbslFormatConvert(\n//     const X& value,\n//     const absl::FormatConversionSpec& spec,\n//     absl::FormatSink *sink);\n//\n// An `AbslFormatConvert()` overload for a type should only be declared in the\n// same file and namespace as said type.\n//\n// The abstractions within this definition include:\n//\n// * An `absl::FormatConversionSpec` to specify the fields to pull from a\n//   user-defined type's format string\n// * An `absl::FormatSink` to hold the converted string data during the\n//   conversion process.\n// * An `absl::FormatConvertResult` to hold the status of the returned\n//   formatting operation\n//\n// The return type encodes all the conversion characters that your\n// AbslFormatConvert() routine accepts.  The return value should be {true}.\n// A return value of {false} will result in `StrFormat()` returning\n// an empty string.  This result will be propagated to the result of\n// `FormatUntyped`.\n//\n// Example:\n//\n// struct Point {\n//   // To add formatting support to `Point`, we simply need to add a free\n//   // (non-member) function `AbslFormatConvert()`.  This method interprets\n//   // `spec` to print in the request format. The allowed conversion characters\n//   // can be restricted via the type of the result, in this example\n//   // string and integral formatting are allowed (but not, for instance\n//   // floating point characters like \"%f\").  You can add such a free function\n//   // using a friend declaration within the body of the class:\n//   friend absl::FormatConvertResult<absl::FormatConversionCharSet::kString |\n//                                    absl::FormatConversionCharSet::kIntegral>\n//   AbslFormatConvert(const Point& p, const absl::FormatConversionSpec& spec,\n//                     absl::FormatSink* s) {\n//     if (spec.conversion_char() == absl::FormatConversionChar::s) {\n//       absl::Format(s, \"x=%vy=%v\", p.x, p.y);\n//     } else {\n//       absl::Format(s, \"%v,%v\", p.x, p.y);\n//     }\n//     return {true};\n//   }\n//\n//   int x;\n//   int y;\n// };\n\n// clang-format off\n\n// FormatConversionChar\n//\n// Specifies the formatting character provided in the format string\n// passed to `StrFormat()`.\nenum class FormatConversionChar : uint8_t {\n  c, s,                    // text\n  d, i, o, u, x, X,        // int\n  f, F, e, E, g, G, a, A,  // float\n  n, p, v                  // misc\n};\n// clang-format on\n\n// FormatConversionSpec\n//\n// Specifies modifications to the conversion of the format string, through use\n// of one or more format flags in the source format string.\nclass FormatConversionSpec {\n public:\n  // FormatConversionSpec::is_basic()\n  //\n  // Indicates that width and precision are not specified, and no additional\n  // flags are set for this conversion character in the format string.\n  bool is_basic() const { return impl_.is_basic(); }\n\n  // FormatConversionSpec::has_left_flag()\n  //\n  // Indicates whether the result should be left justified for this conversion\n  // character in the format string. This flag is set through use of a '-'\n  // character in the format string. E.g. \"%-s\"\n  bool has_left_flag() const { return impl_.has_left_flag(); }\n\n  // FormatConversionSpec::has_show_pos_flag()\n  //\n  // Indicates whether a sign column is prepended to the result for this\n  // conversion character in the format string, even if the result is positive.\n  // This flag is set through use of a '+' character in the format string.\n  // E.g. \"%+d\"\n  bool has_show_pos_flag() const { return impl_.has_show_pos_flag(); }\n\n  // FormatConversionSpec::has_sign_col_flag()\n  //\n  // Indicates whether a mandatory sign column is added to the result for this\n  // conversion character. This flag is set through use of a space character\n  // (' ') in the format string. E.g. \"% i\"\n  bool has_sign_col_flag() const { return impl_.has_sign_col_flag(); }\n\n  // FormatConversionSpec::has_alt_flag()\n  //\n  // Indicates whether an \"alternate\" format is applied to the result for this\n  // conversion character. Alternative forms depend on the type of conversion\n  // character, and unallowed alternatives are undefined. This flag is set\n  // through use of a '#' character in the format string. E.g. \"%#h\"\n  bool has_alt_flag() const { return impl_.has_alt_flag(); }\n\n  // FormatConversionSpec::has_zero_flag()\n  //\n  // Indicates whether zeroes should be prepended to the result for this\n  // conversion character instead of spaces. This flag is set through use of the\n  // '0' character in the format string. E.g. \"%0f\"\n  bool has_zero_flag() const { return impl_.has_zero_flag(); }\n\n  // FormatConversionSpec::conversion_char()\n  //\n  // Returns the underlying conversion character.\n  FormatConversionChar conversion_char() const {\n    return impl_.conversion_char();\n  }\n\n  // FormatConversionSpec::width()\n  //\n  // Returns the specified width (indicated through use of a non-zero integer\n  // value or '*' character) of the conversion character. If width is\n  // unspecified, it returns a negative value.\n  int width() const { return impl_.width(); }\n\n  // FormatConversionSpec::precision()\n  //\n  // Returns the specified precision (through use of the '.' character followed\n  // by a non-zero integer value or '*' character) of the conversion character.\n  // If precision is unspecified, it returns a negative value.\n  int precision() const { return impl_.precision(); }\n\n private:\n  explicit FormatConversionSpec(\n      str_format_internal::FormatConversionSpecImpl impl)\n      : impl_(impl) {}\n\n  friend str_format_internal::FormatConversionSpecImpl;\n\n  absl::str_format_internal::FormatConversionSpecImpl impl_;\n};\n\n// Type safe OR operator for FormatConversionCharSet to allow accepting multiple\n// conversion chars in custom format converters.\nconstexpr FormatConversionCharSet operator|(FormatConversionCharSet a,\n                                            FormatConversionCharSet b) {\n  return static_cast<FormatConversionCharSet>(static_cast<uint64_t>(a) |\n                                              static_cast<uint64_t>(b));\n}\n\n// FormatConversionCharSet\n//\n// Specifies the _accepted_ conversion types as a template parameter to\n// FormatConvertResult for custom implementations of `AbslFormatConvert`.\n// Note the helper predefined alias definitions (kIntegral, etc.) below.\nenum class FormatConversionCharSet : uint64_t {\n  // text\n  c = str_format_internal::FormatConversionCharToConvInt('c'),\n  s = str_format_internal::FormatConversionCharToConvInt('s'),\n  // integer\n  d = str_format_internal::FormatConversionCharToConvInt('d'),\n  i = str_format_internal::FormatConversionCharToConvInt('i'),\n  o = str_format_internal::FormatConversionCharToConvInt('o'),\n  u = str_format_internal::FormatConversionCharToConvInt('u'),\n  x = str_format_internal::FormatConversionCharToConvInt('x'),\n  X = str_format_internal::FormatConversionCharToConvInt('X'),\n  // Float\n  f = str_format_internal::FormatConversionCharToConvInt('f'),\n  F = str_format_internal::FormatConversionCharToConvInt('F'),\n  e = str_format_internal::FormatConversionCharToConvInt('e'),\n  E = str_format_internal::FormatConversionCharToConvInt('E'),\n  g = str_format_internal::FormatConversionCharToConvInt('g'),\n  G = str_format_internal::FormatConversionCharToConvInt('G'),\n  a = str_format_internal::FormatConversionCharToConvInt('a'),\n  A = str_format_internal::FormatConversionCharToConvInt('A'),\n  // misc\n  n = str_format_internal::FormatConversionCharToConvInt('n'),\n  p = str_format_internal::FormatConversionCharToConvInt('p'),\n  v = str_format_internal::FormatConversionCharToConvInt('v'),\n\n  // Used for width/precision '*' specification.\n  kStar = static_cast<uint64_t>(\n      absl::str_format_internal::FormatConversionCharSetInternal::kStar),\n  // Some predefined values:\n  kIntegral = d | i | u | o | x | X,\n  kFloating = a | e | f | g | A | E | F | G,\n  kNumeric = kIntegral | kFloating,\n  kString = s,\n  kPointer = p,\n};\n\n// FormatSink\n//\n// A format sink is a generic abstraction to which conversions may write their\n// formatted string data. `absl::FormatConvert()` uses this sink to write its\n// formatted string.\n//\nclass FormatSink {\n public:\n  // FormatSink::Append()\n  //\n  // Appends `count` copies of `ch` to the format sink.\n  void Append(size_t count, char ch) { sink_->Append(count, ch); }\n\n  // Overload of FormatSink::Append() for appending the characters of a string\n  // view to a format sink.\n  void Append(string_view v) { sink_->Append(v); }\n\n  // FormatSink::PutPaddedString()\n  //\n  // Appends `precision` number of bytes of `v` to the format sink. If this is\n  // less than `width`, spaces will be appended first (if `left` is false), or\n  // after (if `left` is true) to ensure the total amount appended is\n  // at least `width`.\n  bool PutPaddedString(string_view v, int width, int precision, bool left) {\n    return sink_->PutPaddedString(v, width, precision, left);\n  }\n\n  // Support `absl::Format(&sink, format, args...)`.\n  friend void AbslFormatFlush(absl::Nonnull<FormatSink*> sink,\n                              absl::string_view v) {\n    sink->Append(v);\n  }\n\n private:\n  friend str_format_internal::FormatSinkImpl;\n  explicit FormatSink(absl::Nonnull<str_format_internal::FormatSinkImpl*> s)\n      : sink_(s) {}\n  absl::Nonnull<str_format_internal::FormatSinkImpl*> sink_;\n};\n\n// FormatConvertResult\n//\n// Indicates whether a call to AbslFormatConvert() was successful.\n// This return type informs the StrFormat extension framework (through\n// ADL but using the return type) of what conversion characters are supported.\n// It is strongly discouraged to return {false}, as this will result in an\n// empty string in StrFormat.\ntemplate <FormatConversionCharSet C>\nstruct FormatConvertResult {\n  bool value;\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04129",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_format.h",
  "source_line": 322,
  "validation_status": "validated"
}