{
  "code": "{\n\n/// Enumeration specifying the different kinds of C++ overloaded\n/// operators.\nenum OverloadedOperatorKind : int {\n  OO_None,                ///< Not an overloaded operator\n#define OVERLOADED_OPERATOR(Name,Spelling,Token,Unary,Binary,MemberOnly) \\\n  OO_##Name,\n#include \"clang/Basic/OperatorKinds.def\"\n  NUM_OVERLOADED_OPERATORS\n};\n\n/// Retrieve the spelling of the given overloaded operator, without\n/// the preceding \"operator\" keyword.\nconst char *getOperatorSpelling(OverloadedOperatorKind Operator);\n\n/// Get the other overloaded operator that the given operator can be rewritten\n/// into, if any such operator exists.\ninline OverloadedOperatorKind\ngetRewrittenOverloadedOperator(OverloadedOperatorKind Kind) {\n  switch (Kind) {\n  case OO_Less:\n  case OO_LessEqual:\n  case OO_Greater:\n  case OO_GreaterEqual:\n    return OO_Spaceship;\n\n  case OO_ExclaimEqual:\n    return OO_EqualEqual;\n\n  default:\n    return OO_None;\n  }\n}\n\n/// Determine if this is a compound assignment operator.\ninline bool isCompoundAssignmentOperator(OverloadedOperatorKind Kind) {\n  return Kind >= OO_PlusEqual && Kind <= OO_PipeEqual;\n}\n\n}",
  "id": "BLOCK-CPP-16701",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/OperatorKinds.h",
  "source_line": 17,
  "validation_status": "validated"
}