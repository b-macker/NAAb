{
  "code": "{\npublic:\n  /// A queue used for performing data recursion over statements.\n  /// Parameters involving this type are used to implement data\n  /// recursion over Stmts and Exprs within this class, and should\n  /// typically not be explicitly specified by derived classes.\n  /// The bool bit indicates whether the statement has been traversed or not.\n  typedef SmallVectorImpl<llvm::PointerIntPair<Stmt *, 1, bool>>\n    DataRecursionQueue;\n\n  /// Return a reference to the derived class.\n  Derived &getDerived() { return *static_cast<Derived *>(this); }\n\n  /// Return whether this visitor should recurse into\n  /// template instantiations.\n  bool shouldVisitTemplateInstantiations() const { return false; }\n\n  /// Return whether this visitor should recurse into the types of\n  /// TypeLocs.\n  bool shouldWalkTypesOfTypeLocs() const { return true; }\n\n  /// Return whether this visitor should recurse into implicit\n  /// code, e.g., implicit constructors and destructors.\n  bool shouldVisitImplicitCode() const { return false; }\n\n  /// Return whether this visitor should recurse into lambda body\n  bool shouldVisitLambdaBody() const { return true; }\n\n  /// Return whether this visitor should traverse post-order.\n  bool shouldTraversePostOrder() const { return false; }\n\n  /// Recursively visits an entire AST, starting from the TranslationUnitDecl.\n  /// \\returns false if visitation was terminated early.\n  bool TraverseAST(ASTContext &AST) {\n    // Currently just an alias for TraverseDecl(TUDecl), but kept in case\n    // we change the implementation again.\n    return getDerived().TraverseDecl(AST.getTranslationUnitDecl());\n  }\n\n  /// Recursively visit a statement or expression, by\n  /// dispatching to Traverse*() based on the argument's dynamic type.\n  ///\n  /// \\returns false if the visitation was terminated early, true\n  /// otherwise (including when the argument is nullptr).\n  bool TraverseStmt(Stmt *S, DataRecursionQueue *Queue = nullptr);\n\n  /// Invoked before visiting a statement or expression via data recursion.\n  ///\n  /// \\returns false to skip visiting the node, true otherwise.\n  bool dataTraverseStmtPre(Stmt *S) { return true; }\n\n  /// Invoked after visiting a statement or expression via data recursion.\n  /// This is not invoked if the previously invoked \\c dataTraverseStmtPre\n  /// returned false.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool dataTraverseStmtPost(Stmt *S) { return true; }\n\n  /// Recursively visit a type, by dispatching to\n  /// Traverse*Type() based on the argument's getTypeClass() property.\n  ///\n  /// \\returns false if the visitation was terminated early, true\n  /// otherwise (including when the argument is a Null type).\n  bool TraverseType(QualType T);\n\n  /// Recursively visit a type with location, by dispatching to\n  /// Traverse*TypeLoc() based on the argument type's getTypeClass() property.\n  ///\n  /// \\returns false if the visitation was terminated early, true\n  /// otherwise (including when the argument is a Null type location).\n  bool TraverseTypeLoc(TypeLoc TL);\n\n  /// Recursively visit an attribute, by dispatching to\n  /// Traverse*Attr() based on the argument's dynamic type.\n  ///\n  /// \\returns false if the visitation was terminated early, true\n  /// otherwise (including when the argument is a Null type location).\n  bool TraverseAttr(Attr *At);\n\n  /// Recursively visit a declaration, by dispatching to\n  /// Traverse*Decl() based on the argument's dynamic type.\n  ///\n  /// \\returns false if the visitation was terminated early, true\n  /// otherwise (including when the argument is NULL).\n  bool TraverseDecl(Decl *D);\n\n  /// Recursively visit a C++ nested-name-specifier.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseNestedNameSpecifier(NestedNameSpecifier *NNS);\n\n  /// Recursively visit a C++ nested-name-specifier with location\n  /// information.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);\n\n  /// Recursively visit a name with its location information.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseDeclarationNameInfo(DeclarationNameInfo NameInfo);\n\n  /// Recursively visit a template name and dispatch to the\n  /// appropriate method.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseTemplateName(TemplateName Template);\n\n  /// Recursively visit a template argument and dispatch to the\n  /// appropriate method for the argument type.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  // FIXME: migrate callers to TemplateArgumentLoc instead.\n  bool TraverseTemplateArgument(const TemplateArgument &Arg);\n\n  /// Recursively visit a template argument location and dispatch to the\n  /// appropriate method for the argument type.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseTemplateArgumentLoc(const TemplateArgumentLoc &ArgLoc);\n\n  /// Recursively visit a set of template arguments.\n  /// This can be overridden by a subclass, but it's not expected that\n  /// will be needed -- this visitor always dispatches to another.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  // FIXME: take a TemplateArgumentLoc* (or TemplateArgumentListInfo) instead.\n  bool TraverseTemplateArguments(ArrayRef<TemplateArgument> Args);\n\n  /// Recursively visit a base specifier. This can be overridden by a\n  /// subclass.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseCXXBaseSpecifier(const CXXBaseSpecifier &Base);\n\n  /// Recursively visit a constructor initializer.  This\n  /// automatically dispatches to another visitor for the initializer\n  /// expression, but not for the name of the initializer, so may\n  /// be overridden for clients that need access to the name.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseConstructorInitializer(CXXCtorInitializer *Init);\n\n  /// Recursively visit a lambda capture. \\c Init is the expression that\n  /// will be used to initialize the capture.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseLambdaCapture(LambdaExpr *LE, const LambdaCapture *C,\n                             Expr *Init);\n\n  /// Recursively visit the syntactic or semantic form of an\n  /// initialization list.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseSynOrSemInitListExpr(InitListExpr *S,\n                                    DataRecursionQueue *Queue = nullptr);\n\n  /// Recursively visit an Objective-C protocol reference with location\n  /// information.\n  ///\n  /// \\returns false if the visitation was terminated early, true otherwise.\n  bool TraverseObjCProtocolLoc(ObjCProtocolLoc ProtocolLoc);\n\n  // ---- Methods on Attrs ----\n\n  // Visit an attribute.\n  bool VisitAttr(Attr *A) { return true; }\n\n// Declare Traverse* and empty Visit* for all Attr classes.\n#define ATTR_VISITOR_DECLS_ONLY\n#include \"clang/AST/AttrVisitor.inc\"\n#undef ATTR_VISITOR_DECLS_ONLY\n\n// ---- Methods on Stmts ----\n\n  Stmt::child_range getStmtChildren(Stmt *S) { return S->children(); }\n\nprivate:\n  // Traverse the given statement. If the most-derived traverse function takes a\n  // data recursion queue, pass it on; otherwise, discard it. Note that the\n  // first branch of this conditional must compile whether or not the derived\n  // class can take a queue, so if we're taking the second arm, make the first\n  // arm call our function rather than the derived class version.\n#define TRAVERSE_STMT_BASE(NAME, CLASS, VAR, QUEUE)                            \\\n  (::clang::detail::has_same_member_pointer_type<                              \\\n       decltype(&RecursiveASTVisitor::Traverse##NAME),                         \\\n       decltype(&Derived::Traverse##NAME)>::value                              \\\n       ? static_cast<std::conditional_t<                                       \\\n             ::clang::detail::has_same_member_pointer_type<                    \\\n                 decltype(&RecursiveASTVisitor::Traverse##NAME),               \\\n                 decltype(&Derived::Traverse##NAME)>::value,                   \\\n             Derived &, RecursiveASTVisitor &>>(*this)                         \\\n             .Traverse##NAME(static_cast<CLASS *>(VAR), QUEUE)                 \\\n       : getDerived().Traverse##NAME(static_cast<CLASS *>(VAR)))\n\n// Try to traverse the given statement, or enqueue it if we're performing data\n// recursion in the middle of traversing another statement. Can only be called\n// from within a DEF_TRAVERSE_STMT body or similar context.\n#define TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S)                                     \\\n  do {                                                                         \\\n    if (!TRAVERSE_STMT_BASE(Stmt, Stmt, S, Queue))                             \\\n      return false;                                                            \\\n  } while (false)\n\npublic:\n// Declare Traverse*() for all concrete Stmt classes.\n#define ABSTRACT_STMT(STMT)\n#define STMT(CLASS, PARENT) \\\n  bool Traverse##CLASS(CLASS *S, DataRecursionQueue *Queue = nullptr);\n#include \"clang/AST/StmtNodes.inc\"\n  // The above header #undefs ABSTRACT_STMT and STMT upon exit.\n\n  // Define WalkUpFrom*() and empty Visit*() for all Stmt classes.\n  bool WalkUpFromStmt(Stmt *S) { return getDerived().VisitStmt(S); }\n  bool VisitStmt(Stmt *S) { return true; }\n#define STMT(CLASS, PARENT)                                                    \\\n  bool WalkUpFrom##CLASS(CLASS *S) {                                           \\\n    TRY_TO(WalkUpFrom##PARENT(S));                                             \\\n    TRY_TO(Visit##CLASS(S));                                                   \\\n    return true;                                                               \\\n  }                                                                            \\\n  bool Visit##CLASS(CLASS *S) { return true; }\n#include \"clang/AST/StmtNodes.inc\"\n\n// ---- Methods on Types ----\n// FIXME: revamp to take TypeLoc's rather than Types.\n\n// Declare Traverse*() for all concrete Type classes.\n#define ABSTRACT_TYPE(CLASS, BASE)\n#define TYPE(CLASS, BASE) bool Traverse##CLASS##Type(CLASS##Type *T);\n#include \"clang/AST/TypeNodes.inc\"\n  // The above header #undefs ABSTRACT_TYPE and TYPE upon exit.\n\n  // Define WalkUpFrom*() and empty Visit*() for all Type classes.\n  bool WalkUpFromType(Type *T) { return getDerived().VisitType(T); }\n  bool VisitType(Type *T) { return true; }\n#define TYPE(CLASS, BASE)                                                      \\\n  bool WalkUpFrom##CLASS##Type(CLASS##Type *T) {                               \\\n    TRY_TO(WalkUpFrom##BASE(T));                                               \\\n    TRY_TO(Visit##CLASS##Type(T));                                             \\\n    return true;                                                               \\\n  }                                                                            \\\n  bool Visit##CLASS##Type(CLASS##Type *T) { return true; }\n#include \"clang/AST/TypeNodes.inc\"\n\n// ---- Methods on TypeLocs ----\n// FIXME: this currently just calls the matching Type methods\n\n// Declare Traverse*() for all concrete TypeLoc classes.\n#define ABSTRACT_TYPELOC(CLASS, BASE)\n#define TYPELOC(CLASS, BASE) bool Traverse##CLASS##TypeLoc(CLASS##TypeLoc TL);\n#include \"clang/AST/TypeLocNodes.def\"\n  // The above header #undefs ABSTRACT_TYPELOC and TYPELOC upon exit.\n\n  // Define WalkUpFrom*() and empty Visit*() for all TypeLoc classes.\n  bool WalkUpFromTypeLoc(TypeLoc TL) { return getDerived().VisitTypeLoc(TL); }\n  bool VisitTypeLoc(TypeLoc TL) { return true; }\n\n  // QualifiedTypeLoc and UnqualTypeLoc are not declared in\n  // TypeNodes.inc and thus need to be handled specially.\n  bool WalkUpFromQualifiedTypeLoc(QualifiedTypeLoc TL) {\n    return getDerived().VisitUnqualTypeLoc(TL.getUnqualifiedLoc());\n  }\n  bool VisitQualifiedTypeLoc(QualifiedTypeLoc TL) { return true; }\n  bool WalkUpFromUnqualTypeLoc(UnqualTypeLoc TL) {\n    return getDerived().VisitUnqualTypeLoc(TL.getUnqualifiedLoc());\n  }\n  bool VisitUnqualTypeLoc(UnqualTypeLoc TL) { return true; }\n\n// Note that BASE includes trailing 'Type' which CLASS doesn't.\n#define TYPE(CLASS, BASE)                                                      \\\n  bool WalkUpFrom##CLASS##TypeLoc(CLASS##TypeLoc TL) {                         \\\n    TRY_TO(WalkUpFrom##BASE##Loc(TL));                                         \\\n    TRY_TO(Visit##CLASS##TypeLoc(TL));                                         \\\n    return true;                                                               \\\n  }                                                                            \\\n  bool Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) { return true; }\n#include \"clang/AST/TypeNodes.inc\"\n\n// ---- Methods on Decls ----\n\n// Declare Traverse*() for all concrete Decl classes.\n#define ABSTRACT_DECL(DECL)\n#define DECL(CLASS, BASE) bool Traverse##CLASS##Decl(CLASS##Decl *D);\n#include \"clang/AST/DeclNodes.inc\"\n  // The above header #undefs ABSTRACT_DECL and DECL upon exit.\n\n  // Define WalkUpFrom*() and empty Visit*() for all Decl classes.\n  bool WalkUpFromDecl(Decl *D) { return getDerived().VisitDecl(D); }\n  bool VisitDecl(Decl *D) { return true; }\n#define DECL(CLASS, BASE)                                                      \\\n  bool WalkUpFrom##CLASS##Decl(CLASS##Decl *D) {                               \\\n    TRY_TO(WalkUpFrom##BASE(D));                                               \\\n    TRY_TO(Visit##CLASS##Decl(D));                                             \\\n    return true;                                                               \\\n  }                                                                            \\\n  bool Visit##CLASS##Decl(CLASS##Decl *D) { return true; }\n#include \"clang/AST/DeclNodes.inc\"\n\n  bool canIgnoreChildDeclWhileTraversingDeclContext(const Decl *Child);\n\n#define DEF_TRAVERSE_TMPL_INST(TMPLDECLKIND)                                   \\\n  bool TraverseTemplateInstantiations(TMPLDECLKIND##TemplateDecl *D);\n  DEF_TRAVERSE_TMPL_INST(Class)\n  DEF_TRAVERSE_TMPL_INST(Var)\n  DEF_TRAVERSE_TMPL_INST(Function)\n#undef DEF_TRAVERSE_TMPL_INST\n\n  bool TraverseTypeConstraint(const TypeConstraint *C);\n\n  bool TraverseConceptRequirement(concepts::Requirement *R);\n  bool TraverseConceptTypeRequirement(concepts::TypeRequirement *R);\n  bool TraverseConceptExprRequirement(concepts::ExprRequirement *R);\n  bool TraverseConceptNestedRequirement(concepts::NestedRequirement *R);\n\n  bool dataTraverseNode(Stmt *S, DataRecursionQueue *Queue);\n\nprivate:\n  // These are helper methods used by more than one Traverse* method.\n  bool TraverseTemplateParameterListHelper(TemplateParameterList *TPL);\n  /// Traverses the qualifier, name and template arguments of a concept\n  /// reference.\n  bool TraverseConceptReferenceHelper(const ConceptReference &C);\n\n  // Traverses template parameter lists of either a DeclaratorDecl or TagDecl.\n  template <typename T>\n  bool TraverseDeclTemplateParameterLists(T *D);\n\n  bool TraverseTemplateTypeParamDeclConstraints(const TemplateTypeParmDecl *D);\n\n  bool TraverseTemplateArgumentLocsHelper(const TemplateArgumentLoc *TAL,\n                                          unsigned Count);\n  bool TraverseArrayTypeLocHelper(ArrayTypeLoc TL);\n  bool TraverseRecordHelper(RecordDecl *D);\n  bool TraverseCXXRecordHelper(CXXRecordDecl *D);\n  bool TraverseDeclaratorHelper(DeclaratorDecl *D);\n  bool TraverseDeclContextHelper(DeclContext *DC);\n  bool TraverseFunctionHelper(FunctionDecl *D);\n  bool TraverseVarHelper(VarDecl *D);\n  bool TraverseOMPExecutableDirective(OMPExecutableDirective *S);\n  bool TraverseOMPLoopDirective(OMPLoopDirective *S);\n  bool TraverseOMPClause(OMPClause *C);\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) bool Visit##Class(Class *C);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n  /// Process clauses with list of variables.\n  template <typename T> bool VisitOMPClauseList(T *Node);\n  /// Process clauses with pre-initis.\n  bool VisitOMPClauseWithPreInit(OMPClauseWithPreInit *Node);\n  bool VisitOMPClauseWithPostUpdate(OMPClauseWithPostUpdate *Node);\n\n  bool PostVisitStmt(Stmt *S);\n}",
  "id": "BLOCK-CPP-12398",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/RecursiveASTVisitor.h",
  "source_line": 152,
  "validation_status": "validated"
}