{
  "code": "#include \"spdlog/common.h\"\n#include \"spdlog/details/log_msg.h\"\n#include \"spdlog/sinks/base_sink.h\"\n#include <spdlog/details/synchronous_factory.h>\n#include <bsoncxx/builder/stream/document.hpp>\n#include <bsoncxx/types.hpp>\n#include <bsoncxx/view_or_value.hpp>\n#include <mongocxx/client.hpp>\n#include <mongocxx/instance.hpp>\n#include <mongocxx/uri.hpp>\n\nusing namespace spdlog;\nusing namespace sinks;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00426_execute() {\n    {\ntemplate <typename Mutex>\nclass mongo_sink : public base_sink<Mutex> {\npublic:\n    mongo_sink(const std::string &db_name,\n               const std::string &collection_name,\n               const std::string &uri = \"mongodb://localhost:27017\") try\n        : mongo_sink(std::make_shared<mongocxx::instance>(), db_name, collection_name, uri) {\n    } catch (const std::exception &e) {\n        throw_spdlog_ex(fmt_lib::format(\"Error opening database: {}\", e.what()));\n    }\n\n    mongo_sink(std::shared_ptr<mongocxx::instance> instance,\n               const std::string &db_name,\n               const std::string &collection_name,\n               const std::string &uri = \"mongodb://localhost:27017\")\n        : instance_(std::move(instance)),\n          db_name_(db_name),\n          coll_name_(collection_name) {\n        try {\n            client_ = spdlog::details::make_unique<mongocxx::client>(mongocxx::uri{uri});\n        } catch (const std::exception &e) {\n            throw_spdlog_ex(fmt_lib::format(\"Error opening database: {}\", e.what()));\n        }\n    }\n\n    ~mongo_sink() { flush_(); }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        using bsoncxx::builder::stream::document;\n        using bsoncxx::builder::stream::finalize;\n\n        if (client_ != nullptr) {\n            auto doc = document{} << \"timestamp\" << bsoncxx::types::b_date(msg.time) << \"level\"\n                                  << level::to_string_view(msg.level).data() << \"level_num\"\n                                  << msg.level << \"message\"\n                                  << std::string(msg.payload.begin(), msg.payload.end())\n                                  << \"logger_name\"\n                                  << std::string(msg.logger_name.begin(), msg.logger_name.end())\n                                  << \"thread_id\" << static_cast<int>(msg.thread_id) << finalize;\n            client_->database(db_name_).collection(coll_name_).insert_one(doc.view());\n        }\n    }\n\n    void flush_() override {}\n\nprivate:\n    std::shared_ptr<mongocxx::instance> instance_;\n    std::string db_name_;\n    std::string coll_name_;\n    std::unique_ptr<mongocxx::client> client_ = nullptr;\n};\n\n#include \"spdlog/details/null_mutex.h\"\n#include <mutex>\nusing mongo_sink_mt = mongo_sink<std::mutex>;\nusing mongo_sink_st = mongo_sink<spdlog::details::null_mutex>;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00426",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/mongo_sink.h",
  "source_line": 27,
  "validation_status": "validated"
}