{
  "code": "#include <cassert>\n#include <iostream>\n#include \"absl/strings/internal/cord_internal.h\"\n#include \"absl/strings/internal/cord_rep_btree.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06142_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\n// CordRepBtreeNavigator is a bi-directional navigator allowing callers to\n// navigate all the (leaf) data edges in a CordRepBtree instance.\n//\n// A CordRepBtreeNavigator instance is by default empty. Callers initialize a\n// navigator instance by calling one of `InitFirst()`, `InitLast()` or\n// `InitOffset()`, which establishes a current position. Callers can then\n// navigate using the `Next`, `Previous`, `Skip` and `Seek` methods.\n//\n// The navigator instance does not take or adopt a reference on the provided\n// `tree` on any of the initialization calls. Callers are responsible for\n// guaranteeing the lifecycle of the provided tree. A navigator instance can\n// be reset to the empty state by calling `Reset`.\n//\n// A navigator only keeps positional state on the 'current data edge', it does\n// explicitly not keep any 'offset' state. The class does accept and return\n// offsets in the `Read()`, `Skip()` and 'Seek()` methods as these would\n// otherwise put a big burden on callers. Callers are expected to maintain\n// (returned) offset info if they require such granular state.\nclass CordRepBtreeNavigator {\n public:\n  // The logical position as returned by the Seek() and Skip() functions.\n  // Returns the current leaf edge for the desired seek or skip position and\n  // the offset of that position inside that edge.\n  struct Position {\n    CordRep* edge;\n    size_t offset;\n  };\n\n  // The read result as returned by the Read() function.\n  // `tree` contains the resulting tree which is identical to the result\n  // of calling CordRepBtree::SubTree(...) on the tree being navigated.\n  // `n` contains the number of bytes used from the last navigated to\n  // edge of the tree.\n  struct ReadResult {\n    CordRep* tree;\n    size_t n;\n  };\n\n  // Returns true if this instance is not empty.\n  explicit operator bool() const;\n\n  // Returns the tree for this instance or nullptr if empty.\n  CordRepBtree* btree() const;\n\n  // Returns the data edge of the current position.\n  // Requires this instance to not be empty.\n  CordRep* Current() const;\n\n  // Resets this navigator to `tree`, returning the first data edge in the tree.\n  CordRep* InitFirst(CordRepBtree* tree);\n\n  // Resets this navigator to `tree`, returning the last data edge in the tree.\n  CordRep* InitLast(CordRepBtree* tree);\n\n  // Resets this navigator to `tree` returning the data edge at position\n  // `offset` and the relative offset of `offset` into that data edge.\n  // Returns `Position.edge = nullptr` if the provided offset is greater\n  // than or equal to the length of the tree, in which case the state of\n  // the navigator instance remains unchanged.\n  Position InitOffset(CordRepBtree* tree, size_t offset);\n\n  // Navigates to the next data edge.\n  // Returns the next data edge or nullptr if there is no next data edge, in\n  // which case the current position remains unchanged.\n  CordRep* Next();\n\n  // Navigates to the previous data edge.\n  // Returns the previous data edge or nullptr if there is no previous data\n  // edge, in which case the current position remains unchanged.\n  CordRep* Previous();\n\n  // Navigates to the data edge at position `offset`. Returns the navigated to\n  // data edge in `Position.edge` and the relative offset of `offset` into that\n  // data edge in `Position.offset`. Returns `Position.edge = nullptr` if the\n  // provide offset is greater than or equal to the tree's length.\n  Position Seek(size_t offset);\n\n  // Reads `n` bytes of data starting at offset `edge_offset` of the current\n  // data edge, and returns the result in `ReadResult.tree`. `ReadResult.n`\n  // contains the 'bytes used` from the last / current data edge in the tree.\n  // This allows users that mix regular navigation (using string views) and\n  // 'read into cord' navigation to keep track of the current state, and which\n  // bytes have been consumed from a navigator.\n  // This function returns `ReadResult.tree = nullptr` if the requested length\n  // exceeds the length of the tree starting at the current data edge.\n  ReadResult Read(size_t edge_offset, size_t n);\n\n  // Skips `n` bytes forward from the current data edge, returning the navigated\n  // to data edge in `Position.edge` and `Position.offset` containing the offset\n  // inside that data edge. Note that the state of the navigator is left\n  // unchanged if `n` is smaller than the length of the current data edge.\n  Position Skip(size_t n);\n\n  // Resets this instance to the default / empty state.\n  void Reset();\n\n private:\n  // Slow path for Next() if Next() reached the end of a leaf node. Backtracks\n  // up the stack until it finds a node that has a 'next' position available,\n  // and then does a 'front dive' towards the next leaf node.\n  CordRep* NextUp();\n\n  // Slow path for Previous() if Previous() reached the beginning of a leaf\n  // node. Backtracks up the stack until it finds a node that has a 'previous'\n  // position available, and then does a 'back dive' towards the previous leaf\n  // node.\n  CordRep* PreviousUp();\n\n  // Generic implementation of InitFirst() and InitLast().\n  template <CordRepBtree::EdgeType edge_type>\n  CordRep* Init(CordRepBtree* tree);\n\n  // `height_` contains the height of the current tree, or -1 if empty.\n  int height_ = -1;\n\n  // `index_` and `node_` contain the navigation state as the 'path' to the\n  // current data edge which is at `node_[0]->Edge(index_[0])`. The contents\n  // of these are undefined until the instance is initialized (`height_ >= 0`).\n  uint8_t index_[CordRepBtree::kMaxDepth];\n  CordRepBtree* node_[CordRepBtree::kMaxDepth];\n};\n\n// Returns true if this instance is not empty.\ninline CordRepBtreeNavigator::operator bool() const { return height_ >= 0; }\n\ninline CordRepBtree* CordRepBtreeNavigator::btree() const {\n  return height_ >= 0 ? node_[height_] : nullptr;\n}\n\ninline CordRep* CordRepBtreeNavigator::Current() const {\n  assert(height_ >= 0);\n  return node_[0]->Edge(index_[0]);\n}\n\ninline void CordRepBtreeNavigator::Reset() { height_ = -1; }\n\ninline CordRep* CordRepBtreeNavigator::InitFirst(CordRepBtree* tree) {\n  return Init<CordRepBtree::kFront>(tree);\n}\n\ninline CordRep* CordRepBtreeNavigator::InitLast(CordRepBtree* tree) {\n  return Init<CordRepBtree::kBack>(tree);\n}\n\ntemplate <CordRepBtree::EdgeType edge_type>\ninline CordRep* CordRepBtreeNavigator::Init(CordRepBtree* tree) {\n  assert(tree != nullptr);\n  assert(tree->size() > 0);\n  assert(tree->height() <= CordRepBtree::kMaxHeight);\n  int height = height_ = tree->height();\n  size_t index = tree->index(edge_type);\n  node_[height] = tree;\n  index_[height] = static_cast<uint8_t>(index);\n  while (--height >= 0) {\n    tree = tree->Edge(index)->btree();\n    node_[height] = tree;\n    index = tree->index(edge_type);\n    index_[height] = static_cast<uint8_t>(index);\n  }\n  return node_[0]->Edge(index);\n}\n\ninline CordRepBtreeNavigator::Position CordRepBtreeNavigator::Seek(\n    size_t offset) {\n  assert(btree() != nullptr);\n  int height = height_;\n  CordRepBtree* edge = node_[height];\n  if (ABSL_PREDICT_FALSE(offset >= edge->length)) return {nullptr, 0};\n  CordRepBtree::Position index = edge->IndexOf(offset);\n  index_[height] = static_cast<uint8_t>(index.index);\n  while (--height >= 0) {\n    edge = edge->Edge(index.index)->btree();\n    node_[height] = edge;\n    index = edge->IndexOf(index.n);\n    index_[height] = static_cast<uint8_t>(index.index);\n  }\n  return {edge->Edge(index.index), index.n};\n}\n\ninline CordRepBtreeNavigator::Position CordRepBtreeNavigator::InitOffset(\n    CordRepBtree* tree, size_t offset) {\n  assert(tree != nullptr);\n  assert(tree->height() <= CordRepBtree::kMaxHeight);\n  if (ABSL_PREDICT_FALSE(offset >= tree->length)) return {nullptr, 0};\n  height_ = tree->height();\n  node_[height_] = tree;\n  return Seek(offset);\n}\n\ninline CordRep* CordRepBtreeNavigator::Next() {\n  CordRepBtree* edge = node_[0];\n  return index_[0] == edge->back() ? NextUp() : edge->Edge(++index_[0]);\n}\n\ninline CordRep* CordRepBtreeNavigator::Previous() {\n  CordRepBtree* edge = node_[0];\n  return index_[0] == edge->begin() ? PreviousUp() : edge->Edge(--index_[0]);\n}\n\ninline CordRep* CordRepBtreeNavigator::NextUp() {\n  assert(index_[0] == node_[0]->back());\n  CordRepBtree* edge;\n  size_t index;\n  int height = 0;\n  do {\n    if (++height > height_) return nullptr;\n    edge = node_[height];\n    index = index_[height] + 1;\n  } while (index == edge->end());\n  index_[height] = static_cast<uint8_t>(index);\n  do {\n    node_[--height] = edge = edge->Edge(index)->btree();\n    index_[height] = static_cast<uint8_t>(index = edge->begin());\n  } while (height > 0);\n  return edge->Edge(index);\n}\n\ninline CordRep* CordRepBtreeNavigator::PreviousUp() {\n  assert(index_[0] == node_[0]->begin());\n  CordRepBtree* edge;\n  size_t index;\n  int height = 0;\n  do {\n    if (++height > height_) return nullptr;\n    edge = node_[height];\n    index = index_[height];\n  } while (index == edge->begin());\n  index_[height] = static_cast<uint8_t>(--index);\n  do {\n    node_[--height] = edge = edge->Edge(index)->btree();\n    index_[height] = static_cast<uint8_t>(index = edge->back());\n  } while (height > 0);\n  return edge->Edge(index);\n}\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06142",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree_navigator.h",
  "source_line": 24,
  "validation_status": "validated"
}