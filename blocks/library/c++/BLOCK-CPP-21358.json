{
  "code": "{\n\nusing DomTreeNode = llvm::DomTreeNodeBase<CFGBlock>;\n\n/// Dominator tree builder for Clang's CFG based on llvm::DominatorTreeBase.\ntemplate <bool IsPostDom>\nclass CFGDominatorTreeImpl : public ManagedAnalysis {\n  virtual void anchor();\n\npublic:\n  using DominatorTreeBase = llvm::DominatorTreeBase<CFGBlock, IsPostDom>;\n\n  CFGDominatorTreeImpl() = default;\n\n  CFGDominatorTreeImpl(CFG *cfg) {\n    buildDominatorTree(cfg);\n  }\n\n  ~CFGDominatorTreeImpl() override = default;\n\n  DominatorTreeBase &getBase() { return DT; }\n\n  CFG *getCFG() { return cfg; }\n\n  /// \\returns the root CFGBlock of the dominators tree.\n  CFGBlock *getRoot() const {\n    return DT.getRoot();\n  }\n\n  /// \\returns the root DomTreeNode, which is the wrapper for CFGBlock.\n  DomTreeNode *getRootNode() {\n    return DT.getRootNode();\n  }\n\n  /// Compares two dominator trees.\n  /// \\returns false if the other dominator tree matches this dominator tree,\n  /// false otherwise.\n  bool compare(CFGDominatorTreeImpl &Other) const {\n    DomTreeNode *R = getRootNode();\n    DomTreeNode *OtherR = Other.getRootNode();\n\n    if (!R || !OtherR || R->getBlock() != OtherR->getBlock())\n      return true;\n\n    if (DT.compare(Other.getBase()))\n      return true;\n\n    return false;\n  }\n\n  /// Builds the dominator tree for a given CFG.\n  void buildDominatorTree(CFG *cfg) {\n    assert(cfg);\n    this->cfg = cfg;\n    DT.recalculate(*cfg);\n  }\n\n  /// Dumps immediate dominators for each block.\n  void dump() {\n    llvm::errs() << \"Immediate \" << (IsPostDom ? \"post \" : \"\")\n                 << \"dominance tree (Node#,IDom#):\\n\";\n    for (CFG::const_iterator I = cfg->begin(),\n        E = cfg->end(); I != E; ++I) {\n\n      assert(*I &&\n             \"LLVM's Dominator tree builder uses nullpointers to signify the \"\n             \"virtual root!\");\n\n      DomTreeNode *IDom = DT.getNode(*I)->getIDom();\n      if (IDom && IDom->getBlock())\n        llvm::errs() << \"(\" << (*I)->getBlockID()\n                     << \",\"\n                     << IDom->getBlock()->getBlockID()\n                     << \")\\n\";\n      else {\n        bool IsEntryBlock = *I == &(*I)->getParent()->getEntry();\n        bool IsExitBlock = *I == &(*I)->getParent()->getExit();\n\n        bool IsDomTreeRoot = !IDom && !IsPostDom && IsEntryBlock;\n        bool IsPostDomTreeRoot =\n            IDom && !IDom->getBlock() && IsPostDom && IsExitBlock;\n\n        assert((IsDomTreeRoot || IsPostDomTreeRoot) &&\n               \"If the immediate dominator node is nullptr, the CFG block \"\n               \"should be the exit point (since it's the root of the dominator \"\n               \"tree), or if the CFG block it refers to is a nullpointer, it \"\n               \"must be the entry block (since it's the root of the post \"\n               \"dominator tree)\");\n\n        (void)IsDomTreeRoot;\n        (void)IsPostDomTreeRoot;\n\n        llvm::errs() << \"(\" << (*I)->getBlockID()\n                     << \",\" << (*I)->getBlockID() << \")\\n\";\n      }\n    }\n  }\n\n  /// Tests whether \\p A dominates \\p B.\n  /// Note a block always dominates itself.\n  bool dominates(const CFGBlock *A, const CFGBlock *B) const {\n    return DT.dominates(A, B);\n  }\n\n  /// Tests whether \\p A properly dominates \\p B.\n  /// \\returns false if \\p A is the same block as \\p B, otherwise whether A\n  /// dominates B.\n  bool properlyDominates(const CFGBlock *A, const CFGBlock *B) const {\n    return DT.properlyDominates(A, B);\n  }\n\n  /// \\returns the nearest common dominator CFG block for CFG block \\p A and \\p\n  /// B. If there is no such block then return NULL.\n  CFGBlock *findNearestCommonDominator(CFGBlock *A, CFGBlock *B) {\n    return DT.findNearestCommonDominator(A, B);\n  }\n\n  const CFGBlock *findNearestCommonDominator(const CFGBlock *A,\n                                             const CFGBlock *B) {\n    return DT.findNearestCommonDominator(A, B);\n  }\n\n  /// Update the dominator tree information when a node's immediate dominator\n  /// changes.\n  void changeImmediateDominator(CFGBlock *N, CFGBlock *NewIDom) {\n    DT.changeImmediateDominator(N, NewIDom);\n  }\n\n  /// Tests whether \\p A is reachable from the entry block.\n  bool isReachableFromEntry(const CFGBlock *A) {\n    return DT.isReachableFromEntry(A);\n  }\n\n  /// Releases the memory held by the dominator tree.\n  virtual void releaseMemory() { DT.reset(); }\n\n  /// Converts the dominator tree to human readable form.\n  virtual void print(raw_ostream &OS, const llvm::Module* M= nullptr) const {\n    DT.print(OS);\n  }\n\nprivate:\n  CFG *cfg;\n  DominatorTreeBase DT;\n};\n\nusing CFGDomTree = CFGDominatorTreeImpl</*IsPostDom*/ false>;\nusing CFGPostDomTree = CFGDominatorTreeImpl</*IsPostDom*/ true>;\n\ntemplate<> void CFGDominatorTreeImpl<true>::anchor();\ntemplate<> void CFGDominatorTreeImpl<false>::anchor();\n\n}",
  "id": "BLOCK-CPP-21358",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/Dominators.h",
  "source_line": 36,
  "validation_status": "validated"
}