{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/utility/utility.h\"\n#include <variant>  // IWYU pragma: export\n#include <functional>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/macros.h\"\n#include \"absl/base/port.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/types/internal/variant.h\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04536_execute() {\n    {\n//       template<typename T>\n//       void operator()(const T& i) const {\n//         std::cout << \"The variant's value is: \" << i;\n//       }\n//   };\n//\n//   // Declare our variant, and call `absl::visit()` on it.\n//   // Note that `GetVariant()` returns void in either case.\n//   absl::variant<int, std::string> foo = std::string(\"foo\");\n//   GetVariant visitor;\n//   absl::visit(visitor, foo);  // Prints `The variant's value is: foo'\ntemplate <typename Visitor, typename... Variants>\nvariant_internal::VisitResult<Visitor, Variants...> visit(Visitor&& vis,\n                                                          Variants&&... vars) {\n  return variant_internal::\n      VisitIndices<variant_size<absl::decay_t<Variants> >::value...>::Run(\n          variant_internal::PerformVisitation<Visitor, Variants...>{\n              std::forward_as_tuple(absl::forward<Variants>(vars)...),\n              absl::forward<Visitor>(vis)},\n          vars.index()...);\n}\n\n// monostate\n//\n// The monostate class serves as a first alternative type for a variant for\n// which the first variant type is otherwise not default-constructible.\nstruct monostate {};\n\n// `absl::monostate` Relational Operators\n\nconstexpr bool operator<(monostate, monostate) noexcept { return false; }\nconstexpr bool operator>(monostate, monostate) noexcept { return false; }\nconstexpr bool operator<=(monostate, monostate) noexcept { return true; }\nconstexpr bool operator>=(monostate, monostate) noexcept { return true; }\nconstexpr bool operator==(monostate, monostate) noexcept { return true; }\nconstexpr bool operator!=(monostate, monostate) noexcept { return false; }\n\n\n//------------------------------------------------------------------------------\n// `absl::variant` Template Definition\n//------------------------------------------------------------------------------\ntemplate <typename T0, typename... Tn>\nclass variant<T0, Tn...> : private variant_internal::VariantBase<T0, Tn...> {\n  static_assert(absl::conjunction<std::is_object<T0>,\n                                  std::is_object<Tn>...>::value,\n                \"Attempted to instantiate a variant containing a non-object \"\n                \"type.\");\n  // Intentionally not qualifying `negation` with `absl::` to work around a bug\n  // in MSVC 2015 with inline namespace and variadic template.\n  static_assert(absl::conjunction<negation<std::is_array<T0> >,\n                                  negation<std::is_array<Tn> >...>::value,\n                \"Attempted to instantiate a variant containing an array type.\");\n  static_assert(absl::conjunction<std::is_nothrow_destructible<T0>,\n                                  std::is_nothrow_destructible<Tn>...>::value,\n                \"Attempted to instantiate a variant containing a non-nothrow \"\n                \"destructible type.\");\n\n  friend struct variant_internal::VariantCoreAccess;\n\n private:\n  using Base = variant_internal::VariantBase<T0, Tn...>;\n\n public:\n  // Constructors\n\n  // Constructs a variant holding a default-initialized value of the first\n  // alternative type.\n  constexpr variant() /*noexcept(see 111above)*/ = default;\n\n  // Copy constructor, standard semantics\n  variant(const variant& other) = default;\n\n  // Move constructor, standard semantics\n  variant(variant&& other) /*noexcept(see above)*/ = default;\n\n  // Constructs a variant of an alternative type specified by overload\n  // resolution of the provided forwarding arguments through\n  // direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  //\n  // NOTE: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r1.html\n  // has been voted passed the design phase in the C++ standard meeting in Mar\n  // 2018. It will be implemented and integrated into `absl::variant`.\n  template <\n      class T,\n      std::size_t I = std::enable_if<\n          variant_internal::IsNeitherSelfNorInPlace<variant,\n                                                    absl::decay_t<T>>::value,\n          variant_internal::IndexOfConstructedType<variant, T>>::type::value,\n      class Tj = absl::variant_alternative_t<I, variant>,\n      absl::enable_if_t<std::is_constructible<Tj, T>::value>* =\n          nullptr>\n  constexpr variant(T&& t) noexcept(std::is_nothrow_constructible<Tj, T>::value)\n      : Base(variant_internal::EmplaceTag<I>(), absl::forward<T>(t)) {}\n\n  // Constructs a variant of an alternative type from the arguments through\n  // direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  template <class T, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::UnambiguousTypeOfT<variant, T>,\n                Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_type_t<T>, Args&&... args)\n      : Base(variant_internal::EmplaceTag<\n                 variant_internal::UnambiguousIndexOf<variant, T>::value>(),\n             absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from an initializer list\n  // and other arguments through direct-initialization.\n  //\n  // Note: If the selected constructor is a constexpr constructor, this\n  // constructor shall be a constexpr constructor.\n  template <class T, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::UnambiguousTypeOfT<variant, T>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_type_t<T>, std::initializer_list<U> il,\n                             Args&&... args)\n      : Base(variant_internal::EmplaceTag<\n                 variant_internal::UnambiguousIndexOf<variant, T>::value>(),\n             il, absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from a provided index,\n  // through value-initialization using the provided forwarded arguments.\n  template <std::size_t I, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::VariantAlternativeSfinaeT<I, variant>,\n                Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_index_t<I>, Args&&... args)\n      : Base(variant_internal::EmplaceTag<I>(), absl::forward<Args>(args)...) {}\n\n  // Constructs a variant of an alternative type from a provided index,\n  // through value-initialization of an initializer list and the provided\n  // forwarded arguments.\n  template <std::size_t I, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                variant_internal::VariantAlternativeSfinaeT<I, variant>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  constexpr explicit variant(in_place_index_t<I>, std::initializer_list<U> il,\n                             Args&&... args)\n      : Base(variant_internal::EmplaceTag<I>(), il,\n             absl::forward<Args>(args)...) {}\n\n  // Destructors\n\n  // Destroys the variant's currently contained value, provided that\n  // `absl::valueless_by_exception()` is false.\n  ~variant() = default;\n\n  // Assignment Operators\n\n  // Copy assignment operator\n  variant& operator=(const variant& other) = default;\n\n  // Move assignment operator\n  variant& operator=(variant&& other) /*noexcept(see above)*/ = default;\n\n  // Converting assignment operator\n  //\n  // NOTE: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r1.html\n  // has been voted passed the design phase in the C++ standard meeting in Mar\n  // 2018. It will be implemented and integrated into `absl::variant`.\n  template <\n      class T,\n      std::size_t I = std::enable_if<\n          !std::is_same<absl::decay_t<T>, variant>::value,\n          variant_internal::IndexOfConstructedType<variant, T>>::type::value,\n      class Tj = absl::variant_alternative_t<I, variant>,\n      typename std::enable_if<std::is_assignable<Tj&, T>::value &&\n                              std::is_constructible<Tj, T>::value>::type* =\n          nullptr>\n  variant& operator=(T&& t) noexcept(\n      std::is_nothrow_assignable<Tj&, T>::value&&\n          std::is_nothrow_constructible<Tj, T>::value) {\n    variant_internal::VisitIndices<sizeof...(Tn) + 1>::Run(\n        variant_internal::VariantCoreAccess::MakeConversionAssignVisitor(\n            this, absl::forward<T>(t)),\n        index());\n\n    return *this;\n  }\n\n\n  // emplace() Functions\n\n  // Constructs a value of the given alternative type T within the variant. The\n  // existing value of the variant is destroyed first (provided that\n  // `absl::valueless_by_exception()` is false). Requires that T is unambiguous\n  // in the variant.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, std::string> v;\n  //   v.emplace<int>(99);\n  //   v.emplace<std::string>(\"abc\");\n  template <\n      class T, class... Args,\n      typename std::enable_if<std::is_constructible<\n          absl::variant_alternative_t<\n              variant_internal::UnambiguousIndexOf<variant, T>::value, variant>,\n          Args...>::value>::type* = nullptr>\n  T& emplace(Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<\n        variant_internal::UnambiguousIndexOf<variant, T>::value>(\n        this, absl::forward<Args>(args)...);\n  }\n\n  // Constructs a value of the given alternative type T within the variant using\n  // an initializer list. The existing value of the variant is destroyed first\n  // (provided that `absl::valueless_by_exception()` is false). Requires that T\n  // is unambiguous in the variant.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, std::string> v;\n  //   v.emplace<std::vector<int>>({0, 1, 2});\n  template <\n      class T, class U, class... Args,\n      typename std::enable_if<std::is_constructible<\n          absl::variant_alternative_t<\n              variant_internal::UnambiguousIndexOf<variant, T>::value, variant>,\n          std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  T& emplace(std::initializer_list<U> il, Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<\n        variant_internal::UnambiguousIndexOf<variant, T>::value>(\n        this, il, absl::forward<Args>(args)...);\n  }\n\n  // Destroys the current value of the variant (provided that\n  // `absl::valueless_by_exception()` is false) and constructs a new value at\n  // the given index.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, int> v;\n  //   v.emplace<1>(99);\n  //   v.emplace<2>(98);\n  //   v.emplace<int>(99);  // Won't compile. 'int' isn't a unique type.\n  template <std::size_t I, class... Args,\n            typename std::enable_if<\n                std::is_constructible<absl::variant_alternative_t<I, variant>,\n                                      Args...>::value>::type* = nullptr>\n  absl::variant_alternative_t<I, variant>& emplace(Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<I>(\n        this, absl::forward<Args>(args)...);\n  }\n\n  // Destroys the current value of the variant (provided that\n  // `absl::valueless_by_exception()` is false) and constructs a new value at\n  // the given index using an initializer list and the provided arguments.\n  //\n  // Example:\n  //\n  //   absl::variant<std::vector<int>, int, int> v;\n  //   v.emplace<0>({0, 1, 2});\n  template <std::size_t I, class U, class... Args,\n            typename std::enable_if<std::is_constructible<\n                absl::variant_alternative_t<I, variant>,\n                std::initializer_list<U>&, Args...>::value>::type* = nullptr>\n  absl::variant_alternative_t<I, variant>& emplace(std::initializer_list<U> il,\n                                                   Args&&... args) {\n    return variant_internal::VariantCoreAccess::Replace<I>(\n        this, il, absl::forward<Args>(args)...);\n  }\n\n  // variant::valueless_by_exception()\n  //\n  // Returns false if and only if the variant currently holds a valid value.\n  constexpr bool valueless_by_exception() const noexcept {\n    return this->index_ == absl::variant_npos;\n  }\n\n  // variant::index()\n  //\n  // Returns the index value of the variant's currently selected alternative\n  // type.\n  constexpr std::size_t index() const noexcept { return this->index_; }\n\n  // variant::swap()\n  //\n  // Swaps the values of two variant objects.\n  //\n  void swap(variant& rhs) noexcept(\n      absl::conjunction<\n          std::is_nothrow_move_constructible<T0>,\n          std::is_nothrow_move_constructible<Tn>...,\n          type_traits_internal::IsNothrowSwappable<T0>,\n          type_traits_internal::IsNothrowSwappable<Tn>...>::value) {\n    return variant_internal::VisitIndices<sizeof...(Tn) + 1>::Run(\n        variant_internal::Swap<T0, Tn...>{this, &rhs}, rhs.index());\n  }\n};\n\n// We need a valid declaration of variant<> for SFINAE and overload resolution\n// to work properly above, but we don't need a full declaration since this type\n// will never be constructed. This declaration, though incomplete, suffices.\ntemplate <>\nclass variant<>;\n\n//------------------------------------------------------------------------------\n// Relational Operators\n//------------------------------------------------------------------------------\n//\n// If neither operand is in the `variant::valueless_by_exception` state:\n//\n//   * If the index of both variants is the same, the relational operator\n//     returns the result of the corresponding relational operator for the\n//     corresponding alternative type.\n//   * If the index of both variants is not the same, the relational operator\n//     returns the result of that operation applied to the value of the left\n//     operand's index and the value of the right operand's index.\n//   * If at least one operand is in the valueless_by_exception state:\n//     - A variant in the valueless_by_exception state is only considered equal\n//       to another variant in the valueless_by_exception state.\n//     - If exactly one operand is in the valueless_by_exception state, the\n//       variant in the valueless_by_exception state is less than the variant\n//       that is not in the valueless_by_exception state.\n//\n// Note: The value 1 is added to each index in the relational comparisons such\n// that the index corresponding to the valueless_by_exception state wraps around\n// to 0 (the lowest value for the index type), and the remaining indices stay in\n// the same relative order.\n\n// Equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveEqualT<Types...> operator==(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() == b.index()) &&\n         variant_internal::VisitIndices<sizeof...(Types)>::Run(\n             variant_internal::EqualsOp<Types...>{&a, &b}, a.index());\n}\n\n// Not equal operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveNotEqualT<Types...> operator!=(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index()) ||\n         variant_internal::VisitIndices<sizeof...(Types)>::Run(\n             variant_internal::NotEqualsOp<Types...>{&a, &b}, a.index());\n}\n\n// Less-than operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveLessThanT<Types...> operator<(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) < (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::LessThanOp<Types...>{&a, &b}, a.index());\n}\n\n// Greater-than operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveGreaterThanT<Types...> operator>(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) > (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::GreaterThanOp<Types...>{&a, &b},\n                   a.index());\n}\n\n// Less-than or equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveLessThanOrEqualT<Types...> operator<=(\n    const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) < (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::LessThanOrEqualsOp<Types...>{&a, &b},\n                   a.index());\n}\n\n// Greater-than or equal-to operator\ntemplate <typename... Types>\nconstexpr variant_internal::RequireAllHaveGreaterThanOrEqualT<Types...>\noperator>=(const variant<Types...>& a, const variant<Types...>& b) {\n  return (a.index() != b.index())\n             ? (a.index() + 1) > (b.index() + 1)\n             : variant_internal::VisitIndices<sizeof...(Types)>::Run(\n                   variant_internal::GreaterThanOrEqualsOp<Types...>{&a, &b},\n                   a.index());\n}\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04536",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/variant.h",
  "source_line": 417,
  "validation_status": "validated"
}