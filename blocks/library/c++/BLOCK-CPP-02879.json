{
  "code": "{\n  // Allow for full height trees + substring -> flat / external nodes.\n  assert(depth <= CordRepBtree::kMaxDepth + 2);\n  std::string sharing = const_cast<CordRep*>(rep)->refcount.IsOne()\n                            ? std::string(\"Private\")\n                            : absl::StrCat(\"Shared(\", rep->refcount.Get(), \")\");\n  std::string sptr = absl::StrCat(\"0x\", absl::Hex(rep));\n\n  // Dumps the data contents of `rep` if `include_contents` is true.\n  // Always emits a new line character.\n  auto maybe_dump_data = [&stream, include_contents](const CordRep* r) {\n    if (include_contents) {\n      // Allow for up to 60 wide display of content data, which with some\n      // indentation and prefix / labels keeps us within roughly 80-100 wide.\n      constexpr size_t kMaxDataLength = 60;\n      stream << \", data = \\\"\"\n             << EdgeData(r).substr(0, kMaxDataLength)\n             << (r->length > kMaxDataLength ? \"\\\"...\" : \"\\\"\");\n    }\n    stream << '\\n';\n  };\n\n  // For each level, we print the 'shared/private' state and the rep pointer,\n  // indented by two spaces per recursive depth.\n  stream << std::string(depth * 2, ' ') << sharing << \" (\" << sptr << \") \";\n\n  if (rep->IsBtree()) {\n    const CordRepBtree* node = rep->btree();\n    std::string label =\n        node->height() ? absl::StrCat(\"Node(\", node->height(), \")\") : \"Leaf\";\n    stream << label << \", len = \" << node->length\n           << \", begin = \" << node->begin() << \", end = \" << node->end()\n           << \"\\n\";\n    for (CordRep* edge : node->Edges()) {\n      DumpAll(edge, include_contents, stream, depth + 1);\n    }\n  } else if (rep->tag == SUBSTRING) {\n    const CordRepSubstring* substring = rep->substring();\n    stream << \"Substring, len = \" << rep->length\n           << \", start = \" << substring->start;\n    maybe_dump_data(rep);\n    DumpAll(substring->child, include_contents, stream, depth + 1);\n  } else if (rep->tag >= FLAT) {\n    stream << \"Flat, len = \" << rep->length\n           << \", cap = \" << rep->flat()->Capacity();\n    maybe_dump_data(rep);\n  } else if (rep->tag == EXTERNAL) {\n    stream << \"Extn, len = \" << rep->length;\n    maybe_dump_data(rep);\n  }\n}",
  "id": "BLOCK-CPP-02879",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree.cc",
  "source_line": 59,
  "validation_status": "validated"
}