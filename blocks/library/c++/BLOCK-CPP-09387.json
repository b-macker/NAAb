{
  "code": "{\n  ///   template<typename U> struct Inner;\n  ///   template<> struct Inner; // class-scope explicit specialization\n  /// };\n  /// \\endcode\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializedTemplate(ClassTemplateDecl *Specialized) {\n    SpecializedTemplate = Specialized;\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  /// If this class template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// class template or class template partial specialization from which it\n  /// was instantiated.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the class template or class template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<ClassTemplateDecl*>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate members of the class template or class template partial\n  /// specialization from which this class template specialization was\n  /// instantiated.\n  ///\n  /// \\returns For a class template specialization instantiated from the primary\n  /// template, this function will return the same template arguments as\n  /// getTemplateArgs(). For a class template specialization instantiated from\n  /// a class template partial specialization, this function will return the\n  /// deduced template arguments for the class template partial specialization\n  /// itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this class template specialization is actually an\n  /// instantiation of the given class template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Already set to a class template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this class template specialization is an instantiation\n  /// of the given class template.\n  void setInstantiationOf(ClassTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Previously set to a class template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user. This will be a class template specialization type.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          const ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstClassTemplateSpecialization &&\n           K <= lastClassTemplateSpecialization;\n  }\n}",
  "id": "BLOCK-CPP-09387",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 1938,
  "validation_status": "validated"
}