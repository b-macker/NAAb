{
  "code": "{\n\n// Arg\n//\n// This class provides an argument type for `absl::Substitute()` and\n// `absl::SubstituteAndAppend()`. `Arg` handles implicit conversion of various\n// types to a string. (`Arg` is very similar to the `AlphaNum` class in\n// `StrCat()`.)\n//\n// This class has implicit constructors.\nclass Arg {\n public:\n  // Overloads for string-y things\n  //\n  // Explicitly overload `const char*` so the compiler doesn't cast to `bool`.\n  Arg(absl::Nullable<const char*> value)  // NOLINT(google-explicit-constructor)\n      : piece_(absl::NullSafeStringView(value)) {}\n  template <typename Allocator>\n  Arg(  // NOLINT\n      const std::basic_string<char, std::char_traits<char>, Allocator>&\n          value) noexcept\n      : piece_(value) {}\n  Arg(absl::string_view value)  // NOLINT(google-explicit-constructor)\n      : piece_(value) {}\n\n  // Overloads for primitives\n  //\n  // No overloads are available for signed and unsigned char because if people\n  // are explicitly declaring their chars as signed or unsigned then they are\n  // probably using them as 8-bit integers and would probably prefer an integer\n  // representation. However, we can't really know, so we make the caller decide\n  // what to do.\n  Arg(char value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, 1) {\n    scratch_[0] = value;\n  }\n  Arg(short value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned short value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(int value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned int value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(long long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned long long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(float value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {\n  }\n  Arg(double value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {\n  }\n  Arg(bool value)  // NOLINT(google-explicit-constructor)\n      : piece_(value ? \"true\" : \"false\") {}\n\n  template <typename T, typename = typename std::enable_if<\n                            HasAbslStringify<T>::value>::type>\n  Arg(  // NOLINT(google-explicit-constructor)\n      const T& v, strings_internal::StringifySink&& sink = {})\n      : piece_(strings_internal::ExtractStringification(sink, v)) {}\n\n  Arg(Hex hex);  // NOLINT(google-explicit-constructor)\n  Arg(Dec dec);  // NOLINT(google-explicit-constructor)\n\n  // vector<bool>::reference and const_reference require special help to convert\n  // to `Arg` because it requires two user defined conversions.\n  template <typename T,\n            absl::enable_if_t<\n                std::is_class<T>::value &&\n                (std::is_same<T, std::vector<bool>::reference>::value ||\n                 std::is_same<T, std::vector<bool>::const_reference>::value)>* =\n                nullptr>\n  Arg(T value)  // NOLINT(google-explicit-constructor)\n      : Arg(static_cast<bool>(value)) {}\n\n  // `void*` values, with the exception of `char*`, are printed as\n  // \"0x<hex value>\". However, in the case of `nullptr`, \"NULL\" is printed.\n  Arg(  // NOLINT(google-explicit-constructor)\n      absl::Nullable<const void*> value);\n\n  // Normal enums are already handled by the integer formatters.\n  // This overload matches only scoped enums.\n  template <typename T,\n            typename = typename std::enable_if<\n                std::is_enum<T>{} && !std::is_convertible<T, int>{} &&\n                !HasAbslStringify<T>::value>::type>\n  Arg(T value)  // NOLINT(google-explicit-constructor)\n      : Arg(static_cast<typename std::underlying_type<T>::type>(value)) {}\n\n  Arg(const Arg&) = delete;\n  Arg& operator=(const Arg&) = delete;\n\n  absl::string_view piece() const { return piece_; }\n\n private:\n  absl::string_view piece_;\n  char scratch_[numbers_internal::kFastToBufferSize];\n};\n\n// Internal helper function. Don't call this from outside this implementation.\n// This interface may change without notice.\nvoid SubstituteAndAppendArray(\n    absl::Nonnull<std::string*> output, absl::string_view format,\n    absl::Nullable<const absl::string_view*> args_array, size_t num_args);\n\n#if defined(ABSL_BAD_CALL_IF)\nconstexpr int CalculateOneBit(absl::Nonnull<const char*> format) {\n  // Returns:\n  // * 2^N for '$N' when N is in [0-9]\n  // * 0 for correct '$' escaping: '$$'.\n  // * -1 otherwise.\n  return (*format < '0' || *format > '9') ? (*format == '$' ? 0 : -1)\n                                          : (1 << (*format - '0'));\n}\n\nconstexpr const char* SkipNumber(absl::Nonnull<const char*> format) {\n  return !*format ? format : (format + 1);\n}\n\nconstexpr int PlaceholderBitmask(absl::Nonnull<const char*> format) {\n  return !*format\n             ? 0\n             : *format != '$' ? PlaceholderBitmask(format + 1)\n                              : (CalculateOneBit(format + 1) |\n                                 PlaceholderBitmask(SkipNumber(format + 1)));\n}\n#endif  // ABSL_BAD_CALL_IF\n\n}",
  "id": "BLOCK-CPP-04295",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/substitute.h",
  "source_line": 94,
  "validation_status": "validated"
}