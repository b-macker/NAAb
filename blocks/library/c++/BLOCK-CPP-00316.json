{
  "code": "#include <spdlog/common.h>\n#include <spdlog/details/os.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string>\n\nusing namespace spdlog;\nusing namespace details;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00316_execute() {\n    {\n        close();\n        struct addrinfo hints {};\n        memset(&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = AF_UNSPEC;      // To work with IPv4, IPv6, and so on\n        hints.ai_socktype = SOCK_STREAM;  // TCP\n        hints.ai_flags = AI_NUMERICSERV;  // port passed as as numeric value\n        hints.ai_protocol = 0;\n\n        auto port_str = std::to_string(port);\n        struct addrinfo *addrinfo_result;\n        auto rv = ::getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrinfo_result);\n        if (rv != 0) {\n            throw_spdlog_ex(fmt_lib::format(\"::getaddrinfo failed: {}\", gai_strerror(rv)));\n        }\n\n        // Try each address until we successfully connect(2).\n        int last_errno = 0;\n        for (auto *rp = addrinfo_result; rp != nullptr; rp = rp->ai_next) {\n#if defined(SOCK_CLOEXEC)\n            const int flags = SOCK_CLOEXEC;\n#else\n            const int flags = 0;\n#endif\n            socket_ = ::socket(rp->ai_family, rp->ai_socktype | flags, rp->ai_protocol);\n            if (socket_ == -1) {\n                last_errno = errno;\n                continue;\n            }\n            rv = ::connect(socket_, rp->ai_addr, rp->ai_addrlen);\n            if (rv == 0) {\n                break;\n            }\n            last_errno = errno;\n            ::close(socket_);\n            socket_ = -1;\n        }\n        ::freeaddrinfo(addrinfo_result);\n        if (socket_ == -1) {\n            throw_spdlog_ex(\"::connect failed\", last_errno);\n        }\n\n        // set TCP_NODELAY\n        int enable_flag = 1;\n        ::setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&enable_flag),\n                     sizeof(enable_flag));\n\n        // prevent sigpipe on systems where MSG_NOSIGNAL is not available\n#if defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)\n        ::setsockopt(socket_, SOL_SOCKET, SO_NOSIGPIPE, reinterpret_cast<char *>(&enable_flag),\n                     sizeof(enable_flag));\n#endif\n\n#if !defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)\n    #error \"tcp_sink would raise SIGPIPE since neither SO_NOSIGPIPE nor MSG_NOSIGNAL are available\"\n#endif\n    }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00316",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/tcp_client.h",
  "source_line": 43,
  "validation_status": "validated"
}