{
  "code": "{\n  void anchor() override;\n\npublic:\n  enum AccessControl {\n    None, Private, Protected, Public, Package\n  };\n\nprivate:\n  ObjCIvarDecl(ObjCContainerDecl *DC, SourceLocation StartLoc,\n               SourceLocation IdLoc, IdentifierInfo *Id,\n               QualType T, TypeSourceInfo *TInfo, AccessControl ac, Expr *BW,\n               bool synthesized)\n      : FieldDecl(ObjCIvar, DC, StartLoc, IdLoc, Id, T, TInfo, BW,\n                  /*Mutable=*/false, /*HasInit=*/ICIS_NoInit),\n        DeclAccess(ac), Synthesized(synthesized) {}\n\npublic:\n  static ObjCIvarDecl *Create(ASTContext &C, ObjCContainerDecl *DC,\n                              SourceLocation StartLoc, SourceLocation IdLoc,\n                              IdentifierInfo *Id, QualType T,\n                              TypeSourceInfo *TInfo,\n                              AccessControl ac, Expr *BW = nullptr,\n                              bool synthesized=false);\n\n  static ObjCIvarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the class interface that this ivar is logically contained\n  /// in; this is either the interface where the ivar was declared, or the\n  /// interface the ivar is conceptually a part of in the case of synthesized\n  /// ivars.\n  ObjCInterfaceDecl *getContainingInterface();\n  const ObjCInterfaceDecl *getContainingInterface() const {\n    return const_cast<ObjCIvarDecl *>(this)->getContainingInterface();\n  }\n\n  ObjCIvarDecl *getNextIvar() { return NextIvar; }\n  const ObjCIvarDecl *getNextIvar() const { return NextIvar; }\n  void setNextIvar(ObjCIvarDecl *ivar) { NextIvar = ivar; }\n\n  ObjCIvarDecl *getCanonicalDecl() override {\n    return cast<ObjCIvarDecl>(FieldDecl::getCanonicalDecl());\n  }\n  const ObjCIvarDecl *getCanonicalDecl() const {\n    return const_cast<ObjCIvarDecl *>(this)->getCanonicalDecl();\n  }\n\n  void setAccessControl(AccessControl ac) { DeclAccess = ac; }\n\n  AccessControl getAccessControl() const { return AccessControl(DeclAccess); }\n\n  AccessControl getCanonicalAccessControl() const {\n    return DeclAccess == None ? Protected : AccessControl(DeclAccess);\n  }\n\n  void setSynthesize(bool synth) { Synthesized = synth; }\n  bool getSynthesize() const { return Synthesized; }\n\n  /// Retrieve the type of this instance variable when viewed as a member of a\n  /// specific object type.\n  QualType getUsageType(QualType objectType) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCIvar; }\n\nprivate:\n  /// NextIvar - Next Ivar in the list of ivars declared in class; class's\n  /// extensions and class's implementation\n  ObjCIvarDecl *NextIvar = nullptr;\n\n  // NOTE: VC++ treats enums as signed, avoid using the AccessControl enum\n  unsigned DeclAccess : 3;\n  unsigned Synthesized : 1;\n}",
  "id": "BLOCK-CPP-09055",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclObjC.h",
  "source_line": 1939,
  "validation_status": "validated"
}