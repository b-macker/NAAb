{
  "code": "#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/STLFunctionalExtras.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <string>\n#include <utility>\n\nusing namespace clang;\nusing namespace concepts;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-10862_execute() {\n    {\n      llvm::PointerIntPair<\n          llvm::PointerUnion<TemplateParameterList *, SubstitutionDiagnostic *>,\n          1, bool>\n          TypeConstraintInfo;\n  public:\n      friend ASTStmtReader;\n      friend ASTStmtWriter;\n\n      /// \\brief No return type requirement was specified.\n      ReturnTypeRequirement() : TypeConstraintInfo(nullptr, false) {}\n\n      /// \\brief A return type requirement was specified but it was a\n      /// substitution failure.\n      ReturnTypeRequirement(SubstitutionDiagnostic *SubstDiag) :\n          TypeConstraintInfo(SubstDiag, false) {}\n\n      /// \\brief A 'type constraint' style return type requirement.\n      /// \\param TPL an invented template parameter list containing a single\n      /// type parameter with a type-constraint.\n      // TODO: Can we maybe not save the whole template parameter list and just\n      //  the type constraint? Saving the whole TPL makes it easier to handle in\n      //  serialization but is less elegant.\n      ReturnTypeRequirement(TemplateParameterList *TPL);\n\n      bool isDependent() const {\n        return TypeConstraintInfo.getInt();\n      }\n\n      bool containsUnexpandedParameterPack() const {\n        if (!isTypeConstraint())\n          return false;\n        return getTypeConstraintTemplateParameterList()\n                ->containsUnexpandedParameterPack();\n      }\n\n      bool isEmpty() const {\n        return TypeConstraintInfo.getPointer().isNull();\n      }\n\n      bool isSubstitutionFailure() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<SubstitutionDiagnostic *>();\n      }\n\n      bool isTypeConstraint() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<TemplateParameterList *>();\n      }\n\n      SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n        assert(isSubstitutionFailure());\n        return TypeConstraintInfo.getPointer().get<SubstitutionDiagnostic *>();\n      }\n\n      const TypeConstraint *getTypeConstraint() const;\n\n      TemplateParameterList *getTypeConstraintTemplateParameterList() const {\n        assert(isTypeConstraint());\n        return TypeConstraintInfo.getPointer().get<TemplateParameterList *>();\n      }\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-10862",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprConcepts.h",
  "source_line": 268,
  "validation_status": "validated"
}