{
  "code": "{\n\nclass IdentifierInfo;\n\n/// Token - This structure provides full information about a lexed token.\n/// It is not intended to be space efficient, it is intended to return as much\n/// information as possible about each returned token.  This is expected to be\n/// compressed into a smaller form if memory footprint is important.\n///\n/// The parser can create a special \"annotation token\" representing a stream of\n/// tokens that were parsed and semantically resolved, e.g.: \"foo::MyClass<int>\"\n/// can be represented by a single typename annotation token that carries\n/// information about the SourceRange of the tokens and the type object.\nclass Token {\n  /// The location of the token. This is actually a SourceLocation.\n  SourceLocation::UIntTy Loc;\n\n  // Conceptually these next two fields could be in a union.  However, this\n  // causes gcc 4.2 to pessimize LexTokenInternal, a very performance critical\n  // routine. Keeping as separate members with casts until a more beautiful fix\n  // presents itself.\n\n  /// UintData - This holds either the length of the token text, when\n  /// a normal token, or the end of the SourceRange when an annotation\n  /// token.\n  SourceLocation::UIntTy UintData;\n\n  /// PtrData - This is a union of four different pointer types, which depends\n  /// on what type of token this is:\n  ///  Identifiers, keywords, etc:\n  ///    This is an IdentifierInfo*, which contains the uniqued identifier\n  ///    spelling.\n  ///  Literals:  isLiteral() returns true.\n  ///    This is a pointer to the start of the token in a text buffer, which\n  ///    may be dirty (have trigraphs / escaped newlines).\n  ///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().\n  ///    This is a pointer to sema-specific data for the annotation token.\n  ///  Eof:\n  //     This is a pointer to a Decl.\n  ///  Other:\n  ///    This is null.\n  void *PtrData;\n\n  /// Kind - The actual flavor of token this is.\n  tok::TokenKind Kind;\n\n  /// Flags - Bits we track about this token, members of the TokenFlags enum.\n  unsigned short Flags;\n\npublic:\n  // Various flags set per token:\n  enum TokenFlags {\n    StartOfLine = 0x01,   // At start of line or only after whitespace\n                          // (considering the line after macro expansion).\n    LeadingSpace = 0x02,  // Whitespace exists before this token (considering\n                          // whitespace after macro expansion).\n    DisableExpand = 0x04, // This identifier may never be macro expanded.\n    NeedsCleaning = 0x08, // Contained an escaped newline or trigraph.\n    LeadingEmptyMacro = 0x10, // Empty macro exists before this token.\n    HasUDSuffix = 0x20,  // This string or character literal has a ud-suffix.\n    HasUCN = 0x40,       // This identifier contains a UCN.\n    IgnoredComma = 0x80, // This comma is not a macro argument separator (MS).\n    StringifiedInMacro = 0x100, // This string or character literal is formed by\n                                // macro stringizing or charizing operator.\n    CommaAfterElided = 0x200, // The comma following this token was elided (MS).\n    IsEditorPlaceholder = 0x400, // This identifier is a placeholder.\n    IsReinjected = 0x800, // A phase 4 token that was produced before and\n                          // re-added, e.g. via EnterTokenStream. Annotation\n                          // tokens are *not* reinjected.\n  };\n\n  tok::TokenKind getKind() const { return Kind; }\n  void setKind(tok::TokenKind K) { Kind = K; }\n\n  /// is/isNot - Predicates to check if this token is a specific kind, as in\n  /// \"if (Tok.is(tok::l_brace)) {...}\".\n  bool is(tok::TokenKind K) const { return Kind == K; }\n  bool isNot(tok::TokenKind K) const { return Kind != K; }\n  bool isOneOf(tok::TokenKind K1, tok::TokenKind K2) const {\n    return is(K1) || is(K2);\n  }\n  template <typename... Ts> bool isOneOf(tok::TokenKind K1, Ts... Ks) const {\n    return is(K1) || isOneOf(Ks...);\n  }\n\n  /// Return true if this is a raw identifier (when lexing\n  /// in raw mode) or a non-keyword identifier (when lexing in non-raw mode).\n  bool isAnyIdentifier() const {\n    return tok::isAnyIdentifier(getKind());\n  }\n\n  /// Return true if this is a \"literal\", like a numeric\n  /// constant, string, etc.\n  bool isLiteral() const {\n    return tok::isLiteral(getKind());\n  }\n\n  /// Return true if this is any of tok::annot_* kind tokens.\n  bool isAnnotation() const { return tok::isAnnotation(getKind()); }\n\n  /// Return true if the token is a keyword that is parsed in the same\n  /// position as a standard attribute, but that has semantic meaning\n  /// and so cannot be a true attribute.\n  bool isRegularKeywordAttribute() const {\n    return tok::isRegularKeywordAttribute(getKind());\n  }\n\n  /// Return a source location identifier for the specified\n  /// offset in the current file.\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n  unsigned getLength() const {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    return UintData;\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n  void setLength(unsigned Len) {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    UintData = Len;\n  }\n\n  SourceLocation getAnnotationEndLoc() const {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    return SourceLocation::getFromRawEncoding(UintData ? UintData : Loc);\n  }\n  void setAnnotationEndLoc(SourceLocation L) {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    UintData = L.getRawEncoding();\n  }\n\n  SourceLocation getLastLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc() : getLocation();\n  }\n\n  SourceLocation getEndLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc()\n                          : getLocation().getLocWithOffset(getLength());\n  }\n\n  /// SourceRange of the group of tokens that this annotation token\n  /// represents.\n  SourceRange getAnnotationRange() const {\n    return SourceRange(getLocation(), getAnnotationEndLoc());\n  }\n  void setAnnotationRange(SourceRange R) {\n    setLocation(R.getBegin());\n    setAnnotationEndLoc(R.getEnd());\n  }\n\n  const char *getName() const { return tok::getTokenName(Kind); }\n\n  /// Reset all flags to cleared.\n  void startToken() {\n    Kind = tok::unknown;\n    Flags = 0;\n    PtrData = nullptr;\n    UintData = 0;\n    Loc = SourceLocation().getRawEncoding();\n  }\n\n  bool hasPtrData() const { return PtrData != nullptr; }\n\n  IdentifierInfo *getIdentifierInfo() const {\n    assert(isNot(tok::raw_identifier) &&\n           \"getIdentifierInfo() on a tok::raw_identifier token!\");\n    assert(!isAnnotation() &&\n           \"getIdentifierInfo() on an annotation token!\");\n    if (isLiteral()) return nullptr;\n    if (is(tok::eof)) return nullptr;\n    return (IdentifierInfo*) PtrData;\n  }\n  void setIdentifierInfo(IdentifierInfo *II) {\n    PtrData = (void*) II;\n  }\n\n  const void *getEofData() const {\n    assert(is(tok::eof));\n    return reinterpret_cast<const void *>(PtrData);\n  }\n  void setEofData(const void *D) {\n    assert(is(tok::eof));\n    assert(!PtrData);\n    PtrData = const_cast<void *>(D);\n  }\n\n  /// getRawIdentifier - For a raw identifier token (i.e., an identifier\n  /// lexed in raw mode), returns a reference to the text substring in the\n  /// buffer if known.\n  StringRef getRawIdentifier() const {\n    assert(is(tok::raw_identifier));\n    return StringRef(reinterpret_cast<const char *>(PtrData), getLength());\n  }\n  void setRawIdentifierData(const char *Ptr) {\n    assert(is(tok::raw_identifier));\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  /// getLiteralData - For a literal token (numeric constant, string, etc), this\n  /// returns a pointer to the start of it in the text buffer if known, null\n  /// otherwise.\n  const char *getLiteralData() const {\n    assert(isLiteral() && \"Cannot get literal data of non-literal\");\n    return reinterpret_cast<const char*>(PtrData);\n  }\n  void setLiteralData(const char *Ptr) {\n    assert(isLiteral() && \"Cannot set literal data of non-literal\");\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  void *getAnnotationValue() const {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    return PtrData;\n  }\n  void setAnnotationValue(void *val) {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    PtrData = val;\n  }\n\n  /// Set the specified flag.\n  void setFlag(TokenFlags Flag) {\n    Flags |= Flag;\n  }\n\n  /// Get the specified flag.\n  bool getFlag(TokenFlags Flag) const {\n    return (Flags & Flag) != 0;\n  }\n\n  /// Unset the specified flag.\n  void clearFlag(TokenFlags Flag) {\n    Flags &= ~Flag;\n  }\n\n  /// Return the internal represtation of the flags.\n  ///\n  /// This is only intended for low-level operations such as writing tokens to\n  /// disk.\n  unsigned getFlags() const {\n    return Flags;\n  }\n\n  /// Set a flag to either true or false.\n  void setFlagValue(TokenFlags Flag, bool Val) {\n    if (Val)\n      setFlag(Flag);\n    else\n      clearFlag(Flag);\n  }\n\n  /// isAtStartOfLine - Return true if this token is at the start of a line.\n  ///\n  bool isAtStartOfLine() const { return getFlag(StartOfLine); }\n\n  /// Return true if this token has whitespace before it.\n  ///\n  bool hasLeadingSpace() const { return getFlag(LeadingSpace); }\n\n  /// Return true if this identifier token should never\n  /// be expanded in the future, due to C99 6.10.3.4p2.\n  bool isExpandDisabled() const { return getFlag(DisableExpand); }\n\n  /// Return true if we have an ObjC keyword identifier.\n  bool isObjCAtKeyword(tok::ObjCKeywordKind objcKey) const;\n\n  /// Return the ObjC keyword kind.\n  tok::ObjCKeywordKind getObjCKeywordID() const;\n\n  /// Return true if this token has trigraphs or escaped newlines in it.\n  bool needsCleaning() const { return getFlag(NeedsCleaning); }\n\n  /// Return true if this token has an empty macro before it.\n  ///\n  bool hasLeadingEmptyMacro() const { return getFlag(LeadingEmptyMacro); }\n\n  /// Return true if this token is a string or character literal which\n  /// has a ud-suffix.\n  bool hasUDSuffix() const { return getFlag(HasUDSuffix); }\n\n  /// Returns true if this token contains a universal character name.\n  bool hasUCN() const { return getFlag(HasUCN); }\n\n  /// Returns true if this token is formed by macro by stringizing or charizing\n  /// operator.\n  bool stringifiedInMacro() const { return getFlag(StringifiedInMacro); }\n\n  /// Returns true if the comma after this token was elided.\n  bool commaAfterElided() const { return getFlag(CommaAfterElided); }\n\n  /// Returns true if this token is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. The\n  /// lexer uses identifier tokens to represent placeholders.\n  bool isEditorPlaceholder() const { return getFlag(IsEditorPlaceholder); }\n};\n\n/// Information about the conditional stack (\\#if directives)\n/// currently active.\nstruct PPConditionalInfo {\n  /// Location where the conditional started.\n  SourceLocation IfLoc;\n\n  /// True if this was contained in a skipping directive, e.g.,\n  /// in a \"\\#if 0\" block.\n  bool WasSkipping;\n\n  /// True if we have emitted tokens already, and now we're in\n  /// an \\#else block or something.  Only useful in Skipping blocks.\n  bool FoundNonSkip;\n\n  /// True if we've seen a \\#else in this block.  If so,\n  /// \\#elif/\\#else directives are not allowed.\n  bool FoundElse;\n};\n\n// Extra information needed for annonation tokens.\nstruct PragmaLoopHintInfo {\n  Token PragmaName;\n  Token Option;\n  ArrayRef<Token> Toks;\n};\n}",
  "id": "BLOCK-CPP-19196",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/Token.h",
  "source_line": 22,
  "validation_status": "validated"
}