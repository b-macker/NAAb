{
  "code": "#include <stdint.h>\n#include <cstddef>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include \"absl/base/config.h\"\n#include \"absl/hash/hash.h\"\n#include \"absl/strings/cord.h\"\n#include \"absl/strings/string_view.h\"\n#include <string_view>\n\nusing namespace absl;\nusing namespace container_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04997_execute() {\n    {\n\n// The hash of an object of type T is computed by using absl::Hash.\ntemplate <class T, class E = void>\nstruct HashEq {\n  using Hash = absl::Hash<T>;\n  using Eq = std::equal_to<T>;\n};\n\nstruct StringHash {\n  using is_transparent = void;\n\n  size_t operator()(absl::string_view v) const {\n    return absl::Hash<absl::string_view>{}(v);\n  }\n  size_t operator()(const absl::Cord& v) const {\n    return absl::Hash<absl::Cord>{}(v);\n  }\n};\n\nstruct StringEq {\n  using is_transparent = void;\n  bool operator()(absl::string_view lhs, absl::string_view rhs) const {\n    return lhs == rhs;\n  }\n  bool operator()(const absl::Cord& lhs, const absl::Cord& rhs) const {\n    return lhs == rhs;\n  }\n  bool operator()(const absl::Cord& lhs, absl::string_view rhs) const {\n    return lhs == rhs;\n  }\n  bool operator()(absl::string_view lhs, const absl::Cord& rhs) const {\n    return lhs == rhs;\n  }\n};\n\n// Supports heterogeneous lookup for string-like elements.\nstruct StringHashEq {\n  using Hash = StringHash;\n  using Eq = StringEq;\n};\n\ntemplate <>\nstruct HashEq<std::string> : StringHashEq {};\ntemplate <>\nstruct HashEq<absl::string_view> : StringHashEq {};\ntemplate <>\nstruct HashEq<absl::Cord> : StringHashEq {};\n\n#ifdef ABSL_HAVE_STD_STRING_VIEW\n\ntemplate <typename TChar>\nstruct BasicStringHash {\n  using is_transparent = void;\n\n  size_t operator()(std::basic_string_view<TChar> v) const {\n    return absl::Hash<std::basic_string_view<TChar>>{}(v);\n  }\n};\n\ntemplate <typename TChar>\nstruct BasicStringEq {\n  using is_transparent = void;\n  bool operator()(std::basic_string_view<TChar> lhs,\n                  std::basic_string_view<TChar> rhs) const {\n    return lhs == rhs;\n  }\n};\n\n// Supports heterogeneous lookup for w/u16/u32 string + string_view + char*.\ntemplate <typename TChar>\nstruct BasicStringHashEq {\n  using Hash = BasicStringHash<TChar>;\n  using Eq = BasicStringEq<TChar>;\n};\n\ntemplate <>\nstruct HashEq<std::wstring> : BasicStringHashEq<wchar_t> {};\ntemplate <>\nstruct HashEq<std::wstring_view> : BasicStringHashEq<wchar_t> {};\ntemplate <>\nstruct HashEq<std::u16string> : BasicStringHashEq<char16_t> {};\ntemplate <>\nstruct HashEq<std::u16string_view> : BasicStringHashEq<char16_t> {};\ntemplate <>\nstruct HashEq<std::u32string> : BasicStringHashEq<char32_t> {};\ntemplate <>\nstruct HashEq<std::u32string_view> : BasicStringHashEq<char32_t> {};\n\n#endif  // ABSL_HAVE_STD_STRING_VIEW\n\n// Supports heterogeneous lookup for pointers and smart pointers.\ntemplate <class T>\nstruct HashEq<T*> {\n  struct Hash {\n    using is_transparent = void;\n    template <class U>\n    size_t operator()(const U& ptr) const {\n      return absl::Hash<const T*>{}(HashEq::ToPtr(ptr));\n    }\n  };\n  struct Eq {\n    using is_transparent = void;\n    template <class A, class B>\n    bool operator()(const A& a, const B& b) const {\n      return HashEq::ToPtr(a) == HashEq::ToPtr(b);\n    }\n  };\n\n private:\n  static const T* ToPtr(const T* ptr) { return ptr; }\n  template <class U, class D>\n  static const T* ToPtr(const std::unique_ptr<U, D>& ptr) {\n    return ptr.get();\n  }\n  template <class U>\n  static const T* ToPtr(const std::shared_ptr<U>& ptr) {\n    return ptr.get();\n  }\n};\n\ntemplate <class T, class D>\nstruct HashEq<std::unique_ptr<T, D>> : HashEq<T*> {};\ntemplate <class T>\nstruct HashEq<std::shared_ptr<T>> : HashEq<T*> {};\n\n// This header's visibility is restricted.  If you need to access the default\n// hasher please use the container's ::hasher alias instead.\n//\n// Example: typename Hash = typename absl::flat_hash_map<K, V>::hasher\ntemplate <class T>\nusing hash_default_hash = typename container_internal::HashEq<T>::Hash;\n\n// This header's visibility is restricted.  If you need to access the default\n// key equal please use the container's ::key_equal alias instead.\n//\n// Example: typename Eq = typename absl::flat_hash_map<K, V, Hash>::key_equal\ntemplate <class T>\nusing hash_default_eq = typename container_internal::HashEq<T>::Eq;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04997",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/hash_function_defaults.h",
  "source_line": 65,
  "validation_status": "validated"
}