{
  "code": "{\npublic:\n  /// Adds \\c Node to the map with key \\c ID.\n  ///\n  /// The node's base type should be in NodeBaseType or it will be unaccessible.\n  void addNode(StringRef ID, const DynTypedNode &DynNode) {\n    NodeMap[std::string(ID)] = DynNode;\n  }\n\n  /// Returns the AST node bound to \\c ID.\n  ///\n  /// Returns NULL if there was no node bound to \\c ID or if there is a node but\n  /// it cannot be converted to the specified type.\n  template <typename T>\n  const T *getNodeAs(StringRef ID) const {\n    IDToNodeMap::const_iterator It = NodeMap.find(ID);\n    if (It == NodeMap.end()) {\n      return nullptr;\n    }\n    return It->second.get<T>();\n  }\n\n  DynTypedNode getNode(StringRef ID) const {\n    IDToNodeMap::const_iterator It = NodeMap.find(ID);\n    if (It == NodeMap.end()) {\n      return DynTypedNode();\n    }\n    return It->second;\n  }\n\n  /// Imposes an order on BoundNodesMaps.\n  bool operator<(const BoundNodesMap &Other) const {\n    return NodeMap < Other.NodeMap;\n  }\n\n  /// A map from IDs to the bound nodes.\n  ///\n  /// Note that we're using std::map here, as for memoization:\n  /// - we need a comparison operator\n  /// - we need an assignment operator\n  using IDToNodeMap = std::map<std::string, DynTypedNode, std::less<>>;\n\n  const IDToNodeMap &getMap() const {\n    return NodeMap;\n  }\n\n  /// Returns \\c true if this \\c BoundNodesMap can be compared, i.e. all\n  /// stored nodes have memoization data.\n  bool isComparable() const {\n    for (const auto &IDAndNode : NodeMap) {\n      if (!IDAndNode.second.getMemoizationData())\n        return false;\n    }\n    return true;\n  }\n\nprivate:\n  IDToNodeMap NodeMap;\n}",
  "id": "BLOCK-CPP-15252",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchersInternal.h",
  "source_line": 215,
  "validation_status": "validated"
}