{
  "code": "{\n  virtual void anchor();\n\nprotected:\n  friend class Preprocessor;\n\n  // Preprocessor object controlling lexing.\n  Preprocessor *PP = nullptr;\n\n  /// The SourceManager FileID corresponding to the file being lexed.\n  const FileID FID;\n\n  /// Number of SLocEntries before lexing the file.\n  unsigned InitialNumSLocEntries = 0;\n\n  //===--------------------------------------------------------------------===//\n  // Context-specific lexing flags set by the preprocessor.\n  //===--------------------------------------------------------------------===//\n\n  /// True when parsing \\#XXX; turns '\\\\n' into a tok::eod token.\n  bool ParsingPreprocessorDirective = false;\n\n  /// True after \\#include; turns \\<xx> or \"xxx\" into a tok::header_name token.\n  bool ParsingFilename = false;\n\n  /// True if in raw mode.\n  ///\n  /// Raw mode disables interpretation of tokens and is a far faster mode to\n  /// lex in than non-raw-mode.  This flag:\n  ///  1. If EOF of the current lexer is found, the include stack isn't popped.\n  ///  2. Identifier information is not looked up for identifier tokens.  As an\n  ///     effect of this, implicit macro expansion is naturally disabled.\n  ///  3. \"#\" tokens at the start of a line are treated as normal tokens, not\n  ///     implicitly transformed by the lexer.\n  ///  4. All diagnostic messages are disabled.\n  ///  5. No callbacks are made into the preprocessor.\n  ///\n  /// Note that in raw mode that the PP pointer may be null.\n  bool LexingRawMode = false;\n\n  /// A state machine that detects the \\#ifndef-wrapping a file\n  /// idiom for the multiple-include optimization.\n  MultipleIncludeOpt MIOpt;\n\n  /// Information about the set of \\#if/\\#ifdef/\\#ifndef blocks\n  /// we are currently in.\n  SmallVector<PPConditionalInfo, 4> ConditionalStack;\n\n  PreprocessorLexer() : FID() {}\n  PreprocessorLexer(Preprocessor *pp, FileID fid);\n  virtual ~PreprocessorLexer() = default;\n\n  virtual void IndirectLex(Token& Result) = 0;\n\n  /// Return the source location for the next observable location.\n  virtual SourceLocation getSourceLocation() = 0;\n\n  //===--------------------------------------------------------------------===//\n  // #if directive handling.\n\n  /// pushConditionalLevel - When we enter a \\#if directive, this keeps track of\n  /// what we are currently in for diagnostic emission (e.g. \\#if with missing\n  /// \\#endif).\n  void pushConditionalLevel(SourceLocation DirectiveStart, bool WasSkipping,\n                            bool FoundNonSkip, bool FoundElse) {\n    PPConditionalInfo CI;\n    CI.IfLoc = DirectiveStart;\n    CI.WasSkipping = WasSkipping;\n    CI.FoundNonSkip = FoundNonSkip;\n    CI.FoundElse = FoundElse;\n    ConditionalStack.push_back(CI);\n  }\n  void pushConditionalLevel(const PPConditionalInfo &CI) {\n    ConditionalStack.push_back(CI);\n  }\n\n  /// popConditionalLevel - Remove an entry off the top of the conditional\n  /// stack, returning information about it.  If the conditional stack is empty,\n  /// this returns true and does not fill in the arguments.\n  bool popConditionalLevel(PPConditionalInfo &CI) {\n    if (ConditionalStack.empty())\n      return true;\n    CI = ConditionalStack.pop_back_val();\n    return false;\n  }\n\n  /// Return the top of the conditional stack.\n  /// \\pre This requires that there be a conditional active.\n  PPConditionalInfo &peekConditionalLevel() {\n    assert(!ConditionalStack.empty() && \"No conditionals active!\");\n    return ConditionalStack.back();\n  }\n\n  unsigned getConditionalStackDepth() const { return ConditionalStack.size(); }\n\npublic:\n  PreprocessorLexer(const PreprocessorLexer &) = delete;\n  PreprocessorLexer &operator=(const PreprocessorLexer &) = delete;\n\n  //===--------------------------------------------------------------------===//\n  // Misc. lexing methods.\n\n  /// Lex a token, producing a header-name token if possible.\n  void LexIncludeFilename(Token &FilenameTok);\n\n  /// Inform the lexer whether or not we are currently lexing a\n  /// preprocessor directive.\n  void setParsingPreprocessorDirective(bool f) {\n    ParsingPreprocessorDirective = f;\n  }\n\n  /// Return true if this lexer is in raw mode or not.\n  bool isLexingRawMode() const { return LexingRawMode; }\n\n  /// Return the preprocessor object for this lexer.\n  Preprocessor *getPP() const { return PP; }\n\n  FileID getFileID() const {\n    assert(PP &&\n      \"PreprocessorLexer::getFileID() should only be used with a Preprocessor\");\n    return FID;\n  }\n\n  /// Number of SLocEntries before lexing the file.\n  unsigned getInitialNumSLocEntries() const {\n    return InitialNumSLocEntries;\n  }\n\n  /// getFileEntry - Return the FileEntry corresponding to this FileID.  Like\n  /// getFileID(), this only works for lexers with attached preprocessors.\n  OptionalFileEntryRefDegradesToFileEntryPtr getFileEntry() const;\n\n  /// Iterator that traverses the current stack of preprocessor\n  /// conditional directives (\\#if/\\#ifdef/\\#ifndef).\n  using conditional_iterator =\n      SmallVectorImpl<PPConditionalInfo>::const_iterator;\n\n  conditional_iterator conditional_begin() const {\n    return ConditionalStack.begin();\n  }\n\n  conditional_iterator conditional_end() const {\n    return ConditionalStack.end();\n  }\n\n  void setConditionalLevels(ArrayRef<PPConditionalInfo> CL) {\n    ConditionalStack.clear();\n    ConditionalStack.append(CL.begin(), CL.end());\n  }\n}",
  "id": "BLOCK-CPP-19132",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/PreprocessorLexer.h",
  "source_line": 30,
  "validation_status": "validated"
}