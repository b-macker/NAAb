{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <array>\n#include <cassert>\n#include <optional>\n#include <vector>\n\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-07725_execute() {\n    {\n  friend class ComparisonCategories;\n  friend class Sema;\n\npublic:\n  ComparisonCategoryInfo(const ASTContext &Ctx, CXXRecordDecl *RD,\n                         ComparisonCategoryType Kind)\n      : Ctx(Ctx), Record(RD), Kind(Kind) {}\n\n  struct ValueInfo {\n    ComparisonCategoryResult Kind;\n    VarDecl *VD;\n\n    ValueInfo(ComparisonCategoryResult Kind, VarDecl *VD)\n        : Kind(Kind), VD(VD) {}\n\n    /// True iff we've successfully evaluated the variable as a constant\n    /// expression and extracted its integer value.\n    bool hasValidIntValue() const;\n\n    /// Get the constant integer value used by this variable to represent\n    /// the comparison category result type.\n    llvm::APSInt getIntValue() const;\n  };\nprivate:\n  const ASTContext &Ctx;\n\n  /// A map containing the comparison category result decls from the\n  /// standard library. The key is a value of ComparisonCategoryResult.\n  mutable llvm::SmallVector<\n      ValueInfo, static_cast<unsigned>(ComparisonCategoryResult::Last) + 1>\n      Objects;\n\n  /// Lookup the ValueInfo struct for the specified ValueKind. If the\n  /// VarDecl for the value cannot be found, nullptr is returned.\n  ///\n  /// If the ValueInfo does not have a valid integer value the variable\n  /// is evaluated as a constant expression to determine that value.\n  ValueInfo *lookupValueInfo(ComparisonCategoryResult ValueKind) const;\n\npublic:\n  /// The declaration for the comparison category type from the\n  /// standard library.\n  const CXXRecordDecl *Record = nullptr;\n\n  /// The Kind of the comparison category type\n  ComparisonCategoryType Kind;\n\npublic:\n  QualType getType() const;\n\n  const ValueInfo *getValueInfo(ComparisonCategoryResult ValueKind) const {\n    ValueInfo *Info = lookupValueInfo(ValueKind);\n    assert(Info &&\n           \"comparison category does not contain the specified result kind\");\n    assert(Info->hasValidIntValue() &&\n           \"couldn't determine the integer constant for this value\");\n    return Info;\n  }\n\n  /// True iff the comparison is \"strong\". i.e. it checks equality and\n  /// not equivalence.\n  bool isStrong() const {\n    using CCK = ComparisonCategoryType;\n    return Kind == CCK::StrongOrdering;\n  }\n\n  /// True iff the comparison is not totally ordered.\n  bool isPartial() const {\n    using CCK = ComparisonCategoryType;\n    return Kind == CCK::PartialOrdering;\n  }\n\n  /// Converts the specified result kind into the correct result kind\n  /// for this category. Specifically it lowers strong equality results to\n  /// weak equivalence if needed.\n  ComparisonCategoryResult makeWeakResult(ComparisonCategoryResult Res) const {\n    using CCR = ComparisonCategoryResult;\n    if (!isStrong() && Res == CCR::Equal)\n      return CCR::Equivalent;\n    return Res;\n  }\n\n  const ValueInfo *getEqualOrEquiv() const {\n    return getValueInfo(makeWeakResult(ComparisonCategoryResult::Equal));\n  }\n  const ValueInfo *getLess() const {\n    return getValueInfo(ComparisonCategoryResult::Less);\n  }\n  const ValueInfo *getGreater() const {\n    return getValueInfo(ComparisonCategoryResult::Greater);\n  }\n  const ValueInfo *getUnordered() const {\n    assert(isPartial());\n    return getValueInfo(ComparisonCategoryResult::Unordered);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-07725",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ComparisonCategories.h",
  "source_line": 76,
  "validation_status": "validated"
}