{
  "code": "{\n\nclass LExpr {\npublic:\n  enum Opcode {\n    Terminal,\n    And,\n    Or,\n    Not\n  };\n  Opcode kind() const { return Kind; }\n\n  /// Logical implication. Returns true if the LExpr implies RHS, i.e. if\n  /// the LExpr holds, then RHS must hold. For example, (A & B) implies A.\n  inline bool implies(const LExpr *RHS) const;\n\nprotected:\n  LExpr(Opcode Kind) : Kind(Kind) {}\n\nprivate:\n  Opcode Kind;\n};\n\nclass Terminal : public LExpr {\n  til::SExpr *Expr;\n\npublic:\n  Terminal(til::SExpr *Expr) : LExpr(LExpr::Terminal), Expr(Expr) {}\n\n  const til::SExpr *expr() const { return Expr; }\n  til::SExpr *expr() { return Expr; }\n\n  static bool classof(const LExpr *E) { return E->kind() == LExpr::Terminal; }\n};\n\nclass BinOp : public LExpr {\n  LExpr *LHS, *RHS;\n\nprotected:\n  BinOp(LExpr *LHS, LExpr *RHS, Opcode Code) : LExpr(Code), LHS(LHS), RHS(RHS) {}\n\npublic:\n  const LExpr *left() const { return LHS; }\n  LExpr *left() { return LHS; }\n\n  const LExpr *right() const { return RHS; }\n  LExpr *right() { return RHS; }\n};\n\nclass And : public BinOp {\npublic:\n  And(LExpr *LHS, LExpr *RHS) : BinOp(LHS, RHS, LExpr::And) {}\n\n  static bool classof(const LExpr *E) { return E->kind() == LExpr::And; }\n};\n\nclass Or : public BinOp {\npublic:\n  Or(LExpr *LHS, LExpr *RHS) : BinOp(LHS, RHS, LExpr::Or) {}\n\n  static bool classof(const LExpr *E) { return E->kind() == LExpr::Or; }\n};\n\nclass Not : public LExpr {\n  LExpr *Exp;\n\npublic:\n  Not(LExpr *Exp) : LExpr(LExpr::Not), Exp(Exp) {}\n\n  const LExpr *exp() const { return Exp; }\n  LExpr *exp() { return Exp; }\n\n  static bool classof(const LExpr *E) { return E->kind() == LExpr::Not; }\n};\n\n/// Logical implication. Returns true if LHS implies RHS, i.e. if LHS\n/// holds, then RHS must hold. For example, (A & B) implies A.\nbool implies(const LExpr *LHS, const LExpr *RHS);\n\nbool LExpr::implies(const LExpr *RHS) const {\n  return lexpr::implies(this, RHS);\n}\n\n}",
  "id": "BLOCK-CPP-21482",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyLogical.h",
  "source_line": 19,
  "validation_status": "validated"
}