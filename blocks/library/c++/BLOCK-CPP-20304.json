{
  "code": "{\nprotected:\n  CapturingScopeInfo(const CapturingScopeInfo&) = default;\n\npublic:\n  enum ImplicitCaptureStyle {\n    ImpCap_None, ImpCap_LambdaByval, ImpCap_LambdaByref, ImpCap_Block,\n    ImpCap_CapturedRegion\n  };\n\n  ImplicitCaptureStyle ImpCaptureStyle;\n\n  CapturingScopeInfo(DiagnosticsEngine &Diag, ImplicitCaptureStyle Style)\n      : FunctionScopeInfo(Diag), ImpCaptureStyle(Style) {}\n\n  /// CaptureMap - A map of captured variables to (index+1) into Captures.\n  llvm::DenseMap<ValueDecl *, unsigned> CaptureMap;\n\n  /// CXXThisCaptureIndex - The (index+1) of the capture of 'this';\n  /// zero if 'this' is not captured.\n  unsigned CXXThisCaptureIndex = 0;\n\n  /// Captures - The captures.\n  SmallVector<Capture, 4> Captures;\n\n  /// - Whether the target type of return statements in this context\n  /// is deduced (e.g. a lambda or block with omitted return type).\n  bool HasImplicitReturnType = false;\n\n  /// ReturnType - The target type of return statements in this context,\n  /// or null if unknown.\n  QualType ReturnType;\n\n  void addCapture(ValueDecl *Var, bool isBlock, bool isByref, bool isNested,\n                  SourceLocation Loc, SourceLocation EllipsisLoc,\n                  QualType CaptureType, bool Invalid) {\n    Captures.push_back(Capture(Var, isBlock, isByref, isNested, Loc,\n                               EllipsisLoc, CaptureType, Invalid));\n    CaptureMap[Var] = Captures.size();\n  }\n\n  void addVLATypeCapture(SourceLocation Loc, const VariableArrayType *VLAType,\n                         QualType CaptureType) {\n    Captures.push_back(Capture(Capture::VLACapture, VLAType,\n                               /*FIXME: IsNested*/ false, Loc, CaptureType));\n  }\n\n  void addThisCapture(bool isNested, SourceLocation Loc, QualType CaptureType,\n                      bool ByCopy);\n\n  /// Determine whether the C++ 'this' is captured.\n  bool isCXXThisCaptured() const { return CXXThisCaptureIndex != 0; }\n\n  /// Retrieve the capture of C++ 'this', if it has been captured.\n  Capture &getCXXThisCapture() {\n    assert(isCXXThisCaptured() && \"this has not been captured\");\n    return Captures[CXXThisCaptureIndex - 1];\n  }\n\n  /// Determine whether the given variable has been captured.\n  bool isCaptured(ValueDecl *Var) const { return CaptureMap.count(Var); }\n\n  /// Determine whether the given variable-array type has been captured.\n  bool isVLATypeCaptured(const VariableArrayType *VAT) const;\n\n  /// Retrieve the capture of the given variable, if it has been\n  /// captured already.\n  Capture &getCapture(ValueDecl *Var) {\n    assert(isCaptured(Var) && \"Variable has not been captured\");\n    return Captures[CaptureMap[Var] - 1];\n  }\n\n  const Capture &getCapture(ValueDecl *Var) const {\n    llvm::DenseMap<ValueDecl *, unsigned>::const_iterator Known =\n        CaptureMap.find(Var);\n    assert(Known != CaptureMap.end() && \"Variable has not been captured\");\n    return Captures[Known->second - 1];\n  }\n\n  static bool classof(const FunctionScopeInfo *FSI) {\n    return FSI->Kind == SK_Block || FSI->Kind == SK_Lambda\n                                 || FSI->Kind == SK_CapturedRegion;\n  }\n}",
  "id": "BLOCK-CPP-20304",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ScopeInfo.h",
  "source_line": 673,
  "validation_status": "validated"
}