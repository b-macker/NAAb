{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace {\n\n// Since a civil time has a larger year range than absl::Time (64-bit years vs\n// 64-bit seconds, respectively) we normalize years to roughly +/- 400 years\n// around the year 2400, which will produce an equivalent year in a range that\n// absl::Time can handle.\ninline civil_year_t NormalizeYear(civil_year_t year) {\n  return 2400 + year % 400;\n}\n\n// Formats the given CivilSecond according to the given format.\nstd::string FormatYearAnd(string_view fmt, CivilSecond cs) {\n  const CivilSecond ncs(NormalizeYear(cs.year()), cs.month(), cs.day(),\n                        cs.hour(), cs.minute(), cs.second());\n  const TimeZone utc = UTCTimeZone();\n  return StrCat(cs.year(), FormatTime(fmt, FromCivil(ncs, utc), utc));\n}\n\ntemplate <typename CivilT>\nbool ParseYearAnd(string_view fmt, string_view s, CivilT* c) {\n  // Civil times support a larger year range than absl::Time, so we need to\n  // parse the year separately, normalize it, then use absl::ParseTime on the\n  // normalized string.\n  const std::string ss = std::string(s);  // TODO(absl-team): Avoid conversion.\n  const char* const np = ss.c_str();\n  char* endp;\n  errno = 0;\n  const civil_year_t y =\n      std::strtoll(np, &endp, 10);  // NOLINT(runtime/deprecated_fn)\n  if (endp == np || errno == ERANGE) return false;\n  const std::string norm = StrCat(NormalizeYear(y), endp);\n\n  const TimeZone utc = UTCTimeZone();\n  Time t;\n  if (ParseTime(StrCat(\"%Y\", fmt), norm, utc, &t, nullptr)) {\n    const auto cs = ToCivilSecond(t, utc);\n    *c = CivilT(y, cs.month(), cs.day(), cs.hour(), cs.minute(), cs.second());\n    return true;\n  }\n\n  return false;\n}\n\n// Tries to parse the type as a CivilT1, but then assigns the result to the\n// argument of type CivilT2.\ntemplate <typename CivilT1, typename CivilT2>\nbool ParseAs(string_view s, CivilT2* c) {\n  CivilT1 t1;\n  if (ParseCivilTime(s, &t1)) {\n    *c = CivilT2(t1);\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename CivilT>\nbool ParseLenient(string_view s, CivilT* c) {\n  // A fastpath for when the given string data parses exactly into the given\n  // type T (e.g., s=\"YYYY-MM-DD\" and CivilT=CivilDay).\n  if (ParseCivilTime(s, c)) return true;\n  // Try parsing as each of the 6 types, trying the most common types first\n  // (based on csearch results).\n  if (ParseAs<CivilDay>(s, c)) return true;\n  if (ParseAs<CivilSecond>(s, c)) return true;\n  if (ParseAs<CivilHour>(s, c)) return true;\n  if (ParseAs<CivilMonth>(s, c)) return true;\n  if (ParseAs<CivilMinute>(s, c)) return true;\n  if (ParseAs<CivilYear>(s, c)) return true;\n  return false;\n}\n}  // namespace\n\nstd::string FormatCivilTime(CivilSecond c) {\n  return FormatYearAnd(\"-%m-%d%ET%H:%M:%S\", c);\n}\nstd::string FormatCivilTime(CivilMinute c) {\n  return FormatYearAnd(\"-%m-%d%ET%H:%M\", c);\n}\nstd::string FormatCivilTime(CivilHour c) {\n  return FormatYearAnd(\"-%m-%d%ET%H\", c);\n}\nstd::string FormatCivilTime(CivilDay c) { return FormatYearAnd(\"-%m-%d\", c); }\nstd::string FormatCivilTime(CivilMonth c) { return FormatYearAnd(\"-%m\", c); }\nstd::string FormatCivilTime(CivilYear c) { return FormatYearAnd(\"\", c); }\n\nbool ParseCivilTime(string_view s, CivilSecond* c) {\n  return ParseYearAnd(\"-%m-%d%ET%H:%M:%S\", s, c);\n}\nbool ParseCivilTime(string_view s, CivilMinute* c) {\n  return ParseYearAnd(\"-%m-%d%ET%H:%M\", s, c);\n}\nbool ParseCivilTime(string_view s, CivilHour* c) {\n  return ParseYearAnd(\"-%m-%d%ET%H\", s, c);\n}\nbool ParseCivilTime(string_view s, CivilDay* c) {\n  return ParseYearAnd(\"-%m-%d\", s, c);\n}\nbool ParseCivilTime(string_view s, CivilMonth* c) {\n  return ParseYearAnd(\"-%m\", s, c);\n}\nbool ParseCivilTime(string_view s, CivilYear* c) {\n  return ParseYearAnd(\"\", s, c);\n}\n\nbool ParseLenientCivilTime(string_view s, CivilSecond* c) {\n  return ParseLenient(s, c);\n}\nbool ParseLenientCivilTime(string_view s, CivilMinute* c) {\n  return ParseLenient(s, c);\n}\nbool ParseLenientCivilTime(string_view s, CivilHour* c) {\n  return ParseLenient(s, c);\n}\nbool ParseLenientCivilTime(string_view s, CivilDay* c) {\n  return ParseLenient(s, c);\n}\nbool ParseLenientCivilTime(string_view s, CivilMonth* c) {\n  return ParseLenient(s, c);\n}\nbool ParseLenientCivilTime(string_view s, CivilYear* c) {\n  return ParseLenient(s, c);\n}\n\nnamespace time_internal {\n\nstd::ostream& operator<<(std::ostream& os, CivilYear y) {\n  return os << FormatCivilTime(y);\n}\nstd::ostream& operator<<(std::ostream& os, CivilMonth m) {\n  return os << FormatCivilTime(m);\n}\nstd::ostream& operator<<(std::ostream& os, CivilDay d) {\n  return os << FormatCivilTime(d);\n}\nstd::ostream& operator<<(std::ostream& os, CivilHour h) {\n  return os << FormatCivilTime(h);\n}\nstd::ostream& operator<<(std::ostream& os, CivilMinute m) {\n  return os << FormatCivilTime(m);\n}\nstd::ostream& operator<<(std::ostream& os, CivilSecond s) {\n  return os << FormatCivilTime(s);\n}\n\nbool AbslParseFlag(string_view s, CivilSecond* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nbool AbslParseFlag(string_view s, CivilMinute* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nbool AbslParseFlag(string_view s, CivilHour* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nbool AbslParseFlag(string_view s, CivilDay* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nbool AbslParseFlag(string_view s, CivilMonth* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nbool AbslParseFlag(string_view s, CivilYear* c, std::string*) {\n  return ParseLenientCivilTime(s, c);\n}\nstd::string AbslUnparseFlag(CivilSecond c) { return FormatCivilTime(c); }\nstd::string AbslUnparseFlag(CivilMinute c) { return FormatCivilTime(c); }\nstd::string AbslUnparseFlag(CivilHour c) { return FormatCivilTime(c); }\nstd::string AbslUnparseFlag(CivilDay c) { return FormatCivilTime(c); }\nstd::string AbslUnparseFlag(CivilMonth c) { return FormatCivilTime(c); }\nstd::string AbslUnparseFlag(CivilYear c) { return FormatCivilTime(c); }\n\n}  // namespace time_internal\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02150",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/civil_time.cc",
  "source_line": 24,
  "validation_status": "validated"
}