{
  "code": "{\n\nclass LangOptions;\nclass SourceManager;\n\n/// Rewriter - This is the main interface to the rewrite buffers.  Its primary\n/// job is to dispatch high-level requests to the low-level RewriteBuffers that\n/// are involved.\nclass Rewriter {\n  SourceManager *SourceMgr = nullptr;\n  const LangOptions *LangOpts = nullptr;\n  std::map<FileID, RewriteBuffer> RewriteBuffers;\n\npublic:\n  struct RewriteOptions {\n    /// Given a source range, true to include previous inserts at the\n    /// beginning of the range as part of the range itself (true by default).\n    bool IncludeInsertsAtBeginOfRange = true;\n\n    /// Given a source range, true to include previous inserts at the\n    /// end of the range as part of the range itself (true by default).\n    bool IncludeInsertsAtEndOfRange = true;\n\n    /// If true and removing some text leaves a blank line\n    /// also remove the empty line (false by default).\n    ///\n    /// FIXME: This sometimes corrupts the file's rewrite buffer due to\n    /// incorrect indexing in the implementation (see the FIXME in\n    /// clang::RewriteBuffer::RemoveText).  Moreover, it's inefficient because\n    /// it must scan the buffer from the beginning to find the start of the\n    /// line.  When feasible, it's better for the caller to check for a blank\n    /// line and then, if found, expand the removal range to include it.\n    /// Checking for a blank line is easy if, for example, the caller can\n    /// guarantee this is the first edit of a line.  In that case, it can just\n    /// scan before and after the removal range until the next newline or\n    /// begin/end of the input.\n    bool RemoveLineIfEmpty = false;\n\n    RewriteOptions() {}\n  };\n\n  using buffer_iterator = std::map<FileID, RewriteBuffer>::iterator;\n  using const_buffer_iterator = std::map<FileID, RewriteBuffer>::const_iterator;\n\n  explicit Rewriter() = default;\n  explicit Rewriter(SourceManager &SM, const LangOptions &LO)\n      : SourceMgr(&SM), LangOpts(&LO) {}\n\n  void setSourceMgr(SourceManager &SM, const LangOptions &LO) {\n    SourceMgr = &SM;\n    LangOpts = &LO;\n  }\n\n  SourceManager &getSourceMgr() const { return *SourceMgr; }\n  const LangOptions &getLangOpts() const { return *LangOpts; }\n\n  /// isRewritable - Return true if this location is a raw file location, which\n  /// is rewritable.  Locations from macros, etc are not rewritable.\n  static bool isRewritable(SourceLocation Loc) {\n    return Loc.isFileID();\n  }\n\n  /// getRangeSize - Return the size in bytes of the specified range if they\n  /// are in the same file.  If not, this returns -1.\n  int getRangeSize(SourceRange Range,\n                   RewriteOptions opts = RewriteOptions()) const;\n  int getRangeSize(const CharSourceRange &Range,\n                   RewriteOptions opts = RewriteOptions()) const;\n\n  /// getRewrittenText - Return the rewritten form of the text in the specified\n  /// range.  If the start or end of the range was unrewritable or if they are\n  /// in different buffers, this returns an empty string.\n  ///\n  /// Note that this method is not particularly efficient.\n  std::string getRewrittenText(CharSourceRange Range) const;\n\n  /// getRewrittenText - Return the rewritten form of the text in the specified\n  /// range.  If the start or end of the range was unrewritable or if they are\n  /// in different buffers, this returns an empty string.\n  ///\n  /// Note that this method is not particularly efficient.\n  std::string getRewrittenText(SourceRange Range) const {\n    return getRewrittenText(CharSourceRange::getTokenRange(Range));\n  }\n\n  /// InsertText - Insert the specified string at the specified location in the\n  /// original buffer.  This method returns true (and does nothing) if the input\n  /// location was not rewritable, false otherwise.\n  ///\n  /// \\param indentNewLines if true new lines in the string are indented\n  /// using the indentation of the source line in position \\p Loc.\n  bool InsertText(SourceLocation Loc, StringRef Str,\n                  bool InsertAfter = true, bool indentNewLines = false);\n\n  /// InsertTextAfter - Insert the specified string at the specified location in\n  ///  the original buffer.  This method returns true (and does nothing) if\n  ///  the input location was not rewritable, false otherwise.  Text is\n  ///  inserted after any other text that has been previously inserted\n  ///  at the some point (the default behavior for InsertText).\n  bool InsertTextAfter(SourceLocation Loc, StringRef Str) {\n    return InsertText(Loc, Str);\n  }\n\n  /// Insert the specified string after the token in the\n  /// specified location.\n  bool InsertTextAfterToken(SourceLocation Loc, StringRef Str);\n\n  /// InsertText - Insert the specified string at the specified location in the\n  /// original buffer.  This method returns true (and does nothing) if the input\n  /// location was not rewritable, false otherwise.  Text is\n  /// inserted before any other text that has been previously inserted\n  /// at the some point.\n  bool InsertTextBefore(SourceLocation Loc, StringRef Str) {\n    return InsertText(Loc, Str, false);\n  }\n\n  /// RemoveText - Remove the specified text region.\n  bool RemoveText(SourceLocation Start, unsigned Length,\n                  RewriteOptions opts = RewriteOptions());\n\n  /// Remove the specified text region.\n  bool RemoveText(CharSourceRange range,\n                  RewriteOptions opts = RewriteOptions()) {\n    return RemoveText(range.getBegin(), getRangeSize(range, opts), opts);\n  }\n\n  /// Remove the specified text region.\n  bool RemoveText(SourceRange range, RewriteOptions opts = RewriteOptions()) {\n    return RemoveText(range.getBegin(), getRangeSize(range, opts), opts);\n  }\n\n  /// ReplaceText - This method replaces a range of characters in the input\n  /// buffer with a new string.  This is effectively a combined \"remove/insert\"\n  /// operation.\n  bool ReplaceText(SourceLocation Start, unsigned OrigLength,\n                   StringRef NewStr);\n\n  /// ReplaceText - This method replaces a range of characters in the input\n  /// buffer with a new string.  This is effectively a combined \"remove/insert\"\n  /// operation.\n  bool ReplaceText(CharSourceRange range, StringRef NewStr) {\n    return ReplaceText(range.getBegin(), getRangeSize(range), NewStr);\n  }\n\n  /// ReplaceText - This method replaces a range of characters in the input\n  /// buffer with a new string.  This is effectively a combined \"remove/insert\"\n  /// operation.\n  bool ReplaceText(SourceRange range, StringRef NewStr) {\n    return ReplaceText(range.getBegin(), getRangeSize(range), NewStr);\n  }\n\n  /// ReplaceText - This method replaces a range of characters in the input\n  /// buffer with a new string.  This is effectively a combined \"remove/insert\"\n  /// operation.\n  bool ReplaceText(SourceRange range, SourceRange replacementRange);\n\n  /// Increase indentation for the lines between the given source range.\n  /// To determine what the indentation should be, 'parentIndent' is used\n  /// that should be at a source location with an indentation one degree\n  /// lower than the given range.\n  bool IncreaseIndentation(CharSourceRange range, SourceLocation parentIndent);\n  bool IncreaseIndentation(SourceRange range, SourceLocation parentIndent) {\n    return IncreaseIndentation(CharSourceRange::getTokenRange(range),\n                               parentIndent);\n  }\n\n  /// getEditBuffer - This is like getRewriteBufferFor, but always returns a\n  /// buffer, and allows you to write on it directly.  This is useful if you\n  /// want efficient low-level access to apis for scribbling on one specific\n  /// FileID's buffer.\n  RewriteBuffer &getEditBuffer(FileID FID);\n\n  /// getRewriteBufferFor - Return the rewrite buffer for the specified FileID.\n  /// If no modification has been made to it, return null.\n  const RewriteBuffer *getRewriteBufferFor(FileID FID) const {\n    std::map<FileID, RewriteBuffer>::const_iterator I =\n      RewriteBuffers.find(FID);\n    return I == RewriteBuffers.end() ? nullptr : &I->second;\n  }\n\n  // Iterators over rewrite buffers.\n  buffer_iterator buffer_begin() { return RewriteBuffers.begin(); }\n  buffer_iterator buffer_end() { return RewriteBuffers.end(); }\n  const_buffer_iterator buffer_begin() const { return RewriteBuffers.begin(); }\n  const_buffer_iterator buffer_end() const { return RewriteBuffers.end(); }\n\n  /// overwriteChangedFiles - Save all changed files to disk.\n  ///\n  /// Returns true if any files were not saved successfully.\n  /// Outputs diagnostics via the source manager's diagnostic engine\n  /// in case of an error.\n  bool overwriteChangedFiles();\n\nprivate:\n  unsigned getLocationOffsetAndFileID(SourceLocation Loc, FileID &FID) const;\n};\n\n}",
  "id": "BLOCK-CPP-22163",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Rewrite/Core/Rewriter.h",
  "source_line": 24,
  "validation_status": "validated"
}