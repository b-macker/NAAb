{
  "code": "{\n public:\n  using result_type = RealType;\n\n  class param_type {\n   public:\n    using distribution_type = beta_distribution;\n\n    explicit param_type(result_type alpha, result_type beta)\n        : alpha_(alpha), beta_(beta) {\n      assert(alpha >= 0);\n      assert(beta >= 0);\n      assert(alpha <= (std::numeric_limits<result_type>::max)());\n      assert(beta <= (std::numeric_limits<result_type>::max)());\n      if (alpha == 0 || beta == 0) {\n        method_ = DEGENERATE_SMALL;\n        x_ = (alpha >= beta) ? 1 : 0;\n        return;\n      }\n      // a_ = min(beta, alpha), b_ = max(beta, alpha).\n      if (beta < alpha) {\n        inverted_ = true;\n        a_ = beta;\n        b_ = alpha;\n      } else {\n        inverted_ = false;\n        a_ = alpha;\n        b_ = beta;\n      }\n      if (a_ <= 1 && b_ >= ThresholdForLargeA()) {\n        method_ = DEGENERATE_SMALL;\n        x_ = inverted_ ? result_type(1) : result_type(0);\n        return;\n      }\n      // For threshold values, see also:\n      // Evaluation of Beta Generation Algorithms, Ying-Chao Hung, et. al.\n      // February, 2009.\n      if ((b_ < 1.0 && a_ + b_ <= 1.2) || a_ <= ThresholdForSmallA()) {\n        // Choose Joehnk over Cheng when it's faster or when Cheng encounters\n        // numerical issues.\n        method_ = JOEHNK;\n        a_ = result_type(1) / alpha_;\n        b_ = result_type(1) / beta_;\n        if (std::isinf(a_) || std::isinf(b_)) {\n          method_ = DEGENERATE_SMALL;\n          x_ = inverted_ ? result_type(1) : result_type(0);\n        }\n        return;\n      }\n      if (a_ >= ThresholdForLargeA()) {\n        method_ = DEGENERATE_LARGE;\n        // Note: on PPC for long double, evaluating\n        // `std::numeric_limits::max() / ThresholdForLargeA` results in NaN.\n        result_type r = a_ / b_;\n        x_ = (inverted_ ? result_type(1) : r) / (1 + r);\n        return;\n      }\n      x_ = a_ + b_;\n      log_x_ = std::log(x_);\n      if (a_ <= 1) {\n        method_ = CHENG_BA;\n        y_ = result_type(1) / a_;\n        gamma_ = a_ + a_;\n        return;\n      }\n      method_ = CHENG_BB;\n      result_type r = (a_ - 1) / (b_ - 1);\n      y_ = std::sqrt((1 + r) / (b_ * r * 2 - r + 1));\n      gamma_ = a_ + result_type(1) / y_;\n    }\n\n    result_type alpha() const { return alpha_; }\n    result_type beta() const { return beta_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.alpha_ == b.alpha_ && a.beta_ == b.beta_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class beta_distribution;\n\n#ifdef _MSC_VER\n    // MSVC does not have constexpr implementations for std::log and std::exp\n    // so they are computed at runtime.\n#define ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR\n#else\n#define ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR constexpr\n#endif\n\n    // The threshold for whether std::exp(1/a) is finite.\n    // Note that this value is quite large, and a smaller a_ is NOT abnormal.\n    static ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR result_type\n    ThresholdForSmallA() {\n      return result_type(1) /\n             std::log((std::numeric_limits<result_type>::max)());\n    }\n\n    // The threshold for whether a * std::log(a) is finite.\n    static ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR result_type\n    ThresholdForLargeA() {\n      return std::exp(\n          std::log((std::numeric_limits<result_type>::max)()) -\n          std::log(std::log((std::numeric_limits<result_type>::max)())) -\n          ThresholdPadding());\n    }\n\n#undef ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR\n\n    // Pad the threshold for large A for long double on PPC. This is done via a\n    // template specialization below.\n    static constexpr result_type ThresholdPadding() { return 0; }\n\n    enum Method {\n      JOEHNK,    // Uses algorithm Joehnk\n      CHENG_BA,  // Uses algorithm BA in Cheng\n      CHENG_BB,  // Uses algorithm BB in Cheng\n\n      // Note: See also:\n      //   Hung et al. Evaluation of beta generation algorithms. Communications\n      //   in Statistics-Simulation and Computation 38.4 (2009): 750-770.\n      // especially:\n      //   Zechner, Heinz, and Ernst Stadlober. Generating beta variates via\n      //   patchwork rejection. Computing 50.1 (1993): 1-18.\n\n      DEGENERATE_SMALL,  // a_ is abnormally small.\n      DEGENERATE_LARGE,  // a_ is abnormally large.\n    };\n\n    result_type alpha_;\n    result_type beta_;\n\n    result_type a_;  // the smaller of {alpha, beta}, or 1.0/alpha_ in JOEHNK\n    result_type b_;  // the larger of {alpha, beta}, or 1.0/beta_ in JOEHNK\n    result_type x_;  // alpha + beta, or the result in degenerate cases\n    result_type log_x_;  // log(x_)\n    result_type y_;      // \"beta\" in Cheng\n    result_type gamma_;  // \"gamma\" in Cheng\n\n    Method method_;\n\n    // Placing this last for optimal alignment.\n    // Whether alpha_ != a_, i.e. true iff alpha_ > beta_.\n    bool inverted_;\n\n    static_assert(std::is_floating_point<RealType>::value,\n                  \"Class-template absl::beta_distribution<> must be \"\n                  \"parameterized using a floating-point type.\");\n  };\n\n  beta_distribution() : beta_distribution(1) {}\n\n  explicit beta_distribution(result_type alpha, result_type beta = 1)\n      : param_(alpha, beta) {}\n\n  explicit beta_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // Generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const { return 1; }\n\n  result_type alpha() const { return param_.alpha(); }\n  result_type beta() const { return param_.beta(); }\n\n  friend bool operator==(const beta_distribution& a,\n                         const beta_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const beta_distribution& a,\n                         const beta_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  template <typename URBG>\n  result_type AlgorithmJoehnk(URBG& g,  // NOLINT(runtime/references)\n                              const param_type& p);\n\n  template <typename URBG>\n  result_type AlgorithmCheng(URBG& g,  // NOLINT(runtime/references)\n                             const param_type& p);\n\n  template <typename URBG>\n  result_type DegenerateCase(URBG& g,  // NOLINT(runtime/references)\n                             const param_type& p) {\n    if (p.method_ == param_type::DEGENERATE_SMALL && p.alpha_ == p.beta_) {\n      // Returns 0 or 1 with equal probability.\n      random_internal::FastUniformBits<uint8_t> fast_u8;\n      return static_cast<result_type>((fast_u8(g) & 0x10) !=\n                                      0);  // pick any single bit.\n    }\n    return p.x_;\n  }\n\n  param_type param_;\n  random_internal::FastUniformBits<uint64_t> fast_u64_;\n}",
  "id": "BLOCK-CPP-03809",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/beta_distribution.h",
  "source_line": 48,
  "validation_status": "validated"
}