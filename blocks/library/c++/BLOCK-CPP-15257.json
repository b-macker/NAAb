{
  "code": "{\npublic:\n  /// Takes ownership of the provided implementation pointer.\n  explicit Matcher(MatcherInterface<T> *Implementation)\n      : Implementation(Implementation) {}\n\n  /// Implicitly converts \\c Other to a Matcher<T>.\n  ///\n  /// Requires \\c T to be derived from \\c From.\n  template <typename From>\n  Matcher(const Matcher<From> &Other,\n          std::enable_if_t<std::is_base_of<From, T>::value &&\n                           !std::is_same<From, T>::value> * = nullptr)\n      : Implementation(restrictMatcher(Other.Implementation)) {\n    assert(Implementation.getSupportedKind().isSame(\n        ASTNodeKind::getFromNodeKind<T>()));\n  }\n\n  /// Implicitly converts \\c Matcher<Type> to \\c Matcher<QualType>.\n  ///\n  /// The resulting matcher is not strict, i.e. ignores qualifiers.\n  template <typename TypeT>\n  Matcher(const Matcher<TypeT> &Other,\n          std::enable_if_t<std::is_same<T, QualType>::value &&\n                           std::is_same<TypeT, Type>::value> * = nullptr)\n      : Implementation(new TypeToQualType<TypeT>(Other)) {}\n\n  /// Convert \\c this into a \\c Matcher<T> by applying dyn_cast<> to the\n  /// argument.\n  /// \\c To must be a base class of \\c T.\n  template <typename To> Matcher<To> dynCastTo() const & {\n    static_assert(std::is_base_of<To, T>::value, \"Invalid dynCast call.\");\n    return Matcher<To>(Implementation);\n  }\n\n  template <typename To> Matcher<To> dynCastTo() && {\n    static_assert(std::is_base_of<To, T>::value, \"Invalid dynCast call.\");\n    return Matcher<To>(std::move(Implementation));\n  }\n\n  /// Forwards the call to the underlying MatcherInterface<T> pointer.\n  bool matches(const T &Node,\n               ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const {\n    return Implementation.matches(DynTypedNode::create(Node), Finder, Builder);\n  }\n\n  /// Returns an ID that uniquely identifies the matcher.\n  DynTypedMatcher::MatcherIDType getID() const {\n    return Implementation.getID();\n  }\n\n  /// Extract the dynamic matcher.\n  ///\n  /// The returned matcher keeps the same restrictions as \\c this and remembers\n  /// that it is meant to support nodes of type \\c T.\n  operator DynTypedMatcher() const & { return Implementation; }\n\n  operator DynTypedMatcher() && { return std::move(Implementation); }\n\n  /// Allows the conversion of a \\c Matcher<Type> to a \\c\n  /// Matcher<QualType>.\n  ///\n  /// Depending on the constructor argument, the matcher is either strict, i.e.\n  /// does only matches in the absence of qualifiers, or not, i.e. simply\n  /// ignores any qualifiers.\n  template <typename TypeT>\n  class TypeToQualType : public MatcherInterface<QualType> {\n    const DynTypedMatcher InnerMatcher;\n\n  public:\n    TypeToQualType(const Matcher<TypeT> &InnerMatcher)\n        : InnerMatcher(InnerMatcher) {}\n\n    bool matches(const QualType &Node, ASTMatchFinder *Finder,\n                 BoundNodesTreeBuilder *Builder) const override {\n      if (Node.isNull())\n        return false;\n      return this->InnerMatcher.matches(DynTypedNode::create(*Node), Finder,\n                                        Builder);\n    }\n\n    std::optional<clang::TraversalKind> TraversalKind() const override {\n      return this->InnerMatcher.getTraversalKind();\n    }\n  };\n\nprivate:\n  // For Matcher<T> <=> Matcher<U> conversions.\n  template <typename U> friend class Matcher;\n\n  // For DynTypedMatcher::unconditionalConvertTo<T>.\n  friend class DynTypedMatcher;\n\n  static DynTypedMatcher restrictMatcher(const DynTypedMatcher &Other) {\n    return Other.dynCastTo(ASTNodeKind::getFromNodeKind<T>());\n  }\n\n  explicit Matcher(const DynTypedMatcher &Implementation)\n      : Implementation(restrictMatcher(Implementation)) {\n    assert(this->Implementation.getSupportedKind().isSame(\n        ASTNodeKind::getFromNodeKind<T>()));\n  }\n\n  DynTypedMatcher Implementation;\n}",
  "id": "BLOCK-CPP-15257",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchersInternal.h",
  "source_line": 568,
  "validation_status": "validated"
}