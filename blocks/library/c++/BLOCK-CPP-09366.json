{
  "code": "{\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// class template.\n  struct Common : CommonBase {\n    /// The class template specializations for this class\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<ClassTemplateSpecializationDecl> Specializations;\n\n    /// The class template partial specializations for this class\n    /// template.\n    llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl>\n      PartialSpecializations;\n\n    /// The injected-class-name type for this class template.\n    QualType InjectedClassNameType;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this class template.\n  llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  ClassTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName Name, TemplateParameterList *Params,\n                    NamedDecl *Decl)\n      : RedeclarableTemplateDecl(ClassTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  void setCommonPtr(Common *C) {\n    RedeclarableTemplateDecl::Common = C;\n  }\n\npublic:\n\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class TemplateDeclInstantiator;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying class declarations of the template.\n  CXXRecordDecl *getTemplatedDecl() const {\n    return static_cast<CXXRecordDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// class pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// \\brief Create a class template node.\n  static ClassTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L,\n                                   DeclarationName Name,\n                                   TemplateParameterList *Params,\n                                   NamedDecl *Decl);\n\n  /// Create an empty class template node.\n  static ClassTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  ClassTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(ClassTemplateSpecializationDecl *D, void *InsertPos);\n\n  ClassTemplateDecl *getCanonicalDecl() override {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const ClassTemplateDecl *getCanonicalDecl() const {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this class template, or\n  /// nullptr if no such declaration exists.\n  ClassTemplateDecl *getPreviousDecl() {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const ClassTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  ClassTemplateDecl *getMostRecentDecl() {\n    return cast<ClassTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const ClassTemplateDecl *getMostRecentDecl() const {\n    return const_cast<ClassTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  ClassTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(ClassTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<ClassTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a class template partial specialization with the given\n  /// type T.\n  ///\n  /// \\param T a dependent type that names a specialization of this class\n  /// template.\n  ///\n  /// \\returns the class template partial specialization that exactly matches\n  /// the type \\p T, or nullptr if no such partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *findPartialSpecialization(QualType T);\n\n  /// Find a class template partial specialization which was instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member class template partial specialization.\n  ///\n  /// \\returns the class template partial specialization which was instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecInstantiatedFromMember(\n                                     ClassTemplatePartialSpecializationDecl *D);\n\n  /// Retrieve the template specialization type of the\n  /// injected-class-name for this class template.\n  ///\n  /// The injected-class-name for a class template \\c X is \\c\n  /// X<template-args>, where \\c template-args is formed from the\n  /// template arguments that correspond to the template parameters of\n  /// \\c X. For example:\n  ///\n  /// \\code\n  /// template<typename T, int N>\n  /// struct array {\n  ///   typedef array this_type; // \"array\" is equivalent to \"array<T, N>\"\n  /// };\n  /// \\endcode\n  QualType getInjectedClassNameSpecialization();\n\n  using spec_iterator = SpecIterator<ClassTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ClassTemplate; }\n}",
  "id": "BLOCK-CPP-09366",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 2272,
  "validation_status": "validated"
}