{
  "code": "{\n  class ElementList {\n    using ImplTy = BumpVector<CFGElement>;\n\n    ImplTy Impl;\n\n  public:\n    ElementList(BumpVectorContext &C) : Impl(C, 4) {}\n\n    using iterator = std::reverse_iterator<ImplTy::iterator>;\n    using const_iterator = std::reverse_iterator<ImplTy::const_iterator>;\n    using reverse_iterator = ImplTy::iterator;\n    using const_reverse_iterator = ImplTy::const_iterator;\n    using const_reference = ImplTy::const_reference;\n\n    void push_back(CFGElement e, BumpVectorContext &C) { Impl.push_back(e, C); }\n\n    reverse_iterator insert(reverse_iterator I, size_t Cnt, CFGElement E,\n        BumpVectorContext &C) {\n      return Impl.insert(I, Cnt, E, C);\n    }\n\n    const_reference front() const { return Impl.back(); }\n    const_reference back() const { return Impl.front(); }\n\n    iterator begin() { return Impl.rbegin(); }\n    iterator end() { return Impl.rend(); }\n    const_iterator begin() const { return Impl.rbegin(); }\n    const_iterator end() const { return Impl.rend(); }\n    reverse_iterator rbegin() { return Impl.begin(); }\n    reverse_iterator rend() { return Impl.end(); }\n    const_reverse_iterator rbegin() const { return Impl.begin(); }\n    const_reverse_iterator rend() const { return Impl.end(); }\n\n    CFGElement operator[](size_t i) const  {\n      assert(i < Impl.size());\n      return Impl[Impl.size() - 1 - i];\n    }\n\n    size_t size() const { return Impl.size(); }\n    bool empty() const { return Impl.empty(); }\n  };\n\n  /// A convenience class for comparing CFGElements, since methods of CFGBlock\n  /// like operator[] return CFGElements by value. This is practically a wrapper\n  /// around a (CFGBlock, Index) pair.\n  template <bool IsConst> class ElementRefImpl {\n\n    template <bool IsOtherConst> friend class ElementRefImpl;\n\n    using CFGBlockPtr =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using CFGElementPtr =\n        std::conditional_t<IsConst, const CFGElement *, CFGElement *>;\n\n  protected:\n    CFGBlockPtr Parent;\n    size_t Index;\n\n  public:\n    ElementRefImpl(CFGBlockPtr Parent, size_t Index)\n        : Parent(Parent), Index(Index) {}\n\n    template <bool IsOtherConst>\n    ElementRefImpl(ElementRefImpl<IsOtherConst> Other)\n        : ElementRefImpl(Other.Parent, Other.Index) {}\n\n    size_t getIndexInBlock() const { return Index; }\n\n    CFGBlockPtr getParent() { return Parent; }\n    CFGBlockPtr getParent() const { return Parent; }\n\n    bool operator<(ElementRefImpl Other) const {\n      return std::make_pair(Parent, Index) <\n             std::make_pair(Other.Parent, Other.Index);\n    }\n\n    bool operator==(ElementRefImpl Other) const {\n      return Parent == Other.Parent && Index == Other.Index;\n    }\n\n    bool operator!=(ElementRefImpl Other) const { return !(*this == Other); }\n    CFGElement operator*() const { return (*Parent)[Index]; }\n    CFGElementPtr operator->() const { return &*(Parent->begin() + Index); }\n\n    void dumpToStream(llvm::raw_ostream &OS) const {\n      OS << getIndexInBlock() + 1 << \": \";\n      (*this)->dumpToStream(OS);\n    }\n\n    void dump() const {\n      dumpToStream(llvm::errs());\n    }\n  };\n\n  template <bool IsReverse, bool IsConst> class ElementRefIterator {\n\n    template <bool IsOtherReverse, bool IsOtherConst>\n    friend class ElementRefIterator;\n\n    using CFGBlockRef =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using UnderlayingIteratorTy = std::conditional_t<\n        IsConst,\n        std::conditional_t<IsReverse, ElementList::const_reverse_iterator,\n                           ElementList::const_iterator>,\n        std::conditional_t<IsReverse, ElementList::reverse_iterator,\n                           ElementList::iterator>>;\n\n    using IteratorTraits = typename std::iterator_traits<UnderlayingIteratorTy>;\n    using ElementRef = typename CFGBlock::ElementRefImpl<IsConst>;\n\n  public:\n    using difference_type = typename IteratorTraits::difference_type;\n    using value_type = ElementRef;\n    using pointer = ElementRef *;\n    using iterator_category = typename IteratorTraits::iterator_category;\n\n  private:\n    CFGBlockRef Parent;\n    UnderlayingIteratorTy Pos;\n\n  public:\n    ElementRefIterator(CFGBlockRef Parent, UnderlayingIteratorTy Pos)\n        : Parent(Parent), Pos(Pos) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<false, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, E.Pos.base()) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<true, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, std::make_reverse_iterator(E.Pos)) {}\n\n    bool operator<(ElementRefIterator Other) const {\n      assert(Parent == Other.Parent);\n      return Pos < Other.Pos;\n    }\n\n    bool operator==(ElementRefIterator Other) const {\n      return Parent == Other.Parent && Pos == Other.Pos;\n    }\n\n    bool operator!=(ElementRefIterator Other) const {\n      return !(*this == Other);\n    }\n\n  private:\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<true, IsOtherConst> E) {\n      return E.Parent->size() - (E.Pos - E.Parent->rbegin()) - 1;\n    }\n\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<false, IsOtherConst> E) {\n      return E.Pos - E.Parent->begin();\n    }\n\n  public:\n    value_type operator*() { return {Parent, getIndexInBlock(*this)}; }\n\n    difference_type operator-(ElementRefIterator Other) const {\n      return Pos - Other.Pos;\n    }\n\n    ElementRefIterator operator++() {\n      ++this->Pos;\n      return *this;\n    }\n    ElementRefIterator operator++(int) {\n      ElementRefIterator Ret = *this;\n      ++*this;\n      return Ret;\n    }\n    ElementRefIterator operator+(size_t count) {\n      this->Pos += count;\n      return *this;\n    }\n    ElementRefIterator operator-(size_t count) {\n      this->Pos -= count;\n      return *this;\n    }\n  };\n\npublic:\n  /// The set of statements in the basic block.\n  ElementList Elements;\n\n  /// An (optional) label that prefixes the executable statements in the block.\n  /// When this variable is non-NULL, it is either an instance of LabelStmt,\n  /// SwitchCase or CXXCatchStmt.\n  Stmt *Label = nullptr;\n\n  /// The terminator for a basic block that indicates the type of control-flow\n  /// that occurs between a block and its successors.\n  CFGTerminator Terminator;\n\n  /// Some blocks are used to represent the \"loop edge\" to the start of a loop\n  /// from within the loop body. This Stmt* will be refer to the loop statement\n  /// for such blocks (and be null otherwise).\n  const Stmt *LoopTarget = nullptr;\n\n  /// A numerical ID assigned to a CFGBlock during construction of the CFG.\n  unsigned BlockID;\n\npublic:\n  /// This class represents a potential adjacent block in the CFG.  It encodes\n  /// whether or not the block is actually reachable, or can be proved to be\n  /// trivially unreachable.  For some cases it allows one to encode scenarios\n  /// where a block was substituted because the original (now alternate) block\n  /// is unreachable.\n  class AdjacentBlock {\n    enum Kind {\n      AB_Normal,\n      AB_Unreachable,\n      AB_Alternate\n    };\n\n    CFGBlock *ReachableBlock;\n    llvm::PointerIntPair<CFGBlock *, 2> UnreachableBlock;\n\n  public:\n    /// Construct an AdjacentBlock with a possibly unreachable block.\n    AdjacentBlock(CFGBlock *B, bool IsReachable);\n\n    /// Construct an AdjacentBlock with a reachable block and an alternate\n    /// unreachable block.\n    AdjacentBlock(CFGBlock *B, CFGBlock *AlternateBlock);\n\n    /// Get the reachable block, if one exists.\n    CFGBlock *getReachableBlock() const {\n      return ReachableBlock;\n    }\n\n    /// Get the potentially unreachable block.\n    CFGBlock *getPossiblyUnreachableBlock() const {\n      return UnreachableBlock.getPointer();\n    }\n\n    /// Provide an implicit conversion to CFGBlock* so that\n    /// AdjacentBlock can be substituted for CFGBlock*.\n    operator CFGBlock*() const {\n      return getReachableBlock();\n    }\n\n    CFGBlock& operator *() const {\n      return *getReachableBlock();\n    }\n\n    CFGBlock* operator ->() const {\n      return getReachableBlock();\n    }\n\n    bool isReachable() const {\n      Kind K = (Kind) UnreachableBlock.getInt();\n      return K == AB_Normal || K == AB_Alternate;\n    }\n  };\n\nprivate:\n  /// Keep track of the predecessor / successor CFG blocks.\n  using AdjacentBlocks = BumpVector<AdjacentBlock>;\n  AdjacentBlocks Preds;\n  AdjacentBlocks Succs;\n\n  /// This bit is set when the basic block contains a function call\n  /// or implicit destructor that is attributed as 'noreturn'. In that case,\n  /// control cannot technically ever proceed past this block. All such blocks\n  /// will have a single immediate successor: the exit block. This allows them\n  /// to be easily reached from the exit block and using this bit quickly\n  /// recognized without scanning the contents of the block.\n  ///\n  /// Optimization Note: This bit could be profitably folded with Terminator's\n  /// storage if the memory usage of CFGBlock becomes an issue.\n  unsigned HasNoReturnElement : 1;\n\n  /// The parent CFG that owns this CFGBlock.\n  CFG *Parent;\n\npublic:\n  explicit CFGBlock(unsigned blockid, BumpVectorContext &C, CFG *parent)\n      : Elements(C), Terminator(nullptr), BlockID(blockid), Preds(C, 1),\n        Succs(C, 1), HasNoReturnElement(false), Parent(parent) {}\n\n  // Statement iterators\n  using iterator = ElementList::iterator;\n  using const_iterator = ElementList::const_iterator;\n  using reverse_iterator = ElementList::reverse_iterator;\n  using const_reverse_iterator = ElementList::const_reverse_iterator;\n\n  size_t getIndexInCFG() const;\n\n  CFGElement                 front()       const { return Elements.front();   }\n  CFGElement                 back()        const { return Elements.back();    }\n\n  iterator                   begin()             { return Elements.begin();   }\n  iterator                   end()               { return Elements.end();     }\n  const_iterator             begin()       const { return Elements.begin();   }\n  const_iterator             end()         const { return Elements.end();     }\n\n  reverse_iterator           rbegin()            { return Elements.rbegin();  }\n  reverse_iterator           rend()              { return Elements.rend();    }\n  const_reverse_iterator     rbegin()      const { return Elements.rbegin();  }\n  const_reverse_iterator     rend()        const { return Elements.rend();    }\n\n  using CFGElementRef = ElementRefImpl<false>;\n  using ConstCFGElementRef = ElementRefImpl<true>;\n\n  using ref_iterator = ElementRefIterator<false, false>;\n  using ref_iterator_range = llvm::iterator_range<ref_iterator>;\n  using const_ref_iterator = ElementRefIterator<false, true>;\n  using const_ref_iterator_range = llvm::iterator_range<const_ref_iterator>;\n\n  using reverse_ref_iterator = ElementRefIterator<true, false>;\n  using reverse_ref_iterator_range = llvm::iterator_range<reverse_ref_iterator>;\n\n  using const_reverse_ref_iterator = ElementRefIterator<true, true>;\n  using const_reverse_ref_iterator_range =\n      llvm::iterator_range<const_reverse_ref_iterator>;\n\n  ref_iterator ref_begin() { return {this, begin()}; }\n  ref_iterator ref_end() { return {this, end()}; }\n  const_ref_iterator ref_begin() const { return {this, begin()}; }\n  const_ref_iterator ref_end() const { return {this, end()}; }\n\n  reverse_ref_iterator rref_begin() { return {this, rbegin()}; }\n  reverse_ref_iterator rref_end() { return {this, rend()}; }\n  const_reverse_ref_iterator rref_begin() const { return {this, rbegin()}; }\n  const_reverse_ref_iterator rref_end() const { return {this, rend()}; }\n\n  ref_iterator_range refs() { return {ref_begin(), ref_end()}; }\n  const_ref_iterator_range refs() const { return {ref_begin(), ref_end()}; }\n  reverse_ref_iterator_range rrefs() { return {rref_begin(), rref_end()}; }\n  const_reverse_ref_iterator_range rrefs() const {\n    return {rref_begin(), rref_end()};\n  }\n\n  unsigned                   size()        const { return Elements.size();    }\n  bool                       empty()       const { return Elements.empty();   }\n\n  CFGElement operator[](size_t i) const  { return Elements[i]; }\n\n  // CFG iterators\n  using pred_iterator = AdjacentBlocks::iterator;\n  using const_pred_iterator = AdjacentBlocks::const_iterator;\n  using pred_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_pred_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n  using pred_const_range = llvm::iterator_range<const_pred_iterator>;\n\n  using succ_iterator = AdjacentBlocks::iterator;\n  using const_succ_iterator = AdjacentBlocks::const_iterator;\n  using succ_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_succ_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n  using succ_const_range = llvm::iterator_range<const_succ_iterator>;\n\n  pred_iterator                pred_begin()        { return Preds.begin();   }\n  pred_iterator                pred_end()          { return Preds.end();     }\n  const_pred_iterator          pred_begin()  const { return Preds.begin();   }\n  const_pred_iterator          pred_end()    const { return Preds.end();     }\n\n  pred_reverse_iterator        pred_rbegin()       { return Preds.rbegin();  }\n  pred_reverse_iterator        pred_rend()         { return Preds.rend();    }\n  const_pred_reverse_iterator  pred_rbegin() const { return Preds.rbegin();  }\n  const_pred_reverse_iterator  pred_rend()   const { return Preds.rend();    }\n\n  pred_range preds() {\n    return pred_range(pred_begin(), pred_end());\n  }\n\n  pred_const_range preds() const {\n    return pred_const_range(pred_begin(), pred_end());\n  }\n\n  succ_iterator                succ_begin()        { return Succs.begin();   }\n  succ_iterator                succ_end()          { return Succs.end();     }\n  const_succ_iterator          succ_begin()  const { return Succs.begin();   }\n  const_succ_iterator          succ_end()    const { return Succs.end();     }\n\n  succ_reverse_iterator        succ_rbegin()       { return Succs.rbegin();  }\n  succ_reverse_iterator        succ_rend()         { return Succs.rend();    }\n  const_succ_reverse_iterator  succ_rbegin() const { return Succs.rbegin();  }\n  const_succ_reverse_iterator  succ_rend()   const { return Succs.rend();    }\n\n  succ_range succs() {\n    return succ_range(succ_begin(), succ_end());\n  }\n\n  succ_const_range succs() const {\n    return succ_const_range(succ_begin(), succ_end());\n  }\n\n  unsigned                     succ_size()   const { return Succs.size();    }\n  bool                         succ_empty()  const { return Succs.empty();   }\n\n  unsigned                     pred_size()   const { return Preds.size();    }\n  bool                         pred_empty()  const { return Preds.empty();   }\n\n\n  class FilterOptions {\n  public:\n    unsigned IgnoreNullPredecessors : 1;\n    unsigned IgnoreDefaultsWithCoveredEnums : 1;\n\n    FilterOptions()\n        : IgnoreNullPredecessors(1), IgnoreDefaultsWithCoveredEnums(0) {}\n  };\n\n  static bool FilterEdge(const FilterOptions &F, const CFGBlock *Src,\n       const CFGBlock *Dst);\n\n  template <typename IMPL, bool IsPred>\n  class FilteredCFGBlockIterator {\n  private:\n    IMPL I, E;\n    const FilterOptions F;\n    const CFGBlock *From;\n\n  public:\n    explicit FilteredCFGBlockIterator(const IMPL &i, const IMPL &e,\n                                      const CFGBlock *from,\n                                      const FilterOptions &f)\n        : I(i), E(e), F(f), From(from) {\n      while (hasMore() && Filter(*I))\n        ++I;\n    }\n\n    bool hasMore() const { return I != E; }\n\n    FilteredCFGBlockIterator &operator++() {\n      do { ++I; } while (hasMore() && Filter(*I));\n      return *this;\n    }\n\n    const CFGBlock *operator*() const { return *I; }\n\n  private:\n    bool Filter(const CFGBlock *To) {\n      return IsPred ? FilterEdge(F, To, From) : FilterEdge(F, From, To);\n    }\n  };\n\n  using filtered_pred_iterator =\n      FilteredCFGBlockIterator<const_pred_iterator, true>;\n\n  using filtered_succ_iterator =\n      FilteredCFGBlockIterator<const_succ_iterator, false>;\n\n  filtered_pred_iterator filtered_pred_start_end(const FilterOptions &f) const {\n    return filtered_pred_iterator(pred_begin(), pred_end(), this, f);\n  }\n\n  filtered_succ_iterator filtered_succ_start_end(const FilterOptions &f) const {\n    return filtered_succ_iterator(succ_begin(), succ_end(), this, f);\n  }\n\n  // Manipulation of block contents\n\n  void setTerminator(CFGTerminator Term) { Terminator = Term; }\n  void setLabel(Stmt *Statement) { Label = Statement; }\n  void setLoopTarget(const Stmt *loopTarget) { LoopTarget = loopTarget; }\n  void setHasNoReturnElement() { HasNoReturnElement = true; }\n\n  /// Returns true if the block would eventually end with a sink (a noreturn\n  /// node).\n  bool isInevitablySinking() const;\n\n  CFGTerminator getTerminator() const { return Terminator; }\n\n  Stmt *getTerminatorStmt() { return Terminator.getStmt(); }\n  const Stmt *getTerminatorStmt() const { return Terminator.getStmt(); }\n\n  /// \\returns the last (\\c rbegin()) condition, e.g. observe the following code\n  /// snippet:\n  ///   if (A && B && C)\n  /// A block would be created for \\c A, \\c B, and \\c C. For the latter,\n  /// \\c getTerminatorStmt() would retrieve the entire condition, rather than\n  /// C itself, while this method would only return C.\n  const Expr *getLastCondition() const;\n\n  Stmt *getTerminatorCondition(bool StripParens = true);\n\n  const Stmt *getTerminatorCondition(bool StripParens = true) const {\n    return const_cast<CFGBlock*>(this)->getTerminatorCondition(StripParens);\n  }\n\n  const Stmt *getLoopTarget() const { return LoopTarget; }\n\n  Stmt *getLabel() { return Label; }\n  const Stmt *getLabel() const { return Label; }\n\n  bool hasNoReturnElement() const { return HasNoReturnElement; }\n\n  unsigned getBlockID() const { return BlockID; }\n\n  CFG *getParent() const { return Parent; }\n\n  void dump() const;\n\n  void dump(const CFG *cfg, const LangOptions &LO, bool ShowColors = false) const;\n  void print(raw_ostream &OS, const CFG* cfg, const LangOptions &LO,\n             bool ShowColors) const;\n\n  void printTerminator(raw_ostream &OS, const LangOptions &LO) const;\n  void printTerminatorJson(raw_ostream &Out, const LangOptions &LO,\n                           bool AddQuotes) const;\n\n  void printAsOperand(raw_ostream &OS, bool /*PrintType*/) {\n    OS << \"BB#\" << getBlockID();\n  }\n\n  /// Adds a (potentially unreachable) successor block to the current block.\n  void addSuccessor(AdjacentBlock Succ, BumpVectorContext &C);\n\n  void appendStmt(Stmt *statement, BumpVectorContext &C) {\n    Elements.push_back(CFGStmt(statement), C);\n  }\n\n  void appendConstructor(CXXConstructExpr *CE, const ConstructionContext *CC,\n                         BumpVectorContext &C) {\n    Elements.push_back(CFGConstructor(CE, CC), C);\n  }\n\n  void appendCXXRecordTypedCall(Expr *E,\n                                const ConstructionContext *CC,\n                                BumpVectorContext &C) {\n    Elements.push_back(CFGCXXRecordTypedCall(E, CC), C);\n  }\n\n  void appendInitializer(CXXCtorInitializer *initializer,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGInitializer(initializer), C);\n  }\n\n  void appendNewAllocator(CXXNewExpr *NE,\n                          BumpVectorContext &C) {\n    Elements.push_back(CFGNewAllocator(NE), C);\n  }\n\n  void appendScopeBegin(const VarDecl *VD, const Stmt *S,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGScopeBegin(VD, S), C);\n  }\n\n  void appendScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGScopeEnd(VD, S), C);\n  }\n\n  void appendBaseDtor(const CXXBaseSpecifier *BS, BumpVectorContext &C) {\n    Elements.push_back(CFGBaseDtor(BS), C);\n  }\n\n  void appendMemberDtor(FieldDecl *FD, BumpVectorContext &C) {\n    Elements.push_back(CFGMemberDtor(FD), C);\n  }\n\n  void appendTemporaryDtor(CXXBindTemporaryExpr *E, BumpVectorContext &C) {\n    Elements.push_back(CFGTemporaryDtor(E), C);\n  }\n\n  void appendAutomaticObjDtor(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGAutomaticObjDtor(VD, S), C);\n  }\n\n  void appendLifetimeEnds(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGLifetimeEnds(VD, S), C);\n  }\n\n  void appendLoopExit(const Stmt *LoopStmt, BumpVectorContext &C) {\n    Elements.push_back(CFGLoopExit(LoopStmt), C);\n  }\n\n  void appendDeleteDtor(CXXRecordDecl *RD, CXXDeleteExpr *DE, BumpVectorContext &C) {\n    Elements.push_back(CFGDeleteDtor(RD, DE), C);\n  }\n}",
  "id": "BLOCK-CPP-15564",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CFG.h",
  "source_line": 576,
  "validation_status": "validated"
}