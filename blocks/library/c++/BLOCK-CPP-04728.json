{
  "code": "#include <pthread.h>\n#include <unistd.h>\n#include <atomic>\n#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/per_thread_tls.h\"\n#include \"absl/base/optimization.h\"\n\nusing namespace absl;\nusing namespace base_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04728_execute() {\n    {\n  // The internal representation of absl::Mutex and absl::CondVar rely\n  // on the alignment of PerThreadSynch. Both store the address of the\n  // PerThreadSynch in the high-order bits of their internal state,\n  // which means the low kLowZeroBits of the address of PerThreadSynch\n  // must be zero.\n  static constexpr int kLowZeroBits = 8;\n  static constexpr int kAlignment = 1 << kLowZeroBits;\n\n  // Returns the associated ThreadIdentity.\n  // This can be implemented as a cast because we guarantee\n  // PerThreadSynch is the first element of ThreadIdentity.\n  ThreadIdentity* thread_identity() {\n    return reinterpret_cast<ThreadIdentity*>(this);\n  }\n\n  PerThreadSynch* next;  // Circular waiter queue; initialized to 0.\n  PerThreadSynch* skip;  // If non-zero, all entries in Mutex queue\n                         // up to and including \"skip\" have same\n                         // condition as this, and will be woken later\n  bool may_skip;         // if false while on mutex queue, a mutex unlocker\n                         // is using this PerThreadSynch as a terminator.  Its\n                         // skip field must not be filled in because the loop\n                         // might then skip over the terminator.\n  bool wake;             // This thread is to be woken from a Mutex.\n  // If \"x\" is on a waiter list for a mutex, \"x->cond_waiter\" is true iff the\n  // waiter is waiting on the mutex as part of a CV Wait or Mutex Await.\n  //\n  // The value of \"x->cond_waiter\" is meaningless if \"x\" is not on a\n  // Mutex waiter list.\n  bool cond_waiter;\n  bool maybe_unlocking;  // Valid at head of Mutex waiter queue;\n                         // true if UnlockSlow could be searching\n                         // for a waiter to wake.  Used for an optimization\n                         // in Enqueue().  true is always a valid value.\n                         // Can be reset to false when the unlocker or any\n                         // writer releases the lock, or a reader fully\n                         // releases the lock.  It may not be set to false\n                         // by a reader that decrements the count to\n                         // non-zero. protected by mutex spinlock\n  bool suppress_fatal_errors;  // If true, try to proceed even in the face\n                               // of broken invariants.  This is used within\n                               // fatal signal handlers to improve the\n                               // chances of debug logging information being\n                               // output successfully.\n  int priority;                // Priority of thread (updated every so often).\n\n  // State values:\n  //   kAvailable: This PerThreadSynch is available.\n  //   kQueued: This PerThreadSynch is unavailable, it's currently queued on a\n  //            Mutex or CondVar waistlist.\n  //\n  // Transitions from kQueued to kAvailable require a release\n  // barrier. This is needed as a waiter may use \"state\" to\n  // independently observe that it's no longer queued.\n  //\n  // Transitions from kAvailable to kQueued require no barrier, they\n  // are externally ordered by the Mutex.\n  enum State { kAvailable, kQueued };\n  std::atomic<State> state;\n\n  // The wait parameters of the current wait.  waitp is null if the\n  // thread is not waiting. Transitions from null to non-null must\n  // occur before the enqueue commit point (state = kQueued in\n  // Enqueue() and CondVarEnqueue()). Transitions from non-null to\n  // null must occur after the wait is finished (state = kAvailable in\n  // Mutex::Block() and CondVar::WaitCommon()). This field may be\n  // changed only by the thread that describes this PerThreadSynch.  A\n  // special case is Fer(), which calls Enqueue() on another thread,\n  // but with an identical SynchWaitParams pointer, thus leaving the\n  // pointer unchanged.\n  SynchWaitParams* waitp;\n\n  intptr_t readers;  // Number of readers in mutex.\n\n  // When priority will next be read (cycles).\n  int64_t next_priority_read_cycles;\n\n  // Locks held; used during deadlock detection.\n  // Allocated in Synch_GetAllLocks() and freed in ReclaimThreadIdentity().\n  SynchLocksHeld* all_locks;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04728",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/thread_identity.h",
  "source_line": 49,
  "validation_status": "validated"
}