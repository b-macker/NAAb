{
  "code": "{\n  /// Storage for both the value *and* another parameter from which we inherit\n  /// the default argument. This is used when multiple default arguments for a\n  /// parameter are merged together from different modules.\n  struct Chain {\n    ParmDecl *PrevDeclWithDefaultArg;\n    ArgType Value;\n  };\n  static_assert(sizeof(Chain) == sizeof(void *) * 2,\n                \"non-pointer argument type?\");\n\n  llvm::PointerUnion<ArgType, ParmDecl*, Chain*> ValueOrInherited;\n\n  static ParmDecl *getParmOwningDefaultArg(ParmDecl *Parm) {\n    const DefaultArgStorage &Storage = Parm->getDefaultArgStorage();\n    if (auto *Prev = Storage.ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Parm = Prev;\n    assert(!Parm->getDefaultArgStorage()\n                .ValueOrInherited.template is<ParmDecl *>() &&\n           \"should only be one level of indirection\");\n    return Parm;\n  }\n\npublic:\n  DefaultArgStorage() : ValueOrInherited(ArgType()) {}\n\n  /// Determine whether there is a default argument for this parameter.\n  bool isSet() const { return !ValueOrInherited.isNull(); }\n\n  /// Determine whether the default argument for this parameter was inherited\n  /// from a previous declaration of the same entity.\n  bool isInherited() const { return ValueOrInherited.template is<ParmDecl*>(); }\n\n  /// Get the default argument's value. This does not consider whether the\n  /// default argument is visible.\n  ArgType get() const {\n    const DefaultArgStorage *Storage = this;\n    if (const auto *Prev = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Storage = &Prev->getDefaultArgStorage();\n    if (const auto *C = Storage->ValueOrInherited.template dyn_cast<Chain *>())\n      return C->Value;\n    return Storage->ValueOrInherited.template get<ArgType>();\n  }\n\n  /// Get the parameter from which we inherit the default argument, if any.\n  /// This is the parameter on which the default argument was actually written.\n  const ParmDecl *getInheritedFrom() const {\n    if (const auto *D = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      return D;\n    if (const auto *C = ValueOrInherited.template dyn_cast<Chain *>())\n      return C->PrevDeclWithDefaultArg;\n    return nullptr;\n  }\n\n  /// Set the default argument.\n  void set(ArgType Arg) {\n    assert(!isSet() && \"default argument already set\");\n    ValueOrInherited = Arg;\n  }\n\n  /// Set that the default argument was inherited from another parameter.\n  void setInherited(const ASTContext &C, ParmDecl *InheritedFrom) {\n    InheritedFrom = getParmOwningDefaultArg(InheritedFrom);\n    if (!isSet())\n      ValueOrInherited = InheritedFrom;\n    else if (auto *D = ValueOrInherited.template dyn_cast<ParmDecl *>()) {\n      assert(C.isSameDefaultTemplateArgument(D, InheritedFrom));\n      ValueOrInherited =\n          new (allocateDefaultArgStorageChain(C)) Chain{InheritedFrom, get()};\n    } else if (auto *Inherited =\n                   ValueOrInherited.template dyn_cast<Chain *>()) {\n      assert(C.isSameDefaultTemplateArgument(Inherited->PrevDeclWithDefaultArg,\n                                             InheritedFrom));\n      Inherited->PrevDeclWithDefaultArg = InheritedFrom;\n    } else\n      ValueOrInherited = new (allocateDefaultArgStorageChain(C))\n          Chain{InheritedFrom, ValueOrInherited.template get<ArgType>()};\n  }\n\n  /// Remove the default argument, even if it was inherited.\n  void clear() {\n    ValueOrInherited = ArgType();\n  }\n}",
  "id": "BLOCK-CPP-09356",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 314,
  "validation_status": "validated"
}