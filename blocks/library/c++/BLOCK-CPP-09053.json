{
  "code": "{\n  void anchor() override;\n\npublic:\n  enum SetterKind { Assign, Retain, Copy, Weak };\n  enum PropertyControl { None, Required, Optional };\n\nprivate:\n  // location of \\@property\n  SourceLocation AtLoc;\n\n  // location of '(' starting attribute list or null.\n  SourceLocation LParenLoc;\n\n  QualType DeclType;\n  TypeSourceInfo *DeclTypeSourceInfo;\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n  unsigned PropertyAttributesAsWritten : NumObjCPropertyAttrsBits;\n\n  // \\@required/\\@optional\n  unsigned PropertyImplementation : 2;\n\n  // getter name of NULL if no getter\n  Selector GetterName;\n\n  // setter name of NULL if no setter\n  Selector SetterName;\n\n  // location of the getter attribute's value\n  SourceLocation GetterNameLoc;\n\n  // location of the setter attribute's value\n  SourceLocation SetterNameLoc;\n\n  // Declaration of getter instance method\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n\n  // Declaration of setter instance method\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  // Synthesize ivar for this property\n  ObjCIvarDecl *PropertyIvarDecl = nullptr;\n\n  ObjCPropertyDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                   SourceLocation AtLocation, SourceLocation LParenLocation,\n                   QualType T, TypeSourceInfo *TSI, PropertyControl propControl)\n      : NamedDecl(ObjCProperty, DC, L, Id), AtLoc(AtLocation),\n        LParenLoc(LParenLocation), DeclType(T), DeclTypeSourceInfo(TSI),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr),\n        PropertyAttributesAsWritten(ObjCPropertyAttribute::kind_noattr),\n        PropertyImplementation(propControl) {}\n\npublic:\n  static ObjCPropertyDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n         SourceLocation AtLocation, SourceLocation LParenLocation, QualType T,\n         TypeSourceInfo *TSI, PropertyControl propControl = None);\n\n  static ObjCPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const { return DeclTypeSourceInfo; }\n\n  QualType getType() const { return DeclType; }\n\n  void setType(QualType T, TypeSourceInfo *TSI) {\n    DeclType = T;\n    DeclTypeSourceInfo = TSI;\n  }\n\n  /// Retrieve the type when this property is used with a specific base object\n  /// type.\n  QualType getUsageType(QualType objectType) const;\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes |= PRVal;\n  }\n\n  void overwritePropertyAttributes(unsigned PRVal) {\n    PropertyAttributes = PRVal;\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributesAsWritten() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributesAsWritten);\n  }\n\n  void setPropertyAttributesAsWritten(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributesAsWritten = PRVal;\n  }\n\n  // Helper methods for accessing attributes.\n\n  /// isReadOnly - Return true iff the property has a setter.\n  bool isReadOnly() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_readonly);\n  }\n\n  /// isAtomic - Return true if the property is atomic.\n  bool isAtomic() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_atomic);\n  }\n\n  /// isRetaining - Return true if the property retains its value.\n  bool isRetaining() const {\n    return (PropertyAttributes & (ObjCPropertyAttribute::kind_retain |\n                                  ObjCPropertyAttribute::kind_strong |\n                                  ObjCPropertyAttribute::kind_copy));\n  }\n\n  bool isInstanceProperty() const { return !isClassProperty(); }\n  bool isClassProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_class;\n  }\n  bool isDirectProperty() const;\n\n  ObjCPropertyQueryKind getQueryKind() const {\n    return isClassProperty() ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                               ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  static ObjCPropertyQueryKind getQueryKind(bool isClassProperty) {\n    return isClassProperty ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                             ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  /// getSetterKind - Return the method used for doing assignment in\n  /// the property setter. This is only valid if the property has been\n  /// defined to have a setter.\n  SetterKind getSetterKind() const {\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_strong)\n      return getType()->isBlockPointerType() ? Copy : Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_retain)\n      return Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_copy)\n      return Copy;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_weak)\n      return Weak;\n    return Assign;\n  }\n\n  Selector getGetterName() const { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n\n  void setGetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    GetterName = Sel;\n    GetterNameLoc = Loc;\n  }\n\n  Selector getSetterName() const { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n\n  void setSetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    SetterName = Sel;\n    SetterNameLoc = Loc;\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *gDecl) { GetterMethodDecl = gDecl; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *gDecl) { SetterMethodDecl = gDecl; }\n\n  // Related to \\@optional/\\@required declared in \\@protocol\n  void setPropertyImplementation(PropertyControl pc) {\n    PropertyImplementation = pc;\n  }\n\n  PropertyControl getPropertyImplementation() const {\n    return PropertyControl(PropertyImplementation);\n  }\n\n  bool isOptional() const {\n    return getPropertyImplementation() == PropertyControl::Optional;\n  }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar) {\n    PropertyIvarDecl = Ivar;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(AtLoc, getLocation());\n  }\n\n  /// Get the default name of the synthesized ivar.\n  IdentifierInfo *getDefaultSynthIvarName(ASTContext &Ctx) const;\n\n  /// Lookup a property by name in the specified DeclContext.\n  static ObjCPropertyDecl *findPropertyDecl(const DeclContext *DC,\n                                            const IdentifierInfo *propertyID,\n                                            ObjCPropertyQueryKind queryKind);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProperty; }\n}",
  "id": "BLOCK-CPP-09053",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclObjC.h",
  "source_line": 729,
  "validation_status": "validated"
}