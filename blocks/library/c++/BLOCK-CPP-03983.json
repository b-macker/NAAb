{
  "code": "#include <system_error>  // NOLINT(build/c++11)\n#include \"absl/base/config.h\"\n#include \"absl/base/nullability.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03983_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// Workalike compatibility version of std::chars_format from C++17.\n//\n// This is an bitfield enumerator which can be passed to absl::from_chars to\n// configure the string-to-float conversion.\nenum class chars_format {\n  scientific = 1,\n  fixed = 2,\n  hex = 4,\n  general = fixed | scientific,\n};\n\n// The return result of a string-to-number conversion.\n//\n// `ec` will be set to `invalid_argument` if a well-formed number was not found\n// at the start of the input range, `result_out_of_range` if a well-formed\n// number was found, but it was out of the representable range of the requested\n// type, or to std::errc() otherwise.\n//\n// If a well-formed number was found, `ptr` is set to one past the sequence of\n// characters that were successfully parsed.  If none was found, `ptr` is set\n// to the `first` argument to from_chars.\nstruct from_chars_result {\n  absl::Nonnull<const char*> ptr;\n  std::errc ec;\n};\n\n// Workalike compatibility version of std::from_chars from C++17.  Currently\n// this only supports the `double` and `float` types.\n//\n// This interface incorporates the proposed resolutions for library issues\n// DR 3080 and DR 3081.  If these are adopted with different wording,\n// Abseil's behavior will change to match the standard.  (The behavior most\n// likely to change is for DR 3081, which says what `value` will be set to in\n// the case of overflow and underflow.  Code that wants to avoid possible\n// breaking changes in this area should not depend on `value` when the returned\n// from_chars_result indicates a range error.)\n//\n// Searches the range [first, last) for the longest matching pattern beginning\n// at `first` that represents a floating point number.  If one is found, store\n// the result in `value`.\n//\n// The matching pattern format is almost the same as that of strtod(), except\n// that (1) C locale is not respected, (2) an initial '+' character in the\n// input range will never be matched, and (3) leading whitespaces are not\n// ignored.\n//\n// If `fmt` is set, it must be one of the enumerator values of the chars_format.\n// (This is despite the fact that chars_format is a bitmask type.)  If set to\n// `scientific`, a matching number must contain an exponent.  If set to `fixed`,\n// then an exponent will never match.  (For example, the string \"1e5\" will be\n// parsed as \"1\".)  If set to `hex`, then a hexadecimal float is parsed in the\n// format that strtod() accepts, except that a \"0x\" prefix is NOT matched.\n// (In particular, in `hex` mode, the input \"0xff\" results in the largest\n// matching pattern \"0\".)\nabsl::from_chars_result from_chars(absl::Nonnull<const char*> first,\n                                   absl::Nonnull<const char*> last,\n                                   double& value,  // NOLINT\n                                   chars_format fmt = chars_format::general);\n\nabsl::from_chars_result from_chars(absl::Nonnull<const char*> first,\n                                   absl::Nonnull<const char*> last,\n                                   float& value,  // NOLINT\n                                   chars_format fmt = chars_format::general);\n\n// std::chars_format is specified as a bitmask type, which means the following\n// operations must be provided:\ninline constexpr chars_format operator&(chars_format lhs, chars_format rhs) {\n  return static_cast<chars_format>(static_cast<int>(lhs) &\n                                   static_cast<int>(rhs));\n}\ninline constexpr chars_format operator|(chars_format lhs, chars_format rhs) {\n  return static_cast<chars_format>(static_cast<int>(lhs) |\n                                   static_cast<int>(rhs));\n}\ninline constexpr chars_format operator^(chars_format lhs, chars_format rhs) {\n  return static_cast<chars_format>(static_cast<int>(lhs) ^\n                                   static_cast<int>(rhs));\n}\ninline constexpr chars_format operator~(chars_format arg) {\n  return static_cast<chars_format>(~static_cast<int>(arg));\n}\ninline chars_format& operator&=(chars_format& lhs, chars_format rhs) {\n  lhs = lhs & rhs;\n  return lhs;\n}\ninline chars_format& operator|=(chars_format& lhs, chars_format rhs) {\n  lhs = lhs | rhs;\n  return lhs;\n}\ninline chars_format& operator^=(chars_format& lhs, chars_format rhs) {\n  lhs = lhs ^ rhs;\n  return lhs;\n}\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03983",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/charconv.h",
  "source_line": 23,
  "validation_status": "validated"
}