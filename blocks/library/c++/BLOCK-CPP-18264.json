{
  "code": "{\n  /// The options used in this compiler instance.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// The diagnostics engine instance.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diagnostics;\n\n  /// The target being compiled for.\n  IntrusiveRefCntPtr<TargetInfo> Target;\n\n  /// Auxiliary Target info.\n  IntrusiveRefCntPtr<TargetInfo> AuxTarget;\n\n  /// The file manager.\n  IntrusiveRefCntPtr<FileManager> FileMgr;\n\n  /// The source manager.\n  IntrusiveRefCntPtr<SourceManager> SourceMgr;\n\n  /// The cache of PCM files.\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n\n  /// The preprocessor.\n  std::shared_ptr<Preprocessor> PP;\n\n  /// The AST context.\n  IntrusiveRefCntPtr<ASTContext> Context;\n\n  /// An optional sema source that will be attached to sema.\n  IntrusiveRefCntPtr<ExternalSemaSource> ExternalSemaSrc;\n\n  /// The AST consumer.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The code completion consumer.\n  std::unique_ptr<CodeCompleteConsumer> CompletionConsumer;\n\n  /// The semantic analysis object.\n  std::unique_ptr<Sema> TheSema;\n\n  /// The frontend timer group.\n  std::unique_ptr<llvm::TimerGroup> FrontendTimerGroup;\n\n  /// The frontend timer.\n  std::unique_ptr<llvm::Timer> FrontendTimer;\n\n  /// The ASTReader, if one exists.\n  IntrusiveRefCntPtr<ASTReader> TheASTReader;\n\n  /// The module dependency collector for crashdumps\n  std::shared_ptr<ModuleDependencyCollector> ModuleDepCollector;\n\n  /// The module provider.\n  std::shared_ptr<PCHContainerOperations> ThePCHContainerOperations;\n\n  std::vector<std::shared_ptr<DependencyCollector>> DependencyCollectors;\n\n  /// The set of top-level modules that has already been built on the\n  /// fly as part of this overall compilation action.\n  std::map<std::string, std::string, std::less<>> BuiltModules;\n\n  /// Should we delete the BuiltModules when we're done?\n  bool DeleteBuiltModules = true;\n\n  /// The location of the module-import keyword for the last module\n  /// import.\n  SourceLocation LastModuleImportLoc;\n\n  /// The result of the last module import.\n  ///\n  ModuleLoadResult LastModuleImportResult;\n\n  /// Whether we should (re)build the global module index once we\n  /// have finished with this translation unit.\n  bool BuildGlobalModuleIndex = false;\n\n  /// We have a full global module index, with all modules.\n  bool HaveFullGlobalModuleIndex = false;\n\n  /// One or more modules failed to build.\n  bool DisableGeneratingGlobalModuleIndex = false;\n\n  /// The stream for verbose output if owned, otherwise nullptr.\n  std::unique_ptr<raw_ostream> OwnedVerboseOutputStream;\n\n  /// The stream for verbose output.\n  raw_ostream *VerboseOutputStream = &llvm::errs();\n\n  /// Holds information about the output file.\n  ///\n  /// If TempFilename is not empty we must rename it to Filename at the end.\n  /// TempFilename may be empty and Filename non-empty if creating the temporary\n  /// failed.\n  struct OutputFile {\n    std::string Filename;\n    std::optional<llvm::sys::fs::TempFile> File;\n\n    OutputFile(std::string filename,\n               std::optional<llvm::sys::fs::TempFile> file)\n        : Filename(std::move(filename)), File(std::move(file)) {}\n  };\n\n  /// The list of active output files.\n  std::list<OutputFile> OutputFiles;\n\n  /// Force an output buffer.\n  std::unique_ptr<llvm::raw_pwrite_stream> OutputStream;\n\n  CompilerInstance(const CompilerInstance &) = delete;\n  void operator=(const CompilerInstance &) = delete;\npublic:\n  explicit CompilerInstance(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n          std::make_shared<PCHContainerOperations>(),\n      InMemoryModuleCache *SharedModuleCache = nullptr);\n  ~CompilerInstance() override;\n\n  /// @name High-Level Operations\n  /// {\n\n  /// ExecuteAction - Execute the provided action against the compiler's\n  /// CompilerInvocation object.\n  ///\n  /// This function makes the following assumptions:\n  ///\n  ///  - The invocation options should be initialized. This function does not\n  ///    handle the '-help' or '-version' options, clients should handle those\n  ///    directly.\n  ///\n  ///  - The diagnostics engine should have already been created by the client.\n  ///\n  ///  - No other CompilerInstance state should have been initialized (this is\n  ///    an unchecked error).\n  ///\n  ///  - Clients should have initialized any LLVM target features that may be\n  ///    required.\n  ///\n  ///  - Clients should eventually call llvm_shutdown() upon the completion of\n  ///    this routine to ensure that any managed objects are properly destroyed.\n  ///\n  /// Note that this routine may write output to 'stderr'.\n  ///\n  /// \\param Act - The action to execute.\n  /// \\return - True on success.\n  //\n  // FIXME: Eliminate the llvm_shutdown requirement, that should either be part\n  // of the context or else not CompilerInstance specific.\n  bool ExecuteAction(FrontendAction &Act);\n\n  /// Load the list of plugins requested in the \\c FrontendOptions.\n  void LoadRequestedPlugins();\n\n  /// }\n  /// @name Compiler Invocation and Options\n  /// {\n\n  bool hasInvocation() const { return Invocation != nullptr; }\n\n  CompilerInvocation &getInvocation() {\n    assert(Invocation && \"Compiler instance has no invocation!\");\n    return *Invocation;\n  }\n\n  std::shared_ptr<CompilerInvocation> getInvocationPtr() { return Invocation; }\n\n  /// setInvocation - Replace the current invocation.\n  void setInvocation(std::shared_ptr<CompilerInvocation> Value);\n\n  /// Indicates whether we should (re)build the global module index.\n  bool shouldBuildGlobalModuleIndex() const;\n\n  /// Set the flag indicating whether we should (re)build the global\n  /// module index.\n  void setBuildGlobalModuleIndex(bool Build) {\n    BuildGlobalModuleIndex = Build;\n  }\n\n  /// }\n  /// @name Forwarding Methods\n  /// {\n\n  AnalyzerOptionsRef getAnalyzerOpts() {\n    return Invocation->getAnalyzerOpts();\n  }\n\n  CodeGenOptions &getCodeGenOpts() {\n    return Invocation->getCodeGenOpts();\n  }\n  const CodeGenOptions &getCodeGenOpts() const {\n    return Invocation->getCodeGenOpts();\n  }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return Invocation->getDependencyOutputOpts();\n  }\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return Invocation->getDependencyOutputOpts();\n  }\n\n  DiagnosticOptions &getDiagnosticOpts() {\n    return Invocation->getDiagnosticOpts();\n  }\n  const DiagnosticOptions &getDiagnosticOpts() const {\n    return Invocation->getDiagnosticOpts();\n  }\n\n  FileSystemOptions &getFileSystemOpts() {\n    return Invocation->getFileSystemOpts();\n  }\n  const FileSystemOptions &getFileSystemOpts() const {\n    return Invocation->getFileSystemOpts();\n  }\n\n  FrontendOptions &getFrontendOpts() {\n    return Invocation->getFrontendOpts();\n  }\n  const FrontendOptions &getFrontendOpts() const {\n    return Invocation->getFrontendOpts();\n  }\n\n  HeaderSearchOptions &getHeaderSearchOpts() {\n    return Invocation->getHeaderSearchOpts();\n  }\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return Invocation->getHeaderSearchOpts();\n  }\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return Invocation->getHeaderSearchOptsPtr();\n  }\n\n  LangOptions &getLangOpts() {\n    return *Invocation->getLangOpts();\n  }\n  const LangOptions &getLangOpts() const {\n    return *Invocation->getLangOpts();\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() {\n    return Invocation->getPreprocessorOpts();\n  }\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return Invocation->getPreprocessorOpts();\n  }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n\n  TargetOptions &getTargetOpts() {\n    return Invocation->getTargetOpts();\n  }\n  const TargetOptions &getTargetOpts() const {\n    return Invocation->getTargetOpts();\n  }\n\n  /// }\n  /// @name Diagnostics Engine\n  /// {\n\n  bool hasDiagnostics() const { return Diagnostics != nullptr; }\n\n  /// Get the current diagnostics engine.\n  DiagnosticsEngine &getDiagnostics() const {\n    assert(Diagnostics && \"Compiler instance has no diagnostics!\");\n    return *Diagnostics;\n  }\n\n  IntrusiveRefCntPtr<DiagnosticsEngine> getDiagnosticsPtr() const {\n    assert(Diagnostics && \"Compiler instance has no diagnostics!\");\n    return Diagnostics;\n  }\n\n  /// setDiagnostics - Replace the current diagnostics engine.\n  void setDiagnostics(DiagnosticsEngine *Value);\n\n  DiagnosticConsumer &getDiagnosticClient() const {\n    assert(Diagnostics && Diagnostics->getClient() &&\n           \"Compiler instance has no diagnostic client!\");\n    return *Diagnostics->getClient();\n  }\n\n  /// }\n  /// @name VerboseOutputStream\n  /// }\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(raw_ostream &Value);\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(std::unique_ptr<raw_ostream> Value);\n\n  /// Get the current stream for verbose output.\n  raw_ostream &getVerboseOutputStream() {\n    return *VerboseOutputStream;\n  }\n\n  /// }\n  /// @name Target Info\n  /// {\n\n  bool hasTarget() const { return Target != nullptr; }\n\n  TargetInfo &getTarget() const {\n    assert(Target && \"Compiler instance has no target!\");\n    return *Target;\n  }\n\n  IntrusiveRefCntPtr<TargetInfo> getTargetPtr() const {\n    assert(Target && \"Compiler instance has no target!\");\n    return Target;\n  }\n\n  /// Replace the current Target.\n  void setTarget(TargetInfo *Value);\n\n  /// }\n  /// @name AuxTarget Info\n  /// {\n\n  TargetInfo *getAuxTarget() const { return AuxTarget.get(); }\n\n  /// Replace the current AuxTarget.\n  void setAuxTarget(TargetInfo *Value);\n\n  // Create Target and AuxTarget based on current options\n  bool createTarget();\n\n  /// }\n  /// @name Virtual File System\n  /// {\n\n  llvm::vfs::FileSystem &getVirtualFileSystem() const;\n\n  /// }\n  /// @name File Manager\n  /// {\n\n  bool hasFileManager() const { return FileMgr != nullptr; }\n\n  /// Return the current file manager to the caller.\n  FileManager &getFileManager() const {\n    assert(FileMgr && \"Compiler instance has no file manager!\");\n    return *FileMgr;\n  }\n\n  IntrusiveRefCntPtr<FileManager> getFileManagerPtr() const {\n    assert(FileMgr && \"Compiler instance has no file manager!\");\n    return FileMgr;\n  }\n\n  void resetAndLeakFileManager() {\n    llvm::BuryPointer(FileMgr.get());\n    FileMgr.resetWithoutRelease();\n  }\n\n  /// Replace the current file manager and virtual file system.\n  void setFileManager(FileManager *Value);\n\n  /// }\n  /// @name Source Manager\n  /// {\n\n  bool hasSourceManager() const { return SourceMgr != nullptr; }\n\n  /// Return the current source manager.\n  SourceManager &getSourceManager() const {\n    assert(SourceMgr && \"Compiler instance has no source manager!\");\n    return *SourceMgr;\n  }\n\n  IntrusiveRefCntPtr<SourceManager> getSourceManagerPtr() const {\n    assert(SourceMgr && \"Compiler instance has no source manager!\");\n    return SourceMgr;\n  }\n\n  void resetAndLeakSourceManager() {\n    llvm::BuryPointer(SourceMgr.get());\n    SourceMgr.resetWithoutRelease();\n  }\n\n  /// setSourceManager - Replace the current source manager.\n  void setSourceManager(SourceManager *Value);\n\n  /// }\n  /// @name Preprocessor\n  /// {\n\n  bool hasPreprocessor() const { return PP != nullptr; }\n\n  /// Return the current preprocessor.\n  Preprocessor &getPreprocessor() const {\n    assert(PP && \"Compiler instance has no preprocessor!\");\n    return *PP;\n  }\n\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() { return PP; }\n\n  void resetAndLeakPreprocessor() {\n    llvm::BuryPointer(new std::shared_ptr<Preprocessor>(PP));\n  }\n\n  /// Replace the current preprocessor.\n  void setPreprocessor(std::shared_ptr<Preprocessor> Value);\n\n  /// }\n  /// @name ASTContext\n  /// {\n\n  bool hasASTContext() const { return Context != nullptr; }\n\n  ASTContext &getASTContext() const {\n    assert(Context && \"Compiler instance has no AST context!\");\n    return *Context;\n  }\n\n  IntrusiveRefCntPtr<ASTContext> getASTContextPtr() const {\n    assert(Context && \"Compiler instance has no AST context!\");\n    return Context;\n  }\n\n  void resetAndLeakASTContext() {\n    llvm::BuryPointer(Context.get());\n    Context.resetWithoutRelease();\n  }\n\n  /// setASTContext - Replace the current AST context.\n  void setASTContext(ASTContext *Value);\n\n  /// Replace the current Sema; the compiler instance takes ownership\n  /// of S.\n  void setSema(Sema *S);\n\n  /// }\n  /// @name ASTConsumer\n  /// {\n\n  bool hasASTConsumer() const { return (bool)Consumer; }\n\n  ASTConsumer &getASTConsumer() const {\n    assert(Consumer && \"Compiler instance has no AST consumer!\");\n    return *Consumer;\n  }\n\n  /// takeASTConsumer - Remove the current AST consumer and give ownership to\n  /// the caller.\n  std::unique_ptr<ASTConsumer> takeASTConsumer() { return std::move(Consumer); }\n\n  /// setASTConsumer - Replace the current AST consumer; the compiler instance\n  /// takes ownership of \\p Value.\n  void setASTConsumer(std::unique_ptr<ASTConsumer> Value);\n\n  /// }\n  /// @name Semantic analysis\n  /// {\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"Compiler instance has no Sema object!\");\n    return *TheSema;\n  }\n\n  std::unique_ptr<Sema> takeSema();\n  void resetAndLeakSema();\n\n  /// }\n  /// @name Module Management\n  /// {\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n  void setASTReader(IntrusiveRefCntPtr<ASTReader> Reader);\n\n  std::shared_ptr<ModuleDependencyCollector> getModuleDepCollector() const;\n  void setModuleDepCollector(\n      std::shared_ptr<ModuleDependencyCollector> Collector);\n\n  std::shared_ptr<PCHContainerOperations> getPCHContainerOperations() const {\n    return ThePCHContainerOperations;\n  }\n\n  /// Return the appropriate PCHContainerWriter depending on the\n  /// current CodeGenOptions.\n  const PCHContainerWriter &getPCHContainerWriter() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Writer = ThePCHContainerOperations->getWriterOrNull(Format);\n    if (!Writer) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Writer;\n  }\n\n  /// Return the appropriate PCHContainerReader depending on the\n  /// current CodeGenOptions.\n  const PCHContainerReader &getPCHContainerReader() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Reader = ThePCHContainerOperations->getReaderOrNull(Format);\n    if (!Reader) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Reader;\n  }\n\n  /// }\n  /// @name Code Completion\n  /// {\n\n  bool hasCodeCompletionConsumer() const { return (bool)CompletionConsumer; }\n\n  CodeCompleteConsumer &getCodeCompletionConsumer() const {\n    assert(CompletionConsumer &&\n           \"Compiler instance has no code completion consumer!\");\n    return *CompletionConsumer;\n  }\n\n  /// setCodeCompletionConsumer - Replace the current code completion consumer;\n  /// the compiler instance takes ownership of \\p Value.\n  void setCodeCompletionConsumer(CodeCompleteConsumer *Value);\n\n  /// }\n  /// @name Frontend timer\n  /// {\n\n  bool hasFrontendTimer() const { return (bool)FrontendTimer; }\n\n  llvm::Timer &getFrontendTimer() const {\n    assert(FrontendTimer && \"Compiler instance has no frontend timer!\");\n    return *FrontendTimer;\n  }\n\n  /// }\n  /// @name Output Files\n  /// {\n\n  /// clearOutputFiles - Clear the output file list. The underlying output\n  /// streams must have been closed beforehand.\n  ///\n  /// \\param EraseFiles - If true, attempt to erase the files from disk.\n  void clearOutputFiles(bool EraseFiles);\n\n  /// }\n  /// @name Construction Utility Methods\n  /// {\n\n  /// Create the diagnostics engine using the invocation's diagnostic options\n  /// and replace any existing one with it.\n  ///\n  /// Note that this routine also replaces the diagnostic client,\n  /// allocating one if one is not provided.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the DiagnosticsEngine inside this AST\n  /// unit.\n  ///\n  /// \\param ShouldOwnClient If Client is non-NULL, specifies whether\n  /// the diagnostic object should take ownership of the client.\n  void createDiagnostics(DiagnosticConsumer *Client = nullptr,\n                         bool ShouldOwnClient = true);\n\n  /// Create a DiagnosticsEngine object with a the TextDiagnosticPrinter.\n  ///\n  /// If no diagnostic client is provided, this creates a\n  /// DiagnosticConsumer that is owned by the returned diagnostic\n  /// object, if using directly the caller is responsible for\n  /// releasing the returned DiagnosticsEngine's client eventually.\n  ///\n  /// \\param Opts - The diagnostic options; note that the created text\n  /// diagnostic object contains a reference to these options.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the returned DiagnosticsEngine\n  /// object.\n  ///\n  /// \\param CodeGenOpts If non-NULL, the code gen options in use, which may be\n  /// used by some diagnostics printers (for logging purposes only).\n  ///\n  /// \\return The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<DiagnosticsEngine>\n  createDiagnostics(DiagnosticOptions *Opts,\n                    DiagnosticConsumer *Client = nullptr,\n                    bool ShouldOwnClient = true,\n                    const CodeGenOptions *CodeGenOpts = nullptr);\n\n  /// Create the file manager and replace any existing one with it.\n  ///\n  /// \\return The new file manager on success, or null on failure.\n  FileManager *\n  createFileManager(IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Create the source manager and replace any existing one with it.\n  void createSourceManager(FileManager &FileMgr);\n\n  /// Create the preprocessor, using the invocation, file, and source managers,\n  /// and replace any existing one with it.\n  void createPreprocessor(TranslationUnitKind TUKind);\n\n  std::string getSpecificModuleCachePath(StringRef ModuleHash);\n  std::string getSpecificModuleCachePath() {\n    return getSpecificModuleCachePath(getInvocation().getModuleHash());\n  }\n\n  /// Create the AST context.\n  void createASTContext();\n\n  /// Create an external AST source to read a PCH file and attach it to the AST\n  /// context.\n  void createPCHExternalASTSource(\n      StringRef Path, DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, void *DeserializationListener,\n      bool OwnDeserializationListener);\n\n  /// Create an external AST source to read a PCH file.\n  ///\n  /// \\return - The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<ASTReader> createPCHExternalASTSource(\n      StringRef Path, StringRef Sysroot,\n      DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, Preprocessor &PP,\n      InMemoryModuleCache &ModuleCache, ASTContext &Context,\n      const PCHContainerReader &PCHContainerRdr,\n      ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n      ArrayRef<std::shared_ptr<DependencyCollector>> DependencyCollectors,\n      void *DeserializationListener, bool OwnDeserializationListener,\n      bool Preamble, bool UseGlobalModuleIndex);\n\n  /// Create a code completion consumer using the invocation; note that this\n  /// will cause the source manager to truncate the input source file at the\n  /// completion point.\n  void createCodeCompletionConsumer();\n\n  /// Create a code completion consumer to print code completion results, at\n  /// \\p Filename, \\p Line, and \\p Column, to the given output stream \\p OS.\n  static CodeCompleteConsumer *createCodeCompletionConsumer(\n      Preprocessor &PP, StringRef Filename, unsigned Line, unsigned Column,\n      const CodeCompleteOptions &Opts, raw_ostream &OS);\n\n  /// Create the Sema object to be used for parsing.\n  void createSema(TranslationUnitKind TUKind,\n                  CodeCompleteConsumer *CompletionConsumer);\n\n  /// Create the frontend timer and replace any existing one with it.\n  void createFrontendTimer();\n\n  /// Create the default output file (from the invocation's options) and add it\n  /// to the list of tracked output files.\n  ///\n  /// The files created by this are usually removed on signal, and, depending\n  /// on FrontendOptions, may also use a temporary file (that is, the data is\n  /// written to a temporary file which will atomically replace the target\n  /// output on success).\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream> createDefaultOutputFile(\n      bool Binary = true, StringRef BaseInput = \"\", StringRef Extension = \"\",\n      bool RemoveFileOnSignal = true, bool CreateMissingDirectories = false,\n      bool ForceUseTemporary = false);\n\n  /// Create a new output file, optionally deriving the output path name, and\n  /// add it to the list of tracked output files.\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream>\n  createOutputFile(StringRef OutputPath, bool Binary, bool RemoveFileOnSignal,\n                   bool UseTemporary, bool CreateMissingDirectories = false);\n\nprivate:\n  /// Create a new output file and add it to the list of tracked output files.\n  ///\n  /// If \\p OutputPath is empty, then createOutputFile will derive an output\n  /// path location as \\p BaseInput, with any suffix removed, and \\p Extension\n  /// appended. If \\p OutputPath is not stdout and \\p UseTemporary\n  /// is true, createOutputFile will create a new temporary file that must be\n  /// renamed to \\p OutputPath in the end.\n  ///\n  /// \\param OutputPath - If given, the path to the output file.\n  /// \\param Binary - The mode to open the file in.\n  /// \\param RemoveFileOnSignal - Whether the file should be registered with\n  /// llvm::sys::RemoveFileOnSignal. Note that this is not safe for\n  /// multithreaded use, as the underlying signal mechanism is not reentrant\n  /// \\param UseTemporary - Create a new temporary file that must be renamed to\n  /// OutputPath in the end.\n  /// \\param CreateMissingDirectories - When \\p UseTemporary is true, create\n  /// missing directories in the output path.\n  Expected<std::unique_ptr<raw_pwrite_stream>>\n  createOutputFileImpl(StringRef OutputPath, bool Binary,\n                       bool RemoveFileOnSignal, bool UseTemporary,\n                       bool CreateMissingDirectories);\n\npublic:\n  std::unique_ptr<raw_pwrite_stream> createNullOutputFile();\n\n  /// }\n  /// @name Initialization Utility Methods\n  /// {\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  bool InitializeSourceManager(const FrontendInputFile &Input);\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  static bool InitializeSourceManager(const FrontendInputFile &Input,\n                                      DiagnosticsEngine &Diags,\n                                      FileManager &FileMgr,\n                                      SourceManager &SourceMgr);\n\n  /// }\n\n  void setOutputStream(std::unique_ptr<llvm::raw_pwrite_stream> OutStream) {\n    OutputStream = std::move(OutStream);\n  }\n\n  std::unique_ptr<llvm::raw_pwrite_stream> takeOutputStream() {\n    return std::move(OutputStream);\n  }\n\n  void createASTReader();\n\n  bool loadModuleFile(StringRef FileName);\n\nprivate:\n  /// Find a module, potentially compiling it, before reading its AST.  This is\n  /// the guts of loadModule.\n  ///\n  /// For prebuilt modules, the Module is not expected to exist in\n  /// HeaderSearch's ModuleMap.  If a ModuleFile by that name is in the\n  /// ModuleManager, then it will be loaded and looked up.\n  ///\n  /// For implicit modules, the Module is expected to already be in the\n  /// ModuleMap.  First attempt to load it from the given path on disk.  If that\n  /// fails, defer to compileModuleAndReadAST, which will first build and then\n  /// load it.\n  ModuleLoadResult findOrCompileModuleAndReadAST(StringRef ModuleName,\n                                                 SourceLocation ImportLoc,\n                                                 SourceLocation ModuleNameLoc,\n                                                 bool IsInclusionDirective);\n\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override;\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override;\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override;\n\n  bool hadModuleLoaderFatalFailure() const {\n    return ModuleLoader::HadFatalFailure;\n  }\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override;\n\n  bool lookupMissingImports(StringRef Name, SourceLocation TriggerLoc) override;\n\n  void addDependencyCollector(std::shared_ptr<DependencyCollector> Listener) {\n    DependencyCollectors.push_back(std::move(Listener));\n  }\n\n  void setExternalSemaSource(IntrusiveRefCntPtr<ExternalSemaSource> ESS);\n\n  InMemoryModuleCache &getModuleCache() const { return *ModuleCache; }\n}",
  "id": "BLOCK-CPP-18264",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/CompilerInstance.h",
  "source_line": 74,
  "validation_status": "validated"
}