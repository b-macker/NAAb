{
  "code": "{\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *Ty;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts = nullptr;\n    unsigned NumElts = 0;\n    Vec() = default;\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n}",
  "id": "BLOCK-CPP-22646",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/APValue.h",
  "source_line": 122,
  "validation_status": "validated"
}