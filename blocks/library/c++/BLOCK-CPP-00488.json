{
  "code": "{\nnamespace sinks {\n\n/**\n * Sink that write to systemd journal using the `sd_journal_send()` library call.\n */\ntemplate <typename Mutex>\nclass systemd_sink : public base_sink<Mutex> {\npublic:\n    systemd_sink(std::string ident = \"\", bool enable_formatting = false)\n        : ident_{std::move(ident)},\n          enable_formatting_{enable_formatting},\n          syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,\n                          /* spdlog::level::debug      */ LOG_DEBUG,\n                          /* spdlog::level::info       */ LOG_INFO,\n                          /* spdlog::level::warn       */ LOG_WARNING,\n                          /* spdlog::level::err        */ LOG_ERR,\n                          /* spdlog::level::critical   */ LOG_CRIT,\n                          /* spdlog::level::off        */ LOG_INFO}} {}\n\n    ~systemd_sink() override {}\n\n    systemd_sink(const systemd_sink &) = delete;\n    systemd_sink &operator=(const systemd_sink &) = delete;\n\nprotected:\n    const std::string ident_;\n    bool enable_formatting_ = false;\n    using levels_array = std::array<int, 7>;\n    levels_array syslog_levels_;\n\n    void sink_it_(const details::log_msg &msg) override {\n        int err;\n        string_view_t payload;\n        memory_buf_t formatted;\n        if (enable_formatting_) {\n            base_sink<Mutex>::formatter_->format(msg, formatted);\n            payload = string_view_t(formatted.data(), formatted.size());\n        } else {\n            payload = msg.payload;\n        }\n\n        size_t length = payload.size();\n        // limit to max int\n        if (length > static_cast<size_t>(std::numeric_limits<int>::max())) {\n            length = static_cast<size_t>(std::numeric_limits<int>::max());\n        }\n\n        const string_view_t syslog_identifier = ident_.empty() ? msg.logger_name : ident_;\n\n        // Do not send source location if not available\n        if (msg.source.empty()) {\n            // Note: function call inside '()' to avoid macro expansion\n            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(),\n                                    \"PRIORITY=%d\", syslog_level(msg.level),\n#ifndef SPDLOG_NO_THREAD_ID\n                                    \"TID=%zu\", msg.thread_id,\n#endif\n                                    \"SYSLOG_IDENTIFIER=%.*s\",\n                                    static_cast<int>(syslog_identifier.size()),\n                                    syslog_identifier.data(), nullptr);\n        } else {\n            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(),\n                                    \"PRIORITY=%d\", syslog_level(msg.level),\n#ifndef SPDLOG_NO_THREAD_ID\n                                    \"TID=%zu\", msg.thread_id,\n#endif\n                                    \"SYSLOG_IDENTIFIER=%.*s\",\n                                    static_cast<int>(syslog_identifier.size()),\n                                    syslog_identifier.data(), \"CODE_FILE=%s\", msg.source.filename,\n                                    \"CODE_LINE=%d\", msg.source.line, \"CODE_FUNC=%s\",\n                                    msg.source.funcname, nullptr);\n        }\n\n        if (err) {\n            throw_spdlog_ex(\"Failed writing to systemd\", errno);\n        }\n    }\n\n    int syslog_level(level::level_enum l) {\n        return syslog_levels_.at(static_cast<levels_array::size_type>(l));\n    }\n\n    void flush_() override {}\n};\n\nusing systemd_sink_mt = systemd_sink<std::mutex>;\nusing systemd_sink_st = systemd_sink<details::null_mutex>;\n}  // namespace sinks\n\n// Create and register a syslog logger\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> systemd_logger_mt(const std::string &logger_name,\n                                                 const std::string &ident = \"\",\n                                                 bool enable_formatting = false) {\n    return Factory::template create<sinks::systemd_sink_mt>(logger_name, ident, enable_formatting);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> systemd_logger_st(const std::string &logger_name,\n                                                 const std::string &ident = \"\",\n                                                 bool enable_formatting = false) {\n    return Factory::template create<sinks::systemd_sink_st>(logger_name, ident, enable_formatting);\n}\n}",
  "id": "BLOCK-CPP-00488",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/systemd_sink.h",
  "source_line": 17,
  "validation_status": "validated"
}