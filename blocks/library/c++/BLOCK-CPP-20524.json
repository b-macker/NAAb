{
  "code": "{\n  public:\n    enum Kind {\n      /// Emit no diagnostics.\n      K_Nop,\n      /// Emit the diagnostic immediately (i.e., behave like Sema::Diag()).\n      K_Immediate,\n      /// Emit the diagnostic immediately, and, if it's a warning or error, also\n      /// emit a call stack showing how this function can be reached by an a\n      /// priori known-emitted function.\n      K_ImmediateWithCallStack,\n      /// Create a deferred diagnostic, which is emitted only if the function\n      /// it's attached to is codegen'ed.  Also emit a call stack as with\n      /// K_ImmediateWithCallStack.\n      K_Deferred\n    };\n\n    SemaDiagnosticBuilder(Kind K, SourceLocation Loc, unsigned DiagID,\n                          const FunctionDecl *Fn, Sema &S);\n    SemaDiagnosticBuilder(SemaDiagnosticBuilder &&D);\n    SemaDiagnosticBuilder(const SemaDiagnosticBuilder &) = default;\n\n    // The copy and move assignment operator is defined as deleted pending\n    // further motivation.\n    SemaDiagnosticBuilder &operator=(const SemaDiagnosticBuilder &) = delete;\n    SemaDiagnosticBuilder &operator=(SemaDiagnosticBuilder &&) = delete;\n\n    ~SemaDiagnosticBuilder();\n\n    bool isImmediate() const { return ImmediateDiag.has_value(); }\n\n    /// Convertible to bool: True if we immediately emitted an error, false if\n    /// we didn't emit an error or we created a deferred error.\n    ///\n    /// Example usage:\n    ///\n    ///   if (SemaDiagnosticBuilder(...) << foo << bar)\n    ///     return ExprError();\n    ///\n    /// But see CUDADiagIfDeviceCode() and CUDADiagIfHostCode() -- you probably\n    /// want to use these instead of creating a SemaDiagnosticBuilder yourself.\n    operator bool() const { return isImmediate(); }\n\n    template <typename T>\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const T &Value) {\n      if (Diag.ImmediateDiag)\n        *Diag.ImmediateDiag << Value;\n      else if (Diag.PartialDiagId)\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second\n            << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T,\n              typename = std::enable_if_t<!std::is_lvalue_reference<T>::value>>\n    const SemaDiagnosticBuilder &operator<<(T &&V) const {\n      if (ImmediateDiag)\n        *ImmediateDiag << std::move(V);\n      else if (PartialDiagId)\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second << std::move(V);\n      return *this;\n    }\n\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const PartialDiagnostic &PD) {\n      if (Diag.ImmediateDiag)\n        PD.Emit(*Diag.ImmediateDiag);\n      else if (Diag.PartialDiagId)\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second = PD;\n      return Diag;\n    }\n\n    void AddFixItHint(const FixItHint &Hint) const {\n      if (ImmediateDiag)\n        ImmediateDiag->AddFixItHint(Hint);\n      else if (PartialDiagId)\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second.AddFixItHint(Hint);\n    }\n\n    friend ExprResult ExprError(const SemaDiagnosticBuilder &) {\n      return ExprError();\n    }\n    friend StmtResult StmtError(const SemaDiagnosticBuilder &) {\n      return StmtError();\n    }\n    operator ExprResult() const { return ExprError(); }\n    operator StmtResult() const { return StmtError(); }\n    operator TypeResult() const { return TypeError(); }\n    operator DeclResult() const { return DeclResult(true); }\n    operator MemInitResult() const { return MemInitResult(true); }\n\n  private:\n    Sema &S;\n    SourceLocation Loc;\n    unsigned DiagID;\n    const FunctionDecl *Fn;\n    bool ShowCallStack;\n\n    // Invariant: At most one of these Optionals has a value.\n    // FIXME: Switch these to a Variant once that exists.\n    std::optional<ImmediateDiagBuilder> ImmediateDiag;\n    std::optional<unsigned> PartialDiagId;\n  }",
  "id": "BLOCK-CPP-20524",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Sema.h",
  "source_line": 1795,
  "validation_status": "validated"
}