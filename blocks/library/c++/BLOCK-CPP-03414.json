{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nclass once_flag;\n\nnamespace base_internal {\nabsl::Nonnull<std::atomic<uint32_t>*> ControlWord(\n    absl::Nonnull<absl::once_flag*> flag);\n}  // namespace base_internal\n\n// call_once()\n//\n// For all invocations using a given `once_flag`, invokes a given `fn` exactly\n// once across all threads. The first call to `call_once()` with a particular\n// `once_flag` argument (that does not throw an exception) will run the\n// specified function with the provided `args`; other calls with the same\n// `once_flag` argument will not run the function, but will wait\n// for the provided function to finish running (if it is still running).\n//\n// This mechanism provides a safe, simple, and fast mechanism for one-time\n// initialization in a multi-threaded process.\n//\n// Example:\n//\n// class MyInitClass {\n//  public:\n//  ...\n//  mutable absl::once_flag once_;\n//\n//  MyInitClass* init() const {\n//    absl::call_once(once_, &MyInitClass::Init, this);\n//    return ptr_;\n//  }\n//\ntemplate <typename Callable, typename... Args>\nvoid call_once(absl::once_flag& flag, Callable&& fn, Args&&... args);\n\n// once_flag\n//\n// Objects of this type are used to distinguish calls to `call_once()` and\n// ensure the provided function is only invoked once across all threads. This\n// type is not copyable or movable. However, it has a `constexpr`\n// constructor, and is safe to use as a namespace-scoped global variable.\nclass once_flag {\n public:\n  constexpr once_flag() : control_(0) {}\n  once_flag(const once_flag&) = delete;\n  once_flag& operator=(const once_flag&) = delete;\n\n private:\n  friend absl::Nonnull<std::atomic<uint32_t>*> base_internal::ControlWord(\n      absl::Nonnull<once_flag*> flag);\n  std::atomic<uint32_t> control_;\n};\n\n//------------------------------------------------------------------------------\n// End of public interfaces.\n// Implementation details follow.\n//------------------------------------------------------------------------------\n\nnamespace base_internal {\n\n// Like call_once, but uses KERNEL_ONLY scheduling. Intended to be used to\n// initialize entities used by the scheduler implementation.\ntemplate <typename Callable, typename... Args>\nvoid LowLevelCallOnce(absl::Nonnull<absl::once_flag*> flag, Callable&& fn,\n                      Args&&... args);\n\n// Disables scheduling while on stack when scheduling mode is non-cooperative.\n// No effect for cooperative scheduling modes.\nclass SchedulingHelper {\n public:\n  explicit SchedulingHelper(base_internal::SchedulingMode mode) : mode_(mode) {\n    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {\n      guard_result_ = base_internal::SchedulingGuard::DisableRescheduling();\n    }\n  }\n\n  ~SchedulingHelper() {\n    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {\n      base_internal::SchedulingGuard::EnableRescheduling(guard_result_);\n    }\n  }\n\n private:\n  base_internal::SchedulingMode mode_;\n  bool guard_result_ = false;\n};\n\n// Bit patterns for call_once state machine values.  Internal implementation\n// detail, not for use by clients.\n//\n// The bit patterns are arbitrarily chosen from unlikely values, to aid in\n// debugging.  However, kOnceInit must be 0, so that a zero-initialized\n// once_flag will be valid for immediate use.\nenum {\n  kOnceInit = 0,\n  kOnceRunning = 0x65C2937B,\n  kOnceWaiter = 0x05A308D2,\n  // A very small constant is chosen for kOnceDone so that it fit in a single\n  // compare with immediate instruction for most common ISAs.  This is verified\n  // for x86, POWER and ARM.\n  kOnceDone = 221,    // Random Number\n};\n\ntemplate <typename Callable, typename... Args>\nABSL_ATTRIBUTE_NOINLINE void CallOnceImpl(\n    absl::Nonnull<std::atomic<uint32_t>*> control,\n    base_internal::SchedulingMode scheduling_mode, Callable&& fn,\n    Args&&... args) {\n#ifndef NDEBUG\n  {\n    uint32_t old_control = control->load(std::memory_order_relaxed);\n    if (old_control != kOnceInit &&\n        old_control != kOnceRunning &&\n        old_control != kOnceWaiter &&\n        old_control != kOnceDone) {\n      ABSL_RAW_LOG(FATAL, \"Unexpected value for control word: 0x%lx\",\n                   static_cast<unsigned long>(old_control));  // NOLINT\n    }\n  }\n#endif  // NDEBUG\n  static const base_internal::SpinLockWaitTransition trans[] = {\n      {kOnceInit, kOnceRunning, true},\n      {kOnceRunning, kOnceWaiter, false},\n      {kOnceDone, kOnceDone, true}};\n\n  // Must do this before potentially modifying control word's state.\n  base_internal::SchedulingHelper maybe_disable_scheduling(scheduling_mode);\n  // Short circuit the simplest case to avoid procedure call overhead.\n  // The base_internal::SpinLockWait() call returns either kOnceInit or\n  // kOnceDone. If it returns kOnceDone, it must have loaded the control word\n  // with std::memory_order_acquire and seen a value of kOnceDone.\n  uint32_t old_control = kOnceInit;\n  if (control->compare_exchange_strong(old_control, kOnceRunning,\n                                       std::memory_order_relaxed) ||\n      base_internal::SpinLockWait(control, ABSL_ARRAYSIZE(trans), trans,\n                                  scheduling_mode) == kOnceInit) {\n    base_internal::invoke(std::forward<Callable>(fn),\n                          std::forward<Args>(args)...);\n    old_control =\n        control->exchange(base_internal::kOnceDone, std::memory_order_release);\n    if (old_control == base_internal::kOnceWaiter) {\n      base_internal::SpinLockWake(control, true);\n    }\n  }  // else *control is already kOnceDone\n}\n\ninline absl::Nonnull<std::atomic<uint32_t>*> ControlWord(\n    absl::Nonnull<once_flag*> flag) {\n  return &flag->control_;\n}\n\ntemplate <typename Callable, typename... Args>\nvoid LowLevelCallOnce(absl::Nonnull<absl::once_flag*> flag, Callable&& fn,\n                      Args&&... args) {\n  std::atomic<uint32_t>* once = base_internal::ControlWord(flag);\n  uint32_t s = once->load(std::memory_order_acquire);\n  if (ABSL_PREDICT_FALSE(s != base_internal::kOnceDone)) {\n    base_internal::CallOnceImpl(once, base_internal::SCHEDULE_KERNEL_ONLY,\n                                std::forward<Callable>(fn),\n                                std::forward<Args>(args)...);\n  }\n}\n\n}  // namespace base_internal\n\ntemplate <typename Callable, typename... Args>\nvoid call_once(absl::once_flag& flag, Callable&& fn, Args&&... args) {\n  std::atomic<uint32_t>* once = base_internal::ControlWord(&flag);\n  uint32_t s = once->load(std::memory_order_acquire);\n  if (ABSL_PREDICT_FALSE(s != base_internal::kOnceDone)) {\n    base_internal::CallOnceImpl(\n        once, base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL,\n        std::forward<Callable>(fn), std::forward<Args>(args)...);\n  }\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03414",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/call_once.h",
  "source_line": 44,
  "validation_status": "validated"
}