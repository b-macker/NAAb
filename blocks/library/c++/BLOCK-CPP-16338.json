{
  "code": "{\nnamespace FileMgr {\n\ntemplate <class RefTy> class MapEntryOptionalStorage;\n\n} // end namespace FileMgr\n\n/// Cached information about one directory (either on disk or in\n/// the virtual file system).\nclass DirectoryEntry {\n  DirectoryEntry() = default;\n  DirectoryEntry(const DirectoryEntry &) = delete;\n  DirectoryEntry &operator=(const DirectoryEntry &) = delete;\n  friend class FileManager;\n  friend class FileEntryTestHelper;\n\n  // FIXME: We should not be storing a directory entry name here.\n  StringRef Name; // Name of the directory.\n\npublic:\n  LLVM_DEPRECATED(\"Use DirectoryEntryRef::getName() instead.\", \"\")\n  StringRef getName() const { return Name; }\n};\n\n/// A reference to a \\c DirectoryEntry  that includes the name of the directory\n/// as it was accessed by the FileManager's client.\nclass DirectoryEntryRef {\npublic:\n  const DirectoryEntry &getDirEntry() const { return *ME->getValue(); }\n\n  StringRef getName() const { return ME->getKey(); }\n\n  /// Hash code is based on the DirectoryEntry, not the specific named\n  /// reference.\n  friend llvm::hash_code hash_value(DirectoryEntryRef Ref) {\n    return llvm::hash_value(&Ref.getDirEntry());\n  }\n\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<DirectoryEntry &>>;\n\n  const MapEntry &getMapEntry() const { return *ME; }\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(DirectoryEntryRef RHS) const { return ME == RHS.ME; }\n\n  DirectoryEntryRef() = delete;\n  explicit DirectoryEntryRef(const MapEntry &ME) : ME(&ME) {}\n\n  /// Allow DirectoryEntryRef to degrade into 'const DirectoryEntry*' to\n  /// facilitate incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getDirectoryEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::getName\n  /// has been deleted, delete this implicit conversion.\n  operator const DirectoryEntry *() const { return &getDirEntry(); }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<DirectoryEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  DirectoryEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<DirectoryEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  DirectoryEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  DirectoryEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(DirectoryEntryRef(dense_map_empty_tag())) ||\n           isSameRef(DirectoryEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nusing OptionalDirectoryEntryRef = CustomizableOptional<DirectoryEntryRef>;\n\nnamespace FileMgr {\n\n/// Customized storage for refs derived from map entires in FileManager, using\n/// the private optional_none_tag to keep it to the size of a single pointer.\ntemplate <class RefTy> class MapEntryOptionalStorage {\n  using optional_none_tag = typename RefTy::optional_none_tag;\n  RefTy MaybeRef;\n\npublic:\n  MapEntryOptionalStorage() : MaybeRef(optional_none_tag()) {}\n\n  template <class... ArgTypes>\n  explicit MapEntryOptionalStorage(std::in_place_t, ArgTypes &&...Args)\n      : MaybeRef(std::forward<ArgTypes>(Args)...) {}\n\n  void reset() { MaybeRef = optional_none_tag(); }\n\n  bool has_value() const { return MaybeRef.hasOptionalValue(); }\n\n  RefTy &value() & {\n    assert(has_value());\n    return MaybeRef;\n  }\n  RefTy const &value() const & {\n    assert(has_value());\n    return MaybeRef;\n  }\n  RefTy &&value() && {\n    assert(has_value());\n    return std::move(MaybeRef);\n  }\n\n  template <class... Args> void emplace(Args &&...args) {\n    MaybeRef = RefTy(std::forward<Args>(args)...);\n  }\n\n  MapEntryOptionalStorage &operator=(RefTy Ref) {\n    MaybeRef = Ref;\n    return *this;\n  }\n};\n\n} // end namespace FileMgr\n\nnamespace optional_detail {\n\n/// Customize OptionalStorage<DirectoryEntryRef> to use DirectoryEntryRef and\n/// its optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::DirectoryEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(std::in_place_t, ArgTypes &&...Args)\n      : StorageImpl(std::in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::DirectoryEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(OptionalDirectoryEntryRef) == sizeof(DirectoryEntryRef),\n              \"OptionalDirectoryEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<OptionalDirectoryEntryRef>::value,\n              \"OptionalDirectoryEntryRef should be trivially copyable\");\n\n} // end namespace optional_detail\n}",
  "id": "BLOCK-CPP-16338",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/DirectoryEntry.h",
  "source_line": 29,
  "validation_status": "validated"
}