{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nbool EqualsIgnoreCase(absl::string_view piece1,\n                      absl::string_view piece2) noexcept {\n  return (piece1.size() == piece2.size() &&\n          0 == absl::strings_internal::memcasecmp(piece1.data(), piece2.data(),\n                                                  piece1.size()));\n  // memcasecmp uses absl::ascii_tolower().\n}\n\nbool StrContainsIgnoreCase(absl::string_view haystack,\n                           absl::string_view needle) noexcept {\n  while (haystack.size() >= needle.size()) {\n    if (StartsWithIgnoreCase(haystack, needle)) return true;\n    haystack.remove_prefix(1);\n  }\n  return false;\n}\n\nbool StrContainsIgnoreCase(absl::string_view haystack,\n                           char needle) noexcept {\n  char upper_needle = absl::ascii_toupper(static_cast<unsigned char>(needle));\n  char lower_needle = absl::ascii_tolower(static_cast<unsigned char>(needle));\n  if (upper_needle == lower_needle) {\n    return StrContains(haystack, needle);\n  } else {\n    const char both_cstr[3] = {lower_needle, upper_needle, '\\0'};\n    return haystack.find_first_of(both_cstr) != absl::string_view::npos;\n  }\n}\n\nbool StartsWithIgnoreCase(absl::string_view text,\n                          absl::string_view prefix) noexcept {\n  return (text.size() >= prefix.size()) &&\n         EqualsIgnoreCase(text.substr(0, prefix.size()), prefix);\n}\n\nbool EndsWithIgnoreCase(absl::string_view text,\n                        absl::string_view suffix) noexcept {\n  return (text.size() >= suffix.size()) &&\n         EqualsIgnoreCase(text.substr(text.size() - suffix.size()), suffix);\n}\n\nabsl::string_view FindLongestCommonPrefix(absl::string_view a,\n                                          absl::string_view b) {\n  const absl::string_view::size_type limit = std::min(a.size(), b.size());\n  const char* const pa = a.data();\n  const char* const pb = b.data();\n  absl::string_view::size_type count = (unsigned) 0;\n\n  if (ABSL_PREDICT_FALSE(limit < 8)) {\n    while (ABSL_PREDICT_TRUE(count + 2 <= limit)) {\n      uint16_t xor_bytes = absl::little_endian::Load16(pa + count) ^\n                           absl::little_endian::Load16(pb + count);\n      if (ABSL_PREDICT_FALSE(xor_bytes != 0)) {\n        if (ABSL_PREDICT_TRUE((xor_bytes & 0xff) == 0)) ++count;\n        return absl::string_view(pa, count);\n      }\n      count += 2;\n    }\n    if (ABSL_PREDICT_TRUE(count != limit)) {\n      if (ABSL_PREDICT_TRUE(pa[count] == pb[count])) ++count;\n    }\n    return absl::string_view(pa, count);\n  }\n\n  do {\n    uint64_t xor_bytes = absl::little_endian::Load64(pa + count) ^\n                         absl::little_endian::Load64(pb + count);\n    if (ABSL_PREDICT_FALSE(xor_bytes != 0)) {\n      count += static_cast<uint64_t>(absl::countr_zero(xor_bytes) >> 3);\n      return absl::string_view(pa, count);\n    }\n    count += 8;\n  } while (ABSL_PREDICT_TRUE(count + 8 < limit));\n\n  count = limit - 8;\n  uint64_t xor_bytes = absl::little_endian::Load64(pa + count) ^\n                       absl::little_endian::Load64(pb + count);\n  if (ABSL_PREDICT_TRUE(xor_bytes != 0)) {\n    count += static_cast<uint64_t>(absl::countr_zero(xor_bytes) >> 3);\n    return absl::string_view(pa, count);\n  }\n  return absl::string_view(pa, limit);\n}\n\nabsl::string_view FindLongestCommonSuffix(absl::string_view a,\n                                          absl::string_view b) {\n  const absl::string_view::size_type limit = std::min(a.size(), b.size());\n  if (limit == 0) return absl::string_view();\n\n  const char* pa = a.data() + a.size() - 1;\n  const char* pb = b.data() + b.size() - 1;\n  absl::string_view::size_type count = (unsigned) 0;\n  while (count < limit && *pa == *pb) {\n    --pa;\n    --pb;\n    ++count;\n  }\n\n  return absl::string_view(++pa, count);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01946",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/match.cc",
  "source_line": 28,
  "validation_status": "validated"
}