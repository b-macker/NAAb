{
  "code": "#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Availability.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LocInfoType.h\"\n#include \"clang/AST/MangleNumberingContext.h\"\n#include \"clang/AST/NSAPI.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/DarwinSDKInfo.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TemplateKinds.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Sema/AnalysisBasedWarnings.h\"\n#include \"clang/Sema/CleanupInfo.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/ObjCMethodList.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/SemaConcept.h\"\n#include \"clang/Sema/TypoCorrection.h\"\n#include \"clang/Sema/Weak.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include <deque>\n#include <memory>\n#include <optional>\n#include <string>\n#include <tuple>\n#include <vector>\n  // The current #pragma align/pack values and locations at each #include.\n  /// #include or similar preprocessing directive.\n\nusing namespace llvm;\nusing namespace clang;\nusing namespace sema;\nusing namespace threadSafety;\nusing namespace of;\nusing namespace set;\nusing namespace name;\nusing namespace alias;\nusing namespace was;\nusing namespace to;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-20591_execute() {\n    {\n    /// Note that we are instantiating a class template,\n    /// function template, variable template, alias template,\n    /// or a member thereof.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          Decl *Entity,\n                          SourceRange InstantiationRange = SourceRange());\n\n    struct ExceptionSpecification {};\n    /// Note that we are instantiating an exception specification\n    /// of a function template.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionDecl *Entity, ExceptionSpecification,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument in a\n    /// template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateParameter Param, TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting either explicitly-specified or\n    /// deduced template arguments during function template argument deduction.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionTemplateDecl *FunctionTemplate,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          CodeSynthesisContext::SynthesisKind Kind,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template declaration.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a variable template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          VarTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument for a function\n    /// parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParmVarDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting prior template arguments into a\n    /// non-type parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          NonTypeTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are substituting prior template arguments into a\n    /// template template parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          TemplateTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are checking the default template argument\n    /// against the template parameter for a given template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          NamedDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintsCheck {};\n    /// \\brief Note that we are checking the constraints associated with some\n    /// constrained entity (a concept declaration or a template with associated\n    /// constraints).\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintsCheck, NamedDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintSubstitution {};\n    /// \\brief Note that we are checking a constraint expression associated\n    /// with a template declaration or as part of the satisfaction check of a\n    /// concept.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintSubstitution, NamedDecl *Template,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintNormalization {};\n    /// \\brief Note that we are normalizing a constraint expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintNormalization, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    struct ParameterMappingSubstitution {};\n    /// \\brief Note that we are subtituting into the parameter mapping of an\n    /// atomic constraint during constraint normalization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParameterMappingSubstitution, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    /// \\brief Note that we are substituting template arguments into a part of\n    /// a requirement of a requires expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::Requirement *Req,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// \\brief Note that we are checking the satisfaction of the constraint\n    /// expression inside of a nested requirement.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::NestedRequirement *Req, ConstraintsCheck,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// \\brief Note that we are checking a requires clause.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          const RequiresExpr *E,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange);\n\n    struct BuildingDeductionGuidesTag {};\n    /// \\brief Note that we are building deduction guides.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Entity, BuildingDeductionGuidesTag,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we have finished instantiating this template.\n    void Clear();\n\n    ~InstantiatingTemplate() { Clear(); }\n\n    /// Determines whether we have exceeded the maximum\n    /// recursive template instantiations.\n    bool isInvalid() const { return Invalid; }\n\n    /// Determine whether we are already instantiating this\n    /// specialization in some surrounding active instantiation.\n    bool isAlreadyInstantiating() const { return AlreadyInstantiating; }\n\n  private:\n    Sema &SemaRef;\n    bool Invalid;\n    bool AlreadyInstantiating;\n    bool CheckInstantiationDepth(SourceLocation PointOfInstantiation,\n                                 SourceRange InstantiationRange);\n\n    InstantiatingTemplate(\n        Sema &SemaRef, CodeSynthesisContext::SynthesisKind Kind,\n        SourceLocation PointOfInstantiation, SourceRange InstantiationRange,\n        Decl *Entity, NamedDecl *Template = nullptr,\n        ArrayRef<TemplateArgument> TemplateArgs = std::nullopt,\n        sema::TemplateDeductionInfo *DeductionInfo = nullptr);\n\n    InstantiatingTemplate(const InstantiatingTemplate&) = delete;\n\n    InstantiatingTemplate&\n    operator=(const InstantiatingTemplate&) = delete;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-20591",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Sema.h",
  "source_line": 9581,
  "validation_status": "validated"
}