{
  "code": "#include <stddef.h>\n#include <stdlib.h>\n#include <cassert>\n#include <cstring>\n#include <initializer_list>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/strings/internal/str_format/checker.h\"\n#include \"absl/strings/internal/str_format/constexpr_parser.h\"\n#include \"absl/strings/internal/str_format/extension.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06429_execute() {\n    {\n//     if (use_hex) return MyFormat(\"foo %x bar\");\n//     return MyFormat(\"foo %d bar\");\n//   }\n//   // 'format' can be used with any value that supports 'd' and 'x',\n//   // like `int`.\n//   auto format = GetFormat(use_hex);\n//   value = StringF(format, i);\n//\n// This class also supports runtime format checking with the ::New() and\n// ::NewAllowIgnored() factory functions.\n// This is the only API that allows the user to pass a runtime specified format\n// string. These factory functions will return NULL if the format does not match\n// the conversions requested by the user.\ntemplate <FormatConversionCharSet... C>\nclass ExtendedParsedFormat : public str_format_internal::ParsedFormatBase {\n public:\n  explicit ExtendedParsedFormat(string_view format)\n#ifdef ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n      __attribute__((\n          enable_if(str_format_internal::EnsureConstexpr(format),\n                    \"Format string is not constexpr.\"),\n          enable_if(str_format_internal::ValidFormatImpl<C...>(format),\n                    \"Format specified does not match the template arguments.\")))\n#endif  // ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n      : ExtendedParsedFormat(format, false) {\n  }\n\n  // ExtendedParsedFormat factory function.\n  // The user still has to specify the conversion characters, but they will not\n  // be checked at compile time. Instead, it will be checked at runtime.\n  // This delays the checking to runtime, but allows the user to pass\n  // dynamically sourced formats.\n  // It returns NULL if the format does not match the conversion characters.\n  // The user is responsible for checking the return value before using it.\n  //\n  // The 'New' variant will check that all the specified arguments are being\n  // consumed by the format and return NULL if any argument is being ignored.\n  // The 'NewAllowIgnored' variant will not verify this and will allow formats\n  // that ignore arguments.\n  static std::unique_ptr<ExtendedParsedFormat> New(string_view format) {\n    return New(format, false);\n  }\n  static std::unique_ptr<ExtendedParsedFormat> NewAllowIgnored(\n      string_view format) {\n    return New(format, true);\n  }\n\n private:\n  static std::unique_ptr<ExtendedParsedFormat> New(string_view format,\n                                                   bool allow_ignored) {\n    std::unique_ptr<ExtendedParsedFormat> conv(\n        new ExtendedParsedFormat(format, allow_ignored));\n    if (conv->has_error()) return nullptr;\n    return conv;\n  }\n\n  ExtendedParsedFormat(string_view s, bool allow_ignored)\n      : ParsedFormatBase(s, allow_ignored, {C...}) {}\n};\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06429",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/parser.h",
  "source_line": 205,
  "validation_status": "validated"
}