{
  "code": "#include \"absl/strings/internal/str_format/float_conversion.h\"\n#include <string.h>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <limits>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/functional/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/numeric/internal/representation.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03074_execute() {\n    {\n  // Int properties.\n  constexpr size_t kIntBits = sizeof(Int) * 8;\n  constexpr size_t kTotalNibbles = sizeof(Int) * 8 / 4;\n  // Did the user specify a precision explicitly?\n  const bool precision_specified = state.conv.precision() >= 0;\n\n  // ========== Normalize/Denormalize ==========\n  exp += kIntBits;  // make all digits fractional digits.\n  // This holds the (up to four) bits of leading digit, i.e., the '1' in the\n  // number 0x1.e6fp+2. It's always > 0 unless number is zero or denormal.\n  uint8_t leading = 0;\n  FormatANormalize(float_traits, &leading, &mantissa, &exp);\n\n  // =============== Rounding ==================\n  // Check if we need to round; if so, then we do that by manipulating\n  // (incrementing) the mantissa before beginning to print characters.\n  FormatARound(precision_specified, state, &leading, &mantissa, &exp);\n\n  // ============= Format Result ===============\n  // This buffer holds the \"0x1.ab1de3\" portion of \"0x1.ab1de3pe+2\". Compute the\n  // size with long double which is the largest of the floats.\n  constexpr size_t kBufSizeForHexFloatRepr =\n      2                                                // 0x\n      + std::numeric_limits<MaxFloatType>::digits / 4  // number of hex digits\n      + 1                                              // round up\n      + 1;                                             // \".\" (dot)\n  char digits_buffer[kBufSizeForHexFloatRepr];\n  char *digits_iter = digits_buffer;\n  const char *const digits =\n      static_cast<const char *>(\"0123456789ABCDEF0123456789abcdef\") +\n      (uppercase ? 0 : 16);\n\n  // =============== Hex Prefix ================\n  *digits_iter++ = '0';\n  *digits_iter++ = uppercase ? 'X' : 'x';\n\n  // ========== Non-Fractional Digit ===========\n  *digits_iter++ = digits[leading];\n\n  // ================== Dot ====================\n  // There are three reasons we might need a dot. Keep in mind that, at this\n  // point, the mantissa holds only the fractional part.\n  if ((precision_specified && state.precision > 0) ||\n      (!precision_specified && mantissa > 0) || state.conv.has_alt_flag()) {\n    *digits_iter++ = '.';\n  }\n\n  // ============ Fractional Digits ============\n  size_t digits_emitted = 0;\n  while (mantissa > 0) {\n    *digits_iter++ = digits[GetNibble(mantissa, kTotalNibbles - 1)];\n    mantissa <<= 4;\n    ++digits_emitted;\n  }\n  size_t trailing_zeros = 0;\n  if (precision_specified) {\n    assert(state.precision >= digits_emitted);\n    trailing_zeros = state.precision - digits_emitted;\n  }\n  auto digits_result = string_view(\n      digits_buffer, static_cast<size_t>(digits_iter - digits_buffer));\n\n  // =============== Exponent ==================\n  constexpr size_t kBufSizeForExpDecRepr =\n      numbers_internal::kFastToBufferSize  // required for FastIntToBuffer\n      + 1                                  // 'p' or 'P'\n      + 1;                                 // '+' or '-'\n  char exp_buffer[kBufSizeForExpDecRepr];\n  exp_buffer[0] = uppercase ? 'P' : 'p';\n  exp_buffer[1] = exp >= 0 ? '+' : '-';\n  numbers_internal::FastIntToBuffer(exp < 0 ? -exp : exp, exp_buffer + 2);\n\n  // ============ Assemble Result ==============\n  FinalPrint(state,\n             digits_result,                        // 0xN.NNN...\n             2,                                    // offset of any padding\n             static_cast<size_t>(trailing_zeros),  // remaining mantissa padding\n             exp_buffer);                          // exponent\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03074",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 873,
  "validation_status": "validated"
}