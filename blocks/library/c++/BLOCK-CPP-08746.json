{
  "code": "{\n\nclass DependentDiagnostic;\n\n/// An array of decls optimized for the common case of only containing\n/// one entry.\nclass StoredDeclsList {\n  using Decls = DeclListNode::Decls;\n\n  /// A collection of declarations, with a flag to indicate if we have\n  /// further external declarations.\n  using DeclsAndHasExternalTy = llvm::PointerIntPair<Decls, 1, bool>;\n\n  /// The stored data, which will be either a pointer to a NamedDecl,\n  /// or a pointer to a list with a flag to indicate if there are further\n  /// external declarations.\n  DeclsAndHasExternalTy Data;\n\n  template<typename Fn>\n  void erase_if(Fn ShouldErase) {\n    Decls List = Data.getPointer();\n    if (!List)\n      return;\n    ASTContext &C = getASTContext();\n    DeclListNode::Decls NewHead = nullptr;\n    DeclListNode::Decls *NewLast = nullptr;\n    DeclListNode::Decls *NewTail = &NewHead;\n    while (true) {\n      if (!ShouldErase(*DeclListNode::iterator(List))) {\n        NewLast = NewTail;\n        *NewTail = List;\n        if (auto *Node = List.dyn_cast<DeclListNode*>()) {\n          NewTail = &Node->Rest;\n          List = Node->Rest;\n        } else {\n          break;\n        }\n      } else if (DeclListNode *N = List.dyn_cast<DeclListNode*>()) {\n        List = N->Rest;\n        C.DeallocateDeclListNode(N);\n      } else {\n        // We're discarding the last declaration in the list. The last node we\n        // want to keep (if any) will be of the form DeclListNode(D, <rest>);\n        // replace it with just D.\n        if (NewLast) {\n          DeclListNode *Node = NewLast->get<DeclListNode*>();\n          *NewLast = Node->D;\n          C.DeallocateDeclListNode(Node);\n        }\n        break;\n      }\n    }\n    Data.setPointer(NewHead);\n\n    assert(llvm::none_of(getLookupResult(), ShouldErase) && \"Still exists!\");\n  }\n\n  void erase(NamedDecl *ND) {\n    erase_if([ND](NamedDecl *D) { return D == ND; });\n  }\n\npublic:\n  StoredDeclsList() = default;\n\n  StoredDeclsList(StoredDeclsList &&RHS) : Data(RHS.Data) {\n    RHS.Data.setPointer(nullptr);\n    RHS.Data.setInt(false);\n  }\n\n  void MaybeDeallocList() {\n    if (isNull())\n      return;\n    // If this is a list-form, free the list.\n    ASTContext &C = getASTContext();\n    Decls List = Data.getPointer();\n    while (DeclListNode *ToDealloc = List.dyn_cast<DeclListNode *>()) {\n      List = ToDealloc->Rest;\n      C.DeallocateDeclListNode(ToDealloc);\n    }\n  }\n\n  ~StoredDeclsList() {\n    MaybeDeallocList();\n  }\n\n  StoredDeclsList &operator=(StoredDeclsList &&RHS) {\n    MaybeDeallocList();\n\n    Data = RHS.Data;\n    RHS.Data.setPointer(nullptr);\n    RHS.Data.setInt(false);\n    return *this;\n  }\n\n  bool isNull() const { return Data.getPointer().isNull(); }\n\n  ASTContext &getASTContext() {\n    assert(!isNull() && \"No ASTContext.\");\n    if (NamedDecl *ND = getAsDecl())\n      return ND->getASTContext();\n    return getAsList()->D->getASTContext();\n  }\n\n  DeclsAndHasExternalTy getAsListAndHasExternal() const { return Data; }\n\n  NamedDecl *getAsDecl() const {\n    return getAsListAndHasExternal().getPointer().dyn_cast<NamedDecl *>();\n  }\n\n  DeclListNode *getAsList() const {\n    return getAsListAndHasExternal().getPointer().dyn_cast<DeclListNode*>();\n  }\n\n  bool hasExternalDecls() const {\n    return getAsListAndHasExternal().getInt();\n  }\n\n  void setHasExternalDecls() {\n    Data.setInt(true);\n  }\n\n  void remove(NamedDecl *D) {\n    assert(!isNull() && \"removing from empty list\");\n    erase(D);\n  }\n\n  /// Remove any declarations which were imported from an external AST source.\n  void removeExternalDecls() {\n    erase_if([](NamedDecl *ND) { return ND->isFromASTFile(); });\n\n    // Don't have any pending external decls any more.\n    Data.setInt(false);\n  }\n\n  void replaceExternalDecls(ArrayRef<NamedDecl*> Decls) {\n    // Remove all declarations that are either external or are replaced with\n    // external declarations.\n    erase_if([Decls](NamedDecl *ND) {\n      if (ND->isFromASTFile())\n        return true;\n      for (NamedDecl *D : Decls)\n        if (D->declarationReplaces(ND, /*IsKnownNewer=*/false))\n          return true;\n      return false;\n    });\n\n    // Don't have any pending external decls any more.\n    Data.setInt(false);\n\n    if (Decls.empty())\n      return;\n\n    // Convert Decls into a list, in order.\n    ASTContext &C = Decls.front()->getASTContext();\n    DeclListNode::Decls DeclsAsList = Decls.back();\n    for (size_t I = Decls.size() - 1; I != 0; --I) {\n      DeclListNode *Node = C.AllocateDeclListNode(Decls[I - 1]);\n      Node->Rest = DeclsAsList;\n      DeclsAsList = Node;\n    }\n\n    DeclListNode::Decls Head = Data.getPointer();\n    if (Head.isNull()) {\n      Data.setPointer(DeclsAsList);\n      return;\n    }\n\n    // Find the end of the existing list.\n    // FIXME: It would be possible to preserve information from erase_if to\n    // avoid this rescan looking for the end of the list.\n    DeclListNode::Decls *Tail = &Head;\n    while (DeclListNode *Node = Tail->dyn_cast<DeclListNode *>())\n      Tail = &Node->Rest;\n\n    // Append the Decls.\n    DeclListNode *Node = C.AllocateDeclListNode(Tail->get<NamedDecl *>());\n    Node->Rest = DeclsAsList;\n    *Tail = Node;\n    Data.setPointer(Head);\n  }\n\n  /// Return an array of all the decls that this list represents.\n  DeclContext::lookup_result getLookupResult() const {\n    return DeclContext::lookup_result(Data.getPointer());\n  }\n\n  /// If this is a redeclaration of an existing decl, replace the old one with\n  /// D. Otherwise, append D.\n  void addOrReplaceDecl(NamedDecl *D) {\n    const bool IsKnownNewer = true;\n\n    if (isNull()) {\n      Data.setPointer(D);\n      return;\n    }\n\n    // Most decls only have one entry in their list, special case it.\n    if (NamedDecl *OldD = getAsDecl()) {\n      if (D->declarationReplaces(OldD, IsKnownNewer)) {\n        Data.setPointer(D);\n        return;\n      }\n\n      // Add D after OldD.\n      ASTContext &C = D->getASTContext();\n      DeclListNode *Node = C.AllocateDeclListNode(OldD);\n      Node->Rest = D;\n      Data.setPointer(Node);\n      return;\n    }\n\n    // FIXME: Move the assert before the single decl case when we fix the\n    // duplication coming from the ASTReader reading builtin types.\n    assert(!llvm::is_contained(getLookupResult(), D) && \"Already exists!\");\n    // Determine if this declaration is actually a redeclaration.\n    for (DeclListNode *N = getAsList(); /*return in loop*/;\n         N = N->Rest.dyn_cast<DeclListNode *>()) {\n      if (D->declarationReplaces(N->D, IsKnownNewer)) {\n        N->D = D;\n        return;\n      }\n      if (auto *ND = N->Rest.dyn_cast<NamedDecl *>()) {\n        if (D->declarationReplaces(ND, IsKnownNewer)) {\n          N->Rest = D;\n          return;\n        }\n\n        // Add D after ND.\n        ASTContext &C = D->getASTContext();\n        DeclListNode *Node = C.AllocateDeclListNode(ND);\n        N->Rest = Node;\n        Node->Rest = D;\n        return;\n      }\n    }\n  }\n\n  /// Add a declaration to the list without checking if it replaces anything.\n  void prependDeclNoReplace(NamedDecl *D) {\n    if (isNull()) {\n      Data.setPointer(D);\n      return;\n    }\n\n    ASTContext &C = D->getASTContext();\n    DeclListNode *Node = C.AllocateDeclListNode(D);\n    Node->Rest = Data.getPointer();\n    Data.setPointer(Node);\n  }\n\n  LLVM_DUMP_METHOD void dump() const {\n    Decls D = Data.getPointer();\n    if (!D) {\n      llvm::errs() << \"<null>\\n\";\n      return;\n    }\n\n    while (true) {\n      if (auto *Node = D.dyn_cast<DeclListNode*>()) {\n        llvm::errs() << '[' << Node->D << \"] -> \";\n        D = Node->Rest;\n      } else {\n        llvm::errs() << '[' << D.get<NamedDecl*>() << \"]\\n\";\n        return;\n      }\n    }\n  }\n};\n\nclass StoredDeclsMap\n    : public llvm::SmallDenseMap<DeclarationName, StoredDeclsList, 4> {\n  friend class ASTContext; // walks the chain deleting these\n  friend class DeclContext;\n\n  llvm::PointerIntPair<StoredDeclsMap*, 1> Previous;\npublic:\n  static void DestroyAll(StoredDeclsMap *Map, bool Dependent);\n};\n\nclass DependentStoredDeclsMap : public StoredDeclsMap {\n  friend class DeclContext; // iterates over diagnostics\n  friend class DependentDiagnostic;\n\n  DependentDiagnostic *FirstDiagnostic = nullptr;\npublic:\n  DependentStoredDeclsMap() = default;\n};\n\n}",
  "id": "BLOCK-CPP-08746",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclContextInternals.h",
  "source_line": 27,
  "validation_status": "validated"
}