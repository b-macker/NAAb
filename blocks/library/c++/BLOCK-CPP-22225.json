{
  "code": "{\n\nnamespace ento {\n\nclass SValExplainer : public FullSValVisitor<SValExplainer, std::string> {\nprivate:\n  ASTContext &ACtx;\n\n  std::string printStmt(const Stmt *S) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    S->printPretty(OS, nullptr, PrintingPolicy(ACtx.getLangOpts()));\n    return Str;\n  }\n\n  bool isThisObject(const SymbolicRegion *R) {\n    if (auto S = dyn_cast<SymbolRegionValue>(R->getSymbol()))\n      if (isa<CXXThisRegion>(S->getRegion()))\n        return true;\n    return false;\n  }\n\n  bool isThisObject(const ElementRegion *R) {\n    if (const auto *Idx = R->getIndex().getAsInteger()) {\n      if (const auto *SR = R->getSuperRegion()->getAs<SymbolicRegion>()) {\n        QualType Ty = SR->getPointeeStaticType();\n        bool IsNotReinterpretCast = R->getValueType() == Ty;\n        if (Idx->isZero() && IsNotReinterpretCast)\n          return isThisObject(SR);\n      }\n    }\n    return false;\n  }\n\npublic:\n  SValExplainer(ASTContext &Ctx) : ACtx(Ctx) {}\n\n  std::string VisitUnknownVal(UnknownVal V) {\n    return \"unknown value\";\n  }\n\n  std::string VisitUndefinedVal(UndefinedVal V) {\n    return \"undefined value\";\n  }\n\n  std::string VisitLocMemRegionVal(loc::MemRegionVal V) {\n    const MemRegion *R = V.getRegion();\n    // Avoid the weird \"pointer to pointee of ...\".\n    if (auto SR = dyn_cast<SymbolicRegion>(R)) {\n      // However, \"pointer to 'this' object\" is fine.\n      if (!isThisObject(SR))\n        return Visit(SR->getSymbol());\n    }\n    return \"pointer to \" + Visit(R);\n  }\n\n  std::string VisitLocConcreteInt(loc::ConcreteInt V) {\n    const llvm::APSInt &I = V.getValue();\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << \"concrete memory address '\" << I << \"'\";\n    return Str;\n  }\n\n  std::string VisitNonLocSymbolVal(nonloc::SymbolVal V) {\n    return Visit(V.getSymbol());\n  }\n\n  std::string VisitNonLocConcreteInt(nonloc::ConcreteInt V) {\n    const llvm::APSInt &I = V.getValue();\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << (I.isSigned() ? \"signed \" : \"unsigned \") << I.getBitWidth()\n       << \"-bit integer '\" << I << \"'\";\n    return Str;\n  }\n\n  std::string VisitNonLocLazyCompoundVal(nonloc::LazyCompoundVal V) {\n    return \"lazily frozen compound value of \" + Visit(V.getRegion());\n  }\n\n  std::string VisitSymbolRegionValue(const SymbolRegionValue *S) {\n    const MemRegion *R = S->getRegion();\n    // Special handling for argument values.\n    if (auto V = dyn_cast<VarRegion>(R))\n      if (auto D = dyn_cast<ParmVarDecl>(V->getDecl()))\n        return \"argument '\" + D->getQualifiedNameAsString() + \"'\";\n    return \"initial value of \" + Visit(R);\n  }\n\n  std::string VisitSymbolConjured(const SymbolConjured *S) {\n    return \"symbol of type '\" + S->getType().getAsString() +\n           \"' conjured at statement '\" + printStmt(S->getStmt()) + \"'\";\n  }\n\n  std::string VisitSymbolDerived(const SymbolDerived *S) {\n    return \"value derived from (\" + Visit(S->getParentSymbol()) +\n           \") for \" + Visit(S->getRegion());\n  }\n\n  std::string VisitSymbolExtent(const SymbolExtent *S) {\n    return \"extent of \" + Visit(S->getRegion());\n  }\n\n  std::string VisitSymbolMetadata(const SymbolMetadata *S) {\n    return \"metadata of type '\" + S->getType().getAsString() + \"' tied to \" +\n           Visit(S->getRegion());\n  }\n\n  std::string VisitSymIntExpr(const SymIntExpr *S) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << \"(\" << Visit(S->getLHS()) << \") \"\n       << std::string(BinaryOperator::getOpcodeStr(S->getOpcode())) << \" \"\n       << S->getRHS();\n    return Str;\n  }\n\n  // TODO: IntSymExpr doesn't appear in practice.\n  // Add the relevant code once it does.\n\n  std::string VisitSymSymExpr(const SymSymExpr *S) {\n    return \"(\" + Visit(S->getLHS()) + \") \" +\n           std::string(BinaryOperator::getOpcodeStr(S->getOpcode())) +\n           \" (\" + Visit(S->getRHS()) + \")\";\n  }\n\n  std::string VisitUnarySymExpr(const UnarySymExpr *S) {\n    return std::string(UnaryOperator::getOpcodeStr(S->getOpcode())) + \" (\" +\n           Visit(S->getOperand()) + \")\";\n  }\n\n  // TODO: SymbolCast doesn't appear in practice.\n  // Add the relevant code once it does.\n\n  std::string VisitSymbolicRegion(const SymbolicRegion *R) {\n    // Explain 'this' object here - if it's not wrapped by an ElementRegion.\n    // TODO: Explain CXXThisRegion itself, find a way to test it.\n    if (isThisObject(R))\n      return \"'this' object\";\n    // Objective-C objects are not normal symbolic regions. At least,\n    // they're always on the heap.\n    if (R->getSymbol()->getType()\n            .getCanonicalType()->getAs<ObjCObjectPointerType>())\n      return \"object at \" + Visit(R->getSymbol());\n    // Other heap-based symbolic regions are also special.\n    if (isa<HeapSpaceRegion>(R->getMemorySpace()))\n      return \"heap segment that starts at \" + Visit(R->getSymbol());\n    return \"pointee of \" + Visit(R->getSymbol());\n  }\n\n  std::string VisitAllocaRegion(const AllocaRegion *R) {\n    return \"region allocated by '\" + printStmt(R->getExpr()) + \"'\";\n  }\n\n  std::string VisitCompoundLiteralRegion(const CompoundLiteralRegion *R) {\n    return \"compound literal \" + printStmt(R->getLiteralExpr());\n  }\n\n  std::string VisitStringRegion(const StringRegion *R) {\n    return \"string literal \" + R->getString();\n  }\n\n  std::string VisitElementRegion(const ElementRegion *R) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n\n    // Explain 'this' object here.\n    // They are represented by a SymRegion wrapped by an ElementRegion; so\n    // match and handle it here.\n    if (isThisObject(R))\n      return \"'this' object\";\n\n    OS << \"element of type '\" << R->getElementType() << \"' with index \";\n    // For concrete index: omit type of the index integer.\n    if (auto I = R->getIndex().getAs<nonloc::ConcreteInt>())\n      OS << I->getValue();\n    else\n      OS << \"'\" << Visit(R->getIndex()) << \"'\";\n    OS << \" of \" + Visit(R->getSuperRegion());\n    return Str;\n  }\n\n  std::string VisitNonParamVarRegion(const NonParamVarRegion *R) {\n    const VarDecl *VD = R->getDecl();\n    std::string Name = VD->getQualifiedNameAsString();\n    if (isa<ParmVarDecl>(VD))\n      return \"parameter '\" + Name + \"'\";\n    else if (VD->hasAttr<BlocksAttr>())\n      return \"block variable '\" + Name + \"'\";\n    else if (VD->hasLocalStorage())\n      return \"local variable '\" + Name + \"'\";\n    else if (VD->isStaticLocal())\n      return \"static local variable '\" + Name + \"'\";\n    else if (VD->hasGlobalStorage())\n      return \"global variable '\" + Name + \"'\";\n    else\n      llvm_unreachable(\"A variable is either local or global\");\n  }\n\n  std::string VisitObjCIvarRegion(const ObjCIvarRegion *R) {\n    return \"instance variable '\" + R->getDecl()->getNameAsString() + \"' of \" +\n           Visit(R->getSuperRegion());\n  }\n\n  std::string VisitFieldRegion(const FieldRegion *R) {\n    return \"field '\" + R->getDecl()->getNameAsString() + \"' of \" +\n           Visit(R->getSuperRegion());\n  }\n\n  std::string VisitCXXTempObjectRegion(const CXXTempObjectRegion *R) {\n    return \"temporary object constructed at statement '\" +\n           printStmt(R->getExpr()) + \"'\";\n  }\n\n  std::string VisitCXXBaseObjectRegion(const CXXBaseObjectRegion *R) {\n    return \"base object '\" + R->getDecl()->getQualifiedNameAsString() +\n           \"' inside \" + Visit(R->getSuperRegion());\n  }\n\n  std::string VisitParamVarRegion(const ParamVarRegion *R) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n\n    const ParmVarDecl *PVD = R->getDecl();\n    std::string Name = PVD->getQualifiedNameAsString();\n    if (!Name.empty()) {\n      OS << \"parameter '\" << Name << \"'\";\n      return std::string(OS.str());\n    }\n\n    unsigned Index = R->getIndex() + 1;\n    OS << Index << llvm::getOrdinalSuffix(Index) << \" parameter of \";\n    const Decl *Parent = R->getStackFrame()->getDecl();\n    if (const auto *FD = dyn_cast<FunctionDecl>(Parent))\n      OS << \"function '\" << FD->getQualifiedNameAsString() << \"()'\";\n    else if (const auto *CD = dyn_cast<CXXConstructorDecl>(Parent))\n      OS << \"C++ constructor '\" << CD->getQualifiedNameAsString() << \"()'\";\n    else if (const auto *MD = dyn_cast<ObjCMethodDecl>(Parent)) {\n      if (MD->isClassMethod())\n        OS << \"Objective-C method '+\" << MD->getQualifiedNameAsString() << \"'\";\n      else\n        OS << \"Objective-C method '-\" << MD->getQualifiedNameAsString() << \"'\";\n    } else if (isa<BlockDecl>(Parent)) {\n      if (cast<BlockDecl>(Parent)->isConversionFromLambda())\n        OS << \"lambda\";\n      else\n        OS << \"block\";\n    }\n\n    return std::string(OS.str());\n  }\n\n  std::string VisitSVal(SVal V) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << V;\n    return \"a value unsupported by the explainer: (\" +\n           std::string(OS.str()) + \")\";\n  }\n\n  std::string VisitSymExpr(SymbolRef S) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    S->dumpToStream(OS);\n    return \"a symbolic expression unsupported by the explainer: (\" +\n           std::string(OS.str()) + \")\";\n  }\n\n  std::string VisitMemRegion(const MemRegion *R) {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << R;\n    return \"a memory region unsupported by the explainer (\" +\n           std::string(OS.str()) + \")\";\n  }\n};\n\n} // end namespace ento\n\n}",
  "id": "BLOCK-CPP-22225",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Checkers/SValExplainer.h",
  "source_line": 23,
  "validation_status": "validated"
}