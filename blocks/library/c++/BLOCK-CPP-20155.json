{
  "code": "{\n  using VecTy = llvm::SmallVector<ParsedAttr *>;\n  using SizeType = decltype(std::declval<VecTy>().size());\n\npublic:\n  SourceRange Range;\n\n  static const ParsedAttributesView &none() {\n    static const ParsedAttributesView Attrs;\n    return Attrs;\n  }\n\n  bool empty() const { return AttrList.empty(); }\n  SizeType size() const { return AttrList.size(); }\n  ParsedAttr &operator[](SizeType pos) { return *AttrList[pos]; }\n  const ParsedAttr &operator[](SizeType pos) const { return *AttrList[pos]; }\n\n  void addAtEnd(ParsedAttr *newAttr) {\n    assert(newAttr);\n    AttrList.push_back(newAttr);\n  }\n\n  void remove(ParsedAttr *ToBeRemoved) {\n    assert(is_contained(AttrList, ToBeRemoved) &&\n           \"Cannot remove attribute that isn't in the list\");\n    AttrList.erase(llvm::find(AttrList, ToBeRemoved));\n  }\n\n  void clearListOnly() { AttrList.clear(); }\n\n  struct iterator : llvm::iterator_adaptor_base<iterator, VecTy::iterator,\n                                                std::random_access_iterator_tag,\n                                                ParsedAttr> {\n    iterator() : iterator_adaptor_base(nullptr) {}\n    iterator(VecTy::iterator I) : iterator_adaptor_base(I) {}\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n  struct const_iterator\n      : llvm::iterator_adaptor_base<const_iterator, VecTy::const_iterator,\n                                    std::random_access_iterator_tag,\n                                    ParsedAttr> {\n    const_iterator() : iterator_adaptor_base(nullptr) {}\n    const_iterator(VecTy::const_iterator I) : iterator_adaptor_base(I) {}\n\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n\n  void addAll(iterator B, iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAll(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAllAtEnd(iterator B, iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  void addAllAtEnd(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  iterator begin() { return iterator(AttrList.begin()); }\n  const_iterator begin() const { return const_iterator(AttrList.begin()); }\n  iterator end() { return iterator(AttrList.end()); }\n  const_iterator end() const { return const_iterator(AttrList.end()); }\n\n  ParsedAttr &front() {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  const ParsedAttr &front() const {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  ParsedAttr &back() {\n    assert(!empty());\n    return *AttrList.back();\n  }\n  const ParsedAttr &back() const {\n    assert(!empty());\n    return *AttrList.back();\n  }\n\n  bool hasAttribute(ParsedAttr::Kind K) const {\n    return llvm::any_of(AttrList, [K](const ParsedAttr *AL) {\n      return AL->getParsedKind() == K;\n    });\n  }\n\n  const ParsedAttr *getMSPropertyAttr() const {\n    auto It = llvm::find_if(AttrList, [](const ParsedAttr *AL) {\n      return AL->isDeclspecPropertyAttribute();\n    });\n    if (It != AttrList.end())\n      return *It;\n    return nullptr;\n  }\n  bool hasMSPropertyAttr() const { return getMSPropertyAttr(); }\n\nprivate:\n  VecTy AttrList;\n}",
  "id": "BLOCK-CPP-20155",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ParsedAttr.h",
  "source_line": 807,
  "validation_status": "validated"
}