{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace str_format_internal {\n\nstd::string LengthModToString(LengthMod v);\n\nconst char* ConsumeUnboundConversionNoInline(const char* p, const char* end,\n                                             UnboundConversion* conv,\n                                             int* next_arg);\n\n// Parse the format string provided in 'src' and pass the identified items into\n// 'consumer'.\n// Text runs will be passed by calling\n//   Consumer::Append(string_view);\n// ConversionItems will be passed by calling\n//   Consumer::ConvertOne(UnboundConversion, string_view);\n// In the case of ConvertOne, the string_view that is passed is the\n// portion of the format string corresponding to the conversion, not including\n// the leading %. On success, it returns true. On failure, it stops and returns\n// false.\ntemplate <typename Consumer>\nbool ParseFormatString(string_view src, Consumer consumer) {\n  int next_arg = 0;\n  const char* p = src.data();\n  const char* const end = p + src.size();\n  while (p != end) {\n    const char* percent =\n        static_cast<const char*>(memchr(p, '%', static_cast<size_t>(end - p)));\n    if (!percent) {\n      // We found the last substring.\n      return consumer.Append(string_view(p, static_cast<size_t>(end - p)));\n    }\n    // We found a percent, so push the text run then process the percent.\n    if (ABSL_PREDICT_FALSE(!consumer.Append(\n            string_view(p, static_cast<size_t>(percent - p))))) {\n      return false;\n    }\n    if (ABSL_PREDICT_FALSE(percent + 1 >= end)) return false;\n\n    auto tag = GetTagForChar(percent[1]);\n    if (tag.is_conv()) {\n      if (ABSL_PREDICT_FALSE(next_arg < 0)) {\n        // This indicates an error in the format string.\n        // The only way to get `next_arg < 0` here is to have a positional\n        // argument first which sets next_arg to -1 and then a non-positional\n        // argument.\n        return false;\n      }\n      p = percent + 2;\n\n      // Keep this case separate from the one below.\n      // ConvertOne is more efficient when the compiler can see that the `basic`\n      // flag is set.\n      UnboundConversion conv;\n      conv.conv = tag.as_conv();\n      conv.arg_position = ++next_arg;\n      if (ABSL_PREDICT_FALSE(\n              !consumer.ConvertOne(conv, string_view(percent + 1, 1)))) {\n        return false;\n      }\n    } else if (percent[1] != '%') {\n      UnboundConversion conv;\n      p = ConsumeUnboundConversionNoInline(percent + 1, end, &conv, &next_arg);\n      if (ABSL_PREDICT_FALSE(p == nullptr)) return false;\n      if (ABSL_PREDICT_FALSE(!consumer.ConvertOne(\n              conv, string_view(percent + 1,\n                                static_cast<size_t>(p - (percent + 1)))))) {\n        return false;\n      }\n    } else {\n      if (ABSL_PREDICT_FALSE(!consumer.Append(\"%\"))) return false;\n      p = percent + 2;\n      continue;\n    }\n  }\n  return true;\n}\n\n// Always returns true, or fails to compile in a constexpr context if s does not\n// point to a constexpr char array.\nconstexpr bool EnsureConstexpr(string_view s) {\n  return s.empty() || s[0] == s[0];\n}\n\nclass ParsedFormatBase {\n public:\n  explicit ParsedFormatBase(\n      string_view format, bool allow_ignored,\n      std::initializer_list<FormatConversionCharSet> convs);\n\n  ParsedFormatBase(const ParsedFormatBase& other) { *this = other; }\n\n  ParsedFormatBase(ParsedFormatBase&& other) { *this = std::move(other); }\n\n  ParsedFormatBase& operator=(const ParsedFormatBase& other) {\n    if (this == &other) return *this;\n    has_error_ = other.has_error_;\n    items_ = other.items_;\n    size_t text_size = items_.empty() ? 0 : items_.back().text_end;\n    data_.reset(new char[text_size]);\n    memcpy(data_.get(), other.data_.get(), text_size);\n    return *this;\n  }\n\n  ParsedFormatBase& operator=(ParsedFormatBase&& other) {\n    if (this == &other) return *this;\n    has_error_ = other.has_error_;\n    data_ = std::move(other.data_);\n    items_ = std::move(other.items_);\n    // Reset the vector to make sure the invariants hold.\n    other.items_.clear();\n    return *this;\n  }\n\n  template <typename Consumer>\n  bool ProcessFormat(Consumer consumer) const {\n    const char* const base = data_.get();\n    string_view text(base, 0);\n    for (const auto& item : items_) {\n      const char* const end = text.data() + text.size();\n      text =\n          string_view(end, static_cast<size_t>((base + item.text_end) - end));\n      if (item.is_conversion) {\n        if (!consumer.ConvertOne(item.conv, text)) return false;\n      } else {\n        if (!consumer.Append(text)) return false;\n      }\n    }\n    return !has_error_;\n  }\n\n  bool has_error() const { return has_error_; }\n\n private:\n  // Returns whether the conversions match and if !allow_ignored it verifies\n  // that all conversions are used by the format.\n  bool MatchesConversions(\n      bool allow_ignored,\n      std::initializer_list<FormatConversionCharSet> convs) const;\n\n  struct ParsedFormatConsumer;\n\n  struct ConversionItem {\n    bool is_conversion;\n    // Points to the past-the-end location of this element in the data_ array.\n    size_t text_end;\n    UnboundConversion conv;\n  };\n\n  bool has_error_;\n  std::unique_ptr<char[]> data_;\n  std::vector<ConversionItem> items_;\n};\n\n\n// A value type representing a preparsed format.  These can be created, copied\n// around, and reused to speed up formatting loops.\n// The user must specify through the template arguments the conversion\n// characters used in the format. This will be checked at compile time.\n//\n// This class uses Conv enum values to specify each argument.\n// This allows for more flexibility as you can specify multiple possible\n// conversion characters for each argument.\n// ParsedFormat<char...> is a simplified alias for when the user only\n// needs to specify a single conversion character for each argument.\n//\n// Example:\n//   // Extended format supports multiple characters per argument:\n//   using MyFormat = ExtendedParsedFormat<Conv::d | Conv::x>;\n//   MyFormat GetFormat(bool use_hex) {\n//     if (use_hex) return MyFormat(\"foo %x bar\");\n//     return MyFormat(\"foo %d bar\");\n//   }\n//   // 'format' can be used with any value that supports 'd' and 'x',\n//   // like `int`.\n//   auto format = GetFormat(use_hex);\n//   value = StringF(format, i);\n//\n// This class also supports runtime format checking with the ::New() and\n// ::NewAllowIgnored() factory functions.\n// This is the only API that allows the user to pass a runtime specified format\n// string. These factory functions will return NULL if the format does not match\n// the conversions requested by the user.\ntemplate <FormatConversionCharSet... C>\nclass ExtendedParsedFormat : public str_format_internal::ParsedFormatBase {\n public:\n  explicit ExtendedParsedFormat(string_view format)\n#ifdef ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n      __attribute__((\n          enable_if(str_format_internal::EnsureConstexpr(format),\n                    \"Format string is not constexpr.\"),\n          enable_if(str_format_internal::ValidFormatImpl<C...>(format),\n                    \"Format specified does not match the template arguments.\")))\n#endif  // ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n      : ExtendedParsedFormat(format, false) {\n  }\n\n  // ExtendedParsedFormat factory function.\n  // The user still has to specify the conversion characters, but they will not\n  // be checked at compile time. Instead, it will be checked at runtime.\n  // This delays the checking to runtime, but allows the user to pass\n  // dynamically sourced formats.\n  // It returns NULL if the format does not match the conversion characters.\n  // The user is responsible for checking the return value before using it.\n  //\n  // The 'New' variant will check that all the specified arguments are being\n  // consumed by the format and return NULL if any argument is being ignored.\n  // The 'NewAllowIgnored' variant will not verify this and will allow formats\n  // that ignore arguments.\n  static std::unique_ptr<ExtendedParsedFormat> New(string_view format) {\n    return New(format, false);\n  }\n  static std::unique_ptr<ExtendedParsedFormat> NewAllowIgnored(\n      string_view format) {\n    return New(format, true);\n  }\n\n private:\n  static std::unique_ptr<ExtendedParsedFormat> New(string_view format,\n                                                   bool allow_ignored) {\n    std::unique_ptr<ExtendedParsedFormat> conv(\n        new ExtendedParsedFormat(format, allow_ignored));\n    if (conv->has_error()) return nullptr;\n    return conv;\n  }\n\n  ExtendedParsedFormat(string_view s, bool allow_ignored)\n      : ParsedFormatBase(s, allow_ignored, {C...}) {}\n};\n}  // namespace str_format_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06438",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/parser.h",
  "source_line": 36,
  "validation_status": "validated"
}