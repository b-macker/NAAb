{
  "code": "#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <functional>\n#include <memory>\n#include <string>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17631_execute() {\n    {\n/// Provides notifications for file changes in a directory.\n///\n/// Invokes client-provided function on every filesystem event in the watched\n/// directory. Initially the watched directory is scanned and for every file\n/// found, an event is synthesized as if the file was added.\n///\n/// This is not a general purpose directory monitoring tool - list of\n/// limitations follows.\n///\n/// Only flat directories with no subdirectories are supported. In case\n/// subdirectories are present the behavior is unspecified - events *might* be\n/// passed to Receiver on macOS (due to FSEvents being used) while they\n/// *probably* won't be passed on Linux (due to inotify being used).\n///\n/// Known potential inconsistencies\n/// - For files that are deleted befor the initial scan processed them, clients\n/// might receive Removed notification without any prior Added notification.\n/// - Multiple notifications might be produced when a file is added to the\n/// watched directory during the initial scan. We are choosing the lesser evil\n/// here as the only known alternative strategy would be to invalidate the\n/// watcher instance and force user to create a new one whenever filesystem\n/// event occurs during the initial scan but that would introduce continuous\n/// restarting failure mode (watched directory is not always \"owned\" by the same\n/// process that is consuming it). Since existing clients can handle duplicate\n/// events well, we decided for simplicity.\n///\n/// Notifications are provided only for changes done through local user-space\n/// filesystem interface. Specifically, it's unspecified if notification would\n/// be provided in case of a:\n/// - a file mmap-ed and changed\n/// - a file changed via remote (NFS) or virtual (/proc) FS access to monitored\n/// directory\n/// - another filesystem mounted to the watched directory\n///\n/// No support for LLVM VFS.\n///\n/// It is unspecified whether notifications for files being deleted are sent in\n/// case the whole watched directory is sent.\n///\n/// Directories containing \"too many\" files and/or receiving events \"too\n/// frequently\" are not supported - if the initial scan can't be finished before\n/// the watcher instance gets invalidated (see WatcherGotInvalidated) there's no\n/// good error handling strategy - the only option for client is to destroy the\n/// watcher, restart watching with new instance and hope it won't repeat.\nclass DirectoryWatcher {\npublic:\n  struct Event {\n    enum class EventKind {\n      Removed,\n      /// Content of a file was modified.\n      Modified,\n      /// The watched directory got deleted.\n      WatchedDirRemoved,\n      /// The DirectoryWatcher that originated this event is no longer valid and\n      /// its behavior is unspecified.\n      ///\n      /// The prime case is kernel signalling to OS-specific implementation of\n      /// DirectoryWatcher some resource limit being hit.\n      /// *Usually* kernel starts dropping or squashing events together after\n      /// that and so would DirectoryWatcher. This means that *some* events\n      /// might still be passed to Receiver but this behavior is unspecified.\n      ///\n      /// Another case is after the watched directory itself is deleted.\n      /// WatcherGotInvalidated will be received at least once during\n      /// DirectoryWatcher instance lifetime - when handling errors this is done\n      /// on best effort basis, when an instance is being destroyed then this is\n      /// guaranteed.\n      ///\n      /// The only proper response to this kind of event is to destruct the\n      /// originating DirectoryWatcher instance and create a new one.\n      WatcherGotInvalidated\n    };\n\n    EventKind Kind;\n    /// Filename that this event is related to or an empty string in\n    /// case this event is related to the watched directory itself.\n    std::string Filename;\n\n    Event(EventKind Kind, llvm::StringRef Filename)\n        : Kind(Kind), Filename(Filename) {}\n  };\n\n  /// llvm fatal_error if \\param Path doesn't exist or isn't a directory.\n  /// Returns llvm::Expected Error if OS kernel API told us we can't start\n  /// watching. In such case it's unclear whether just retrying has any chance\n  /// to succeed.\n  static llvm::Expected<std::unique_ptr<DirectoryWatcher>>\n  create(llvm::StringRef Path,\n         std::function<void(llvm::ArrayRef<DirectoryWatcher::Event> Events,\n                            bool IsInitial)>\n             Receiver,\n         bool WaitForInitialSync);\n\n  virtual ~DirectoryWatcher() = default;\n  DirectoryWatcher(const DirectoryWatcher &) = delete;\n  DirectoryWatcher &operator=(const DirectoryWatcher &) = delete;\n  DirectoryWatcher(DirectoryWatcher &&) = default;\n\nprotected:\n  DirectoryWatcher() = default;\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17631",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h",
  "source_line": 19,
  "validation_status": "validated"
}