{
  "code": "#include \"absl/time/clock.h\"\n#include \"absl/base/attributes.h\"\n#include \"absl/base/optimization.h\"\n#include <windows.h>\n#include <algorithm>\n#include <atomic>\n#include <cerrno>\n#include <cstdint>\n#include <ctime>\n#include <limits>\n#include \"absl/base/internal/spinlock.h\"\n#include \"absl/base/internal/unscaledcycleclock.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/port.h\"\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/time/internal/get_current_time_chrono.inc\"\n#include \"absl/time/internal/get_current_time_posix.inc\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace time_internal;\nusing namespace time_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02159_execute() {\n    {\n  // read the data from the \"last_sample\" struct (but don't need raw_ns yet)\n  // The reads of \"seq\" and test of the values emulate a reader lock.\n  uint64_t base_ns;\n  uint64_t base_cycles;\n  uint64_t nsscaled_per_cycle;\n  uint64_t min_cycles_per_sample;\n  uint64_t seq_read0;\n  uint64_t seq_read1;\n\n  // If we have enough information to interpolate, the value returned will be\n  // derived from this cycleclock-derived time estimate.  On some platforms\n  // (POWER) the function to retrieve this value has enough complexity to\n  // contribute to register pressure - reading it early before initializing\n  // the other pieces of the calculation minimizes spill/restore instructions,\n  // minimizing icache cost.\n  uint64_t now_cycles =\n      static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());\n\n  // Acquire pairs with the barrier in SeqRelease - if this load sees that\n  // store, the shared-data reads necessarily see that SeqRelease's updates\n  // to the same shared data.\n  seq_read0 = time_state.seq.load(std::memory_order_acquire);\n\n  base_ns = time_state.last_sample.base_ns.load(std::memory_order_relaxed);\n  base_cycles =\n      time_state.last_sample.base_cycles.load(std::memory_order_relaxed);\n  nsscaled_per_cycle =\n      time_state.last_sample.nsscaled_per_cycle.load(std::memory_order_relaxed);\n  min_cycles_per_sample = time_state.last_sample.min_cycles_per_sample.load(\n      std::memory_order_relaxed);\n\n  // This acquire fence pairs with the release fence in SeqAcquire.  Since it\n  // is sequenced between reads of shared data and seq_read1, the reads of\n  // shared data are effectively acquiring.\n  std::atomic_thread_fence(std::memory_order_acquire);\n\n  // The shared-data reads are effectively acquire ordered, and the\n  // shared-data writes are effectively release ordered. Therefore if our\n  // shared-data reads see any of a particular update's shared-data writes,\n  // seq_read1 is guaranteed to see that update's SeqAcquire.\n  seq_read1 = time_state.seq.load(std::memory_order_relaxed);\n\n  // Fast path.  Return if min_cycles_per_sample has not yet elapsed since the\n  // last sample, and we read a consistent sample.  The fast path activates\n  // only when min_cycles_per_sample is non-zero, which happens when we get an\n  // estimate for the cycle time.  The predicate will fail if now_cycles <\n  // base_cycles, or if some other thread is in the slow path.\n  //\n  // Since we now read now_cycles before base_ns, it is possible for now_cycles\n  // to be less than base_cycles (if we were interrupted between those loads and\n  // last_sample was updated). This is harmless, because delta_cycles will wrap\n  // and report a time much much bigger than min_cycles_per_sample. In that case\n  // we will take the slow path.\n  uint64_t delta_cycles;\n  if (seq_read0 == seq_read1 && (seq_read0 & 1) == 0 &&\n      (delta_cycles = now_cycles - base_cycles) < min_cycles_per_sample) {\n    return static_cast<int64_t>(\n        base_ns + ((delta_cycles * nsscaled_per_cycle) >> kScale));\n  }\n  return GetCurrentTimeNanosSlowPath();\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02159",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/clock.cc",
  "source_line": 304,
  "validation_status": "validated"
}