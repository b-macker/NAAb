{
  "code": "{\n  /// For makeDeclVisibleInContextImpl\n  friend class ASTDeclReader;\n  /// For checking the new bits in the Serialization part.\n  friend class ASTDeclWriter;\n  /// For reconcileExternalVisibleStorage, CreateStoredDeclsMap,\n  /// hasNeedToReconcileExternalVisibleStorage\n  friend class ExternalASTSource;\n  /// For CreateStoredDeclsMap\n  friend class DependentDiagnostic;\n  /// For hasNeedToReconcileExternalVisibleStorage,\n  /// hasLazyLocalLexicalLookups, hasLazyExternalLexicalLookups\n  friend class ASTWriter;\n\n  // We use uint64_t in the bit-fields below since some bit-fields\n  // cross the unsigned boundary and this breaks the packing.\n\n  /// Stores the bits used by DeclContext.\n  /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor\n  /// methods in DeclContext should be updated appropriately.\n  class DeclContextBitfields {\n    friend class DeclContext;\n    /// DeclKind - This indicates which class this is.\n    uint64_t DeclKind : 7;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are lexically\n    /// part of this context.\n    mutable uint64_t ExternalLexicalStorage : 1;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are visible\n    /// in this context.\n    mutable uint64_t ExternalVisibleStorage : 1;\n\n    /// Whether this declaration context has had externally visible\n    /// storage added since the last lookup. In this case, \\c LookupPtr's\n    /// invariant may not hold and needs to be fixed before we perform\n    /// another lookup.\n    mutable uint64_t NeedToReconcileExternalVisibleStorage : 1;\n\n    /// If \\c true, this context may have local lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyLocalLexicalLookups : 1;\n\n    /// If \\c true, the external source may have lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyExternalLexicalLookups : 1;\n\n    /// If \\c true, lookups should only return identifier from\n    /// DeclContext scope (for example TranslationUnit). Used in\n    /// LookupQualifiedName()\n    mutable uint64_t UseQualifiedLookup : 1;\n  };\n\n  /// Number of bits in DeclContextBitfields.\n  enum { NumDeclContextBits = 13 };\n\n  /// Stores the bits used by TagDecl.\n  /// If modified NumTagDeclBits and the accessor\n  /// methods in TagDecl should be updated appropriately.\n  class TagDeclBitfields {\n    friend class TagDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// The TagKind enum.\n    uint64_t TagDeclKind : 3;\n\n    /// True if this is a definition (\"struct foo {};\"), false if it is a\n    /// declaration (\"struct foo;\").  It is not considered a definition\n    /// until the definition has been fully processed.\n    uint64_t IsCompleteDefinition : 1;\n\n    /// True if this is currently being defined.\n    uint64_t IsBeingDefined : 1;\n\n    /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n    /// for the very first time) in the syntax of a declarator.\n    uint64_t IsEmbeddedInDeclarator : 1;\n\n    /// True if this tag is free standing, e.g. \"struct foo;\".\n    uint64_t IsFreeStanding : 1;\n\n    /// Indicates whether it is possible for declarations of this kind\n    /// to have an out-of-date definition.\n    ///\n    /// This option is only enabled when modules are enabled.\n    uint64_t MayHaveOutOfDateDef : 1;\n\n    /// Has the full definition of this type been required by a use somewhere in\n    /// the TU.\n    uint64_t IsCompleteDefinitionRequired : 1;\n\n    /// Whether this tag is a definition which was demoted due to\n    /// a module merge.\n    uint64_t IsThisDeclarationADemotedDefinition : 1;\n  };\n\n  /// Number of non-inherited bits in TagDeclBitfields.\n  enum { NumTagDeclBits = 10 };\n\n  /// Stores the bits used by EnumDecl.\n  /// If modified NumEnumDeclBit and the accessor\n  /// methods in EnumDecl should be updated appropriately.\n  class EnumDeclBitfields {\n    friend class EnumDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// Width in bits required to store all the non-negative\n    /// enumerators of this enum.\n    uint64_t NumPositiveBits : 8;\n\n    /// Width in bits required to store all the negative\n    /// enumerators of this enum.\n    uint64_t NumNegativeBits : 8;\n\n    /// True if this tag declaration is a scoped enumeration. Only\n    /// possible in C++11 mode.\n    uint64_t IsScoped : 1;\n\n    /// If this tag declaration is a scoped enum,\n    /// then this is true if the scoped enum was declared using the class\n    /// tag, false if it was declared with the struct tag. No meaning is\n    /// associated if this tag declaration is not a scoped enum.\n    uint64_t IsScopedUsingClassTag : 1;\n\n    /// True if this is an enumeration with fixed underlying type. Only\n    /// possible in C++11, Microsoft extensions, or Objective C mode.\n    uint64_t IsFixed : 1;\n\n    /// True if a valid hash is stored in ODRHash.\n    uint64_t HasODRHash : 1;\n  };\n\n  /// Number of non-inherited bits in EnumDeclBitfields.\n  enum { NumEnumDeclBits = 20 };\n\n  /// Stores the bits used by RecordDecl.\n  /// If modified NumRecordDeclBits and the accessor\n  /// methods in RecordDecl should be updated appropriately.\n  class RecordDeclBitfields {\n    friend class RecordDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// This is true if this struct ends with a flexible\n    /// array member (e.g. int X[]) or if this union contains a struct that does.\n    /// If so, this cannot be contained in arrays or other structs as a member.\n    uint64_t HasFlexibleArrayMember : 1;\n\n    /// Whether this is the type of an anonymous struct or union.\n    uint64_t AnonymousStructOrUnion : 1;\n\n    /// This is true if this struct has at least one member\n    /// containing an Objective-C object pointer type.\n    uint64_t HasObjectMember : 1;\n\n    /// This is true if struct has at least one member of\n    /// 'volatile' type.\n    uint64_t HasVolatileMember : 1;\n\n    /// Whether the field declarations of this record have been loaded\n    /// from external storage. To avoid unnecessary deserialization of\n    /// methods/nested types we allow deserialization of just the fields\n    /// when needed.\n    mutable uint64_t LoadedFieldsFromExternalStorage : 1;\n\n    /// Basic properties of non-trivial C structs.\n    uint64_t NonTrivialToPrimitiveDefaultInitialize : 1;\n    uint64_t NonTrivialToPrimitiveCopy : 1;\n    uint64_t NonTrivialToPrimitiveDestroy : 1;\n\n    /// The following bits indicate whether this is or contains a C union that\n    /// is non-trivial to default-initialize, destruct, or copy. These bits\n    /// imply the associated basic non-triviality predicates declared above.\n    uint64_t HasNonTrivialToPrimitiveDefaultInitializeCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveDestructCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveCopyCUnion : 1;\n\n    /// Indicates whether this struct is destroyed in the callee.\n    uint64_t ParamDestroyedInCallee : 1;\n\n    /// Represents the way this type is passed to a function.\n    uint64_t ArgPassingRestrictions : 2;\n\n    /// Indicates whether this struct has had its field layout randomized.\n    uint64_t IsRandomized : 1;\n\n    /// True if a valid hash is stored in ODRHash. This should shave off some\n    /// extra storage and prevent CXXRecordDecl to store unused bits.\n    uint64_t ODRHash : 26;\n  };\n\n  /// Number of non-inherited bits in RecordDeclBitfields.\n  enum { NumRecordDeclBits = 41 };\n\n  /// Stores the bits used by OMPDeclareReductionDecl.\n  /// If modified NumOMPDeclareReductionDeclBits and the accessor\n  /// methods in OMPDeclareReductionDecl should be updated appropriately.\n  class OMPDeclareReductionDeclBitfields {\n    friend class OMPDeclareReductionDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// Kind of initializer,\n    /// function call or omp_priv<init_expr> initialization.\n    uint64_t InitializerKind : 2;\n  };\n\n  /// Number of non-inherited bits in OMPDeclareReductionDeclBitfields.\n  enum { NumOMPDeclareReductionDeclBits = 2 };\n\n  /// Stores the bits used by FunctionDecl.\n  /// If modified NumFunctionDeclBits and the accessor\n  /// methods in FunctionDecl and CXXDeductionGuideDecl\n  /// (for DeductionCandidateKind) should be updated appropriately.\n  class FunctionDeclBitfields {\n    friend class FunctionDecl;\n    /// For DeductionCandidateKind\n    friend class CXXDeductionGuideDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t SClass : 3;\n    uint64_t IsInline : 1;\n    uint64_t IsInlineSpecified : 1;\n\n    uint64_t IsVirtualAsWritten : 1;\n    uint64_t IsPure : 1;\n    uint64_t HasInheritedPrototype : 1;\n    uint64_t HasWrittenPrototype : 1;\n    uint64_t IsDeleted : 1;\n    /// Used by CXXMethodDecl\n    uint64_t IsTrivial : 1;\n\n    /// This flag indicates whether this function is trivial for the purpose of\n    /// calls. This is meaningful only when this function is a copy/move\n    /// constructor or a destructor.\n    uint64_t IsTrivialForCall : 1;\n\n    uint64_t IsDefaulted : 1;\n    uint64_t IsExplicitlyDefaulted : 1;\n    uint64_t HasDefaultedFunctionInfo : 1;\n\n    /// For member functions of complete types, whether this is an ineligible\n    /// special member function or an unselected destructor. See\n    /// [class.mem.special].\n    uint64_t IsIneligibleOrNotSelected : 1;\n\n    uint64_t HasImplicitReturnZero : 1;\n    uint64_t IsLateTemplateParsed : 1;\n\n    /// Kind of contexpr specifier as defined by ConstexprSpecKind.\n    uint64_t ConstexprKind : 2;\n    uint64_t BodyContainsImmediateEscalatingExpression : 1;\n\n    uint64_t InstantiationIsPending : 1;\n\n    /// Indicates if the function uses __try.\n    uint64_t UsesSEHTry : 1;\n\n    /// Indicates if the function was a definition\n    /// but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n\n    /// Indicates if the function declaration will\n    /// have a body, once we're done parsing it.\n    uint64_t WillHaveBody : 1;\n\n    /// Indicates that this function is a multiversioned\n    /// function using attribute 'target'.\n    uint64_t IsMultiVersion : 1;\n\n    /// Only used by CXXDeductionGuideDecl. Indicates the kind\n    /// of the Deduction Guide that is implicitly generated\n    /// (used during overload resolution).\n    uint64_t DeductionCandidateKind : 2;\n\n    /// Store the ODRHash after first calculation.\n    uint64_t HasODRHash : 1;\n\n    /// Indicates if the function uses Floating Point Constrained Intrinsics\n    uint64_t UsesFPIntrin : 1;\n\n    // Indicates this function is a constrained friend, where the constraint\n    // refers to an enclosing template for hte purposes of [temp.friend]p9.\n    uint64_t FriendConstraintRefersToEnclosingTemplate : 1;\n  };\n\n  /// Number of non-inherited bits in FunctionDeclBitfields.\n  enum { NumFunctionDeclBits = 31 };\n\n  /// Stores the bits used by CXXConstructorDecl. If modified\n  /// NumCXXConstructorDeclBits and the accessor\n  /// methods in CXXConstructorDecl should be updated appropriately.\n  class CXXConstructorDeclBitfields {\n    friend class CXXConstructorDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in FunctionDeclBitfields.\n    uint64_t : NumFunctionDeclBits;\n\n    /// 20 bits to fit in the remaining available space.\n    /// Note that this makes CXXConstructorDeclBitfields take\n    /// exactly 64 bits and thus the width of NumCtorInitializers\n    /// will need to be shrunk if some bit is added to NumDeclContextBitfields,\n    /// NumFunctionDeclBitfields or CXXConstructorDeclBitfields.\n    uint64_t NumCtorInitializers : 17;\n    uint64_t IsInheritingConstructor : 1;\n\n    /// Whether this constructor has a trail-allocated explicit specifier.\n    uint64_t HasTrailingExplicitSpecifier : 1;\n    /// If this constructor does't have a trail-allocated explicit specifier.\n    /// Whether this constructor is explicit specified.\n    uint64_t IsSimpleExplicit : 1;\n  };\n\n  /// Number of non-inherited bits in CXXConstructorDeclBitfields.\n  enum {\n    NumCXXConstructorDeclBits = 64 - NumDeclContextBits - NumFunctionDeclBits\n  };\n\n  /// Stores the bits used by ObjCMethodDecl.\n  /// If modified NumObjCMethodDeclBits and the accessor\n  /// methods in ObjCMethodDecl should be updated appropriately.\n  class ObjCMethodDeclBitfields {\n    friend class ObjCMethodDecl;\n\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The conventional meaning of this method; an ObjCMethodFamily.\n    /// This is not serialized; instead, it is computed on demand and\n    /// cached.\n    mutable uint64_t Family : ObjCMethodFamilyBitWidth;\n\n    /// instance (true) or class (false) method.\n    uint64_t IsInstance : 1;\n    uint64_t IsVariadic : 1;\n\n    /// True if this method is the getter or setter for an explicit property.\n    uint64_t IsPropertyAccessor : 1;\n\n    /// True if this method is a synthesized property accessor stub.\n    uint64_t IsSynthesizedAccessorStub : 1;\n\n    /// Method has a definition.\n    uint64_t IsDefined : 1;\n\n    /// Method redeclaration in the same interface.\n    uint64_t IsRedeclaration : 1;\n\n    /// Is redeclared in the same interface.\n    mutable uint64_t HasRedeclaration : 1;\n\n    /// \\@required/\\@optional\n    uint64_t DeclImplementation : 2;\n\n    /// in, inout, etc.\n    uint64_t objcDeclQualifier : 7;\n\n    /// Indicates whether this method has a related result type.\n    uint64_t RelatedResultType : 1;\n\n    /// Whether the locations of the selector identifiers are in a\n    /// \"standard\" position, a enum SelectorLocationsKind.\n    uint64_t SelLocsKind : 2;\n\n    /// Whether this method overrides any other in the class hierarchy.\n    ///\n    /// A method is said to override any method in the class's\n    /// base classes, its protocols, or its categories' protocols, that has\n    /// the same selector and is of the same kind (class or instance).\n    /// A method in an implementation is not considered as overriding the same\n    /// method in the interface or its categories.\n    uint64_t IsOverriding : 1;\n\n    /// Indicates if the method was a definition but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n  };\n\n  /// Number of non-inherited bits in ObjCMethodDeclBitfields.\n  enum { NumObjCMethodDeclBits = 24 };\n\n  /// Stores the bits used by ObjCContainerDecl.\n  /// If modified NumObjCContainerDeclBits and the accessor\n  /// methods in ObjCContainerDecl should be updated appropriately.\n  class ObjCContainerDeclBitfields {\n    friend class ObjCContainerDecl;\n    /// For the bits in DeclContextBitfields\n    uint32_t : NumDeclContextBits;\n\n    // Not a bitfield but this saves space.\n    // Note that ObjCContainerDeclBitfields is full.\n    SourceLocation AtStart;\n  };\n\n  /// Number of non-inherited bits in ObjCContainerDeclBitfields.\n  /// Note that here we rely on the fact that SourceLocation is 32 bits\n  /// wide. We check this with the static_assert in the ctor of DeclContext.\n  enum { NumObjCContainerDeclBits = 64 - NumDeclContextBits };\n\n  /// Stores the bits used by LinkageSpecDecl.\n  /// If modified NumLinkageSpecDeclBits and the accessor\n  /// methods in LinkageSpecDecl should be updated appropriately.\n  class LinkageSpecDeclBitfields {\n    friend class LinkageSpecDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The language for this linkage specification with values\n    /// in the enum LinkageSpecDecl::LanguageIDs.\n    uint64_t Language : 3;\n\n    /// True if this linkage spec has braces.\n    /// This is needed so that hasBraces() returns the correct result while the\n    /// linkage spec body is being parsed.  Once RBraceLoc has been set this is\n    /// not used, so it doesn't need to be serialized.\n    uint64_t HasBraces : 1;\n  };\n\n  /// Number of non-inherited bits in LinkageSpecDeclBitfields.\n  enum { NumLinkageSpecDeclBits = 4 };\n\n  /// Stores the bits used by BlockDecl.\n  /// If modified NumBlockDeclBits and the accessor\n  /// methods in BlockDecl should be updated appropriately.\n  class BlockDeclBitfields {\n    friend class BlockDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t IsVariadic : 1;\n    uint64_t CapturesCXXThis : 1;\n    uint64_t BlockMissingReturnType : 1;\n    uint64_t IsConversionFromLambda : 1;\n\n    /// A bit that indicates this block is passed directly to a function as a\n    /// non-escaping parameter.\n    uint64_t DoesNotEscape : 1;\n\n    /// A bit that indicates whether it's possible to avoid coying this block to\n    /// the heap when it initializes or is assigned to a local variable with\n    /// automatic storage.\n    uint64_t CanAvoidCopyToHeap : 1;\n  };\n\n  /// Number of non-inherited bits in BlockDeclBitfields.\n  enum { NumBlockDeclBits = 5 };\n\n  /// Pointer to the data structure used to lookup declarations\n  /// within this context (or a DependentStoredDeclsMap if this is a\n  /// dependent context). We maintain the invariant that, if the map\n  /// contains an entry for a DeclarationName (and we haven't lazily\n  /// omitted anything), then it contains all relevant entries for that\n  /// name (modulo the hasExternalDecls() flag).\n  mutable StoredDeclsMap *LookupPtr = nullptr;\n\nprotected:\n  /// This anonymous union stores the bits belonging to DeclContext and classes\n  /// deriving from it. The goal is to use otherwise wasted\n  /// space in DeclContext to store data belonging to derived classes.\n  /// The space saved is especially significient when pointers are aligned\n  /// to 8 bytes. In this case due to alignment requirements we have a\n  /// little less than 8 bytes free in DeclContext which we can use.\n  /// We check that none of the classes in this union is larger than\n  /// 8 bytes with static_asserts in the ctor of DeclContext.\n  union {\n    DeclContextBitfields DeclContextBits;\n    TagDeclBitfields TagDeclBits;\n    EnumDeclBitfields EnumDeclBits;\n    RecordDeclBitfields RecordDeclBits;\n    OMPDeclareReductionDeclBitfields OMPDeclareReductionDeclBits;\n    FunctionDeclBitfields FunctionDeclBits;\n    CXXConstructorDeclBitfields CXXConstructorDeclBits;\n    ObjCMethodDeclBitfields ObjCMethodDeclBits;\n    ObjCContainerDeclBitfields ObjCContainerDeclBits;\n    LinkageSpecDeclBitfields LinkageSpecDeclBits;\n    BlockDeclBitfields BlockDeclBits;\n\n    static_assert(sizeof(DeclContextBitfields) <= 8,\n                  \"DeclContextBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(TagDeclBitfields) <= 8,\n                  \"TagDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(EnumDeclBitfields) <= 8,\n                  \"EnumDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(RecordDeclBitfields) <= 8,\n                  \"RecordDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(OMPDeclareReductionDeclBitfields) <= 8,\n                  \"OMPDeclareReductionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(FunctionDeclBitfields) <= 8,\n                  \"FunctionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(CXXConstructorDeclBitfields) <= 8,\n                  \"CXXConstructorDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCMethodDeclBitfields) <= 8,\n                  \"ObjCMethodDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCContainerDeclBitfields) <= 8,\n                  \"ObjCContainerDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(LinkageSpecDeclBitfields) <= 8,\n                  \"LinkageSpecDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(BlockDeclBitfields) <= 8,\n                  \"BlockDeclBitfields is larger than 8 bytes!\");\n  };\n\n  /// FirstDecl - The first declaration stored within this declaration\n  /// context.\n  mutable Decl *FirstDecl = nullptr;\n\n  /// LastDecl - The last declaration stored within this declaration\n  /// context. FIXME: We could probably cache this value somewhere\n  /// outside of the DeclContext, to reduce the size of DeclContext by\n  /// another pointer.\n  mutable Decl *LastDecl = nullptr;\n\n  /// Build up a chain of declarations.\n  ///\n  /// \\returns the first/last pair of declarations.\n  static std::pair<Decl *, Decl *>\n  BuildDeclChain(ArrayRef<Decl*> Decls, bool FieldsAlreadyLoaded);\n\n  DeclContext(Decl::Kind K);\n\npublic:\n  ~DeclContext();\n\n  // For use when debugging; hasValidDeclKind() will always return true for\n  // a correctly constructed object within its lifetime.\n  bool hasValidDeclKind() const;\n\n  Decl::Kind getDeclKind() const {\n    return static_cast<Decl::Kind>(DeclContextBits.DeclKind);\n  }\n\n  const char *getDeclKindName() const;\n\n  /// getParent - Returns the containing DeclContext.\n  DeclContext *getParent() {\n    return cast<Decl>(this)->getDeclContext();\n  }\n  const DeclContext *getParent() const {\n    return const_cast<DeclContext*>(this)->getParent();\n  }\n\n  /// getLexicalParent - Returns the containing lexical DeclContext. May be\n  /// different from getParent, e.g.:\n  ///\n  ///   namespace A {\n  ///      struct S;\n  ///   }\n  ///   struct A::S {}; // getParent() == namespace 'A'\n  ///                   // getLexicalParent() == translation unit\n  ///\n  DeclContext *getLexicalParent() {\n    return cast<Decl>(this)->getLexicalDeclContext();\n  }\n  const DeclContext *getLexicalParent() const {\n    return const_cast<DeclContext*>(this)->getLexicalParent();\n  }\n\n  DeclContext *getLookupParent();\n\n  const DeclContext *getLookupParent() const {\n    return const_cast<DeclContext*>(this)->getLookupParent();\n  }\n\n  ASTContext &getParentASTContext() const {\n    return cast<Decl>(this)->getASTContext();\n  }\n\n  bool isClosure() const { return getDeclKind() == Decl::Block; }\n\n  /// Return this DeclContext if it is a BlockDecl. Otherwise, return the\n  /// innermost enclosing BlockDecl or null if there are no enclosing blocks.\n  const BlockDecl *getInnermostBlockDecl() const;\n\n  bool isObjCContainer() const {\n    switch (getDeclKind()) {\n    case Decl::ObjCCategory:\n    case Decl::ObjCCategoryImpl:\n    case Decl::ObjCImplementation:\n    case Decl::ObjCInterface:\n    case Decl::ObjCProtocol:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isFunctionOrMethod() const {\n    switch (getDeclKind()) {\n    case Decl::Block:\n    case Decl::Captured:\n    case Decl::ObjCMethod:\n      return true;\n    default:\n      return getDeclKind() >= Decl::firstFunction &&\n             getDeclKind() <= Decl::lastFunction;\n    }\n  }\n\n  /// Test whether the context supports looking up names.\n  bool isLookupContext() const {\n    return !isFunctionOrMethod() && getDeclKind() != Decl::LinkageSpec &&\n           getDeclKind() != Decl::Export;\n  }\n\n  bool isFileContext() const {\n    return getDeclKind() == Decl::TranslationUnit ||\n           getDeclKind() == Decl::Namespace;\n  }\n\n  bool isTranslationUnit() const {\n    return getDeclKind() == Decl::TranslationUnit;\n  }\n\n  bool isRecord() const {\n    return getDeclKind() >= Decl::firstRecord &&\n           getDeclKind() <= Decl::lastRecord;\n  }\n\n  bool isNamespace() const { return getDeclKind() == Decl::Namespace; }\n\n  bool isStdNamespace() const;\n\n  bool isInlineNamespace() const;\n\n  /// Determines whether this context is dependent on a\n  /// template parameter.\n  bool isDependentContext() const;\n\n  /// isTransparentContext - Determines whether this context is a\n  /// \"transparent\" context, meaning that the members declared in this\n  /// context are semantically declared in the nearest enclosing\n  /// non-transparent (opaque) context but are lexically declared in\n  /// this context. For example, consider the enumerators of an\n  /// enumeration type:\n  /// @code\n  /// enum E {\n  ///   Val1\n  /// };\n  /// @endcode\n  /// Here, E is a transparent context, so its enumerator (Val1) will\n  /// appear (semantically) that it is in the same context of E.\n  /// Examples of transparent contexts include: enumerations (except for\n  /// C++0x scoped enums), C++ linkage specifications and export declaration.\n  bool isTransparentContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C linkage.\n  bool isExternCContext() const;\n\n  /// Retrieve the nearest enclosing C linkage specification context.\n  const LinkageSpecDecl *getExternCContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C++ linkage.\n  bool isExternCXXContext() const;\n\n  /// Determine whether this declaration context is equivalent\n  /// to the declaration context DC.\n  bool Equals(const DeclContext *DC) const {\n    return DC && this->getPrimaryContext() == DC->getPrimaryContext();\n  }\n\n  /// Determine whether this declaration context encloses the\n  /// declaration context DC.\n  bool Encloses(const DeclContext *DC) const;\n\n  /// Find the nearest non-closure ancestor of this context,\n  /// i.e. the innermost semantic parent of this context which is not\n  /// a closure.  A context may be its own non-closure ancestor.\n  Decl *getNonClosureAncestor();\n  const Decl *getNonClosureAncestor() const {\n    return const_cast<DeclContext*>(this)->getNonClosureAncestor();\n  }\n\n  // Retrieve the nearest context that is not a transparent context.\n  DeclContext *getNonTransparentContext();\n  const DeclContext *getNonTransparentContext() const {\n    return const_cast<DeclContext *>(this)->getNonTransparentContext();\n  }\n\n  /// getPrimaryContext - There may be many different\n  /// declarations of the same entity (including forward declarations\n  /// of classes, multiple definitions of namespaces, etc.), each with\n  /// a different set of declarations. This routine returns the\n  /// \"primary\" DeclContext structure, which will contain the\n  /// information needed to perform name lookup into this context.\n  DeclContext *getPrimaryContext();\n  const DeclContext *getPrimaryContext() const {\n    return const_cast<DeclContext*>(this)->getPrimaryContext();\n  }\n\n  /// getRedeclContext - Retrieve the context in which an entity conflicts with\n  /// other entities of the same name, or where it is a redeclaration if the\n  /// two entities are compatible. This skips through transparent contexts.\n  DeclContext *getRedeclContext();\n  const DeclContext *getRedeclContext() const {\n    return const_cast<DeclContext *>(this)->getRedeclContext();\n  }\n\n  /// Retrieve the nearest enclosing namespace context.\n  DeclContext *getEnclosingNamespaceContext();\n  const DeclContext *getEnclosingNamespaceContext() const {\n    return const_cast<DeclContext *>(this)->getEnclosingNamespaceContext();\n  }\n\n  /// Retrieve the outermost lexically enclosing record context.\n  RecordDecl *getOuterLexicalRecordContext();\n  const RecordDecl *getOuterLexicalRecordContext() const {\n    return const_cast<DeclContext *>(this)->getOuterLexicalRecordContext();\n  }\n\n  /// Test if this context is part of the enclosing namespace set of\n  /// the context NS, as defined in C++0x [namespace.def]p9. If either context\n  /// isn't a namespace, this is equivalent to Equals().\n  ///\n  /// The enclosing namespace set of a namespace is the namespace and, if it is\n  /// inline, its enclosing namespace, recursively.\n  bool InEnclosingNamespaceSetOf(const DeclContext *NS) const;\n\n  /// Collects all of the declaration contexts that are semantically\n  /// connected to this declaration context.\n  ///\n  /// For declaration contexts that have multiple semantically connected but\n  /// syntactically distinct contexts, such as C++ namespaces, this routine\n  /// retrieves the complete set of such declaration contexts in source order.\n  /// For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   int x;\n  /// }\n  /// namespace N {\n  ///   int y;\n  /// }\n  /// \\endcode\n  ///\n  /// The \\c Contexts parameter will contain both definitions of N.\n  ///\n  /// \\param Contexts Will be cleared and set to the set of declaration\n  /// contexts that are semanticaly connected to this declaration context,\n  /// in source order, including this context (which may be the only result,\n  /// for non-namespace contexts).\n  void collectAllContexts(SmallVectorImpl<DeclContext *> &Contexts);\n\n  /// decl_iterator - Iterates through the declarations stored\n  /// within this context.\n  class decl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    decl_iterator() = default;\n    explicit decl_iterator(Decl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return Current; }\n\n    decl_iterator& operator++() {\n      Current = Current->getNextDeclInContext();\n      return *this;\n    }\n\n    decl_iterator operator++(int) {\n      decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(decl_iterator x, decl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(decl_iterator x, decl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// decls_begin/decls_end - Iterate over the declarations stored in\n  /// this context.\n  decl_range decls() const { return decl_range(decls_begin(), decls_end()); }\n  decl_iterator decls_begin() const;\n  decl_iterator decls_end() const { return decl_iterator(); }\n  bool decls_empty() const;\n\n  /// noload_decls_begin/end - Iterate over the declarations stored in this\n  /// context that are currently loaded; don't attempt to retrieve anything\n  /// from an external source.\n  decl_range noload_decls() const {\n    return decl_range(noload_decls_begin(), noload_decls_end());\n  }\n  decl_iterator noload_decls_begin() const { return decl_iterator(FirstDecl); }\n  decl_iterator noload_decls_end() const { return decl_iterator(); }\n\n  /// specific_decl_iterator - Iterates over a subrange of\n  /// declarations stored in a DeclContext, providing only those that\n  /// are of type SpecificDecl (or a class derived from it). This\n  /// iterator is used, for example, to provide iteration over just\n  /// the fields within a RecordDecl (with SpecificDecl = FieldDecl).\n  template<typename SpecificDecl>\n  class specific_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Iterates over a filtered subrange of declarations stored\n  /// in a DeclContext.\n  ///\n  /// This iterator visits only those declarations that are of type\n  /// SpecificDecl (or a class derived from it) and that meet some\n  /// additional run-time criteria. This iterator is used, for\n  /// example, to provide access to the instance methods within an\n  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl and\n  /// Acceptable = ObjCMethodDecl::isInstanceMethod).\n  template<typename SpecificDecl, bool (SpecificDecl::*Acceptable)() const>\n  class filtered_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current &&\n             (!isa<SpecificDecl>(*Current) ||\n              (Acceptable && !(cast<SpecificDecl>(*Current)->*Acceptable)())))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    filtered_decl_iterator() = default;\n\n    /// filtered_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit filtered_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n    value_type operator->() const { return cast<SpecificDecl>(*Current); }\n\n    filtered_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    filtered_decl_iterator operator++(int) {\n      filtered_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Add the declaration D into this context.\n  ///\n  /// This routine should be invoked when the declaration D has first\n  /// been declared, to place D into the context where it was\n  /// (lexically) defined. Every declaration must be added to one\n  /// (and only one!) context, where it can be visited via\n  /// [decls_begin(), decls_end()). Once a declaration has been added\n  /// to its lexical context, the corresponding DeclContext owns the\n  /// declaration.\n  ///\n  /// If D is also a NamedDecl, it will be made visible within its\n  /// semantic context via makeDeclVisibleInContext.\n  void addDecl(Decl *D);\n\n  /// Add the declaration D into this context, but suppress\n  /// searches for external declarations with the same name.\n  ///\n  /// Although analogous in function to addDecl, this removes an\n  /// important check.  This is only useful if the Decl is being\n  /// added in response to an external search; in all other cases,\n  /// addDecl() is the right function to use.\n  /// See the ASTImporter for use cases.\n  void addDeclInternal(Decl *D);\n\n  /// Add the declaration D to this context without modifying\n  /// any lookup tables.\n  ///\n  /// This is useful for some operations in dependent contexts where\n  /// the semantic context might not be dependent;  this basically\n  /// only happens with friends.\n  void addHiddenDecl(Decl *D);\n\n  /// Removes a declaration from this context.\n  void removeDecl(Decl *D);\n\n  /// Checks whether a declaration is in this context.\n  bool containsDecl(Decl *D) const;\n\n  /// Checks whether a declaration is in this context.\n  /// This also loads the Decls from the external source before the check.\n  bool containsDeclAndLoad(Decl *D) const;\n\n  using lookup_result = DeclContextLookupResult;\n  using lookup_iterator = lookup_result::iterator;\n\n  /// lookup - Find the declarations (if any) with the given Name in\n  /// this context. Returns a range of iterators that contains all of\n  /// the declarations with this name, with object, function, member,\n  /// and enumerator names preceding any tag name. Note that this\n  /// routine will not look into parent contexts.\n  lookup_result lookup(DeclarationName Name) const;\n\n  /// Find the declarations with the given name that are visible\n  /// within this context; don't attempt to retrieve anything from an\n  /// external source.\n  lookup_result noload_lookup(DeclarationName Name);\n\n  /// A simplistic name lookup mechanism that performs name lookup\n  /// into this declaration context without consulting the external source.\n  ///\n  /// This function should almost never be used, because it subverts the\n  /// usual relationship between a DeclContext and the external source.\n  /// See the ASTImporter for the (few, but important) use cases.\n  ///\n  /// FIXME: This is very inefficient; replace uses of it with uses of\n  /// noload_lookup.\n  void localUncachedLookup(DeclarationName Name,\n                           SmallVectorImpl<NamedDecl *> &Results);\n\n  /// Makes a declaration visible within this context.\n  ///\n  /// This routine makes the declaration D visible to name lookup\n  /// within this context and, if this is a transparent context,\n  /// within its parent contexts up to the first enclosing\n  /// non-transparent context. Making a declaration visible within a\n  /// context does not transfer ownership of a declaration, and a\n  /// declaration can be visible in many contexts that aren't its\n  /// lexical context.\n  ///\n  /// If D is a redeclaration of an existing declaration that is\n  /// visible from this context, as determined by\n  /// NamedDecl::declarationReplaces, the previous declaration will be\n  /// replaced with D.\n  void makeDeclVisibleInContext(NamedDecl *D);\n\n  /// all_lookups_iterator - An iterator that provides a view over the results\n  /// of looking up every possible name.\n  class all_lookups_iterator;\n\n  using lookups_range = llvm::iterator_range<all_lookups_iterator>;\n\n  lookups_range lookups() const;\n  // Like lookups(), but avoids loading external declarations.\n  // If PreserveInternalState, avoids building lookup data structures too.\n  lookups_range noload_lookups(bool PreserveInternalState) const;\n\n  /// Iterators over all possible lookups within this context.\n  all_lookups_iterator lookups_begin() const;\n  all_lookups_iterator lookups_end() const;\n\n  /// Iterators over all possible lookups within this context that are\n  /// currently loaded; don't attempt to retrieve anything from an external\n  /// source.\n  all_lookups_iterator noload_lookups_begin() const;\n  all_lookups_iterator noload_lookups_end() const;\n\n  struct udir_iterator;\n\n  using udir_iterator_base =\n      llvm::iterator_adaptor_base<udir_iterator, lookup_iterator,\n                                  typename lookup_iterator::iterator_category,\n                                  UsingDirectiveDecl *>;\n\n  struct udir_iterator : udir_iterator_base {\n    udir_iterator(lookup_iterator I) : udir_iterator_base(I) {}\n\n    UsingDirectiveDecl *operator*() const;\n  };\n\n  using udir_range = llvm::iterator_range<udir_iterator>;\n\n  udir_range using_directives() const;\n\n  // These are all defined in DependentDiagnostic.h.\n  class ddiag_iterator;\n\n  using ddiag_range = llvm::iterator_range<DeclContext::ddiag_iterator>;\n\n  inline ddiag_range ddiags() const;\n\n  // Low-level accessors\n\n  /// Mark that there are external lexical declarations that we need\n  /// to include in our lookup table (and that are not available as external\n  /// visible lookups). These extra lookup results will be found by walking\n  /// the lexical declarations of this context. This should be used only if\n  /// setHasExternalLexicalStorage() has been called on any decl context for\n  /// which this is the primary context.\n  void setMustBuildLookupTable() {\n    assert(this == getPrimaryContext() &&\n           \"should only be called on primary context\");\n    DeclContextBits.HasLazyExternalLexicalLookups = true;\n  }\n\n  /// Retrieve the internal representation of the lookup structure.\n  /// This may omit some names if we are lazily building the structure.\n  StoredDeclsMap *getLookupPtr() const { return LookupPtr; }\n\n  /// Ensure the lookup structure is fully-built and return it.\n  StoredDeclsMap *buildLookup();\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are lexically in this context.\n  bool hasExternalLexicalStorage() const {\n    return DeclContextBits.ExternalLexicalStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations lexically in this context.\n  void setHasExternalLexicalStorage(bool ES = true) const {\n    DeclContextBits.ExternalLexicalStorage = ES;\n  }\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are visible in this context.\n  bool hasExternalVisibleStorage() const {\n    return DeclContextBits.ExternalVisibleStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations visible in this context.\n  void setHasExternalVisibleStorage(bool ES = true) const {\n    DeclContextBits.ExternalVisibleStorage = ES;\n    if (ES && LookupPtr)\n      DeclContextBits.NeedToReconcileExternalVisibleStorage = true;\n  }\n\n  /// Determine whether the given declaration is stored in the list of\n  /// declarations lexically within this context.\n  bool isDeclInLexicalTraversal(const Decl *D) const {\n    return D && (D->NextInContextAndBits.getPointer() || D == FirstDecl ||\n                 D == LastDecl);\n  }\n\n  void setUseQualifiedLookup(bool use = true) const {\n    DeclContextBits.UseQualifiedLookup = use;\n  }\n\n  bool shouldUseQualifiedLookup() const {\n    return DeclContextBits.UseQualifiedLookup;\n  }\n\n  static bool classof(const Decl *D);\n  static bool classof(const DeclContext *D) { return true; }\n\n  void dumpAsDecl() const;\n  void dumpAsDecl(const ASTContext *Ctx) const;\n  void dumpDeclContext() const;\n  void dumpLookups() const;\n  void dumpLookups(llvm::raw_ostream &OS, bool DumpDecls = false,\n                   bool Deserialize = false) const;\n\nprivate:\n  /// Whether this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  bool hasNeedToReconcileExternalVisibleStorage() const {\n    return DeclContextBits.NeedToReconcileExternalVisibleStorage;\n  }\n\n  /// State that this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  void setNeedToReconcileExternalVisibleStorage(bool Need = true) const {\n    DeclContextBits.NeedToReconcileExternalVisibleStorage = Need;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyLocalLexicalLookups() const {\n    return DeclContextBits.HasLazyLocalLexicalLookups;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyLocalLexicalLookups(bool HasLLLL = true) const {\n    DeclContextBits.HasLazyLocalLexicalLookups = HasLLLL;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyExternalLexicalLookups() const {\n    return DeclContextBits.HasLazyExternalLexicalLookups;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyExternalLexicalLookups(bool HasLELL = true) const {\n    DeclContextBits.HasLazyExternalLexicalLookups = HasLELL;\n  }\n\n  void reconcileExternalVisibleStorage() const;\n  bool LoadLexicalDeclsFromExternalStorage() const;\n\n  StoredDeclsMap *CreateStoredDeclsMap(ASTContext &C) const;\n\n  void loadLazyLocalLexicalLookups();\n  void buildLookupImpl(DeclContext *DCtx, bool Internal);\n  void makeDeclVisibleInContextWithFlags(NamedDecl *D, bool Internal,\n                                         bool Rediscoverable);\n  void makeDeclVisibleInContextImpl(NamedDecl *D, bool Internal);\n}",
  "id": "BLOCK-CPP-08326",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclBase.h",
  "source_line": 1409,
  "validation_status": "validated"
}