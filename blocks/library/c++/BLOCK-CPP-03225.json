{
  "code": "#include \"time_zone_impl.h\"\n#include <deque>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include \"absl/base/config.h\"\n#include \"time_zone_fixed.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03225_execute() {\n    {\n\nnamespace {\n\n// time_zone::Impls are linked into a map to support fast lookup by name.\nusing TimeZoneImplByName =\n    std::unordered_map<std::string, const time_zone::Impl*>;\nTimeZoneImplByName* time_zone_map = nullptr;\n\n// Mutual exclusion for time_zone_map.\nstd::mutex& TimeZoneMutex() {\n  // This mutex is intentionally \"leaked\" to avoid the static deinitialization\n  // order fiasco (std::mutex's destructor is not trivial on many platforms).\n  static std::mutex* time_zone_mutex = new std::mutex;\n  return *time_zone_mutex;\n}\n\n}  // namespace\n\ntime_zone time_zone::Impl::UTC() { return time_zone(UTCImpl()); }\n\nbool time_zone::Impl::LoadTimeZone(const std::string& name, time_zone* tz) {\n  const Impl* const utc_impl = UTCImpl();\n\n  // Check for UTC (which is never a key in time_zone_map).\n  auto offset = seconds::zero();\n  if (FixedOffsetFromName(name, &offset) && offset == seconds::zero()) {\n    *tz = time_zone(utc_impl);\n    return true;\n  }\n\n  // Check whether the time zone has already been loaded.\n  {\n    std::lock_guard<std::mutex> lock(TimeZoneMutex());\n    if (time_zone_map != nullptr) {\n      TimeZoneImplByName::const_iterator itr = time_zone_map->find(name);\n      if (itr != time_zone_map->end()) {\n        *tz = time_zone(itr->second);\n        return itr->second != utc_impl;\n      }\n    }\n  }\n\n  // Load the new time zone (outside the lock).\n  std::unique_ptr<const Impl> new_impl(new Impl(name));\n\n  // Add the new time zone to the map.\n  std::lock_guard<std::mutex> lock(TimeZoneMutex());\n  if (time_zone_map == nullptr) time_zone_map = new TimeZoneImplByName;\n  const Impl*& impl = (*time_zone_map)[name];\n  if (impl == nullptr) {  // this thread won any load race\n    impl = new_impl->zone_ ? new_impl.release() : utc_impl;\n  }\n  *tz = time_zone(impl);\n  return impl != utc_impl;\n}\n\nvoid time_zone::Impl::ClearTimeZoneMapTestOnly() {\n  std::lock_guard<std::mutex> lock(TimeZoneMutex());\n  if (time_zone_map != nullptr) {\n    // Existing time_zone::Impl* entries are in the wild, so we can't delete\n    // them. Instead, we move them to a private container, where they are\n    // logically unreachable but not \"leaked\".  Future requests will result\n    // in reloading the data.\n    static auto* cleared = new std::deque<const time_zone::Impl*>;\n    for (const auto& element : *time_zone_map) {\n      cleared->push_back(element.second);\n    }\n    time_zone_map->clear();\n  }\n}\n\ntime_zone::Impl::Impl() : name_(\"UTC\"), zone_(TimeZoneIf::UTC()) {}\n\ntime_zone::Impl::Impl(const std::string& name)\n    : name_(name), zone_(TimeZoneIf::Make(name_)) {}\n\nconst time_zone::Impl* time_zone::Impl::UTCImpl() {\n  static const Impl* utc_impl = new Impl;\n  return utc_impl;\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03225",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_impl.cc",
  "source_line": 30,
  "validation_status": "validated"
}