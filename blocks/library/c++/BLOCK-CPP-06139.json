{
  "code": "#include <cassert>\n#include <iostream>\n#include \"absl/strings/internal/cord_internal.h\"\n#include \"absl/strings/internal/cord_rep_btree.h\"\n\nusing namespace absl;\nusing namespace cord_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06139_execute() {\n    {\n public:\n  // The logical position as returned by the Seek() and Skip() functions.\n  // Returns the current leaf edge for the desired seek or skip position and\n  // the offset of that position inside that edge.\n  struct Position {\n    CordRep* edge;\n    size_t offset;\n  };\n\n  // The read result as returned by the Read() function.\n  // `tree` contains the resulting tree which is identical to the result\n  // of calling CordRepBtree::SubTree(...) on the tree being navigated.\n  // `n` contains the number of bytes used from the last navigated to\n  // edge of the tree.\n  struct ReadResult {\n    CordRep* tree;\n    size_t n;\n  };\n\n  // Returns true if this instance is not empty.\n  explicit operator bool() const;\n\n  // Returns the tree for this instance or nullptr if empty.\n  CordRepBtree* btree() const;\n\n  // Returns the data edge of the current position.\n  // Requires this instance to not be empty.\n  CordRep* Current() const;\n\n  // Resets this navigator to `tree`, returning the first data edge in the tree.\n  CordRep* InitFirst(CordRepBtree* tree);\n\n  // Resets this navigator to `tree`, returning the last data edge in the tree.\n  CordRep* InitLast(CordRepBtree* tree);\n\n  // Resets this navigator to `tree` returning the data edge at position\n  // `offset` and the relative offset of `offset` into that data edge.\n  // Returns `Position.edge = nullptr` if the provided offset is greater\n  // than or equal to the length of the tree, in which case the state of\n  // the navigator instance remains unchanged.\n  Position InitOffset(CordRepBtree* tree, size_t offset);\n\n  // Navigates to the next data edge.\n  // Returns the next data edge or nullptr if there is no next data edge, in\n  // which case the current position remains unchanged.\n  CordRep* Next();\n\n  // Navigates to the previous data edge.\n  // Returns the previous data edge or nullptr if there is no previous data\n  // edge, in which case the current position remains unchanged.\n  CordRep* Previous();\n\n  // Navigates to the data edge at position `offset`. Returns the navigated to\n  // data edge in `Position.edge` and the relative offset of `offset` into that\n  // data edge in `Position.offset`. Returns `Position.edge = nullptr` if the\n  // provide offset is greater than or equal to the tree's length.\n  Position Seek(size_t offset);\n\n  // Reads `n` bytes of data starting at offset `edge_offset` of the current\n  // data edge, and returns the result in `ReadResult.tree`. `ReadResult.n`\n  // contains the 'bytes used` from the last / current data edge in the tree.\n  // This allows users that mix regular navigation (using string views) and\n  // 'read into cord' navigation to keep track of the current state, and which\n  // bytes have been consumed from a navigator.\n  // This function returns `ReadResult.tree = nullptr` if the requested length\n  // exceeds the length of the tree starting at the current data edge.\n  ReadResult Read(size_t edge_offset, size_t n);\n\n  // Skips `n` bytes forward from the current data edge, returning the navigated\n  // to data edge in `Position.edge` and `Position.offset` containing the offset\n  // inside that data edge. Note that the state of the navigator is left\n  // unchanged if `n` is smaller than the length of the current data edge.\n  Position Skip(size_t n);\n\n  // Resets this instance to the default / empty state.\n  void Reset();\n\n private:\n  // Slow path for Next() if Next() reached the end of a leaf node. Backtracks\n  // up the stack until it finds a node that has a 'next' position available,\n  // and then does a 'front dive' towards the next leaf node.\n  CordRep* NextUp();\n\n  // Slow path for Previous() if Previous() reached the beginning of a leaf\n  // node. Backtracks up the stack until it finds a node that has a 'previous'\n  // position available, and then does a 'back dive' towards the previous leaf\n  // node.\n  CordRep* PreviousUp();\n\n  // Generic implementation of InitFirst() and InitLast().\n  template <CordRepBtree::EdgeType edge_type>\n  CordRep* Init(CordRepBtree* tree);\n\n  // `height_` contains the height of the current tree, or -1 if empty.\n  int height_ = -1;\n\n  // `index_` and `node_` contain the navigation state as the 'path' to the\n  // current data edge which is at `node_[0]->Edge(index_[0])`. The contents\n  // of these are undefined until the instance is initialized (`height_ >= 0`).\n  uint8_t index_[CordRepBtree::kMaxDepth];\n  CordRepBtree* node_[CordRepBtree::kMaxDepth];\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06139",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree_navigator.h",
  "source_line": 46,
  "validation_status": "validated"
}