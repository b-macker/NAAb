{
  "code": "#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <optional>\n\nusing namespace clang;\nusing namespace detail;\nusing namespace detail;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-15699_execute() {\n    {\n///     int x =  f(f(1))  ));  // Look at the parenthesis!\n///   //         ^~~~~~^ is the substituted range\n///   // Substituted text is \"f(f(1))\"\n///   // Expanded text is \"((1,bar(),1,bar(),1\"\n///   }\n/// \\endcode\n/// \\remark Currently we don't respect the whitespaces between expanded tokens,\n///         so the output for this example might differ from the -E compiler\n///         invocation.\n/// \\remark All whitespaces are consumed while constructing the expansion.\n///         After all identifier a single space inserted to produce a valid C\n///         code even if identifier follows an other identifiers such as\n///         variable declarations.\n/// \\remark MacroExpansionContext object must outlive the Preprocessor\n///         parameter.\nclass MacroExpansionContext {\npublic:\n  /// Creates a MacroExpansionContext.\n  /// \\remark You must call registerForPreprocessor to set the required\n  ///         onTokenLexed callback and the PPCallbacks.\n  explicit MacroExpansionContext(const LangOptions &LangOpts);\n\n  /// Register the necessary callbacks to the Preprocessor to record the\n  /// expansion events and the generated tokens. Must ensure that this object\n  /// outlives the given Preprocessor.\n  void registerForPreprocessor(Preprocessor &PP);\n\n  /// \\param MacroExpansionLoc Must be the expansion location of a macro.\n  /// \\return The textual representation of the token sequence which was\n  ///         substituted in place of the macro after the preprocessing.\n  ///         If no macro was expanded at that location, returns std::nullopt.\n  std::optional<StringRef>\n  getExpandedText(SourceLocation MacroExpansionLoc) const;\n\n  /// \\param MacroExpansionLoc Must be the expansion location of a macro.\n  /// \\return The text from the original source code which were substituted by\n  ///         the macro expansion chain from the given location.\n  ///         If no macro was expanded at that location, returns std::nullopt.\n  std::optional<StringRef>\n  getOriginalText(SourceLocation MacroExpansionLoc) const;\n\n  LLVM_DUMP_METHOD void dumpExpansionRangesToStream(raw_ostream &OS) const;\n  LLVM_DUMP_METHOD void dumpExpandedTextsToStream(raw_ostream &OS) const;\n  LLVM_DUMP_METHOD void dumpExpansionRanges() const;\n  LLVM_DUMP_METHOD void dumpExpandedTexts() const;\n\nprivate:\n  friend class detail::MacroExpansionRangeRecorder;\n  using MacroExpansionText = SmallString<40>;\n  using ExpansionMap = llvm::DenseMap<SourceLocation, MacroExpansionText>;\n  using ExpansionRangeMap = llvm::DenseMap<SourceLocation, SourceLocation>;\n\n  /// Associates the textual representation of the expanded tokens at the given\n  /// macro expansion location.\n  ExpansionMap ExpandedTokens;\n\n  /// Tracks which source location was the last affected by any macro\n  /// substitution starting from a given macro expansion location.\n  ExpansionRangeMap ExpansionRanges;\n\n  Preprocessor *PP = nullptr;\n  SourceManager *SM = nullptr;\n  const LangOptions &LangOpts;\n\n  /// This callback is called by the preprocessor.\n  /// It stores the textual representation of the expanded token sequence for a\n  /// macro expansion location.\n  void onTokenLexed(const Token &Tok);\n};\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-15699",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/MacroExpansionContext.h",
  "source_line": 57,
  "validation_status": "validated"
}