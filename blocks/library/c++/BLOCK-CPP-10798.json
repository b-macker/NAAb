{
  "code": "{\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The replacement expression.\n  Stmt *Replacement;\n\n  /// The associated declaration and a flag indicating if it was a reference\n  /// parameter. For class NTTPs, we can't determine that based on the value\n  /// category alone.\n  llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndRef;\n\n  unsigned Index : 15;\n  unsigned PackIndex : 16;\n\n  explicit SubstNonTypeTemplateParmExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmExpr(QualType Ty, ExprValueKind ValueKind,\n                               SourceLocation Loc, Expr *Replacement,\n                               Decl *AssociatedDecl, unsigned Index,\n                               std::optional<unsigned> PackIndex, bool RefParam)\n      : Expr(SubstNonTypeTemplateParmExprClass, Ty, ValueKind, OK_Ordinary),\n        Replacement(Replacement),\n        AssociatedDeclAndRef(AssociatedDecl, RefParam), Index(Index),\n        PackIndex(PackIndex ? *PackIndex + 1 : 0) {\n    assert(AssociatedDecl != nullptr);\n    SubstNonTypeTemplateParmExprBits.NameLoc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  SourceLocation getNameLoc() const {\n    return SubstNonTypeTemplateParmExprBits.NameLoc;\n  }\n  SourceLocation getBeginLoc() const { return getNameLoc(); }\n  SourceLocation getEndLoc() const { return getNameLoc(); }\n\n  Expr *getReplacement() const { return cast<Expr>(Replacement); }\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDeclAndRef.getPointer(); }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameter()->getIndex()`.\n  unsigned getIndex() const { return Index; }\n\n  std::optional<unsigned> getPackIndex() const {\n    if (PackIndex == 0)\n      return std::nullopt;\n    return PackIndex - 1;\n  }\n\n  NonTypeTemplateParmDecl *getParameter() const;\n\n  bool isReferenceParameter() const { return AssociatedDeclAndRef.getInt(); }\n\n  /// Determine the substituted type of the template parameter.\n  QualType getParameterType(const ASTContext &Ctx) const;\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == SubstNonTypeTemplateParmExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Replacement, &Replacement + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Replacement, &Replacement + 1);\n  }\n}",
  "id": "BLOCK-CPP-10798",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 4328,
  "validation_status": "validated"
}