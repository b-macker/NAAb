{
  "code": "{\n///   static int b;\n/// #pragma omp allocate(b)\n/// };\n/// \\endcode\n///\nclass OMPAllocateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPAllocateDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPAllocate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::ArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::MutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPAllocateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<Expr *> VL,\n                                 ArrayRef<OMPClause *> CL);\n  static OMPAllocateDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned NVars, unsigned NClauses);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPAllocate; }\n};\n\n}",
  "id": "BLOCK-CPP-09140",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclOpenMP.h",
  "source_line": 467,
  "validation_status": "validated"
}