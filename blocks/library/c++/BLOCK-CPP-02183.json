{
  "code": "{\n  // Bail if num or den is an infinity.\n  if (time_internal::IsInfiniteDuration(num) ||\n      time_internal::IsInfiniteDuration(den))\n    return false;\n\n  int64_t num_hi = time_internal::GetRepHi(num);\n  uint32_t num_lo = time_internal::GetRepLo(num);\n  int64_t den_hi = time_internal::GetRepHi(den);\n  uint32_t den_lo = time_internal::GetRepLo(den);\n\n  if (den_hi == 0 && den_lo == kTicksPerNanosecond) {\n    // Dividing by 1ns\n    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000000) {\n      *q = num_hi * 1000000000 + num_lo / kTicksPerNanosecond;\n      *rem = time_internal::MakeDuration(0, num_lo % den_lo);\n      return true;\n    }\n  } else if (den_hi == 0 && den_lo == 100 * kTicksPerNanosecond) {\n    // Dividing by 100ns (common when converting to Universal time)\n    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 10000000) {\n      *q = num_hi * 10000000 + num_lo / (100 * kTicksPerNanosecond);\n      *rem = time_internal::MakeDuration(0, num_lo % den_lo);\n      return true;\n    }\n  } else if (den_hi == 0 && den_lo == 1000 * kTicksPerNanosecond) {\n    // Dividing by 1us\n    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000) {\n      *q = num_hi * 1000000 + num_lo / (1000 * kTicksPerNanosecond);\n      *rem = time_internal::MakeDuration(0, num_lo % den_lo);\n      return true;\n    }\n  } else if (den_hi == 0 && den_lo == 1000000 * kTicksPerNanosecond) {\n    // Dividing by 1ms\n    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000) {\n      *q = num_hi * 1000 + num_lo / (1000000 * kTicksPerNanosecond);\n      *rem = time_internal::MakeDuration(0, num_lo % den_lo);\n      return true;\n    }\n  } else if (den_hi > 0 && den_lo == 0) {\n    // Dividing by positive multiple of 1s\n    if (num_hi >= 0) {\n      if (den_hi == 1) {\n        *q = num_hi;\n        *rem = time_internal::MakeDuration(0, num_lo);\n        return true;\n      }\n      *q = num_hi / den_hi;\n      *rem = time_internal::MakeDuration(num_hi % den_hi, num_lo);\n      return true;\n    }\n    if (num_lo != 0) {\n      num_hi += 1;\n    }\n    int64_t quotient = num_hi / den_hi;\n    int64_t rem_sec = num_hi % den_hi;\n    if (rem_sec > 0) {\n      rem_sec -= den_hi;\n      quotient += 1;\n    }\n    if (num_lo != 0) {\n      rem_sec -= 1;\n    }\n    *q = quotient;\n    *rem = time_internal::MakeDuration(rem_sec, num_lo);\n    return true;\n  }\n\n  return false;\n}",
  "id": "BLOCK-CPP-02183",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/duration.cc",
  "source_line": 271,
  "validation_status": "validated"
}