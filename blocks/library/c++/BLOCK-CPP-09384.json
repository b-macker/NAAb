{
  "code": "{\n  ///   template<template<Types> class...Templates> struct Inner;\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Templates is a pack expansion, which expands the\n  /// pack \\c Types. When \\c Types is supplied with template arguments by\n  /// instantiating \\c Outer, the instantiation of \\c Templates is an expanded\n  /// parameter pack.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion template parameters in\n  /// an expanded parameter pack.\n  unsigned getNumExpansionTemplateParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedParams;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  TemplateParameterList *getExpansionTemplateParameters(unsigned I) const {\n    assert(I < NumExpandedParams && \"Out-of-range expansion type index\");\n    return getTrailingObjects<TemplateParameterList *>()[I];\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  const TemplateArgumentLoc &getDefaultArgument() const {\n    static const TemplateArgumentLoc NoneLoc;\n    return DefaultArgument.isSet() ? *DefaultArgument.get() : NoneLoc;\n  }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(const ASTContext &C,\n                          const TemplateArgumentLoc &DefArg);\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTemplateParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    SourceLocation End = getLocation();\n    if (hasDefaultArgument() && !defaultArgumentWasInherited())\n      End = getDefaultArgument().getSourceRange().getEnd();\n    return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTemplateParm; }\n}",
  "id": "BLOCK-CPP-09384",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 1715,
  "validation_status": "validated"
}