{
  "code": "#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/ASTMatchers/ASTMatchersInternal.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include <memory>\n#include <optional>\n#include <vector>\n\nusing namespace clang;\nusing namespace ast_matchers;\nusing namespace dynamic;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21302_execute() {\n    {\npublic:\n  VariantValue() : Type(VT_Nothing) {}\n\n  VariantValue(const VariantValue &Other);\n  ~VariantValue();\n  VariantValue &operator=(const VariantValue &Other);\n\n  /// Specific constructors for each supported type.\n  VariantValue(bool Boolean);\n  VariantValue(double Double);\n  VariantValue(unsigned Unsigned);\n  VariantValue(StringRef String);\n  VariantValue(ASTNodeKind NodeKind);\n  VariantValue(const VariantMatcher &Matchers);\n\n  /// Constructs an \\c unsigned value (disambiguation from bool).\n  VariantValue(int Signed) : VariantValue(static_cast<unsigned>(Signed)) {}\n\n  /// Returns true iff this is not an empty value.\n  explicit operator bool() const { return hasValue(); }\n  bool hasValue() const { return Type != VT_Nothing; }\n\n  /// Boolean value functions.\n  bool isBoolean() const;\n  bool getBoolean() const;\n  void setBoolean(bool Boolean);\n\n  /// Double value functions.\n  bool isDouble() const;\n  double getDouble() const;\n  void setDouble(double Double);\n\n  /// Unsigned value functions.\n  bool isUnsigned() const;\n  unsigned getUnsigned() const;\n  void setUnsigned(unsigned Unsigned);\n\n  /// String value functions.\n  bool isString() const;\n  const std::string &getString() const;\n  void setString(StringRef String);\n\n  bool isNodeKind() const;\n  const ASTNodeKind &getNodeKind() const;\n  void setNodeKind(ASTNodeKind NodeKind);\n\n  /// Matcher value functions.\n  bool isMatcher() const;\n  const VariantMatcher &getMatcher() const;\n  void setMatcher(const VariantMatcher &Matcher);\n\n  /// Determines if the contained value can be converted to \\p Kind.\n  ///\n  /// \\param Kind the requested destination type.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion.\n  bool isConvertibleTo(ArgKind Kind, unsigned* Specificity) const;\n\n  /// Determines if the contained value can be converted to any kind\n  /// in \\p Kinds.\n  ///\n  /// \\param Kinds the requested destination types.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion. It is the maximum specificity of all the possible\n  ///   conversions.\n  bool isConvertibleTo(ArrayRef<ArgKind> Kinds, unsigned *Specificity) const;\n\n  /// String representation of the type of the value.\n  std::string getTypeAsString() const;\n\nprivate:\n  void reset();\n\n  /// All supported value types.\n  enum ValueType {\n    VT_Nothing,\n    VT_Boolean,\n    VT_Double,\n    VT_Unsigned,\n    VT_String,\n    VT_Matcher,\n    VT_NodeKind\n  };\n\n  /// All supported value types.\n  union AllValues {\n    unsigned Unsigned;\n    double Double;\n    bool Boolean;\n    std::string *String;\n    VariantMatcher *Matcher;\n    ASTNodeKind *NodeKind;\n  };\n\n  ValueType Type;\n  AllValues Value;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21302",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/Dynamic/VariantValue.h",
  "source_line": 254,
  "validation_status": "validated"
}