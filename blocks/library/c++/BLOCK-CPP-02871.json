{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace {\n\n// ParseFloat<10> will read the first 19 significant digits of the mantissa.\n// This number was chosen for multiple reasons.\n//\n// (a) First, for whatever integer type we choose to represent the mantissa, we\n// want to choose the largest possible number of decimal digits for that integer\n// type.  We are using uint64_t, which can express any 19-digit unsigned\n// integer.\n//\n// (b) Second, we need to parse enough digits that the binary value of any\n// mantissa we capture has more bits of resolution than the mantissa\n// representation in the target float.  Our algorithm requires at least 3 bits\n// of headway, but 19 decimal digits give a little more than that.\n//\n// The following static assertions verify the above comments:\nconstexpr int kDecimalMantissaDigitsMax = 19;\n\nstatic_assert(std::numeric_limits<uint64_t>::digits10 ==\n                  kDecimalMantissaDigitsMax,\n              \"(a) above\");\n\n// IEEE doubles, which we assume in Abseil, have 53 binary bits of mantissa.\nstatic_assert(std::numeric_limits<double>::is_iec559, \"IEEE double assumed\");\nstatic_assert(std::numeric_limits<double>::radix == 2, \"IEEE double fact\");\nstatic_assert(std::numeric_limits<double>::digits == 53, \"IEEE double fact\");\n\n// The lowest valued 19-digit decimal mantissa we can read still contains\n// sufficient information to reconstruct a binary mantissa.\nstatic_assert(1000000000000000000u > (uint64_t{1} << (53 + 3)), \"(b) above\");\n\n// ParseFloat<16> will read the first 15 significant digits of the mantissa.\n//\n// Because a base-16-to-base-2 conversion can be done exactly, we do not need\n// to maximize the number of scanned hex digits to improve our conversion.  What\n// is required is to scan two more bits than the mantissa can represent, so that\n// we always round correctly.\n//\n// (One extra bit does not suffice to perform correct rounding, since a number\n// exactly halfway between two representable floats has unique rounding rules,\n// so we need to differentiate between a \"halfway between\" number and a \"closer\n// to the larger value\" number.)\nconstexpr int kHexadecimalMantissaDigitsMax = 15;\n\n// The minimum number of significant bits that will be read from\n// kHexadecimalMantissaDigitsMax hex digits.  We must subtract by three, since\n// the most significant digit can be a \"1\", which only contributes a single\n// significant bit.\nconstexpr int kGuaranteedHexadecimalMantissaBitPrecision =\n    4 * kHexadecimalMantissaDigitsMax - 3;\n\nstatic_assert(kGuaranteedHexadecimalMantissaBitPrecision >\n                  std::numeric_limits<double>::digits + 2,\n              \"kHexadecimalMantissaDigitsMax too small\");\n\n// We also impose a limit on the number of significant digits we will read from\n// an exponent, to avoid having to deal with integer overflow.  We use 9 for\n// this purpose.\n//\n// If we read a 9 digit exponent, the end result of the conversion will\n// necessarily be infinity or zero, depending on the sign of the exponent.\n// Therefore we can just drop extra digits on the floor without any extra\n// logic.\nconstexpr int kDecimalExponentDigitsMax = 9;\nstatic_assert(std::numeric_limits<int>::digits10 >= kDecimalExponentDigitsMax,\n              \"int type too small\");\n\n// To avoid incredibly large inputs causing integer overflow for our exponent,\n// we impose an arbitrary but very large limit on the number of significant\n// digits we will accept.  The implementation refuses to match a string with\n// more consecutive significant mantissa digits than this.\nconstexpr int kDecimalDigitLimit = 50000000;\n\n// Corresponding limit for hexadecimal digit inputs.  This is one fourth the\n// amount of kDecimalDigitLimit, since each dropped hexadecimal digit requires\n// a binary exponent adjustment of 4.\nconstexpr int kHexadecimalDigitLimit = kDecimalDigitLimit / 4;\n\n// The largest exponent we can read is 999999999 (per\n// kDecimalExponentDigitsMax), and the largest exponent adjustment we can get\n// from dropped mantissa digits is 2 * kDecimalDigitLimit, and the sum of these\n// comfortably fits in an integer.\n//\n// We count kDecimalDigitLimit twice because there are independent limits for\n// numbers before and after the decimal point.  (In the case where there are no\n// significant digits before the decimal point, there are independent limits for\n// post-decimal-point leading zeroes and for significant digits.)\nstatic_assert(999999999 + 2 * kDecimalDigitLimit <\n                  std::numeric_limits<int>::max(),\n              \"int type too small\");\nstatic_assert(999999999 + 2 * (4 * kHexadecimalDigitLimit) <\n                  std::numeric_limits<int>::max(),\n              \"int type too small\");\n\n// Returns true if the provided bitfield allows parsing an exponent value\n// (e.g., \"1.5e100\").\nbool AllowExponent(chars_format flags) {\n  bool fixed = (flags & chars_format::fixed) == chars_format::fixed;\n  bool scientific =\n      (flags & chars_format::scientific) == chars_format::scientific;\n  return scientific || !fixed;\n}\n\n// Returns true if the provided bitfield requires an exponent value be present.\nbool RequireExponent(chars_format flags) {\n  bool fixed = (flags & chars_format::fixed) == chars_format::fixed;\n  bool scientific =\n      (flags & chars_format::scientific) == chars_format::scientific;\n  return scientific && !fixed;\n}\n\nconst int8_t kAsciiToInt[256] = {\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,  1,  2,  3,  4,  5,  6,  7,  8,\n    9,  -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\n// Returns true if `ch` is a digit in the given base\ntemplate <int base>\nbool IsDigit(char ch);\n\n// Converts a valid `ch` to its digit value in the given base.\ntemplate <int base>\nunsigned ToDigit(char ch);\n\n// Returns true if `ch` is the exponent delimiter for the given base.\ntemplate <int base>\nbool IsExponentCharacter(char ch);\n\n// Returns the maximum number of significant digits we will read for a float\n// in the given base.\ntemplate <int base>\nconstexpr int MantissaDigitsMax();\n\n// Returns the largest consecutive run of digits we will accept when parsing a\n// number in the given base.\ntemplate <int base>\nconstexpr int DigitLimit();\n\n// Returns the amount the exponent must be adjusted by for each dropped digit.\n// (For decimal this is 1, since the digits are in base 10 and the exponent base\n// is also 10, but for hexadecimal this is 4, since the digits are base 16 but\n// the exponent base is 2.)\ntemplate <int base>\nconstexpr int DigitMagnitude();\n\ntemplate <>\nbool IsDigit<10>(char ch) {\n  return ch >= '0' && ch <= '9';\n}\ntemplate <>\nbool IsDigit<16>(char ch) {\n  return kAsciiToInt[static_cast<unsigned char>(ch)] >= 0;\n}\n\ntemplate <>\nunsigned ToDigit<10>(char ch) {\n  return static_cast<unsigned>(ch - '0');\n}\ntemplate <>\nunsigned ToDigit<16>(char ch) {\n  return static_cast<unsigned>(kAsciiToInt[static_cast<unsigned char>(ch)]);\n}\n\ntemplate <>\nbool IsExponentCharacter<10>(char ch) {\n  return ch == 'e' || ch == 'E';\n}\n\ntemplate <>\nbool IsExponentCharacter<16>(char ch) {\n  return ch == 'p' || ch == 'P';\n}\n\ntemplate <>\nconstexpr int MantissaDigitsMax<10>() {\n  return kDecimalMantissaDigitsMax;\n}\ntemplate <>\nconstexpr int MantissaDigitsMax<16>() {\n  return kHexadecimalMantissaDigitsMax;\n}\n\ntemplate <>\nconstexpr int DigitLimit<10>() {\n  return kDecimalDigitLimit;\n}\ntemplate <>\nconstexpr int DigitLimit<16>() {\n  return kHexadecimalDigitLimit;\n}\n\ntemplate <>\nconstexpr int DigitMagnitude<10>() {\n  return 1;\n}\ntemplate <>\nconstexpr int DigitMagnitude<16>() {\n  return 4;\n}\n\n// Reads decimal digits from [begin, end) into *out.  Returns the number of\n// digits consumed.\n//\n// After max_digits has been read, keeps consuming characters, but no longer\n// adjusts *out.  If a nonzero digit is dropped this way, *dropped_nonzero_digit\n// is set; otherwise, it is left unmodified.\n//\n// If no digits are matched, returns 0 and leaves *out unchanged.\n//\n// ConsumeDigits does not protect against overflow on *out; max_digits must\n// be chosen with respect to type T to avoid the possibility of overflow.\ntemplate <int base, typename T>\nint ConsumeDigits(const char* begin, const char* end, int max_digits, T* out,\n                  bool* dropped_nonzero_digit) {\n  if (base == 10) {\n    assert(max_digits <= std::numeric_limits<T>::digits10);\n  } else if (base == 16) {\n    assert(max_digits * 4 <= std::numeric_limits<T>::digits);\n  }\n  const char* const original_begin = begin;\n\n  // Skip leading zeros, but only if *out is zero.\n  // They don't cause an overflow so we don't have to count them for\n  // `max_digits`.\n  while (!*out && end != begin && *begin == '0') ++begin;\n\n  T accumulator = *out;\n  const char* significant_digits_end =\n      (end - begin > max_digits) ? begin + max_digits : end;\n  while (begin < significant_digits_end && IsDigit<base>(*begin)) {\n    // Do not guard against *out overflow; max_digits was chosen to avoid this.\n    // Do assert against it, to detect problems in debug builds.\n    auto digit = static_cast<T>(ToDigit<base>(*begin));\n    assert(accumulator * base >= accumulator);\n    accumulator *= base;\n    assert(accumulator + digit >= accumulator);\n    accumulator += digit;\n    ++begin;\n  }\n  bool dropped_nonzero = false;\n  while (begin < end && IsDigit<base>(*begin)) {\n    dropped_nonzero = dropped_nonzero || (*begin != '0');\n    ++begin;\n  }\n  if (dropped_nonzero && dropped_nonzero_digit != nullptr) {\n    *dropped_nonzero_digit = true;\n  }\n  *out = accumulator;\n  return static_cast<int>(begin - original_begin);\n}\n\n// Returns true if `v` is one of the chars allowed inside parentheses following\n// a NaN.\nbool IsNanChar(char v) {\n  return (v == '_') || (v >= '0' && v <= '9') || (v >= 'a' && v <= 'z') ||\n         (v >= 'A' && v <= 'Z');\n}\n\n// Checks the range [begin, end) for a strtod()-formatted infinity or NaN.  If\n// one is found, sets `out` appropriately and returns true.\nbool ParseInfinityOrNan(const char* begin, const char* end,\n                        strings_internal::ParsedFloat* out) {\n  if (end - begin < 3) {\n    return false;\n  }\n  switch (*begin) {\n    case 'i':\n    case 'I': {\n      // An infinity string consists of the characters \"inf\" or \"infinity\",\n      // case insensitive.\n      if (strings_internal::memcasecmp(begin + 1, \"nf\", 2) != 0) {\n        return false;\n      }\n      out->type = strings_internal::FloatType::kInfinity;\n      if (end - begin >= 8 &&\n          strings_internal::memcasecmp(begin + 3, \"inity\", 5) == 0) {\n        out->end = begin + 8;\n      } else {\n        out->end = begin + 3;\n      }\n      return true;\n    }\n    case 'n':\n    case 'N': {\n      // A NaN consists of the characters \"nan\", case insensitive, optionally\n      // followed by a parenthesized sequence of zero or more alphanumeric\n      // characters and/or underscores.\n      if (strings_internal::memcasecmp(begin + 1, \"an\", 2) != 0) {\n        return false;\n      }\n      out->type = strings_internal::FloatType::kNan;\n      out->end = begin + 3;\n      // NaN is allowed to be followed by a parenthesized string, consisting of\n      // only the characters [a-zA-Z0-9_].  Match that if it's present.\n      begin += 3;\n      if (begin < end && *begin == '(') {\n        const char* nan_begin = begin + 1;\n        while (nan_begin < end && IsNanChar(*nan_begin)) {\n          ++nan_begin;\n        }\n        if (nan_begin < end && *nan_begin == ')') {\n          // We found an extra NaN specifier range\n          out->subrange_begin = begin + 1;\n          out->subrange_end = nan_begin;\n          out->end = nan_begin + 1;\n        }\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}\n}  // namespace\n\nnamespace strings_internal {\n\ntemplate <int base>\nstrings_internal::ParsedFloat ParseFloat(const char* begin, const char* end,\n                                         chars_format format_flags) {\n  strings_internal::ParsedFloat result;\n\n  // Exit early if we're given an empty range.\n  if (begin == end) return result;\n\n  // Handle the infinity and NaN cases.\n  if (ParseInfinityOrNan(begin, end, &result)) {\n    return result;\n  }\n\n  const char* const mantissa_begin = begin;\n  while (begin < end && *begin == '0') {\n    ++begin;  // skip leading zeros\n  }\n  uint64_t mantissa = 0;\n\n  int exponent_adjustment = 0;\n  bool mantissa_is_inexact = false;\n  int pre_decimal_digits = ConsumeDigits<base>(\n      begin, end, MantissaDigitsMax<base>(), &mantissa, &mantissa_is_inexact);\n  begin += pre_decimal_digits;\n  int digits_left;\n  if (pre_decimal_digits >= DigitLimit<base>()) {\n    // refuse to parse pathological inputs\n    return result;\n  } else if (pre_decimal_digits > MantissaDigitsMax<base>()) {\n    // We dropped some non-fraction digits on the floor.  Adjust our exponent\n    // to compensate.\n    exponent_adjustment =\n        static_cast<int>(pre_decimal_digits - MantissaDigitsMax<base>());\n    digits_left = 0;\n  } else {\n    digits_left =\n        static_cast<int>(MantissaDigitsMax<base>() - pre_decimal_digits);\n  }\n  if (begin < end && *begin == '.') {\n    ++begin;\n    if (mantissa == 0) {\n      // If we haven't seen any nonzero digits yet, keep skipping zeros.  We\n      // have to adjust the exponent to reflect the changed place value.\n      const char* begin_zeros = begin;\n      while (begin < end && *begin == '0') {\n        ++begin;\n      }\n      int zeros_skipped = static_cast<int>(begin - begin_zeros);\n      if (zeros_skipped >= DigitLimit<base>()) {\n        // refuse to parse pathological inputs\n        return result;\n      }\n      exponent_adjustment -= static_cast<int>(zeros_skipped);\n    }\n    int post_decimal_digits = ConsumeDigits<base>(\n        begin, end, digits_left, &mantissa, &mantissa_is_inexact);\n    begin += post_decimal_digits;\n\n    // Since `mantissa` is an integer, each significant digit we read after\n    // the decimal point requires an adjustment to the exponent. \"1.23e0\" will\n    // be stored as `mantissa` == 123 and `exponent` == -2 (that is,\n    // \"123e-2\").\n    if (post_decimal_digits >= DigitLimit<base>()) {\n      // refuse to parse pathological inputs\n      return result;\n    } else if (post_decimal_digits > digits_left) {\n      exponent_adjustment -= digits_left;\n    } else {\n      exponent_adjustment -= post_decimal_digits;\n    }\n  }\n  // If we've found no mantissa whatsoever, this isn't a number.\n  if (mantissa_begin == begin) {\n    return result;\n  }\n  // A bare \".\" doesn't count as a mantissa either.\n  if (begin - mantissa_begin == 1 && *mantissa_begin == '.') {\n    return result;\n  }\n\n  if (mantissa_is_inexact) {\n    // We dropped significant digits on the floor.  Handle this appropriately.\n    if (base == 10) {\n      // If we truncated significant decimal digits, store the full range of the\n      // mantissa for future big integer math for exact rounding.\n      result.subrange_begin = mantissa_begin;\n      result.subrange_end = begin;\n    } else if (base == 16) {\n      // If we truncated hex digits, reflect this fact by setting the low\n      // (\"sticky\") bit.  This allows for correct rounding in all cases.\n      mantissa |= 1;\n    }\n  }\n  result.mantissa = mantissa;\n\n  const char* const exponent_begin = begin;\n  result.literal_exponent = 0;\n  bool found_exponent = false;\n  if (AllowExponent(format_flags) && begin < end &&\n      IsExponentCharacter<base>(*begin)) {\n    bool negative_exponent = false;\n    ++begin;\n    if (begin < end && *begin == '-') {\n      negative_exponent = true;\n      ++begin;\n    } else if (begin < end && *begin == '+') {\n      ++begin;\n    }\n    const char* const exponent_digits_begin = begin;\n    // Exponent is always expressed in decimal, even for hexadecimal floats.\n    begin += ConsumeDigits<10>(begin, end, kDecimalExponentDigitsMax,\n                               &result.literal_exponent, nullptr);\n    if (begin == exponent_digits_begin) {\n      // there were no digits where we expected an exponent.  We failed to read\n      // an exponent and should not consume the 'e' after all.  Rewind 'begin'.\n      found_exponent = false;\n      begin = exponent_begin;\n    } else {\n      found_exponent = true;\n      if (negative_exponent) {\n        result.literal_exponent = -result.literal_exponent;\n      }\n    }\n  }\n\n  if (!found_exponent && RequireExponent(format_flags)) {\n    // Provided flags required an exponent, but none was found.  This results\n    // in a failure to scan.\n    return result;\n  }\n\n  // Success!\n  result.type = strings_internal::FloatType::kNumber;\n  if (result.mantissa > 0) {\n    result.exponent = result.literal_exponent +\n                      (DigitMagnitude<base>() * exponent_adjustment);\n  } else {\n    result.exponent = 0;\n  }\n  result.end = begin;\n  return result;\n}\n\ntemplate ParsedFloat ParseFloat<10>(const char* begin, const char* end,\n                                    chars_format format_flags);\ntemplate ParsedFloat ParseFloat<16>(const char* begin, const char* end,\n                                    chars_format format_flags);\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02871",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/charconv_parse.cc",
  "source_line": 24,
  "validation_status": "validated"
}