{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n#ifdef ABSL_USES_STD_ORDERING\n\nusing std::partial_ordering;\nusing std::strong_ordering;\nusing std::weak_ordering;\n\n#else\n\nnamespace compare_internal {\n\nusing value_type = int8_t;\n\nclass OnlyLiteralZero {\n public:\n#if ABSL_HAVE_ATTRIBUTE(enable_if)\n  // On clang, we can avoid triggering modernize-use-nullptr by only enabling\n  // this overload when the value is a compile time integer constant equal to 0.\n  //\n  // In c++20, this could be a static_assert in a consteval function.\n  constexpr OnlyLiteralZero(int n)  // NOLINT\n      __attribute__((enable_if(n == 0, \"Only literal `0` is allowed.\"))) {}\n#else  // ABSL_HAVE_ATTRIBUTE(enable_if)\n  // Accept only literal zero since it can be implicitly converted to a pointer\n  // to member type. nullptr constants will be caught by the other constructor\n  // which accepts a nullptr_t.\n  //\n  // This constructor is not used for clang since it triggers\n  // modernize-use-nullptr.\n  constexpr OnlyLiteralZero(int OnlyLiteralZero::*) noexcept {}  // NOLINT\n#endif\n\n  // Fails compilation when `nullptr` or integral type arguments other than\n  // `int` are passed. This constructor doesn't accept `int` because literal `0`\n  // has type `int`. Literal `0` arguments will be implicitly converted to\n  // `std::nullptr_t` and accepted by the above constructor, while other `int`\n  // arguments will fail to be converted and cause compilation failure.\n  template <typename T, typename = typename std::enable_if<\n                            std::is_same<T, std::nullptr_t>::value ||\n                            (std::is_integral<T>::value &&\n                             !std::is_same<T, int>::value)>::type>\n  OnlyLiteralZero(T) {  // NOLINT\n    static_assert(sizeof(T) < 0, \"Only literal `0` is allowed.\");\n  }\n};\n\nenum class eq : value_type {\n  equal = 0,\n  equivalent = equal,\n  nonequal = 1,\n  nonequivalent = nonequal,\n};\n\nenum class ord : value_type { less = -1, greater = 1 };\n\nenum class ncmp : value_type { unordered = -127 };\n\n// Define macros to allow for creation or emulation of C++17 inline variables\n// based on whether the feature is supported. Note: we can't use\n// ABSL_INTERNAL_INLINE_CONSTEXPR here because the variables here are of\n// incomplete types so they need to be defined after the types are complete.\n#ifdef __cpp_inline_variables\n\n// A no-op expansion that can be followed by a semicolon at class level.\n#define ABSL_COMPARE_INLINE_BASECLASS_DECL(name) static_assert(true, \"\")\n\n#define ABSL_COMPARE_INLINE_SUBCLASS_DECL(type, name) \\\n  static const type name\n\n#define ABSL_COMPARE_INLINE_INIT(type, name, init) \\\n  inline constexpr type type::name(init)\n\n#else  // __cpp_inline_variables\n\n#define ABSL_COMPARE_INLINE_BASECLASS_DECL(name) \\\n  ABSL_CONST_INIT static const T name\n\n// A no-op expansion that can be followed by a semicolon at class level.\n#define ABSL_COMPARE_INLINE_SUBCLASS_DECL(type, name) static_assert(true, \"\")\n\n#define ABSL_COMPARE_INLINE_INIT(type, name, init) \\\n  template <typename T>                            \\\n  const T compare_internal::type##_base<T>::name(init)\n\n#endif  // __cpp_inline_variables\n\n// These template base classes allow for defining the values of the constants\n// in the header file (for performance) without using inline variables (which\n// aren't available in C++11).\ntemplate <typename T>\nstruct partial_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(unordered);\n};\n\ntemplate <typename T>\nstruct weak_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n};\n\ntemplate <typename T>\nstruct strong_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equal);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n};\n\n}  // namespace compare_internal\n\nclass partial_ordering\n    : public compare_internal::partial_ordering_base<partial_ordering> {\n  explicit constexpr partial_ordering(compare_internal::eq v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  explicit constexpr partial_ordering(compare_internal::ord v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  explicit constexpr partial_ordering(compare_internal::ncmp v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  friend struct compare_internal::partial_ordering_base<partial_ordering>;\n\n  constexpr bool is_ordered() const noexcept {\n    return value_ !=\n           compare_internal::value_type(compare_internal::ncmp::unordered);\n  }\n\n public:\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(partial_ordering, less);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(partial_ordering, equivalent);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(partial_ordering, greater);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(partial_ordering, unordered);\n\n  // Comparisons\n  friend constexpr bool operator==(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.is_ordered() && v.value_ == 0;\n  }\n  friend constexpr bool operator!=(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return !v.is_ordered() || v.value_ != 0;\n  }\n  friend constexpr bool operator<(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.is_ordered() && v.value_ < 0;\n  }\n  friend constexpr bool operator<=(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.is_ordered() && v.value_ <= 0;\n  }\n  friend constexpr bool operator>(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.is_ordered() && v.value_ > 0;\n  }\n  friend constexpr bool operator>=(\n      partial_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.is_ordered() && v.value_ >= 0;\n  }\n  friend constexpr bool operator==(compare_internal::OnlyLiteralZero,\n                                   partial_ordering v) noexcept {\n    return v.is_ordered() && 0 == v.value_;\n  }\n  friend constexpr bool operator!=(compare_internal::OnlyLiteralZero,\n                                   partial_ordering v) noexcept {\n    return !v.is_ordered() || 0 != v.value_;\n  }\n  friend constexpr bool operator<(compare_internal::OnlyLiteralZero,\n                                  partial_ordering v) noexcept {\n    return v.is_ordered() && 0 < v.value_;\n  }\n  friend constexpr bool operator<=(compare_internal::OnlyLiteralZero,\n                                   partial_ordering v) noexcept {\n    return v.is_ordered() && 0 <= v.value_;\n  }\n  friend constexpr bool operator>(compare_internal::OnlyLiteralZero,\n                                  partial_ordering v) noexcept {\n    return v.is_ordered() && 0 > v.value_;\n  }\n  friend constexpr bool operator>=(compare_internal::OnlyLiteralZero,\n                                   partial_ordering v) noexcept {\n    return v.is_ordered() && 0 >= v.value_;\n  }\n  friend constexpr bool operator==(partial_ordering v1,\n                                   partial_ordering v2) noexcept {\n    return v1.value_ == v2.value_;\n  }\n  friend constexpr bool operator!=(partial_ordering v1,\n                                   partial_ordering v2) noexcept {\n    return v1.value_ != v2.value_;\n  }\n\n private:\n  compare_internal::value_type value_;\n};\nABSL_COMPARE_INLINE_INIT(partial_ordering, less, compare_internal::ord::less);\nABSL_COMPARE_INLINE_INIT(partial_ordering, equivalent,\n                         compare_internal::eq::equivalent);\nABSL_COMPARE_INLINE_INIT(partial_ordering, greater,\n                         compare_internal::ord::greater);\nABSL_COMPARE_INLINE_INIT(partial_ordering, unordered,\n                         compare_internal::ncmp::unordered);\n\nclass weak_ordering\n    : public compare_internal::weak_ordering_base<weak_ordering> {\n  explicit constexpr weak_ordering(compare_internal::eq v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  explicit constexpr weak_ordering(compare_internal::ord v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  friend struct compare_internal::weak_ordering_base<weak_ordering>;\n\n public:\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(weak_ordering, less);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(weak_ordering, equivalent);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(weak_ordering, greater);\n\n  // Conversions\n  constexpr operator partial_ordering() const noexcept {  // NOLINT\n    return value_ == 0 ? partial_ordering::equivalent\n                       : (value_ < 0 ? partial_ordering::less\n                                     : partial_ordering::greater);\n  }\n  // Comparisons\n  friend constexpr bool operator==(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ == 0;\n  }\n  friend constexpr bool operator!=(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ != 0;\n  }\n  friend constexpr bool operator<(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ < 0;\n  }\n  friend constexpr bool operator<=(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ <= 0;\n  }\n  friend constexpr bool operator>(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ > 0;\n  }\n  friend constexpr bool operator>=(\n      weak_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ >= 0;\n  }\n  friend constexpr bool operator==(compare_internal::OnlyLiteralZero,\n                                   weak_ordering v) noexcept {\n    return 0 == v.value_;\n  }\n  friend constexpr bool operator!=(compare_internal::OnlyLiteralZero,\n                                   weak_ordering v) noexcept {\n    return 0 != v.value_;\n  }\n  friend constexpr bool operator<(compare_internal::OnlyLiteralZero,\n                                  weak_ordering v) noexcept {\n    return 0 < v.value_;\n  }\n  friend constexpr bool operator<=(compare_internal::OnlyLiteralZero,\n                                   weak_ordering v) noexcept {\n    return 0 <= v.value_;\n  }\n  friend constexpr bool operator>(compare_internal::OnlyLiteralZero,\n                                  weak_ordering v) noexcept {\n    return 0 > v.value_;\n  }\n  friend constexpr bool operator>=(compare_internal::OnlyLiteralZero,\n                                   weak_ordering v) noexcept {\n    return 0 >= v.value_;\n  }\n  friend constexpr bool operator==(weak_ordering v1,\n                                   weak_ordering v2) noexcept {\n    return v1.value_ == v2.value_;\n  }\n  friend constexpr bool operator!=(weak_ordering v1,\n                                   weak_ordering v2) noexcept {\n    return v1.value_ != v2.value_;\n  }\n\n private:\n  compare_internal::value_type value_;\n};\nABSL_COMPARE_INLINE_INIT(weak_ordering, less, compare_internal::ord::less);\nABSL_COMPARE_INLINE_INIT(weak_ordering, equivalent,\n                         compare_internal::eq::equivalent);\nABSL_COMPARE_INLINE_INIT(weak_ordering, greater,\n                         compare_internal::ord::greater);\n\nclass strong_ordering\n    : public compare_internal::strong_ordering_base<strong_ordering> {\n  explicit constexpr strong_ordering(compare_internal::eq v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  explicit constexpr strong_ordering(compare_internal::ord v) noexcept\n      : value_(static_cast<compare_internal::value_type>(v)) {}\n  friend struct compare_internal::strong_ordering_base<strong_ordering>;\n\n public:\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(strong_ordering, less);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(strong_ordering, equal);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(strong_ordering, equivalent);\n  ABSL_COMPARE_INLINE_SUBCLASS_DECL(strong_ordering, greater);\n\n  // Conversions\n  constexpr operator partial_ordering() const noexcept {  // NOLINT\n    return value_ == 0 ? partial_ordering::equivalent\n                       : (value_ < 0 ? partial_ordering::less\n                                     : partial_ordering::greater);\n  }\n  constexpr operator weak_ordering() const noexcept {  // NOLINT\n    return value_ == 0\n               ? weak_ordering::equivalent\n               : (value_ < 0 ? weak_ordering::less : weak_ordering::greater);\n  }\n  // Comparisons\n  friend constexpr bool operator==(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ == 0;\n  }\n  friend constexpr bool operator!=(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ != 0;\n  }\n  friend constexpr bool operator<(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ < 0;\n  }\n  friend constexpr bool operator<=(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ <= 0;\n  }\n  friend constexpr bool operator>(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ > 0;\n  }\n  friend constexpr bool operator>=(\n      strong_ordering v, compare_internal::OnlyLiteralZero) noexcept {\n    return v.value_ >= 0;\n  }\n  friend constexpr bool operator==(compare_internal::OnlyLiteralZero,\n                                   strong_ordering v) noexcept {\n    return 0 == v.value_;\n  }\n  friend constexpr bool operator!=(compare_internal::OnlyLiteralZero,\n                                   strong_ordering v) noexcept {\n    return 0 != v.value_;\n  }\n  friend constexpr bool operator<(compare_internal::OnlyLiteralZero,\n                                  strong_ordering v) noexcept {\n    return 0 < v.value_;\n  }\n  friend constexpr bool operator<=(compare_internal::OnlyLiteralZero,\n                                   strong_ordering v) noexcept {\n    return 0 <= v.value_;\n  }\n  friend constexpr bool operator>(compare_internal::OnlyLiteralZero,\n                                  strong_ordering v) noexcept {\n    return 0 > v.value_;\n  }\n  friend constexpr bool operator>=(compare_internal::OnlyLiteralZero,\n                                   strong_ordering v) noexcept {\n    return 0 >= v.value_;\n  }\n  friend constexpr bool operator==(strong_ordering v1,\n                                   strong_ordering v2) noexcept {\n    return v1.value_ == v2.value_;\n  }\n  friend constexpr bool operator!=(strong_ordering v1,\n                                   strong_ordering v2) noexcept {\n    return v1.value_ != v2.value_;\n  }\n\n private:\n  compare_internal::value_type value_;\n};\nABSL_COMPARE_INLINE_INIT(strong_ordering, less, compare_internal::ord::less);\nABSL_COMPARE_INLINE_INIT(strong_ordering, equal, compare_internal::eq::equal);\nABSL_COMPARE_INLINE_INIT(strong_ordering, equivalent,\n                         compare_internal::eq::equivalent);\nABSL_COMPARE_INLINE_INIT(strong_ordering, greater,\n                         compare_internal::ord::greater);\n\n#undef ABSL_COMPARE_INLINE_BASECLASS_DECL\n#undef ABSL_COMPARE_INLINE_SUBCLASS_DECL\n#undef ABSL_COMPARE_INLINE_INIT\n\n#endif  // ABSL_USES_STD_ORDERING\n\nnamespace compare_internal {\n// We also provide these comparator adapter functions for internal absl use.\n\n// Helper functions to do a boolean comparison of two keys given a boolean\n// or three-way comparator.\n// SFINAE prevents implicit conversions to bool (such as from int).\ntemplate <typename BoolT,\n          absl::enable_if_t<std::is_same<bool, BoolT>::value, int> = 0>\nconstexpr bool compare_result_as_less_than(const BoolT r) { return r; }\nconstexpr bool compare_result_as_less_than(const absl::weak_ordering r) {\n  return r < 0;\n}\n\ntemplate <typename Compare, typename K, typename LK>\nconstexpr bool do_less_than_comparison(const Compare &compare, const K &x,\n                                       const LK &y) {\n  return compare_result_as_less_than(compare(x, y));\n}\n\n// Helper functions to do a three-way comparison of two keys given a boolean or\n// three-way comparator.\n// SFINAE prevents implicit conversions to int (such as from bool).\ntemplate <typename Int,\n          absl::enable_if_t<std::is_same<int, Int>::value, int> = 0>\nconstexpr absl::weak_ordering compare_result_as_ordering(const Int c) {\n  return c < 0 ? absl::weak_ordering::less\n               : c == 0 ? absl::weak_ordering::equivalent\n                        : absl::weak_ordering::greater;\n}\nconstexpr absl::weak_ordering compare_result_as_ordering(\n    const absl::weak_ordering c) {\n  return c;\n}\n\ntemplate <\n    typename Compare, typename K, typename LK,\n    absl::enable_if_t<!std::is_same<bool, absl::result_of_t<Compare(\n                                              const K &, const LK &)>>::value,\n                      int> = 0>\nconstexpr absl::weak_ordering do_three_way_comparison(const Compare &compare,\n                                                      const K &x, const LK &y) {\n  return compare_result_as_ordering(compare(x, y));\n}\ntemplate <\n    typename Compare, typename K, typename LK,\n    absl::enable_if_t<std::is_same<bool, absl::result_of_t<Compare(\n                                             const K &, const LK &)>>::value,\n                      int> = 0>\nconstexpr absl::weak_ordering do_three_way_comparison(const Compare &compare,\n                                                      const K &x, const LK &y) {\n  return compare(x, y) ? absl::weak_ordering::less\n                       : compare(y, x) ? absl::weak_ordering::greater\n                                       : absl::weak_ordering::equivalent;\n}\n\n}  // namespace compare_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04477",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/compare.h",
  "source_line": 55,
  "validation_status": "validated"
}