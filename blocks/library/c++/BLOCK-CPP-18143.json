{
  "code": "{\n    /// Wrap case labels.\n    /// \\code\n    ///   false:                                true:\n    ///   switch (foo) {                vs.     switch (foo) {\n    ///     case 1: {                             case 1:\n    ///       bar();                              {\n    ///       break;                                bar();\n    ///     }                                       break;\n    ///     default: {                            }\n    ///       plop();                             default:\n    ///     }                                     {\n    ///   }                                         plop();\n    ///                                           }\n    ///                                         }\n    /// \\endcode\n    bool AfterCaseLabel;\n    /// Wrap class definitions.\n    /// \\code\n    ///   true:\n    ///   class foo\n    ///   {};\n    ///\n    ///   false:\n    ///   class foo {};\n    /// \\endcode\n    bool AfterClass;\n\n    /// Wrap control statements (``if``/``for``/``while``/``switch``/..).\n    BraceWrappingAfterControlStatementStyle AfterControlStatement;\n    /// Wrap enum definitions.\n    /// \\code\n    ///   true:\n    ///   enum X : int\n    ///   {\n    ///     B\n    ///   };\n    ///\n    ///   false:\n    ///   enum X : int { B };\n    /// \\endcode\n    bool AfterEnum;\n    /// Wrap function definitions.\n    /// \\code\n    ///   true:\n    ///   void foo()\n    ///   {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    ///\n    ///   false:\n    ///   void foo() {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    bool AfterFunction;\n    /// Wrap namespace definitions.\n    /// \\code\n    ///   true:\n    ///   namespace\n    ///   {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    ///\n    ///   false:\n    ///   namespace {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    /// \\endcode\n    bool AfterNamespace;\n    /// Wrap ObjC definitions (interfaces, implementations...).\n    /// \\note\n    ///  @autoreleasepool and @synchronized blocks are wrapped\n    ///  according to ``AfterControlStatement`` flag.\n    /// \\endnote\n    bool AfterObjCDeclaration;\n    /// Wrap struct definitions.\n    /// \\code\n    ///   true:\n    ///   struct foo\n    ///   {\n    ///     int x;\n    ///   };\n    ///\n    ///   false:\n    ///   struct foo {\n    ///     int x;\n    ///   };\n    /// \\endcode\n    bool AfterStruct;\n    /// Wrap union definitions.\n    /// \\code\n    ///   true:\n    ///   union foo\n    ///   {\n    ///     int x;\n    ///   }\n    ///\n    ///   false:\n    ///   union foo {\n    ///     int x;\n    ///   }\n    /// \\endcode\n    bool AfterUnion;\n    /// Wrap extern blocks.\n    /// \\code\n    ///   true:\n    ///   extern \"C\"\n    ///   {\n    ///     int foo();\n    ///   }\n    ///\n    ///   false:\n    ///   extern \"C\" {\n    ///   int foo();\n    ///   }\n    /// \\endcode\n    bool AfterExternBlock; // Partially superseded by IndentExternBlock\n    /// Wrap before ``catch``.\n    /// \\code\n    ///   true:\n    ///   try {\n    ///     foo();\n    ///   }\n    ///   catch () {\n    ///   }\n    ///\n    ///   false:\n    ///   try {\n    ///     foo();\n    ///   } catch () {\n    ///   }\n    /// \\endcode\n    bool BeforeCatch;\n    /// Wrap before ``else``.\n    /// \\code\n    ///   true:\n    ///   if (foo()) {\n    ///   }\n    ///   else {\n    ///   }\n    ///\n    ///   false:\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    /// \\endcode\n    bool BeforeElse;\n    /// Wrap lambda block.\n    /// \\code\n    ///   true:\n    ///   connect(\n    ///     []()\n    ///     {\n    ///       foo();\n    ///       bar();\n    ///     });\n    ///\n    ///   false:\n    ///   connect([]() {\n    ///     foo();\n    ///     bar();\n    ///   });\n    /// \\endcode\n    bool BeforeLambdaBody;\n    /// Wrap before ``while``.\n    /// \\code\n    ///   true:\n    ///   do {\n    ///     foo();\n    ///   }\n    ///   while (1);\n    ///\n    ///   false:\n    ///   do {\n    ///     foo();\n    ///   } while (1);\n    /// \\endcode\n    bool BeforeWhile;\n    /// Indent the wrapped braces themselves.\n    bool IndentBraces;\n    /// If ``false``, empty function body can be put on a single line.\n    /// This option is used only if the opening brace of the function has\n    /// already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is\n    /// set, and the function could/should not be put on a single line (as per\n    /// ``AllowShortFunctionsOnASingleLine`` and constructor formatting\n    /// options).\n    /// \\code\n    ///   false:          true:\n    ///   int f()   vs.   int f()\n    ///   {}              {\n    ///                   }\n    /// \\endcode\n    ///\n    bool SplitEmptyFunction;\n    /// If ``false``, empty record (e.g. class, struct or union) body\n    /// can be put on a single line. This option is used only if the opening\n    /// brace of the record has already been wrapped, i.e. the ``AfterClass``\n    /// (for classes) brace wrapping mode is set.\n    /// \\code\n    ///   false:           true:\n    ///   class Foo   vs.  class Foo\n    ///   {}               {\n    ///                    }\n    /// \\endcode\n    ///\n    bool SplitEmptyRecord;\n    /// If ``false``, empty namespace body can be put on a single line.\n    /// This option is used only if the opening brace of the namespace has\n    /// already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is\n    /// set.\n    /// \\code\n    ///   false:               true:\n    ///   namespace Foo   vs.  namespace Foo\n    ///   {}                   {\n    ///                        }\n    /// \\endcode\n    ///\n    bool SplitEmptyNamespace;\n  }",
  "id": "BLOCK-CPP-18143",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 1123,
  "validation_status": "validated"
}