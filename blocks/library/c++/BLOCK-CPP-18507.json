{
  "code": "{\n\nclass CompilerInstance;\nclass IncrementalExecutor;\nclass IncrementalParser;\n\n/// Create a pre-configured \\c CompilerInstance for incremental processing.\nclass IncrementalCompilerBuilder {\npublic:\n  IncrementalCompilerBuilder() {}\n\n  void SetCompilerArgs(const std::vector<const char *> &Args) {\n    UserArgs = Args;\n  }\n\n  // General C++\n  llvm::Expected<std::unique_ptr<CompilerInstance>> CreateCpp();\n\n  // Offload options\n  void SetOffloadArch(llvm::StringRef Arch) { OffloadArch = Arch; };\n\n  // CUDA specific\n  void SetCudaSDK(llvm::StringRef path) { CudaSDKPath = path; };\n\n  llvm::Expected<std::unique_ptr<CompilerInstance>> CreateCudaHost();\n  llvm::Expected<std::unique_ptr<CompilerInstance>> CreateCudaDevice();\n\nprivate:\n  static llvm::Expected<std::unique_ptr<CompilerInstance>>\n  create(std::vector<const char *> &ClangArgv);\n\n  llvm::Expected<std::unique_ptr<CompilerInstance>> createCuda(bool device);\n\n  std::vector<const char *> UserArgs;\n\n  llvm::StringRef OffloadArch;\n  llvm::StringRef CudaSDKPath;\n};\n\n/// Provides top-level interfaces for incremental compilation and execution.\nclass Interpreter {\n  std::unique_ptr<llvm::orc::ThreadSafeContext> TSCtx;\n  std::unique_ptr<IncrementalParser> IncrParser;\n  std::unique_ptr<IncrementalExecutor> IncrExecutor;\n\n  // An optional parser for CUDA offloading\n  std::unique_ptr<IncrementalParser> DeviceParser;\n\n  Interpreter(std::unique_ptr<CompilerInstance> CI, llvm::Error &Err);\n\n  llvm::Error CreateExecutor();\n  unsigned InitPTUSize = 0;\n\n  // This member holds the last result of the value printing. It's a class\n  // member because we might want to access it after more inputs. If no value\n  // printing happens, it's in an invalid state.\n  Value LastValue;\n\npublic:\n  ~Interpreter();\n  static llvm::Expected<std::unique_ptr<Interpreter>>\n  create(std::unique_ptr<CompilerInstance> CI);\n  static llvm::Expected<std::unique_ptr<Interpreter>>\n  createWithCUDA(std::unique_ptr<CompilerInstance> CI,\n                 std::unique_ptr<CompilerInstance> DCI);\n  const ASTContext &getASTContext() const;\n  ASTContext &getASTContext();\n  const CompilerInstance *getCompilerInstance() const;\n  llvm::Expected<llvm::orc::LLJIT &> getExecutionEngine();\n\n  llvm::Expected<PartialTranslationUnit &> Parse(llvm::StringRef Code);\n  llvm::Error Execute(PartialTranslationUnit &T);\n  llvm::Error ParseAndExecute(llvm::StringRef Code, Value *V = nullptr);\n  llvm::Expected<llvm::orc::ExecutorAddr> CompileDtorCall(CXXRecordDecl *CXXRD);\n\n  /// Undo N previous incremental inputs.\n  llvm::Error Undo(unsigned N = 1);\n\n  /// Link a dynamic library\n  llvm::Error LoadDynamicLibrary(const char *name);\n\n  /// \\returns the \\c ExecutorAddr of a \\c GlobalDecl. This interface uses\n  /// the CodeGenModule's internal mangling cache to avoid recomputing the\n  /// mangled name.\n  llvm::Expected<llvm::orc::ExecutorAddr> getSymbolAddress(GlobalDecl GD) const;\n\n  /// \\returns the \\c ExecutorAddr of a given name as written in the IR.\n  llvm::Expected<llvm::orc::ExecutorAddr>\n  getSymbolAddress(llvm::StringRef IRName) const;\n\n  /// \\returns the \\c ExecutorAddr of a given name as written in the object\n  /// file.\n  llvm::Expected<llvm::orc::ExecutorAddr>\n  getSymbolAddressFromLinkerName(llvm::StringRef LinkerName) const;\n\n  enum InterfaceKind { NoAlloc, WithAlloc, CopyArray };\n\n  const llvm::SmallVectorImpl<Expr *> &getValuePrintingInfo() const {\n    return ValuePrintingInfo;\n  }\n\n  Expr *SynthesizeExpr(Expr *E);\n\nprivate:\n  size_t getEffectivePTUSize() const;\n\n  bool FindRuntimeInterface();\n\n  llvm::DenseMap<CXXRecordDecl *, llvm::orc::ExecutorAddr> Dtors;\n\n  llvm::SmallVector<Expr *, 3> ValuePrintingInfo;\n};\n}",
  "id": "BLOCK-CPP-18507",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Interpreter/Interpreter.h",
  "source_line": 36,
  "validation_status": "validated"
}