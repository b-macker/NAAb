{
  "code": "{\n  using is_key_compare_to = typename Params::is_key_compare_to;\n  using field_type = typename Params::node_count_type;\n  using allocator_type = typename Params::allocator_type;\n  using slot_type = typename Params::slot_type;\n  using original_key_compare = typename Params::original_key_compare;\n\n public:\n  using params_type = Params;\n  using key_type = typename Params::key_type;\n  using value_type = typename Params::value_type;\n  using pointer = typename Params::pointer;\n  using const_pointer = typename Params::const_pointer;\n  using reference = typename Params::reference;\n  using const_reference = typename Params::const_reference;\n  using key_compare = typename Params::key_compare;\n  using size_type = typename Params::size_type;\n  using difference_type = typename Params::difference_type;\n\n  // Btree decides whether to use linear node search as follows:\n  //   - If the comparator expresses a preference, use that.\n  //   - If the key expresses a preference, use that.\n  //   - If the key is arithmetic and the comparator is std::less or\n  //     std::greater, choose linear.\n  //   - Otherwise, choose binary.\n  // TODO(ezb): Might make sense to add condition(s) based on node-size.\n  using use_linear_search = std::integral_constant<\n      bool, has_linear_node_search_preference<original_key_compare>::value\n                ? prefers_linear_node_search<original_key_compare>::value\n            : has_linear_node_search_preference<key_type>::value\n                ? prefers_linear_node_search<key_type>::value\n                : std::is_arithmetic<key_type>::value &&\n                      (std::is_same<std::less<key_type>,\n                                    original_key_compare>::value ||\n                       std::is_same<std::greater<key_type>,\n                                    original_key_compare>::value)>;\n\n  // This class is organized by absl::container_internal::Layout as if it had\n  // the following structure:\n  //   // A pointer to the node's parent.\n  //   btree_node *parent;\n  //\n  //   // When ABSL_BTREE_ENABLE_GENERATIONS is defined, we also have a\n  //   // generation integer in order to check that when iterators are\n  //   // used, they haven't been invalidated already. Only the generation on\n  //   // the root is used, but we have one on each node because whether a node\n  //   // is root or not can change.\n  //   uint32_t generation;\n  //\n  //   // The position of the node in the node's parent.\n  //   field_type position;\n  //   // The index of the first populated value in `values`.\n  //   // TODO(ezb): right now, `start` is always 0. Update insertion/merge\n  //   // logic to allow for floating storage within nodes.\n  //   field_type start;\n  //   // The index after the last populated value in `values`. Currently, this\n  //   // is the same as the count of values.\n  //   field_type finish;\n  //   // The maximum number of values the node can hold. This is an integer in\n  //   // [1, kNodeSlots] for root leaf nodes, kNodeSlots for non-root leaf\n  //   // nodes, and kInternalNodeMaxCount (as a sentinel value) for internal\n  //   // nodes (even though there are still kNodeSlots values in the node).\n  //   // TODO(ezb): make max_count use only 4 bits and record log2(capacity)\n  //   // to free extra bits for is_root, etc.\n  //   field_type max_count;\n  //\n  //   // The array of values. The capacity is `max_count` for leaf nodes and\n  //   // kNodeSlots for internal nodes. Only the values in\n  //   // [start, finish) have been initialized and are valid.\n  //   slot_type values[max_count];\n  //\n  //   // The array of child pointers. The keys in children[i] are all less\n  //   // than key(i). The keys in children[i + 1] are all greater than key(i).\n  //   // There are 0 children for leaf nodes and kNodeSlots + 1 children for\n  //   // internal nodes.\n  //   btree_node *children[kNodeSlots + 1];\n  //\n  // This class is only constructed by EmptyNodeType. Normally, pointers to the\n  // layout above are allocated, cast to btree_node*, and de-allocated within\n  // the btree implementation.\n  ~btree_node() = default;\n  btree_node(btree_node const &) = delete;\n  btree_node &operator=(btree_node const &) = delete;\n\n protected:\n  btree_node() = default;\n\n private:\n  using layout_type =\n      absl::container_internal::Layout<btree_node *, uint32_t, field_type,\n                                       slot_type, btree_node *>;\n  constexpr static size_type SizeWithNSlots(size_type n) {\n    return layout_type(\n               /*parent*/ 1,\n               /*generation*/ BtreeGenerationsEnabled() ? 1 : 0,\n               /*position, start, finish, max_count*/ 4,\n               /*slots*/ n,\n               /*children*/ 0)\n        .AllocSize();\n  }\n  // A lower bound for the overhead of fields other than slots in a leaf node.\n  constexpr static size_type MinimumOverhead() {\n    return SizeWithNSlots(1) - sizeof(slot_type);\n  }\n\n  // Compute how many values we can fit onto a leaf node taking into account\n  // padding.\n  constexpr static size_type NodeTargetSlots(const size_type begin,\n                                             const size_type end) {\n    return begin == end ? begin\n           : SizeWithNSlots((begin + end) / 2 + 1) >\n                   params_type::kTargetNodeSize\n               ? NodeTargetSlots(begin, (begin + end) / 2)\n               : NodeTargetSlots((begin + end) / 2 + 1, end);\n  }\n\n  constexpr static size_type kTargetNodeSize = params_type::kTargetNodeSize;\n  constexpr static size_type kNodeTargetSlots =\n      NodeTargetSlots(0, kTargetNodeSize);\n\n  // We need a minimum of 3 slots per internal node in order to perform\n  // splitting (1 value for the two nodes involved in the split and 1 value\n  // propagated to the parent as the delimiter for the split). For performance\n  // reasons, we don't allow 3 slots-per-node due to bad worst case occupancy of\n  // 1/3 (for a node, not a b-tree).\n  constexpr static size_type kMinNodeSlots = 4;\n\n  constexpr static size_type kNodeSlots =\n      kNodeTargetSlots >= kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots;\n\n  // The node is internal (i.e. is not a leaf node) if and only if `max_count`\n  // has this value.\n  constexpr static field_type kInternalNodeMaxCount = 0;\n\n  constexpr static layout_type Layout(const size_type slot_count,\n                                      const size_type child_count) {\n    return layout_type(\n        /*parent*/ 1,\n        /*generation*/ BtreeGenerationsEnabled() ? 1 : 0,\n        /*position, start, finish, max_count*/ 4,\n        /*slots*/ slot_count,\n        /*children*/ child_count);\n  }\n  // Leaves can have less than kNodeSlots values.\n  constexpr static layout_type LeafLayout(\n      const size_type slot_count = kNodeSlots) {\n    return Layout(slot_count, 0);\n  }\n  constexpr static layout_type InternalLayout() {\n    return Layout(kNodeSlots, kNodeSlots + 1);\n  }\n  constexpr static size_type LeafSize(const size_type slot_count = kNodeSlots) {\n    return LeafLayout(slot_count).AllocSize();\n  }\n  constexpr static size_type InternalSize() {\n    return InternalLayout().AllocSize();\n  }\n\n  constexpr static size_type Alignment() {\n    static_assert(LeafLayout(1).Alignment() == InternalLayout().Alignment(),\n                  \"Alignment of all nodes must be equal.\");\n    return InternalLayout().Alignment();\n  }\n\n  // N is the index of the type in the Layout definition.\n  // ElementType<N> is the Nth type in the Layout definition.\n  template <size_type N>\n  inline typename layout_type::template ElementType<N> *GetField() {\n    // We assert that we don't read from values that aren't there.\n    assert(N < 4 || is_internal());\n    return InternalLayout().template Pointer<N>(reinterpret_cast<char *>(this));\n  }\n  template <size_type N>\n  inline const typename layout_type::template ElementType<N> *GetField() const {\n    assert(N < 4 || is_internal());\n    return InternalLayout().template Pointer<N>(\n        reinterpret_cast<const char *>(this));\n  }\n  void set_parent(btree_node *p) { *GetField<0>() = p; }\n  field_type &mutable_finish() { return GetField<2>()[2]; }\n  slot_type *slot(size_type i) { return &GetField<3>()[i]; }\n  slot_type *start_slot() { return slot(start()); }\n  slot_type *finish_slot() { return slot(finish()); }\n  const slot_type *slot(size_type i) const { return &GetField<3>()[i]; }\n  void set_position(field_type v) { GetField<2>()[0] = v; }\n  void set_start(field_type v) { GetField<2>()[1] = v; }\n  void set_finish(field_type v) { GetField<2>()[2] = v; }\n  // This method is only called by the node init methods.\n  void set_max_count(field_type v) { GetField<2>()[3] = v; }\n\n public:\n  // Whether this is a leaf node or not. This value doesn't change after the\n  // node is created.\n  bool is_leaf() const { return GetField<2>()[3] != kInternalNodeMaxCount; }\n  // Whether this is an internal node or not. This value doesn't change after\n  // the node is created.\n  bool is_internal() const { return !is_leaf(); }\n\n  // Getter for the position of this node in its parent.\n  field_type position() const { return GetField<2>()[0]; }\n\n  // Getter for the offset of the first value in the `values` array.\n  field_type start() const {\n    // TODO(ezb): when floating storage is implemented, return GetField<2>()[1];\n    assert(GetField<2>()[1] == 0);\n    return 0;\n  }\n\n  // Getter for the offset after the last value in the `values` array.\n  field_type finish() const { return GetField<2>()[2]; }\n\n  // Getters for the number of values stored in this node.\n  field_type count() const {\n    assert(finish() >= start());\n    return finish() - start();\n  }\n  field_type max_count() const {\n    // Internal nodes have max_count==kInternalNodeMaxCount.\n    // Leaf nodes have max_count in [1, kNodeSlots].\n    const field_type max_count = GetField<2>()[3];\n    return max_count == field_type{kInternalNodeMaxCount}\n               ? field_type{kNodeSlots}\n               : max_count;\n  }\n\n  // Getter for the parent of this node.\n  btree_node *parent() const { return *GetField<0>(); }\n  // Getter for whether the node is the root of the tree. The parent of the\n  // root of the tree is the leftmost node in the tree which is guaranteed to\n  // be a leaf.\n  bool is_root() const { return parent()->is_leaf(); }\n  void make_root() {\n    assert(parent()->is_root());\n    set_generation(parent()->generation());\n    set_parent(parent()->parent());\n  }\n\n  // Gets the root node's generation integer, which is the one used by the tree.\n  uint32_t *get_root_generation() const {\n    assert(BtreeGenerationsEnabled());\n    const btree_node *curr = this;\n    for (; !curr->is_root(); curr = curr->parent()) continue;\n    return const_cast<uint32_t *>(&curr->GetField<1>()[0]);\n  }\n\n  // Returns the generation for iterator validation.\n  uint32_t generation() const {\n    return BtreeGenerationsEnabled() ? *get_root_generation() : 0;\n  }\n  // Updates generation. Should only be called on a root node or during node\n  // initialization.\n  void set_generation(uint32_t generation) {\n    if (BtreeGenerationsEnabled()) GetField<1>()[0] = generation;\n  }\n  // Updates the generation. We do this whenever the node is mutated.\n  void next_generation() {\n    if (BtreeGenerationsEnabled()) ++*get_root_generation();\n  }\n\n  // Getters for the key/value at position i in the node.\n  const key_type &key(size_type i) const { return params_type::key(slot(i)); }\n  reference value(size_type i) { return params_type::element(slot(i)); }\n  const_reference value(size_type i) const {\n    return params_type::element(slot(i));\n  }\n\n  // Getters/setter for the child at position i in the node.\n  btree_node *child(field_type i) const { return GetField<4>()[i]; }\n  btree_node *start_child() const { return child(start()); }\n  btree_node *&mutable_child(field_type i) { return GetField<4>()[i]; }\n  void clear_child(field_type i) {\n    absl::container_internal::SanitizerPoisonObject(&mutable_child(i));\n  }\n  void set_child_noupdate_position(field_type i, btree_node *c) {\n    absl::container_internal::SanitizerUnpoisonObject(&mutable_child(i));\n    mutable_child(i) = c;\n  }\n  void set_child(field_type i, btree_node *c) {\n    set_child_noupdate_position(i, c);\n    c->set_position(i);\n  }\n  void init_child(field_type i, btree_node *c) {\n    set_child(i, c);\n    c->set_parent(this);\n  }\n\n  // Returns the position of the first value whose key is not less than k.\n  template <typename K>\n  SearchResult<size_type, is_key_compare_to::value> lower_bound(\n      const K &k, const key_compare &comp) const {\n    return use_linear_search::value ? linear_search(k, comp)\n                                    : binary_search(k, comp);\n  }\n  // Returns the position of the first value whose key is greater than k.\n  template <typename K>\n  size_type upper_bound(const K &k, const key_compare &comp) const {\n    auto upper_compare = upper_bound_adapter<key_compare>(comp);\n    return use_linear_search::value ? linear_search(k, upper_compare).value\n                                    : binary_search(k, upper_compare).value;\n  }\n\n  template <typename K, typename Compare>\n  SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>\n  linear_search(const K &k, const Compare &comp) const {\n    return linear_search_impl(k, start(), finish(), comp,\n                              btree_is_key_compare_to<Compare, key_type>());\n  }\n\n  template <typename K, typename Compare>\n  SearchResult<size_type, btree_is_key_compare_to<Compare, key_type>::value>\n  binary_search(const K &k, const Compare &comp) const {\n    return binary_search_impl(k, start(), finish(), comp,\n                              btree_is_key_compare_to<Compare, key_type>());\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // linear search performed using plain compare.\n  template <typename K, typename Compare>\n  SearchResult<size_type, false> linear_search_impl(\n      const K &k, size_type s, const size_type e, const Compare &comp,\n      std::false_type /* IsCompareTo */) const {\n    while (s < e) {\n      if (!comp(key(s), k)) {\n        break;\n      }\n      ++s;\n    }\n    return SearchResult<size_type, false>{s};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // linear search performed using compare-to.\n  template <typename K, typename Compare>\n  SearchResult<size_type, true> linear_search_impl(\n      const K &k, size_type s, const size_type e, const Compare &comp,\n      std::true_type /* IsCompareTo */) const {\n    while (s < e) {\n      const absl::weak_ordering c = comp(key(s), k);\n      if (c == 0) {\n        return {s, MatchKind::kEq};\n      } else if (c > 0) {\n        break;\n      }\n      ++s;\n    }\n    return {s, MatchKind::kNe};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // binary search performed using plain compare.\n  template <typename K, typename Compare>\n  SearchResult<size_type, false> binary_search_impl(\n      const K &k, size_type s, size_type e, const Compare &comp,\n      std::false_type /* IsCompareTo */) const {\n    while (s != e) {\n      const size_type mid = (s + e) >> 1;\n      if (comp(key(mid), k)) {\n        s = mid + 1;\n      } else {\n        e = mid;\n      }\n    }\n    return SearchResult<size_type, false>{s};\n  }\n\n  // Returns the position of the first value whose key is not less than k using\n  // binary search performed using compare-to.\n  template <typename K, typename CompareTo>\n  SearchResult<size_type, true> binary_search_impl(\n      const K &k, size_type s, size_type e, const CompareTo &comp,\n      std::true_type /* IsCompareTo */) const {\n    if (params_type::template can_have_multiple_equivalent_keys<K>()) {\n      MatchKind exact_match = MatchKind::kNe;\n      while (s != e) {\n        const size_type mid = (s + e) >> 1;\n        const absl::weak_ordering c = comp(key(mid), k);\n        if (c < 0) {\n          s = mid + 1;\n        } else {\n          e = mid;\n          if (c == 0) {\n            // Need to return the first value whose key is not less than k,\n            // which requires continuing the binary search if there could be\n            // multiple equivalent keys.\n            exact_match = MatchKind::kEq;\n          }\n        }\n      }\n      return {s, exact_match};\n    } else {  // Can't have multiple equivalent keys.\n      while (s != e) {\n        const size_type mid = (s + e) >> 1;\n        const absl::weak_ordering c = comp(key(mid), k);\n        if (c < 0) {\n          s = mid + 1;\n        } else if (c > 0) {\n          e = mid;\n        } else {\n          return {mid, MatchKind::kEq};\n        }\n      }\n      return {s, MatchKind::kNe};\n    }\n  }\n\n  // Returns whether key i is ordered correctly with respect to the other keys\n  // in the node. The motivation here is to detect comparators that violate\n  // transitivity. Note: we only do comparisons of keys on this node rather than\n  // the whole tree so that this is constant time.\n  template <typename Compare>\n  bool is_ordered_correctly(field_type i, const Compare &comp) const {\n    if (std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase,\n                        Compare>::value ||\n        params_type::kIsKeyCompareStringAdapted) {\n      return true;\n    }\n\n    const auto compare = [&](field_type a, field_type b) {\n      const absl::weak_ordering cmp =\n          compare_internal::do_three_way_comparison(comp, key(a), key(b));\n      return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;\n    };\n    int cmp = -1;\n    constexpr bool kCanHaveEquivKeys =\n        params_type::template can_have_multiple_equivalent_keys<key_type>();\n    for (field_type j = start(); j < finish(); ++j) {\n      if (j == i) {\n        if (cmp > 0) return false;\n        continue;\n      }\n      int new_cmp = compare(j, i);\n      if (new_cmp < cmp || (!kCanHaveEquivKeys && new_cmp == 0)) return false;\n      cmp = new_cmp;\n    }\n    return true;\n  }\n\n  // Emplaces a value at position i, shifting all existing values and\n  // children at positions >= i to the right by 1.\n  template <typename... Args>\n  void emplace_value(field_type i, allocator_type *alloc, Args &&...args);\n\n  // Removes the values at positions [i, i + to_erase), shifting all existing\n  // values and children after that range to the left by to_erase. Clears all\n  // children between [i, i + to_erase).\n  void remove_values(field_type i, field_type to_erase, allocator_type *alloc);\n\n  // Rebalances a node with its right sibling.\n  void rebalance_right_to_left(field_type to_move, btree_node *right,\n                               allocator_type *alloc);\n  void rebalance_left_to_right(field_type to_move, btree_node *right,\n                               allocator_type *alloc);\n\n  // Splits a node, moving a portion of the node's values to its right sibling.\n  void split(int insert_position, btree_node *dest, allocator_type *alloc);\n\n  // Merges a node with its right sibling, moving all of the values and the\n  // delimiting key in the parent node onto itself, and deleting the src node.\n  void merge(btree_node *src, allocator_type *alloc);\n\n  // Node allocation/deletion routines.\n  void init_leaf(field_type position, field_type max_count,\n                 btree_node *parent) {\n    set_generation(0);\n    set_parent(parent);\n    set_position(position);\n    set_start(0);\n    set_finish(0);\n    set_max_count(max_count);\n    absl::container_internal::SanitizerPoisonMemoryRegion(\n        start_slot(), max_count * sizeof(slot_type));\n  }\n  void init_internal(field_type position, btree_node *parent) {\n    init_leaf(position, kNodeSlots, parent);\n    // Set `max_count` to a sentinel value to indicate that this node is\n    // internal.\n    set_max_count(kInternalNodeMaxCount);\n    absl::container_internal::SanitizerPoisonMemoryRegion(\n        &mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *));\n  }\n\n  static void deallocate(const size_type size, btree_node *node,\n                         allocator_type *alloc) {\n    absl::container_internal::SanitizerUnpoisonMemoryRegion(node, size);\n    absl::container_internal::Deallocate<Alignment()>(alloc, node, size);\n  }\n\n  // Deletes a node and all of its children.\n  static void clear_and_delete(btree_node *node, allocator_type *alloc);\n\n private:\n  template <typename... Args>\n  void value_init(const field_type i, allocator_type *alloc, Args &&...args) {\n    next_generation();\n    absl::container_internal::SanitizerUnpoisonObject(slot(i));\n    params_type::construct(alloc, slot(i), std::forward<Args>(args)...);\n  }\n  void value_destroy(const field_type i, allocator_type *alloc) {\n    next_generation();\n    params_type::destroy(alloc, slot(i));\n    absl::container_internal::SanitizerPoisonObject(slot(i));\n  }\n  void value_destroy_n(const field_type i, const field_type n,\n                       allocator_type *alloc) {\n    next_generation();\n    for (slot_type *s = slot(i), *end = slot(i + n); s != end; ++s) {\n      params_type::destroy(alloc, s);\n      absl::container_internal::SanitizerPoisonObject(s);\n    }\n  }\n\n  static void transfer(slot_type *dest, slot_type *src, allocator_type *alloc) {\n    absl::container_internal::SanitizerUnpoisonObject(dest);\n    params_type::transfer(alloc, dest, src);\n    absl::container_internal::SanitizerPoisonObject(src);\n  }\n\n  // Transfers value from slot `src_i` in `src_node` to slot `dest_i` in `this`.\n  void transfer(const size_type dest_i, const size_type src_i,\n                btree_node *src_node, allocator_type *alloc) {\n    next_generation();\n    transfer(slot(dest_i), src_node->slot(src_i), alloc);\n  }\n\n  // Transfers `n` values starting at value `src_i` in `src_node` into the\n  // values starting at value `dest_i` in `this`.\n  void transfer_n(const size_type n, const size_type dest_i,\n                  const size_type src_i, btree_node *src_node,\n                  allocator_type *alloc) {\n    next_generation();\n    for (slot_type *src = src_node->slot(src_i), *end = src + n,\n                   *dest = slot(dest_i);\n         src != end; ++src, ++dest) {\n      transfer(dest, src, alloc);\n    }\n  }\n\n  // Same as above, except that we start at the end and work our way to the\n  // beginning.\n  void transfer_n_backward(const size_type n, const size_type dest_i,\n                           const size_type src_i, btree_node *src_node,\n                           allocator_type *alloc) {\n    next_generation();\n    for (slot_type *src = src_node->slot(src_i + n), *end = src - n,\n                   *dest = slot(dest_i + n);\n         src != end; --src, --dest) {\n      // If we modified the loop index calculations above to avoid the -1s here,\n      // it would result in UB in the computation of `end` (and possibly `src`\n      // as well, if n == 0), since slot() is effectively an array index and it\n      // is UB to compute the address of any out-of-bounds array element except\n      // for one-past-the-end.\n      transfer(dest - 1, src - 1, alloc);\n    }\n  }\n\n  template <typename P>\n  friend class btree;\n  template <typename N, typename R, typename P>\n  friend class btree_iterator;\n  friend class BtreeNodePeer;\n  friend struct btree_access;\n}",
  "id": "BLOCK-CPP-04876",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree.h",
  "source_line": 491,
  "validation_status": "validated"
}