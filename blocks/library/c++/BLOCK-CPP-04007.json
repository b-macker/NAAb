{
  "code": "{\n  //     bool first = true;\n  //     while (n > 0) {\n  //       CordBuffer buffer = first ? cord.GetAppendBuffer(n)\n  //                                 : CordBuffer::CreateWithDefaultLimit(n);\n  //       absl::Span<char> data = buffer.available_up_to(n);\n  //       FillRandomValues(data.data(), data.size());\n  //       buffer.IncreaseLengthBy(data.size());\n  //       cord.Append(std::move(buffer));\n  //       n -= data.size();\n  //       first = false;\n  //     }\n  //   }\n  CordBuffer GetAppendBuffer(size_t capacity, size_t min_capacity = 16);\n\n  // Returns a CordBuffer, re-using potential existing capacity in this cord.\n  //\n  // This function is identical to `GetAppendBuffer`, except that in the case\n  // where a new `CordBuffer` is allocated, it is allocated using the provided\n  // custom limit instead of the default limit. `GetAppendBuffer` will default\n  // to `CordBuffer::CreateWithDefaultLimit(capacity)` whereas this method\n  // will default to `CordBuffer::CreateWithCustomLimit(block_size, capacity)`.\n  // This method is equivalent to `GetAppendBuffer` if `block_size` is zero.\n  // See the documentation for `CreateWithCustomLimit` for more details on the\n  // restrictions and legal values for `block_size`.\n  CordBuffer GetCustomAppendBuffer(size_t block_size, size_t capacity,\n                                   size_t min_capacity = 16);\n\n  // Cord::Prepend()\n  //\n  // Prepends data to the Cord, which may come from another Cord or other string\n  // data.\n  void Prepend(const Cord& src);\n  void Prepend(absl::string_view src);\n  template <typename T, EnableIfString<T> = 0>\n  void Prepend(T&& src);\n\n  // Prepends `buffer` to this cord, unless `buffer` has a zero length in which\n  // case this method has no effect on this cord instance.\n  // This method is guaranteed to consume `buffer`.\n  void Prepend(CordBuffer buffer);\n\n  // Cord::RemovePrefix()\n  //\n  // Removes the first `n` bytes of a Cord.\n  void RemovePrefix(size_t n);\n  void RemoveSuffix(size_t n);\n\n  // Cord::Subcord()\n  //\n  // Returns a new Cord representing the subrange [pos, pos + new_size) of\n  // *this. If pos >= size(), the result is empty(). If\n  // (pos + new_size) >= size(), the result is the subrange [pos, size()).\n  Cord Subcord(size_t pos, size_t new_size) const;\n\n  // Cord::swap()\n  //\n  // Swaps the contents of the Cord with `other`.\n  void swap(Cord& other) noexcept;\n\n  // swap()\n  //\n  // Swaps the contents of two Cords.\n  friend void swap(Cord& x, Cord& y) noexcept { x.swap(y); }\n\n  // Cord::size()\n  //\n  // Returns the size of the Cord.\n  size_t size() const;\n\n  // Cord::empty()\n  //\n  // Determines whether the given Cord is empty, returning `true` if so.\n  bool empty() const;\n\n  // Cord::EstimatedMemoryUsage()\n  //\n  // Returns the *approximate* number of bytes held by this cord.\n  // See CordMemoryAccounting for more information on the accounting method.\n  size_t EstimatedMemoryUsage(CordMemoryAccounting accounting_method =\n                                  CordMemoryAccounting::kTotal) const;\n\n  // Cord::Compare()\n  //\n  // Compares 'this' Cord with rhs. This function and its relatives treat Cords\n  // as sequences of unsigned bytes. The comparison is a straightforward\n  // lexicographic comparison. `Cord::Compare()` returns values as follows:\n  //\n  //   -1  'this' Cord is smaller\n  //    0  two Cords are equal\n  //    1  'this' Cord is larger\n  int Compare(absl::string_view rhs) const;\n  int Compare(const Cord& rhs) const;\n\n  // Cord::StartsWith()\n  //\n  // Determines whether the Cord starts with the passed string data `rhs`.\n  bool StartsWith(const Cord& rhs) const;\n  bool StartsWith(absl::string_view rhs) const;\n\n  // Cord::EndsWith()\n  //\n  // Determines whether the Cord ends with the passed string data `rhs`.\n  bool EndsWith(absl::string_view rhs) const;\n  bool EndsWith(const Cord& rhs) const;\n\n  // Cord::Contains()\n  //\n  // Determines whether the Cord contains the passed string data `rhs`.\n  bool Contains(absl::string_view rhs) const;\n  bool Contains(const Cord& rhs) const;\n\n  // Cord::operator std::string()\n  //\n  // Converts a Cord into a `std::string()`. This operator is marked explicit to\n  // prevent unintended Cord usage in functions that take a string.\n  explicit operator std::string() const;\n\n  // CopyCordToString()\n  //\n  // Copies the contents of a `src` Cord into a `*dst` string.\n  //\n  // This function optimizes the case of reusing the destination string since it\n  // can reuse previously allocated capacity. However, this function does not\n  // guarantee that pointers previously returned by `dst->data()` remain valid\n  // even if `*dst` had enough capacity to hold `src`. If `*dst` is a new\n  // object, prefer to simply use the conversion operator to `std::string`.\n  friend void CopyCordToString(const Cord& src,\n                               absl::Nonnull<std::string*> dst);\n\n  class CharIterator;\n\n  //----------------------------------------------------------------------------\n  // Cord::ChunkIterator\n  //----------------------------------------------------------------------------\n  //\n  // A `Cord::ChunkIterator` allows iteration over the constituent chunks of its\n  // Cord. Such iteration allows you to perform non-const operations on the data\n  // of a Cord without modifying it.\n  //\n  // Generally, you do not instantiate a `Cord::ChunkIterator` directly;\n  // instead, you create one implicitly through use of the `Cord::Chunks()`\n  // member function.\n  //\n  // The `Cord::ChunkIterator` has the following properties:\n  //\n  //   * The iterator is invalidated after any non-const operation on the\n  //     Cord object over which it iterates.\n  //   * The `string_view` returned by dereferencing a valid, non-`end()`\n  //     iterator is guaranteed to be non-empty.\n  //   * Two `ChunkIterator` objects can be compared equal if and only if they\n  //     remain valid and iterate over the same Cord.\n  //   * The iterator in this case is a proxy iterator; the `string_view`\n  //     returned by the iterator does not live inside the Cord, and its\n  //     lifetime is limited to the lifetime of the iterator itself. To help\n  //     prevent lifetime issues, `ChunkIterator::reference` is not a true\n  //     reference type and is equivalent to `value_type`.\n  //   * The iterator keeps state that can grow for Cords that contain many\n  //     nodes and are imbalanced due to sharing. Prefer to pass this type by\n  //     const reference instead of by value.\n  class ChunkIterator {\n   public:\n    using iterator_category = std::input_iterator_tag;\n    using value_type = absl::string_view;\n    using difference_type = ptrdiff_t;\n    using pointer = absl::Nonnull<const value_type*>;\n    using reference = value_type;\n\n    ChunkIterator() = default;\n\n    ChunkIterator& operator++();\n    ChunkIterator operator++(int);\n    bool operator==(const ChunkIterator& other) const;\n    bool operator!=(const ChunkIterator& other) const;\n    reference operator*() const;\n    pointer operator->() const;\n\n    friend class Cord;\n    friend class CharIterator;\n\n   private:\n    using CordRep = absl::cord_internal::CordRep;\n    using CordRepBtree = absl::cord_internal::CordRepBtree;\n    using CordRepBtreeReader = absl::cord_internal::CordRepBtreeReader;\n\n    // Constructs a `begin()` iterator from `tree`.\n    explicit ChunkIterator(absl::Nonnull<cord_internal::CordRep*> tree);\n\n    // Constructs a `begin()` iterator from `cord`.\n    explicit ChunkIterator(absl::Nonnull<const Cord*> cord);\n\n    // Initializes this instance from a tree. Invoked by constructors.\n    void InitTree(absl::Nonnull<cord_internal::CordRep*> tree);\n\n    // Removes `n` bytes from `current_chunk_`. Expects `n` to be smaller than\n    // `current_chunk_.size()`.\n    void RemoveChunkPrefix(size_t n);\n    Cord AdvanceAndReadBytes(size_t n);\n    void AdvanceBytes(size_t n);\n\n    // Btree specific operator++\n    ChunkIterator& AdvanceBtree();\n    void AdvanceBytesBtree(size_t n);\n\n    // A view into bytes of the current `CordRep`. It may only be a view to a\n    // suffix of bytes if this is being used by `CharIterator`.\n    absl::string_view current_chunk_;\n    // The current leaf, or `nullptr` if the iterator points to short data.\n    // If the current chunk is a substring node, current_leaf_ points to the\n    // underlying flat or external node.\n    absl::Nullable<absl::cord_internal::CordRep*> current_leaf_ = nullptr;\n    // The number of bytes left in the `Cord` over which we are iterating.\n    size_t bytes_remaining_ = 0;\n\n    // Cord reader for cord btrees. Empty if not traversing a btree.\n    CordRepBtreeReader btree_reader_;\n  };\n\n  // Cord::chunk_begin()\n  //\n  // Returns an iterator to the first chunk of the `Cord`.\n  //\n  // Generally, prefer using `Cord::Chunks()` within a range-based for loop for\n  // iterating over the chunks of a Cord. This method may be useful for getting\n  // a `ChunkIterator` where range-based for-loops are not useful.\n  //\n  // Example:\n  //\n  //   absl::Cord::ChunkIterator FindAsChunk(const absl::Cord& c,\n  //                                         absl::string_view s) {\n  //     return std::find(c.chunk_begin(), c.chunk_end(), s);\n  //   }\n  ChunkIterator chunk_begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::chunk_end()\n  //\n  // Returns an iterator one increment past the last chunk of the `Cord`.\n  //\n  // Generally, prefer using `Cord::Chunks()` within a range-based for loop for\n  // iterating over the chunks of a Cord. This method may be useful for getting\n  // a `ChunkIterator` where range-based for-loops may not be available.\n  ChunkIterator chunk_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  //----------------------------------------------------------------------------\n  // Cord::ChunkRange\n  //----------------------------------------------------------------------------\n  //\n  // `ChunkRange` is a helper class for iterating over the chunks of the `Cord`,\n  // producing an iterator which can be used within a range-based for loop.\n  // Construction of a `ChunkRange` will return an iterator pointing to the\n  // first chunk of the Cord. Generally, do not construct a `ChunkRange`\n  // directly; instead, prefer to use the `Cord::Chunks()` method.\n  //\n  // Implementation note: `ChunkRange` is simply a convenience wrapper over\n  // `Cord::chunk_begin()` and `Cord::chunk_end()`.\n  class ChunkRange {\n   public:\n    // Fulfill minimum c++ container requirements [container.requirements]\n    // These (partial) container type definitions allow ChunkRange to be used\n    // in various utilities expecting a subset of [container.requirements].\n    // For example, the below enables using `::testing::ElementsAre(...)`\n    using value_type = absl::string_view;\n    using reference = value_type&;\n    using const_reference = const value_type&;\n    using iterator = ChunkIterator;\n    using const_iterator = ChunkIterator;\n\n    explicit ChunkRange(absl::Nonnull<const Cord*> cord) : cord_(cord) {}\n\n    ChunkIterator begin() const;\n    ChunkIterator end() const;\n\n   private:\n    absl::Nonnull<const Cord*> cord_;\n  };\n\n  // Cord::Chunks()\n  //\n  // Returns a `Cord::ChunkRange` for iterating over the chunks of a `Cord` with\n  // a range-based for-loop. For most iteration tasks on a Cord, use\n  // `Cord::Chunks()` to retrieve this iterator.\n  //\n  // Example:\n  //\n  //   void ProcessChunks(const Cord& cord) {\n  //     for (absl::string_view chunk : cord.Chunks()) { ... }\n  //   }\n  //\n  // Note that the ordinary caveats of temporary lifetime extension apply:\n  //\n  //   void Process() {\n  //     for (absl::string_view chunk : CordFactory().Chunks()) {\n  //       // The temporary Cord returned by CordFactory has been destroyed!\n  //     }\n  //   }\n  ChunkRange Chunks() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  //----------------------------------------------------------------------------\n  // Cord::CharIterator\n  //----------------------------------------------------------------------------\n  //\n  // A `Cord::CharIterator` allows iteration over the constituent characters of\n  // a `Cord`.\n  //\n  // Generally, you do not instantiate a `Cord::CharIterator` directly; instead,\n  // you create one implicitly through use of the `Cord::Chars()` member\n  // function.\n  //\n  // A `Cord::CharIterator` has the following properties:\n  //\n  //   * The iterator is invalidated after any non-const operation on the\n  //     Cord object over which it iterates.\n  //   * Two `CharIterator` objects can be compared equal if and only if they\n  //     remain valid and iterate over the same Cord.\n  //   * The iterator keeps state that can grow for Cords that contain many\n  //     nodes and are imbalanced due to sharing. Prefer to pass this type by\n  //     const reference instead of by value.\n  //   * This type cannot act as a forward iterator because a `Cord` can reuse\n  //     sections of memory. This fact violates the requirement for forward\n  //     iterators to compare equal if dereferencing them returns the same\n  //     object.\n  class CharIterator {\n   public:\n    using iterator_category = std::input_iterator_tag;\n    using value_type = char;\n    using difference_type = ptrdiff_t;\n    using pointer = absl::Nonnull<const char*>;\n    using reference = const char&;\n\n    CharIterator() = default;\n\n    CharIterator& operator++();\n    CharIterator operator++(int);\n    bool operator==(const CharIterator& other) const;\n    bool operator!=(const CharIterator& other) const;\n    reference operator*() const;\n    pointer operator->() const;\n\n    friend Cord;\n\n   private:\n    explicit CharIterator(absl::Nonnull<const Cord*> cord)\n        : chunk_iterator_(cord) {}\n\n    ChunkIterator chunk_iterator_;\n  };\n\n  // Cord::AdvanceAndRead()\n  //\n  // Advances the `Cord::CharIterator` by `n_bytes` and returns the bytes\n  // advanced as a separate `Cord`. `n_bytes` must be less than or equal to the\n  // number of bytes within the Cord; otherwise, behavior is undefined. It is\n  // valid to pass `char_end()` and `0`.\n  static Cord AdvanceAndRead(absl::Nonnull<CharIterator*> it, size_t n_bytes);\n\n  // Cord::Advance()\n  //\n  // Advances the `Cord::CharIterator` by `n_bytes`. `n_bytes` must be less than\n  // or equal to the number of bytes remaining within the Cord; otherwise,\n  // behavior is undefined. It is valid to pass `char_end()` and `0`.\n  static void Advance(absl::Nonnull<CharIterator*> it, size_t n_bytes);\n\n  // Cord::ChunkRemaining()\n  //\n  // Returns the longest contiguous view starting at the iterator's position.\n  //\n  // `it` must be dereferenceable.\n  static absl::string_view ChunkRemaining(const CharIterator& it);\n\n  // Cord::char_begin()\n  //\n  // Returns an iterator to the first character of the `Cord`.\n  //\n  // Generally, prefer using `Cord::Chars()` within a range-based for loop for\n  // iterating over the chunks of a Cord. This method may be useful for getting\n  // a `CharIterator` where range-based for-loops may not be available.\n  CharIterator char_begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::char_end()\n  //\n  // Returns an iterator to one past the last character of the `Cord`.\n  //\n  // Generally, prefer using `Cord::Chars()` within a range-based for loop for\n  // iterating over the chunks of a Cord. This method may be useful for getting\n  // a `CharIterator` where range-based for-loops are not useful.\n  CharIterator char_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::CharRange\n  //\n  // `CharRange` is a helper class for iterating over the characters of a\n  // producing an iterator which can be used within a range-based for loop.\n  // Construction of a `CharRange` will return an iterator pointing to the first\n  // character of the Cord. Generally, do not construct a `CharRange` directly;\n  // instead, prefer to use the `Cord::Chars()` method shown below.\n  //\n  // Implementation note: `CharRange` is simply a convenience wrapper over\n  // `Cord::char_begin()` and `Cord::char_end()`.\n  class CharRange {\n   public:\n    // Fulfill minimum c++ container requirements [container.requirements]\n    // These (partial) container type definitions allow CharRange to be used\n    // in various utilities expecting a subset of [container.requirements].\n    // For example, the below enables using `::testing::ElementsAre(...)`\n    using value_type = char;\n    using reference = value_type&;\n    using const_reference = const value_type&;\n    using iterator = CharIterator;\n    using const_iterator = CharIterator;\n\n    explicit CharRange(absl::Nonnull<const Cord*> cord) : cord_(cord) {}\n\n    CharIterator begin() const;\n    CharIterator end() const;\n\n   private:\n    absl::Nonnull<const Cord*> cord_;\n  };\n\n  // Cord::Chars()\n  //\n  // Returns a `Cord::CharRange` for iterating over the characters of a `Cord`\n  // with a range-based for-loop. For most character-based iteration tasks on a\n  // Cord, use `Cord::Chars()` to retrieve this iterator.\n  //\n  // Example:\n  //\n  //   void ProcessCord(const Cord& cord) {\n  //     for (char c : cord.Chars()) { ... }\n  //   }\n  //\n  // Note that the ordinary caveats of temporary lifetime extension apply:\n  //\n  //   void Process() {\n  //     for (char c : CordFactory().Chars()) {\n  //       // The temporary Cord returned by CordFactory has been destroyed!\n  //     }\n  //   }\n  CharRange Chars() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::operator[]\n  //\n  // Gets the \"i\"th character of the Cord and returns it, provided that\n  // 0 <= i < Cord.size().\n  //\n  // NOTE: This routine is reasonably efficient. It is roughly\n  // logarithmic based on the number of chunks that make up the cord. Still,\n  // if you need to iterate over the contents of a cord, you should\n  // use a CharIterator/ChunkIterator rather than call operator[] or Get()\n  // repeatedly in a loop.\n  char operator[](size_t i) const;\n\n  // Cord::TryFlat()\n  //\n  // If this cord's representation is a single flat array, returns a\n  // string_view referencing that array.  Otherwise returns nullopt.\n  absl::optional<absl::string_view> TryFlat() const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::Flatten()\n  //\n  // Flattens the cord into a single array and returns a view of the data.\n  //\n  // If the cord was already flat, the contents are not modified.\n  absl::string_view Flatten() ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // Cord::Find()\n  //\n  // Returns an iterator to the first occurrance of the substring `needle`.\n  //\n  // If the substring `needle` does not occur, `Cord::char_end()` is returned.\n  CharIterator Find(absl::string_view needle) const;\n  CharIterator Find(const absl::Cord& needle) const;\n\n  // Supports absl::Cord as a sink object for absl::Format().\n  friend void AbslFormatFlush(absl::Nonnull<absl::Cord*> cord,\n                              absl::string_view part) {\n    cord->Append(part);\n  }\n\n  // Support automatic stringification with absl::StrCat and absl::StrFormat.\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, const absl::Cord& cord) {\n    for (absl::string_view chunk : cord.Chunks()) {\n      sink.Append(chunk);\n    }\n  }\n\n  // Cord::SetExpectedChecksum()\n  //\n  // Stores a checksum value with this non-empty cord instance, for later\n  // retrieval.\n  //\n  // The expected checksum is a number stored out-of-band, alongside the data.\n  // It is preserved across copies and assignments, but any mutations to a cord\n  // will cause it to lose its expected checksum.\n  //\n  // The expected checksum is not part of a Cord's value, and does not affect\n  // operations such as equality or hashing.\n  //\n  // This field is intended to store a CRC32C checksum for later validation, to\n  // help support end-to-end checksum workflows.  However, the Cord API itself\n  // does no CRC validation, and assigns no meaning to this number.\n  //\n  // This call has no effect if this cord is empty.\n  void SetExpectedChecksum(uint32_t crc);\n\n  // Returns this cord's expected checksum, if it has one.  Otherwise, returns\n  // nullopt.\n  absl::optional<uint32_t> ExpectedChecksum() const;\n\n  template <typename H>\n  friend H AbslHashValue(H hash_state, const absl::Cord& c) {\n    absl::optional<absl::string_view> maybe_flat = c.TryFlat();\n    if (maybe_flat.has_value()) {\n      return H::combine(std::move(hash_state), *maybe_flat);\n    }\n    return c.HashFragmented(std::move(hash_state));\n  }\n\n  // Create a Cord with the contents of StringConstant<T>::value.\n  // No allocations will be done and no data will be copied.\n  // This is an INTERNAL API and subject to change or removal. This API can only\n  // be used by spelling absl::strings_internal::MakeStringConstant, which is\n  // also an internal API.\n  template <typename T>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  constexpr Cord(strings_internal::StringConstant<T>);\n\n private:\n  using CordRep = absl::cord_internal::CordRep;\n  using CordRepFlat = absl::cord_internal::CordRepFlat;\n  using CordzInfo = cord_internal::CordzInfo;\n  using CordzUpdateScope = cord_internal::CordzUpdateScope;\n  using CordzUpdateTracker = cord_internal::CordzUpdateTracker;\n  using InlineData = cord_internal::InlineData;\n  using MethodIdentifier = CordzUpdateTracker::MethodIdentifier;\n\n  // Creates a cord instance with `method` representing the originating\n  // public API call causing the cord to be created.\n  explicit Cord(absl::string_view src, MethodIdentifier method);\n\n  friend class CordTestPeer;\n  friend bool operator==(const Cord& lhs, const Cord& rhs);\n  friend bool operator==(const Cord& lhs, absl::string_view rhs);\n\n  friend absl::Nullable<const CordzInfo*> GetCordzInfoForTesting(\n      const Cord& cord);\n\n  // Calls the provided function once for each cord chunk, in order.  Unlike\n  // Chunks(), this API will not allocate memory.\n  void ForEachChunk(absl::FunctionRef<void(absl::string_view)>) const;\n\n  // Allocates new contiguous storage for the contents of the cord. This is\n  // called by Flatten() when the cord was not already flat.\n  absl::string_view FlattenSlowPath();\n\n  // Actual cord contents are hidden inside the following simple\n  // class so that we can isolate the bulk of cord.cc from changes\n  // to the representation.\n  //\n  // InlineRep holds either a tree pointer, or an array of kMaxInline bytes.\n  class InlineRep {\n   public:\n    static constexpr unsigned char kMaxInline = cord_internal::kMaxInline;\n    static_assert(kMaxInline >= sizeof(absl::cord_internal::CordRep*), \"\");\n\n    constexpr InlineRep() : data_() {}\n    explicit InlineRep(InlineData::DefaultInitType init) : data_(init) {}\n    InlineRep(const InlineRep& src);\n    InlineRep(InlineRep&& src);\n    InlineRep& operator=(const InlineRep& src);\n    InlineRep& operator=(InlineRep&& src) noexcept;\n\n    explicit constexpr InlineRep(absl::string_view sv,\n                                 absl::Nullable<CordRep*> rep);\n\n    void Swap(absl::Nonnull<InlineRep*> rhs);\n    size_t size() const;\n    // Returns nullptr if holding pointer\n    absl::Nullable<const char*> data() const;\n    // Discards pointer, if any\n    void set_data(absl::Nonnull<const char*> data, size_t n);\n    absl::Nonnull<char*> set_data(size_t n);  // Write data to the result\n    // Returns nullptr if holding bytes\n    absl::Nullable<absl::cord_internal::CordRep*> tree() const;\n    absl::Nonnull<absl::cord_internal::CordRep*> as_tree() const;\n    absl::Nonnull<const char*> as_chars() const;\n    // Returns non-null iff was holding a pointer\n    absl::Nullable<absl::cord_internal::CordRep*> clear();\n    // Converts to pointer if necessary.\n    void reduce_size(size_t n);    // REQUIRES: holding data\n    void remove_prefix(size_t n);  // REQUIRES: holding data\n    void AppendArray(absl::string_view src, MethodIdentifier method);\n    absl::string_view FindFlatStartPiece() const;\n\n    // Creates a CordRepFlat instance from the current inlined data with `extra'\n    // bytes of desired additional capacity.\n    absl::Nonnull<CordRepFlat*> MakeFlatWithExtraCapacity(size_t extra);\n\n    // Sets the tree value for this instance. `rep` must not be null.\n    // Requires the current instance to hold a tree, and a lock to be held on\n    // any CordzInfo referenced by this instance. The latter is enforced through\n    // the CordzUpdateScope argument. If the current instance is sampled, then\n    // the CordzInfo instance is updated to reference the new `rep` value.\n    void SetTree(absl::Nonnull<CordRep*> rep, const CordzUpdateScope& scope);\n\n    // Identical to SetTree(), except that `rep` is allowed to be null, in\n    // which case the current instance is reset to an empty value.\n    void SetTreeOrEmpty(absl::Nullable<CordRep*> rep,\n                        const CordzUpdateScope& scope);\n\n    // Sets the tree value for this instance, and randomly samples this cord.\n    // This function disregards existing contents in `data_`, and should be\n    // called when a Cord is 'promoted' from an 'uninitialized' or 'inlined'\n    // value to a non-inlined (tree / ring) value.\n    void EmplaceTree(absl::Nonnull<CordRep*> rep, MethodIdentifier method);\n\n    // Identical to EmplaceTree, except that it copies the parent stack from\n    // the provided `parent` data if the parent is sampled.\n    void EmplaceTree(absl::Nonnull<CordRep*> rep, const InlineData& parent,\n                     MethodIdentifier method);\n\n    // Commits the change of a newly created, or updated `rep` root value into\n    // this cord. `old_rep` indicates the old (inlined or tree) value of the\n    // cord, and determines if the commit invokes SetTree() or EmplaceTree().\n    void CommitTree(absl::Nullable<const CordRep*> old_rep,\n                    absl::Nonnull<CordRep*> rep, const CordzUpdateScope& scope,\n                    MethodIdentifier method);\n\n    void AppendTreeToInlined(absl::Nonnull<CordRep*> tree,\n                             MethodIdentifier method);\n    void AppendTreeToTree(absl::Nonnull<CordRep*> tree,\n                          MethodIdentifier method);\n    void AppendTree(absl::Nonnull<CordRep*> tree, MethodIdentifier method);\n    void PrependTreeToInlined(absl::Nonnull<CordRep*> tree,\n                              MethodIdentifier method);\n    void PrependTreeToTree(absl::Nonnull<CordRep*> tree,\n                           MethodIdentifier method);\n    void PrependTree(absl::Nonnull<CordRep*> tree, MethodIdentifier method);\n\n    bool IsSame(const InlineRep& other) const { return data_ == other.data_; }\n\n    void CopyTo(absl::Nonnull<std::string*> dst) const {\n      // memcpy is much faster when operating on a known size. On most supported\n      // platforms, the small string optimization is large enough that resizing\n      // to 15 bytes does not cause a memory allocation.\n      absl::strings_internal::STLStringResizeUninitialized(dst, kMaxInline);\n      data_.copy_max_inline_to(&(*dst)[0]);\n      // erase is faster than resize because the logic for memory allocation is\n      // not needed.\n      dst->erase(inline_size());\n    }\n\n    // Copies the inline contents into `dst`. Assumes the cord is not empty.\n    void CopyToArray(absl::Nonnull<char*> dst) const;\n\n    bool is_tree() const { return data_.is_tree(); }\n\n    // Returns true if the Cord is being profiled by cordz.\n    bool is_profiled() const { return data_.is_tree() && data_.is_profiled(); }\n\n    // Returns the available inlined capacity, or 0 if is_tree() == true.\n    size_t remaining_inline_capacity() const {\n      return data_.is_tree() ? 0 : kMaxInline - data_.inline_size();\n    }\n\n    // Returns the profiled CordzInfo, or nullptr if not sampled.\n    absl::Nullable<absl::cord_internal::CordzInfo*> cordz_info() const {\n      return data_.cordz_info();\n    }\n\n    // Sets the profiled CordzInfo.\n    void set_cordz_info(absl::Nonnull<cord_internal::CordzInfo*> cordz_info) {\n      assert(cordz_info != nullptr);\n      data_.set_cordz_info(cordz_info);\n    }\n\n    // Resets the current cordz_info to null / empty.\n    void clear_cordz_info() { data_.clear_cordz_info(); }\n\n   private:\n    friend class Cord;\n\n    void AssignSlow(const InlineRep& src);\n    // Unrefs the tree and stops profiling.\n    void UnrefTree();\n\n    void ResetToEmpty() { data_ = {}; }\n\n    void set_inline_size(size_t size) { data_.set_inline_size(size); }\n    size_t inline_size() const { return data_.inline_size(); }\n\n    // Empty cords that carry a checksum have a CordRepCrc node with a null\n    // child node. The code can avoid lots of special cases where it would\n    // otherwise transition from tree to inline storage if we just remove the\n    // CordRepCrc node before mutations. Must never be called inside a\n    // CordzUpdateScope since it untracks the cordz info.\n    void MaybeRemoveEmptyCrcNode();\n\n    cord_internal::InlineData data_;\n  };\n  InlineRep contents_;\n\n  // Helper for GetFlat() and TryFlat().\n  static bool GetFlatAux(absl::Nonnull<absl::cord_internal::CordRep*> rep,\n                         absl::Nonnull<absl::string_view*> fragment);\n\n  // Helper for ForEachChunk().\n  static void ForEachChunkAux(\n      absl::Nonnull<absl::cord_internal::CordRep*> rep,\n      absl::FunctionRef<void(absl::string_view)> callback);\n\n  // The destructor for non-empty Cords.\n  void DestroyCordSlow();\n\n  // Out-of-line implementation of slower parts of logic.\n  void CopyToArraySlowPath(absl::Nonnull<char*> dst) const;\n  int CompareSlowPath(absl::string_view rhs, size_t compared_size,\n                      size_t size_to_compare) const;\n  int CompareSlowPath(const Cord& rhs, size_t compared_size,\n                      size_t size_to_compare) const;\n  bool EqualsImpl(absl::string_view rhs, size_t size_to_compare) const;\n  bool EqualsImpl(const Cord& rhs, size_t size_to_compare) const;\n  int CompareImpl(const Cord& rhs) const;\n\n  template <typename ResultType, typename RHS>\n  friend ResultType GenericCompare(const Cord& lhs, const RHS& rhs,\n                                   size_t size_to_compare);\n  static absl::string_view GetFirstChunk(const Cord& c);\n  static absl::string_view GetFirstChunk(absl::string_view sv);\n\n  // Returns a new reference to contents_.tree(), or steals an existing\n  // reference if called on an rvalue.\n  absl::Nonnull<absl::cord_internal::CordRep*> TakeRep() const&;\n  absl::Nonnull<absl::cord_internal::CordRep*> TakeRep() &&;\n\n  // Helper for Append().\n  template <typename C>\n  void AppendImpl(C&& src);\n\n  // Appends / Prepends `src` to this instance, using precise sizing.\n  // This method does explicitly not attempt to use any spare capacity\n  // in any pending last added private owned flat.\n  // Requires `src` to be <= kMaxFlatLength.\n  void AppendPrecise(absl::string_view src, MethodIdentifier method);\n  void PrependPrecise(absl::string_view src, MethodIdentifier method);\n\n  CordBuffer GetAppendBufferSlowPath(size_t block_size, size_t capacity,\n                                     size_t min_capacity);\n\n  // Prepends the provided data to this instance. `method` contains the public\n  // API method for this action which is tracked for Cordz sampling purposes.\n  void PrependArray(absl::string_view src, MethodIdentifier method);\n\n  // Assigns the value in 'src' to this instance, 'stealing' its contents.\n  // Requires src.length() > kMaxBytesToCopy.\n  Cord& AssignLargeString(std::string&& src);\n\n  // Helper for AbslHashValue().\n  template <typename H>\n  H HashFragmented(H hash_state) const {\n    typename H::AbslInternalPiecewiseCombiner combiner;\n    ForEachChunk([&combiner, &hash_state](absl::string_view chunk) {\n      hash_state = combiner.add_buffer(std::move(hash_state), chunk.data(),\n                                       chunk.size());\n    });\n    return H::combine(combiner.finalize(std::move(hash_state)), size());\n  }\n\n  friend class CrcCord;\n  void SetCrcCordState(crc_internal::CrcCordState state);\n  absl::Nullable<const crc_internal::CrcCordState*> MaybeGetCrcCordState()\n      const;\n\n  CharIterator FindImpl(CharIterator it, absl::string_view needle) const;\n}",
  "id": "BLOCK-CPP-04007",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord.h",
  "source_line": 293,
  "validation_status": "validated"
}