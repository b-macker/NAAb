{
  "code": "{\n  DeclGroupRef DG;\n  SourceLocation StartLoc, EndLoc;\n\npublic:\n  DeclStmt(DeclGroupRef dg, SourceLocation startLoc, SourceLocation endLoc)\n      : Stmt(DeclStmtClass), DG(dg), StartLoc(startLoc), EndLoc(endLoc) {}\n\n  /// Build an empty declaration statement.\n  explicit DeclStmt(EmptyShell Empty) : Stmt(DeclStmtClass, Empty) {}\n\n  /// isSingleDecl - This method returns true if this DeclStmt refers\n  /// to a single Decl.\n  bool isSingleDecl() const { return DG.isSingleDecl(); }\n\n  const Decl *getSingleDecl() const { return DG.getSingleDecl(); }\n  Decl *getSingleDecl() { return DG.getSingleDecl(); }\n\n  const DeclGroupRef getDeclGroup() const { return DG; }\n  DeclGroupRef getDeclGroup() { return DG; }\n  void setDeclGroup(DeclGroupRef DGR) { DG = DGR; }\n\n  void setStartLoc(SourceLocation L) { StartLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclStmtClass;\n  }\n\n  // Iterators over subexpressions.\n  child_range children() {\n    return child_range(child_iterator(DG.begin(), DG.end()),\n                       child_iterator(DG.end(), DG.end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<DeclStmt *>(this)->children();\n    return const_child_range(Children);\n  }\n\n  using decl_iterator = DeclGroupRef::iterator;\n  using const_decl_iterator = DeclGroupRef::const_iterator;\n  using decl_range = llvm::iterator_range<decl_iterator>;\n  using decl_const_range = llvm::iterator_range<const_decl_iterator>;\n\n  decl_range decls() { return decl_range(decl_begin(), decl_end()); }\n\n  decl_const_range decls() const {\n    return decl_const_range(decl_begin(), decl_end());\n  }\n\n  decl_iterator decl_begin() { return DG.begin(); }\n  decl_iterator decl_end() { return DG.end(); }\n  const_decl_iterator decl_begin() const { return DG.begin(); }\n  const_decl_iterator decl_end() const { return DG.end(); }\n\n  using reverse_decl_iterator = std::reverse_iterator<decl_iterator>;\n\n  reverse_decl_iterator decl_rbegin() {\n    return reverse_decl_iterator(decl_end());\n  }\n\n  reverse_decl_iterator decl_rend() {\n    return reverse_decl_iterator(decl_begin());\n  }\n}",
  "id": "BLOCK-CPP-12876",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Stmt.h",
  "source_line": 1320,
  "validation_status": "validated"
}