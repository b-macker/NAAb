{
  "code": "{\n  using params_type = typename Tree::params_type;\n\n protected:\n  // Alias used for heterogeneous lookup functions.\n  // `key_arg<K>` evaluates to `K` when the functors are transparent and to\n  // `key_type` otherwise. It permits template argument deduction on `K` for the\n  // transparent case.\n  template <class K>\n  using key_arg =\n      typename KeyArg<params_type::kIsKeyCompareTransparent>::template type<\n          K, typename Tree::key_type>;\n\n public:\n  using key_type = typename Tree::key_type;\n  using value_type = typename Tree::value_type;\n  using size_type = typename Tree::size_type;\n  using difference_type = typename Tree::difference_type;\n  using key_compare = typename Tree::original_key_compare;\n  using value_compare = typename Tree::value_compare;\n  using allocator_type = typename Tree::allocator_type;\n  using reference = typename Tree::reference;\n  using const_reference = typename Tree::const_reference;\n  using pointer = typename Tree::pointer;\n  using const_pointer = typename Tree::const_pointer;\n  using iterator = typename Tree::iterator;\n  using const_iterator = typename Tree::const_iterator;\n  using reverse_iterator = typename Tree::reverse_iterator;\n  using const_reverse_iterator = typename Tree::const_reverse_iterator;\n  using node_type = typename Tree::node_handle_type;\n\n  struct extract_and_get_next_return_type {\n    node_type node;\n    iterator next;\n  };\n\n  // Constructors/assignments.\n  btree_container() : tree_(key_compare(), allocator_type()) {}\n  explicit btree_container(const key_compare &comp,\n                           const allocator_type &alloc = allocator_type())\n      : tree_(comp, alloc) {}\n  explicit btree_container(const allocator_type &alloc)\n      : tree_(key_compare(), alloc) {}\n\n  btree_container(const btree_container &other)\n      : btree_container(other, absl::allocator_traits<allocator_type>::\n                                   select_on_container_copy_construction(\n                                       other.get_allocator())) {}\n  btree_container(const btree_container &other, const allocator_type &alloc)\n      : tree_(other.tree_, alloc) {}\n\n  btree_container(btree_container &&other) noexcept(\n      std::is_nothrow_move_constructible<Tree>::value) = default;\n  btree_container(btree_container &&other, const allocator_type &alloc)\n      : tree_(std::move(other.tree_), alloc) {}\n\n  btree_container &operator=(const btree_container &other) = default;\n  btree_container &operator=(btree_container &&other) noexcept(\n      std::is_nothrow_move_assignable<Tree>::value) = default;\n\n  // Iterator routines.\n  iterator begin() ABSL_ATTRIBUTE_LIFETIME_BOUND { return tree_.begin(); }\n  const_iterator begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.begin();\n  }\n  const_iterator cbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.begin();\n  }\n  iterator end() ABSL_ATTRIBUTE_LIFETIME_BOUND { return tree_.end(); }\n  const_iterator end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.end();\n  }\n  const_iterator cend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.end();\n  }\n  reverse_iterator rbegin() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.rbegin();\n  }\n  const_reverse_iterator rbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.rbegin();\n  }\n  const_reverse_iterator crbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.rbegin();\n  }\n  reverse_iterator rend() ABSL_ATTRIBUTE_LIFETIME_BOUND { return tree_.rend(); }\n  const_reverse_iterator rend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.rend();\n  }\n  const_reverse_iterator crend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.rend();\n  }\n\n  // Lookup routines.\n  template <typename K = key_type>\n  size_type count(const key_arg<K> &key) const {\n    auto equal_range = this->equal_range(key);\n    return equal_range.second - equal_range.first;\n  }\n  template <typename K = key_type>\n  iterator find(const key_arg<K> &key) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.find(key);\n  }\n  template <typename K = key_type>\n  const_iterator find(const key_arg<K> &key) const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.find(key);\n  }\n  template <typename K = key_type>\n  bool contains(const key_arg<K> &key) const {\n    return find(key) != end();\n  }\n  template <typename K = key_type>\n  iterator lower_bound(const key_arg<K> &key) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.lower_bound(key);\n  }\n  template <typename K = key_type>\n  const_iterator lower_bound(const key_arg<K> &key) const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.lower_bound(key);\n  }\n  template <typename K = key_type>\n  iterator upper_bound(const key_arg<K> &key) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.upper_bound(key);\n  }\n  template <typename K = key_type>\n  const_iterator upper_bound(const key_arg<K> &key) const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.upper_bound(key);\n  }\n  template <typename K = key_type>\n  std::pair<iterator, iterator> equal_range(const key_arg<K> &key)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.equal_range(key);\n  }\n  template <typename K = key_type>\n  std::pair<const_iterator, const_iterator> equal_range(\n      const key_arg<K> &key) const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.equal_range(key);\n  }\n\n  // Deletion routines. Note that there is also a deletion routine that is\n  // specific to btree_set_container/btree_multiset_container.\n\n  // Erase the specified iterator from the btree. The iterator must be valid\n  // (i.e. not equal to end()).  Return an iterator pointing to the node after\n  // the one that was erased (or end() if none exists).\n  iterator erase(const_iterator iter) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.erase(iterator(iter));\n  }\n  iterator erase(iterator iter) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.erase(iter);\n  }\n  iterator erase(const_iterator first,\n                 const_iterator last) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return tree_.erase_range(iterator(first), iterator(last)).second;\n  }\n  template <typename K = key_type>\n  size_type erase(const key_arg<K> &key) {\n    auto equal_range = this->equal_range(key);\n    return tree_.erase_range(equal_range.first, equal_range.second).first;\n  }\n\n  // Extract routines.\n  extract_and_get_next_return_type extract_and_get_next(const_iterator position)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    // Use Construct instead of Transfer because the rebalancing code will\n    // destroy the slot later.\n    // Note: we rely on erase() taking place after Construct().\n    return {CommonAccess::Construct<node_type>(get_allocator(),\n                                               iterator(position).slot()),\n            erase(position)};\n  }\n  node_type extract(iterator position) {\n    // Use Construct instead of Transfer because the rebalancing code will\n    // destroy the slot later.\n    auto node =\n        CommonAccess::Construct<node_type>(get_allocator(), position.slot());\n    erase(position);\n    return node;\n  }\n  node_type extract(const_iterator position) {\n    return extract(iterator(position));\n  }\n\n  // Utility routines.\n  ABSL_ATTRIBUTE_REINITIALIZES void clear() { tree_.clear(); }\n  void swap(btree_container &other) { tree_.swap(other.tree_); }\n  void verify() const { tree_.verify(); }\n\n  // Size routines.\n  size_type size() const { return tree_.size(); }\n  size_type max_size() const { return tree_.max_size(); }\n  bool empty() const { return tree_.empty(); }\n\n  friend bool operator==(const btree_container &x, const btree_container &y) {\n    if (x.size() != y.size()) return false;\n    return std::equal(x.begin(), x.end(), y.begin());\n  }\n\n  friend bool operator!=(const btree_container &x, const btree_container &y) {\n    return !(x == y);\n  }\n\n  friend bool operator<(const btree_container &x, const btree_container &y) {\n    return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n  }\n\n  friend bool operator>(const btree_container &x, const btree_container &y) {\n    return y < x;\n  }\n\n  friend bool operator<=(const btree_container &x, const btree_container &y) {\n    return !(y < x);\n  }\n\n  friend bool operator>=(const btree_container &x, const btree_container &y) {\n    return !(x < y);\n  }\n\n  // The allocator used by the btree.\n  allocator_type get_allocator() const { return tree_.get_allocator(); }\n\n  // The key comparator used by the btree.\n  key_compare key_comp() const { return key_compare(tree_.key_comp()); }\n  value_compare value_comp() const { return tree_.value_comp(); }\n\n  // Support absl::Hash.\n  template <typename State>\n  friend State AbslHashValue(State h, const btree_container &b) {\n    for (const auto &v : b) {\n      h = State::combine(std::move(h), v);\n    }\n    return State::combine(std::move(h), b.size());\n  }\n\n protected:\n  friend struct btree_access;\n  Tree tree_;\n}",
  "id": "BLOCK-CPP-04922",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree_container.h",
  "source_line": 36,
  "validation_status": "validated"
}