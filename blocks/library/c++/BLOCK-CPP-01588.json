{
  "code": "{\ntemplate <typename T> struct range_format_kind_ {\n  static constexpr auto value = std::is_same<range_reference_type<T>, T>::value\n                                    ? range_format::disabled\n                                : is_map<T>::value ? range_format::map\n                                : is_set<T>::value ? range_format::set\n                                                   : range_format::sequence;\n};\n\ntemplate <range_format K, typename R, typename Char, typename Enable = void>\nstruct range_default_formatter;\n\ntemplate <range_format K>\nusing range_format_constant = std::integral_constant<range_format, K>;\n\ntemplate <range_format K, typename R, typename Char>\nstruct range_default_formatter<\n    K, R, Char,\n    enable_if_t<(K == range_format::sequence || K == range_format::map ||\n                 K == range_format::set)>> {\n  using range_type = detail::maybe_const_range<R>;\n  range_formatter<detail::uncvref_type<range_type>, Char> underlying_;\n\n  FMT_CONSTEXPR range_default_formatter() { init(range_format_constant<K>()); }\n\n  FMT_CONSTEXPR void init(range_format_constant<range_format::set>) {\n    underlying_.set_brackets(detail::string_literal<Char, '{'>{},\n                             detail::string_literal<Char, '}'>{});\n  }\n\n  FMT_CONSTEXPR void init(range_format_constant<range_format::map>) {\n    underlying_.set_brackets(detail::string_literal<Char, '{'>{},\n                             detail::string_literal<Char, '}'>{});\n    underlying_.underlying().set_brackets({}, {});\n    underlying_.underlying().set_separator(\n        detail::string_literal<Char, ':', ' '>{});\n  }\n\n  FMT_CONSTEXPR void init(range_format_constant<range_format::sequence>) {}\n\n  template <typename ParseContext>\n  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n    return underlying_.parse(ctx);\n  }\n\n  template <typename FormatContext>\n  auto format(range_type& range, FormatContext& ctx) const\n      -> decltype(ctx.out()) {\n    return underlying_.format(range, ctx);\n  }\n};\n}",
  "id": "BLOCK-CPP-01588",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/ranges.h",
  "source_line": 522,
  "validation_status": "validated"
}