{
  "code": "{\n\n// Do not call directly - these are not part of the public API.\nvoid STLStringAppendUninitializedAmortized(std::string* dest,\n                                           size_t to_append) {\n  strings_internal::AppendUninitializedTraits<std::string>::Append(dest,\n                                                                   to_append);\n}\n\ntemplate <typename Integer>\nstd::enable_if_t<std::is_integral<Integer>::value, std::string> IntegerToString(\n    Integer i) {\n  std::string str;\n  const auto /* either bool or std::false_type */ is_negative =\n      absl::numbers_internal::IsNegative(i);\n  const uint32_t digits = absl::numbers_internal::Base10Digits(\n      absl::numbers_internal::UnsignedAbsoluteValue(i));\n  absl::strings_internal::STLStringResizeUninitialized(\n      &str, digits + static_cast<uint32_t>(is_negative));\n  absl::numbers_internal::FastIntToBufferBackward(i, &str[str.size()], digits);\n  return str;\n}\n\ntemplate <>\nstd::string IntegerToString(long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(int)) {\n    return IntegerToString(static_cast<int>(i));\n  } else {\n    return IntegerToString(static_cast<long long>(i));  // NOLINT\n  }\n}\n\ntemplate <>\nstd::string IntegerToString(unsigned long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(unsigned int)) {\n    return IntegerToString(static_cast<unsigned int>(i));\n  } else {\n    return IntegerToString(static_cast<unsigned long long>(i));  // NOLINT\n  }\n}\n\ntemplate <typename Float>\nstd::enable_if_t<std::is_floating_point<Float>::value, std::string>\nFloatToString(Float f) {\n  std::string result;\n  strings_internal::STLStringResizeUninitialized(\n      &result, numbers_internal::kSixDigitsToBufferSize);\n  char* start = &result[0];\n  result.erase(numbers_internal::SixDigitsToBuffer(f, start));\n  return result;\n}\n\nstd::string SingleArgStrCat(int x) { return IntegerToString(x); }\nstd::string SingleArgStrCat(unsigned int x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(unsigned long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(long long x) { return IntegerToString(x); }\n// NOLINTNEXTLINE\nstd::string SingleArgStrCat(unsigned long long x) { return IntegerToString(x); }\nstd::string SingleArgStrCat(float x) { return FloatToString(x); }\nstd::string SingleArgStrCat(double x) { return FloatToString(x); }\n\ntemplate <class Integer>\nstd::enable_if_t<std::is_integral<Integer>::value, void> AppendIntegerToString(\n    std::string& str, Integer i) {\n  const auto /* either bool or std::false_type */ is_negative =\n      absl::numbers_internal::IsNegative(i);\n  const uint32_t digits = absl::numbers_internal::Base10Digits(\n      absl::numbers_internal::UnsignedAbsoluteValue(i));\n  absl::strings_internal::STLStringAppendUninitializedAmortized(\n      &str, digits + static_cast<uint32_t>(is_negative));\n  absl::numbers_internal::FastIntToBufferBackward(i, &str[str.size()], digits);\n}\n\ntemplate <>\nvoid AppendIntegerToString(std::string& str, long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(int)) {\n    return AppendIntegerToString(str, static_cast<int>(i));\n  } else {\n    return AppendIntegerToString(str, static_cast<long long>(i));  // NOLINT\n  }\n}\n\ntemplate <>\nvoid AppendIntegerToString(std::string& str,\n                           unsigned long i) {  // NOLINT\n  if (sizeof(i) <= sizeof(unsigned int)) {\n    return AppendIntegerToString(str, static_cast<unsigned int>(i));\n  } else {\n    return AppendIntegerToString(str,\n                                 static_cast<unsigned long long>(i));  // NOLINT\n  }\n}\n\n// `SingleArgStrAppend` overloads are defined here for the same reasons as with\n// `SingleArgStrCat` above.\nvoid SingleArgStrAppend(std::string& str, int x) {\n  return AppendIntegerToString(str, x);\n}\n\nvoid SingleArgStrAppend(std::string& str, unsigned int x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, unsigned long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, long long x) {\n  return AppendIntegerToString(str, x);\n}\n\n// NOLINTNEXTLINE\nvoid SingleArgStrAppend(std::string& str, unsigned long long x) {\n  return AppendIntegerToString(str, x);\n}\n\nstd::string CatPieces(std::initializer_list<absl::string_view> pieces) {\n  std::string result;\n  size_t total_size = 0;\n  for (absl::string_view piece : pieces) total_size += piece.size();\n  strings_internal::STLStringResizeUninitialized(&result, total_size);\n\n  char* const begin = &result[0];\n  char* out = begin;\n  for (absl::string_view piece : pieces) {\n    const size_t this_size = piece.size();\n    if (this_size != 0) {\n      memcpy(out, piece.data(), this_size);\n      out += this_size;\n    }\n  }\n  assert(out == begin + result.size());\n  return result;\n}\n\n// It's possible to call StrAppend with an absl::string_view that is itself a\n// fragment of the string we're appending to.  However the results of this are\n// random. Therefore, check for this in debug mode.  Use unsigned math so we\n// only have to do one comparison. Note, there's an exception case: appending an\n// empty string is always allowed.\n#define ASSERT_NO_OVERLAP(dest, src) \\\n  assert(((src).size() == 0) ||      \\\n         (uintptr_t((src).data() - (dest).data()) > uintptr_t((dest).size())))\n\nvoid AppendPieces(absl::Nonnull<std::string*> dest,\n                  std::initializer_list<absl::string_view> pieces) {\n  size_t old_size = dest->size();\n  size_t to_append = 0;\n  for (absl::string_view piece : pieces) {\n    ASSERT_NO_OVERLAP(*dest, piece);\n    to_append += piece.size();\n  }\n  strings_internal::STLStringAppendUninitializedAmortized(dest, to_append);\n\n  char* const begin = &(*dest)[0];\n  char* out = begin + old_size;\n  for (absl::string_view piece : pieces) {\n    const size_t this_size = piece.size();\n    if (this_size != 0) {\n      memcpy(out, piece.data(), this_size);\n      out += this_size;\n    }\n  }\n  assert(out == begin + dest->size());\n}\n\n}",
  "id": "BLOCK-CPP-02023",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.cc",
  "source_line": 98,
  "validation_status": "validated"
}