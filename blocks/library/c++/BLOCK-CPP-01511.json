{
  "code": "{\n\n// Checks if T has a user-defined operator<<.\ntemplate <typename T, typename Char, typename Enable = void>\nclass is_streamable {\n private:\n  template <typename U>\n  static auto test(int)\n      -> bool_constant<sizeof(std::declval<std::basic_ostream<Char>&>()\n                              << std::declval<U>()) != 0>;\n\n  template <typename> static auto test(...) -> std::false_type;\n\n  using result = decltype(test<T>(0));\n\n public:\n  is_streamable() = default;\n\n  static const bool value = result::value;\n};\n\n// Formatting of built-in types and arrays is intentionally disabled because\n// it's handled by standard (non-ostream) formatters.\ntemplate <typename T, typename Char>\nstruct is_streamable<\n    T, Char,\n    enable_if_t<\n        std::is_arithmetic<T>::value || std::is_array<T>::value ||\n        std::is_pointer<T>::value || std::is_same<T, char8_type>::value ||\n        std::is_convertible<T, fmt::basic_string_view<Char>>::value ||\n        std::is_same<T, std_string_view<Char>>::value ||\n        (std::is_convertible<T, int>::value && !std::is_enum<T>::value)>>\n    : std::false_type {};\n\n// Generate a unique explicit instantion in every translation unit using a tag\n// type in an anonymous namespace.\nnamespace {\nstruct file_access_tag {};\n}  // namespace\ntemplate <class Tag, class BufType, FILE* BufType::*FileMemberPtr>\nclass file_access {\n  friend auto get_file(BufType& obj) -> FILE* { return obj.*FileMemberPtr; }\n};\n\n#if FMT_MSC_VERSION\ntemplate class file_access<file_access_tag, std::filebuf,\n                           &std::filebuf::_Myfile>;\nauto get_file(std::filebuf&) -> FILE*;\n#elif defined(_WIN32) && defined(_LIBCPP_VERSION)\ntemplate class file_access<file_access_tag, std::__stdoutbuf<char>,\n                           &std::__stdoutbuf<char>::__file_>;\nauto get_file(std::__stdoutbuf<char>&) -> FILE*;\n#endif\n\ninline bool write_ostream_unicode(std::ostream& os, fmt::string_view data) {\n#if FMT_MSC_VERSION\n  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))\n    if (FILE* f = get_file(*buf)) return write_console(f, data);\n#elif defined(_WIN32) && defined(__GLIBCXX__)\n  auto* rdbuf = os.rdbuf();\n  FILE* c_file;\n  if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))\n    c_file = fbuf->file();\n  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))\n    c_file = fbuf->file();\n  else\n    return false;\n  if (c_file) return write_console(c_file, data);\n#elif defined(_WIN32) && defined(_LIBCPP_VERSION)\n  if (auto* buf = dynamic_cast<std::__stdoutbuf<char>*>(os.rdbuf()))\n    if (FILE* f = get_file(*buf)) return write_console(f, data);\n#else\n  ignore_unused(os, data);\n#endif\n  return false;\n}\ninline bool write_ostream_unicode(std::wostream&,\n                                  fmt::basic_string_view<wchar_t>) {\n  return false;\n}\n\n// Write the content of buf to os.\n// It is a separate function rather than a part of vprint to simplify testing.\ntemplate <typename Char>\nvoid write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {\n  const Char* buf_data = buf.data();\n  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;\n  unsigned_streamsize size = buf.size();\n  unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());\n  do {\n    unsigned_streamsize n = size <= max_size ? size : max_size;\n    os.write(buf_data, static_cast<std::streamsize>(n));\n    buf_data += n;\n    size -= n;\n  } while (size != 0);\n}\n\ntemplate <typename Char, typename T>\nvoid format_value(buffer<Char>& buf, const T& value,\n                  locale_ref loc = locale_ref()) {\n  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);\n  auto&& output = std::basic_ostream<Char>(&format_buf);\n#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)\n  if (loc) output.imbue(loc.get<std::locale>());\n#endif\n  output << value;\n  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);\n}\n\ntemplate <typename T> struct streamed_view { const T& value; };\n\n}",
  "id": "BLOCK-CPP-01511",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/ostream.h",
  "source_line": 26,
  "validation_status": "validated"
}