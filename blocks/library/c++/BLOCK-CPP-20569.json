{
  "code": "{\n    struct Slot {\n      llvm::StringRef StackSlotLabel;\n      ValueType Value;\n      SourceLocation PragmaLocation;\n      SourceLocation PragmaPushLocation;\n      Slot(llvm::StringRef StackSlotLabel, ValueType Value,\n           SourceLocation PragmaLocation, SourceLocation PragmaPushLocation)\n          : StackSlotLabel(StackSlotLabel), Value(Value),\n            PragmaLocation(PragmaLocation),\n            PragmaPushLocation(PragmaPushLocation) {}\n    };\n\n    void Act(SourceLocation PragmaLocation, PragmaMsStackAction Action,\n             llvm::StringRef StackSlotLabel, ValueType Value) {\n      if (Action == PSK_Reset) {\n        CurrentValue = DefaultValue;\n        CurrentPragmaLocation = PragmaLocation;\n        return;\n      }\n      if (Action & PSK_Push)\n        Stack.emplace_back(StackSlotLabel, CurrentValue, CurrentPragmaLocation,\n                           PragmaLocation);\n      else if (Action & PSK_Pop) {\n        if (!StackSlotLabel.empty()) {\n          // If we've got a label, try to find it and jump there.\n          auto I = llvm::find_if(llvm::reverse(Stack), [&](const Slot &x) {\n            return x.StackSlotLabel == StackSlotLabel;\n          });\n          // If we found the label so pop from there.\n          if (I != Stack.rend()) {\n            CurrentValue = I->Value;\n            CurrentPragmaLocation = I->PragmaLocation;\n            Stack.erase(std::prev(I.base()), Stack.end());\n          }\n        } else if (!Stack.empty()) {\n          // We do not have a label, just pop the last entry.\n          CurrentValue = Stack.back().Value;\n          CurrentPragmaLocation = Stack.back().PragmaLocation;\n          Stack.pop_back();\n        }\n      }\n      if (Action & PSK_Set) {\n        CurrentValue = Value;\n        CurrentPragmaLocation = PragmaLocation;\n      }\n    }\n\n    // MSVC seems to add artificial slots to #pragma stacks on entering a C++\n    // method body to restore the stacks on exit, so it works like this:\n    //\n    //   struct S {\n    //     #pragma <name>(push, InternalPragmaSlot, <current_pragma_value>)\n    //     void Method {}\n    //     #pragma <name>(pop, InternalPragmaSlot)\n    //   };\n    //\n    // It works even with #pragma vtordisp, although MSVC doesn't support\n    //   #pragma vtordisp(push [, id], n)\n    // syntax.\n    //\n    // Push / pop a named sentinel slot.\n    void SentinelAction(PragmaMsStackAction Action, StringRef Label) {\n      assert((Action == PSK_Push || Action == PSK_Pop) &&\n             \"Can only push / pop #pragma stack sentinels!\");\n      Act(CurrentPragmaLocation, Action, Label, CurrentValue);\n    }\n\n    // Constructors.\n    explicit PragmaStack(const ValueType &Default)\n        : DefaultValue(Default), CurrentValue(Default) {}\n\n    bool hasValue() const { return CurrentValue != DefaultValue; }\n\n    SmallVector<Slot, 2> Stack;\n    ValueType DefaultValue; // Value used for PSK_Reset action.\n    ValueType CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n  }",
  "id": "BLOCK-CPP-20569",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Sema.h",
  "source_line": 592,
  "validation_status": "validated"
}