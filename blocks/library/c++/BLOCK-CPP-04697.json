{
  "code": "#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/scheduling_mode.h\"\n#include \"absl/base/macros.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\nusing namespace synchronization_internal;\nusing namespace base_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04697_execute() {\n    {\n\nclass SchedulingHelper;  // To allow use of SchedulingGuard.\nclass SpinLock;          // To allow use of SchedulingGuard.\n\n// SchedulingGuard\n// Provides guard semantics that may be used to disable cooperative rescheduling\n// of the calling thread within specific program blocks.  This is used to\n// protect resources (e.g. low-level SpinLocks or Domain code) that cooperative\n// scheduling depends on.\n//\n// Domain implementations capable of rescheduling in reaction to involuntary\n// kernel thread actions (e.g blocking due to a pagefault or syscall) must\n// guarantee that an annotated thread is not allowed to (cooperatively)\n// reschedule until the annotated region is complete.\n//\n// It is an error to attempt to use a cooperatively scheduled resource (e.g.\n// Mutex) within a rescheduling-disabled region.\n//\n// All methods are async-signal safe.\nclass SchedulingGuard {\n public:\n  // Returns true iff the calling thread may be cooperatively rescheduled.\n  static bool ReschedulingIsAllowed();\n  SchedulingGuard(const SchedulingGuard&) = delete;\n  SchedulingGuard& operator=(const SchedulingGuard&) = delete;\n\n private:\n  // Disable cooperative rescheduling of the calling thread.  It may still\n  // initiate scheduling operations (e.g. wake-ups), however, it may not itself\n  // reschedule.  Nestable.  The returned result is opaque, clients should not\n  // attempt to interpret it.\n  // REQUIRES: Result must be passed to a pairing EnableScheduling().\n  static bool DisableRescheduling();\n\n  // Marks the end of a rescheduling disabled region, previously started by\n  // DisableRescheduling().\n  // REQUIRES: Pairs with innermost call (and result) of DisableRescheduling().\n  static void EnableRescheduling(bool disable_result);\n\n  // A scoped helper for {Disable, Enable}Rescheduling().\n  // REQUIRES: destructor must run in same thread as constructor.\n  struct ScopedDisable {\n    ScopedDisable() { disabled = SchedulingGuard::DisableRescheduling(); }\n    ~ScopedDisable() { SchedulingGuard::EnableRescheduling(disabled); }\n\n    bool disabled;\n  };\n\n  // A scoped helper to enable rescheduling temporarily.\n  // REQUIRES: destructor must run in same thread as constructor.\n  class ScopedEnable {\n   public:\n    ScopedEnable();\n    ~ScopedEnable();\n\n   private:\n    int scheduling_disabled_depth_;\n  };\n\n  // Access to SchedulingGuard is explicitly permitted.\n  friend class absl::CondVar;\n  friend class absl::Mutex;\n  friend class SchedulingHelper;\n  friend class SpinLock;\n  friend int absl::synchronization_internal::MutexDelay(int32_t c, int mode);\n};\n\n//------------------------------------------------------------------------------\n// End of public interfaces.\n//------------------------------------------------------------------------------\n\ninline bool SchedulingGuard::ReschedulingIsAllowed() {\n  return false;\n}\n\ninline bool SchedulingGuard::DisableRescheduling() {\n  return false;\n}\n\ninline void SchedulingGuard::EnableRescheduling(bool /* disable_result */) {\n  return;\n}\n\ninline SchedulingGuard::ScopedEnable::ScopedEnable()\n    : scheduling_disabled_depth_(0) {}\ninline SchedulingGuard::ScopedEnable::~ScopedEnable() {\n  ABSL_RAW_CHECK(scheduling_disabled_depth_ == 0, \"disable unused warning\");\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04697",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/low_level_scheduling.h",
  "source_line": 40,
  "validation_status": "validated"
}