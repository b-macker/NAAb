{
  "code": "{\npublic:\n  DeclarationFragments() = default;\n\n  /// The kind of a fragment.\n  enum class FragmentKind {\n    /// Unknown fragment kind.\n    None,\n\n    Keyword,\n    Attribute,\n    NumberLiteral,\n    StringLiteral,\n    Identifier,\n\n    /// Identifier that refers to a type in the context.\n    TypeIdentifier,\n\n    /// Parameter that's used as generics in the context. For example template\n    /// parameters.\n    GenericParameter,\n\n    /// External parameters in Objective-C methods.\n    /// For example, \\c forKey in\n    /// \\code{.m}\n    ///   - (void) setValue:(Value)value forKey(Key)key\n    /// \\endcode\n    ExternalParam,\n\n    /// Internal/local parameters in Objective-C methods.\n    /// For example, \\c key in\n    /// \\code{.m}\n    ///   - (void) setValue:(Value)value forKey(Key)key\n    /// \\endcode\n    InternalParam,\n\n    Text,\n  };\n\n  /// Fragment holds information of a single fragment.\n  struct Fragment {\n    std::string Spelling;\n    FragmentKind Kind;\n\n    /// The USR of the fragment symbol, if applicable.\n    std::string PreciseIdentifier;\n\n    /// The associated declaration, if applicable. This is not intended to be\n    /// used outside of libclang.\n    const Decl *Declaration;\n\n    Fragment(StringRef Spelling, FragmentKind Kind, StringRef PreciseIdentifier,\n             const Decl *Declaration)\n        : Spelling(Spelling), Kind(Kind), PreciseIdentifier(PreciseIdentifier),\n          Declaration(Declaration) {}\n  };\n\n  using FragmentIterator = std::vector<Fragment>::iterator;\n  using ConstFragmentIterator = std::vector<Fragment>::const_iterator;\n\n  const std::vector<Fragment> &getFragments() const { return Fragments; }\n\n  FragmentIterator begin() { return Fragments.begin(); }\n\n  FragmentIterator end() { return Fragments.end(); }\n\n  ConstFragmentIterator cbegin() const { return Fragments.cbegin(); }\n\n  ConstFragmentIterator cend() const { return Fragments.cend(); }\n\n  // Add a new Fragment at an arbitrary offset.\n  DeclarationFragments &insert(FragmentIterator It, StringRef Spelling,\n                               FragmentKind Kind,\n                               StringRef PreciseIdentifier = \"\",\n                               const Decl *Declaration = nullptr) {\n    Fragments.insert(It,\n                     Fragment(Spelling, Kind, PreciseIdentifier, Declaration));\n    return *this;\n  }\n\n  DeclarationFragments &insert(FragmentIterator It,\n                               DeclarationFragments &&Other) {\n    Fragments.insert(It, std::make_move_iterator(Other.Fragments.begin()),\n                     std::make_move_iterator(Other.Fragments.end()));\n    Other.Fragments.clear();\n    return *this;\n  }\n\n  /// Append a new Fragment to the end of the Fragments.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &append(StringRef Spelling, FragmentKind Kind,\n                               StringRef PreciseIdentifier = \"\",\n                               const Decl *Declaration = nullptr) {\n    if (Kind == FragmentKind::Text && !Fragments.empty() &&\n        Fragments.back().Kind == FragmentKind::Text) {\n      // If appending a text fragment, and the last fragment is also text,\n      // merge into the last fragment.\n      Fragments.back().Spelling.append(Spelling.data(), Spelling.size());\n    } else {\n      Fragments.emplace_back(Spelling, Kind, PreciseIdentifier, Declaration);\n    }\n    return *this;\n  }\n\n  /// Append another DeclarationFragments to the end.\n  ///\n  /// Note: \\p Other is moved from and cannot be used after a call to this\n  /// method.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &append(DeclarationFragments &&Other) {\n    Fragments.insert(Fragments.end(),\n                     std::make_move_iterator(Other.Fragments.begin()),\n                     std::make_move_iterator(Other.Fragments.end()));\n    Other.Fragments.clear();\n    return *this;\n  }\n\n  /// Append a text Fragment of a space character.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &appendSpace();\n\n  /// Get the string description of a FragmentKind \\p Kind.\n  static StringRef getFragmentKindString(FragmentKind Kind);\n\n  /// Get the corresponding FragmentKind from string \\p S.\n  static FragmentKind parseFragmentKindFromString(StringRef S);\n\nprivate:\n  std::vector<Fragment> Fragments;\n}",
  "id": "BLOCK-CPP-18017",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ExtractAPI/DeclarationFragments.h",
  "source_line": 43,
  "validation_status": "validated"
}