{
  "code": "#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/Pragma.h\"\n#include \"llvm/ADT/StringRef.h\"\n  /// \\param SkippedFile The file that is skipped instead of entering \\#include\n  /// \\param FilenameTok The file name token in \\#include \"FileName\" directive\n  /// or macro expanded file name token from \\#include MACRO(PARAMS) directive.\n  /// any kind (\\c \\#include, \\c \\#import, etc.) has been processed, regardless\n\nusing namespace clang;\nusing namespace of;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18865_execute() {\n    {\n  std::unique_ptr<PPCallbacks> First, Second;\n\npublic:\n  PPChainedCallbacks(std::unique_ptr<PPCallbacks> _First,\n                     std::unique_ptr<PPCallbacks> _Second)\n    : First(std::move(_First)), Second(std::move(_Second)) {}\n\n  ~PPChainedCallbacks() override;\n\n  void FileChanged(SourceLocation Loc, FileChangeReason Reason,\n                   SrcMgr::CharacteristicKind FileType,\n                   FileID PrevFID) override {\n    First->FileChanged(Loc, Reason, FileType, PrevFID);\n    Second->FileChanged(Loc, Reason, FileType, PrevFID);\n  }\n\n  void LexedFileChanged(FileID FID, LexedFileChangeReason Reason,\n                        SrcMgr::CharacteristicKind FileType, FileID PrevFID,\n                        SourceLocation Loc) override {\n    First->LexedFileChanged(FID, Reason, FileType, PrevFID, Loc);\n    Second->LexedFileChanged(FID, Reason, FileType, PrevFID, Loc);\n  }\n\n  void FileSkipped(const FileEntryRef &SkippedFile, const Token &FilenameTok,\n                   SrcMgr::CharacteristicKind FileType) override {\n    First->FileSkipped(SkippedFile, FilenameTok, FileType);\n    Second->FileSkipped(SkippedFile, FilenameTok, FileType);\n  }\n\n  bool FileNotFound(StringRef FileName) override {\n    bool Skip = First->FileNotFound(FileName);\n    // Make sure to invoke the second callback, no matter if the first already\n    // returned true to skip the file.\n    Skip |= Second->FileNotFound(FileName);\n    return Skip;\n  }\n\n  void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,\n                          StringRef FileName, bool IsAngled,\n                          CharSourceRange FilenameRange,\n                          OptionalFileEntryRef File, StringRef SearchPath,\n                          StringRef RelativePath, const Module *Imported,\n                          SrcMgr::CharacteristicKind FileType) override {\n    First->InclusionDirective(HashLoc, IncludeTok, FileName, IsAngled,\n                              FilenameRange, File, SearchPath, RelativePath,\n                              Imported, FileType);\n    Second->InclusionDirective(HashLoc, IncludeTok, FileName, IsAngled,\n                               FilenameRange, File, SearchPath, RelativePath,\n                               Imported, FileType);\n  }\n\n  void EnteredSubmodule(Module *M, SourceLocation ImportLoc,\n                        bool ForPragma) override {\n    First->EnteredSubmodule(M, ImportLoc, ForPragma);\n    Second->EnteredSubmodule(M, ImportLoc, ForPragma);\n  }\n\n  void LeftSubmodule(Module *M, SourceLocation ImportLoc,\n                     bool ForPragma) override {\n    First->LeftSubmodule(M, ImportLoc, ForPragma);\n    Second->LeftSubmodule(M, ImportLoc, ForPragma);\n  }\n\n  void moduleImport(SourceLocation ImportLoc, ModuleIdPath Path,\n                    const Module *Imported) override {\n    First->moduleImport(ImportLoc, Path, Imported);\n    Second->moduleImport(ImportLoc, Path, Imported);\n  }\n\n  void EndOfMainFile() override {\n    First->EndOfMainFile();\n    Second->EndOfMainFile();\n  }\n\n  void Ident(SourceLocation Loc, StringRef str) override {\n    First->Ident(Loc, str);\n    Second->Ident(Loc, str);\n  }\n\n  void PragmaDirective(SourceLocation Loc,\n                       PragmaIntroducerKind Introducer) override {\n    First->PragmaDirective(Loc, Introducer);\n    Second->PragmaDirective(Loc, Introducer);\n  }\n\n  void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind,\n                     StringRef Str) override {\n    First->PragmaComment(Loc, Kind, Str);\n    Second->PragmaComment(Loc, Kind, Str);\n  }\n\n  void PragmaMark(SourceLocation Loc, StringRef Trivia) override {\n    First->PragmaMark(Loc, Trivia);\n    Second->PragmaMark(Loc, Trivia);\n  }\n\n  void PragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                            StringRef Value) override {\n    First->PragmaDetectMismatch(Loc, Name, Value);\n    Second->PragmaDetectMismatch(Loc, Name, Value);\n  }\n\n  void PragmaDebug(SourceLocation Loc, StringRef DebugType) override {\n    First->PragmaDebug(Loc, DebugType);\n    Second->PragmaDebug(Loc, DebugType);\n  }\n\n  void PragmaMessage(SourceLocation Loc, StringRef Namespace,\n                     PragmaMessageKind Kind, StringRef Str) override {\n    First->PragmaMessage(Loc, Namespace, Kind, Str);\n    Second->PragmaMessage(Loc, Namespace, Kind, Str);\n  }\n\n  void PragmaDiagnosticPush(SourceLocation Loc, StringRef Namespace) override {\n    First->PragmaDiagnosticPush(Loc, Namespace);\n    Second->PragmaDiagnosticPush(Loc, Namespace);\n  }\n\n  void PragmaDiagnosticPop(SourceLocation Loc, StringRef Namespace) override {\n    First->PragmaDiagnosticPop(Loc, Namespace);\n    Second->PragmaDiagnosticPop(Loc, Namespace);\n  }\n\n  void PragmaDiagnostic(SourceLocation Loc, StringRef Namespace,\n                        diag::Severity mapping, StringRef Str) override {\n    First->PragmaDiagnostic(Loc, Namespace, mapping, Str);\n    Second->PragmaDiagnostic(Loc, Namespace, mapping, Str);\n  }\n\n  void HasInclude(SourceLocation Loc, StringRef FileName, bool IsAngled,\n                  OptionalFileEntryRef File,\n                  SrcMgr::CharacteristicKind FileType) override;\n\n  void PragmaOpenCLExtension(SourceLocation NameLoc, const IdentifierInfo *Name,\n                             SourceLocation StateLoc, unsigned State) override {\n    First->PragmaOpenCLExtension(NameLoc, Name, StateLoc, State);\n    Second->PragmaOpenCLExtension(NameLoc, Name, StateLoc, State);\n  }\n\n  void PragmaWarning(SourceLocation Loc, PragmaWarningSpecifier WarningSpec,\n                     ArrayRef<int> Ids) override {\n    First->PragmaWarning(Loc, WarningSpec, Ids);\n    Second->PragmaWarning(Loc, WarningSpec, Ids);\n  }\n\n  void PragmaWarningPush(SourceLocation Loc, int Level) override {\n    First->PragmaWarningPush(Loc, Level);\n    Second->PragmaWarningPush(Loc, Level);\n  }\n\n  void PragmaWarningPop(SourceLocation Loc) override {\n    First->PragmaWarningPop(Loc);\n    Second->PragmaWarningPop(Loc);\n  }\n\n  void PragmaExecCharsetPush(SourceLocation Loc, StringRef Str) override {\n    First->PragmaExecCharsetPush(Loc, Str);\n    Second->PragmaExecCharsetPush(Loc, Str);\n  }\n\n  void PragmaExecCharsetPop(SourceLocation Loc) override {\n    First->PragmaExecCharsetPop(Loc);\n    Second->PragmaExecCharsetPop(Loc);\n  }\n\n  void PragmaAssumeNonNullBegin(SourceLocation Loc) override {\n    First->PragmaAssumeNonNullBegin(Loc);\n    Second->PragmaAssumeNonNullBegin(Loc);\n  }\n\n  void PragmaAssumeNonNullEnd(SourceLocation Loc) override {\n    First->PragmaAssumeNonNullEnd(Loc);\n    Second->PragmaAssumeNonNullEnd(Loc);\n  }\n\n  void MacroExpands(const Token &MacroNameTok, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    First->MacroExpands(MacroNameTok, MD, Range, Args);\n    Second->MacroExpands(MacroNameTok, MD, Range, Args);\n  }\n\n  void MacroDefined(const Token &MacroNameTok,\n                    const MacroDirective *MD) override {\n    First->MacroDefined(MacroNameTok, MD);\n    Second->MacroDefined(MacroNameTok, MD);\n  }\n\n  void MacroUndefined(const Token &MacroNameTok,\n                      const MacroDefinition &MD,\n                      const MacroDirective *Undef) override {\n    First->MacroUndefined(MacroNameTok, MD, Undef);\n    Second->MacroUndefined(MacroNameTok, MD, Undef);\n  }\n\n  void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n               SourceRange Range) override {\n    First->Defined(MacroNameTok, MD, Range);\n    Second->Defined(MacroNameTok, MD, Range);\n  }\n\n  void SourceRangeSkipped(SourceRange Range, SourceLocation EndifLoc) override {\n    First->SourceRangeSkipped(Range, EndifLoc);\n    Second->SourceRangeSkipped(Range, EndifLoc);\n  }\n\n  /// Hook called whenever an \\#if is seen.\n  void If(SourceLocation Loc, SourceRange ConditionRange,\n          ConditionValueKind ConditionValue) override {\n    First->If(Loc, ConditionRange, ConditionValue);\n    Second->If(Loc, ConditionRange, ConditionValue);\n  }\n\n  /// Hook called whenever an \\#elif is seen.\n  void Elif(SourceLocation Loc, SourceRange ConditionRange,\n            ConditionValueKind ConditionValue, SourceLocation IfLoc) override {\n    First->Elif(Loc, ConditionRange, ConditionValue, IfLoc);\n    Second->Elif(Loc, ConditionRange, ConditionValue, IfLoc);\n  }\n\n  /// Hook called whenever an \\#ifdef is seen.\n  void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n             const MacroDefinition &MD) override {\n    First->Ifdef(Loc, MacroNameTok, MD);\n    Second->Ifdef(Loc, MacroNameTok, MD);\n  }\n\n  /// Hook called whenever an \\#elifdef is taken.\n  void Elifdef(SourceLocation Loc, const Token &MacroNameTok,\n               const MacroDefinition &MD) override {\n    First->Elifdef(Loc, MacroNameTok, MD);\n    Second->Elifdef(Loc, MacroNameTok, MD);\n  }\n  /// Hook called whenever an \\#elifdef is skipped.\n  void Elifdef(SourceLocation Loc, SourceRange ConditionRange,\n               SourceLocation IfLoc) override {\n    First->Elifdef(Loc, ConditionRange, IfLoc);\n    Second->Elifdef(Loc, ConditionRange, IfLoc);\n  }\n\n  /// Hook called whenever an \\#ifndef is seen.\n  void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n              const MacroDefinition &MD) override {\n    First->Ifndef(Loc, MacroNameTok, MD);\n    Second->Ifndef(Loc, MacroNameTok, MD);\n  }\n\n  /// Hook called whenever an \\#elifndef is taken.\n  void Elifndef(SourceLocation Loc, const Token &MacroNameTok,\n                const MacroDefinition &MD) override {\n    First->Elifndef(Loc, MacroNameTok, MD);\n    Second->Elifndef(Loc, MacroNameTok, MD);\n  }\n  /// Hook called whenever an \\#elifndef is skipped.\n  void Elifndef(SourceLocation Loc, SourceRange ConditionRange,\n               SourceLocation IfLoc) override {\n    First->Elifndef(Loc, ConditionRange, IfLoc);\n    Second->Elifndef(Loc, ConditionRange, IfLoc);\n  }\n\n  /// Hook called whenever an \\#else is seen.\n  void Else(SourceLocation Loc, SourceLocation IfLoc) override {\n    First->Else(Loc, IfLoc);\n    Second->Else(Loc, IfLoc);\n  }\n\n  /// Hook called whenever an \\#endif is seen.\n  void Endif(SourceLocation Loc, SourceLocation IfLoc) override {\n    First->Endif(Loc, IfLoc);\n    Second->Endif(Loc, IfLoc);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18865",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/PPCallbacks.h",
  "source_line": 434,
  "validation_status": "validated"
}