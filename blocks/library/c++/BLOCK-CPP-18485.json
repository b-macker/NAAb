{
  "code": "{\nclass ASTContext;\nclass Decl;\nclass MacroDefinitionRecord;\nclass Module;\nclass SourceLocation;\nclass SourceManager;\nclass QualType;\n\nnamespace index {\n\nstatic inline StringRef getUSRSpacePrefix() {\n  return \"c:\";\n}\n\n/// Generate a USR for a Decl, including the USR prefix.\n/// \\returns true if the results should be ignored, false otherwise.\nbool generateUSRForDecl(const Decl *D, SmallVectorImpl<char> &Buf);\n\n/// Generate a USR fragment for an Objective-C class.\nvoid generateUSRForObjCClass(StringRef Cls, raw_ostream &OS,\n                             StringRef ExtSymbolDefinedIn = \"\",\n                             StringRef CategoryContextExtSymbolDefinedIn = \"\");\n\n/// Generate a USR fragment for an Objective-C class category.\nvoid generateUSRForObjCCategory(StringRef Cls, StringRef Cat, raw_ostream &OS,\n                                StringRef ClsExtSymbolDefinedIn = \"\",\n                                StringRef CatExtSymbolDefinedIn = \"\");\n\n/// Generate a USR fragment for an Objective-C instance variable.  The\n/// complete USR can be created by concatenating the USR for the\n/// encompassing class with this USR fragment.\nvoid generateUSRForObjCIvar(StringRef Ivar, raw_ostream &OS);\n\n/// Generate a USR fragment for an Objective-C method.\nvoid generateUSRForObjCMethod(StringRef Sel, bool IsInstanceMethod,\n                              raw_ostream &OS);\n\n/// Generate a USR fragment for an Objective-C property.\nvoid generateUSRForObjCProperty(StringRef Prop, bool isClassProp, raw_ostream &OS);\n\n/// Generate a USR fragment for an Objective-C protocol.\nvoid generateUSRForObjCProtocol(StringRef Prot, raw_ostream &OS,\n                                StringRef ExtSymbolDefinedIn = \"\");\n\n/// Generate USR fragment for a global (non-nested) enum.\nvoid generateUSRForGlobalEnum(StringRef EnumName, raw_ostream &OS,\n                              StringRef ExtSymbolDefinedIn = \"\");\n\n/// Generate a USR fragment for an enum constant.\nvoid generateUSRForEnumConstant(StringRef EnumConstantName, raw_ostream &OS);\n\n/// Generate a USR for a macro, including the USR prefix.\n///\n/// \\returns true on error, false on success.\nbool generateUSRForMacro(const MacroDefinitionRecord *MD,\n                         const SourceManager &SM, SmallVectorImpl<char> &Buf);\nbool generateUSRForMacro(StringRef MacroName, SourceLocation Loc,\n                         const SourceManager &SM, SmallVectorImpl<char> &Buf);\n\n/// Generates a USR for a type.\n///\n/// \\return true on error, false on success.\nbool generateUSRForType(QualType T, ASTContext &Ctx, SmallVectorImpl<char> &Buf);\n\n/// Generate a USR for a module, including the USR prefix.\n/// \\returns true on error, false on success.\nbool generateFullUSRForModule(const Module *Mod, raw_ostream &OS);\n\n/// Generate a USR for a top-level module name, including the USR prefix.\n/// \\returns true on error, false on success.\nbool generateFullUSRForTopLevelModuleName(StringRef ModName, raw_ostream &OS);\n\n/// Generate a USR fragment for a module.\n/// \\returns true on error, false on success.\nbool generateUSRFragmentForModule(const Module *Mod, raw_ostream &OS);\n\n/// Generate a USR fragment for a module name.\n/// \\returns true on error, false on success.\nbool generateUSRFragmentForModuleName(StringRef ModName, raw_ostream &OS);\n\n\n} // namespace index\n}",
  "id": "BLOCK-CPP-18485",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Index/USRGeneration.h",
  "source_line": 15,
  "validation_status": "validated"
}