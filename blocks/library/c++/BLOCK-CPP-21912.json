{
  "code": "{\n  public:\n    virtual ~ValueModel() = default;\n\n    /// Returns:\n    ///   `Same`: `Val1` is equivalent to `Val2`, according to the model.\n    ///   `Different`: `Val1` is distinct from `Val2`, according to the model.\n    ///   `Unknown`: The model can't determine a relationship between `Val1` and\n    ///    `Val2`.\n    ///\n    /// Requirements:\n    ///\n    ///  `Val1` and `Val2` must be distinct.\n    ///\n    ///  `Val1` and `Val2` must model values of type `Type`.\n    ///\n    ///  `Val1` and `Val2` must be assigned to the same storage location in\n    ///  `Env1` and `Env2` respectively.\n    virtual ComparisonResult compare(QualType Type, const Value &Val1,\n                                     const Environment &Env1, const Value &Val2,\n                                     const Environment &Env2) {\n      // FIXME: Consider adding QualType to StructValue and removing the Type\n      // argument here.\n      return ComparisonResult::Unknown;\n    }\n\n    /// Modifies `MergedVal` to approximate both `Val1` and `Val2`. This could\n    /// be a strict lattice join or a more general widening operation.\n    ///\n    /// If this function returns true, `MergedVal` will be assigned to a storage\n    /// location of type `Type` in `MergedEnv`.\n    ///\n    /// `Env1` and `Env2` can be used to query child values and path condition\n    /// implications of `Val1` and `Val2` respectively.\n    ///\n    /// Requirements:\n    ///\n    ///  `Val1` and `Val2` must be distinct.\n    ///\n    ///  `Val1`, `Val2`, and `MergedVal` must model values of type `Type`.\n    ///\n    ///  `Val1` and `Val2` must be assigned to the same storage location in\n    ///  `Env1` and `Env2` respectively.\n    virtual bool merge(QualType Type, const Value &Val1,\n                       const Environment &Env1, const Value &Val2,\n                       const Environment &Env2, Value &MergedVal,\n                       Environment &MergedEnv) {\n      return true;\n    }\n\n    /// This function may widen the current value -- replace it with an\n    /// approximation that can reach a fixed point more quickly than iterated\n    /// application of the transfer function alone. The previous value is\n    /// provided to inform the choice of widened value. The function must also\n    /// serve as a comparison operation, by indicating whether the widened value\n    /// is equivalent to the previous value.\n    ///\n    /// Returns either:\n    ///\n    ///   `nullptr`, if this value is not of interest to the model, or\n    ///\n    ///   `&Prev`, if the widened value is equivalent to `Prev`, or\n    ///\n    ///   A non-null value that approximates `Current`. `Prev` is available to\n    ///   inform the chosen approximation.\n    ///\n    /// `PrevEnv` and `CurrentEnv` can be used to query child values and path\n    /// condition implications of `Prev` and `Current`, respectively.\n    ///\n    /// Requirements:\n    ///\n    ///  `Prev` and `Current` must model values of type `Type`.\n    ///\n    ///  `Prev` and `Current` must be assigned to the same storage location in\n    ///  `PrevEnv` and `CurrentEnv`, respectively.\n    virtual Value *widen(QualType Type, Value &Prev, const Environment &PrevEnv,\n                         Value &Current, Environment &CurrentEnv) {\n      // The default implementation reduces to just comparison, since comparison\n      // is required by the API, even if no widening is performed.\n      switch (compare(Type, Prev, PrevEnv, Current, CurrentEnv)) {\n        case ComparisonResult::Same:\n          return &Prev;\n        case ComparisonResult::Different:\n          return &Current;\n        case ComparisonResult::Unknown:\n          return nullptr;\n      }\n      llvm_unreachable(\"all cases in switch covered\");\n    }\n  }",
  "id": "BLOCK-CPP-21912",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h",
  "source_line": 70,
  "validation_status": "validated"
}