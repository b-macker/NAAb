{
  "code": "{\n  ///     template<typename T> struct X { typename T* type; };\n  ///   };\n  /// }\n  ///\n  /// template<typename T> struct Y {\n  ///   typename N::S::X<T>::type member;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, the nested-name-specifier for N::S::X<T>:: will be\n  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined\n  /// by declarations in the type system and the canonical type for\n  /// the template type parameter 'T' is template-param-0-0.\n  NestedNameSpecifier *\n  getCanonicalNestedNameSpecifier(NestedNameSpecifier *NNS) const;\n\n  /// Retrieves the default calling convention for the current target.\n  CallingConv getDefaultCallingConvention(bool IsVariadic,\n                                          bool IsCXXMethod,\n                                          bool IsBuiltin = false) const;\n\n  /// Retrieves the \"canonical\" template name that refers to a\n  /// given template.\n  ///\n  /// The canonical template name is the simplest expression that can\n  /// be used to refer to a given template. For most templates, this\n  /// expression is just the template declaration itself. For example,\n  /// the template std::vector can be referred to via a variety of\n  /// names---std::vector, \\::std::vector, vector (if vector is in\n  /// scope), etc.---but all of these names map down to the same\n  /// TemplateDecl, which is used to form the canonical template name.\n  ///\n  /// Dependent template names are more interesting. Here, the\n  /// template name could be something like T::template apply or\n  /// std::allocator<T>::template rebind, where the nested name\n  /// specifier itself is dependent. In this case, the canonical\n  /// template name uses the shortest form of the dependent\n  /// nested-name-specifier, which itself contains all canonical\n  /// types, values, and templates.\n  TemplateName getCanonicalTemplateName(const TemplateName &Name) const;\n\n  /// Determine whether the given template names refer to the same\n  /// template.\n  bool hasSameTemplateName(const TemplateName &X, const TemplateName &Y) const;\n\n  /// Determine whether the two declarations refer to the same entity.\n  bool isSameEntity(const NamedDecl *X, const NamedDecl *Y) const;\n\n  /// Determine whether two template parameter lists are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameTemplateParameterList(const TemplateParameterList *X,\n                                   const TemplateParameterList *Y) const;\n\n  /// Determine whether two template parameters are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameTemplateParameter(const NamedDecl *X, const NamedDecl *Y) const;\n\n  /// Determine whether two 'requires' expressions are similar enough that they\n  /// may be used in re-declarations.\n  ///\n  /// Use of 'requires' isn't mandatory, works with constraints expressed in\n  /// other ways too.\n  bool isSameConstraintExpr(const Expr *XCE, const Expr *YCE) const;\n\n  /// Determine whether two type contraint are similar enough that they could\n  /// used in declarations of the same template.\n  bool isSameTypeConstraint(const TypeConstraint *XTC,\n                            const TypeConstraint *YTC) const;\n\n  /// Determine whether two default template arguments are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameDefaultTemplateArgument(const NamedDecl *X,\n                                     const NamedDecl *Y) const;\n\n  /// Retrieve the \"canonical\" template argument.\n  ///\n  /// The canonical template argument is the simplest template argument\n  /// (which may be a type, value, expression, or declaration) that\n  /// expresses the value of the argument.\n  TemplateArgument getCanonicalTemplateArgument(const TemplateArgument &Arg)\n    const;\n\n  /// Type Query functions.  If the type is an instance of the specified class,\n  /// return the Type pointer for the underlying maximally pretty type.  This\n  /// is a member of ASTContext because this may need to do some amount of\n  /// canonicalization, e.g. to move type qualifiers into the element type.\n  const ArrayType *getAsArrayType(QualType T) const;\n  const ConstantArrayType *getAsConstantArrayType(QualType T) const {\n    return dyn_cast_or_null<ConstantArrayType>(getAsArrayType(T));\n  }\n  const VariableArrayType *getAsVariableArrayType(QualType T) const {\n    return dyn_cast_or_null<VariableArrayType>(getAsArrayType(T));\n  }\n  const IncompleteArrayType *getAsIncompleteArrayType(QualType T) const {\n    return dyn_cast_or_null<IncompleteArrayType>(getAsArrayType(T));\n  }\n  const DependentSizedArrayType *getAsDependentSizedArrayType(QualType T)\n    const {\n    return dyn_cast_or_null<DependentSizedArrayType>(getAsArrayType(T));\n  }\n\n  /// Return the innermost element type of an array type.\n  ///\n  /// For example, will return \"int\" for int[m][n]\n  QualType getBaseElementType(const ArrayType *VAT) const;\n\n  /// Return the innermost element type of a type (which needn't\n  /// actually be an array type).\n  QualType getBaseElementType(QualType QT) const;\n\n  /// Return number of constant array elements.\n  uint64_t getConstantArrayElementCount(const ConstantArrayType *CA) const;\n\n  /// Return number of elements initialized in an ArrayInitLoopExpr.\n  uint64_t\n  getArrayInitLoopExprElementCount(const ArrayInitLoopExpr *AILE) const;\n\n  /// Perform adjustment on the parameter type of a function.\n  ///\n  /// This routine adjusts the given parameter type @p T to the actual\n  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],\n  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.\n  QualType getAdjustedParameterType(QualType T) const;\n\n  /// Retrieve the parameter type as adjusted for use in the signature\n  /// of a function, decaying array and function types and removing top-level\n  /// cv-qualifiers.\n  QualType getSignatureParameterType(QualType T) const;\n\n  QualType getExceptionObjectType(QualType T) const;\n\n  /// Return the properly qualified result of decaying the specified\n  /// array type to a pointer.\n  ///\n  /// This operation is non-trivial when handling typedefs etc.  The canonical\n  /// type of \\p T must be an array type, this returns a pointer to a properly\n  /// qualified element of the array.\n  ///\n  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.\n  QualType getArrayDecayedType(QualType T) const;\n\n  /// Return the type that \\p PromotableType will promote to: C99\n  /// 6.3.1.1p2, assuming that \\p PromotableType is a promotable integer type.\n  QualType getPromotedIntegerType(QualType PromotableType) const;\n\n  /// Recurses in pointer/array types until it finds an Objective-C\n  /// retainable type and returns its ownership.\n  Qualifiers::ObjCLifetime getInnerObjCOwnership(QualType T) const;\n\n  /// Whether this is a promotable bitfield reference according\n  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).\n  ///\n  /// \\returns the type this bit-field will promote to, or NULL if no\n  /// promotion occurs.\n  QualType isPromotableBitField(Expr *E) const;\n\n  /// Return the highest ranked integer type, see C99 6.3.1.8p1.\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getIntegerTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of the two specified floating point types,\n  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getFloatingTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of two floating point types as above, but compare equal\n  /// if both types have the same floating-point semantics on the target (i.e.\n  /// long double and double on AArch64 will return 0).\n  int getFloatingTypeSemanticOrder(QualType LHS, QualType RHS) const;\n\n  unsigned getTargetAddressSpace(LangAS AS) const;\n\n  LangAS getLangASForBuiltinAddressSpace(unsigned AS) const;\n\n  /// Get target-dependent integer value for null pointer which is used for\n  /// constant folding.\n  uint64_t getTargetNullPointerValue(QualType QT) const;\n\n  bool addressSpaceMapManglingFor(LangAS AS) const {\n    return AddrSpaceMapMangling || isTargetAddressSpace(AS);\n  }\n\n  // Merges two exception specifications, such that the resulting\n  // exception spec is the union of both. For example, if either\n  // of them can throw something, the result can throw it as well.\n  FunctionProtoType::ExceptionSpecInfo\n  mergeExceptionSpecs(FunctionProtoType::ExceptionSpecInfo ESI1,\n                      FunctionProtoType::ExceptionSpecInfo ESI2,\n                      SmallVectorImpl<QualType> &ExceptionTypeStorage,\n                      bool AcceptDependent);\n\n  // For two \"same\" types, return a type which has\n  // the common sugar between them. If Unqualified is true,\n  // both types need only be the same unqualified type.\n  // The result will drop the qualifiers which do not occur\n  // in both types.\n  QualType getCommonSugaredType(QualType X, QualType Y,\n                                bool Unqualified = false);\n\nprivate:\n  // Helper for integer ordering\n  unsigned getIntegerRank(const Type *T) const;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  //                    Type Compatibility Predicates\n  //===--------------------------------------------------------------------===//\n\n  /// Compatibility predicates used to check assignment expressions.\n  bool typesAreCompatible(QualType T1, QualType T2,\n                          bool CompareUnqualified = false); // C99 6.2.7p1\n\n  bool propertyTypesAreCompatible(QualType, QualType);\n  bool typesAreBlockPointerCompatible(QualType, QualType);\n\n  bool isObjCIdType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCIdType();\n  }\n\n  bool isObjCClassType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCClassType();\n  }\n\n  bool isObjCSelType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCSelType();\n  }\n\n  bool ObjCQualifiedIdTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                         const ObjCObjectPointerType *RHS,\n                                         bool ForCompare);\n\n  bool ObjCQualifiedClassTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                            const ObjCObjectPointerType *RHS);\n\n  // Check the safety of assignment from LHS to RHS\n  bool canAssignObjCInterfaces(const ObjCObjectPointerType *LHSOPT,\n                               const ObjCObjectPointerType *RHSOPT);\n  bool canAssignObjCInterfaces(const ObjCObjectType *LHS,\n                               const ObjCObjectType *RHS);\n  bool canAssignObjCInterfacesInBlockPointer(\n                                          const ObjCObjectPointerType *LHSOPT,\n                                          const ObjCObjectPointerType *RHSOPT,\n                                          bool BlockReturnType);\n  bool areComparableObjCPointerTypes(QualType LHS, QualType RHS);\n  QualType areCommonBaseCompatible(const ObjCObjectPointerType *LHSOPT,\n                                   const ObjCObjectPointerType *RHSOPT);\n  bool canBindObjCObjectType(QualType To, QualType From);\n\n  // Functions for calculating composite types\n  QualType mergeTypes(QualType, QualType, bool OfBlockPointer = false,\n                      bool Unqualified = false, bool BlockReturnType = false,\n                      bool IsConditionalOperator = false);\n  QualType mergeFunctionTypes(QualType, QualType, bool OfBlockPointer = false,\n                              bool Unqualified = false, bool AllowCXX = false,\n                              bool IsConditionalOperator = false);\n  QualType mergeFunctionParameterTypes(QualType, QualType,\n                                       bool OfBlockPointer = false,\n                                       bool Unqualified = false);\n  QualType mergeTransparentUnionType(QualType, QualType,\n                                     bool OfBlockPointer=false,\n                                     bool Unqualified = false);\n\n  QualType mergeObjCGCQualifiers(QualType, QualType);\n\n  /// This function merges the ExtParameterInfo lists of two functions. It\n  /// returns true if the lists are compatible. The merged list is returned in\n  /// NewParamInfos.\n  ///\n  /// \\param FirstFnType The type of the first function.\n  ///\n  /// \\param SecondFnType The type of the second function.\n  ///\n  /// \\param CanUseFirst This flag is set to true if the first function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param CanUseSecond This flag is set to true if the second function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param NewParamInfos The composite list of ExtParameterInfo. The list is\n  /// empty if none of the flags are set.\n  ///\n  bool mergeExtParameterInfo(\n      const FunctionProtoType *FirstFnType,\n      const FunctionProtoType *SecondFnType,\n      bool &CanUseFirst, bool &CanUseSecond,\n      SmallVectorImpl<FunctionProtoType::ExtParameterInfo> &NewParamInfos);\n\n  void ResetObjCLayout(const ObjCContainerDecl *CD);\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Predicates\n  //===--------------------------------------------------------------------===//\n\n  // The width of an integer, as defined in C99 6.2.6.2. This is the number\n  // of bits in an integer type excluding any padding bits.\n  unsigned getIntWidth(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes a signed type, and returns the\n  // corresponding unsigned integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding unsigned type for\n  // a given fixed point type.\n  QualType getCorrespondingUnsignedType(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes an unsigned type, and returns the\n  // corresponding signed integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding signed type for\n  // a given fixed point type.\n  QualType getCorrespondingSignedType(QualType T) const;\n\n  // Per ISO N1169, this method accepts fixed point types and returns the\n  // corresponding saturated type for a given fixed point type.\n  QualType getCorrespondingSaturatedType(QualType Ty) const;\n\n  // This method accepts fixed point types and returns the corresponding signed\n  // type. Unlike getCorrespondingUnsignedType(), this only accepts unsigned\n  // fixed point types because there are unsigned integer types like bool and\n  // char8_t that don't have signed equivalents.\n  QualType getCorrespondingSignedFixedPointType(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Values\n  //===--------------------------------------------------------------------===//\n\n  /// Make an APSInt of the appropriate width and signedness for the\n  /// given \\p Value and integer \\p Type.\n  llvm::APSInt MakeIntValue(uint64_t Value, QualType Type) const {\n    // If Type is a signed integer type larger than 64 bits, we need to be sure\n    // to sign extend Res appropriately.\n    llvm::APSInt Res(64, !Type->isSignedIntegerOrEnumerationType());\n    Res = Value;\n    unsigned Width = getIntWidth(Type);\n    if (Width != Res.getBitWidth())\n      return Res.extOrTrunc(Width);\n    return Res;\n  }\n\n  bool isSentinelNullExpr(const Expr *E);\n\n  /// Get the implementation of the ObjCInterfaceDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCImplementationDecl *getObjCImplementation(ObjCInterfaceDecl *D);\n\n  /// Get the implementation of the ObjCCategoryDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCCategoryImplDecl *getObjCImplementation(ObjCCategoryDecl *D);\n\n  /// Return true if there is at least one \\@implementation in the TU.\n  bool AnyObjCImplementation() {\n    return !ObjCImpls.empty();\n  }\n\n  /// Set the implementation of ObjCInterfaceDecl.\n  void setObjCImplementation(ObjCInterfaceDecl *IFaceD,\n                             ObjCImplementationDecl *ImplD);\n\n  /// Set the implementation of ObjCCategoryDecl.\n  void setObjCImplementation(ObjCCategoryDecl *CatD,\n                             ObjCCategoryImplDecl *ImplD);\n\n  /// Get the duplicate declaration of a ObjCMethod in the same\n  /// interface, or null if none exists.\n  const ObjCMethodDecl *\n  getObjCMethodRedeclaration(const ObjCMethodDecl *MD) const;\n\n  void setObjCMethodRedeclaration(const ObjCMethodDecl *MD,\n                                  const ObjCMethodDecl *Redecl);\n\n  /// Returns the Objective-C interface that \\p ND belongs to if it is\n  /// an Objective-C method/property/ivar etc. that is part of an interface,\n  /// otherwise returns null.\n  const ObjCInterfaceDecl *getObjContainingInterface(const NamedDecl *ND) const;\n\n  /// Set the copy initialization expression of a block var decl. \\p CanThrow\n  /// indicates whether the copy expression can throw or not.\n  void setBlockVarCopyInit(const VarDecl* VD, Expr *CopyExpr, bool CanThrow);\n\n  /// Get the copy initialization expression of the VarDecl \\p VD, or\n  /// nullptr if none exists.\n  BlockVarCopyInit getBlockVarCopyInit(const VarDecl* VD) const;\n\n  /// Allocate an uninitialized TypeSourceInfo.\n  ///\n  /// The caller should initialize the memory held by TypeSourceInfo using\n  /// the TypeLoc wrappers.\n  ///\n  /// \\param T the type that will be the basis for type source info. This type\n  /// should refer to how the declarator was written in source code, not to\n  /// what type semantic analysis resolved the declarator to.\n  ///\n  /// \\param Size the size of the type info to create, or 0 if the size\n  /// should be calculated based on the type.\n  TypeSourceInfo *CreateTypeSourceInfo(QualType T, unsigned Size = 0) const;\n\n  /// Allocate a TypeSourceInfo where all locations have been\n  /// initialized to a given location, which defaults to the empty\n  /// location.\n  TypeSourceInfo *\n  getTrivialTypeSourceInfo(QualType T,\n                           SourceLocation Loc = SourceLocation()) const;\n\n  /// Add a deallocation callback that will be invoked when the\n  /// ASTContext is destroyed.\n  ///\n  /// \\param Callback A callback function that will be invoked on destruction.\n  ///\n  /// \\param Data Pointer data that will be provided to the callback function\n  /// when it is called.\n  void AddDeallocation(void (*Callback)(void *), void *Data) const;\n\n  /// If T isn't trivially destructible, calls AddDeallocation to register it\n  /// for destruction.\n  template <typename T> void addDestruction(T *Ptr) const {\n    if (!std::is_trivially_destructible<T>::value) {\n      auto DestroyPtr = [](void *V) { static_cast<T *>(V)->~T(); };\n      AddDeallocation(DestroyPtr, Ptr);\n    }\n  }\n\n  GVALinkage GetGVALinkageForFunction(const FunctionDecl *FD) const;\n  GVALinkage GetGVALinkageForVariable(const VarDecl *VD) const;\n\n  /// Determines if the decl can be CodeGen'ed or deserialized from PCH\n  /// lazily, only when used; this is only relevant for function or file scoped\n  /// var definitions.\n  ///\n  /// \\returns true if the function/var must be CodeGen'ed/deserialized even if\n  /// it is not used.\n  bool DeclMustBeEmitted(const Decl *D);\n\n  /// Visits all versions of a multiversioned function with the passed\n  /// predicate.\n  void forEachMultiversionedFunctionVersion(\n      const FunctionDecl *FD,\n      llvm::function_ref<void(FunctionDecl *)> Pred) const;\n\n  const CXXConstructorDecl *\n  getCopyConstructorForExceptionObject(CXXRecordDecl *RD);\n\n  void addCopyConstructorForExceptionObject(CXXRecordDecl *RD,\n                                            CXXConstructorDecl *CD);\n\n  void addTypedefNameForUnnamedTagDecl(TagDecl *TD, TypedefNameDecl *TND);\n\n  TypedefNameDecl *getTypedefNameForUnnamedTagDecl(const TagDecl *TD);\n\n  void addDeclaratorForUnnamedTagDecl(TagDecl *TD, DeclaratorDecl *DD);\n\n  DeclaratorDecl *getDeclaratorForUnnamedTagDecl(const TagDecl *TD);\n\n  void setManglingNumber(const NamedDecl *ND, unsigned Number);\n  unsigned getManglingNumber(const NamedDecl *ND,\n                             bool ForAuxTarget = false) const;\n\n  void setStaticLocalNumber(const VarDecl *VD, unsigned Number);\n  unsigned getStaticLocalNumber(const VarDecl *VD) const;\n\n  /// Retrieve the context for computing mangling numbers in the given\n  /// DeclContext.\n  MangleNumberingContext &getManglingNumberContext(const DeclContext *DC);\n  enum NeedExtraManglingDecl_t { NeedExtraManglingDecl };\n  MangleNumberingContext &getManglingNumberContext(NeedExtraManglingDecl_t,\n                                                   const Decl *D);\n\n  std::unique_ptr<MangleNumberingContext> createMangleNumberingContext() const;\n\n  /// Used by ParmVarDecl to store on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  void setParameterIndex(const ParmVarDecl *D, unsigned index);\n\n  /// Used by ParmVarDecl to retrieve on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  unsigned getParameterIndex(const ParmVarDecl *D) const;\n\n  /// Return a string representing the human readable name for the specified\n  /// function declaration or file name. Used by SourceLocExpr and\n  /// PredefinedExpr to cache evaluated results.\n  StringLiteral *getPredefinedStringLiteralFromCache(StringRef Key) const;\n\n  /// Return a declaration for the global GUID object representing the given\n  /// GUID value.\n  MSGuidDecl *getMSGuidDecl(MSGuidDeclParts Parts) const;\n\n  /// Return a declaration for a uniquified anonymous global constant\n  /// corresponding to a given APValue.\n  UnnamedGlobalConstantDecl *\n  getUnnamedGlobalConstantDecl(QualType Ty, const APValue &Value) const;\n\n  /// Return the template parameter object of the given type with the given\n  /// value.\n  TemplateParamObjectDecl *getTemplateParamObjectDecl(QualType T,\n                                                      const APValue &V) const;\n\n  /// Parses the target attributes passed in, and returns only the ones that are\n  /// valid feature names.\n  ParsedTargetAttr filterFunctionTargetAttrs(const TargetAttr *TD) const;\n\n  std::vector<std::string>\n  filterFunctionTargetVersionAttrs(const TargetVersionAttr *TV) const;\n\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             const FunctionDecl *) const;\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             GlobalDecl GD) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Statistics\n  //===--------------------------------------------------------------------===//\n\n  /// The number of implicitly-declared default constructors.\n  unsigned NumImplicitDefaultConstructors = 0;\n\n  /// The number of implicitly-declared default constructors for\n  /// which declarations were built.\n  unsigned NumImplicitDefaultConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy constructors.\n  unsigned NumImplicitCopyConstructors = 0;\n\n  /// The number of implicitly-declared copy constructors for\n  /// which declarations were built.\n  unsigned NumImplicitCopyConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared move constructors.\n  unsigned NumImplicitMoveConstructors = 0;\n\n  /// The number of implicitly-declared move constructors for\n  /// which declarations were built.\n  unsigned NumImplicitMoveConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy assignment operators.\n  unsigned NumImplicitCopyAssignmentOperators = 0;\n\n  /// The number of implicitly-declared copy assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitCopyAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared move assignment operators.\n  unsigned NumImplicitMoveAssignmentOperators = 0;\n\n  /// The number of implicitly-declared move assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitMoveAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared destructors.\n  unsigned NumImplicitDestructors = 0;\n\n  /// The number of implicitly-declared destructors for which\n  /// declarations were built.\n  unsigned NumImplicitDestructorsDeclared = 0;\n\npublic:\n  /// Initialize built-in types.\n  ///\n  /// This routine may only be invoked once for a given ASTContext object.\n  /// It is normally invoked after ASTContext construction.\n  ///\n  /// \\param Target The target\n  void InitBuiltinTypes(const TargetInfo &Target,\n                        const TargetInfo *AuxTarget = nullptr);\n\nprivate:\n  void InitBuiltinType(CanQualType &R, BuiltinType::Kind K);\n\n  class ObjCEncOptions {\n    unsigned Bits;\n\n    ObjCEncOptions(unsigned Bits) : Bits(Bits) {}\n\n  public:\n    ObjCEncOptions() : Bits(0) {}\n\n#define OPT_LIST(V)                                                            \\\n  V(ExpandPointedToStructures, 0)                                              \\\n  V(ExpandStructures, 1)                                                       \\\n  V(IsOutermostType, 2)                                                        \\\n  V(EncodingProperty, 3)                                                       \\\n  V(IsStructField, 4)                                                          \\\n  V(EncodeBlockParameters, 5)                                                  \\\n  V(EncodeClassNames, 6)                                                       \\\n\n#define V(N,I) ObjCEncOptions& set##N() { Bits |= 1 << I; return *this; }\nOPT_LIST(V)\n#undef V\n\n#define V(N,I) bool N() const { return Bits & 1 << I; }\nOPT_LIST(V)\n#undef V\n\n#undef OPT_LIST\n\n    [[nodiscard]] ObjCEncOptions keepingOnly(ObjCEncOptions Mask) const {\n      return Bits & Mask.Bits;\n    }\n\n    [[nodiscard]] ObjCEncOptions forComponentType() const {\n      ObjCEncOptions Mask = ObjCEncOptions()\n                                .setIsOutermostType()\n                                .setIsStructField();\n      return Bits & ~Mask.Bits;\n    }\n  };\n\n  // Return the Objective-C type encoding for a given type.\n  void getObjCEncodingForTypeImpl(QualType t, std::string &S,\n                                  ObjCEncOptions Options,\n                                  const FieldDecl *Field,\n                                  QualType *NotEncodedT = nullptr) const;\n\n  // Adds the encoding of the structure's members.\n  void getObjCEncodingForStructureImpl(RecordDecl *RD, std::string &S,\n                                       const FieldDecl *Field,\n                                       bool includeVBases = true,\n                                       QualType *NotEncodedT=nullptr) const;\n\npublic:\n  // Adds the encoding of a method parameter or return type.\n  void getObjCEncodingForMethodParameter(Decl::ObjCDeclQualifier QT,\n                                         QualType T, std::string& S,\n                                         bool Extended) const;\n\n  /// Returns true if this is an inline-initialized static data member\n  /// which is treated as a definition for MSVC compatibility.\n  bool isMSStaticDataMemberInlineDefinition(const VarDecl *VD) const;\n\n  enum class InlineVariableDefinitionKind {\n    /// Not an inline variable.\n    None,\n\n    /// Weak definition of inline variable.\n    Weak,\n\n    /// Weak for now, might become strong later in this TU.\n    WeakUnknown,\n\n    /// Strong definition.\n    Strong\n  };\n\n  /// Determine whether a definition of this inline variable should\n  /// be treated as a weak or strong definition. For compatibility with\n  /// C++14 and before, for a constexpr static data member, if there is an\n  /// out-of-line declaration of the member, we may promote it from weak to\n  /// strong.\n  InlineVariableDefinitionKind\n  getInlineVariableDefinitionKind(const VarDecl *VD) const;\n\nprivate:\n  friend class DeclarationNameTable;\n  friend class DeclContext;\n\n  const ASTRecordLayout &\n  getObjCLayout(const ObjCInterfaceDecl *D,\n                const ObjCImplementationDecl *Impl) const;\n\n  /// A set of deallocations that should be performed when the\n  /// ASTContext is destroyed.\n  // FIXME: We really should have a better mechanism in the ASTContext to\n  // manage running destructors for types which do variable sized allocation\n  // within the AST. In some places we thread the AST bump pointer allocator\n  // into the datastructures which avoids this mess during deallocation but is\n  // wasteful of memory, and here we require a lot of error prone book keeping\n  // in order to track and run destructors while we're tearing things down.\n  using DeallocationFunctionsAndArguments =\n      llvm::SmallVector<std::pair<void (*)(void *), void *>, 16>;\n  mutable DeallocationFunctionsAndArguments Deallocations;\n\n  // FIXME: This currently contains the set of StoredDeclMaps used\n  // by DeclContext objects.  This probably should not be in ASTContext,\n  // but we include it here so that ASTContext can quickly deallocate them.\n  llvm::PointerIntPair<StoredDeclsMap *, 1> LastSDM;\n\n  std::vector<Decl *> TraversalScope;\n\n  std::unique_ptr<VTableContextBase> VTContext;\n\n  void ReleaseDeclContextMaps();\n\npublic:\n  enum PragmaSectionFlag : unsigned {\n    PSF_None = 0,\n    PSF_Read = 0x1,\n    PSF_Write = 0x2,\n    PSF_Execute = 0x4,\n    PSF_Implicit = 0x8,\n    PSF_ZeroInit = 0x10,\n    PSF_Invalid = 0x80000000U,\n  };\n\n  struct SectionInfo {\n    NamedDecl *Decl;\n    SourceLocation PragmaSectionLocation;\n    int SectionFlags;\n\n    SectionInfo() = default;\n    SectionInfo(NamedDecl *Decl, SourceLocation PragmaSectionLocation,\n                int SectionFlags)\n        : Decl(Decl), PragmaSectionLocation(PragmaSectionLocation),\n          SectionFlags(SectionFlags) {}\n  };\n\n  llvm::StringMap<SectionInfo> SectionInfos;\n\n  /// Return a new OMPTraitInfo object owned by this context.\n  OMPTraitInfo &getNewOMPTraitInfo();\n\n  /// Whether a C++ static variable or CUDA/HIP kernel may be externalized.\n  bool mayExternalize(const Decl *D) const;\n\n  /// Whether a C++ static variable or CUDA/HIP kernel should be externalized.\n  bool shouldExternalize(const Decl *D) const;\n\n  StringRef getCUIDHash() const;\n\nprivate:\n  /// All OMPTraitInfo objects live in this collection, one per\n  /// `pragma omp [begin] declare variant` directive.\n  SmallVector<std::unique_ptr<OMPTraitInfo>, 4> OMPTraitInfoVector;\n}",
  "id": "BLOCK-CPP-07064",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTContext.h",
  "source_line": 2629,
  "validation_status": "validated"
}