{
  "code": "#include <string>\n#include \"absl/base/config.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04733_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\n// Helper functions that allow throwing exceptions consistently from anywhere.\n// The main use case is for header-based libraries (eg templates), as they will\n// be built by many different targets with their own compiler options.\n// In particular, this will allow a safe way to throw exceptions even if the\n// caller is compiled with -fno-exceptions.  This is intended for implementing\n// things like map<>::at(), which the standard documents as throwing an\n// exception on error.\n//\n// Using other techniques like #if tricks could lead to ODR violations.\n//\n// You shouldn't use it unless you're writing code that you know will be built\n// both with and without exceptions and you need to conform to an interface\n// that uses exceptions.\n\n[[noreturn]] void ThrowStdLogicError(const std::string& what_arg);\n[[noreturn]] void ThrowStdLogicError(const char* what_arg);\n[[noreturn]] void ThrowStdInvalidArgument(const std::string& what_arg);\n[[noreturn]] void ThrowStdInvalidArgument(const char* what_arg);\n[[noreturn]] void ThrowStdDomainError(const std::string& what_arg);\n[[noreturn]] void ThrowStdDomainError(const char* what_arg);\n[[noreturn]] void ThrowStdLengthError(const std::string& what_arg);\n[[noreturn]] void ThrowStdLengthError(const char* what_arg);\n[[noreturn]] void ThrowStdOutOfRange(const std::string& what_arg);\n[[noreturn]] void ThrowStdOutOfRange(const char* what_arg);\n[[noreturn]] void ThrowStdRuntimeError(const std::string& what_arg);\n[[noreturn]] void ThrowStdRuntimeError(const char* what_arg);\n[[noreturn]] void ThrowStdRangeError(const std::string& what_arg);\n[[noreturn]] void ThrowStdRangeError(const char* what_arg);\n[[noreturn]] void ThrowStdOverflowError(const std::string& what_arg);\n[[noreturn]] void ThrowStdOverflowError(const char* what_arg);\n[[noreturn]] void ThrowStdUnderflowError(const std::string& what_arg);\n[[noreturn]] void ThrowStdUnderflowError(const char* what_arg);\n\n[[noreturn]] void ThrowStdBadFunctionCall();\n[[noreturn]] void ThrowStdBadAlloc();\n\n// ThrowStdBadArrayNewLength() cannot be consistently supported because\n// std::bad_array_new_length is missing in libstdc++ until 4.9.0.\n// https://gcc.gnu.org/onlinedocs/gcc-4.8.3/libstdc++/api/a01379_source.html\n// https://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01327_source.html\n// libcxx (as of 3.2) and msvc (as of 2015) both have it.\n// [[noreturn]] void ThrowStdBadArrayNewLength();\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04733",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/throw_delegate.h",
  "source_line": 24,
  "validation_status": "validated"
}