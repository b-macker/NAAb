{
  "code": "{\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Kind of the directive.\n  OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n  /// Starting location of the directive (directive keyword).\n  SourceLocation StartLoc;\n  /// Ending location of the directive.\n  SourceLocation EndLoc;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return std::nullopt;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive of class \\a K.\n  ///\n  /// \\param SC Statement class.\n  /// \\param K Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPExecutableDirective(StmtClass SC, OpenMPDirectiveKind K,\n                         SourceLocation StartLoc, SourceLocation EndLoc)\n      : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),\n        EndLoc(std::move(EndLoc)) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, ArrayRef<OMPClause *> Clauses,\n                            Stmt *AssociatedStmt, unsigned NumChildren,\n                            Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(Clauses.size(), AssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n\n    auto *Data = OMPChildren::Create(reinterpret_cast<T *>(Mem) + 1, Clauses,\n                                     AssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt, unsigned NumChildren,\n                                 Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt = false,\n                                 unsigned NumChildren = 0) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T;\n    Inst->Data = Data;\n    return Inst;\n  }\n\npublic:\n  /// Iterates over expressions/statements used in the construct.\n  class used_clauses_child_iterator\n      : public llvm::iterator_adaptor_base<\n            used_clauses_child_iterator, ArrayRef<OMPClause *>::iterator,\n            std::forward_iterator_tag, Stmt *, ptrdiff_t, Stmt *, Stmt *> {\n    ArrayRef<OMPClause *>::iterator End;\n    OMPClause::child_iterator ChildI, ChildEnd;\n\n    void MoveToNext() {\n      if (ChildI != ChildEnd)\n        return;\n      while (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n          if (ChildI != ChildEnd)\n            return;\n        }\n      }\n    }\n\n  public:\n    explicit used_clauses_child_iterator(ArrayRef<OMPClause *> Clauses)\n        : used_clauses_child_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      if (this->I != End) {\n        ChildI = (*this->I)->used_children().begin();\n        ChildEnd = (*this->I)->used_children().end();\n        MoveToNext();\n      }\n    }\n    Stmt *operator*() const { return *ChildI; }\n    Stmt *operator->() const { return **this; }\n\n    used_clauses_child_iterator &operator++() {\n      ++ChildI;\n      if (ChildI != ChildEnd)\n        return *this;\n      if (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n        }\n      }\n      MoveToNext();\n      return *this;\n    }\n  };\n\n  static llvm::iterator_range<used_clauses_child_iterator>\n  used_clauses_children(ArrayRef<OMPClause *> Clauses) {\n    return {\n        used_clauses_child_iterator(Clauses),\n        used_clauses_child_iterator(llvm::ArrayRef(Clauses.end(), (size_t)0))};\n  }\n\n  /// Iterates over a filtered subrange of clauses applied to a\n  /// directive.\n  ///\n  /// This iterator visits only clauses of type SpecificClause.\n  template <typename SpecificClause>\n  class specific_clause_iterator\n      : public llvm::iterator_adaptor_base<\n            specific_clause_iterator<SpecificClause>,\n            ArrayRef<OMPClause *>::const_iterator, std::forward_iterator_tag,\n            const SpecificClause *, ptrdiff_t, const SpecificClause *,\n            const SpecificClause *> {\n    ArrayRef<OMPClause *>::const_iterator End;\n\n    void SkipToNextClause() {\n      while (this->I != End && !isa<SpecificClause>(*this->I))\n        ++this->I;\n    }\n\n  public:\n    explicit specific_clause_iterator(ArrayRef<OMPClause *> Clauses)\n        : specific_clause_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      SkipToNextClause();\n    }\n\n    const SpecificClause *operator*() const {\n      return cast<SpecificClause>(*this->I);\n    }\n    const SpecificClause *operator->() const { return **this; }\n\n    specific_clause_iterator &operator++() {\n      ++this->I;\n      SkipToNextClause();\n      return *this;\n    }\n  };\n\n  template <typename SpecificClause>\n  static llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind(ArrayRef<OMPClause *> Clauses) {\n    return {specific_clause_iterator<SpecificClause>(Clauses),\n            specific_clause_iterator<SpecificClause>(\n                llvm::ArrayRef(Clauses.end(), (size_t)0))};\n  }\n\n  template <typename SpecificClause>\n  llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind() const {\n    return getClausesOfKind<SpecificClause>(clauses());\n  }\n\n  /// Gets a single clause of the specified kind associated with the\n  /// current directive iff there is only one clause of this kind (and assertion\n  /// is fired if there is more than one clause is associated with the\n  /// directive). Returns nullptr if no clause of this kind is associated with\n  /// the directive.\n  template <typename SpecificClause>\n  static const SpecificClause *getSingleClause(ArrayRef<OMPClause *> Clauses) {\n    auto ClausesOfKind = getClausesOfKind<SpecificClause>(Clauses);\n\n    if (ClausesOfKind.begin() != ClausesOfKind.end()) {\n      assert(std::next(ClausesOfKind.begin()) == ClausesOfKind.end() &&\n             \"There are at least 2 clauses of the specified kind\");\n      return *ClausesOfKind.begin();\n    }\n    return nullptr;\n  }\n\n  template <typename SpecificClause>\n  const SpecificClause *getSingleClause() const {\n    return getSingleClause<SpecificClause>(clauses());\n  }\n\n  /// Returns true if the current directive has one or more clauses of a\n  /// specific kind.\n  template <typename SpecificClause>\n  bool hasClausesOfKind() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n    return Clauses.begin() != Clauses.end();\n  }\n\n  /// Returns starting location of directive kind.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n  /// Returns ending location of directive.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Set starting location of directive kind.\n  ///\n  /// \\param Loc New starting location of directive.\n  ///\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n  /// Set ending location of directive.\n  ///\n  /// \\param Loc New ending location of directive.\n  ///\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  /// Returns true if directive has associated statement.\n  bool hasAssociatedStmt() const { return Data && Data->hasAssociatedStmt(); }\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getAssociatedStmt();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *getCapturedStmt(OpenMPDirectiveKind RegionKind) const {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getCapturedStmt(RegionKind, CaptureRegions);\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *getInnermostCapturedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getInnermostCapturedStmt(CaptureRegions);\n  }\n\n  const CapturedStmt *getInnermostCapturedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)\n        ->getInnermostCapturedStmt();\n  }\n\n  OpenMPDirectiveKind getDirectiveKind() const { return Kind; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstOMPExecutableDirectiveConstant &&\n           S->getStmtClass() <= lastOMPExecutableDirectiveConstant;\n  }\n\n  child_range children() {\n    if (!Data)\n      return child_range(child_iterator(), child_iterator());\n    return Data->getAssociatedStmtAsRange();\n  }\n\n  const_child_range children() const {\n    return const_cast<OMPExecutableDirective *>(this)->children();\n  }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return std::nullopt;\n    return Data->getClauses();\n  }\n\n  /// Returns whether or not this is a Standalone directive.\n  ///\n  /// Stand-alone directives are executable directives\n  /// that have no associated user code.\n  bool isStandaloneDirective() const;\n\n  /// Returns the AST node representing OpenMP structured-block of this\n  /// OpenMP executable directive,\n  /// Prerequisite: Executable Directive must not be Standalone directive.\n  const Stmt *getStructuredBlock() const {\n    return const_cast<OMPExecutableDirective *>(this)->getStructuredBlock();\n  }\n  Stmt *getStructuredBlock();\n\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getRawStmt();\n  }\n  Stmt *getRawStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getRawStmt();\n  }\n}",
  "id": "BLOCK-CPP-13359",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 266,
  "validation_status": "validated"
}