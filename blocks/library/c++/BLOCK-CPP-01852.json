{
  "code": "{\n  uint64_t man = input.mantissa;\n  int exp10 = input.exponent;\n  if (exp10 < FloatTraits<FloatType>::kEiselLemireMinInclusiveExp10) {\n    *value = negative ? -0.0 : 0.0;\n    *ec = std::errc::result_out_of_range;\n    return true;\n  } else if (exp10 >= FloatTraits<FloatType>::kEiselLemireMaxExclusiveExp10) {\n    // Return max (a finite value) consistent with from_chars and DR 3081. For\n    // SimpleAtod and SimpleAtof, post-processing will return infinity.\n    *value = negative ? -std::numeric_limits<FloatType>::max()\n                      : std::numeric_limits<FloatType>::max();\n    *ec = std::errc::result_out_of_range;\n    return true;\n  }\n\n  // Assert kPower10TableMinInclusive <= exp10 < kPower10TableMaxExclusive.\n  // Equivalently, !Power10Underflow(exp10) and !Power10Overflow(exp10).\n  static_assert(\n      FloatTraits<FloatType>::kEiselLemireMinInclusiveExp10 >=\n          kPower10TableMinInclusive,\n      \"(exp10-kPower10TableMinInclusive) in kPower10MantissaHighTable bounds\");\n  static_assert(\n      FloatTraits<FloatType>::kEiselLemireMaxExclusiveExp10 <=\n          kPower10TableMaxExclusive,\n      \"(exp10-kPower10TableMinInclusive) in kPower10MantissaHighTable bounds\");\n\n  // The terse (+) comments in this function body refer to sections of the\n  // https://nigeltao.github.io/blog/2020/eisel-lemire.html blog post.\n  //\n  // That blog post discusses double precision (11 exponent bits with a -1023\n  // bias, 52 mantissa bits), but the same approach applies to single precision\n  // (8 exponent bits with a -127 bias, 23 mantissa bits). Either way, the\n  // computation here happens with 64-bit values (e.g. man) or 128-bit values\n  // (e.g. x) before finally converting to 64- or 32-bit floating point.\n  //\n  // See also \"Number Parsing at a Gigabyte per Second, Software: Practice and\n  // Experience 51 (8), 2021\" (https://arxiv.org/abs/2101.11408) for detail.\n\n  // (+) Normalization.\n  int clz = countl_zero(man);\n  man <<= static_cast<unsigned int>(clz);\n  // The 217706 etc magic numbers are from the Power10Exponent function.\n  uint64_t ret_exp2 =\n      static_cast<uint64_t>((217706 * exp10 >> 16) + 64 +\n                            FloatTraits<FloatType>::kExponentBias - clz);\n\n  // (+) Multiplication.\n  uint128 x = static_cast<uint128>(man) *\n              static_cast<uint128>(\n                  kPower10MantissaHighTable[exp10 - kPower10TableMinInclusive]);\n\n  // (+) Wider Approximation.\n  static constexpr uint64_t high64_mask =\n      FloatTraits<FloatType>::kEiselLemireMask;\n  if (((Uint128High64(x) & high64_mask) == high64_mask) &&\n      (man > (std::numeric_limits<uint64_t>::max() - Uint128Low64(x)))) {\n    uint128 y =\n        static_cast<uint128>(man) *\n        static_cast<uint128>(\n            kPower10MantissaLowTable[exp10 - kPower10TableMinInclusive]);\n    x += Uint128High64(y);\n    // For example, parsing \"4503599627370497.5\" will take the if-true\n    // branch here (for double precision), since:\n    //  - x   = 0x8000000000000BFF_FFFFFFFFFFFFFFFF\n    //  - y   = 0x8000000000000BFF_7FFFFFFFFFFFF400\n    //  - man = 0xA000000000000F00\n    // Likewise, when parsing \"0.0625\" for single precision:\n    //  - x   = 0x7FFFFFFFFFFFFFFF_FFFFFFFFFFFFFFFF\n    //  - y   = 0x813FFFFFFFFFFFFF_8A00000000000000\n    //  - man = 0x9C40000000000000\n    if (((Uint128High64(x) & high64_mask) == high64_mask) &&\n        ((Uint128Low64(x) + 1) == 0) &&\n        (man > (std::numeric_limits<uint64_t>::max() - Uint128Low64(y)))) {\n      return false;\n    }\n  }\n\n  // (+) Shifting to 54 Bits (or for single precision, to 25 bits).\n  uint64_t msb = Uint128High64(x) >> 63;\n  uint64_t ret_man =\n      Uint128High64(x) >> (msb + FloatTraits<FloatType>::kEiselLemireShift);\n  ret_exp2 -= 1 ^ msb;\n\n  // (+) Half-way Ambiguity.\n  //\n  // For example, parsing \"1e+23\" will take the if-true branch here (for double\n  // precision), since:\n  //  - x       = 0x54B40B1F852BDA00_0000000000000000\n  //  - ret_man = 0x002A5A058FC295ED\n  // Likewise, when parsing \"20040229.0\" for single precision:\n  //  - x       = 0x4C72894000000000_0000000000000000\n  //  - ret_man = 0x000000000131CA25\n  if ((Uint128Low64(x) == 0) && ((Uint128High64(x) & high64_mask) == 0) &&\n      ((ret_man & 3) == 1)) {\n    return false;\n  }\n\n  // (+) From 54 to 53 Bits (or for single precision, from 25 to 24 bits).\n  ret_man += ret_man & 1;  // Line From54a.\n  ret_man >>= 1;           // Line From54b.\n  // Incrementing ret_man (at line From54a) may have overflowed 54 bits (53\n  // bits after the right shift by 1 at line From54b), so adjust for that.\n  //\n  // For example, parsing \"9223372036854775807\" will take the if-true branch\n  // here (for double precision), since:\n  //  - ret_man = 0x0020000000000000 = (1 << 53)\n  // Likewise, when parsing \"2147483647.0\" for single precision:\n  //  - ret_man = 0x0000000001000000 = (1 << 24)\n  if ((ret_man >> FloatTraits<FloatType>::kTargetMantissaBits) > 0) {\n    ret_exp2 += 1;\n    // Conceptually, we need a \"ret_man >>= 1\" in this if-block to balance\n    // incrementing ret_exp2 in the line immediately above. However, we only\n    // get here when line From54a overflowed (after adding a 1), so ret_man\n    // here is (1 << 53). Its low 53 bits are therefore all zeroes. The only\n    // remaining use of ret_man is to mask it with ((1 << 52) - 1), so only its\n    // low 52 bits matter. A \"ret_man >>= 1\" would have no effect in practice.\n    //\n    // We omit the \"ret_man >>= 1\", even if it is cheap (and this if-branch is\n    // rarely taken) and technically 'more correct', so that mutation tests\n    // that would otherwise modify or omit that \"ret_man >>= 1\" don't complain\n    // that such code mutations have no observable effect.\n  }\n\n  // ret_exp2 is a uint64_t. Zero or underflow means that we're in subnormal\n  // space. max_exp2 (0x7FF for double precision, 0xFF for single precision) or\n  // above means that we're in Inf/NaN space.\n  //\n  // The if block is equivalent to (but has fewer branches than):\n  //   if ((ret_exp2 <= 0) || (ret_exp2 >= max_exp2)) { etc }\n  //\n  // For example, parsing \"4.9406564584124654e-324\" will take the if-true\n  // branch here, since ret_exp2 = -51.\n  static constexpr uint64_t max_exp2 =\n      (1 << FloatTraits<FloatType>::kTargetExponentBits) - 1;\n  if ((ret_exp2 - 1) >= (max_exp2 - 1)) {\n    return false;\n  }\n\n#ifndef ABSL_BIT_PACK_FLOATS\n  if (FloatTraits<FloatType>::kTargetBits == 64) {\n    *value = FloatTraits<FloatType>::Make(\n        (ret_man & 0x000FFFFFFFFFFFFFu) | 0x0010000000000000u,\n        static_cast<int>(ret_exp2) - 1023 - 52, negative);\n    return true;\n  } else if (FloatTraits<FloatType>::kTargetBits == 32) {\n    *value = FloatTraits<FloatType>::Make(\n        (static_cast<uint32_t>(ret_man) & 0x007FFFFFu) | 0x00800000u,\n        static_cast<int>(ret_exp2) - 127 - 23, negative);\n    return true;\n  }\n#else\n  if (FloatTraits<FloatType>::kTargetBits == 64) {\n    uint64_t ret_bits = (ret_exp2 << 52) | (ret_man & 0x000FFFFFFFFFFFFFu);\n    if (negative) {\n      ret_bits |= 0x8000000000000000u;\n    }\n    *value = absl::bit_cast<double>(ret_bits);\n    return true;\n  } else if (FloatTraits<FloatType>::kTargetBits == 32) {\n    uint32_t ret_bits = (static_cast<uint32_t>(ret_exp2) << 23) |\n                        (static_cast<uint32_t>(ret_man) & 0x007FFFFFu);\n    if (negative) {\n      ret_bits |= 0x80000000u;\n    }\n    *value = absl::bit_cast<float>(ret_bits);\n    return true;\n  }\n#endif  // ABSL_BIT_PACK_FLOATS\n  return false;\n}",
  "id": "BLOCK-CPP-01852",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/charconv.cc",
  "source_line": 688,
  "validation_status": "validated"
}