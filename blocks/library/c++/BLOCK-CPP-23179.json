{
  "code": "{\n  // Idx is exposed only via accessors that specify specific encodings.\n  unsigned Idx : 30;\n  unsigned HasThis : 1;\n  unsigned IsValid : 1;\n\n  void assertComparable(const ParamIdx &I) const {\n    assert(isValid() && I.isValid() &&\n           \"ParamIdx must be valid to be compared\");\n    // It's possible to compare indices from separate functions, but so far\n    // it's not proven useful.  Moreover, it might be confusing because a\n    // comparison on the results of getASTIndex might be inconsistent with a\n    // comparison on the ParamIdx objects themselves.\n    assert(HasThis == I.HasThis &&\n           \"ParamIdx must be for the same function to be compared\");\n  }\n\npublic:\n  /// Construct an invalid parameter index (\\c isValid returns false and\n  /// accessors fail an assert).\n  ParamIdx() : Idx(0), HasThis(false), IsValid(false) {}\n\n  /// \\param Idx is the parameter index as it is normally specified in\n  /// attributes in the source: one-origin including any C++ implicit this\n  /// parameter.\n  ///\n  /// \\param D is the declaration containing the parameters.  It is used to\n  /// determine if there is a C++ implicit this parameter.\n  ParamIdx(unsigned Idx, const Decl *D)\n      : Idx(Idx), HasThis(false), IsValid(true) {\n    assert(Idx >= 1 && \"Idx must be one-origin\");\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      HasThis = FD->isCXXInstanceMember();\n  }\n\n  /// A type into which \\c ParamIdx can be serialized.\n  ///\n  /// A static assertion that it's of the correct size follows the \\c ParamIdx\n  /// class definition.\n  typedef uint32_t SerialType;\n\n  /// Produce a representation that can later be passed to \\c deserialize to\n  /// construct an equivalent \\c ParamIdx.\n  SerialType serialize() const {\n    return *reinterpret_cast<const SerialType *>(this);\n  }\n\n  /// Construct from a result from \\c serialize.\n  static ParamIdx deserialize(SerialType S) {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC7 and earlier.\n    void *ParamIdxPtr = static_cast<void *>(&S);\n    ParamIdx P(*static_cast<ParamIdx *>(ParamIdxPtr));\n    assert((!P.IsValid || P.Idx >= 1) && \"valid Idx must be one-origin\");\n    return P;\n  }\n\n  /// Is this parameter index valid?\n  bool isValid() const { return IsValid; }\n\n  /// Get the parameter index as it would normally be encoded for attributes at\n  /// the source level of representation: one-origin including any C++ implicit\n  /// this parameter.\n  ///\n  /// This encoding thus makes sense for diagnostics, pretty printing, and\n  /// constructing new attributes from a source-like specification.\n  unsigned getSourceIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    return Idx;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the AST level\n  /// of representation: zero-origin not including any C++ implicit this\n  /// parameter.\n  ///\n  /// This is the encoding primarily used in Sema.  However, in diagnostics,\n  /// Sema uses \\c getSourceIndex instead.\n  unsigned getASTIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 + HasThis &&\n           \"stored index must be base-1 and not specify C++ implicit this\");\n    return Idx - 1 - HasThis;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the LLVM level\n  /// of representation: zero-origin including any C++ implicit this parameter.\n  ///\n  /// This is the encoding primarily used in CodeGen.\n  unsigned getLLVMIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 && \"stored index must be base-1\");\n    return Idx - 1;\n  }\n\n  bool operator==(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx == I.Idx;\n  }\n  bool operator!=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx != I.Idx;\n  }\n  bool operator<(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx < I.Idx;\n  }\n  bool operator>(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx > I.Idx;\n  }\n  bool operator<=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx <= I.Idx;\n  }\n  bool operator>=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx >= I.Idx;\n  }\n}",
  "id": "BLOCK-CPP-23179",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Attr.h",
  "source_line": 242,
  "validation_status": "validated"
}