{
  "code": "{\n  ///   const int x = 10;\n  ///   auto L = [=](auto a) { // capture 'x'\n  ///      return [=](auto b) {\n  ///        f(x, a);  // we may or may not need to capture 'x'\n  ///      };\n  ///   };\n  /// }\n  void addPotentialCapture(Expr *VarExpr) {\n    assert(isa<DeclRefExpr>(VarExpr) || isa<MemberExpr>(VarExpr) ||\n           isa<FunctionParmPackExpr>(VarExpr));\n    PotentiallyCapturingExprs.push_back(VarExpr);\n  }\n\n  void addPotentialThisCapture(SourceLocation Loc) {\n    PotentialThisCaptureLocation = Loc;\n  }\n\n  bool hasPotentialThisCapture() const {\n    return PotentialThisCaptureLocation.isValid();\n  }\n\n  /// Mark a variable's reference in a lambda as non-odr using.\n  ///\n  /// For generic lambdas, if a variable is named in a potentially evaluated\n  /// expression, where the enclosing full expression is dependent then we\n  /// must capture the variable (given a default capture).\n  /// This is accomplished by recording all references to variables\n  /// (DeclRefExprs or MemberExprs) within said nested lambda in its array of\n  /// PotentialCaptures. All such variables have to be captured by that lambda,\n  /// except for as described below.\n  /// If that variable is usable as a constant expression and is named in a\n  /// manner that does not involve its odr-use (e.g. undergoes\n  /// lvalue-to-rvalue conversion, or discarded) record that it is so. Upon the\n  /// act of analyzing the enclosing full expression (ActOnFinishFullExpr)\n  /// if we can determine that the full expression is not instantiation-\n  /// dependent, then we can entirely avoid its capture.\n  ///\n  ///   const int n = 0;\n  ///   [&] (auto x) {\n  ///     (void)+n + x;\n  ///   };\n  /// Interestingly, this strategy would involve a capture of n, even though\n  /// it's obviously not odr-used here, because the full-expression is\n  /// instantiation-dependent.  It could be useful to avoid capturing such\n  /// variables, even when they are referred to in an instantiation-dependent\n  /// expression, if we can unambiguously determine that they shall never be\n  /// odr-used.  This would involve removal of the variable-referring-expression\n  /// from the array of PotentialCaptures during the lvalue-to-rvalue\n  /// conversions.  But per the working draft N3797, (post-chicago 2013) we must\n  /// capture such variables.\n  /// Before anyone is tempted to implement a strategy for not-capturing 'n',\n  /// consider the insightful warning in:\n  ///    /cfe-commits/Week-of-Mon-20131104/092596.html\n  /// \"The problem is that the set of captures for a lambda is part of the ABI\n  ///  (since lambda layout can be made visible through inline functions and the\n  ///  like), and there are no guarantees as to which cases we'll manage to build\n  ///  an lvalue-to-rvalue conversion in, when parsing a template -- some\n  ///  seemingly harmless change elsewhere in Sema could cause us to start or stop\n  ///  building such a node. So we need a rule that anyone can implement and get\n  ///  exactly the same result\".\n  void markVariableExprAsNonODRUsed(Expr *CapturingVarExpr) {\n    assert(isa<DeclRefExpr>(CapturingVarExpr) ||\n           isa<MemberExpr>(CapturingVarExpr) ||\n           isa<FunctionParmPackExpr>(CapturingVarExpr));\n    NonODRUsedCapturingExprs.insert(CapturingVarExpr);\n  }\n  bool isVariableExprMarkedAsNonODRUsed(Expr *CapturingVarExpr) const {\n    assert(isa<DeclRefExpr>(CapturingVarExpr) ||\n           isa<MemberExpr>(CapturingVarExpr) ||\n           isa<FunctionParmPackExpr>(CapturingVarExpr));\n    return NonODRUsedCapturingExprs.count(CapturingVarExpr);\n  }\n  void removePotentialCapture(Expr *E) {\n    llvm::erase_value(PotentiallyCapturingExprs, E);\n  }\n  void clearPotentialCaptures() {\n    PotentiallyCapturingExprs.clear();\n    PotentialThisCaptureLocation = SourceLocation();\n  }\n  unsigned getNumPotentialVariableCaptures() const {\n    return PotentiallyCapturingExprs.size();\n  }\n\n  bool hasPotentialCaptures() const {\n    return getNumPotentialVariableCaptures() ||\n                                  PotentialThisCaptureLocation.isValid();\n  }\n\n  void visitPotentialCaptures(\n      llvm::function_ref<void(ValueDecl *, Expr *)> Callback) const;\n}",
  "id": "BLOCK-CPP-20286",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ScopeInfo.h",
  "source_line": 954,
  "validation_status": "validated"
}