{
  "code": "{\n  // 768 is the number of digits needed in the worst case.  We could determine a\n  // better limit dynamically based on the value of parsed_decimal.exponent.\n  // This would optimize pathological input cases only.  (Sane inputs won't have\n  // hundreds of digits of mantissa.)\n  absl::strings_internal::BigUnsigned<84> exact_mantissa;\n  int exact_exponent = exact_mantissa.ReadFloatMantissa(parsed_decimal, 768);\n\n  // Adjust the `guess` arguments to be halfway between A and B.\n  guess_mantissa = guess_mantissa * 2 + 1;\n  guess_exponent -= 1;\n\n  // In our comparison:\n  // lhs = exact = exact_mantissa * 10**exact_exponent\n  //             = exact_mantissa * 5**exact_exponent * 2**exact_exponent\n  // rhs = guess = guess_mantissa * 2**guess_exponent\n  //\n  // Because we are doing integer math, we can't directly deal with negative\n  // exponents.  We instead move these to the other side of the inequality.\n  absl::strings_internal::BigUnsigned<84>& lhs = exact_mantissa;\n  int comparison;\n  if (exact_exponent >= 0) {\n    lhs.MultiplyByFiveToTheNth(exact_exponent);\n    absl::strings_internal::BigUnsigned<84> rhs(guess_mantissa);\n    // There are powers of 2 on both sides of the inequality; reduce this to\n    // a single bit-shift.\n    if (exact_exponent > guess_exponent) {\n      lhs.ShiftLeft(exact_exponent - guess_exponent);\n    } else {\n      rhs.ShiftLeft(guess_exponent - exact_exponent);\n    }\n    comparison = Compare(lhs, rhs);\n  } else {\n    // Move the power of 5 to the other side of the equation, giving us:\n    // lhs = exact_mantissa * 2**exact_exponent\n    // rhs = guess_mantissa * 5**(-exact_exponent) * 2**guess_exponent\n    absl::strings_internal::BigUnsigned<84> rhs =\n        absl::strings_internal::BigUnsigned<84>::FiveToTheNth(-exact_exponent);\n    rhs.MultiplyBy(guess_mantissa);\n    if (exact_exponent > guess_exponent) {\n      lhs.ShiftLeft(exact_exponent - guess_exponent);\n    } else {\n      rhs.ShiftLeft(guess_exponent - exact_exponent);\n    }\n    comparison = Compare(lhs, rhs);\n  }\n  if (comparison < 0) {\n    return false;\n  } else if (comparison > 0) {\n    return true;\n  } else {\n    // When lhs == rhs, the decimal input is exactly between A and B.\n    // Round towards even -- round up only if the low bit of the initial\n    // `guess_mantissa` was a 1.  We shifted guess_mantissa left 1 bit at\n    // the beginning of this function, so test the 2nd bit here.\n    return (guess_mantissa & 2) == 2;\n  }\n}",
  "id": "BLOCK-CPP-01846",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/charconv.cc",
  "source_line": 512,
  "validation_status": "validated"
}