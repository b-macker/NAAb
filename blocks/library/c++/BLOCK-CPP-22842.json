{
  "code": "#include \"clang/AST/DeclBase.h\" // lookup_result\n#include \"clang/AST/DeclarationName.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SetVector.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-22842_execute() {\n    {\n\nclass NamedDecl;\nclass DeclContext;\n\n// There are certain cases when normal C/C++ lookup (localUncachedLookup)\n// does not find AST nodes. E.g.:\n// Example 1:\n//   template <class T>\n//   struct X {\n//     friend void foo(); // this is never found in the DC of the TU.\n//   };\n// Example 2:\n//   // The fwd decl to Foo is not found in the lookupPtr of the DC of the\n//   // translation unit decl.\n//   // Here we could find the node by doing a traverse throught the list of\n//   // the Decls in the DC, but that would not scale.\n//   struct A { struct Foo *p; };\n// This is a severe problem because the importer decides if it has to create a\n// new Decl or not based on the lookup results.\n// To overcome these cases we need an importer specific lookup table which\n// holds every node and we are not interested in any C/C++ specific visibility\n// considerations. Simply, we must know if there is an existing Decl in a\n// given DC. Once we found it then we can handle any visibility related tasks.\nclass ASTImporterLookupTable {\n\n  // We store a list of declarations for each name.\n  // And we collect these lists for each DeclContext.\n  // We could have a flat map with (DeclContext, Name) tuple as key, but a two\n  // level map seems easier to handle.\n  using DeclList = llvm::SmallSetVector<NamedDecl *, 2>;\n  using NameMap = llvm::SmallDenseMap<DeclarationName, DeclList, 4>;\n  using DCMap = llvm::DenseMap<DeclContext *, NameMap>;\n\n  void add(DeclContext *DC, NamedDecl *ND);\n  void remove(DeclContext *DC, NamedDecl *ND);\n\n  DCMap LookupTable;\n\npublic:\n  ASTImporterLookupTable(TranslationUnitDecl &TU);\n  void add(NamedDecl *ND);\n  void remove(NamedDecl *ND);\n  // Sometimes a declaration is created first with a temporarily value of decl\n  // context (often the translation unit) and later moved to the final context.\n  // This happens for declarations that are created before the final declaration\n  // context. In such cases the lookup table needs to be updated.\n  // (The declaration is in these cases not added to the temporary decl context,\n  // only its parent is set.)\n  // FIXME: It would be better to not add the declaration to the temporary\n  // context at all in the lookup table, but this requires big change in\n  // ASTImporter.\n  // The function should be called when the old context is definitely different\n  // from the new.\n  void update(NamedDecl *ND, DeclContext *OldDC);\n  // Same as 'update' but allow if 'ND' is not in the table or the old context\n  // is the same as the new.\n  // FIXME: The old redeclaration context is not handled.\n  void updateForced(NamedDecl *ND, DeclContext *OldDC);\n  using LookupResult = DeclList;\n  LookupResult lookup(DeclContext *DC, DeclarationName Name) const;\n  // Check if the `ND` is within the lookup table (with its current name) in\n  // context `DC`. This is intended for debug purposes when the DeclContext of a\n  // NamedDecl is changed.\n  bool contains(DeclContext *DC, NamedDecl *ND) const;\n  void dump(DeclContext *DC) const;\n  void dump() const;\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-22842",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTImporterLookupTable.h",
  "source_line": 22,
  "validation_status": "validated"
}