{
  "code": "{\n  friend class Preprocessor;\n\n  void anchor() override;\n\n  //===--------------------------------------------------------------------===//\n  // Constant configuration values for this lexer.\n\n  // Start of the buffer.\n  const char *BufferStart;\n\n  // End of the buffer.\n  const char *BufferEnd;\n\n  // Location for start of file.\n  SourceLocation FileLoc;\n\n  // LangOpts enabled by this language.\n  // Storing LangOptions as reference here is important from performance point\n  // of view. Lack of reference means that LangOptions copy constructor would be\n  // called by Lexer(..., const LangOptions &LangOpts,...). Given that local\n  // Lexer objects are created thousands times (in Lexer::getRawToken,\n  // Preprocessor::EnterSourceFile and other places) during single module\n  // processing in frontend it would make std::vector<std::string> copy\n  // constructors surprisingly hot.\n  const LangOptions &LangOpts;\n\n  // True if '//' line comments are enabled.\n  bool LineComment;\n\n  // True if lexer for _Pragma handling.\n  bool Is_PragmaLexer;\n\n  //===--------------------------------------------------------------------===//\n  // Context-specific lexing flags set by the preprocessor.\n  //\n\n  /// ExtendedTokenMode - The lexer can optionally keep comments and whitespace\n  /// and return them as tokens.  This is used for -C and -CC modes, and\n  /// whitespace preservation can be useful for some clients that want to lex\n  /// the file in raw mode and get every character from the file.\n  ///\n  /// When this is set to 2 it returns comments and whitespace.  When set to 1\n  /// it returns comments, when it is set to 0 it returns normal tokens only.\n  unsigned char ExtendedTokenMode;\n\n  //===--------------------------------------------------------------------===//\n  // Context that changes as the file is lexed.\n  // NOTE: any state that mutates when in raw mode must have save/restore code\n  // in Lexer::isNextPPTokenLParen.\n\n  // BufferPtr - Current pointer into the buffer.  This is the next character\n  // to be lexed.\n  const char *BufferPtr;\n\n  // IsAtStartOfLine - True if the next lexed token should get the \"start of\n  // line\" flag set on it.\n  bool IsAtStartOfLine;\n\n  bool IsAtPhysicalStartOfLine;\n\n  bool HasLeadingSpace;\n\n  bool HasLeadingEmptyMacro;\n\n  /// True if this is the first time we're lexing the input file.\n  bool IsFirstTimeLexingFile;\n\n  // NewLinePtr - A pointer to new line character '\\n' being lexed. For '\\r\\n',\n  // it also points to '\\n.'\n  const char *NewLinePtr;\n\n  // CurrentConflictMarkerState - The kind of conflict marker we are handling.\n  ConflictMarkerKind CurrentConflictMarkerState;\n\n  /// Non-empty if this \\p Lexer is \\p isDependencyDirectivesLexer().\n  ArrayRef<dependency_directives_scan::Directive> DepDirectives;\n\n  /// If this \\p Lexer is \\p isDependencyDirectivesLexer(), it represents the\n  /// next token to use from the current dependency directive.\n  unsigned NextDepDirectiveTokenIndex = 0;\n\n  void InitLexer(const char *BufStart, const char *BufPtr, const char *BufEnd);\n\npublic:\n  /// Lexer constructor - Create a new lexer object for the specified buffer\n  /// with the specified preprocessor managing the lexing process.  This lexer\n  /// assumes that the associated file buffer and Preprocessor objects will\n  /// outlive it, so it doesn't take ownership of either of them.\n  Lexer(FileID FID, const llvm::MemoryBufferRef &InputFile, Preprocessor &PP,\n        bool IsFirstIncludeOfFile = true);\n\n  /// Lexer constructor - Create a new raw lexer object.  This object is only\n  /// suitable for calls to 'LexFromRawLexer'.  This lexer assumes that the\n  /// text range will outlive it, so it doesn't take ownership of it.\n  Lexer(SourceLocation FileLoc, const LangOptions &LangOpts,\n        const char *BufStart, const char *BufPtr, const char *BufEnd,\n        bool IsFirstIncludeOfFile = true);\n\n  /// Lexer constructor - Create a new raw lexer object.  This object is only\n  /// suitable for calls to 'LexFromRawLexer'.  This lexer assumes that the\n  /// text range will outlive it, so it doesn't take ownership of it.\n  Lexer(FileID FID, const llvm::MemoryBufferRef &FromFile,\n        const SourceManager &SM, const LangOptions &LangOpts,\n        bool IsFirstIncludeOfFile = true);\n\n  Lexer(const Lexer &) = delete;\n  Lexer &operator=(const Lexer &) = delete;\n\n  /// Create_PragmaLexer: Lexer constructor - Create a new lexer object for\n  /// _Pragma expansion.  This has a variety of magic semantics that this method\n  /// sets up.  It returns a new'd Lexer that must be delete'd when done.\n  static Lexer *Create_PragmaLexer(SourceLocation SpellingLoc,\n                                   SourceLocation ExpansionLocStart,\n                                   SourceLocation ExpansionLocEnd,\n                                   unsigned TokLen, Preprocessor &PP);\n\n  /// getFileLoc - Return the File Location for the file we are lexing out of.\n  /// The physical location encodes the location where the characters come from,\n  /// the virtual location encodes where we should *claim* the characters came\n  /// from.  Currently this is only used by _Pragma handling.\n  SourceLocation getFileLoc() const { return FileLoc; }\n\nprivate:\n  /// Lex - Return the next token in the file.  If this is the end of file, it\n  /// return the tok::eof token.  This implicitly involves the preprocessor.\n  bool Lex(Token &Result);\n\n  /// Called when the preprocessor is in 'dependency scanning lexing mode'.\n  bool LexDependencyDirectiveToken(Token &Result);\n\n  /// Called when the preprocessor is in 'dependency scanning lexing mode' and\n  /// is skipping a conditional block.\n  bool LexDependencyDirectiveTokenWhileSkipping(Token &Result);\n\n  /// True when the preprocessor is in 'dependency scanning lexing mode' and\n  /// created this \\p Lexer for lexing a set of dependency directive tokens.\n  bool isDependencyDirectivesLexer() const { return !DepDirectives.empty(); }\n\n  /// Initializes \\p Result with data from \\p DDTok and advances \\p BufferPtr to\n  /// the position just after the token.\n  /// \\returns the buffer pointer at the beginning of the token.\n  const char *convertDependencyDirectiveToken(\n      const dependency_directives_scan::Token &DDTok, Token &Result);\n\npublic:\n  /// isPragmaLexer - Returns true if this Lexer is being used to lex a pragma.\n  bool isPragmaLexer() const { return Is_PragmaLexer; }\n\nprivate:\n  /// IndirectLex - An indirect call to 'Lex' that can be invoked via\n  ///  the PreprocessorLexer interface.\n  void IndirectLex(Token &Result) override { Lex(Result); }\n\npublic:\n  /// LexFromRawLexer - Lex a token from a designated raw lexer (one with no\n  /// associated preprocessor object.  Return true if the 'next character to\n  /// read' pointer points at the end of the lexer buffer, false otherwise.\n  bool LexFromRawLexer(Token &Result) {\n    assert(LexingRawMode && \"Not already in raw mode!\");\n    Lex(Result);\n    // Note that lexing to the end of the buffer doesn't implicitly delete the\n    // lexer when in raw mode.\n    return BufferPtr == BufferEnd;\n  }\n\n  /// isKeepWhitespaceMode - Return true if the lexer should return tokens for\n  /// every character in the file, including whitespace and comments.  This\n  /// should only be used in raw mode, as the preprocessor is not prepared to\n  /// deal with the excess tokens.\n  bool isKeepWhitespaceMode() const {\n    return ExtendedTokenMode > 1;\n  }\n\n  /// SetKeepWhitespaceMode - This method lets clients enable or disable\n  /// whitespace retention mode.\n  void SetKeepWhitespaceMode(bool Val) {\n    assert((!Val || LexingRawMode || LangOpts.TraditionalCPP) &&\n           \"Can only retain whitespace in raw mode or -traditional-cpp\");\n    ExtendedTokenMode = Val ? 2 : 0;\n  }\n\n  /// inKeepCommentMode - Return true if the lexer should return comments as\n  /// tokens.\n  bool inKeepCommentMode() const {\n    return ExtendedTokenMode > 0;\n  }\n\n  /// SetCommentRetentionMode - Change the comment retention mode of the lexer\n  /// to the specified mode.  This is really only useful when lexing in raw\n  /// mode, because otherwise the lexer needs to manage this.\n  void SetCommentRetentionState(bool Mode) {\n    assert(!isKeepWhitespaceMode() &&\n           \"Can't play with comment retention state when retaining whitespace\");\n    ExtendedTokenMode = Mode ? 1 : 0;\n  }\n\n  /// Sets the extended token mode back to its initial value, according to the\n  /// language options and preprocessor. This controls whether the lexer\n  /// produces comment and whitespace tokens.\n  ///\n  /// This requires the lexer to have an associated preprocessor. A standalone\n  /// lexer has nothing to reset to.\n  void resetExtendedTokenMode();\n\n  /// Gets source code buffer.\n  StringRef getBuffer() const {\n    return StringRef(BufferStart, BufferEnd - BufferStart);\n  }\n\n  /// ReadToEndOfLine - Read the rest of the current preprocessor line as an\n  /// uninterpreted string.  This switches the lexer out of directive mode.\n  void ReadToEndOfLine(SmallVectorImpl<char> *Result = nullptr);\n\n\n  /// Diag - Forwarding function for diagnostics.  This translate a source\n  /// position in the current buffer into a SourceLocation object for rendering.\n  DiagnosticBuilder Diag(const char *Loc, unsigned DiagID) const;\n\n  /// getSourceLocation - Return a source location identifier for the specified\n  /// offset in the current file.\n  SourceLocation getSourceLocation(const char *Loc, unsigned TokLen = 1) const;\n\n  /// getSourceLocation - Return a source location for the next character in\n  /// the current file.\n  SourceLocation getSourceLocation() override {\n    return getSourceLocation(BufferPtr);\n  }\n\n  /// Return the current location in the buffer.\n  const char *getBufferLocation() const { return BufferPtr; }\n\n  /// Returns the current lexing offset.\n  unsigned getCurrentBufferOffset() {\n    assert(BufferPtr >= BufferStart && \"Invalid buffer state\");\n    return BufferPtr - BufferStart;\n  }\n\n  /// Set the lexer's buffer pointer to \\p Offset.\n  void seek(unsigned Offset, bool IsAtStartOfLine);\n\n  /// Stringify - Convert the specified string into a C string by i) escaping\n  /// '\\\\' and \" characters and ii) replacing newline character(s) with \"\\\\n\".\n  /// If Charify is true, this escapes the ' character instead of \".\n  static std::string Stringify(StringRef Str, bool Charify = false);\n\n  /// Stringify - Convert the specified string into a C string by i) escaping\n  /// '\\\\' and \" characters and ii) replacing newline character(s) with \"\\\\n\".\n  static void Stringify(SmallVectorImpl<char> &Str);\n\n  /// getSpelling - This method is used to get the spelling of a token into a\n  /// preallocated buffer, instead of as an std::string.  The caller is required\n  /// to allocate enough space for the token, which is guaranteed to be at least\n  /// Tok.getLength() bytes long.  The length of the actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  static unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                              const SourceManager &SourceMgr,\n                              const LangOptions &LangOpts,\n                              bool *Invalid = nullptr);\n\n  /// getSpelling() - Return the 'spelling' of the Tok token.  The spelling of a\n  /// token is the characters used to represent the token in the source file\n  /// after trigraph expansion and escaped-newline folding.  In particular, this\n  /// wants to get the true, uncanonicalized, spelling of things like digraphs\n  /// UCNs, etc.\n  static std::string getSpelling(const Token &Tok,\n                                 const SourceManager &SourceMgr,\n                                 const LangOptions &LangOpts,\n                                 bool *Invalid = nullptr);\n\n  /// getSpelling - This method is used to get the spelling of the\n  /// token at the given source location.  If, as is usually true, it\n  /// is not necessary to copy any data, then the returned string may\n  /// not point into the provided buffer.\n  ///\n  /// This method lexes at the expansion depth of the given\n  /// location and does not jump to the expansion or spelling\n  /// location.\n  static StringRef getSpelling(SourceLocation loc,\n                               SmallVectorImpl<char> &buffer,\n                               const SourceManager &SM,\n                               const LangOptions &options,\n                               bool *invalid = nullptr);\n\n  /// MeasureTokenLength - Relex the token at the specified location and return\n  /// its length in bytes in the input file.  If the token needs cleaning (e.g.\n  /// includes a trigraph or an escaped newline) then this count includes bytes\n  /// that are part of that.\n  static unsigned MeasureTokenLength(SourceLocation Loc,\n                                     const SourceManager &SM,\n                                     const LangOptions &LangOpts);\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  static bool getRawToken(SourceLocation Loc, Token &Result,\n                          const SourceManager &SM,\n                          const LangOptions &LangOpts,\n                          bool IgnoreWhiteSpace = false);\n\n  /// Given a location any where in a source buffer, find the location\n  /// that corresponds to the beginning of the token in which the original\n  /// source location lands.\n  static SourceLocation GetBeginningOfToken(SourceLocation Loc,\n                                            const SourceManager &SM,\n                                            const LangOptions &LangOpts);\n\n  /// Get the physical length (including trigraphs and escaped newlines) of the\n  /// first \\p Characters characters of the token starting at TokStart.\n  static unsigned getTokenPrefixLength(SourceLocation TokStart,\n                                       unsigned CharNo,\n                                       const SourceManager &SM,\n                                       const LangOptions &LangOpts);\n\n  /// AdvanceToTokenCharacter - If the current SourceLocation specifies a\n  /// location at the start of a token, return a new location that specifies a\n  /// character within the token.  This handles trigraphs and escaped newlines.\n  static SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                                unsigned Characters,\n                                                const SourceManager &SM,\n                                                const LangOptions &LangOpts) {\n    return TokStart.getLocWithOffset(\n        getTokenPrefixLength(TokStart, Characters, SM, LangOpts));\n  }\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  static SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset,\n                                            const SourceManager &SM,\n                                            const LangOptions &LangOpts);\n\n  /// Given a token range, produce a corresponding CharSourceRange that\n  /// is not a token range. This allows the source range to be used by\n  /// components that don't have access to the lexer and thus can't find the\n  /// end of the range for themselves.\n  static CharSourceRange getAsCharRange(SourceRange Range,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts) {\n    SourceLocation End = getLocForEndOfToken(Range.getEnd(), 0, SM, LangOpts);\n    return End.isInvalid() ? CharSourceRange()\n                           : CharSourceRange::getCharRange(\n                                 Range.getBegin(), End);\n  }\n  static CharSourceRange getAsCharRange(CharSourceRange Range,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts) {\n    return Range.isTokenRange()\n               ? getAsCharRange(Range.getAsRange(), SM, LangOpts)\n               : Range;\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  static bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts,\n                                        SourceLocation *MacroBegin = nullptr);\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  static bool isAtEndOfMacroExpansion(SourceLocation loc,\n                                      const SourceManager &SM,\n                                      const LangOptions &LangOpts,\n                                      SourceLocation *MacroEnd = nullptr);\n\n  /// Accepts a range and returns a character range with file locations.\n  ///\n  /// Returns a null range if a part of the range resides inside a macro\n  /// expansion or the range does not reside on the same FileID.\n  ///\n  /// This function is trying to deal with macros and return a range based on\n  /// file locations. The cases where it can successfully handle macros are:\n  ///\n  /// -begin or end range lies at the start or end of a macro expansion, in\n  ///  which case the location will be set to the expansion point, e.g:\n  ///    \\#define M 1 2\n  ///    a M\n  /// If you have a range [a, 2] (where 2 came from the macro), the function\n  /// will return a range for \"a M\"\n  /// if you have range [a, 1], the function will fail because the range\n  /// overlaps with only a part of the macro\n  ///\n  /// -The macro is a function macro and the range can be mapped to the macro\n  ///  arguments, e.g:\n  ///    \\#define M 1 2\n  ///    \\#define FM(x) x\n  ///    FM(a b M)\n  /// if you have range [b, 2], the function will return the file range \"b M\"\n  /// inside the macro arguments.\n  /// if you have range [a, 2], the function will return the file range\n  /// \"FM(a b M)\" since the range includes all of the macro expansion.\n  static CharSourceRange makeFileCharRange(CharSourceRange Range,\n                                           const SourceManager &SM,\n                                           const LangOptions &LangOpts);\n\n  /// Returns a string for the source that the range encompasses.\n  static StringRef getSourceText(CharSourceRange Range,\n                                 const SourceManager &SM,\n                                 const LangOptions &LangOpts,\n                                 bool *Invalid = nullptr);\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the macro\n  /// responsible for its immediate expansion. It looks through any intervening\n  /// macro argument expansions to compute this. It returns a StringRef which\n  /// refers to the SourceManager-owned buffer of the source where that macro\n  /// name is spelled. Thus, the result shouldn't out-live that SourceManager.\n  static StringRef getImmediateMacroName(SourceLocation Loc,\n                                         const SourceManager &SM,\n                                         const LangOptions &LangOpts);\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef which refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// that SourceManager.\n  ///\n  /// This differs from Lexer::getImmediateMacroName in that any macro argument\n  /// location will result in the topmost function macro that accepted it.\n  /// e.g.\n  /// \\code\n  ///   MAC1( MAC2(foo) )\n  /// \\endcode\n  /// for location of 'foo' token, this function will return \"MAC1\" while\n  /// Lexer::getImmediateMacroName will return \"MAC2\".\n  static StringRef getImmediateMacroNameForDiagnostics(\n      SourceLocation Loc, const SourceManager &SM, const LangOptions &LangOpts);\n\n  /// Compute the preamble of the given file.\n  ///\n  /// The preamble of a file contains the initial comments, include directives,\n  /// and other preprocessor directives that occur before the code in this\n  /// particular file actually begins. The preamble of the main source file is\n  /// a potential prefix header.\n  ///\n  /// \\param Buffer The memory buffer containing the file's contents.\n  ///\n  /// \\param MaxLines If non-zero, restrict the length of the preamble\n  /// to fewer than this number of lines.\n  ///\n  /// \\returns The offset into the file where the preamble ends and the rest\n  /// of the file begins along with a boolean value indicating whether\n  /// the preamble ends at the beginning of a new line.\n  static PreambleBounds ComputePreamble(StringRef Buffer,\n                                        const LangOptions &LangOpts,\n                                        unsigned MaxLines = 0);\n\n  /// Finds the token that comes right after the given location.\n  ///\n  /// Returns the next token, or std::nullopt if the location is inside a macro.\n  static std::optional<Token> findNextToken(SourceLocation Loc,\n                                            const SourceManager &SM,\n                                            const LangOptions &LangOpts);\n\n  /// Checks that the given token is the first token that occurs after\n  /// the given location (this excludes comments and whitespace). Returns the\n  /// location immediately after the specified token. If the token is not found\n  /// or the location is inside a macro, the returned source location will be\n  /// invalid.\n  static SourceLocation findLocationAfterToken(SourceLocation loc,\n                                         tok::TokenKind TKind,\n                                         const SourceManager &SM,\n                                         const LangOptions &LangOpts,\n                                         bool SkipTrailingWhitespaceAndNewLine);\n\n  /// Returns true if the given character could appear in an identifier.\n  static bool isAsciiIdentifierContinueChar(char c,\n                                            const LangOptions &LangOpts);\n\n  /// Checks whether new line pointed by Str is preceded by escape\n  /// sequence.\n  static bool isNewLineEscaped(const char *BufferStart, const char *Str);\n\n  /// getCharAndSizeNoWarn - Like the getCharAndSize method, but does not ever\n  /// emit a warning.\n  static inline char getCharAndSizeNoWarn(const char *Ptr, unsigned &Size,\n                                          const LangOptions &LangOpts) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) {\n      Size = 1;\n      return *Ptr;\n    }\n\n    Size = 0;\n    return getCharAndSizeSlowNoWarn(Ptr, Size, LangOpts);\n  }\n\n  /// Returns the leading whitespace for line that corresponds to the given\n  /// location \\p Loc.\n  static StringRef getIndentationForLine(SourceLocation Loc,\n                                         const SourceManager &SM);\n\n  /// Check if this is the first time we're lexing the input file.\n  bool isFirstTimeLexingFile() const { return IsFirstTimeLexingFile; }\n\nprivate:\n  //===--------------------------------------------------------------------===//\n  // Internal implementation interfaces.\n\n  /// LexTokenInternal - Internal interface to lex a preprocessing token. Called\n  /// by Lex.\n  ///\n  bool LexTokenInternal(Token &Result, bool TokAtPhysicalStartOfLine);\n\n  bool CheckUnicodeWhitespace(Token &Result, uint32_t C, const char *CurPtr);\n\n  bool LexUnicodeIdentifierStart(Token &Result, uint32_t C, const char *CurPtr);\n\n  /// FormTokenWithChars - When we lex a token, we have identified a span\n  /// starting at BufferPtr, going to TokEnd that forms the token.  This method\n  /// takes that range and assigns it to the token as its location and size.  In\n  /// addition, since tokens cannot overlap, this also updates BufferPtr to be\n  /// TokEnd.\n  void FormTokenWithChars(Token &Result, const char *TokEnd,\n                          tok::TokenKind Kind) {\n    unsigned TokLen = TokEnd-BufferPtr;\n    Result.setLength(TokLen);\n    Result.setLocation(getSourceLocation(BufferPtr, TokLen));\n    Result.setKind(Kind);\n    BufferPtr = TokEnd;\n  }\n\n  /// isNextPPTokenLParen - Return 1 if the next unexpanded token will return a\n  /// tok::l_paren token, 0 if it is something else and 2 if there are no more\n  /// tokens in the buffer controlled by this lexer.\n  unsigned isNextPPTokenLParen();\n\n  //===--------------------------------------------------------------------===//\n  // Lexer character reading interfaces.\n\n  // This lexer is built on two interfaces for reading characters, both of which\n  // automatically provide phase 1/2 translation.  getAndAdvanceChar is used\n  // when we know that we will be reading a character from the input buffer and\n  // that this character will be part of the result token. This occurs in (f.e.)\n  // string processing, because we know we need to read until we find the\n  // closing '\"' character.\n  //\n  // The second interface is the combination of getCharAndSize with\n  // ConsumeChar.  getCharAndSize reads a phase 1/2 translated character,\n  // returning it and its size.  If the lexer decides that this character is\n  // part of the current token, it calls ConsumeChar on it.  This two stage\n  // approach allows us to emit diagnostics for characters (e.g. warnings about\n  // trigraphs), knowing that they only are emitted if the character is\n  // consumed.\n\n  /// isObviouslySimpleCharacter - Return true if the specified character is\n  /// obviously the same in translation phase 1 and translation phase 3.  This\n  /// can return false for characters that end up being the same, but it will\n  /// never return true for something that needs to be mapped.\n  static bool isObviouslySimpleCharacter(char C) {\n    return C != '?' && C != '\\\\';\n  }\n\n  /// getAndAdvanceChar - Read a single 'character' from the specified buffer,\n  /// advance over it, and return it.  This is tricky in several cases.  Here we\n  /// just handle the trivial case and fall-back to the non-inlined\n  /// getCharAndSizeSlow method to handle the hard case.\n  inline char getAndAdvanceChar(const char *&Ptr, Token &Tok) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) return *Ptr++;\n\n    unsigned Size = 0;\n    char C = getCharAndSizeSlow(Ptr, Size, &Tok);\n    Ptr += Size;\n    return C;\n  }\n\n  /// ConsumeChar - When a character (identified by getCharAndSize) is consumed\n  /// and added to a given token, check to see if there are diagnostics that\n  /// need to be emitted or flags that need to be set on the token.  If so, do\n  /// it.\n  const char *ConsumeChar(const char *Ptr, unsigned Size, Token &Tok) {\n    // Normal case, we consumed exactly one token.  Just return it.\n    if (Size == 1)\n      return Ptr+Size;\n\n    // Otherwise, re-lex the character with a current token, allowing\n    // diagnostics to be emitted and flags to be set.\n    Size = 0;\n    getCharAndSizeSlow(Ptr, Size, &Tok);\n    return Ptr+Size;\n  }\n\n  /// getCharAndSize - Peek a single 'character' from the specified buffer,\n  /// get its size, and return it.  This is tricky in several cases.  Here we\n  /// just handle the trivial case and fall-back to the non-inlined\n  /// getCharAndSizeSlow method to handle the hard case.\n  inline char getCharAndSize(const char *Ptr, unsigned &Size) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) {\n      Size = 1;\n      return *Ptr;\n    }\n\n    Size = 0;\n    return getCharAndSizeSlow(Ptr, Size);\n  }\n\n  /// getCharAndSizeSlow - Handle the slow/uncommon case of the getCharAndSize\n  /// method.\n  char getCharAndSizeSlow(const char *Ptr, unsigned &Size,\n                          Token *Tok = nullptr);\n\n  /// getEscapedNewLineSize - Return the size of the specified escaped newline,\n  /// or 0 if it is not an escaped newline. P[-1] is known to be a \"\\\" on entry\n  /// to this function.\n  static unsigned getEscapedNewLineSize(const char *P);\n\n  /// SkipEscapedNewLines - If P points to an escaped newline (or a series of\n  /// them), skip over them and return the first non-escaped-newline found,\n  /// otherwise return P.\n  static const char *SkipEscapedNewLines(const char *P);\n\n  /// getCharAndSizeSlowNoWarn - Same as getCharAndSizeSlow, but never emits a\n  /// diagnostic.\n  static char getCharAndSizeSlowNoWarn(const char *Ptr, unsigned &Size,\n                                       const LangOptions &LangOpts);\n\n  //===--------------------------------------------------------------------===//\n  // Other lexer functions.\n\n  void SetByteOffset(unsigned Offset, bool StartOfLine);\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  const char *LexUDSuffix(Token &Result, const char *CurPtr,\n                          bool IsStringLiteral);\n\n  // Helper functions to lex the remainder of a token of the specific type.\n\n  // This function handles both ASCII and Unicode identifiers after\n  // the first codepoint of the identifyier has been parsed.\n  bool LexIdentifierContinue(Token &Result, const char *CurPtr);\n\n  bool LexNumericConstant    (Token &Result, const char *CurPtr);\n  bool LexStringLiteral      (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexRawStringLiteral   (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexAngledStringLiteral(Token &Result, const char *CurPtr);\n  bool LexCharConstant       (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexEndOfFile          (Token &Result, const char *CurPtr);\n  bool SkipWhitespace        (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SkipLineComment       (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SkipBlockComment      (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SaveLineComment       (Token &Result, const char *CurPtr);\n\n  bool IsStartOfConflictMarker(const char *CurPtr);\n  bool HandleEndOfConflictMarker(const char *CurPtr);\n\n  bool lexEditorPlaceholder(Token &Result, const char *CurPtr);\n\n  bool isCodeCompletionPoint(const char *CurPtr) const;\n  void cutOffLexing() { BufferPtr = BufferEnd; }\n\n  bool isHexaLiteral(const char *Start, const LangOptions &LangOpts);\n\n  void codeCompleteIncludedFile(const char *PathStart,\n                                const char *CompletionPoint, bool IsAngled);\n\n  std::optional<uint32_t>\n  tryReadNumericUCN(const char *&StartPtr, const char *SlashLoc, Token *Result);\n  std::optional<uint32_t> tryReadNamedUCN(const char *&StartPtr,\n                                          const char *SlashLoc, Token *Result);\n\n  /// Read a universal character name.\n  ///\n  /// \\param StartPtr The position in the source buffer after the initial '\\'.\n  ///                 If the UCN is syntactically well-formed (but not\n  ///                 necessarily valid), this parameter will be updated to\n  ///                 point to the character after the UCN.\n  /// \\param SlashLoc The position in the source buffer of the '\\'.\n  /// \\param Result   The token being formed. Pass \\c nullptr to suppress\n  ///                 diagnostics and handle token formation in the caller.\n  ///\n  /// \\return The Unicode codepoint specified by the UCN, or 0 if the UCN is\n  ///         invalid.\n  uint32_t tryReadUCN(const char *&StartPtr, const char *SlashLoc, Token *Result);\n\n  /// Try to consume a UCN as part of an identifier at the current\n  /// location.\n  /// \\param CurPtr Initially points to the range of characters in the source\n  ///               buffer containing the '\\'. Updated to point past the end of\n  ///               the UCN on success.\n  /// \\param Size The number of characters occupied by the '\\' (including\n  ///             trigraphs and escaped newlines).\n  /// \\param Result The token being produced. Marked as containing a UCN on\n  ///               success.\n  /// \\return \\c true if a UCN was lexed and it produced an acceptable\n  ///         identifier character, \\c false otherwise.\n  bool tryConsumeIdentifierUCN(const char *&CurPtr, unsigned Size,\n                               Token &Result);\n\n  /// Try to consume an identifier character encoded in UTF-8.\n  /// \\param CurPtr Points to the start of the (potential) UTF-8 code unit\n  ///        sequence. On success, updated to point past the end of it.\n  /// \\return \\c true if a UTF-8 sequence mapping to an acceptable identifier\n  ///         character was lexed, \\c false otherwise.\n  bool tryConsumeIdentifierUTF8Char(const char *&CurPtr);\n}",
  "id": "BLOCK-CPP-18642",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/Lexer.h",
  "source_line": 78,
  "validation_status": "validated"
}