{
  "code": "#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/atomic_hook.h\"\n#include \"absl/base/log_severity.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/base/port.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04703_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace raw_log_internal {\n\n// Helper function to implement ABSL_RAW_LOG\n// Logs format... at \"severity\" level, reporting it\n// as called from file:line.\n// This does not allocate memory or acquire locks.\nvoid RawLog(absl::LogSeverity severity, const char* file, int line,\n            const char* format, ...) ABSL_PRINTF_ATTRIBUTE(4, 5);\n\n// Writes the provided buffer directly to stderr, in a signal-safe, low-level\n// manner.  Preserves errno.\nvoid AsyncSignalSafeWriteError(const char* s, size_t len);\n\n// compile-time function to get the \"base\" filename, that is, the part of\n// a filename after the last \"/\" or \"\\\" path separator.  The search starts at\n// the end of the string; the second parameter is the length of the string.\nconstexpr const char* Basename(const char* fname, int offset) {\n  return offset == 0 || fname[offset - 1] == '/' || fname[offset - 1] == '\\\\'\n             ? fname + offset\n             : Basename(fname, offset - 1);\n}\n\n// For testing only.\n// Returns true if raw logging is fully supported. When it is not\n// fully supported, no messages will be emitted, but a log at FATAL\n// severity will cause an abort.\n//\n// TODO(gfalcon): Come up with a better name for this method.\nbool RawLoggingFullySupported();\n\n// Function type for a raw_log customization hook for suppressing messages\n// by severity, and for writing custom prefixes on non-suppressed messages.\n//\n// The installed hook is called for every raw log invocation.  The message will\n// be logged to stderr only if the hook returns true.  FATAL errors will cause\n// the process to abort, even if writing to stderr is suppressed.  The hook is\n// also provided with an output buffer, where it can write a custom log message\n// prefix.\n//\n// The raw_log system does not allocate memory or grab locks.  User-provided\n// hooks must avoid these operations, and must not throw exceptions.\n//\n// 'severity' is the severity level of the message being written.\n// 'file' and 'line' are the file and line number where the ABSL_RAW_LOG macro\n// was located.\n// 'buf' and 'buf_size' are pointers to the buffer and buffer size.  If the\n// hook writes a prefix, it must increment *buf and decrement *buf_size\n// accordingly.\nusing LogFilterAndPrefixHook = bool (*)(absl::LogSeverity severity,\n                                        const char* file, int line, char** buf,\n                                        int* buf_size);\n\n// Function type for a raw_log customization hook called to abort a process\n// when a FATAL message is logged.  If the provided AbortHook() returns, the\n// logging system will call abort().\n//\n// 'file' and 'line' are the file and line number where the ABSL_RAW_LOG macro\n// was located.\n// The NUL-terminated logged message lives in the buffer between 'buf_start'\n// and 'buf_end'.  'prefix_end' points to the first non-prefix character of the\n// buffer (as written by the LogFilterAndPrefixHook.)\n//\n// The lifetime of the filename and message buffers will not end while the\n// process remains alive.\nusing AbortHook = void (*)(const char* file, int line, const char* buf_start,\n                           const char* prefix_end, const char* buf_end);\n\n// Internal logging function for ABSL_INTERNAL_LOG to dispatch to.\n//\n// TODO(gfalcon): When string_view no longer depends on base, change this\n// interface to take its message as a string_view instead.\nusing InternalLogFunction = void (*)(absl::LogSeverity severity,\n                                     const char* file, int line,\n                                     const std::string& message);\n\nABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES ABSL_DLL extern base_internal::AtomicHook<\n    InternalLogFunction>\n    internal_log_function;\n\n// Registers hooks of the above types.  Only a single hook of each type may be\n// registered.  It is an error to call these functions multiple times with\n// different input arguments.\n//\n// These functions are safe to call at any point during initialization; they do\n// not block or malloc, and are async-signal safe.\nvoid RegisterLogFilterAndPrefixHook(LogFilterAndPrefixHook func);\nvoid RegisterAbortHook(AbortHook func);\nvoid RegisterInternalLogFunction(InternalLogFunction func);\n\n}  // namespace raw_log_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04703",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/raw_logging.h",
  "source_line": 122,
  "validation_status": "validated"
}