{
  "code": "{\n//       auto found = text.find(c_, pos);\n//       if (found == absl::string_view::npos)\n//         return text.substr(text.size());\n//\n//       return text.substr(found, 1);\n//     }\n//   };\n\n// ByString\n//\n// A sub-string delimiter. If `StrSplit()` is passed a string in place of a\n// `Delimiter` object, the string will be implicitly converted into a\n// `ByString` delimiter.\n//\n// Example:\n//\n//   // Because a string literal is converted to an `absl::ByString`,\n//   // the following two splits are equivalent.\n//\n//   std::vector<std::string> v1 = absl::StrSplit(\"a, b, c\", \", \");\n//\n//   using absl::ByString;\n//   std::vector<std::string> v2 = absl::StrSplit(\"a, b, c\",\n//                                                ByString(\", \"));\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\"\nclass ByString {\n public:\n  explicit ByString(absl::string_view sp);\n  absl::string_view Find(absl::string_view text, size_t pos) const;\n\n private:\n  const std::string delimiter_;\n};\n\n// ByAsciiWhitespace\n//\n// A sub-string delimiter that splits by ASCII whitespace\n// (space, tab, vertical tab, formfeed, linefeed, or carriage return).\n// Note: you probably want to use absl::SkipEmpty() as well!\n//\n// This class is equivalent to ByAnyChar with ASCII whitespace chars.\n//\n// Example:\n//\n//   std::vector<std::string> v = absl::StrSplit(\n//       \"a b\\tc\\n  d  \\n\", absl::ByAsciiWhitespace(), absl::SkipEmpty());\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\", v[3] == \"d\"\nclass ByAsciiWhitespace {\n public:\n  absl::string_view Find(absl::string_view text, size_t pos) const;\n};\n\n// ByChar\n//\n// A single character delimiter. `ByChar` is functionally equivalent to a\n// 1-char string within a `ByString` delimiter, but slightly more efficient.\n//\n// Example:\n//\n//   // Because a char literal is converted to a absl::ByChar,\n//   // the following two splits are equivalent.\n//   std::vector<std::string> v1 = absl::StrSplit(\"a,b,c\", ',');\n//   using absl::ByChar;\n//   std::vector<std::string> v2 = absl::StrSplit(\"a,b,c\", ByChar(','));\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\"\n//\n// `ByChar` is also the default delimiter if a single character is given\n// as the delimiter to `StrSplit()`. For example, the following calls are\n// equivalent:\n//\n//   std::vector<std::string> v = absl::StrSplit(\"a-b\", '-');\n//\n//   using absl::ByChar;\n//   std::vector<std::string> v = absl::StrSplit(\"a-b\", ByChar('-'));\n//\nclass ByChar {\n public:\n  explicit ByChar(char c) : c_(c) {}\n  absl::string_view Find(absl::string_view text, size_t pos) const;\n\n private:\n  char c_;\n};\n\n// ByAnyChar\n//\n// A delimiter that will match any of the given byte-sized characters within\n// its provided string.\n//\n// Note: this delimiter works with single-byte string data, but does not work\n// with variable-width encodings, such as UTF-8.\n//\n// Example:\n//\n//   using absl::ByAnyChar;\n//   std::vector<std::string> v = absl::StrSplit(\"a,b=c\", ByAnyChar(\",=\"));\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\"\n//\n// If `ByAnyChar` is given the empty string, it behaves exactly like\n// `ByString` and matches each individual character in the input string.\n//\nclass ByAnyChar {\n public:\n  explicit ByAnyChar(absl::string_view sp);\n  absl::string_view Find(absl::string_view text, size_t pos) const;\n\n private:\n  const std::string delimiters_;\n};\n\n// ByLength\n//\n// A delimiter for splitting into equal-length strings. The length argument to\n// the constructor must be greater than 0.\n//\n// Note: this delimiter works with single-byte string data, but does not work\n// with variable-width encodings, such as UTF-8.\n//\n// Example:\n//\n//   using absl::ByLength;\n//   std::vector<std::string> v = absl::StrSplit(\"123456789\", ByLength(3));\n\n//   // v[0] == \"123\", v[1] == \"456\", v[2] == \"789\"\n//\n// Note that the string does not have to be a multiple of the fixed split\n// length. In such a case, the last substring will be shorter.\n//\n//   using absl::ByLength;\n//   std::vector<std::string> v = absl::StrSplit(\"12345\", ByLength(2));\n//\n//   // v[0] == \"12\", v[1] == \"34\", v[2] == \"5\"\nclass ByLength {\n public:\n  explicit ByLength(ptrdiff_t length);\n  absl::string_view Find(absl::string_view text, size_t pos) const;\n\n private:\n  const ptrdiff_t length_;\n};\n\nnamespace strings_internal {\n\n// A traits-like metafunction for selecting the default Delimiter object type\n// for a particular Delimiter type. The base case simply exposes type Delimiter\n// itself as the delimiter's Type. However, there are specializations for\n// string-like objects that map them to the ByString delimiter object.\n// This allows functions like absl::StrSplit() and absl::MaxSplits() to accept\n// string-like objects (e.g., ',') as delimiter arguments but they will be\n// treated as if a ByString delimiter was given.\ntemplate <typename Delimiter>\nstruct SelectDelimiter {\n  using type = Delimiter;\n};\n\ntemplate <>\nstruct SelectDelimiter<char> {\n  using type = ByChar;\n};\ntemplate <>\nstruct SelectDelimiter<char*> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<const char*> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<absl::string_view> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<std::string> {\n  using type = ByString;\n};\n\n// Wraps another delimiter and sets a max number of matches for that delimiter.\ntemplate <typename Delimiter>\nclass MaxSplitsImpl {\n public:\n  MaxSplitsImpl(Delimiter delimiter, int limit)\n      : delimiter_(delimiter), limit_(limit), count_(0) {}\n  absl::string_view Find(absl::string_view text, size_t pos) {\n    if (count_++ == limit_) {\n      return absl::string_view(text.data() + text.size(),\n                               0);  // No more matches.\n    }\n    return delimiter_.Find(text, pos);\n  }\n\n private:\n  Delimiter delimiter_;\n  const int limit_;\n  int count_;\n};\n\n}  // namespace strings_internal\n\n// MaxSplits()\n//\n// A delimiter that limits the number of matches which can occur to the passed\n// `limit`. The last element in the returned collection will contain all\n// remaining unsplit pieces, which may contain instances of the delimiter.\n// The collection will contain at most `limit` + 1 elements.\n// Example:\n//\n//   using absl::MaxSplits;\n//   std::vector<std::string> v = absl::StrSplit(\"a,b,c\", MaxSplits(',', 1));\n//\n//   // v[0] == \"a\", v[1] == \"b,c\"\ntemplate <typename Delimiter>\ninline strings_internal::MaxSplitsImpl<\n    typename strings_internal::SelectDelimiter<Delimiter>::type>\nMaxSplits(Delimiter delimiter, int limit) {\n  typedef\n      typename strings_internal::SelectDelimiter<Delimiter>::type DelimiterType;\n  return strings_internal::MaxSplitsImpl<DelimiterType>(\n      DelimiterType(delimiter), limit);\n}\n\n//------------------------------------------------------------------------------\n// Predicates\n//------------------------------------------------------------------------------\n//\n// Predicates filter the results of a `StrSplit()` by determining whether or not\n// a resultant element is included in the result set. A predicate may be passed\n// as an optional third argument to the `StrSplit()` function.\n//\n// Predicates are unary functions (or functors) that take a single\n// `absl::string_view` argument and return a bool indicating whether the\n// argument should be included (`true`) or excluded (`false`).\n//\n// Predicates are useful when filtering out empty substrings. By default, empty\n// substrings may be returned by `StrSplit()`, which is similar to the way split\n// functions work in other programming languages.\n\n// AllowEmpty()\n//\n// Always returns `true`, indicating that all strings--including empty\n// strings--should be included in the split output. This predicate is not\n// strictly needed because this is the default behavior of `StrSplit()`;\n// however, it might be useful at some call sites to make the intent explicit.\n//\n// Example:\n//\n//  std::vector<std::string> v = absl::StrSplit(\" a , ,,b,\", ',', AllowEmpty());\n//\n//  // v[0] == \" a \", v[1] == \" \", v[2] == \"\", v[3] = \"b\", v[4] == \"\"\nstruct AllowEmpty {\n  bool operator()(absl::string_view) const { return true; }\n};\n\n// SkipEmpty()\n//\n// Returns `false` if the given `absl::string_view` is empty, indicating that\n// `StrSplit()` should omit the empty string.\n//\n// Example:\n//\n//   std::vector<std::string> v = absl::StrSplit(\",a,,b,\", ',', SkipEmpty());\n//\n//   // v[0] == \"a\", v[1] == \"b\"\n//\n// Note: `SkipEmpty()` does not consider a string containing only whitespace\n// to be empty. To skip such whitespace as well, use the `SkipWhitespace()`\n// predicate.\nstruct SkipEmpty {\n  bool operator()(absl::string_view sp) const { return !sp.empty(); }\n};\n\n// SkipWhitespace()\n//\n// Returns `false` if the given `absl::string_view` is empty *or* contains only\n// whitespace, indicating that `StrSplit()` should omit the string.\n//\n// Example:\n//\n//   std::vector<std::string> v = absl::StrSplit(\" a , ,,b,\",\n//                                               ',', SkipWhitespace());\n//   // v[0] == \" a \", v[1] == \"b\"\n//\n//   // SkipEmpty() would return whitespace elements\n//   std::vector<std::string> v = absl::StrSplit(\" a , ,,b,\", ',', SkipEmpty());\n//   // v[0] == \" a \", v[1] == \" \", v[2] == \"b\"\nstruct SkipWhitespace {\n  bool operator()(absl::string_view sp) const {\n    sp = absl::StripAsciiWhitespace(sp);\n    return !sp.empty();\n  }\n};\n\ntemplate <typename T>\nusing EnableSplitIfString =\n    typename std::enable_if<std::is_same<T, std::string>::value ||\n                            std::is_same<T, const std::string>::value,\n                            int>::type;\n\n//------------------------------------------------------------------------------\n//                                  StrSplit()\n//------------------------------------------------------------------------------\n\n// StrSplit()\n//\n// Splits a given string based on the provided `Delimiter` object, returning the\n// elements within the type specified by the caller. Optionally, you may pass a\n// `Predicate` to `StrSplit()` indicating whether to include or exclude the\n// resulting element within the final result set. (See the overviews for\n// Delimiters and Predicates above.)\n//\n// Example:\n//\n//   std::vector<std::string> v = absl::StrSplit(\"a,b,c,d\", ',');\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\", v[3] == \"d\"\n//\n// You can also provide an explicit `Delimiter` object:\n//\n// Example:\n//\n//   using absl::ByAnyChar;\n//   std::vector<std::string> v = absl::StrSplit(\"a,b=c\", ByAnyChar(\",=\"));\n//   // v[0] == \"a\", v[1] == \"b\", v[2] == \"c\"\n//\n// See above for more information on delimiters.\n//\n// By default, empty strings are included in the result set. You can optionally\n// include a third `Predicate` argument to apply a test for whether the\n// resultant element should be included in the result set:\n//\n// Example:\n//\n//   std::vector<std::string> v = absl::StrSplit(\" a , ,,b,\",\n//                                               ',', SkipWhitespace());\n//   // v[0] == \" a \", v[1] == \"b\"\n//\n// See above for more information on predicates.\n//\n//------------------------------------------------------------------------------\n// StrSplit() Return Types\n//------------------------------------------------------------------------------\n//\n// The `StrSplit()` function adapts the returned collection to the collection\n// specified by the caller (e.g. `std::vector` above). The returned collections\n// may contain `std::string`, `absl::string_view` (in which case the original\n// string being split must ensure that it outlives the collection), or any\n// object that can be explicitly created from an `absl::string_view`. This\n// behavior works for:\n//\n// 1) All standard STL containers including `std::vector`, `std::list`,\n//    `std::deque`, `std::set`,`std::multiset`, 'std::map`, and `std::multimap`\n// 2) `std::pair` (which is not actually a container). See below.\n//\n// Example:\n//\n//   // The results are returned as `absl::string_view` objects. Note that we\n//   // have to ensure that the input string outlives any results.\n//   std::vector<absl::string_view> v = absl::StrSplit(\"a,b,c\", ',');\n//\n//   // Stores results in a std::set<std::string>, which also performs\n//   // de-duplication and orders the elements in ascending order.\n//   std::set<std::string> a = absl::StrSplit(\"b,a,c,a,b\", ',');\n//   // v[0] == \"a\", v[1] == \"b\", v[2] = \"c\"\n//\n//   // `StrSplit()` can be used within a range-based for loop, in which case\n//   // each element will be of type `absl::string_view`.\n//   std::vector<std::string> v;\n//   for (const auto sv : absl::StrSplit(\"a,b,c\", ',')) {\n//     if (sv != \"b\") v.emplace_back(sv);\n//   }\n//   // v[0] == \"a\", v[1] == \"c\"\n//\n//   // Stores results in a map. The map implementation assumes that the input\n//   // is provided as a series of key/value pairs. For example, the 0th element\n//   // resulting from the split will be stored as a key to the 1st element. If\n//   // an odd number of elements are resolved, the last element is paired with\n//   // a default-constructed value (e.g., empty string).\n//   std::map<std::string, std::string> m = absl::StrSplit(\"a,b,c\", ',');\n//   // m[\"a\"] == \"b\", m[\"c\"] == \"\"     // last component value equals \"\"\n//\n// Splitting to `std::pair` is an interesting case because it can hold only two\n// elements and is not a collection type. When splitting to a `std::pair` the\n// first two split strings become the `std::pair` `.first` and `.second`\n// members, respectively. The remaining split substrings are discarded. If there\n// are less than two split substrings, the empty string is used for the\n// corresponding `std::pair` member.\n//\n// Example:\n//\n//   // Stores first two split strings as the members in a std::pair.\n//   std::pair<std::string, std::string> p = absl::StrSplit(\"a,b,c\", ',');\n//   // p.first == \"a\", p.second == \"b\"       // \"c\" is omitted.\n//\n// The `StrSplit()` function can be used multiple times to perform more\n// complicated splitting logic, such as intelligently parsing key-value pairs.\n//\n// Example:\n//\n//   // The input string \"a=b=c,d=e,f=,g\" becomes\n//   // { \"a\" => \"b=c\", \"d\" => \"e\", \"f\" => \"\", \"g\" => \"\" }\n//   std::map<std::string, std::string> m;\n//   for (absl::string_view sp : absl::StrSplit(\"a=b=c,d=e,f=,g\", ',')) {\n//     m.insert(absl::StrSplit(sp, absl::MaxSplits('=', 1)));\n//   }\n//   EXPECT_EQ(\"b=c\", m.find(\"a\")->second);\n//   EXPECT_EQ(\"e\", m.find(\"d\")->second);\n//   EXPECT_EQ(\"\", m.find(\"f\")->second);\n//   EXPECT_EQ(\"\", m.find(\"g\")->second);\n//\n// WARNING: Due to a legacy bug that is maintained for backward compatibility,\n// splitting the following empty string_views produces different results:\n//\n//   absl::StrSplit(absl::string_view(\"\"), '-');  // {\"\"}\n//   absl::StrSplit(absl::string_view(), '-');    // {}, but should be {\"\"}\n//\n// Try not to depend on this distinction because the bug may one day be fixed.\ntemplate <typename Delimiter>\nstrings_internal::Splitter<\n    typename strings_internal::SelectDelimiter<Delimiter>::type, AllowEmpty,\n    absl::string_view>\nStrSplit(strings_internal::ConvertibleToStringView text, Delimiter d) {\n  using DelimiterType =\n      typename strings_internal::SelectDelimiter<Delimiter>::type;\n  return strings_internal::Splitter<DelimiterType, AllowEmpty,\n                                    absl::string_view>(\n      text.value(), DelimiterType(d), AllowEmpty());\n}\n\ntemplate <typename Delimiter, typename StringType,\n          EnableSplitIfString<StringType> = 0>\nstrings_internal::Splitter<\n    typename strings_internal::SelectDelimiter<Delimiter>::type, AllowEmpty,\n    std::string>\nStrSplit(StringType&& text, Delimiter d) {\n  using DelimiterType =\n      typename strings_internal::SelectDelimiter<Delimiter>::type;\n  return strings_internal::Splitter<DelimiterType, AllowEmpty, std::string>(\n      std::move(text), DelimiterType(d), AllowEmpty());\n}\n\ntemplate <typename Delimiter, typename Predicate>\nstrings_internal::Splitter<\n    typename strings_internal::SelectDelimiter<Delimiter>::type, Predicate,\n    absl::string_view>\nStrSplit(strings_internal::ConvertibleToStringView text, Delimiter d,\n         Predicate p) {\n  using DelimiterType =\n      typename strings_internal::SelectDelimiter<Delimiter>::type;\n  return strings_internal::Splitter<DelimiterType, Predicate,\n                                    absl::string_view>(\n      text.value(), DelimiterType(d), std::move(p));\n}\n\ntemplate <typename Delimiter, typename Predicate, typename StringType,\n          EnableSplitIfString<StringType> = 0>\nstrings_internal::Splitter<\n    typename strings_internal::SelectDelimiter<Delimiter>::type, Predicate,\n    std::string>\nStrSplit(StringType&& text, Delimiter d, Predicate p) {\n  using DelimiterType =\n      typename strings_internal::SelectDelimiter<Delimiter>::type;\n  return strings_internal::Splitter<DelimiterType, Predicate, std::string>(\n      std::move(text), DelimiterType(d), std::move(p));\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04186",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_split.h",
  "source_line": 98,
  "validation_status": "validated"
}