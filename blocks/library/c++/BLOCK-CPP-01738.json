{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace flags_internal {\n\n// --------------------------------------------------------------------\n// FlagRegistry\n//    A FlagRegistry singleton object holds all flag objects indexed by their\n//    names so that if you know a flag's name, you can access or set it. If the\n//    function is named FooLocked(), you must own the registry lock before\n//    calling the function; otherwise, you should *not* hold the lock, and the\n//    function will acquire it itself if needed.\n// --------------------------------------------------------------------\n\nclass FlagRegistry {\n public:\n  FlagRegistry() = default;\n  ~FlagRegistry() = default;\n\n  // Store a flag in this registry. Takes ownership of *flag.\n  void RegisterFlag(CommandLineFlag& flag, const char* filename);\n\n  void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION(lock_) { lock_.Lock(); }\n  void Unlock() ABSL_UNLOCK_FUNCTION(lock_) { lock_.Unlock(); }\n\n  // Returns the flag object for the specified name, or nullptr if not found.\n  // Will emit a warning if a 'retired' flag is specified.\n  CommandLineFlag* FindFlag(absl::string_view name);\n\n  static FlagRegistry& GlobalRegistry();  // returns a singleton registry\n\n private:\n  friend class flags_internal::FlagSaverImpl;  // reads all the flags in order\n                                               // to copy them\n  friend void ForEachFlag(std::function<void(CommandLineFlag&)> visitor);\n  friend void FinalizeRegistry();\n\n  // The map from name to flag, for FindFlag().\n  using FlagMap = absl::flat_hash_map<absl::string_view, CommandLineFlag*>;\n  using FlagIterator = FlagMap::iterator;\n  using FlagConstIterator = FlagMap::const_iterator;\n  FlagMap flags_;\n  std::vector<CommandLineFlag*> flat_flags_;\n  std::atomic<bool> finalized_flags_{false};\n\n  absl::Mutex lock_;\n\n  // Disallow\n  FlagRegistry(const FlagRegistry&);\n  FlagRegistry& operator=(const FlagRegistry&);\n};\n\nnamespace {\n\nclass FlagRegistryLock {\n public:\n  explicit FlagRegistryLock(FlagRegistry& fr) : fr_(fr) { fr_.Lock(); }\n  ~FlagRegistryLock() { fr_.Unlock(); }\n\n private:\n  FlagRegistry& fr_;\n};\n\n}  // namespace\n\nCommandLineFlag* FlagRegistry::FindFlag(absl::string_view name) {\n  if (finalized_flags_.load(std::memory_order_acquire)) {\n    // We could save some gcus here if we make `Name()` be non-virtual.\n    // We could move the `const char*` name to the base class.\n    auto it = std::partition_point(\n        flat_flags_.begin(), flat_flags_.end(),\n        [=](CommandLineFlag* f) { return f->Name() < name; });\n    if (it != flat_flags_.end() && (*it)->Name() == name) return *it;\n  }\n\n  FlagRegistryLock frl(*this);\n  auto it = flags_.find(name);\n  return it != flags_.end() ? it->second : nullptr;\n}\n\nvoid FlagRegistry::RegisterFlag(CommandLineFlag& flag, const char* filename) {\n  if (filename != nullptr &&\n      flag.Filename() != GetUsageConfig().normalize_filename(filename)) {\n    flags_internal::ReportUsageError(\n        absl::StrCat(\n            \"Inconsistency between flag object and registration for flag '\",\n            flag.Name(),\n            \"', likely due to duplicate flags or an ODR violation. Relevant \"\n            \"files: \",\n            flag.Filename(), \" and \", filename),\n        true);\n    std::exit(1);\n  }\n\n  FlagRegistryLock registry_lock(*this);\n\n  std::pair<FlagIterator, bool> ins =\n      flags_.insert(FlagMap::value_type(flag.Name(), &flag));\n  if (ins.second == false) {  // means the name was already in the map\n    CommandLineFlag& old_flag = *ins.first->second;\n    if (flag.IsRetired() != old_flag.IsRetired()) {\n      // All registrations must agree on the 'retired' flag.\n      flags_internal::ReportUsageError(\n          absl::StrCat(\n              \"Retired flag '\", flag.Name(), \"' was defined normally in file '\",\n              (flag.IsRetired() ? old_flag.Filename() : flag.Filename()), \"'.\"),\n          true);\n    } else if (flags_internal::PrivateHandleAccessor::TypeId(flag) !=\n               flags_internal::PrivateHandleAccessor::TypeId(old_flag)) {\n      flags_internal::ReportUsageError(\n          absl::StrCat(\"Flag '\", flag.Name(),\n                       \"' was defined more than once but with \"\n                       \"differing types. Defined in files '\",\n                       old_flag.Filename(), \"' and '\", flag.Filename(), \"'.\"),\n          true);\n    } else if (old_flag.IsRetired()) {\n      return;\n    } else if (old_flag.Filename() != flag.Filename()) {\n      flags_internal::ReportUsageError(\n          absl::StrCat(\"Flag '\", flag.Name(),\n                       \"' was defined more than once (in files '\",\n                       old_flag.Filename(), \"' and '\", flag.Filename(), \"').\"),\n          true);\n    } else {\n      flags_internal::ReportUsageError(\n          absl::StrCat(\n              \"Something is wrong with flag '\", flag.Name(), \"' in file '\",\n              flag.Filename(), \"'. One possibility: file '\", flag.Filename(),\n              \"' is being linked both statically and dynamically into this \"\n              \"executable. e.g. some files listed as srcs to a test and also \"\n              \"listed as srcs of some shared lib deps of the same test.\"),\n          true);\n    }\n    // All cases above are fatal, except for the retired flags.\n    std::exit(1);\n  }\n}\n\nFlagRegistry& FlagRegistry::GlobalRegistry() {\n  static absl::NoDestructor<FlagRegistry> global_registry;\n  return *global_registry;\n}\n\n// --------------------------------------------------------------------\n\nvoid ForEachFlag(std::function<void(CommandLineFlag&)> visitor) {\n  FlagRegistry& registry = FlagRegistry::GlobalRegistry();\n\n  if (registry.finalized_flags_.load(std::memory_order_acquire)) {\n    for (const auto& i : registry.flat_flags_) visitor(*i);\n  }\n\n  FlagRegistryLock frl(registry);\n  for (const auto& i : registry.flags_) visitor(*i.second);\n}\n\n// --------------------------------------------------------------------\n\nbool RegisterCommandLineFlag(CommandLineFlag& flag, const char* filename) {\n  FlagRegistry::GlobalRegistry().RegisterFlag(flag, filename);\n  return true;\n}\n\nvoid FinalizeRegistry() {\n  auto& registry = FlagRegistry::GlobalRegistry();\n  FlagRegistryLock frl(registry);\n  if (registry.finalized_flags_.load(std::memory_order_relaxed)) {\n    // Was already finalized. Ignore the second time.\n    return;\n  }\n  registry.flat_flags_.reserve(registry.flags_.size());\n  for (const auto& f : registry.flags_) {\n    registry.flat_flags_.push_back(f.second);\n  }\n  std::sort(std::begin(registry.flat_flags_), std::end(registry.flat_flags_),\n            [](const CommandLineFlag* lhs, const CommandLineFlag* rhs) {\n              return lhs->Name() < rhs->Name();\n            });\n  registry.flags_.clear();\n  registry.finalized_flags_.store(true, std::memory_order_release);\n}\n\n// --------------------------------------------------------------------\n\nnamespace {\n\nclass RetiredFlagObj final : public CommandLineFlag {\n public:\n  constexpr RetiredFlagObj(const char* name, FlagFastTypeId type_id)\n      : name_(name), type_id_(type_id) {}\n\n private:\n  absl::string_view Name() const override { return name_; }\n  std::string Filename() const override {\n    OnAccess();\n    return \"RETIRED\";\n  }\n  FlagFastTypeId TypeId() const override { return type_id_; }\n  std::string Help() const override {\n    OnAccess();\n    return \"\";\n  }\n  bool IsRetired() const override { return true; }\n  bool IsSpecifiedOnCommandLine() const override {\n    OnAccess();\n    return false;\n  }\n  std::string DefaultValue() const override {\n    OnAccess();\n    return \"\";\n  }\n  std::string CurrentValue() const override {\n    OnAccess();\n    return \"\";\n  }\n\n  // Any input is valid\n  bool ValidateInputValue(absl::string_view) const override {\n    OnAccess();\n    return true;\n  }\n\n  std::unique_ptr<flags_internal::FlagStateInterface> SaveState() override {\n    return nullptr;\n  }\n\n  bool ParseFrom(absl::string_view, flags_internal::FlagSettingMode,\n                 flags_internal::ValueSource, std::string&) override {\n    OnAccess();\n    return false;\n  }\n\n  void CheckDefaultValueParsingRoundtrip() const override { OnAccess(); }\n\n  void Read(void*) const override { OnAccess(); }\n\n  void OnAccess() const {\n    flags_internal::ReportUsageError(\n        absl::StrCat(\"Accessing retired flag '\", name_, \"'\"), false);\n  }\n\n  // Data members\n  const char* const name_;\n  const FlagFastTypeId type_id_;\n};\n\n}  // namespace\n\nvoid Retire(const char* name, FlagFastTypeId type_id, char* buf) {\n  static_assert(sizeof(RetiredFlagObj) == kRetiredFlagObjSize, \"\");\n  static_assert(alignof(RetiredFlagObj) == kRetiredFlagObjAlignment, \"\");\n  auto* flag = ::new (static_cast<void*>(buf))\n      flags_internal::RetiredFlagObj(name, type_id);\n  FlagRegistry::GlobalRegistry().RegisterFlag(*flag, nullptr);\n}\n\n// --------------------------------------------------------------------\n\nclass FlagSaverImpl {\n public:\n  FlagSaverImpl() = default;\n  FlagSaverImpl(const FlagSaverImpl&) = delete;\n  void operator=(const FlagSaverImpl&) = delete;\n\n  // Saves the flag states from the flag registry into this object.\n  // It's an error to call this more than once.\n  void SaveFromRegistry() {\n    assert(backup_registry_.empty());  // call only once!\n    flags_internal::ForEachFlag([&](CommandLineFlag& flag) {\n      if (auto flag_state =\n              flags_internal::PrivateHandleAccessor::SaveState(flag)) {\n        backup_registry_.emplace_back(std::move(flag_state));\n      }\n    });\n  }\n\n  // Restores the saved flag states into the flag registry.\n  void RestoreToRegistry() {\n    for (const auto& flag_state : backup_registry_) {\n      flag_state->Restore();\n    }\n  }\n\n private:\n  std::vector<std::unique_ptr<flags_internal::FlagStateInterface>>\n      backup_registry_;\n};\n\n}  // namespace flags_internal\n\nFlagSaver::FlagSaver() : impl_(new flags_internal::FlagSaverImpl) {\n  impl_->SaveFromRegistry();\n}\n\nFlagSaver::~FlagSaver() {\n  if (!impl_) return;\n\n  impl_->RestoreToRegistry();\n  delete impl_;\n}\n\n// --------------------------------------------------------------------\n\nCommandLineFlag* FindCommandLineFlag(absl::string_view name) {\n  if (name.empty()) return nullptr;\n  flags_internal::FlagRegistry& registry =\n      flags_internal::FlagRegistry::GlobalRegistry();\n  return registry.FindFlag(name);\n}\n\n// --------------------------------------------------------------------\n\nabsl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> GetAllFlags() {\n  absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> res;\n  flags_internal::ForEachFlag([&](CommandLineFlag& flag) {\n    if (!flag.IsRetired()) res.insert({flag.Name(), &flag});\n  });\n  return res;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01738",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/reflection.cc",
  "source_line": 35,
  "validation_status": "validated"
}