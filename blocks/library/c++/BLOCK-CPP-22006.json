{
  "code": "{\nnamespace dataflow {\n\n/// Base class for elements of the local variable store and of the heap.\n///\n/// Each storage location holds a value. The mapping from storage locations to\n/// values is stored in the environment.\nclass StorageLocation {\npublic:\n  enum class Kind { Scalar, Aggregate };\n\n  StorageLocation(Kind LocKind, QualType Type) : LocKind(LocKind), Type(Type) {\n    assert(Type.isNull() || !Type->isReferenceType());\n  }\n\n  // Non-copyable because addresses of storage locations are used as their\n  // identities throughout framework and user code. The framework is responsible\n  // for construction and destruction of storage locations.\n  StorageLocation(const StorageLocation &) = delete;\n  StorageLocation &operator=(const StorageLocation &) = delete;\n\n  virtual ~StorageLocation() = default;\n\n  Kind getKind() const { return LocKind; }\n\n  QualType getType() const { return Type; }\n\nprivate:\n  Kind LocKind;\n  QualType Type;\n};\n\n/// A storage location that is not subdivided further for the purposes of\n/// abstract interpretation. For example: `int`, `int*`, `int&`.\nclass ScalarStorageLocation final : public StorageLocation {\npublic:\n  explicit ScalarStorageLocation(QualType Type)\n      : StorageLocation(Kind::Scalar, Type) {}\n\n  static bool classof(const StorageLocation *Loc) {\n    return Loc->getKind() == Kind::Scalar;\n  }\n};\n\n/// A storage location which is subdivided into smaller storage locations that\n/// can be traced independently by abstract interpretation. For example: a\n/// struct with public members. The child map is flat, so when used for a struct\n/// or class type, all accessible members of base struct and class types are\n/// directly accesible as children of this location.\n///\n/// The storage location for a field of reference type may be null. This\n/// typically occurs in one of two situations:\n/// - The record has not been fully initialized.\n/// - The maximum depth for modelling a self-referential data structure has been\n///   reached.\n/// Storage locations for fields of all other types must be non-null.\n///\n/// FIXME: Currently, the storage location of unions is modelled the same way as\n/// that of structs or classes. Eventually, we need to change this modelling so\n/// that all of the members of a given union have the same storage location.\nclass AggregateStorageLocation final : public StorageLocation {\npublic:\n  using FieldToLoc = llvm::DenseMap<const ValueDecl *, StorageLocation *>;\n\n  explicit AggregateStorageLocation(QualType Type)\n      : AggregateStorageLocation(Type, FieldToLoc()) {}\n\n  AggregateStorageLocation(QualType Type, FieldToLoc TheChildren)\n      : StorageLocation(Kind::Aggregate, Type),\n        Children(std::move(TheChildren)) {\n    assert(!Type.isNull());\n    assert(Type->isRecordType());\n    assert([this] {\n      for (auto [Field, Loc] : Children) {\n        if (!Field->getType()->isReferenceType() && Loc == nullptr)\n          return false;\n      }\n      return true;\n    }());\n  }\n\n  static bool classof(const StorageLocation *Loc) {\n    return Loc->getKind() == Kind::Aggregate;\n  }\n\n  /// Returns the child storage location for `D`.\n  ///\n  /// May return null if `D` has reference type; guaranteed to return non-null\n  /// in all other cases.\n  ///\n  /// Note that it is an error to call this with a field that does not exist.\n  /// The function does not return null in this case.\n  StorageLocation *getChild(const ValueDecl &D) const {\n    auto It = Children.find(&D);\n    LLVM_DEBUG({\n      if (It == Children.end()) {\n        llvm::dbgs() << \"Couldn't find child \" << D.getNameAsString()\n                     << \" on StorageLocation \" << this << \" of type \"\n                     << getType() << \"\\n\";\n        llvm::dbgs() << \"Existing children:\\n\";\n        for ([[maybe_unused]] auto [Field, Loc] : Children) {\n          llvm::dbgs() << Field->getNameAsString() << \"\\n\";\n        }\n      }\n    });\n    assert(It != Children.end());\n    return It->second;\n  }\n\n  /// Changes the child storage location for a field `D` of reference type.\n  /// All other fields cannot change their storage location and always retain\n  /// the storage location passed to the `AggregateStorageLocation` constructor.\n  ///\n  /// Requirements:\n  ///\n  ///  `D` must have reference type.\n  void setChild(const ValueDecl &D, StorageLocation *Loc) {\n    assert(D.getType()->isReferenceType());\n    Children[&D] = Loc;\n  }\n\n  llvm::iterator_range<FieldToLoc::const_iterator> children() const {\n    return {Children.begin(), Children.end()};\n  }\n\nprivate:\n  FieldToLoc Children;\n};\n\n} // namespace dataflow\n}",
  "id": "BLOCK-CPP-22006",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h",
  "source_line": 25,
  "validation_status": "validated"
}