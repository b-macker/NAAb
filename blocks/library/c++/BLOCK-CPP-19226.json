{
  "code": "{\n    const Preprocessor &PP;\n    IdentifierInfo *const Ident__VA_ARGS__;\n    IdentifierInfo *const Ident__VA_OPT__;\n\n  public:\n    VariadicMacroScopeGuard(const Preprocessor &P)\n        : PP(P), Ident__VA_ARGS__(PP.Ident__VA_ARGS__),\n          Ident__VA_OPT__(PP.Ident__VA_OPT__) {\n      assert(Ident__VA_ARGS__->isPoisoned() && \"__VA_ARGS__ should be poisoned \"\n                                              \"outside an ISO C/C++ variadic \"\n                                              \"macro definition!\");\n      assert(Ident__VA_OPT__->isPoisoned() && \"__VA_OPT__ should be poisoned!\");\n    }\n\n    /// Client code should call this function just before the Preprocessor is\n    /// about to Lex tokens from the definition of a variadic (ISO C/C++) macro.\n    void enterScope() {\n      Ident__VA_ARGS__->setIsPoisoned(false);\n      Ident__VA_OPT__->setIsPoisoned(false);\n    }\n\n    /// Client code should call this function as soon as the Preprocessor has\n    /// either completed lexing the macro's definition tokens, or an error\n    /// occurred and the context is being exited.  This function is idempotent\n    /// (might be explicitly called, and then reinvoked via the destructor).\n    void exitScope() {\n      Ident__VA_ARGS__->setIsPoisoned(true);\n      Ident__VA_OPT__->setIsPoisoned(true);\n    }\n\n    ~VariadicMacroScopeGuard() { exitScope(); }\n  }",
  "id": "BLOCK-CPP-19226",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/VariadicMacroSupport.h",
  "source_line": 30,
  "validation_status": "validated"
}