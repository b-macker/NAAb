{
  "code": "#include <array>\n#include <bitset>\n#include <deque>\n#include <forward_list>\n#include <list>\n#include <map>\n#include <set>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include \"absl/meta/type_traits.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06233_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace strings_internal {\n\ntemplate <typename C, template <typename...> class T>\nstruct IsSpecializationImpl : std::false_type {};\ntemplate <template <typename...> class T, typename... Args>\nstruct IsSpecializationImpl<T<Args...>, T> : std::true_type {};\ntemplate <typename C, template <typename...> class T>\nusing IsSpecialization = IsSpecializationImpl<absl::decay_t<C>, T>;\n\ntemplate <typename C>\nstruct IsArrayImpl : std::false_type {};\ntemplate <template <typename, size_t> class A, typename T, size_t N>\nstruct IsArrayImpl<A<T, N>> : std::is_same<A<T, N>, std::array<T, N>> {};\ntemplate <typename C>\nusing IsArray = IsArrayImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsBitsetImpl : std::false_type {};\ntemplate <template <size_t> class B, size_t N>\nstruct IsBitsetImpl<B<N>> : std::is_same<B<N>, std::bitset<N>> {};\ntemplate <typename C>\nusing IsBitset = IsBitsetImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsSTLContainer\n    : absl::disjunction<\n          IsArray<C>, IsBitset<C>, IsSpecialization<C, std::deque>,\n          IsSpecialization<C, std::forward_list>,\n          IsSpecialization<C, std::list>, IsSpecialization<C, std::map>,\n          IsSpecialization<C, std::multimap>, IsSpecialization<C, std::set>,\n          IsSpecialization<C, std::multiset>,\n          IsSpecialization<C, std::unordered_map>,\n          IsSpecialization<C, std::unordered_multimap>,\n          IsSpecialization<C, std::unordered_set>,\n          IsSpecialization<C, std::unordered_multiset>,\n          IsSpecialization<C, std::vector>> {};\n\ntemplate <typename C, template <typename...> class T, typename = void>\nstruct IsBaseOfSpecializationImpl : std::false_type {};\n// IsBaseOfSpecializationImpl needs multiple partial specializations to SFINAE\n// on the existence of container dependent types and plug them into the STL\n// template.\ntemplate <typename C, template <typename, typename> class T>\nstruct IsBaseOfSpecializationImpl<\n    C, T, absl::void_t<typename C::value_type, typename C::allocator_type>>\n    : std::is_base_of<C,\n                      T<typename C::value_type, typename C::allocator_type>> {};\ntemplate <typename C, template <typename, typename, typename> class T>\nstruct IsBaseOfSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::key_compare,\n                 typename C::allocator_type>>\n    : std::is_base_of<C, T<typename C::key_type, typename C::key_compare,\n                           typename C::allocator_type>> {};\ntemplate <typename C, template <typename, typename, typename, typename> class T>\nstruct IsBaseOfSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::mapped_type,\n                 typename C::key_compare, typename C::allocator_type>>\n    : std::is_base_of<C,\n                      T<typename C::key_type, typename C::mapped_type,\n                        typename C::key_compare, typename C::allocator_type>> {\n};\ntemplate <typename C, template <typename, typename, typename, typename> class T>\nstruct IsBaseOfSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::hasher,\n                 typename C::key_equal, typename C::allocator_type>>\n    : std::is_base_of<C, T<typename C::key_type, typename C::hasher,\n                           typename C::key_equal, typename C::allocator_type>> {\n};\ntemplate <typename C,\n          template <typename, typename, typename, typename, typename> class T>\nstruct IsBaseOfSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::mapped_type,\n                 typename C::hasher, typename C::key_equal,\n                 typename C::allocator_type>>\n    : std::is_base_of<C, T<typename C::key_type, typename C::mapped_type,\n                           typename C::hasher, typename C::key_equal,\n                           typename C::allocator_type>> {};\ntemplate <typename C, template <typename...> class T>\nusing IsBaseOfSpecialization = IsBaseOfSpecializationImpl<absl::decay_t<C>, T>;\n\ntemplate <typename C>\nstruct IsBaseOfArrayImpl : std::false_type {};\ntemplate <template <typename, size_t> class A, typename T, size_t N>\nstruct IsBaseOfArrayImpl<A<T, N>> : std::is_base_of<A<T, N>, std::array<T, N>> {\n};\ntemplate <typename C>\nusing IsBaseOfArray = IsBaseOfArrayImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsBaseOfBitsetImpl : std::false_type {};\ntemplate <template <size_t> class B, size_t N>\nstruct IsBaseOfBitsetImpl<B<N>> : std::is_base_of<B<N>, std::bitset<N>> {};\ntemplate <typename C>\nusing IsBaseOfBitset = IsBaseOfBitsetImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsBaseOfSTLContainer\n    : absl::disjunction<IsBaseOfArray<C>, IsBaseOfBitset<C>,\n                        IsBaseOfSpecialization<C, std::deque>,\n                        IsBaseOfSpecialization<C, std::forward_list>,\n                        IsBaseOfSpecialization<C, std::list>,\n                        IsBaseOfSpecialization<C, std::map>,\n                        IsBaseOfSpecialization<C, std::multimap>,\n                        IsBaseOfSpecialization<C, std::set>,\n                        IsBaseOfSpecialization<C, std::multiset>,\n                        IsBaseOfSpecialization<C, std::unordered_map>,\n                        IsBaseOfSpecialization<C, std::unordered_multimap>,\n                        IsBaseOfSpecialization<C, std::unordered_set>,\n                        IsBaseOfSpecialization<C, std::unordered_multiset>,\n                        IsBaseOfSpecialization<C, std::vector>> {};\n\ntemplate <typename C, template <typename...> class T, typename = void>\nstruct IsConvertibleToSpecializationImpl : std::false_type {};\n// IsConvertibleToSpecializationImpl needs multiple partial specializations to\n// SFINAE on the existence of container dependent types and plug them into the\n// STL template.\ntemplate <typename C, template <typename, typename> class T>\nstruct IsConvertibleToSpecializationImpl<\n    C, T, absl::void_t<typename C::value_type, typename C::allocator_type>>\n    : std::is_convertible<\n          C, T<typename C::value_type, typename C::allocator_type>> {};\ntemplate <typename C, template <typename, typename, typename> class T>\nstruct IsConvertibleToSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::key_compare,\n                 typename C::allocator_type>>\n    : std::is_convertible<C, T<typename C::key_type, typename C::key_compare,\n                               typename C::allocator_type>> {};\ntemplate <typename C, template <typename, typename, typename, typename> class T>\nstruct IsConvertibleToSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::mapped_type,\n                 typename C::key_compare, typename C::allocator_type>>\n    : std::is_convertible<\n          C, T<typename C::key_type, typename C::mapped_type,\n               typename C::key_compare, typename C::allocator_type>> {};\ntemplate <typename C, template <typename, typename, typename, typename> class T>\nstruct IsConvertibleToSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::hasher,\n                 typename C::key_equal, typename C::allocator_type>>\n    : std::is_convertible<\n          C, T<typename C::key_type, typename C::hasher, typename C::key_equal,\n               typename C::allocator_type>> {};\ntemplate <typename C,\n          template <typename, typename, typename, typename, typename> class T>\nstruct IsConvertibleToSpecializationImpl<\n    C, T,\n    absl::void_t<typename C::key_type, typename C::mapped_type,\n                 typename C::hasher, typename C::key_equal,\n                 typename C::allocator_type>>\n    : std::is_convertible<C, T<typename C::key_type, typename C::mapped_type,\n                               typename C::hasher, typename C::key_equal,\n                               typename C::allocator_type>> {};\ntemplate <typename C, template <typename...> class T>\nusing IsConvertibleToSpecialization =\n    IsConvertibleToSpecializationImpl<absl::decay_t<C>, T>;\n\ntemplate <typename C>\nstruct IsConvertibleToArrayImpl : std::false_type {};\ntemplate <template <typename, size_t> class A, typename T, size_t N>\nstruct IsConvertibleToArrayImpl<A<T, N>>\n    : std::is_convertible<A<T, N>, std::array<T, N>> {};\ntemplate <typename C>\nusing IsConvertibleToArray = IsConvertibleToArrayImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsConvertibleToBitsetImpl : std::false_type {};\ntemplate <template <size_t> class B, size_t N>\nstruct IsConvertibleToBitsetImpl<B<N>>\n    : std::is_convertible<B<N>, std::bitset<N>> {};\ntemplate <typename C>\nusing IsConvertibleToBitset = IsConvertibleToBitsetImpl<absl::decay_t<C>>;\n\ntemplate <typename C>\nstruct IsConvertibleToSTLContainer\n    : absl::disjunction<\n          IsConvertibleToArray<C>, IsConvertibleToBitset<C>,\n          IsConvertibleToSpecialization<C, std::deque>,\n          IsConvertibleToSpecialization<C, std::forward_list>,\n          IsConvertibleToSpecialization<C, std::list>,\n          IsConvertibleToSpecialization<C, std::map>,\n          IsConvertibleToSpecialization<C, std::multimap>,\n          IsConvertibleToSpecialization<C, std::set>,\n          IsConvertibleToSpecialization<C, std::multiset>,\n          IsConvertibleToSpecialization<C, std::unordered_map>,\n          IsConvertibleToSpecialization<C, std::unordered_multimap>,\n          IsConvertibleToSpecialization<C, std::unordered_set>,\n          IsConvertibleToSpecialization<C, std::unordered_multiset>,\n          IsConvertibleToSpecialization<C, std::vector>> {};\n\ntemplate <typename C>\nstruct IsStrictlyBaseOfAndConvertibleToSTLContainer\n    : absl::conjunction<absl::negation<IsSTLContainer<C>>,\n                        IsBaseOfSTLContainer<C>,\n                        IsConvertibleToSTLContainer<C>> {};\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06233",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/stl_type_traits.h",
  "source_line": 42,
  "validation_status": "validated"
}