{
  "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/endian.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/base/options.h\"\n#include \"absl/base/port.h\"\n#include \"absl/base/prefetch.h\"\n#include \"absl/container/internal/common.h\"  // IWYU pragma: export // for node_handle\n#include \"absl/container/internal/compressed_tuple.h\"\n#include \"absl/container/internal/container_memory.h\"\n#include \"absl/container/internal/hash_policy_traits.h\"\n#include \"absl/container/internal/hashtable_debug_hooks.h\"\n#include \"absl/container/internal/hashtablez_sampler.h\"\n#include \"absl/memory/memory.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/utility/utility.h\"\n#include <emmintrin.h>\n#include <tmmintrin.h>\n#include <intrin.h>\n#include <arm_neon.h>\n\nusing namespace absl;\nusing namespace container_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05269_execute() {\n    {\n    assert(c.capacity());\n    // Folks with custom allocators often make unwarranted assumptions about the\n    // behavior of their classes vis-a-vis trivial destructability and what\n    // calls they will or won't make.  Avoid sampling for people with custom\n    // allocators to get us out of this mess.  This is not a hard guarantee but\n    // a workaround while we plan the exact guarantee we want to provide.\n    const size_t sample_size =\n        (std::is_same<Alloc, std::allocator<char>>::value &&\n         c.slot_array() == nullptr)\n            ? SizeOfSlot\n            : 0;\n    HashtablezInfoHandle infoz =\n        sample_size > 0 ? Sample(sample_size) : c.infoz();\n\n    const bool has_infoz = infoz.IsSampled();\n    const size_t cap = c.capacity();\n    const size_t alloc_size =\n        AllocSize(cap, SizeOfSlot, AlignOfSlot, has_infoz);\n    char* mem = static_cast<char*>(\n        Allocate<BackingArrayAlignment(AlignOfSlot)>(&alloc, alloc_size));\n    const GenerationType old_generation = c.generation();\n    c.set_generation_ptr(reinterpret_cast<GenerationType*>(\n        mem + GenerationOffset(cap, has_infoz)));\n    c.set_generation(NextGeneration(old_generation));\n    c.set_control(reinterpret_cast<ctrl_t*>(mem + ControlOffset(has_infoz)));\n    c.set_slots(mem + SlotOffset(cap, AlignOfSlot, has_infoz));\n    ResetGrowthLeft(c);\n\n    const bool grow_single_group =\n        IsGrowingIntoSingleGroupApplicable(old_capacity_, c.capacity());\n    if (old_capacity_ != 0 && grow_single_group) {\n      if (TransferUsesMemcpy) {\n        GrowSizeIntoSingleGroupTransferable(c, old_slots, SizeOfSlot);\n        DeallocateOld<AlignOfSlot>(alloc, SizeOfSlot, old_slots);\n      } else {\n        GrowIntoSingleGroupShuffleControlBytes(c.control(), c.capacity());\n      }\n    } else {\n      ResetCtrl(c, SizeOfSlot);\n    }\n\n    c.set_has_infoz(has_infoz);\n    if (has_infoz) {\n      infoz.RecordStorageChanged(c.size(), cap);\n      if (grow_single_group || old_capacity_ == 0) {\n        infoz.RecordRehash(0);\n      }\n      c.set_infoz(infoz);\n    }\n    return grow_single_group;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05269",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 1594,
  "validation_status": "validated"
}