{
  "code": "{\n\nnamespace sinks {\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE stdout_sink_base<ConsoleMutex>::stdout_sink_base(FILE *file)\n    : mutex_(ConsoleMutex::mutex()),\n      file_(file),\n      formatter_(details::make_unique<spdlog::pattern_formatter>()) {\n#ifdef _WIN32\n    // get windows handle from the FILE* object\n\n    handle_ = reinterpret_cast<HANDLE>(::_get_osfhandle(::_fileno(file_)));\n\n    // don't throw to support cases where no console is attached,\n    // and let the log method to do nothing if (handle_ == INVALID_HANDLE_VALUE).\n    // throw only if non stdout/stderr target is requested (probably regular file and not console).\n    if (handle_ == INVALID_HANDLE_VALUE && file != stdout && file != stderr) {\n        throw_spdlog_ex(\"spdlog::stdout_sink_base: _get_osfhandle() failed\", errno);\n    }\n#endif  // WIN32\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::log(const details::log_msg &msg) {\n#ifdef _WIN32\n    if (handle_ == INVALID_HANDLE_VALUE) {\n        return;\n    }\n    std::lock_guard<mutex_t> lock(mutex_);\n    memory_buf_t formatted;\n    formatter_->format(msg, formatted);\n    auto size = static_cast<DWORD>(formatted.size());\n    DWORD bytes_written = 0;\n    bool ok = ::WriteFile(handle_, formatted.data(), size, &bytes_written, nullptr) != 0;\n    if (!ok) {\n        throw_spdlog_ex(\"stdout_sink_base: WriteFile() failed. GetLastError(): \" +\n                        std::to_string(::GetLastError()));\n    }\n#else\n    std::lock_guard<mutex_t> lock(mutex_);\n    memory_buf_t formatted;\n    formatter_->format(msg, formatted);\n    ::fwrite(formatted.data(), sizeof(char), formatted.size(), file_);\n#endif                // WIN32\n    ::fflush(file_);  // flush every line to terminal\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::flush() {\n    std::lock_guard<mutex_t> lock(mutex_);\n    fflush(file_);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::set_pattern(const std::string &pattern) {\n    std::lock_guard<mutex_t> lock(mutex_);\n    formatter_ = std::unique_ptr<spdlog::formatter>(new pattern_formatter(pattern));\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::set_formatter(\n    std::unique_ptr<spdlog::formatter> sink_formatter) {\n    std::lock_guard<mutex_t> lock(mutex_);\n    formatter_ = std::move(sink_formatter);\n}\n\n// stdout sink\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE stdout_sink<ConsoleMutex>::stdout_sink()\n    : stdout_sink_base<ConsoleMutex>(stdout) {}\n\n// stderr sink\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE stderr_sink<ConsoleMutex>::stderr_sink()\n    : stdout_sink_base<ConsoleMutex>(stderr) {}\n\n}  // namespace sinks\n\n// factory methods\ntemplate <typename Factory>\nSPDLOG_INLINE std::shared_ptr<logger> stdout_logger_mt(const std::string &logger_name) {\n    return Factory::template create<sinks::stdout_sink_mt>(logger_name);\n}\n\ntemplate <typename Factory>\nSPDLOG_INLINE std::shared_ptr<logger> stdout_logger_st(const std::string &logger_name) {\n    return Factory::template create<sinks::stdout_sink_st>(logger_name);\n}\n\ntemplate <typename Factory>\nSPDLOG_INLINE std::shared_ptr<logger> stderr_logger_mt(const std::string &logger_name) {\n    return Factory::template create<sinks::stderr_sink_mt>(logger_name);\n}\n\ntemplate <typename Factory>\nSPDLOG_INLINE std::shared_ptr<logger> stderr_logger_st(const std::string &logger_name) {\n    return Factory::template create<sinks::stderr_sink_st>(logger_name);\n}\n}",
  "id": "BLOCK-CPP-00475",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/stdout_sinks-inl.h",
  "source_line": 27,
  "validation_status": "validated"
}