{
  "code": "{\n public:\n  MockingBitGen() = default;\n  ~MockingBitGen() = default;\n\n  // URBG interface\n  using result_type = absl::BitGen::result_type;\n\n  static constexpr result_type(min)() { return (absl::BitGen::min)(); }\n  static constexpr result_type(max)() { return (absl::BitGen::max)(); }\n  result_type operator()() { return gen_(); }\n\n private:\n  // GetMockFnType returns the testing::MockFunction for a result and tuple.\n  // This method only exists for type deduction and is otherwise unimplemented.\n  template <typename ResultT, typename... Args>\n  static auto GetMockFnType(ResultT, std::tuple<Args...>)\n      -> ::testing::MockFunction<ResultT(Args...)>;\n\n  // MockFnCaller is a helper method for use with absl::apply to\n  // apply an ArgTupleT to a compatible MockFunction.\n  // NOTE: MockFnCaller is essentially equivalent to the lambda:\n  // [fn](auto... args) { return fn->Call(std::move(args)...)}\n  // however that fails to build on some supported platforms.\n  template <typename MockFnType, typename ResultT, typename Tuple>\n  struct MockFnCaller;\n\n  // specialization for std::tuple.\n  template <typename MockFnType, typename ResultT, typename... Args>\n  struct MockFnCaller<MockFnType, ResultT, std::tuple<Args...>> {\n    MockFnType* fn;\n    inline ResultT operator()(Args... args) {\n      return fn->Call(std::move(args)...);\n    }\n  };\n\n  // FunctionHolder owns a particular ::testing::MockFunction associated with\n  // a mocked type signature, and implement the type-erased Apply call, which\n  // applies type-erased arguments to the mock.\n  class FunctionHolder {\n   public:\n    virtual ~FunctionHolder() = default;\n\n    // Call is a dispatch function which converts the\n    // generic type-erased parameters into a specific mock invocation call.\n    virtual void Apply(/*ArgTupleT*/ void* args_tuple,\n                       /*ResultT*/ void* result) = 0;\n  };\n\n  template <typename MockFnType, typename ResultT, typename ArgTupleT>\n  class FunctionHolderImpl final : public FunctionHolder {\n   public:\n    void Apply(void* args_tuple, void* result) override {\n      // Requires tuple_args to point to a ArgTupleT, which is a\n      // std::tuple<Args...> used to invoke the mock function. Requires result\n      // to point to a ResultT, which is the result of the call.\n      *static_cast<ResultT*>(result) =\n          absl::apply(MockFnCaller<MockFnType, ResultT, ArgTupleT>{&mock_fn_},\n                      *static_cast<ArgTupleT*>(args_tuple));\n    }\n\n    MockFnType mock_fn_;\n  };\n\n  // MockingBitGen::RegisterMock\n  //\n  // RegisterMock<ResultT, ArgTupleT>(FastTypeIdType) is the main extension\n  // point for extending the MockingBitGen framework. It provides a mechanism to\n  // install a mock expectation for a function like ResultT(Args...) keyed by\n  // type_idex onto the MockingBitGen context. The key is that the type_index\n  // used to register must match the type index used to call the mock.\n  //\n  // The returned MockFunction<...> type can be used to setup additional\n  // distribution parameters of the expectation.\n  template <typename ResultT, typename ArgTupleT, typename SelfT>\n  auto RegisterMock(SelfT&, base_internal::FastTypeIdType type)\n      -> decltype(GetMockFnType(std::declval<ResultT>(),\n                                std::declval<ArgTupleT>()))& {\n    using MockFnType = decltype(GetMockFnType(std::declval<ResultT>(),\n                                              std::declval<ArgTupleT>()));\n\n    using WrappedFnType = absl::conditional_t<\n        std::is_same<SelfT, ::testing::NiceMock<absl::MockingBitGen>>::value,\n        ::testing::NiceMock<MockFnType>,\n        absl::conditional_t<\n            std::is_same<SelfT,\n                         ::testing::NaggyMock<absl::MockingBitGen>>::value,\n            ::testing::NaggyMock<MockFnType>,\n            absl::conditional_t<\n                std::is_same<SelfT,\n                             ::testing::StrictMock<absl::MockingBitGen>>::value,\n                ::testing::StrictMock<MockFnType>, MockFnType>>>;\n\n    using ImplT = FunctionHolderImpl<WrappedFnType, ResultT, ArgTupleT>;\n    auto& mock = mocks_[type];\n    if (!mock) {\n      mock = absl::make_unique<ImplT>();\n    }\n    return static_cast<ImplT*>(mock.get())->mock_fn_;\n  }\n\n  // MockingBitGen::InvokeMock\n  //\n  // InvokeMock(FastTypeIdType, args, result) is the entrypoint for invoking\n  // mocks registered on MockingBitGen.\n  //\n  // When no mocks are registered on the provided FastTypeIdType, returns false.\n  // Otherwise attempts to invoke the mock function ResultT(Args...) that\n  // was previously registered via the type_index.\n  // Requires tuple_args to point to a ArgTupleT, which is a std::tuple<Args...>\n  // used to invoke the mock function.\n  // Requires result to point to a ResultT, which is the result of the call.\n  inline bool InvokeMock(base_internal::FastTypeIdType type, void* args_tuple,\n                         void* result) {\n    // Trigger a mock, if there exists one that matches `param`.\n    auto it = mocks_.find(type);\n    if (it == mocks_.end()) return false;\n    it->second->Apply(args_tuple, result);\n    return true;\n  }\n\n  absl::flat_hash_map<base_internal::FastTypeIdType,\n                      std::unique_ptr<FunctionHolder>>\n      mocks_;\n  absl::BitGen gen_;\n\n  template <typename>\n  friend struct ::absl::random_internal::DistributionCaller;  // for InvokeMock\n  friend class ::absl::BitGenRef;                             // for InvokeMock\n  friend class ::absl::random_internal::MockHelpers;  // for RegisterMock,\n                                                      // InvokeMock\n}",
  "id": "BLOCK-CPP-03877",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/mocking_bit_gen.h",
  "source_line": 104,
  "validation_status": "validated"
}