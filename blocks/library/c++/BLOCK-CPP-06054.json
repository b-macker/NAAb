{
  "code": "#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/strings/charconv.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06054_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace strings_internal {\n\n// Enum indicating whether a parsed float is a number or special value.\nenum class FloatType { kNumber, kInfinity, kNan };\n\n// The decomposed parts of a parsed `float` or `double`.\nstruct ParsedFloat {\n  // Representation of the parsed mantissa, with the decimal point adjusted to\n  // make it an integer.\n  //\n  // During decimal scanning, this contains 19 significant digits worth of\n  // mantissa value.  If digits beyond this point are found, they\n  // are truncated, and if any of these dropped digits are nonzero, then\n  // `mantissa` is inexact, and the full mantissa is stored in [subrange_begin,\n  // subrange_end).\n  //\n  // During hexadecimal scanning, this contains 15 significant hex digits worth\n  // of mantissa value.  Digits beyond this point are sticky -- they are\n  // truncated, but if any dropped digits are nonzero, the low bit of mantissa\n  // will be set.  (This allows for precise rounding, and avoids the need\n  // to store the full mantissa in [subrange_begin, subrange_end).)\n  uint64_t mantissa = 0;\n\n  // Floating point expontent.  This reflects any decimal point adjustments and\n  // any truncated digits from the mantissa.  The absolute value of the parsed\n  // number is represented by mantissa * (base ** exponent), where base==10 for\n  // decimal floats, and base==2 for hexadecimal floats.\n  int exponent = 0;\n\n  // The literal exponent value scanned from the input, or 0 if none was\n  // present.  This does not reflect any adjustments applied to mantissa.\n  int literal_exponent = 0;\n\n  // The type of number scanned.\n  FloatType type = FloatType::kNumber;\n\n  // When non-null, [subrange_begin, subrange_end) marks a range of characters\n  // that require further processing.  The meaning is dependent on float type.\n  // If type == kNumber and this is set, this is a \"wide input\": the input\n  // mantissa contained more than 19 digits.  The range contains the full\n  // mantissa.  It plus `literal_exponent` need to be examined to find the best\n  // floating point match.\n  // If type == kNan and this is set, the range marks the contents of a\n  // matched parenthesized character region after the NaN.\n  const char* subrange_begin = nullptr;\n  const char* subrange_end = nullptr;\n\n  // One-past-the-end of the successfully parsed region, or nullptr if no\n  // matching pattern was found.\n  const char* end = nullptr;\n};\n\n// Read the floating point number in the provided range, and populate\n// ParsedFloat accordingly.\n//\n// format_flags is a bitmask value specifying what patterns this API will match.\n// `scientific` and `fixed`  are honored per std::from_chars rules\n// ([utility.from.chars], C++17): if exactly one of these bits is set, then an\n// exponent is required, or dislallowed, respectively.\n//\n// Template parameter `base` must be either 10 or 16.  For base 16, a \"0x\" is\n// *not* consumed.  The `hex` bit from format_flags is ignored by ParseFloat.\ntemplate <int base>\nParsedFloat ParseFloat(const char* begin, const char* end,\n                       absl::chars_format format_flags);\n\nextern template ParsedFloat ParseFloat<10>(const char* begin, const char* end,\n                                           absl::chars_format format_flags);\nextern template ParsedFloat ParseFloat<16>(const char* begin, const char* end,\n                                           absl::chars_format format_flags);\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06054",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/charconv_parse.h",
  "source_line": 23,
  "validation_status": "validated"
}