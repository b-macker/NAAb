{
  "code": "{\n  // Inherit from checked_compare_base to support function pointers and also\n  // keep empty-base-optimization (EBO) support for classes.\n  // Note: we can't use CompressedTuple here because that would interfere\n  // with the EBO for `btree::rightmost_`. `btree::rightmost_` is itself a\n  // CompressedTuple and nested `CompressedTuple`s don't support EBO.\n  // TODO(b/214288561): use CompressedTuple instead once it supports EBO for\n  // nested `CompressedTuple`s.\n  struct checked_compare : checked_compare_base<Compare> {\n   private:\n    using Base = typename checked_compare::checked_compare_base;\n    using Base::comp;\n\n    // If possible, returns whether `t` is equivalent to itself. We can only do\n    // this for `Key`s because we can't be sure that it's safe to call\n    // `comp()(k, k)` otherwise. Even if SFINAE allows it, there could be a\n    // compilation failure inside the implementation of the comparison operator.\n    bool is_self_equivalent(const Key &k) const {\n      // Note: this works for both boolean and three-way comparators.\n      return comp()(k, k) == 0;\n    }\n    // If we can't compare `t` with itself, returns true unconditionally.\n    template <typename T>\n    bool is_self_equivalent(const T &) const {\n      return true;\n    }\n\n   public:\n    using Base::Base;\n    checked_compare(Compare comp) : Base(std::move(comp)) {}  // NOLINT\n\n    // Allow converting to Compare for use in key_comp()/value_comp().\n    explicit operator Compare() const { return comp(); }\n\n    template <typename T, typename U,\n              absl::enable_if_t<\n                  std::is_same<bool, compare_result_t<Compare, T, U>>::value,\n                  int> = 0>\n    bool operator()(const T &lhs, const U &rhs) const {\n      // NOTE: if any of these assertions fail, then the comparator does not\n      // establish a strict-weak-ordering (see\n      // https://en.cppreference.com/w/cpp/named_req/Compare).\n      assert(is_self_equivalent(lhs));\n      assert(is_self_equivalent(rhs));\n      const bool lhs_comp_rhs = comp()(lhs, rhs);\n      assert(!lhs_comp_rhs || !comp()(rhs, lhs));\n      return lhs_comp_rhs;\n    }\n\n    template <\n        typename T, typename U,\n        absl::enable_if_t<std::is_convertible<compare_result_t<Compare, T, U>,\n                                              absl::weak_ordering>::value,\n                          int> = 0>\n    absl::weak_ordering operator()(const T &lhs, const U &rhs) const {\n      // NOTE: if any of these assertions fail, then the comparator does not\n      // establish a strict-weak-ordering (see\n      // https://en.cppreference.com/w/cpp/named_req/Compare).\n      assert(is_self_equivalent(lhs));\n      assert(is_self_equivalent(rhs));\n      const absl::weak_ordering lhs_comp_rhs = comp()(lhs, rhs);\n#ifndef NDEBUG\n      const absl::weak_ordering rhs_comp_lhs = comp()(rhs, lhs);\n      if (lhs_comp_rhs > 0) {\n        assert(rhs_comp_lhs < 0 && \"lhs_comp_rhs > 0 -> rhs_comp_lhs < 0\");\n      } else if (lhs_comp_rhs == 0) {\n        assert(rhs_comp_lhs == 0 && \"lhs_comp_rhs == 0 -> rhs_comp_lhs == 0\");\n      } else {\n        assert(rhs_comp_lhs > 0 && \"lhs_comp_rhs < 0 -> rhs_comp_lhs > 0\");\n      }\n#endif\n      return lhs_comp_rhs;\n    }\n  };\n  using type = absl::conditional_t<\n      std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase, Compare>::value,\n      Compare, checked_compare>;\n}",
  "id": "BLOCK-CPP-04884",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/btree.h",
  "source_line": 197,
  "validation_status": "validated"
}