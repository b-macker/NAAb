{
  "code": "{\n  if (len <= 32) {\n    if (len <= 16) {\n      return HashLen0to16(s, len);\n    } else {\n      return HashLen17to32(s, len);\n    }\n  } else if (len <= 64) {\n    return HashLen33to64(s, len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  uint64_t x = Fetch64(s + len - 40);\n  uint64_t y = Fetch64(s + len - 16) + Fetch64(s + len - 56);\n  uint64_t z = HashLen16(Fetch64(s + len - 48) + len, Fetch64(s + len - 24));\n  std::pair<uint64_t, uint64_t> v =\n      WeakHashLen32WithSeeds(s + len - 64, len, z);\n  std::pair<uint64_t, uint64_t> w =\n      WeakHashLen32WithSeeds(s + len - 32, y + k1, x);\n  x = x * k1 + Fetch64(s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  len = (len - 1) & ~static_cast<size_t>(63);\n  do {\n    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;\n    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;\n    x ^= w.second;\n    y += v.first + Fetch64(s + 40);\n    z = Rotate(z + w.first, 33) * k1;\n    v = WeakHashLen32WithSeeds(s, v.second * k1, x + w.first);\n    w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + Fetch64(s + 16));\n    std::swap(z, x);\n    s += 64;\n    len -= 64;\n  } while (len != 0);\n  return HashLen16(HashLen16(v.first, w.first) + ShiftMix(y) * k1 + z,\n                   HashLen16(v.second, w.second) + x);\n}",
  "id": "BLOCK-CPP-02671",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/internal/city.cc",
  "source_line": 298,
  "validation_status": "validated"
}