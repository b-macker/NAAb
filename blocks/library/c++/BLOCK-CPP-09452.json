{
  "code": "{\n  friend class DeclarationNameTable;\n  friend class NamedDecl;\n\n  /// StoredNameKind represent the kind of name that is actually stored in the\n  /// upper bits of the Ptr field. This is only used internally.\n  ///\n  /// NameKind, StoredNameKind, and DeclarationNameExtra::ExtraKind\n  /// must satisfy the following properties. These properties enable\n  /// efficient conversion between the various kinds.\n  ///\n  /// * The first seven enumerators of StoredNameKind must have the same\n  ///   numerical value as the first seven enumerators of NameKind.\n  ///   This enable efficient conversion between the two enumerations\n  ///   in the usual case.\n  ///\n  /// * The enumerations values of DeclarationNameExtra::ExtraKind must start\n  ///   at zero, and correspond to the numerical value of the first non-inline\n  ///   enumeration values of NameKind minus an offset. This makes conversion\n  ///   between DeclarationNameExtra::ExtraKind and NameKind possible with\n  ///   a single addition/substraction.\n  ///\n  /// * The enumeration values of Selector::IdentifierInfoFlag must correspond\n  ///   to the relevant enumeration values of StoredNameKind.\n  ///   More specifically:\n  ///    * ZeroArg == StoredObjCZeroArgSelector,\n  ///    * OneArg == StoredObjCOneArgSelector,\n  ///    * MultiArg == StoredDeclarationNameExtra\n  ///\n  /// * PtrMask must mask the low 3 bits of Ptr.\n  enum StoredNameKind {\n    StoredIdentifier = 0,\n    StoredObjCZeroArgSelector = Selector::ZeroArg,\n    StoredObjCOneArgSelector = Selector::OneArg,\n    StoredCXXConstructorName = 3,\n    StoredCXXDestructorName = 4,\n    StoredCXXConversionFunctionName = 5,\n    StoredCXXOperatorName = 6,\n    StoredDeclarationNameExtra = Selector::MultiArg,\n    PtrMask = 7,\n    UncommonNameKindOffset = 8\n  };\n\n  static_assert(alignof(IdentifierInfo) >= 8 &&\n                    alignof(detail::DeclarationNameExtra) >= 8 &&\n                    alignof(detail::CXXSpecialNameExtra) >= 8 &&\n                    alignof(detail::CXXOperatorIdName) >= 8 &&\n                    alignof(detail::CXXDeductionGuideNameExtra) >= 8 &&\n                    alignof(detail::CXXLiteralOperatorIdName) >= 8,\n                \"The various classes that DeclarationName::Ptr can point to\"\n                \" must be at least aligned to 8 bytes!\");\n\n  static_assert(\n      std::is_same<std::underlying_type_t<StoredNameKind>,\n                   std::underlying_type_t<\n                       detail::DeclarationNameExtra::ExtraKind>>::value,\n      \"The various enums used to compute values for NameKind should \"\n      \"all have the same underlying type\");\n\npublic:\n  /// The kind of the name stored in this DeclarationName.\n  /// The first 7 enumeration values are stored inline and correspond\n  /// to frequently used kinds. The rest is stored in DeclarationNameExtra\n  /// and correspond to infrequently used kinds.\n  enum NameKind {\n    Identifier = StoredIdentifier,\n    ObjCZeroArgSelector = StoredObjCZeroArgSelector,\n    ObjCOneArgSelector = StoredObjCOneArgSelector,\n    CXXConstructorName = StoredCXXConstructorName,\n    CXXDestructorName = StoredCXXDestructorName,\n    CXXConversionFunctionName = StoredCXXConversionFunctionName,\n    CXXOperatorName = StoredCXXOperatorName,\n    CXXDeductionGuideName = llvm::addEnumValues(\n        UncommonNameKindOffset,\n        detail::DeclarationNameExtra::CXXDeductionGuideName),\n    CXXLiteralOperatorName = llvm::addEnumValues(\n        UncommonNameKindOffset,\n        detail::DeclarationNameExtra::CXXLiteralOperatorName),\n    CXXUsingDirective =\n        llvm::addEnumValues(UncommonNameKindOffset,\n                            detail::DeclarationNameExtra::CXXUsingDirective),\n    ObjCMultiArgSelector =\n        llvm::addEnumValues(UncommonNameKindOffset,\n                            detail::DeclarationNameExtra::ObjCMultiArgSelector),\n  };\n\nprivate:\n  /// The lowest three bits of Ptr are used to express what kind of name\n  /// we're actually storing, using the values of StoredNameKind. Depending\n  /// on the kind of name this is, the upper bits of Ptr may have one\n  /// of several different meanings:\n  ///\n  ///   StoredIdentifier - The name is a normal identifier, and Ptr is\n  ///   a normal IdentifierInfo pointer.\n  ///\n  ///   StoredObjCZeroArgSelector - The name is an Objective-C\n  ///   selector with zero arguments, and Ptr is an IdentifierInfo\n  ///   pointer pointing to the selector name.\n  ///\n  ///   StoredObjCOneArgSelector - The name is an Objective-C selector\n  ///   with one argument, and Ptr is an IdentifierInfo pointer\n  ///   pointing to the selector name.\n  ///\n  ///   StoredCXXConstructorName - The name of a C++ constructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXDestructorName - The name of a C++ destructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXConversionFunctionName - The name of a C++ conversion function,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXOperatorName - The name of an overloaded C++ operator,\n  ///   Ptr points to a CXXOperatorIdName.\n  ///\n  ///   StoredDeclarationNameExtra - Ptr is actually a pointer to a\n  ///   DeclarationNameExtra structure, whose first value will tell us\n  ///   whether this is an Objective-C selector, C++ deduction guide,\n  ///   C++ literal operator, or C++ using directive.\n  uintptr_t Ptr = 0;\n\n  StoredNameKind getStoredNameKind() const {\n    return static_cast<StoredNameKind>(Ptr & PtrMask);\n  }\n\n  void *getPtr() const { return reinterpret_cast<void *>(Ptr & ~PtrMask); }\n\n  void setPtrAndKind(const void *P, StoredNameKind Kind) {\n    uintptr_t PAsInteger = reinterpret_cast<uintptr_t>(P);\n    assert((Kind & ~PtrMask) == 0 &&\n           \"Invalid StoredNameKind in setPtrAndKind!\");\n    assert((PAsInteger & PtrMask) == 0 &&\n           \"Improperly aligned pointer in setPtrAndKind!\");\n    Ptr = PAsInteger | Kind;\n  }\n\n  /// Construct a declaration name from a DeclarationNameExtra.\n  DeclarationName(detail::DeclarationNameExtra *Name) {\n    setPtrAndKind(Name, StoredDeclarationNameExtra);\n  }\n\n  /// Construct a declaration name from a CXXSpecialNameExtra.\n  DeclarationName(detail::CXXSpecialNameExtra *Name,\n                  StoredNameKind StoredKind) {\n    assert((StoredKind == StoredCXXConstructorName ||\n           StoredKind == StoredCXXDestructorName ||\n           StoredKind == StoredCXXConversionFunctionName) &&\n               \"Invalid StoredNameKind when constructing a DeclarationName\"\n               \" from a CXXSpecialNameExtra!\");\n    setPtrAndKind(Name, StoredKind);\n  }\n\n  /// Construct a DeclarationName from a CXXOperatorIdName.\n  DeclarationName(detail::CXXOperatorIdName *Name) {\n    setPtrAndKind(Name, StoredCXXOperatorName);\n  }\n\n  /// Assert that the stored pointer points to an IdentifierInfo and return it.\n  IdentifierInfo *castAsIdentifierInfo() const {\n    assert((getStoredNameKind() == StoredIdentifier) &&\n           \"DeclarationName does not store an IdentifierInfo!\");\n    return static_cast<IdentifierInfo *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a DeclarationNameExtra\n  /// and return it.\n  detail::DeclarationNameExtra *castAsExtra() const {\n    assert((getStoredNameKind() == StoredDeclarationNameExtra) &&\n           \"DeclarationName does not store an Extra structure!\");\n    return static_cast<detail::DeclarationNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXSpecialNameExtra\n  /// and return it.\n  detail::CXXSpecialNameExtra *castAsCXXSpecialNameExtra() const {\n    assert((getStoredNameKind() == StoredCXXConstructorName ||\n           getStoredNameKind() == StoredCXXDestructorName ||\n           getStoredNameKind() == StoredCXXConversionFunctionName) &&\n               \"DeclarationName does not store a CXXSpecialNameExtra!\");\n    return static_cast<detail::CXXSpecialNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXOperatorIdName\n  /// and return it.\n  detail::CXXOperatorIdName *castAsCXXOperatorIdName() const {\n    assert((getStoredNameKind() == StoredCXXOperatorName) &&\n           \"DeclarationName does not store a CXXOperatorIdName!\");\n    return static_cast<detail::CXXOperatorIdName *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXDeductionGuideNameExtra\n  /// and return it.\n  detail::CXXDeductionGuideNameExtra *castAsCXXDeductionGuideNameExtra() const {\n    assert(getNameKind() == CXXDeductionGuideName &&\n           \"DeclarationName does not store a CXXDeductionGuideNameExtra!\");\n    return static_cast<detail::CXXDeductionGuideNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXLiteralOperatorIdName\n  /// and return it.\n  detail::CXXLiteralOperatorIdName *castAsCXXLiteralOperatorIdName() const {\n    assert(getNameKind() == CXXLiteralOperatorName &&\n           \"DeclarationName does not store a CXXLiteralOperatorIdName!\");\n    return static_cast<detail::CXXLiteralOperatorIdName *>(getPtr());\n  }\n\n  /// Get and set the FETokenInfo in the less common cases where the\n  /// declaration name do not point to an identifier.\n  void *getFETokenInfoSlow() const;\n  void setFETokenInfoSlow(void *T);\n\npublic:\n  /// Construct an empty declaration name.\n  DeclarationName() { setPtrAndKind(nullptr, StoredIdentifier); }\n\n  /// Construct a declaration name from an IdentifierInfo *.\n  DeclarationName(const IdentifierInfo *II) {\n    setPtrAndKind(II, StoredIdentifier);\n  }\n\n  /// Construct a declaration name from an Objective-C selector.\n  DeclarationName(Selector Sel) : Ptr(Sel.InfoPtr) {}\n\n  /// Returns the name for all C++ using-directives.\n  static DeclarationName getUsingDirectiveName() {\n    // Single instance of DeclarationNameExtra for using-directive\n    static detail::DeclarationNameExtra UDirExtra(\n        detail::DeclarationNameExtra::CXXUsingDirective);\n    return DeclarationName(&UDirExtra);\n  }\n\n  /// Evaluates true when this declaration name is non-empty.\n  explicit operator bool() const {\n    return getPtr() || (getStoredNameKind() != StoredIdentifier);\n  }\n\n  /// Evaluates true when this declaration name is empty.\n  bool isEmpty() const { return !*this; }\n\n  /// Predicate functions for querying what type of name this is.\n  bool isIdentifier() const { return getStoredNameKind() == StoredIdentifier; }\n  bool isObjCZeroArgSelector() const {\n    return getStoredNameKind() == StoredObjCZeroArgSelector;\n  }\n  bool isObjCOneArgSelector() const {\n    return getStoredNameKind() == StoredObjCOneArgSelector;\n  }\n\n  /// Determine what kind of name this is.\n  NameKind getNameKind() const {\n    // We rely on the fact that the first 7 NameKind and StoredNameKind\n    // have the same numerical value. This makes the usual case efficient.\n    StoredNameKind StoredKind = getStoredNameKind();\n    if (StoredKind != StoredDeclarationNameExtra)\n      return static_cast<NameKind>(StoredKind);\n    // We have to consult DeclarationNameExtra. We rely on the fact that the\n    // enumeration values of ExtraKind correspond to the enumeration values of\n    // NameKind minus an offset of UncommonNameKindOffset.\n    unsigned ExtraKind = castAsExtra()->getKind();\n    return static_cast<NameKind>(UncommonNameKindOffset + ExtraKind);\n  }\n\n  /// Determines whether the name itself is dependent, e.g., because it\n  /// involves a C++ type that is itself dependent.\n  ///\n  /// Note that this does not capture all of the notions of \"dependent name\",\n  /// because an identifier can be a dependent name if it is used as the\n  /// callee in a call expression with dependent arguments.\n  bool isDependentName() const;\n\n  /// Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// Retrieve the IdentifierInfo * stored in this declaration name,\n  /// or null if this declaration name isn't a simple identifier.\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (isIdentifier())\n      return castAsIdentifierInfo();\n    return nullptr;\n  }\n\n  /// Get the representation of this declaration name as an opaque integer.\n  uintptr_t getAsOpaqueInteger() const { return Ptr; }\n\n  /// Get the representation of this declaration name as an opaque pointer.\n  void *getAsOpaquePtr() const { return reinterpret_cast<void *>(Ptr); }\n\n  /// Get a declaration name from an opaque pointer returned by getAsOpaquePtr.\n  static DeclarationName getFromOpaquePtr(void *P) {\n    DeclarationName N;\n    N.Ptr = reinterpret_cast<uintptr_t>(P);\n    return N;\n  }\n\n  /// Get a declaration name from an opaque integer\n  /// returned by getAsOpaqueInteger.\n  static DeclarationName getFromOpaqueInteger(uintptr_t P) {\n    DeclarationName N;\n    N.Ptr = P;\n    return N;\n  }\n\n  /// If this name is one of the C++ names (of a constructor, destructor,\n  /// or conversion function), return the type associated with that name.\n  QualType getCXXNameType() const {\n    if (getStoredNameKind() == StoredCXXConstructorName ||\n        getStoredNameKind() == StoredCXXDestructorName ||\n        getStoredNameKind() == StoredCXXConversionFunctionName) {\n      assert(getPtr() && \"getCXXNameType on a null DeclarationName!\");\n      return castAsCXXSpecialNameExtra()->Type;\n    }\n    return QualType();\n  }\n\n  /// If this name is the name of a C++ deduction guide, return the\n  /// template associated with that name.\n  TemplateDecl *getCXXDeductionGuideTemplate() const {\n    if (getNameKind() == CXXDeductionGuideName) {\n      assert(getPtr() &&\n             \"getCXXDeductionGuideTemplate on a null DeclarationName!\");\n      return castAsCXXDeductionGuideNameExtra()->Template;\n    }\n    return nullptr;\n  }\n\n  /// If this name is the name of an overloadable operator in C++\n  /// (e.g., @c operator+), retrieve the kind of overloaded operator.\n  OverloadedOperatorKind getCXXOverloadedOperator() const {\n    if (getStoredNameKind() == StoredCXXOperatorName) {\n      assert(getPtr() && \"getCXXOverloadedOperator on a null DeclarationName!\");\n      return castAsCXXOperatorIdName()->Kind;\n    }\n    return OO_None;\n  }\n\n  /// If this name is the name of a literal operator,\n  /// retrieve the identifier associated with it.\n  const IdentifierInfo *getCXXLiteralIdentifier() const {\n    if (getNameKind() == CXXLiteralOperatorName) {\n      assert(getPtr() && \"getCXXLiteralIdentifier on a null DeclarationName!\");\n      return castAsCXXLiteralOperatorIdName()->ID;\n    }\n    return nullptr;\n  }\n\n  /// Get the Objective-C selector stored in this declaration name.\n  Selector getObjCSelector() const {\n    assert((getNameKind() == ObjCZeroArgSelector ||\n            getNameKind() == ObjCOneArgSelector ||\n            getNameKind() == ObjCMultiArgSelector || !getPtr()) &&\n           \"Not a selector!\");\n    return Selector(Ptr);\n  }\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with some kinds of declaration names, including normal\n  /// identifiers and C++ constructors, destructors, and conversion functions.\n  void *getFETokenInfo() const {\n    assert(getPtr() && \"getFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      return castAsIdentifierInfo()->getFETokenInfo();\n    return getFETokenInfoSlow();\n  }\n\n  void setFETokenInfo(void *T) {\n    assert(getPtr() && \"setFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      castAsIdentifierInfo()->setFETokenInfo(T);\n    else\n      setFETokenInfoSlow(T);\n  }\n\n  /// Determine whether the specified names are identical.\n  friend bool operator==(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  /// Determine whether the specified names are different.\n  friend bool operator!=(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\n  static DeclarationName getEmptyMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-1);\n    return Name;\n  }\n\n  static DeclarationName getTombstoneMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-2);\n    return Name;\n  }\n\n  static int compare(DeclarationName LHS, DeclarationName RHS);\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  void dump() const;\n}",
  "id": "BLOCK-CPP-09452",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclarationName.h",
  "source_line": 144,
  "validation_status": "validated"
}