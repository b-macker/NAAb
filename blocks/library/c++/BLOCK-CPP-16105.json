{
  "code": "{\n\nnamespace optional_detail {\ntemplate <typename> class OptionalStorage;\n} // namespace optional_detail\n\n// Optional type which internal storage can be specialized by providing\n// OptionalStorage. The interface follows std::optional.\ntemplate <typename T> class CustomizableOptional {\n  optional_detail::OptionalStorage<T> Storage;\n\npublic:\n  using value_type = T;\n\n  constexpr CustomizableOptional() = default;\n  constexpr CustomizableOptional(std::nullopt_t) {}\n\n  constexpr CustomizableOptional(const T &y) : Storage(std::in_place, y) {}\n  constexpr CustomizableOptional(const CustomizableOptional &O) = default;\n\n  constexpr CustomizableOptional(T &&y)\n      : Storage(std::in_place, std::move(y)) {}\n  constexpr CustomizableOptional(CustomizableOptional &&O) = default;\n\n  template <typename... ArgTypes>\n  constexpr CustomizableOptional(std::in_place_t, ArgTypes &&...Args)\n      : Storage(std::in_place, std::forward<ArgTypes>(Args)...) {}\n\n  // Allow conversion from std::optional<T>.\n  constexpr CustomizableOptional(const std::optional<T> &y)\n      : CustomizableOptional(y ? *y : CustomizableOptional()) {}\n  constexpr CustomizableOptional(std::optional<T> &&y)\n      : CustomizableOptional(y ? std::move(*y) : CustomizableOptional()) {}\n\n  CustomizableOptional &operator=(T &&y) {\n    Storage = std::move(y);\n    return *this;\n  }\n  CustomizableOptional &operator=(CustomizableOptional &&O) = default;\n\n  /// Create a new object by constructing it in place with the given arguments.\n  template <typename... ArgTypes> void emplace(ArgTypes &&...Args) {\n    Storage.emplace(std::forward<ArgTypes>(Args)...);\n  }\n\n  CustomizableOptional &operator=(const T &y) {\n    Storage = y;\n    return *this;\n  }\n  CustomizableOptional &operator=(const CustomizableOptional &O) = default;\n\n  void reset() { Storage.reset(); }\n\n  LLVM_DEPRECATED(\"Use &*X instead.\", \"&*X\")\n  constexpr const T *getPointer() const { return &Storage.value(); }\n  LLVM_DEPRECATED(\"Use &*X instead.\", \"&*X\")\n  T *getPointer() { return &Storage.value(); }\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  constexpr const T &value() const & { return Storage.value(); }\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  T &value() & { return Storage.value(); }\n\n  constexpr explicit operator bool() const { return has_value(); }\n  constexpr bool has_value() const { return Storage.has_value(); }\n  constexpr const T *operator->() const { return &Storage.value(); }\n  T *operator->() { return &Storage.value(); }\n  constexpr const T &operator*() const & { return Storage.value(); }\n  T &operator*() & { return Storage.value(); }\n\n  template <typename U> constexpr T value_or(U &&alt) const & {\n    return has_value() ? operator*() : std::forward<U>(alt);\n  }\n\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  T &&value() && { return std::move(Storage.value()); }\n  T &&operator*() && { return std::move(Storage.value()); }\n\n  template <typename U> T value_or(U &&alt) && {\n    return has_value() ? std::move(operator*()) : std::forward<U>(alt);\n  }\n\n  // Allow conversion to std::optional<T>.\n  explicit operator std::optional<T> &() const & {\n    return *this ? **this : std::optional<T>();\n  }\n  explicit operator std::optional<T> &&() const && {\n    return *this ? std::move(**this) : std::optional<T>();\n  }\n};\n\ntemplate <typename T>\nCustomizableOptional(const T &) -> CustomizableOptional<T>;\n\ntemplate <class T>\nllvm::hash_code hash_value(const CustomizableOptional<T> &O) {\n  return O ? llvm::hash_combine(true, *O) : llvm::hash_value(false);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator==(const CustomizableOptional<T> &X,\n                          const CustomizableOptional<U> &Y) {\n  if (X && Y)\n    return *X == *Y;\n  return X.has_value() == Y.has_value();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator!=(const CustomizableOptional<T> &X,\n                          const CustomizableOptional<U> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<(const CustomizableOptional<T> &X,\n                         const CustomizableOptional<U> &Y) {\n  if (X && Y)\n    return *X < *Y;\n  return X.has_value() < Y.has_value();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<=(const CustomizableOptional<T> &X,\n                          const CustomizableOptional<U> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>(const CustomizableOptional<T> &X,\n                         const CustomizableOptional<U> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>=(const CustomizableOptional<T> &X,\n                          const CustomizableOptional<U> &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const CustomizableOptional<T> &X, std::nullopt_t) {\n  return !X;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return X == std::nullopt;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const CustomizableOptional<T> &X, std::nullopt_t) {\n  return !(X == std::nullopt);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return X != std::nullopt;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const CustomizableOptional<T> &, std::nullopt_t) {\n  return false;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return X.has_value();\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const CustomizableOptional<T> &X, std::nullopt_t) {\n  return !(std::nullopt < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return !(X < std::nullopt);\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const CustomizableOptional<T> &X, std::nullopt_t) {\n  return std::nullopt < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return X < std::nullopt;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const CustomizableOptional<T> &X, std::nullopt_t) {\n  return std::nullopt <= X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(std::nullopt_t, const CustomizableOptional<T> &X) {\n  return X <= std::nullopt;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const CustomizableOptional<T> &X, const T &Y) {\n  return X && *X == Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const T &X, const CustomizableOptional<T> &Y) {\n  return Y && X == *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const CustomizableOptional<T> &X, const T &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const T &X, const CustomizableOptional<T> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const CustomizableOptional<T> &X, const T &Y) {\n  return !X || *X < Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const T &X, const CustomizableOptional<T> &Y) {\n  return Y && X < *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const CustomizableOptional<T> &X, const T &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const T &X, const CustomizableOptional<T> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const CustomizableOptional<T> &X, const T &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const T &X, const CustomizableOptional<T> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const CustomizableOptional<T> &X, const T &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const T &X, const CustomizableOptional<T> &Y) {\n  return !(X < Y);\n}\n\n}",
  "id": "BLOCK-CPP-16105",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/CustomizableOptional.h",
  "source_line": 20,
  "validation_status": "validated"
}