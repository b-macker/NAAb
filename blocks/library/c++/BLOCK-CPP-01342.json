{
  "code": "{\n  auto significand = f.significand;\n  int significand_size = get_significand_size(f);\n  const Char zero = static_cast<Char>('0');\n  auto sign = fspecs.sign;\n  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);\n  using iterator = reserve_iterator<OutputIt>;\n\n  Char decimal_point =\n      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');\n\n  int output_exp = f.exponent + significand_size - 1;\n  auto use_exp_format = [=]() {\n    if (fspecs.format == float_format::exp) return true;\n    if (fspecs.format != float_format::general) return false;\n    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),\n    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.\n    const int exp_lower = -4, exp_upper = 16;\n    return output_exp < exp_lower ||\n           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);\n  };\n  if (use_exp_format()) {\n    int num_zeros = 0;\n    if (fspecs.showpoint) {\n      num_zeros = fspecs.precision - significand_size;\n      if (num_zeros < 0) num_zeros = 0;\n      size += to_unsigned(num_zeros);\n    } else if (significand_size == 1) {\n      decimal_point = Char();\n    }\n    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;\n    int exp_digits = 2;\n    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;\n\n    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);\n    char exp_char = fspecs.upper ? 'E' : 'e';\n    auto write = [=](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      // Insert a decimal point after the first digit and add an exponent.\n      it = write_significand(it, significand, significand_size, 1,\n                             decimal_point);\n      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);\n      *it++ = static_cast<Char>(exp_char);\n      return write_exponent<Char>(output_exp, it);\n    };\n    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)\n                           : base_iterator(out, write(reserve(out, size)));\n  }\n\n  int exp = f.exponent + significand_size;\n  if (f.exponent >= 0) {\n    // 1234e5 -> 123400000[.0+]\n    size += to_unsigned(f.exponent);\n    int num_zeros = fspecs.precision - exp;\n    abort_fuzzing_if(num_zeros > 5000);\n    if (fspecs.showpoint) {\n      ++size;\n      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;\n      if (num_zeros > 0) size += to_unsigned(num_zeros);\n    }\n    auto grouping = Grouping(loc, fspecs.locale);\n    size += to_unsigned(grouping.count_separators(exp));\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      it = write_significand<Char>(it, significand, significand_size,\n                                   f.exponent, grouping);\n      if (!fspecs.showpoint) return it;\n      *it++ = decimal_point;\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\n    });\n  } else if (exp > 0) {\n    // 1234e-2 -> 12.34[0+]\n    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;\n    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);\n    auto grouping = Grouping(loc, fspecs.locale);\n    size += to_unsigned(grouping.count_separators(significand_size));\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\n      if (sign) *it++ = detail::sign<Char>(sign);\n      it = write_significand(it, significand, significand_size, exp,\n                             decimal_point, grouping);\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\n    });\n  }\n  // 1234e-6 -> 0.001234\n  int num_zeros = -exp;\n  if (significand_size == 0 && fspecs.precision >= 0 &&\n      fspecs.precision < num_zeros) {\n    num_zeros = fspecs.precision;\n  }\n  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;\n  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);\n  return write_padded<align::right>(out, specs, size, [&](iterator it) {\n    if (sign) *it++ = detail::sign<Char>(sign);\n    *it++ = zero;\n    if (!pointy) return it;\n    *it++ = decimal_point;\n    it = detail::fill_n(it, num_zeros, zero);\n    return write_significand<Char>(it, significand, significand_size);\n  });\n}",
  "id": "BLOCK-CPP-01342",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 2361,
  "validation_status": "validated"
}