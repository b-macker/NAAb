{
  "code": "{\n  ///        void bar();                                void bar();\n  ///      protected:                                 protected:\n  ///        D();                                       D();\n  ///      };                                       };\n  ///    public:                                  public:\n  ///      C();                                     C();\n  ///    };                                     };\n  ///    void foo() {                           void foo() {\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 13\n  bool IndentAccessModifiers;\n\n  /// Indent case label blocks one level from the case label.\n  ///\n  /// When ``false``, the block following the case label uses the same\n  /// indentation level as for the case label, treating the case label the same\n  /// as an if-statement.\n  /// When ``true``, the block gets indented as a scope block.\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1: {                              case 1:\n  ///      bar();                                 {\n  ///    } break;                                   bar();\n  ///    default: {                               }\n  ///      plop();                                break;\n  ///    }                                      default:\n  ///    }                                        {\n  ///                                               plop();\n  ///                                             }\n  ///                                           }\n  /// \\endcode\n  /// \\version 11\n  bool IndentCaseBlocks;\n\n  /// Indent case labels one level from the switch statement.\n  ///\n  /// When ``false``, use the same indentation level as for the switch\n  /// statement. Switch statement body is always indented one level more than\n  /// case labels (except the first block following the case label, which\n  /// itself indents the code - unless IndentCaseBlocks is enabled).\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1:                                  case 1:\n  ///      bar();                                   bar();\n  ///      break;                                   break;\n  ///    default:                                 default:\n  ///      plop();                                  plop();\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 3.3\n  bool IndentCaseLabels;\n\n  /// Indent goto labels.\n  ///\n  /// When ``false``, goto labels are flushed left.\n  /// \\code\n  ///    true:                                  false:\n  ///    int f() {                      vs.     int f() {\n  ///      if (foo()) {                           if (foo()) {\n  ///      label1:                              label1:\n  ///        bar();                                 bar();\n  ///      }                                      }\n  ///    label2:                                label2:\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 10\n  bool IndentGotoLabels;\n\n  /// Indents extern blocks\n  enum IndentExternBlockStyle : int8_t {\n    /// Backwards compatible with AfterExternBlock's indenting.\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: true\n    ///    extern \"C\"\n    ///    {\n    ///        void foo();\n    ///    }\n    /// \\endcode\n    ///\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: false\n    ///    extern \"C\" {\n    ///    void foo();\n    ///    }\n    /// \\endcode\n    IEBS_AfterExternBlock,\n    /// Does not indent extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///     void foo();\n    ///     }\n    /// \\endcode\n    IEBS_NoIndent,\n    /// Indents extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///       void foo();\n    ///     }\n    /// \\endcode\n    IEBS_Indent,\n  };\n\n  /// IndentExternBlockStyle is the type of indenting of extern blocks.\n  /// \\version 11\n  IndentExternBlockStyle IndentExternBlock;\n\n  /// Options for indenting preprocessor directives.\n  enum PPDirectiveIndentStyle : int8_t {\n    /// Does not indent any directives.\n    /// \\code\n    ///    #if FOO\n    ///    #if BAR\n    ///    #include <foo>\n    ///    #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_None,\n    /// Indents directives after the hash.\n    /// \\code\n    ///    #if FOO\n    ///    #  if BAR\n    ///    #    include <foo>\n    ///    #  endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_AfterHash,\n    /// Indents directives before the hash.\n    /// \\code\n    ///    #if FOO\n    ///      #if BAR\n    ///        #include <foo>\n    ///      #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_BeforeHash\n  };\n\n  /// The preprocessor directive indenting style to use.\n  /// \\version 6\n  PPDirectiveIndentStyle IndentPPDirectives;\n\n  /// Indent the requires clause in a template. This only applies when\n  /// ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``.\n  ///\n  /// In clang-format 12, 13 and 14 it was named ``IndentRequires``.\n  /// \\code\n  ///    true:\n  ///    template <typename It>\n  ///      requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  ///\n  ///    false:\n  ///    template <typename It>\n  ///    requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  /// \\endcode\n  /// \\version 15\n  bool IndentRequiresClause;\n\n  /// The number of columns to use for indentation.\n  /// \\code\n  ///    IndentWidth: 3\n  ///\n  ///    void f() {\n  ///       someFunction();\n  ///       if (true, false) {\n  ///          f();\n  ///       }\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned IndentWidth;\n\n  /// Indent if a function definition or declaration is wrapped after the\n  /// type.\n  /// \\code\n  ///    true:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///        LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  ///\n  ///    false:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///    LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  /// \\endcode\n  /// \\version 3.7\n  bool IndentWrappedFunctionNames;\n\n  /// Insert braces after control statements (``if``, ``else``, ``for``, ``do``,\n  /// and ``while``) in C++ unless the control statements are inside macro\n  /// definitions or the braces would enclose preprocessor directives.\n  /// \\warning\n  ///  Setting this option to ``true`` could lead to incorrect code formatting\n  ///  due to clang-format's lack of complete semantic information. As such,\n  ///  extra care should be taken to review code changes made by this option.\n  /// \\endwarning\n  /// \\code\n  ///   false:                                    true:\n  ///\n  ///   if (isa<FunctionDecl>(D))        vs.      if (isa<FunctionDecl>(D)) {\n  ///     handleFunctionDecl(D);                    handleFunctionDecl(D);\n  ///   else if (isa<VarDecl>(D))                 } else if (isa<VarDecl>(D)) {\n  ///     handleVarDecl(D);                         handleVarDecl(D);\n  ///   else                                      } else {\n  ///     return;                                   return;\n  ///                                             }\n  ///\n  ///   while (i--)                      vs.      while (i--) {\n  ///     for (auto *A : D.attrs())                 for (auto *A : D.attrs()) {\n  ///       handleAttr(A);                            handleAttr(A);\n  ///                                               }\n  ///                                             }\n  ///\n  ///   do                               vs.      do {\n  ///     --i;                                      --i;\n  ///   while (i);                                } while (i);\n  /// \\endcode\n  /// \\version 15\n  bool InsertBraces;\n\n  /// Insert a newline at end of file if missing.\n  /// \\version 16\n  bool InsertNewlineAtEOF;\n\n  /// The style of inserting trailing commas into container literals.\n  enum TrailingCommaStyle : int8_t {\n    /// Do not insert trailing commas.\n    TCS_None,\n    /// Insert trailing commas in container literals that were wrapped over\n    /// multiple lines. Note that this is conceptually incompatible with\n    /// bin-packing, because the trailing comma is used as an indicator\n    /// that a container should be formatted one-per-line (i.e. not bin-packed).\n    /// So inserting a trailing comma counteracts bin-packing.\n    TCS_Wrapped,\n  };\n\n  /// If set to ``TCS_Wrapped`` will insert trailing commas in container\n  /// literals (arrays and objects) that wrap across multiple lines.\n  /// It is currently only available for JavaScript\n  /// and disabled by default ``TCS_None``.\n  /// ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\n  /// as inserting the comma disables bin-packing.\n  /// \\code\n  ///   TSC_Wrapped:\n  ///   const someArray = [\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   //                        ^ inserted\n  ///   ]\n  /// \\endcode\n  /// \\version 11\n  TrailingCommaStyle InsertTrailingCommas;\n\n  /// Separator format of integer literals of different bases.\n  ///\n  /// If negative, remove separators. If  ``0``, leave the literal as is. If\n  /// positive, insert separators between digits starting from the rightmost\n  /// digit.\n  ///\n  /// For example, the config below will leave separators in binary literals\n  /// alone, insert separators in decimal literals to separate the digits into\n  /// groups of 3, and remove separators in hexadecimal literals.\n  /// \\code\n  ///   IntegerLiteralSeparator:\n  ///     Binary: 0\n  ///     Decimal: 3\n  ///     Hex: -1\n  /// \\endcode\n  ///\n  /// You can also specify a minimum number of digits (``BinaryMinDigits``,\n  /// ``DecimalMinDigits``, and ``HexMinDigits``) the integer literal must\n  /// have in order for the separators to be inserted.\n  struct IntegerLiteralSeparatorStyle {\n    /// Format separators in binary literals.\n    /// \\code{.text}\n    ///   /* -1: */ b = 0b100111101101;\n    ///   /*  0: */ b = 0b10011'11'0110'1;\n    ///   /*  3: */ b = 0b100'111'101'101;\n    ///   /*  4: */ b = 0b1001'1110'1101;\n    /// \\endcode\n    int8_t Binary;\n    /// Format separators in binary literals with a minimum number of digits.\n    /// \\code{.text}\n    ///   // Binary: 3\n    ///   // BinaryMinDigits: 7\n    ///   b1 = 0b101101;\n    ///   b2 = 0b1'101'101;\n    /// \\endcode\n    int8_t BinaryMinDigits;\n    /// Format separators in decimal literals.\n    /// \\code{.text}\n    ///   /* -1: */ d = 18446744073709550592ull;\n    ///   /*  0: */ d = 184467'440737'0'95505'92ull;\n    ///   /*  3: */ d = 18'446'744'073'709'550'592ull;\n    /// \\endcode\n    int8_t Decimal;\n    /// Format separators in decimal literals with a minimum number of digits.\n    /// \\code{.text}\n    ///   // Decimal: 3\n    ///   // DecimalMinDigits: 5\n    ///   d1 = 2023;\n    ///   d2 = 10'000;\n    /// \\endcode\n    int8_t DecimalMinDigits;\n    /// Format separators in hexadecimal literals.\n    /// \\code{.text}\n    ///   /* -1: */ h = 0xDEADBEEFDEADBEEFuz;\n    ///   /*  0: */ h = 0xDEAD'BEEF'DE'AD'BEE'Fuz;\n    ///   /*  2: */ h = 0xDE'AD'BE'EF'DE'AD'BE'EFuz;\n    /// \\endcode\n    int8_t Hex;\n    /// Format separators in hexadecimal literals with a minimum number of\n    /// digits.\n    /// \\code{.text}\n    ///   // Hex: 2\n    ///   // HexMinDigits: 6\n    ///   h1 = 0xABCDE;\n    ///   h2 = 0xAB'CD'EF;\n    /// \\endcode\n    int8_t HexMinDigits;\n    bool operator==(const IntegerLiteralSeparatorStyle &R) const {\n      return Binary == R.Binary && BinaryMinDigits == R.BinaryMinDigits &&\n             Decimal == R.Decimal && DecimalMinDigits == R.DecimalMinDigits &&\n             Hex == R.Hex && HexMinDigits == R.HexMinDigits;\n    }\n  };\n\n  /// Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,\n  /// and JavaScript).\n  /// \\version 16\n  IntegerLiteralSeparatorStyle IntegerLiteralSeparator;\n\n  /// A vector of prefixes ordered by the desired groups for Java imports.\n  ///\n  /// One group's prefix can be a subset of another - the longest prefix is\n  /// always matched. Within a group, the imports are ordered lexicographically.\n  /// Static imports are grouped separately and follow the same group rules.\n  /// By default, static imports are placed before non-static imports,\n  /// but this behavior is changed by another option,\n  /// ``SortJavaStaticImport``.\n  ///\n  /// In the .clang-format configuration file, this can be configured like\n  /// in the following yaml example. This will result in imports being\n  /// formatted as in the Java example below.\n  /// \\code{.yaml}\n  ///   JavaImportGroups: ['com.example', 'com', 'org']\n  /// \\endcode\n  ///\n  /// \\code{.java}\n  ///    import static com.example.function1;\n  ///\n  ///    import static com.test.function2;\n  ///\n  ///    import static org.example.function3;\n  ///\n  ///    import com.example.ClassA;\n  ///    import com.example.Test;\n  ///    import com.example.a.ClassB;\n  ///\n  ///    import com.test.ClassC;\n  ///\n  ///    import org.example.ClassD;\n  /// \\endcode\n  /// \\version 8\n  std::vector<std::string> JavaImportGroups;\n\n  /// Quotation styles for JavaScript strings. Does not affect template\n  /// strings.\n  enum JavaScriptQuoteStyle : int8_t {\n    /// Leave string quotes as they are.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Leave,\n    /// Always use single quotes.\n    /// \\code{.js}\n    ///    string1 = 'foo';\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Single,\n    /// Always use double quotes.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = \"bar\";\n    /// \\endcode\n    JSQS_Double\n  };\n\n  /// The JavaScriptQuoteStyle to use for JavaScript strings.\n  /// \\version 3.9\n  JavaScriptQuoteStyle JavaScriptQuotes;\n\n  // clang-format off\n  /// Whether to wrap JavaScript import/export statements.\n  /// \\code{.js}\n  ///    true:\n  ///    import {\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///    } from 'some/module.js'\n  ///\n  ///    false:\n  ///    import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"\n  /// \\endcode\n  /// \\version 3.9\n  bool JavaScriptWrapImports;\n  // clang-format on\n\n  /// Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file.\n  /// \\version 17\n  bool KeepEmptyLinesAtEOF;\n\n  /// If true, the empty line at the start of blocks is kept.\n  /// \\code\n  ///    true:                                  false:\n  ///    if (foo) {                     vs.     if (foo) {\n  ///                                             bar();\n  ///      bar();                               }\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  bool KeepEmptyLinesAtTheStartOfBlocks;\n\n  /// Indentation logic for lambda bodies.\n  enum LambdaBodyIndentationKind : int8_t {\n    /// Align lambda body relative to the lambda signature. This is the default.\n    /// \\code\n    ///    someMethod(\n    ///        [](SomeReallyLongLambdaSignatureArgument foo) {\n    ///          return;\n    ///        });\n    /// \\endcode\n    LBI_Signature,\n    /// Align lambda body relative to the indentation level of the outer scope\n    /// the lambda signature resides in.\n    /// \\code\n    ///    someMethod(\n    ///        [](SomeReallyLongLambdaSignatureArgument foo) {\n    ///      return;\n    ///    });\n    ///\n    ///    someMethod(someOtherMethod(\n    ///        [](SomeReallyLongLambdaSignatureArgument foo) {\n    ///      return;\n    ///    }));\n    /// \\endcode\n    LBI_OuterScope,\n  };\n\n  /// The indentation style of lambda bodies. ``Signature`` (the default)\n  /// causes the lambda body to be indented one additional level relative to\n  /// the indentation level of the signature. ``OuterScope`` forces the lambda\n  /// body to be indented one additional level relative to the parent scope\n  /// containing the lambda signature.\n  /// \\version 13\n  LambdaBodyIndentationKind LambdaBodyIndentation;\n\n  /// Supported languages.\n  ///\n  /// When stored in a configuration file, specifies the language, that the\n  /// configuration targets. When passed to the ``reformat()`` function, enables\n  /// syntax features specific to the language.\n  enum LanguageKind : int8_t {\n    /// Do not use.\n    LK_None,\n    /// Should be used for C, C++.\n    LK_Cpp,\n    /// Should be used for C#.\n    LK_CSharp,\n    /// Should be used for Java.\n    LK_Java,\n    /// Should be used for JavaScript.\n    LK_JavaScript,\n    /// Should be used for JSON.\n    LK_Json,\n    /// Should be used for Objective-C, Objective-C++.\n    LK_ObjC,\n    /// Should be used for Protocol Buffers\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_Proto,\n    /// Should be used for TableGen code.\n    LK_TableGen,\n    /// Should be used for Protocol Buffer messages in text format\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_TextProto,\n    /// Should be used for Verilog and SystemVerilog.\n    /// https://standards.ieee.org/ieee/1800/6700/\n    /// https://sci-hub.st/10.1109/IEEESTD.2018.8299595\n    LK_Verilog\n  };\n  bool isCpp() const { return Language == LK_Cpp || Language == LK_ObjC; }\n  bool isCSharp() const { return Language == LK_CSharp; }\n  bool isJson() const { return Language == LK_Json; }\n  bool isJavaScript() const { return Language == LK_JavaScript; }\n  bool isVerilog() const { return Language == LK_Verilog; }\n  bool isProto() const { return Language == LK_Proto; }\n\n  /// Language, this format style is targeted at.\n  /// \\version 3.5\n  LanguageKind Language;\n\n  /// Line ending style.\n  enum LineEndingStyle : int8_t {\n    /// Use ``\\n``.\n    LE_LF,\n    /// Use ``\\r\\n``.\n    LE_CRLF,\n    /// Use ``\\n`` unless the input has more lines ending in ``\\r\\n``.\n    LE_DeriveLF,\n    /// Use ``\\r\\n`` unless the input has more lines ending in ``\\n``.\n    LE_DeriveCRLF,\n  };\n\n  /// Line ending style (``\\n`` or ``\\r\\n``) to use.\n  /// \\version 16\n  LineEndingStyle LineEnding;\n\n  /// A regular expression matching macros that start a block.\n  /// \\code\n  ///    # With:\n  ///    MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n  ///    NS_TABLE_HEAD$\"\n  ///    MacroBlockEnd: \"^\\\n  ///    NS_MAP_END|\\\n  ///    NS_TABLE_.*_END$\"\n  ///\n  ///    NS_MAP_BEGIN\n  ///      foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///      bar();\n  ///    NS_TABLE_FOO_END\n  ///\n  ///    # Without:\n  ///    NS_MAP_BEGIN\n  ///    foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///    bar();\n  ///    NS_TABLE_FOO_END\n  /// \\endcode\n  /// \\version 3.7\n  std::string MacroBlockBegin;\n\n  /// A regular expression matching macros that end a block.\n  /// \\version 3.7\n  std::string MacroBlockEnd;\n\n  /// A list of macros of the form \\c <definition>=<expansion> .\n  ///\n  /// Code will be parsed with macros expanded, in order to determine how to\n  /// interpret and format the macro arguments.\n  ///\n  /// For example, the code:\n  /// \\code\n  ///   A(a*b);\n  /// \\endcode\n  ///\n  /// will usually be interpreted as a call to a function A, and the\n  /// multiplication expression will be formatted as ``a * b``.\n  ///\n  /// If we specify the macro definition:\n  /// \\code{.yaml}\n  ///   Macros:\n  ///   - A(x)=x\n  /// \\endcode\n  ///\n  /// the code will now be parsed as a declaration of the variable b of type a*,\n  /// and formatted as ``a* b`` (depending on pointer-binding rules).\n  ///\n  /// Features and restrictions:\n  ///  * Both function-like macros and object-like macros are supported.\n  ///  * Macro arguments must be used exactly once in the expansion.\n  ///  * No recursive expansion; macros referencing other macros will be\n  ///    ignored.\n  ///  * Overloading by arity is supported: for example, given the macro\n  ///    definitions A=x, A()=y, A(a)=a\n  ///\n  /// \\code\n  ///    A; -> x;\n  ///    A(); -> y;\n  ///    A(z); -> z;\n  ///    A(a, b); // will not be expanded.\n  /// \\endcode\n  ///\n  /// \\version 17.0\n  std::vector<std::string> Macros;\n\n  /// The maximum number of consecutive empty lines to keep.\n  /// \\code\n  ///    MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n  ///    int f() {                              int f() {\n  ///      int = 1;                                 int i = 1;\n  ///                                               i = foo();\n  ///      i = foo();                               return i;\n  ///                                           }\n  ///      return i;\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned MaxEmptyLinesToKeep;\n\n  /// Different ways to indent namespace contents.\n  enum NamespaceIndentationKind : int8_t {\n    /// Don't indent in namespaces.\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///    int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_None,\n    /// Indent only in inner namespaces (nested in other namespaces).\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///      int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_Inner,\n    /// Indent in all namespaces.\n    /// \\code\n    ///    namespace out {\n    ///      int i;\n    ///      namespace in {\n    ///        int i;\n    ///      }\n    ///    }\n    /// \\endcode\n    NI_All\n  };\n\n  /// The indentation used for namespaces.\n  /// \\version 3.7\n  NamespaceIndentationKind NamespaceIndentation;\n\n  /// A vector of macros which are used to open namespace blocks.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   NAMESPACE(<namespace-name>, ...) {\n  ///     <namespace-content>\n  ///   }\n  /// \\endcode\n  ///\n  /// For example: TESTSUITE\n  /// \\version 9\n  std::vector<std::string> NamespaceMacros;\n\n  /// Controls bin-packing Objective-C protocol conformance list\n  /// items into as few lines as possible when they go over ``ColumnLimit``.\n  ///\n  /// If ``Auto`` (the default), delegates to the value in\n  /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  /// protocol conformance list items into as few lines as possible\n  /// whenever they go over ``ColumnLimit``.\n  ///\n  /// If ``Always``, always bin-packs Objective-C protocol conformance\n  /// list items into as few lines as possible whenever they go over\n  /// ``ColumnLimit``.\n  ///\n  /// If ``Never``, lays out Objective-C protocol conformance list items\n  /// onto individual lines whenever they go over ``ColumnLimit``.\n  ///\n  /// \\code{.objc}\n  ///    Always (or Auto, if BinPackParameters=true):\n  ///    @interface ccccccccccccc () <\n  ///        ccccccccccccc, ccccccccccccc,\n  ///        ccccccccccccc, ccccccccccccc> {\n  ///    }\n  ///\n  ///    Never (or Auto, if BinPackParameters=false):\n  ///    @interface ddddddddddddd () <\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd> {\n  ///    }\n  /// \\endcode\n  /// \\version 7\n  BinPackStyle ObjCBinPackProtocolList;\n\n  /// The number of characters to use for indentation of ObjC blocks.\n  /// \\code{.objc}\n  ///    ObjCBlockIndentWidth: 4\n  ///\n  ///    [operation setCompletionBlock:^{\n  ///        [self onOperationDone];\n  ///    }];\n  /// \\endcode\n  /// \\version 3.7\n  unsigned ObjCBlockIndentWidth;\n\n  /// Break parameters list into lines when there is nested block\n  /// parameters in a function call.\n  /// \\code\n  ///   false:\n  ///    - (void)_aMethod\n  ///    {\n  ///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n  ///        *u, NSNumber *v) {\n  ///            u = c;\n  ///        }]\n  ///    }\n  ///    true:\n  ///    - (void)_aMethod\n  ///    {\n  ///       [self.test1 t:self\n  ///                    w:self\n  ///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n  ///                u = c;\n  ///            }]\n  ///    }\n  /// \\endcode\n  /// \\version 11\n  bool ObjCBreakBeforeNestedBlockParam;\n\n  /// Add a space after ``@property`` in Objective-C, i.e. use\n  /// ``@property (readonly)`` instead of ``@property(readonly)``.\n  /// \\version 3.7\n  bool ObjCSpaceAfterProperty;\n\n  /// Add a space in front of an Objective-C protocol list, i.e. use\n  /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n  /// \\version 3.7\n  bool ObjCSpaceBeforeProtocolList;\n\n  /// Different ways to try to fit all constructor initializers on a line.\n  enum PackConstructorInitializersStyle : int8_t {\n    /// Always put each constructor initializer on its own line.\n    /// \\code\n    ///    Constructor()\n    ///        : a(),\n    ///          b()\n    /// \\endcode\n    PCIS_Never,\n    /// Bin-pack constructor initializers.\n    /// \\code\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_BinPack,\n    /// Put all constructor initializers on the current line if they fit.\n    /// Otherwise, put each one on its own line.\n    /// \\code\n    ///    Constructor() : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          ddddddddddddd()\n    /// \\endcode\n    PCIS_CurrentLine,\n    /// Same as ``PCIS_CurrentLine`` except that if all constructor initializers\n    /// do not fit on the current line, try to fit them on the next line.\n    /// \\code\n    ///    Constructor() : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_NextLine,\n    /// Put all constructor initializers on the next line if they fit.\n    /// Otherwise, put each one on its own line.\n    /// \\code\n    ///    Constructor()\n    ///        : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_NextLineOnly,\n  };\n\n  /// The pack constructor initializers style to use.\n  /// \\version 14\n  PackConstructorInitializersStyle PackConstructorInitializers;\n\n  /// The penalty for breaking around an assignment operator.\n  /// \\version 5\n  unsigned PenaltyBreakAssignment;\n\n  /// The penalty for breaking a function call after ``call(``.\n  /// \\version 3.7\n  unsigned PenaltyBreakBeforeFirstCallParameter;\n\n  /// The penalty for each line break introduced inside a comment.\n  /// \\version 3.7\n  unsigned PenaltyBreakComment;\n\n  /// The penalty for breaking before the first ``<<``.\n  /// \\version 3.7\n  unsigned PenaltyBreakFirstLessLess;\n\n  /// The penalty for breaking after ``(``.\n  /// \\version 14\n  unsigned PenaltyBreakOpenParenthesis;\n\n  /// The penalty for each line break introduced inside a string literal.\n  /// \\version 3.7\n  unsigned PenaltyBreakString;\n\n  /// The penalty for breaking after template declaration.\n  /// \\version 7\n  unsigned PenaltyBreakTemplateDeclaration;\n\n  /// The penalty for each character outside of the column limit.\n  /// \\version 3.7\n  unsigned PenaltyExcessCharacter;\n\n  /// Penalty for each character of whitespace indentation\n  /// (counted relative to leading non-whitespace column).\n  /// \\version 12\n  unsigned PenaltyIndentedWhitespace;\n\n  /// Penalty for putting the return type of a function onto its own line.\n  /// \\version 3.7\n  unsigned PenaltyReturnTypeOnItsOwnLine;\n\n  /// The ``&``, ``&&`` and ``*`` alignment style.\n  enum PointerAlignmentStyle : int8_t {\n    /// Align pointer to the left.\n    /// \\code\n    ///   int* a;\n    /// \\endcode\n    PAS_Left,\n    /// Align pointer to the right.\n    /// \\code\n    ///   int *a;\n    /// \\endcode\n    PAS_Right,\n    /// Align pointer in the middle.\n    /// \\code\n    ///   int * a;\n    /// \\endcode\n    PAS_Middle\n  };\n\n  /// Pointer and reference alignment style.\n  /// \\version 3.7\n  PointerAlignmentStyle PointerAlignment;\n\n  /// The number of columns to use for indentation of preprocessor statements.\n  /// When set to -1 (default) ``IndentWidth`` is used also for preprocessor\n  /// statements.\n  /// \\code\n  ///    PPIndentWidth: 1\n  ///\n  ///    #ifdef __linux__\n  ///    # define FOO\n  ///    #else\n  ///    # define BAR\n  ///    #endif\n  /// \\endcode\n  /// \\version 13\n  int PPIndentWidth;\n\n  /// Different specifiers and qualifiers alignment styles.\n  enum QualifierAlignmentStyle : int8_t {\n    /// Don't change specifiers/qualifiers to either Left or Right alignment\n    /// (default).\n    /// \\code\n    ///    int const a;\n    ///    const int *a;\n    /// \\endcode\n    QAS_Leave,\n    /// Change specifiers/qualifiers to be left-aligned.\n    /// \\code\n    ///    const int a;\n    ///    const int *a;\n    /// \\endcode\n    QAS_Left,\n    /// Change specifiers/qualifiers to be right-aligned.\n    /// \\code\n    ///    int const a;\n    ///    int const *a;\n    /// \\endcode\n    QAS_Right,\n    /// Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.\n    /// With:\n    /// \\code{.yaml}\n    ///   QualifierOrder: ['inline', 'static', 'type', 'const']\n    /// \\endcode\n    ///\n    /// \\code\n    ///\n    ///    int const a;\n    ///    int const *a;\n    /// \\endcode\n    QAS_Custom\n  };\n\n  /// Different ways to arrange specifiers and qualifiers (e.g. const/volatile).\n  /// \\warning\n  ///  Setting ``QualifierAlignment``  to something other than ``Leave``, COULD\n  ///  lead to incorrect code formatting due to incorrect decisions made due to\n  ///  clang-formats lack of complete semantic information.\n  ///  As such extra care should be taken to review code changes made by the use\n  ///  of this option.\n  /// \\endwarning\n  /// \\version 14\n  QualifierAlignmentStyle QualifierAlignment;\n\n  /// The order in which the qualifiers appear.\n  /// Order is an array that can contain any of the following:\n  ///\n  ///   * const\n  ///   * inline\n  ///   * static\n  ///   * friend\n  ///   * constexpr\n  ///   * volatile\n  ///   * restrict\n  ///   * type\n  ///\n  /// \\note\n  ///  it MUST contain 'type'.\n  /// \\endnote\n  ///\n  /// Items to the left of 'type' will be placed to the left of the type and\n  /// aligned in the order supplied. Items to the right of 'type' will be\n  /// placed to the right of the type and aligned in the order supplied.\n  ///\n  /// \\code{.yaml}\n  ///   QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]\n  /// \\endcode\n  /// \\version 14\n  std::vector<std::string> QualifierOrder;\n\n  /// See documentation of ``RawStringFormats``.\n  struct RawStringFormat {\n    /// The language of this raw string.\n    LanguageKind Language;\n    /// A list of raw string delimiters that match this language.\n    std::vector<std::string> Delimiters;\n    /// A list of enclosing function names that match this language.\n    std::vector<std::string> EnclosingFunctions;\n    /// The canonical delimiter for this language.\n    std::string CanonicalDelimiter;\n    /// The style name on which this raw string format is based on.\n    /// If not specified, the raw string format is based on the style that this\n    /// format is based on.\n    std::string BasedOnStyle;\n    bool operator==(const RawStringFormat &Other) const {\n      return Language == Other.Language && Delimiters == Other.Delimiters &&\n             EnclosingFunctions == Other.EnclosingFunctions &&\n             CanonicalDelimiter == Other.CanonicalDelimiter &&\n             BasedOnStyle == Other.BasedOnStyle;\n    }\n  };\n\n  /// Defines hints for detecting supported languages code blocks in raw\n  /// strings.\n  ///\n  /// A raw string with a matching delimiter or a matching enclosing function\n  /// name will be reformatted assuming the specified language based on the\n  /// style for that language defined in the .clang-format file. If no style has\n  /// been defined in the .clang-format file for the specific language, a\n  /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  /// found, the formatting is based on llvm style. A matching delimiter takes\n  /// precedence over a matching enclosing function name for determining the\n  /// language of the raw string contents.\n  ///\n  /// If a canonical delimiter is specified, occurrences of other delimiters for\n  /// the same language will be updated to the canonical if possible.\n  ///\n  /// There should be at most one specification per language and each delimiter\n  /// and enclosing function should not occur in multiple specifications.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   RawStringFormats:\n  ///     - Language: TextProto\n  ///         Delimiters:\n  ///           - 'pb'\n  ///           - 'proto'\n  ///         EnclosingFunctions:\n  ///           - 'PARSE_TEXT_PROTO'\n  ///         BasedOnStyle: google\n  ///     - Language: Cpp\n  ///         Delimiters:\n  ///           - 'cc'\n  ///           - 'cpp'\n  ///         BasedOnStyle: llvm\n  ///         CanonicalDelimiter: 'cc'\n  /// \\endcode\n  /// \\version 6\n  std::vector<RawStringFormat> RawStringFormats;\n\n  /// \\brief The ``&`` and ``&&`` alignment style.\n  enum ReferenceAlignmentStyle : int8_t {\n    /// Align reference like ``PointerAlignment``.\n    RAS_Pointer,\n    /// Align reference to the left.\n    /// \\code\n    ///   int& a;\n    /// \\endcode\n    RAS_Left,\n    /// Align reference to the right.\n    /// \\code\n    ///   int &a;\n    /// \\endcode\n    RAS_Right,\n    /// Align reference in the middle.\n    /// \\code\n    ///   int & a;\n    /// \\endcode\n    RAS_Middle\n  };\n\n  /// \\brief Reference alignment style (overrides ``PointerAlignment`` for\n  /// references).\n  /// \\version 13\n  ReferenceAlignmentStyle ReferenceAlignment;\n\n  // clang-format off\n  /// If ``true``, clang-format will attempt to re-flow comments. That is it\n  /// will touch a comment and *reflow* long comments into new lines, trying to\n  /// obey the ``ColumnLimit``.\n  /// \\code\n  ///    false:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n  ///\n  ///    true:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///    // information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///     * information */\n  /// \\endcode\n  /// \\version 3.8\n  bool ReflowComments;\n  // clang-format on\n\n  /// Remove optional braces of control statements (``if``, ``else``, ``for``,\n  /// and ``while``) in C++ according to the LLVM coding style.\n  /// \\warning\n  ///  This option will be renamed and expanded to support other styles.\n  /// \\endwarning\n  /// \\warning\n  ///  Setting this option to ``true`` could lead to incorrect code formatting\n  ///  due to clang-format's lack of complete semantic information. As such,\n  ///  extra care should be taken to review code changes made by this option.\n  /// \\endwarning\n  /// \\code\n  ///   false:                                     true:\n  ///\n  ///   if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n  ///     handleFunctionDecl(D);                     handleFunctionDecl(D);\n  ///   } else if (isa<VarDecl>(D)) {              else if (isa<VarDecl>(D))\n  ///     handleVarDecl(D);                          handleVarDecl(D);\n  ///   }\n  ///\n  ///   if (isa<VarDecl>(D)) {             vs.     if (isa<VarDecl>(D)) {\n  ///     for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n  ///       if (shouldProcessAttr(A)) {                if (shouldProcessAttr(A))\n  ///         handleAttr(A);                             handleAttr(A);\n  ///       }                                      }\n  ///     }\n  ///   }\n  ///\n  ///   if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n  ///     for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n  ///       handleAttr(A);                             handleAttr(A);\n  ///     }\n  ///   }\n  ///\n  ///   if (auto *D = (T)(D)) {            vs.     if (auto *D = (T)(D)) {\n  ///     if (shouldProcess(D)) {                    if (shouldProcess(D))\n  ///       handleVarDecl(D);                          handleVarDecl(D);\n  ///     } else {                                   else\n  ///       markAsIgnored(D);                          markAsIgnored(D);\n  ///     }                                        }\n  ///   }\n  ///\n  ///   if (a) {                           vs.     if (a)\n  ///     b();                                       b();\n  ///   } else {                                   else if (c)\n  ///     if (c) {                                   d();\n  ///       d();                                   else\n  ///     } else {                                   e();\n  ///       e();\n  ///     }\n  ///   }\n  /// \\endcode\n  /// \\version 14\n  bool RemoveBracesLLVM;\n\n  /// Types of redundant parentheses to remove.\n  enum RemoveParenthesesStyle : int8_t {\n    /// Do not remove parentheses.\n    /// \\code\n    ///   class __declspec((dllimport)) X {};\n    ///   co_return (((0)));\n    ///   return ((a + b) - ((c + d)));\n    /// \\endcode\n    RPS_Leave,\n    /// Replace multiple parentheses with single parentheses.\n    /// \\code\n    ///   class __declspec(dllimport) X {};\n    ///   co_return (0);\n    ///   return ((a + b) - (c + d));\n    /// \\endcode\n    RPS_MultipleParentheses,\n    /// Also remove parentheses enclosing the expression in a\n    /// ``return``/``co_return`` statement.\n    /// \\code\n    ///   class __declspec(dllimport) X {};\n    ///   co_return 0;\n    ///   return (a + b) - (c + d);\n    /// \\endcode\n    RPS_ReturnStatement,\n  };\n\n  /// Remove redundant parentheses.\n  /// \\warning\n  ///  Setting this option to any value other than ``Leave`` could lead to\n  ///  incorrect code formatting due to clang-format's lack of complete semantic\n  ///  information. As such, extra care should be taken to review code changes\n  ///  made by this option.\n  /// \\endwarning\n  /// \\version 17\n  RemoveParenthesesStyle RemoveParentheses;\n\n  /// Remove semicolons after the closing brace of a non-empty function.\n  /// \\warning\n  ///  Setting this option to ``true`` could lead to incorrect code formatting\n  ///  due to clang-format's lack of complete semantic information. As such,\n  ///  extra care should be taken to review code changes made by this option.\n  /// \\endwarning\n  /// \\code\n  ///   false:                                     true:\n  ///\n  ///   int max(int a, int b) {                    int max(int a, int b) {\n  ///     return a > b ? a : b;                      return a > b ? a : b;\n  ///   };                                         }\n  ///\n  /// \\endcode\n  /// \\version 16\n  bool RemoveSemicolon;\n\n  /// \\brief The possible positions for the requires clause. The\n  /// ``IndentRequires`` option is only used if the ``requires`` is put on the\n  /// start of a line.\n  enum RequiresClausePositionStyle : int8_t {\n    /// Always put the ``requires`` clause on its own line.\n    /// \\code\n    ///   template <typename T>\n    ///   requires C<T>\n    ///   struct Foo {...\n    ///\n    ///   template <typename T>\n    ///   requires C<T>\n    ///   void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t)\n    ///   requires C<T>\n    ///   {...\n    /// \\endcode\n    RCPS_OwnLine,\n    /// Try to put the clause together with the preceding part of a declaration.\n    /// For class templates: stick to the template declaration.\n    /// For function templates: stick to the template declaration.\n    /// For function declaration followed by a requires clause: stick to the\n    /// parameter list.\n    /// \\code\n    ///   template <typename T> requires C<T>\n    ///   struct Foo {...\n    ///\n    ///   template <typename T> requires C<T>\n    ///   void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t) requires C<T>\n    ///   {...\n    /// \\endcode\n    RCPS_WithPreceding,\n    /// Try to put the ``requires`` clause together with the class or function\n    /// declaration.\n    /// \\code\n    ///   template <typename T>\n    ///   requires C<T> struct Foo {...\n    ///\n    ///   template <typename T>\n    ///   requires C<T> void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t)\n    ///   requires C<T> {...\n    /// \\endcode\n    RCPS_WithFollowing,\n    /// Try to put everything in the same line if possible. Otherwise normal\n    /// line breaking rules take over.\n    /// \\code\n    ///   // Fitting:\n    ///   template <typename T> requires C<T> struct Foo {...\n    ///\n    ///   template <typename T> requires C<T> void bar(T t) {...\n    ///\n    ///   template <typename T> void bar(T t) requires C<T> {...\n    ///\n    ///   // Not fitting, one possible example:\n    ///   template <typename LongName>\n    ///   requires C<LongName>\n    ///   struct Foo {...\n    ///\n    ///   template <typename LongName>\n    ///   requires C<LongName>\n    ///   void bar(LongName ln) {\n    ///\n    ///   template <typename LongName>\n    ///   void bar(LongName ln)\n    ///       requires C<LongName> {\n    /// \\endcode\n    RCPS_SingleLine,\n  };\n\n  /// \\brief The position of the ``requires`` clause.\n  /// \\version 15\n  RequiresClausePositionStyle RequiresClausePosition;\n\n  /// Indentation logic for requires expression bodies.\n  enum RequiresExpressionIndentationKind : int8_t {\n    /// Align requires expression body relative to the indentation level of the\n    /// outer scope the requires expression resides in.\n    /// This is the default.\n    /// \\code\n    ///    template <typename T>\n    ///    concept C = requires(T t) {\n    ///      ...\n    ///    }\n    /// \\endcode\n    REI_OuterScope,\n    /// Align requires expression body relative to the ``requires`` keyword.\n    /// \\code\n    ///    template <typename T>\n    ///    concept C = requires(T t) {\n    ///                  ...\n    ///                }\n    /// \\endcode\n    REI_Keyword,\n  };\n\n  /// The indentation used for requires expression bodies.\n  /// \\version 16\n  RequiresExpressionIndentationKind RequiresExpressionIndentation;\n\n  /// \\brief The style if definition blocks should be separated.\n  enum SeparateDefinitionStyle : int8_t {\n    /// Leave definition blocks as they are.\n    SDS_Leave,\n    /// Insert an empty line between definition blocks.\n    SDS_Always,\n    /// Remove any empty line between definition blocks.\n    SDS_Never\n  };\n\n  /// Specifies the use of empty lines to separate definition blocks, including\n  /// classes, structs, enums, and functions.\n  /// \\code\n  ///    Never                  v.s.     Always\n  ///    #include <cstring>              #include <cstring>\n  ///    struct Foo {\n  ///      int a, b, c;                  struct Foo {\n  ///    };                                int a, b, c;\n  ///    namespace Ns {                  };\n  ///    class Bar {\n  ///    public:                         namespace Ns {\n  ///      struct Foobar {               class Bar {\n  ///        int a;                      public:\n  ///        int b;                        struct Foobar {\n  ///      };                                int a;\n  ///    private:                            int b;\n  ///      int t;                          };\n  ///      int method1() {\n  ///        // ...                      private:\n  ///      }                               int t;\n  ///      enum List {\n  ///        ITEM1,                        int method1() {\n  ///        ITEM2                           // ...\n  ///      };                              }\n  ///      template<typename T>\n  ///      int method2(T x) {              enum List {\n  ///        // ...                          ITEM1,\n  ///      }                                 ITEM2\n  ///      int i, j, k;                    };\n  ///      int method3(int par) {\n  ///        // ...                        template<typename T>\n  ///      }                               int method2(T x) {\n  ///    };                                  // ...\n  ///    class C {};                       }\n  ///    }\n  ///                                      int i, j, k;\n  ///\n  ///                                      int method3(int par) {\n  ///                                        // ...\n  ///                                      }\n  ///                                    };\n  ///\n  ///                                    class C {};\n  ///                                    }\n  /// \\endcode\n  /// \\version 14\n  SeparateDefinitionStyle SeparateDefinitionBlocks;\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  /// \\version 13\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : int8_t {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// \\version 3.8\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : int8_t {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  /// \\version 12\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// Using declaration sorting options.\n  enum SortUsingDeclarationsOptions : int8_t {\n    /// Using declarations are never sorted.\n    /// \\code\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Never,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. Sort\n    /// the lists of names lexicographically, and within those groups, names are\n    /// in case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Lexicographic,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. The\n    /// last element of each list is a non-namespace name; all others are\n    /// namespace names. Sort the lists of names lexicographically, where the\n    /// sort order of individual names is that all non-namespace names come\n    /// before all namespace names, and within those groups, names are in\n    /// case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::move;\n    ///    using std::string;\n    ///    using std::chrono::duration_cast;\n    /// \\endcode\n    SUD_LexicographicNumeric,\n  };\n\n  /// Controls if and how clang-format will sort using declarations.\n  /// \\version 5\n  SortUsingDeclarationsOptions SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  /// \\version 3.5\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  /// \\version 9\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  /// \\version 4\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : int8_t {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  /// \\version 12\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  /// \\version 3.7\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  /// \\version 12\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeInheritanceColon;\n\n  /// If ``true``, a space will be added before a JSON colon. For other\n  /// languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead.\n  /// \\code\n  ///    true:                                  false:\n  ///    {                                      {\n  ///      \"key\" : \"value\"              vs.       \"key\": \"value\"\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 17\n  bool SpaceBeforeJsonColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensStyle : int8_t {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach and If macros. This is useful in projects where ForEach/If\n    /// macros are treated as function calls instead of control statements.\n    /// ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for\n    /// backward compatibility.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptControlMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always,\n    /// Configure each individual space before parentheses in\n    /// ``SpaceBeforeParensOptions``.\n    SBPO_Custom,\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  /// \\version 3.5\n  SpaceBeforeParensStyle SpaceBeforeParens;\n\n  /// Precise control over the spacing before parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  struct SpaceBeforeParensCustom {\n    /// If ``true``, put space betwee control statement keywords\n    /// (for/if/while...) and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    if (...) {}                     vs.    if(...) {}\n    /// \\endcode\n    bool AfterControlStatements;\n    /// If ``true``, put space between foreach macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    FOREACH (...)                   vs.    FOREACH(...)\n    ///      <loop-body>                            <loop-body>\n    /// \\endcode\n    bool AfterForeachMacros;\n    /// If ``true``, put a space between function declaration name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f ();                      vs.    void f();\n    /// \\endcode\n    bool AfterFunctionDeclarationName;\n    /// If ``true``, put a space between function definition name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f () {}                    vs.    void f() {}\n    /// \\endcode\n    bool AfterFunctionDefinitionName;\n    /// If ``true``, put space between if macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    IF (...)                        vs.    IF(...)\n    ///      <conditional-body>                     <conditional-body>\n    /// \\endcode\n    bool AfterIfMacros;\n    /// If ``true``, put a space between operator overloading and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void operator++ (int a);        vs.    void operator++(int a);\n    ///    object.operator++ (10);                object.operator++(10);\n    /// \\endcode\n    bool AfterOverloadedOperator;\n    /// If ``true``, put space between requires keyword in a requires clause and\n    /// opening parentheses, if there is one.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    requires (A<T> && B<T>)                requires(A<T> && B<T>)\n    ///    ...                                    ...\n    /// \\endcode\n    bool AfterRequiresInClause;\n    /// If ``true``, put space between requires keyword in a requires expression\n    /// and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    concept C = requires (T t) {           concept C = requires(T t) {\n    ///                  ...                                    ...\n    ///                }                                      }\n    /// \\endcode\n    bool AfterRequiresInExpression;\n    /// If ``true``, put a space before opening parentheses only if the\n    /// parentheses are not empty.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f (int a);                 vs.    void f();\n    ///    f (a);                                 f();\n    /// \\endcode\n    bool BeforeNonEmptyParentheses;\n\n    SpaceBeforeParensCustom()\n        : AfterControlStatements(false), AfterForeachMacros(false),\n          AfterFunctionDeclarationName(false),\n          AfterFunctionDefinitionName(false), AfterIfMacros(false),\n          AfterOverloadedOperator(false), AfterRequiresInClause(false),\n          AfterRequiresInExpression(false), BeforeNonEmptyParentheses(false) {}\n\n    bool operator==(const SpaceBeforeParensCustom &Other) const {\n      return AfterControlStatements == Other.AfterControlStatements &&\n             AfterForeachMacros == Other.AfterForeachMacros &&\n             AfterFunctionDeclarationName ==\n                 Other.AfterFunctionDeclarationName &&\n             AfterFunctionDefinitionName == Other.AfterFunctionDefinitionName &&\n             AfterIfMacros == Other.AfterIfMacros &&\n             AfterOverloadedOperator == Other.AfterOverloadedOperator &&\n             AfterRequiresInClause == Other.AfterRequiresInClause &&\n             AfterRequiresInExpression == Other.AfterRequiresInExpression &&\n             BeforeNonEmptyParentheses == Other.BeforeNonEmptyParentheses;\n    }\n  };\n\n  /// Control of individual space before parentheses.\n  ///\n  /// If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify\n  /// how each individual space before parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  /// \\version 14\n  SpaceBeforeParensCustom SpaceBeforeParensOptions;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  /// \\version 10\n  bool SpaceBeforeSquareBrackets;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  /// \\version 10\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// This option is **deprecated**. See ``InEmptyParentheses`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as those\n  /// commonly have different usage patterns and a number of special cases.  In\n  /// the case of Verilog, it doesn't affect a comment right after the opening\n  /// parenthesis in the port or parameter list in a module header, because it\n  /// is probably for the port on the following line instead of the parenthesis\n  /// it follows.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned SpacesBeforeTrailingComments;\n\n  /// Styles for adding spacing after ``<`` and before ``>``\n  ///  in template argument lists.\n  enum SpacesInAnglesStyle : int8_t {\n    /// Remove spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast<int>(arg);\n    ///    std::function<void(int)> fct;\n    /// \\endcode\n    SIAS_Never,\n    /// Add spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast< int >(arg);\n    ///    std::function< void(int) > fct;\n    /// \\endcode\n    SIAS_Always,\n    /// Keep a single space after ``<`` and before ``>`` if any spaces were\n    /// present. Option ``Standard: Cpp03`` takes precedence.\n    SIAS_Leave\n  };\n  /// The SpacesInAnglesStyle to use for template argument lists.\n  /// \\version 3.4\n  SpacesInAnglesStyle SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// This option is **deprecated**. See ``InConditionalStatements`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 10\n  // bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.  ObjC and\n  /// Javascript array and dict literals). For JSON, use\n  /// ``SpaceBeforeJsonColon`` instead.\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// This option is **deprecated**. See ``InCStyleCasts`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment.\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code\n  ///   Minimum = 1\n  ///   Maximum = -1\n  ///   // One space is forced\n  ///\n  ///   //  but more spaces are possible\n  ///\n  ///   Minimum = 0\n  ///   Maximum = 0\n  ///   //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  ///   before:                                   after:\n  ///   Minimum: 1\n  ///   //if (b) {                                // if (b) {\n  ///   //  return true;                          //   return true;\n  ///   //}                                       // }\n  ///\n  ///   Maximum: 0\n  ///   /// List:                                 ///List:\n  ///   ///  - Foo                                /// - Foo\n  ///   ///    - Bar                              ///   - Bar\n  /// \\endcode\n  ///\n  /// This option has only effect if ``ReflowComments`` is set to ``true``.\n  /// \\version 13\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// Different ways to put a space before opening and closing parentheses.\n  enum SpacesInParensStyle : int8_t {\n    /// Never put a space in parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SIPO_Never,\n    /// Configure each individual space in parentheses in\n    /// `SpacesInParensOptions`.\n    SIPO_Custom,\n  };\n\n  /// If ``true'', spaces will be inserted after ``(`` and before ``)``.\n  /// This option is **deprecated**. The previous behavior is preserved by using\n  /// ``SpacesInParens`` with ``Custom`` and by setting all\n  /// ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and\n  /// ``InEmptyParentheses``.\n  /// \\version 3.7\n  // bool SpacesInParentheses;\n\n  /// Defines in which cases spaces will be inserted after ``(`` and before\n  /// ``)``.\n  /// \\version 17\n  SpacesInParensStyle SpacesInParens;\n\n  /// Precise control over the spacing in parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     Other: true\n  /// \\endcode\n  struct SpacesInParensCustom {\n    /// Put a space in parentheses only inside conditional statements\n    /// (``for/if/while/switch...``).\n    /// \\code\n    ///    true:                                  false:\n    ///    if ( a )  { ... }              vs.     if (a) { ... }\n    ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n    /// \\endcode\n    bool InConditionalStatements;\n    /// Put a space in C style casts.\n    /// \\code\n    ///    true:                                  false:\n    ///    x = ( int32 )y                 vs.     x = (int32)y\n    /// \\endcode\n    bool InCStyleCasts;\n    /// Put a space in parentheses only if the parentheses are empty i.e. '()'\n    /// \\code\n    ///    true:                                false:\n    ///    void f( ) {                    vs.   void f() {\n    ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n    ///      if (true) {                          if (true) {\n    ///        f( );                                f();\n    ///      }                                    }\n    ///    }                                    }\n    /// \\endcode\n    bool InEmptyParentheses;\n    /// Put a space in parentheses not covered by preceding options.\n    /// \\code\n    ///    true:                                  false:\n    ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n    /// \\endcode\n    bool Other;\n\n    SpacesInParensCustom()\n        : InConditionalStatements(false), InCStyleCasts(false),\n          InEmptyParentheses(false), Other(false) {}\n\n    SpacesInParensCustom(bool InConditionalStatements, bool InCStyleCasts,\n        bool InEmptyParentheses, bool Other)\n        : InConditionalStatements(InConditionalStatements),\n          InCStyleCasts(InCStyleCasts),\n          InEmptyParentheses(InEmptyParentheses),\n          Other(Other) {}\n\n    bool operator==(const SpacesInParensCustom &R) const {\n      return InConditionalStatements == R.InConditionalStatements &&\n             InCStyleCasts == R.InCStyleCasts &&\n             InEmptyParentheses == R.InEmptyParentheses &&\n             Other == R.Other;\n    }\n    bool operator!=(const SpacesInParensCustom &R) const {\n      return !(*this == R);\n    }\n  };\n\n  /// Control of individual spaces in parentheses.\n  ///\n  /// If ``SpacesInParens`` is set to ``Custom``, use this to specify\n  /// how each individual space in parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     InEmptyParentheses: true\n  /// \\endcode\n  /// \\version 17\n  SpacesInParensCustom SpacesInParensOptions;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInSquareBrackets;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : int8_t {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  /// \\version 3.7\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  /// \\version 12\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  /// \\version 8\n  std::vector<std::string> StatementMacros;\n\n  /// The number of columns used for tab stops.\n  /// \\version 3.7\n  unsigned TabWidth;\n\n  /// A vector of non-keyword identifiers that should be interpreted as type\n  /// names.\n  ///\n  /// A ``*``, ``&``, or ``&&`` between a type name and another non-keyword\n  /// identifier is annotated as a pointer or reference token instead of a\n  /// binary operator.\n  ///\n  /// \\version 17\n  std::vector<std::string> TypeNames;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  /// \\version 9\n  std::vector<std::string> TypenameMacros;\n\n  /// This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``.\n  /// \\version 10\n  // bool UseCRLF;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : int8_t {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// The way to use tab characters in the resulting file.\n  /// \\version 3.7\n  UseTabStyle UseTab;\n\n  /// For Verilog, put each port on its own line in module instantiations.\n  /// \\code\n  ///    true:\n  ///    ffnand ff1(.q(),\n  ///               .qbar(out1),\n  ///               .clear(in1),\n  ///               .preset(in2));\n  ///\n  ///    false:\n  ///    ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));\n  /// \\endcode\n  /// \\version 17\n  bool VerilogBreakBetweenInstancePorts;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  /// \\version 11\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignArrayOfStructures == R.AlignArrayOfStructures &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignConsecutiveShortCaseStatements ==\n               R.AlignConsecutiveShortCaseStatements &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           BracedInitializerIndentWidth == R.BracedInitializerIndentWidth &&\n           BreakAfterAttributes == R.BreakAfterAttributes &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakArrays == R.BreakArrays &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeInlineASMColon == R.BreakBeforeInlineASMColon &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           CompactNamespaces == R.CompactNamespaces &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineAfterAccessModifier == R.EmptyLineAfterAccessModifier &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentRequiresClause == R.IndentRequiresClause &&\n           IndentWidth == R.IndentWidth &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           InsertBraces == R.InsertBraces &&\n           InsertNewlineAtEOF == R.InsertNewlineAtEOF &&\n           IntegerLiteralSeparator == R.IntegerLiteralSeparator &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtEOF == R.KeepEmptyLinesAtEOF &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           Language == R.Language &&\n           LambdaBodyIndentation == R.LambdaBodyIndentation &&\n           LineEnding == R.LineEnding && MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd && Macros == R.Macros &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PackConstructorInitializers == R.PackConstructorInitializers &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakOpenParenthesis == R.PenaltyBreakOpenParenthesis &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PointerAlignment == R.PointerAlignment &&\n           QualifierAlignment == R.QualifierAlignment &&\n           QualifierOrder == R.QualifierOrder &&\n           RawStringFormats == R.RawStringFormats &&\n           ReferenceAlignment == R.ReferenceAlignment &&\n           RemoveBracesLLVM == R.RemoveBracesLLVM &&\n           RemoveParentheses == R.RemoveParentheses &&\n           RemoveSemicolon == R.RemoveSemicolon &&\n           RequiresClausePosition == R.RequiresClausePosition &&\n           RequiresExpressionIndentation == R.RequiresExpressionIndentation &&\n           SeparateDefinitionBlocks == R.SeparateDefinitionBlocks &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeJsonColon == R.SpaceBeforeJsonColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceBeforeParensOptions == R.SpaceBeforeParensOptions &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParens == R.SpacesInParens &&\n           SpacesInParensOptions == R.SpacesInParensOptions &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           TypeNames == R.TypeNames && TypenameMacros == R.TypenameMacros &&\n           UseTab == R.UseTab &&\n           VerilogBreakBetweenInstancePorts ==\n               R.VerilogBreakBetweenInstancePorts &&\n           WhitespaceSensitiveMacros == R.WhitespaceSensitiveMacros;\n  }\n\n  std::optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    std::optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n}",
  "id": "BLOCK-CPP-18134",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 2365,
  "validation_status": "validated"
}