{
  "code": "{\n  FormatContext& context;\n  OutputIt out;\n  int precision;\n  bool localized = false;\n  // rep is unsigned to avoid overflow.\n  using rep =\n      conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),\n                    unsigned, typename make_unsigned_or_unchanged<Rep>::type>;\n  rep val;\n  using seconds = std::chrono::duration<rep>;\n  seconds s;\n  using milliseconds = std::chrono::duration<rep, std::milli>;\n  bool negative;\n\n  using char_type = typename FormatContext::char_type;\n  using tm_writer_type = tm_writer<OutputIt, char_type>;\n\n  chrono_formatter(FormatContext& ctx, OutputIt o,\n                   std::chrono::duration<Rep, Period> d)\n      : context(ctx),\n        out(o),\n        val(static_cast<rep>(d.count())),\n        negative(false) {\n    if (d.count() < 0) {\n      val = 0 - val;\n      negative = true;\n    }\n\n    // this may overflow and/or the result may not fit in the\n    // target type.\n#if FMT_SAFE_DURATION_CAST\n    // might need checked conversion (rep!=Rep)\n    auto tmpval = std::chrono::duration<rep, Period>(val);\n    s = fmt_safe_duration_cast<seconds>(tmpval);\n#else\n    s = std::chrono::duration_cast<seconds>(\n        std::chrono::duration<rep, Period>(val));\n#endif\n  }\n\n  // returns true if nan or inf, writes to out.\n  bool handle_nan_inf() {\n    if (isfinite(val)) {\n      return false;\n    }\n    if (isnan(val)) {\n      write_nan();\n      return true;\n    }\n    // must be +-inf\n    if (val > 0) {\n      write_pinf();\n    } else {\n      write_ninf();\n    }\n    return true;\n  }\n\n  Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }\n\n  Rep hour12() const {\n    Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));\n    return hour <= 0 ? 12 : hour;\n  }\n\n  Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }\n  Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }\n\n  std::tm time() const {\n    auto time = std::tm();\n    time.tm_hour = to_nonnegative_int(hour(), 24);\n    time.tm_min = to_nonnegative_int(minute(), 60);\n    time.tm_sec = to_nonnegative_int(second(), 60);\n    return time;\n  }\n\n  void write_sign() {\n    if (negative) {\n      *out++ = '-';\n      negative = false;\n    }\n  }\n\n  void write(Rep value, int width) {\n    write_sign();\n    if (isnan(value)) return write_nan();\n    uint32_or_64_or_128_t<int> n =\n        to_unsigned(to_nonnegative_int(value, max_value<int>()));\n    int num_digits = detail::count_digits(n);\n    if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');\n    out = format_decimal<char_type>(out, n, num_digits).end;\n  }\n\n  template <typename Duration> void write_fractional_seconds(Duration d) {\n    FMT_ASSERT(!std::is_floating_point<typename Duration::rep>::value, \"\");\n    constexpr auto num_fractional_digits =\n        count_fractional_digits<Duration::period::num,\n                                Duration::period::den>::value;\n\n    using subsecond_precision = std::chrono::duration<\n        typename std::common_type<typename Duration::rep,\n                                  std::chrono::seconds::rep>::type,\n        std::ratio<1, detail::pow10(num_fractional_digits)>>;\n    if (std::ratio_less<typename subsecond_precision::period,\n                        std::chrono::seconds::period>::value) {\n      *out++ = '.';\n      auto fractional =\n          detail::abs(d) - std::chrono::duration_cast<std::chrono::seconds>(d);\n      auto subseconds =\n          std::chrono::treat_as_floating_point<\n              typename subsecond_precision::rep>::value\n              ? fractional.count()\n              : std::chrono::duration_cast<subsecond_precision>(fractional)\n                    .count();\n      uint32_or_64_or_128_t<long long> n =\n          to_unsigned(to_nonnegative_int(subseconds, max_value<long long>()));\n      int num_digits = detail::count_digits(n);\n      if (num_fractional_digits > num_digits)\n        out = std::fill_n(out, num_fractional_digits - num_digits, '0');\n      out = format_decimal<char_type>(out, n, num_digits).end;\n    }\n  }\n\n  void write_nan() { std::copy_n(\"nan\", 3, out); }\n  void write_pinf() { std::copy_n(\"inf\", 3, out); }\n  void write_ninf() { std::copy_n(\"-inf\", 4, out); }\n\n  template <typename Callback, typename... Args>\n  void format_tm(const tm& time, Callback cb, Args... args) {\n    if (isnan(val)) return write_nan();\n    get_locale loc(localized, context.locale());\n    auto w = tm_writer_type(loc, out, time);\n    (w.*cb)(args...);\n    out = w.out();\n  }\n\n  void on_text(const char_type* begin, const char_type* end) {\n    std::copy(begin, end, out);\n  }\n\n  // These are not implemented because durations don't have date information.\n  void on_abbr_weekday() {}\n  void on_full_weekday() {}\n  void on_dec0_weekday(numeric_system) {}\n  void on_dec1_weekday(numeric_system) {}\n  void on_abbr_month() {}\n  void on_full_month() {}\n  void on_datetime(numeric_system) {}\n  void on_loc_date(numeric_system) {}\n  void on_loc_time(numeric_system) {}\n  void on_us_date() {}\n  void on_iso_date() {}\n  void on_utc_offset() {}\n  void on_tz_name() {}\n  void on_year(numeric_system) {}\n  void on_short_year(numeric_system) {}\n  void on_offset_year() {}\n  void on_century(numeric_system) {}\n  void on_iso_week_based_year() {}\n  void on_iso_week_based_short_year() {}\n  void on_dec_month(numeric_system) {}\n  void on_dec0_week_of_year(numeric_system) {}\n  void on_dec1_week_of_year(numeric_system) {}\n  void on_iso_week_of_year(numeric_system) {}\n  void on_day_of_year() {}\n  void on_day_of_month(numeric_system) {}\n  void on_day_of_month_space(numeric_system) {}\n\n  void on_24_hour(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) return write(hour(), 2);\n    auto time = tm();\n    time.tm_hour = to_nonnegative_int(hour(), 24);\n    format_tm(time, &tm_writer_type::on_24_hour, ns);\n  }\n\n  void on_12_hour(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) return write(hour12(), 2);\n    auto time = tm();\n    time.tm_hour = to_nonnegative_int(hour12(), 12);\n    format_tm(time, &tm_writer_type::on_12_hour, ns);\n  }\n\n  void on_minute(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) return write(minute(), 2);\n    auto time = tm();\n    time.tm_min = to_nonnegative_int(minute(), 60);\n    format_tm(time, &tm_writer_type::on_minute, ns);\n  }\n\n  void on_second(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) {\n      if (std::is_floating_point<rep>::value) {\n        constexpr auto num_fractional_digits =\n            count_fractional_digits<Period::num, Period::den>::value;\n        auto buf = memory_buffer();\n        format_to(std::back_inserter(buf), runtime(\"{:.{}f}\"),\n                  std::fmod(val * static_cast<rep>(Period::num) /\n                                static_cast<rep>(Period::den),\n                            static_cast<rep>(60)),\n                  num_fractional_digits);\n        if (negative) *out++ = '-';\n        if (buf.size() < 2 || buf[1] == '.') *out++ = '0';\n        out = std::copy(buf.begin(), buf.end(), out);\n      } else {\n        write(second(), 2);\n        write_fractional_seconds(std::chrono::duration<rep, Period>(val));\n      }\n      return;\n    }\n    auto time = tm();\n    time.tm_sec = to_nonnegative_int(second(), 60);\n    format_tm(time, &tm_writer_type::on_second, ns);\n  }\n\n  void on_12_hour_time() {\n    if (handle_nan_inf()) return;\n    format_tm(time(), &tm_writer_type::on_12_hour_time);\n  }\n\n  void on_24_hour_time() {\n    if (handle_nan_inf()) {\n      *out++ = ':';\n      handle_nan_inf();\n      return;\n    }\n\n    write(hour(), 2);\n    *out++ = ':';\n    write(minute(), 2);\n  }\n\n  void on_iso_time() {\n    on_24_hour_time();\n    *out++ = ':';\n    if (handle_nan_inf()) return;\n    on_second(numeric_system::standard);\n  }\n\n  void on_am_pm() {\n    if (handle_nan_inf()) return;\n    format_tm(time(), &tm_writer_type::on_am_pm);\n  }\n\n  void on_duration_value() {\n    if (handle_nan_inf()) return;\n    write_sign();\n    out = format_duration_value<char_type>(out, val, precision);\n  }\n\n  void on_duration_unit() {\n    out = format_duration_unit<char_type, Period>(out);\n  }\n}",
  "id": "BLOCK-CPP-00812",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/chrono.h",
  "source_line": 1571,
  "validation_status": "validated"
}