{
  "code": "#include <cstddef>\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05956_execute() {\n    {\n\n// RANDen = RANDom generator or beetroots in Swiss High German.\n// 'Strong' (well-distributed, unpredictable, backtracking-resistant) random\n// generator, faster in some benchmarks than std::mt19937_64 and pcg64_c32.\n//\n// High-level summary:\n// 1) Reverie (see \"A Robust and Sponge-Like PRNG with Improved Efficiency\") is\n//    a sponge-like random generator that requires a cryptographic permutation.\n//    It improves upon \"Provably Robust Sponge-Based PRNGs and KDFs\" by\n//    achieving backtracking resistance with only one Permute() per buffer.\n//\n// 2) \"Simpira v2: A Family of Efficient Permutations Using the AES Round\n//    Function\" constructs up to 1024-bit permutations using an improved\n//    Generalized Feistel network with 2-round AES-128 functions. This Feistel\n//    block shuffle achieves diffusion faster and is less vulnerable to\n//    sliced-biclique attacks than the Type-2 cyclic shuffle.\n//\n// 3) \"Improving the Generalized Feistel\" and \"New criterion for diffusion\n//    property\" extends the same kind of improved Feistel block shuffle to 16\n//    branches, which enables a 2048-bit permutation.\n//\n// Combine these three ideas and also change Simpira's subround keys from\n// structured/low-entropy counters to digits of Pi (or other random source).\n\n// RandenTraits contains the basic algorithm traits, such as the size of the\n// state, seed, sponge, etc.\nstruct RandenTraits {\n  // Size of the entire sponge / state for the randen PRNG.\n  static constexpr size_t kStateBytes = 256;  // 2048-bit\n\n  // Size of the 'inner' (inaccessible) part of the sponge. Larger values would\n  // require more frequent calls to RandenGenerate.\n  static constexpr size_t kCapacityBytes = 16;  // 128-bit\n\n  // Size of the default seed consumed by the sponge.\n  static constexpr size_t kSeedBytes = kStateBytes - kCapacityBytes;\n\n  // Assuming 128-bit blocks, the number of blocks in the state.\n  // Largest size for which security proofs are known.\n  static constexpr size_t kFeistelBlocks = 16;\n\n  // Ensures SPRP security and two full subblock diffusions.\n  // Must be > 4 * log2(kFeistelBlocks).\n  static constexpr size_t kFeistelRounds = 16 + 1;\n\n  // Size of the key. A 128-bit key block is used for every-other\n  // feistel block (Type-2 generalized Feistel network) in each round.\n  static constexpr size_t kKeyBytes = 16 * kFeistelRounds * kFeistelBlocks / 2;\n};\n\n// Randen key arrays. In randen_round_keys.cc\nextern const unsigned char kRandenRoundKeys[RandenTraits::kKeyBytes];\nextern const unsigned char kRandenRoundKeysBE[RandenTraits::kKeyBytes];\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05956",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/randen_traits.h",
  "source_line": 29,
  "validation_status": "validated"
}