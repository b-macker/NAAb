{
  "code": "#include \"absl/debugging/failure_signal_handler.h\"\n#include \"absl/base/config.h\"\n#include <windows.h>\n#include <sched.h>\n#include <unistd.h>\n#include <TargetConditionals.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <algorithm>\n#include <atomic>\n#include <cerrno>\n#include <csignal>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/sysinfo.h\"\n#include \"absl/debugging/internal/examine_stack.h\"\n#include \"absl/debugging/stacktrace.h\"\n\nusing namespace absl;\nusing namespace debugging_internal;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01629_execute() {\n    {\n#endif\n\n  const GetTidType this_tid = absl::base_internal::GetTID();\n  GetTidType previous_failed_tid = 0;\n  if (!failed_tid.compare_exchange_strong(previous_failed_tid, this_tid,\n                                          std::memory_order_acq_rel,\n                                          std::memory_order_relaxed)) {\n    ABSL_RAW_LOG(\n        ERROR,\n        \"Signal %d raised at PC=%p while already in AbslFailureSignalHandler()\",\n        signo, absl::debugging_internal::GetProgramCounter(ucontext));\n    if (this_tid != previous_failed_tid) {\n      // Another thread is already in AbslFailureSignalHandler(), so wait\n      // a bit for it to finish. If the other thread doesn't kill us,\n      // we do so after sleeping.\n      PortableSleepForSeconds(3);\n      RaiseToDefaultHandler(signo);\n      // The recursively raised signal may be blocked until we return.\n      return;\n    }\n  }\n\n  // Increase the chance that the CPU we report was the same CPU on which the\n  // signal was received by doing this as early as possible, i.e. after\n  // verifying that this is not a recursive signal handler invocation.\n  int my_cpu = -1;\n#ifdef ABSL_HAVE_SCHED_GETCPU\n  my_cpu = sched_getcpu();\n#endif\n\n#ifdef ABSL_HAVE_ALARM\n  // Set an alarm to abort the program in case this code hangs or deadlocks.\n  if (fsh_options.alarm_on_failure_secs > 0) {\n    alarm(0);  // Cancel any existing alarms.\n    signal(SIGALRM, ImmediateAbortSignalHandler);\n    alarm(static_cast<unsigned int>(fsh_options.alarm_on_failure_secs));\n  }\n#endif\n\n  // First write to stderr.\n  WriteFailureInfo(\n      signo, ucontext, my_cpu, +[](const char* data) {\n        absl::raw_log_internal::AsyncSignalSafeWriteError(data, strlen(data));\n      });\n\n  // Riskier code (because it is less likely to be async-signal-safe)\n  // goes after this point.\n  if (fsh_options.writerfn != nullptr) {\n    WriteFailureInfo(signo, ucontext, my_cpu, fsh_options.writerfn);\n    fsh_options.writerfn(nullptr);\n  }\n\n  if (fsh_options.call_previous_handler) {\n    RaiseToPreviousHandler(signo);\n  } else {\n    RaiseToDefaultHandler(signo);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01629",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/failure_signal_handler.cc",
  "source_line": 337,
  "validation_status": "validated"
}