{
  "code": "{\n\n// MockHelpers works in conjunction with MockOverloadSet, MockingBitGen, and\n// BitGenRef to enable the mocking capability for absl distribution functions.\n//\n// MockingBitGen registers mocks based on the typeid of a mock signature, KeyT,\n// which is used to generate a unique id.\n//\n// KeyT is a signature of the form:\n//   result_type(discriminator_type, std::tuple<args...>)\n// The mocked function signature will be composed from KeyT as:\n//   result_type(args...)\n//\nclass MockHelpers {\n  using IdType = ::absl::base_internal::FastTypeIdType;\n\n  // Given a key signature type used to index the mock, extract the components.\n  // KeyT is expected to have the form:\n  //   result_type(discriminator_type, arg_tuple_type)\n  template <typename KeyT>\n  struct KeySignature;\n\n  template <typename ResultT, typename DiscriminatorT, typename ArgTupleT>\n  struct KeySignature<ResultT(DiscriminatorT, ArgTupleT)> {\n    using result_type = ResultT;\n    using discriminator_type = DiscriminatorT;\n    using arg_tuple_type = ArgTupleT;\n  };\n\n  // Detector for InvokeMock.\n  template <class T>\n  using invoke_mock_t = decltype(std::declval<T*>()->InvokeMock(\n      std::declval<IdType>(), std::declval<void*>(), std::declval<void*>()));\n\n  // Empty implementation of InvokeMock.\n  template <typename KeyT, typename ReturnT, typename ArgTupleT, typename URBG,\n            typename... Args>\n  static absl::optional<ReturnT> InvokeMockImpl(char, URBG*, Args&&...) {\n    return absl::nullopt;\n  }\n\n  // Non-empty implementation of InvokeMock.\n  template <typename KeyT, typename ReturnT, typename ArgTupleT, typename URBG,\n            typename = invoke_mock_t<URBG>, typename... Args>\n  static absl::optional<ReturnT> InvokeMockImpl(int, URBG* urbg,\n                                                Args&&... args) {\n    ArgTupleT arg_tuple(std::forward<Args>(args)...);\n    ReturnT result;\n    if (urbg->InvokeMock(::absl::base_internal::FastTypeId<KeyT>(), &arg_tuple,\n                         &result)) {\n      return result;\n    }\n    return absl::nullopt;\n  }\n\n public:\n  // InvokeMock is private; this provides access for some specialized use cases.\n  template <typename URBG>\n  static inline bool PrivateInvokeMock(URBG* urbg, IdType type,\n                                       void* args_tuple, void* result) {\n    return urbg->InvokeMock(type, args_tuple, result);\n  }\n\n  // Invoke a mock for the KeyT (may or may not be a signature).\n  //\n  // KeyT is used to generate a typeid-based lookup key for the mock.\n  // KeyT is a signature of the form:\n  //   result_type(discriminator_type, std::tuple<args...>)\n  // The mocked function signature will be composed from KeyT as:\n  //   result_type(args...)\n  //\n  // An instance of arg_tuple_type must be constructable from Args..., since\n  // the underlying mechanism requires a pointer to an argument tuple.\n  template <typename KeyT, typename URBG, typename... Args>\n  static auto MaybeInvokeMock(URBG* urbg, Args&&... args)\n      -> absl::optional<typename KeySignature<KeyT>::result_type> {\n    // Use function overloading to dispatch to the implementation since\n    // more modern patterns (e.g. require + constexpr) are not supported in all\n    // compiler configurations.\n    return InvokeMockImpl<KeyT, typename KeySignature<KeyT>::result_type,\n                          typename KeySignature<KeyT>::arg_tuple_type, URBG>(\n        0, urbg, std::forward<Args>(args)...);\n  }\n\n  // Acquire a mock for the KeyT (may or may not be a signature).\n  //\n  // KeyT is used to generate a typeid-based lookup for the mock.\n  // KeyT is a signature of the form:\n  //   result_type(discriminator_type, std::tuple<args...>)\n  // The mocked function signature will be composed from KeyT as:\n  //   result_type(args...)\n  template <typename KeyT, typename MockURBG>\n  static auto MockFor(MockURBG& m)\n      -> decltype(m.template RegisterMock<\n                  typename KeySignature<KeyT>::result_type,\n                  typename KeySignature<KeyT>::arg_tuple_type>(\n          m, std::declval<IdType>())) {\n    return m.template RegisterMock<typename KeySignature<KeyT>::result_type,\n                                   typename KeySignature<KeyT>::arg_tuple_type>(\n        m, ::absl::base_internal::FastTypeId<KeyT>());\n  }\n};\n\n}",
  "id": "BLOCK-CPP-05891",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/mock_helpers.h",
  "source_line": 28,
  "validation_status": "validated"
}