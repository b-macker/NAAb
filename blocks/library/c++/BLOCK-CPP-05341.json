{
  "code": "{\n public:\n  explicit HashSetResizeHelper(CommonFields& c)\n      : old_ctrl_(c.control()),\n        old_capacity_(c.capacity()),\n        had_infoz_(c.has_infoz()) {}\n\n  // Optimized for small groups version of `find_first_non_full` applicable\n  // only right after calling `raw_hash_set::resize`.\n  // It has implicit assumption that `resize` will call\n  // `GrowSizeIntoSingleGroup*` in case `IsGrowingIntoSingleGroupApplicable`.\n  // Falls back to `find_first_non_full` in case of big groups, so it is\n  // safe to use after `rehash_and_grow_if_necessary`.\n  static FindInfo FindFirstNonFullAfterResize(const CommonFields& c,\n                                              size_t old_capacity,\n                                              size_t hash) {\n    if (!IsGrowingIntoSingleGroupApplicable(old_capacity, c.capacity())) {\n      return find_first_non_full(c, hash);\n    }\n    // Find a location for the new element non-deterministically.\n    // Note that any position is correct.\n    // It will located at `half_old_capacity` or one of the other\n    // empty slots with approximately 50% probability each.\n    size_t offset = probe(c, hash).offset();\n\n    // Note that we intentionally use unsigned int underflow.\n    if (offset - (old_capacity + 1) >= old_capacity) {\n      // Offset fall on kSentinel or into the mostly occupied first half.\n      offset = old_capacity / 2;\n    }\n    assert(IsEmpty(c.control()[offset]));\n    return FindInfo{offset, 0};\n  }\n\n  ctrl_t* old_ctrl() const { return old_ctrl_; }\n  size_t old_capacity() const { return old_capacity_; }\n\n  // Allocates a backing array for the hashtable.\n  // Reads `capacity` and updates all other fields based on the result of\n  // the allocation.\n  //\n  // It also may do the folowing actions:\n  // 1. initialize control bytes\n  // 2. initialize slots\n  // 3. deallocate old slots.\n  //\n  // We are bundling a lot of functionality\n  // in one ABSL_ATTRIBUTE_NOINLINE function in order to minimize binary code\n  // duplication in raw_hash_set<>::resize.\n  //\n  // `c.capacity()` must be nonzero.\n  // POSTCONDITIONS:\n  //  1. CommonFields is initialized.\n  //\n  //  if IsGrowingIntoSingleGroupApplicable && TransferUsesMemcpy\n  //    Both control bytes and slots are fully initialized.\n  //    old_slots are deallocated.\n  //    infoz.RecordRehash is called.\n  //\n  //  if IsGrowingIntoSingleGroupApplicable && !TransferUsesMemcpy\n  //    Control bytes are fully initialized.\n  //    infoz.RecordRehash is called.\n  //    GrowSizeIntoSingleGroup must be called to finish slots initialization.\n  //\n  //  if !IsGrowingIntoSingleGroupApplicable\n  //    Control bytes are initialized to empty table via ResetCtrl.\n  //    raw_hash_set<>::resize must insert elements regularly.\n  //    infoz.RecordRehash is called if old_capacity == 0.\n  //\n  //  Returns IsGrowingIntoSingleGroupApplicable result to avoid recomputation.\n  template <typename Alloc, size_t SizeOfSlot, bool TransferUsesMemcpy,\n            size_t AlignOfSlot>\n  ABSL_ATTRIBUTE_NOINLINE bool InitializeSlots(CommonFields& c, void* old_slots,\n                                               Alloc alloc) {\n    assert(c.capacity());\n    // Folks with custom allocators often make unwarranted assumptions about the\n    // behavior of their classes vis-a-vis trivial destructability and what\n    // calls they will or won't make.  Avoid sampling for people with custom\n    // allocators to get us out of this mess.  This is not a hard guarantee but\n    // a workaround while we plan the exact guarantee we want to provide.\n    const size_t sample_size =\n        (std::is_same<Alloc, std::allocator<char>>::value &&\n         c.slot_array() == nullptr)\n            ? SizeOfSlot\n            : 0;\n    HashtablezInfoHandle infoz =\n        sample_size > 0 ? Sample(sample_size) : c.infoz();\n\n    const bool has_infoz = infoz.IsSampled();\n    const size_t cap = c.capacity();\n    const size_t alloc_size =\n        AllocSize(cap, SizeOfSlot, AlignOfSlot, has_infoz);\n    char* mem = static_cast<char*>(\n        Allocate<BackingArrayAlignment(AlignOfSlot)>(&alloc, alloc_size));\n    const GenerationType old_generation = c.generation();\n    c.set_generation_ptr(reinterpret_cast<GenerationType*>(\n        mem + GenerationOffset(cap, has_infoz)));\n    c.set_generation(NextGeneration(old_generation));\n    c.set_control(reinterpret_cast<ctrl_t*>(mem + ControlOffset(has_infoz)));\n    c.set_slots(mem + SlotOffset(cap, AlignOfSlot, has_infoz));\n    ResetGrowthLeft(c);\n\n    const bool grow_single_group =\n        IsGrowingIntoSingleGroupApplicable(old_capacity_, c.capacity());\n    if (old_capacity_ != 0 && grow_single_group) {\n      if (TransferUsesMemcpy) {\n        GrowSizeIntoSingleGroupTransferable(c, old_slots, SizeOfSlot);\n        DeallocateOld<AlignOfSlot>(alloc, SizeOfSlot, old_slots);\n      } else {\n        GrowIntoSingleGroupShuffleControlBytes(c.control(), c.capacity());\n      }\n    } else {\n      ResetCtrl(c, SizeOfSlot);\n    }\n\n    c.set_has_infoz(has_infoz);\n    if (has_infoz) {\n      infoz.RecordStorageChanged(c.size(), cap);\n      if (grow_single_group || old_capacity_ == 0) {\n        infoz.RecordRehash(0);\n      }\n      c.set_infoz(infoz);\n    }\n    return grow_single_group;\n  }\n\n  // Relocates slots into new single group consistent with\n  // GrowIntoSingleGroupShuffleControlBytes.\n  //\n  // PRECONDITIONS:\n  // 1. GrowIntoSingleGroupShuffleControlBytes was already called.\n  template <class PolicyTraits, class Alloc>\n  void GrowSizeIntoSingleGroup(CommonFields& c, Alloc& alloc_ref,\n                               typename PolicyTraits::slot_type* old_slots) {\n    assert(old_capacity_ < Group::kWidth / 2);\n    assert(IsGrowingIntoSingleGroupApplicable(old_capacity_, c.capacity()));\n    using slot_type = typename PolicyTraits::slot_type;\n    assert(is_single_group(c.capacity()));\n\n    auto* new_slots = reinterpret_cast<slot_type*>(c.slot_array());\n\n    size_t shuffle_bit = old_capacity_ / 2 + 1;\n    for (size_t i = 0; i < old_capacity_; ++i) {\n      if (IsFull(old_ctrl_[i])) {\n        size_t new_i = i ^ shuffle_bit;\n        SanitizerUnpoisonMemoryRegion(new_slots + new_i, sizeof(slot_type));\n        PolicyTraits::transfer(&alloc_ref, new_slots + new_i, old_slots + i);\n      }\n    }\n    PoisonSingleGroupEmptySlots(c, sizeof(slot_type));\n  }\n\n  // Deallocates old backing array.\n  template <size_t AlignOfSlot, class CharAlloc>\n  void DeallocateOld(CharAlloc alloc_ref, size_t slot_size, void* old_slots) {\n    SanitizerUnpoisonMemoryRegion(old_slots, slot_size * old_capacity_);\n    Deallocate<BackingArrayAlignment(AlignOfSlot)>(\n        &alloc_ref, old_ctrl_ - ControlOffset(had_infoz_),\n        AllocSize(old_capacity_, slot_size, AlignOfSlot, had_infoz_));\n  }\n\n private:\n  // Returns true if `GrowSizeIntoSingleGroup` can be used for resizing.\n  static bool IsGrowingIntoSingleGroupApplicable(size_t old_capacity,\n                                                 size_t new_capacity) {\n    // NOTE that `old_capacity < new_capacity` in order to have\n    // `old_capacity < Group::kWidth / 2` to make faster copies of 8 bytes.\n    return is_single_group(new_capacity) && old_capacity < new_capacity;\n  }\n\n  // Relocates control bytes and slots into new single group for\n  // transferable objects.\n  // Must be called only if IsGrowingIntoSingleGroupApplicable returned true.\n  void GrowSizeIntoSingleGroupTransferable(CommonFields& c, void* old_slots,\n                                           size_t slot_size);\n\n  // Shuffle control bits deterministically to the next capacity.\n  // Returns offset for newly added element with given hash.\n  //\n  // PRECONDITIONs:\n  // 1. new_ctrl is allocated for new_capacity,\n  //    but not initialized.\n  // 2. new_capacity is a single group.\n  //\n  // All elements are transferred into the first `old_capacity + 1` positions\n  // of the new_ctrl. Elements are rotated by `old_capacity_ / 2 + 1` positions\n  // in order to change an order and keep it non deterministic.\n  // Although rotation itself deterministic, position of the new added element\n  // will be based on `H1` and is not deterministic.\n  //\n  // Examples:\n  // S = kSentinel, E = kEmpty\n  //\n  // old_ctrl = SEEEEEEEE...\n  // new_ctrl = ESEEEEEEE...\n  //\n  // old_ctrl = 0SEEEEEEE...\n  // new_ctrl = E0ESE0EEE...\n  //\n  // old_ctrl = 012S012EEEEEEEEE...\n  // new_ctrl = 2E01EEES2E01EEE...\n  //\n  // old_ctrl = 0123456S0123456EEEEEEEEEEE...\n  // new_ctrl = 456E0123EEEEEES456E0123EEE...\n  void GrowIntoSingleGroupShuffleControlBytes(ctrl_t* new_ctrl,\n                                              size_t new_capacity) const;\n\n  // Shuffle trivially transferable slots in the way consistent with\n  // GrowIntoSingleGroupShuffleControlBytes.\n  //\n  // PRECONDITIONs:\n  // 1. old_capacity must be non-zero.\n  // 2. new_ctrl is fully initialized using\n  //    GrowIntoSingleGroupShuffleControlBytes.\n  // 3. new_slots is allocated and *not* poisoned.\n  //\n  // POSTCONDITIONS:\n  // 1. new_slots are transferred from old_slots_ consistent with\n  //    GrowIntoSingleGroupShuffleControlBytes.\n  // 2. Empty new_slots are *not* poisoned.\n  void GrowIntoSingleGroupShuffleTransferableSlots(void* old_slots,\n                                                   void* new_slots,\n                                                   size_t slot_size) const;\n\n  // Poison empty slots that were transferred using the deterministic algorithm\n  // described above.\n  // PRECONDITIONs:\n  // 1. new_ctrl is fully initialized using\n  //    GrowIntoSingleGroupShuffleControlBytes.\n  // 2. new_slots is fully initialized consistent with\n  //    GrowIntoSingleGroupShuffleControlBytes.\n  void PoisonSingleGroupEmptySlots(CommonFields& c, size_t slot_size) const {\n    // poison non full items\n    for (size_t i = 0; i < c.capacity(); ++i) {\n      if (!IsFull(c.control()[i])) {\n        SanitizerPoisonMemoryRegion(SlotAddress(c.slot_array(), i, slot_size),\n                                    slot_size);\n      }\n    }\n  }\n\n  ctrl_t* old_ctrl_;\n  size_t old_capacity_;\n  bool had_infoz_;\n}",
  "id": "BLOCK-CPP-05341",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 1522,
  "validation_status": "validated"
}