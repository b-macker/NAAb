{
  "code": "{\nnamespace details {\n\nSPDLOG_INLINE registry::registry()\n    : formatter_(new pattern_formatter()) {\n#ifndef SPDLOG_DISABLE_DEFAULT_LOGGER\n    // create default logger (ansicolor_stdout_sink_mt or wincolor_stdout_sink_mt in windows).\n    #ifdef _WIN32\n    auto color_sink = std::make_shared<sinks::wincolor_stdout_sink_mt>();\n    #else\n    auto color_sink = std::make_shared<sinks::ansicolor_stdout_sink_mt>();\n    #endif\n\n    const char *default_logger_name = \"\";\n    default_logger_ = std::make_shared<spdlog::logger>(default_logger_name, std::move(color_sink));\n    loggers_[default_logger_name] = default_logger_;\n\n#endif  // SPDLOG_DISABLE_DEFAULT_LOGGER\n}\n\nSPDLOG_INLINE registry::~registry() = default;\n\nSPDLOG_INLINE void registry::register_logger(std::shared_ptr<logger> new_logger) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    register_logger_(std::move(new_logger));\n}\n\nSPDLOG_INLINE void registry::initialize_logger(std::shared_ptr<logger> new_logger) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    new_logger->set_formatter(formatter_->clone());\n\n    if (err_handler_) {\n        new_logger->set_error_handler(err_handler_);\n    }\n\n    // set new level according to previously configured level or default level\n    auto it = log_levels_.find(new_logger->name());\n    auto new_level = it != log_levels_.end() ? it->second : global_log_level_;\n    new_logger->set_level(new_level);\n\n    new_logger->flush_on(flush_level_);\n\n    if (backtrace_n_messages_ > 0) {\n        new_logger->enable_backtrace(backtrace_n_messages_);\n    }\n\n    if (automatic_registration_) {\n        register_logger_(std::move(new_logger));\n    }\n}\n\nSPDLOG_INLINE std::shared_ptr<logger> registry::get(const std::string &logger_name) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    auto found = loggers_.find(logger_name);\n    return found == loggers_.end() ? nullptr : found->second;\n}\n\nSPDLOG_INLINE std::shared_ptr<logger> registry::default_logger() {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    return default_logger_;\n}\n\n// Return raw ptr to the default logger.\n// To be used directly by the spdlog default api (e.g. spdlog::info)\n// This make the default API faster, but cannot be used concurrently with set_default_logger().\n// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.\nSPDLOG_INLINE logger *registry::get_default_raw() { return default_logger_.get(); }\n\n// set default logger.\n// default logger is stored in default_logger_ (for faster retrieval) and in the loggers_ map.\nSPDLOG_INLINE void registry::set_default_logger(std::shared_ptr<logger> new_default_logger) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    // remove previous default logger from the map\n    if (default_logger_ != nullptr) {\n        loggers_.erase(default_logger_->name());\n    }\n    if (new_default_logger != nullptr) {\n        loggers_[new_default_logger->name()] = new_default_logger;\n    }\n    default_logger_ = std::move(new_default_logger);\n}\n\nSPDLOG_INLINE void registry::set_tp(std::shared_ptr<thread_pool> tp) {\n    std::lock_guard<std::recursive_mutex> lock(tp_mutex_);\n    tp_ = std::move(tp);\n}\n\nSPDLOG_INLINE std::shared_ptr<thread_pool> registry::get_tp() {\n    std::lock_guard<std::recursive_mutex> lock(tp_mutex_);\n    return tp_;\n}\n\n// Set global formatter. Each sink in each logger will get a clone of this object\nSPDLOG_INLINE void registry::set_formatter(std::unique_ptr<formatter> formatter) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    formatter_ = std::move(formatter);\n    for (auto &l : loggers_) {\n        l.second->set_formatter(formatter_->clone());\n    }\n}\n\nSPDLOG_INLINE void registry::enable_backtrace(size_t n_messages) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    backtrace_n_messages_ = n_messages;\n\n    for (auto &l : loggers_) {\n        l.second->enable_backtrace(n_messages);\n    }\n}\n\nSPDLOG_INLINE void registry::disable_backtrace() {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    backtrace_n_messages_ = 0;\n    for (auto &l : loggers_) {\n        l.second->disable_backtrace();\n    }\n}\n\nSPDLOG_INLINE void registry::set_level(level::level_enum log_level) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    for (auto &l : loggers_) {\n        l.second->set_level(log_level);\n    }\n    global_log_level_ = log_level;\n}\n\nSPDLOG_INLINE void registry::flush_on(level::level_enum log_level) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    for (auto &l : loggers_) {\n        l.second->flush_on(log_level);\n    }\n    flush_level_ = log_level;\n}\n\nSPDLOG_INLINE void registry::set_error_handler(err_handler handler) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    for (auto &l : loggers_) {\n        l.second->set_error_handler(handler);\n    }\n    err_handler_ = std::move(handler);\n}\n\nSPDLOG_INLINE void registry::apply_all(\n    const std::function<void(const std::shared_ptr<logger>)> &fun) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    for (auto &l : loggers_) {\n        fun(l.second);\n    }\n}\n\nSPDLOG_INLINE void registry::flush_all() {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    for (auto &l : loggers_) {\n        l.second->flush();\n    }\n}\n\nSPDLOG_INLINE void registry::drop(const std::string &logger_name) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    auto is_default_logger = default_logger_ && default_logger_->name() == logger_name;\n    loggers_.erase(logger_name);\n    if (is_default_logger) {\n        default_logger_.reset();\n    }\n}\n\nSPDLOG_INLINE void registry::drop_all() {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    loggers_.clear();\n    default_logger_.reset();\n}\n\n// clean all resources and threads started by the registry\nSPDLOG_INLINE void registry::shutdown() {\n    {\n        std::lock_guard<std::mutex> lock(flusher_mutex_);\n        periodic_flusher_.reset();\n    }\n\n    drop_all();\n\n    {\n        std::lock_guard<std::recursive_mutex> lock(tp_mutex_);\n        tp_.reset();\n    }\n}\n\nSPDLOG_INLINE std::recursive_mutex &registry::tp_mutex() { return tp_mutex_; }\n\nSPDLOG_INLINE void registry::set_automatic_registration(bool automatic_registration) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    automatic_registration_ = automatic_registration;\n}\n\nSPDLOG_INLINE void registry::set_levels(log_levels levels, level::level_enum *global_level) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    log_levels_ = std::move(levels);\n    auto global_level_requested = global_level != nullptr;\n    global_log_level_ = global_level_requested ? *global_level : global_log_level_;\n\n    for (auto &logger : loggers_) {\n        auto logger_entry = log_levels_.find(logger.first);\n        if (logger_entry != log_levels_.end()) {\n            logger.second->set_level(logger_entry->second);\n        } else if (global_level_requested) {\n            logger.second->set_level(*global_level);\n        }\n    }\n}\n\nSPDLOG_INLINE registry &registry::instance() {\n    static registry s_instance;\n    return s_instance;\n}\n\nSPDLOG_INLINE void registry::apply_logger_env_levels(std::shared_ptr<logger> new_logger) {\n    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n    auto it = log_levels_.find(new_logger->name());\n    auto new_level = it != log_levels_.end() ? it->second : global_log_level_;\n    new_logger->set_level(new_level);\n}\n\nSPDLOG_INLINE void registry::throw_if_exists_(const std::string &logger_name) {\n    if (loggers_.find(logger_name) != loggers_.end()) {\n        throw_spdlog_ex(\"logger with name '\" + logger_name + \"' already exists\");\n    }\n}\n\nSPDLOG_INLINE void registry::register_logger_(std::shared_ptr<logger> new_logger) {\n    auto logger_name = new_logger->name();\n    throw_if_exists_(logger_name);\n    loggers_[logger_name] = std::move(new_logger);\n}\n\n}  // namespace details\n}",
  "id": "BLOCK-CPP-00294",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/registry-inl.h",
  "source_line": 30,
  "validation_status": "validated"
}