{
  "code": "{\n#ifdef ABSL_IS_LITTLE_ENDIAN\n\ninline uint16_t FromHost16(uint16_t x) { return gbswap_16(x); }\ninline uint16_t ToHost16(uint16_t x) { return gbswap_16(x); }\n\ninline uint32_t FromHost32(uint32_t x) { return gbswap_32(x); }\ninline uint32_t ToHost32(uint32_t x) { return gbswap_32(x); }\n\ninline uint64_t FromHost64(uint64_t x) { return gbswap_64(x); }\ninline uint64_t ToHost64(uint64_t x) { return gbswap_64(x); }\n\ninline constexpr bool IsLittleEndian() { return true; }\n\n#elif defined ABSL_IS_BIG_ENDIAN\n\ninline uint16_t FromHost16(uint16_t x) { return x; }\ninline uint16_t ToHost16(uint16_t x) { return x; }\n\ninline uint32_t FromHost32(uint32_t x) { return x; }\ninline uint32_t ToHost32(uint32_t x) { return x; }\n\ninline uint64_t FromHost64(uint64_t x) { return x; }\ninline uint64_t ToHost64(uint64_t x) { return x; }\n\ninline constexpr bool IsLittleEndian() { return false; }\n\n#endif /* ENDIAN */\n\ninline uint8_t FromHost(uint8_t x) { return x; }\ninline uint16_t FromHost(uint16_t x) { return FromHost16(x); }\ninline uint32_t FromHost(uint32_t x) { return FromHost32(x); }\ninline uint64_t FromHost(uint64_t x) { return FromHost64(x); }\ninline uint8_t ToHost(uint8_t x) { return x; }\ninline uint16_t ToHost(uint16_t x) { return ToHost16(x); }\ninline uint32_t ToHost(uint32_t x) { return ToHost32(x); }\ninline uint64_t ToHost(uint64_t x) { return ToHost64(x); }\n\ninline int8_t FromHost(int8_t x) { return x; }\ninline int16_t FromHost(int16_t x) {\n  return bit_cast<int16_t>(FromHost16(bit_cast<uint16_t>(x)));\n}\ninline int32_t FromHost(int32_t x) {\n  return bit_cast<int32_t>(FromHost32(bit_cast<uint32_t>(x)));\n}\ninline int64_t FromHost(int64_t x) {\n  return bit_cast<int64_t>(FromHost64(bit_cast<uint64_t>(x)));\n}\ninline int8_t ToHost(int8_t x) { return x; }\ninline int16_t ToHost(int16_t x) {\n  return bit_cast<int16_t>(ToHost16(bit_cast<uint16_t>(x)));\n}\ninline int32_t ToHost(int32_t x) {\n  return bit_cast<int32_t>(ToHost32(bit_cast<uint32_t>(x)));\n}\ninline int64_t ToHost(int64_t x) {\n  return bit_cast<int64_t>(ToHost64(bit_cast<uint64_t>(x)));\n}\n\n// Functions to do unaligned loads and stores in big-endian order.\ninline uint16_t Load16(absl::Nonnull<const void *> p) {\n  return ToHost16(ABSL_INTERNAL_UNALIGNED_LOAD16(p));\n}\n\ninline void Store16(absl::Nonnull<void *> p, uint16_t v) {\n  ABSL_INTERNAL_UNALIGNED_STORE16(p, FromHost16(v));\n}\n\ninline uint32_t Load32(absl::Nonnull<const void *> p) {\n  return ToHost32(ABSL_INTERNAL_UNALIGNED_LOAD32(p));\n}\n\ninline void Store32(absl::Nonnull<void *>p, uint32_t v) {\n  ABSL_INTERNAL_UNALIGNED_STORE32(p, FromHost32(v));\n}\n\ninline uint64_t Load64(absl::Nonnull<const void *> p) {\n  return ToHost64(ABSL_INTERNAL_UNALIGNED_LOAD64(p));\n}\n\ninline void Store64(absl::Nonnull<void *> p, uint64_t v) {\n  ABSL_INTERNAL_UNALIGNED_STORE64(p, FromHost64(v));\n}\n\n}",
  "id": "BLOCK-CPP-04664",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/endian.h",
  "source_line": 194,
  "validation_status": "validated"
}