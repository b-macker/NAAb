{
  "code": "{\nnamespace yaml {\n\ntemplate <> struct MappingTraits<clang::tooling::FileByteRange> {\n  static void mapping(IO &Io, clang::tooling::FileByteRange &R) {\n    Io.mapRequired(\"FilePath\", R.FilePath);\n    Io.mapRequired(\"FileOffset\", R.FileOffset);\n    Io.mapRequired(\"Length\", R.Length);\n  }\n};\n\ntemplate <> struct MappingTraits<clang::tooling::DiagnosticMessage> {\n  static void mapping(IO &Io, clang::tooling::DiagnosticMessage &M) {\n    Io.mapRequired(\"Message\", M.Message);\n    Io.mapOptional(\"FilePath\", M.FilePath);\n    Io.mapOptional(\"FileOffset\", M.FileOffset);\n    std::vector<clang::tooling::Replacement> Fixes;\n    for (auto &Replacements : M.Fix) {\n      llvm::append_range(Fixes, Replacements.second);\n    }\n    Io.mapRequired(\"Replacements\", Fixes);\n    for (auto &Fix : Fixes) {\n      llvm::Error Err = M.Fix[Fix.getFilePath()].add(Fix);\n      if (Err) {\n        // FIXME: Implement better conflict handling.\n        llvm::errs() << \"Fix conflicts with existing fix: \"\n                     << llvm::toString(std::move(Err)) << \"\\n\";\n      }\n    }\n    Io.mapOptional(\"Ranges\", M.Ranges);\n  }\n};\n\ntemplate <> struct MappingTraits<clang::tooling::Diagnostic> {\n  /// Helper to (de)serialize a Diagnostic since we don't have direct\n  /// access to its data members.\n  class NormalizedDiagnostic {\n  public:\n    NormalizedDiagnostic(const IO &)\n        : DiagLevel(clang::tooling::Diagnostic::Level::Warning) {}\n\n    NormalizedDiagnostic(const IO &, const clang::tooling::Diagnostic &D)\n        : DiagnosticName(D.DiagnosticName), Message(D.Message), Notes(D.Notes),\n          DiagLevel(D.DiagLevel), BuildDirectory(D.BuildDirectory) {}\n\n    clang::tooling::Diagnostic denormalize(const IO &) {\n      return clang::tooling::Diagnostic(DiagnosticName, Message, Notes,\n                                        DiagLevel, BuildDirectory);\n    }\n\n    std::string DiagnosticName;\n    clang::tooling::DiagnosticMessage Message;\n    SmallVector<clang::tooling::DiagnosticMessage, 1> Notes;\n    clang::tooling::Diagnostic::Level DiagLevel;\n    std::string BuildDirectory;\n  };\n\n  static void mapping(IO &Io, clang::tooling::Diagnostic &D) {\n    MappingNormalization<NormalizedDiagnostic, clang::tooling::Diagnostic> Keys(\n        Io, D);\n    Io.mapRequired(\"DiagnosticName\", Keys->DiagnosticName);\n    Io.mapRequired(\"DiagnosticMessage\", Keys->Message);\n    Io.mapOptional(\"Notes\", Keys->Notes);\n    Io.mapOptional(\"Level\", Keys->DiagLevel);\n    Io.mapOptional(\"BuildDirectory\", Keys->BuildDirectory);\n  }\n};\n\n/// Specialized MappingTraits to describe how a\n/// TranslationUnitDiagnostics is (de)serialized.\ntemplate <> struct MappingTraits<clang::tooling::TranslationUnitDiagnostics> {\n  static void mapping(IO &Io, clang::tooling::TranslationUnitDiagnostics &Doc) {\n    Io.mapRequired(\"MainSourceFile\", Doc.MainSourceFile);\n    Io.mapRequired(\"Diagnostics\", Doc.Diagnostics);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<clang::tooling::Diagnostic::Level> {\n  static void enumeration(IO &IO, clang::tooling::Diagnostic::Level &Value) {\n    IO.enumCase(Value, \"Warning\", clang::tooling::Diagnostic::Warning);\n    IO.enumCase(Value, \"Error\", clang::tooling::Diagnostic::Error);\n    IO.enumCase(Value, \"Remark\", clang::tooling::Diagnostic::Remark);\n  }\n};\n\n} // end namespace yaml\n}",
  "id": "BLOCK-CPP-21158",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/DiagnosticsYaml.h",
  "source_line": 27,
  "validation_status": "validated"
}