{
  "code": "{\n\n// In this type trait, we look for a __resize_default_init member function, and\n// we use it if available, otherwise, we use resize. We provide HasMember to\n// indicate whether __resize_default_init is present.\ntemplate <typename string_type, typename = void>\nstruct ResizeUninitializedTraits {\n  using HasMember = std::false_type;\n  static void Resize(string_type* s, size_t new_size) { s->resize(new_size); }\n};\n\n// __resize_default_init is provided by libc++ >= 8.0\ntemplate <typename string_type>\nstruct ResizeUninitializedTraits<\n    string_type, absl::void_t<decltype(std::declval<string_type&>()\n                                           .__resize_default_init(237))> > {\n  using HasMember = std::true_type;\n  static void Resize(string_type* s, size_t new_size) {\n    s->__resize_default_init(new_size);\n  }\n};\n\n// Returns true if the std::string implementation supports a resize where\n// the new characters added to the std::string are left untouched.\n//\n// (A better name might be \"STLStringSupportsUninitializedResize\", alluding to\n// the previous function.)\ntemplate <typename string_type>\ninline constexpr bool STLStringSupportsNontrashingResize(string_type*) {\n  return ResizeUninitializedTraits<string_type>::HasMember::value;\n}\n\n// Like str->resize(new_size), except any new characters added to \"*str\" as a\n// result of resizing may be left uninitialized, rather than being filled with\n// '0' bytes. Typically used when code is then going to overwrite the backing\n// store of the std::string with known data.\ntemplate <typename string_type, typename = void>\ninline void STLStringResizeUninitialized(string_type* s, size_t new_size) {\n  ResizeUninitializedTraits<string_type>::Resize(s, new_size);\n}\n\n// Used to ensure exponential growth so that the amortized complexity of\n// increasing the string size by a small amount is O(1), in contrast to\n// O(str->size()) in the case of precise growth.\ntemplate <typename string_type>\nvoid STLStringReserveAmortized(string_type* s, size_t new_size) {\n  const size_t cap = s->capacity();\n  if (new_size > cap) {\n    // Make sure to always grow by at least a factor of 2x.\n    s->reserve((std::max)(new_size, 2 * cap));\n  }\n}\n\n// In this type trait, we look for an __append_default_init member function, and\n// we use it if available, otherwise, we use append.\ntemplate <typename string_type, typename = void>\nstruct AppendUninitializedTraits {\n  static void Append(string_type* s, size_t n) {\n    s->append(n, typename string_type::value_type());\n  }\n};\n\ntemplate <typename string_type>\nstruct AppendUninitializedTraits<\n    string_type, absl::void_t<decltype(std::declval<string_type&>()\n                                           .__append_default_init(237))> > {\n  static void Append(string_type* s, size_t n) {\n    s->__append_default_init(n);\n  }\n};\n\n// Like STLStringResizeUninitialized(str, new_size), except guaranteed to use\n// exponential growth so that the amortized complexity of increasing the string\n// size by a small amount is O(1), in contrast to O(str->size()) in the case of\n// precise growth.\ntemplate <typename string_type>\nvoid STLStringResizeUninitializedAmortized(string_type* s, size_t new_size) {\n  const size_t size = s->size();\n  if (new_size > size) {\n    AppendUninitializedTraits<string_type>::Append(s, new_size - size);\n  } else {\n    s->erase(new_size);\n  }\n}\n\n}",
  "id": "BLOCK-CPP-06232",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/resize_uninitialized.h",
  "source_line": 30,
  "validation_status": "validated"
}