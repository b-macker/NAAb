{
  "code": "{\n\nclass CrcMemcpyEngine {\n public:\n  virtual ~CrcMemcpyEngine() = default;\n\n  virtual crc32c_t Compute(void* __restrict dst, const void* __restrict src,\n                           std::size_t length, crc32c_t initial_crc) const = 0;\n\n protected:\n  CrcMemcpyEngine() = default;\n};\n\nclass CrcMemcpy {\n public:\n  static crc32c_t CrcAndCopy(void* __restrict dst, const void* __restrict src,\n                             std::size_t length,\n                             crc32c_t initial_crc = crc32c_t{0},\n                             bool non_temporal = false) {\n    static const ArchSpecificEngines engines = GetArchSpecificEngines();\n    auto* engine = non_temporal ? engines.non_temporal : engines.temporal;\n    return engine->Compute(dst, src, length, initial_crc);\n  }\n\n  // For testing only: get an architecture-specific engine for tests.\n  static std::unique_ptr<CrcMemcpyEngine> GetTestEngine(int vector,\n                                                        int integer);\n\n private:\n  struct ArchSpecificEngines {\n    CrcMemcpyEngine* temporal;\n    CrcMemcpyEngine* non_temporal;\n  };\n\n  static ArchSpecificEngines GetArchSpecificEngines();\n};\n\n// Fallback CRC-memcpy engine.\nclass FallbackCrcMemcpyEngine : public CrcMemcpyEngine {\n public:\n  FallbackCrcMemcpyEngine() = default;\n  FallbackCrcMemcpyEngine(const FallbackCrcMemcpyEngine&) = delete;\n  FallbackCrcMemcpyEngine operator=(const FallbackCrcMemcpyEngine&) = delete;\n\n  crc32c_t Compute(void* __restrict dst, const void* __restrict src,\n                   std::size_t length, crc32c_t initial_crc) const override;\n};\n\n// CRC Non-Temporal-Memcpy engine.\nclass CrcNonTemporalMemcpyEngine : public CrcMemcpyEngine {\n public:\n  CrcNonTemporalMemcpyEngine() = default;\n  CrcNonTemporalMemcpyEngine(const CrcNonTemporalMemcpyEngine&) = delete;\n  CrcNonTemporalMemcpyEngine operator=(const CrcNonTemporalMemcpyEngine&) =\n      delete;\n\n  crc32c_t Compute(void* __restrict dst, const void* __restrict src,\n                   std::size_t length, crc32c_t initial_crc) const override;\n};\n\n// CRC Non-Temporal-Memcpy AVX engine.\nclass CrcNonTemporalMemcpyAVXEngine : public CrcMemcpyEngine {\n public:\n  CrcNonTemporalMemcpyAVXEngine() = default;\n  CrcNonTemporalMemcpyAVXEngine(const CrcNonTemporalMemcpyAVXEngine&) = delete;\n  CrcNonTemporalMemcpyAVXEngine operator=(\n      const CrcNonTemporalMemcpyAVXEngine&) = delete;\n\n  crc32c_t Compute(void* __restrict dst, const void* __restrict src,\n                   std::size_t length, crc32c_t initial_crc) const override;\n};\n\n// Copy source to destination and return the CRC32C of the data copied.  If an\n// accelerated version is available, use the accelerated version, otherwise use\n// the generic fallback version.\ninline crc32c_t Crc32CAndCopy(void* __restrict dst, const void* __restrict src,\n                              std::size_t length,\n                              crc32c_t initial_crc = crc32c_t{0},\n                              bool non_temporal = false) {\n  return CrcMemcpy::CrcAndCopy(dst, src, length, initial_crc, non_temporal);\n}\n\n}",
  "id": "BLOCK-CPP-05441",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc_memcpy.h",
  "source_line": 36,
  "validation_status": "validated"
}