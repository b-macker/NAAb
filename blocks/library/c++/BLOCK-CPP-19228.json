{
  "code": "{\n  class Preprocessor;\n\n  /// An RAII class that tracks when the Preprocessor starts and stops lexing\n  /// the definition of a (ISO C/C++) variadic macro.  As an example, this is\n  /// useful for unpoisoning and repoisoning certain identifiers (such as\n  /// __VA_ARGS__) that are only allowed in this context.  Also, being a friend\n  /// of the Preprocessor class allows it to access PP's cached identifiers\n  /// directly (as opposed to performing a lookup each time).\n  class VariadicMacroScopeGuard {\n    const Preprocessor &PP;\n    IdentifierInfo *const Ident__VA_ARGS__;\n    IdentifierInfo *const Ident__VA_OPT__;\n\n  public:\n    VariadicMacroScopeGuard(const Preprocessor &P)\n        : PP(P), Ident__VA_ARGS__(PP.Ident__VA_ARGS__),\n          Ident__VA_OPT__(PP.Ident__VA_OPT__) {\n      assert(Ident__VA_ARGS__->isPoisoned() && \"__VA_ARGS__ should be poisoned \"\n                                              \"outside an ISO C/C++ variadic \"\n                                              \"macro definition!\");\n      assert(Ident__VA_OPT__->isPoisoned() && \"__VA_OPT__ should be poisoned!\");\n    }\n\n    /// Client code should call this function just before the Preprocessor is\n    /// about to Lex tokens from the definition of a variadic (ISO C/C++) macro.\n    void enterScope() {\n      Ident__VA_ARGS__->setIsPoisoned(false);\n      Ident__VA_OPT__->setIsPoisoned(false);\n    }\n\n    /// Client code should call this function as soon as the Preprocessor has\n    /// either completed lexing the macro's definition tokens, or an error\n    /// occurred and the context is being exited.  This function is idempotent\n    /// (might be explicitly called, and then reinvoked via the destructor).\n    void exitScope() {\n      Ident__VA_ARGS__->setIsPoisoned(true);\n      Ident__VA_OPT__->setIsPoisoned(true);\n    }\n\n    ~VariadicMacroScopeGuard() { exitScope(); }\n  };\n\n  /// A class for tracking whether we're inside a VA_OPT during a\n  /// traversal of the tokens of a variadic macro definition.\n  class VAOptDefinitionContext {\n    /// Contains all the locations of so far unmatched lparens.\n    SmallVector<SourceLocation, 8> UnmatchedOpeningParens;\n\n    const IdentifierInfo *const Ident__VA_OPT__;\n\n\n  public:\n    VAOptDefinitionContext(Preprocessor &PP)\n        : Ident__VA_OPT__(PP.Ident__VA_OPT__) {}\n\n    bool isVAOptToken(const Token &T) const {\n      return Ident__VA_OPT__ && T.getIdentifierInfo() == Ident__VA_OPT__;\n    }\n\n    /// Returns true if we have seen the __VA_OPT__ and '(' but before having\n    /// seen the matching ')'.\n    bool isInVAOpt() const { return UnmatchedOpeningParens.size(); }\n\n    /// Call this function as soon as you see __VA_OPT__ and '('.\n    void sawVAOptFollowedByOpeningParens(const SourceLocation LParenLoc) {\n      assert(!isInVAOpt() && \"Must NOT be within VAOPT context to call this\");\n      UnmatchedOpeningParens.push_back(LParenLoc);\n\n    }\n\n    SourceLocation getUnmatchedOpeningParenLoc() const {\n      assert(isInVAOpt() && \"Must be within VAOPT context to call this\");\n      return UnmatchedOpeningParens.back();\n    }\n\n    /// Call this function each time an rparen is seen.  It returns true only if\n    /// the rparen that was just seen was the eventual (non-nested) closing\n    /// paren for VAOPT, and ejects us out of the VAOPT context.\n    bool sawClosingParen() {\n      assert(isInVAOpt() && \"Must be within VAOPT context to call this\");\n      UnmatchedOpeningParens.pop_back();\n      return !UnmatchedOpeningParens.size();\n    }\n\n    /// Call this function each time an lparen is seen.\n    void sawOpeningParen(SourceLocation LParenLoc) {\n      assert(isInVAOpt() && \"Must be within VAOPT context to call this\");\n      UnmatchedOpeningParens.push_back(LParenLoc);\n    }\n\n    /// Are we at the top level within the __VA_OPT__?\n    bool isAtTopLevel() const { return UnmatchedOpeningParens.size() == 1; }\n  };\n\n  /// A class for tracking whether we're inside a VA_OPT during a\n  /// traversal of the tokens of a macro during macro expansion.\n  class VAOptExpansionContext : VAOptDefinitionContext {\n\n    Token SyntheticEOFToken;\n\n    // The (spelling) location of the current __VA_OPT__ in the replacement list\n    // of the function-like macro being expanded.\n    SourceLocation VAOptLoc;\n\n    // NumOfTokensPriorToVAOpt : when != -1, contains the index *of* the first\n    // token of the current VAOPT contents (so we know where to start eager\n    // token-pasting and stringification) *within*  the substituted tokens of\n    // the function-like macro's new replacement list.\n    int NumOfTokensPriorToVAOpt = -1;\n\n    unsigned LeadingSpaceForStringifiedToken : 1;\n\n    unsigned StringifyBefore : 1;\n    unsigned CharifyBefore : 1;\n    unsigned BeginsWithPlaceholder : 1;\n    unsigned EndsWithPlaceholder : 1;\n\n    bool hasStringifyBefore() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      return StringifyBefore;\n    }\n\n    bool isReset() const {\n      return NumOfTokensPriorToVAOpt == -1 ||\n             VAOptLoc.isInvalid();\n    }\n\n  public:\n    VAOptExpansionContext(Preprocessor &PP)\n        : VAOptDefinitionContext(PP), LeadingSpaceForStringifiedToken(false),\n          StringifyBefore(false), CharifyBefore(false),\n          BeginsWithPlaceholder(false), EndsWithPlaceholder(false) {\n      SyntheticEOFToken.startToken();\n      SyntheticEOFToken.setKind(tok::eof);\n    }\n\n    void reset() {\n      VAOptLoc = SourceLocation();\n      NumOfTokensPriorToVAOpt = -1;\n      LeadingSpaceForStringifiedToken = false;\n      StringifyBefore = false;\n      CharifyBefore = false;\n      BeginsWithPlaceholder = false;\n      EndsWithPlaceholder = false;\n    }\n\n    const Token &getEOFTok() const { return SyntheticEOFToken; }\n\n    void sawHashOrHashAtBefore(const bool HasLeadingSpace,\n                               const bool IsHashAt) {\n\n      StringifyBefore = !IsHashAt;\n      CharifyBefore = IsHashAt;\n      LeadingSpaceForStringifiedToken = HasLeadingSpace;\n    }\n\n    void hasPlaceholderAfterHashhashAtStart() { BeginsWithPlaceholder = true; }\n    void hasPlaceholderBeforeRParen() {\n      if (isAtTopLevel())\n        EndsWithPlaceholder = true;\n    }\n\n\n    bool beginsWithPlaceholder() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      return BeginsWithPlaceholder;\n    }\n    bool endsWithPlaceholder() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      return EndsWithPlaceholder;\n    }\n\n    bool hasCharifyBefore() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      return CharifyBefore;\n    }\n    bool hasStringifyOrCharifyBefore() const {\n      return hasStringifyBefore() || hasCharifyBefore();\n    }\n\n    unsigned int getNumberOfTokensPriorToVAOpt() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      return NumOfTokensPriorToVAOpt;\n    }\n\n    bool getLeadingSpaceForStringifiedToken() const {\n      assert(hasStringifyBefore() &&\n             \"Must only be called if this has been marked for stringification\");\n      return LeadingSpaceForStringifiedToken;\n    }\n\n    void sawVAOptFollowedByOpeningParens(const SourceLocation VAOptLoc,\n                                         const unsigned int NumPriorTokens) {\n      assert(VAOptLoc.isFileID() && \"Must not come from a macro expansion\");\n      assert(isReset() && \"Must only be called if the state has been reset\");\n      VAOptDefinitionContext::sawVAOptFollowedByOpeningParens(SourceLocation());\n      this->VAOptLoc = VAOptLoc;\n      NumOfTokensPriorToVAOpt = NumPriorTokens;\n      assert(NumOfTokensPriorToVAOpt > -1 &&\n             \"Too many prior tokens\");\n    }\n\n    SourceLocation getVAOptLoc() const {\n      assert(!isReset() &&\n             \"Must only be called if the state has not been reset\");\n      assert(VAOptLoc.isValid() && \"__VA_OPT__ location must be valid\");\n      return VAOptLoc;\n    }\n    using VAOptDefinitionContext::isVAOptToken;\n    using VAOptDefinitionContext::isInVAOpt;\n    using VAOptDefinitionContext::sawClosingParen;\n    using VAOptDefinitionContext::sawOpeningParen;\n\n  };\n}",
  "id": "BLOCK-CPP-19228",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/VariadicMacroSupport.h",
  "source_line": 21,
  "validation_status": "validated"
}