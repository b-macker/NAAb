{
  "code": "{\n\ntemplate <typename T>\nclass AtomicHook;\n\n// To workaround AtomicHook not being constant-initializable on some platforms,\n// prefer to annotate instances with `ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES`\n// instead of `ABSL_CONST_INIT`.\n#if ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT\n#define ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES ABSL_CONST_INIT\n#else\n#define ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES\n#endif\n\n// `AtomicHook` is a helper class, templatized on a raw function pointer type,\n// for implementing Abseil customization hooks.  It is a callable object that\n// dispatches to the registered hook.  Objects of type `AtomicHook` must have\n// static or thread storage duration.\n//\n// A default constructed object performs a no-op (and returns a default\n// constructed object) if no hook has been registered.\n//\n// Hooks can be pre-registered via constant initialization, for example:\n//\n// ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES static AtomicHook<void(*)()>\n//     my_hook(DefaultAction);\n//\n// and then changed at runtime via a call to `Store()`.\n//\n// Reads and writes guarantee memory_order_acquire/memory_order_release\n// semantics.\ntemplate <typename ReturnType, typename... Args>\nclass AtomicHook<ReturnType (*)(Args...)> {\n public:\n  using FnPtr = ReturnType (*)(Args...);\n\n  // Constructs an object that by default performs a no-op (and\n  // returns a default constructed object) when no hook as been registered.\n  constexpr AtomicHook() : AtomicHook(DummyFunction) {}\n\n  // Constructs an object that by default dispatches to/returns the\n  // pre-registered default_fn when no hook has been registered at runtime.\n#if ABSL_HAVE_WORKING_ATOMIC_POINTER && ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT\n  explicit constexpr AtomicHook(FnPtr default_fn)\n      : hook_(default_fn), default_fn_(default_fn) {}\n#elif ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT\n  explicit constexpr AtomicHook(FnPtr default_fn)\n      : hook_(kUninitialized), default_fn_(default_fn) {}\n#else\n  // As of January 2020, on all known versions of MSVC this constructor runs in\n  // the global constructor sequence.  If `Store()` is called by a dynamic\n  // initializer, we want to preserve the value, even if this constructor runs\n  // after the call to `Store()`.  If not, `hook_` will be\n  // zero-initialized by the linker and we have no need to set it.\n  // https://developercommunity.visualstudio.com/content/problem/336946/class-with-constexpr-constructor-not-using-static.html\n  explicit constexpr AtomicHook(FnPtr default_fn)\n      : /* hook_(deliberately omitted), */ default_fn_(default_fn) {\n    static_assert(kUninitialized == 0, \"here we rely on zero-initialization\");\n  }\n#endif\n\n  // Stores the provided function pointer as the value for this hook.\n  //\n  // This is intended to be called once.  Multiple calls are legal only if the\n  // same function pointer is provided for each call.  The store is implemented\n  // as a memory_order_release operation, and read accesses are implemented as\n  // memory_order_acquire.\n  void Store(FnPtr fn) {\n    bool success = DoStore(fn);\n    static_cast<void>(success);\n    assert(success);\n  }\n\n  // Invokes the registered callback.  If no callback has yet been registered, a\n  // default-constructed object of the appropriate type is returned instead.\n  template <typename... CallArgs>\n  ReturnType operator()(CallArgs&&... args) const {\n    return DoLoad()(std::forward<CallArgs>(args)...);\n  }\n\n  // Returns the registered callback, or nullptr if none has been registered.\n  // Useful if client code needs to conditionalize behavior based on whether a\n  // callback was registered.\n  //\n  // Note that atomic_hook.Load()() and atomic_hook() have different semantics:\n  // operator()() will perform a no-op if no callback was registered, while\n  // Load()() will dereference a null function pointer.  Prefer operator()() to\n  // Load()() unless you must conditionalize behavior on whether a hook was\n  // registered.\n  FnPtr Load() const {\n    FnPtr ptr = DoLoad();\n    return (ptr == DummyFunction) ? nullptr : ptr;\n  }\n\n private:\n  static ReturnType DummyFunction(Args...) {\n    return ReturnType();\n  }\n\n  // Current versions of MSVC (as of September 2017) have a broken\n  // implementation of std::atomic<T*>:  Its constructor attempts to do the\n  // equivalent of a reinterpret_cast in a constexpr context, which is not\n  // allowed.\n  //\n  // This causes an issue when building with LLVM under Windows.  To avoid this,\n  // we use a less-efficient, intptr_t-based implementation on Windows.\n#if ABSL_HAVE_WORKING_ATOMIC_POINTER\n  // Return the stored value, or DummyFunction if no value has been stored.\n  FnPtr DoLoad() const { return hook_.load(std::memory_order_acquire); }\n\n  // Store the given value.  Returns false if a different value was already\n  // stored to this object.\n  bool DoStore(FnPtr fn) {\n    assert(fn);\n    FnPtr expected = default_fn_;\n    const bool store_succeeded = hook_.compare_exchange_strong(\n        expected, fn, std::memory_order_acq_rel, std::memory_order_acquire);\n    const bool same_value_already_stored = (expected == fn);\n    return store_succeeded || same_value_already_stored;\n  }\n\n  std::atomic<FnPtr> hook_;\n#else  // !ABSL_HAVE_WORKING_ATOMIC_POINTER\n  // Use a sentinel value unlikely to be the address of an actual function.\n  static constexpr intptr_t kUninitialized = 0;\n\n  static_assert(sizeof(intptr_t) >= sizeof(FnPtr),\n                \"intptr_t can't contain a function pointer\");\n\n  FnPtr DoLoad() const {\n    const intptr_t value = hook_.load(std::memory_order_acquire);\n    if (value == kUninitialized) {\n      return default_fn_;\n    }\n    return reinterpret_cast<FnPtr>(value);\n  }\n\n  bool DoStore(FnPtr fn) {\n    assert(fn);\n    const auto value = reinterpret_cast<intptr_t>(fn);\n    intptr_t expected = kUninitialized;\n    const bool store_succeeded = hook_.compare_exchange_strong(\n        expected, value, std::memory_order_acq_rel, std::memory_order_acquire);\n    const bool same_value_already_stored = (expected == value);\n    return store_succeeded || same_value_already_stored;\n  }\n\n  std::atomic<intptr_t> hook_;\n#endif\n\n  const FnPtr default_fn_;\n};\n\n#undef ABSL_HAVE_WORKING_ATOMIC_POINTER\n#undef ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT\n\n}",
  "id": "BLOCK-CPP-04565",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/atomic_hook.h",
  "source_line": 40,
  "validation_status": "validated"
}