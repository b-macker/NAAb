{
  "code": "{\n    /// The base object decl, as described in the class documentation.\n    ///\n    /// The extra flag is \"true\" if the Base and Property are enough to uniquely\n    /// identify the object in memory.\n    ///\n    /// \\sa isExactProfile()\n    using BaseInfoTy = llvm::PointerIntPair<const NamedDecl *, 1, bool>;\n    BaseInfoTy Base;\n\n    /// The \"property\" decl, as described in the class documentation.\n    ///\n    /// Note that this may not actually be an ObjCPropertyDecl, e.g. in the\n    /// case of \"implicit\" properties (regular methods accessed via dot syntax).\n    const NamedDecl *Property = nullptr;\n\n    /// Used to find the proper base profile for a given base expression.\n    static BaseInfoTy getBaseInfo(const Expr *BaseE);\n\n    inline WeakObjectProfileTy();\n    static inline WeakObjectProfileTy getSentinel();\n\n  public:\n    WeakObjectProfileTy(const ObjCPropertyRefExpr *RE);\n    WeakObjectProfileTy(const Expr *Base, const ObjCPropertyDecl *Property);\n    WeakObjectProfileTy(const DeclRefExpr *RE);\n    WeakObjectProfileTy(const ObjCIvarRefExpr *RE);\n\n    const NamedDecl *getBase() const { return Base.getPointer(); }\n    const NamedDecl *getProperty() const { return Property; }\n\n    /// Returns true if the object base specifies a known object in memory,\n    /// rather than, say, an instance variable or property of another object.\n    ///\n    /// Note that this ignores the effects of aliasing; that is, \\c foo.bar is\n    /// considered an exact profile if \\c foo is a local variable, even if\n    /// another variable \\c foo2 refers to the same object as \\c foo.\n    ///\n    /// For increased precision, accesses with base variables that are\n    /// properties or ivars of 'self' (e.g. self.prop1.prop2) are considered to\n    /// be exact, though this is not true for arbitrary variables\n    /// (foo.prop1.prop2).\n    bool isExactProfile() const {\n      return Base.getInt();\n    }\n\n    bool operator==(const WeakObjectProfileTy &Other) const {\n      return Base == Other.Base && Property == Other.Property;\n    }\n\n    // For use in DenseMap.\n    // We can't specialize the usual llvm::DenseMapInfo at the end of the file\n    // because by that point the DenseMap in FunctionScopeInfo has already been\n    // instantiated.\n    class DenseMapInfo {\n    public:\n      static inline WeakObjectProfileTy getEmptyKey() {\n        return WeakObjectProfileTy();\n      }\n\n      static inline WeakObjectProfileTy getTombstoneKey() {\n        return WeakObjectProfileTy::getSentinel();\n      }\n\n      static unsigned getHashValue(const WeakObjectProfileTy &Val) {\n        using Pair = std::pair<BaseInfoTy, const NamedDecl *>;\n\n        return llvm::DenseMapInfo<Pair>::getHashValue(Pair(Val.Base,\n                                                           Val.Property));\n      }\n\n      static bool isEqual(const WeakObjectProfileTy &LHS,\n                          const WeakObjectProfileTy &RHS) {\n        return LHS == RHS;\n      }\n    };\n  }",
  "id": "BLOCK-CPP-20300",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ScopeInfo.h",
  "source_line": 265,
  "validation_status": "validated"
}