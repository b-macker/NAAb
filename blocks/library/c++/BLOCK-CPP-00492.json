{
  "code": "#include <spdlog/common.h>\n#include <spdlog/details/null_mutex.h>\n#include <spdlog/sinks/base_sink.h>\n    #include <spdlog/details/tcp_client-windows.h>\n    #include <spdlog/details/tcp_client.h>\n#include <chrono>\n#include <functional>\n#include <mutex>\n#include <string>\n\nusing namespace spdlog;\nusing namespace sinks;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00492_execute() {\n    {\n\nstruct tcp_sink_config {\n    std::string server_host;\n    int server_port;\n    bool lazy_connect = false;  // if true connect on first log call instead of on construction\n\n    tcp_sink_config(std::string host, int port)\n        : server_host{std::move(host)},\n          server_port{port} {}\n};\n\ntemplate <typename Mutex>\nclass tcp_sink : public spdlog::sinks::base_sink<Mutex> {\npublic:\n    // connect to tcp host/port or throw if failed\n    // host can be hostname or ip address\n\n    explicit tcp_sink(tcp_sink_config sink_config)\n        : config_{std::move(sink_config)} {\n        if (!config_.lazy_connect) {\n            this->client_.connect(config_.server_host, config_.server_port);\n        }\n    }\n\n    ~tcp_sink() override = default;\n\nprotected:\n    void sink_it_(const spdlog::details::log_msg &msg) override {\n        spdlog::memory_buf_t formatted;\n        spdlog::sinks::base_sink<Mutex>::formatter_->format(msg, formatted);\n        if (!client_.is_connected()) {\n            client_.connect(config_.server_host, config_.server_port);\n        }\n        client_.send(formatted.data(), formatted.size());\n    }\n\n    void flush_() override {}\n    tcp_sink_config config_;\n    details::tcp_client client_;\n};\n\nusing tcp_sink_mt = tcp_sink<std::mutex>;\nusing tcp_sink_st = tcp_sink<spdlog::details::null_mutex>;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00492",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/tcp_sink.h",
  "source_line": 29,
  "validation_status": "validated"
}