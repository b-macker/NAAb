{
  "code": "{\n public:\n  struct MemcpyPolicy {};\n  struct ElementwiseAssignPolicy {};\n  struct ElementwiseSwapPolicy {};\n  struct ElementwiseConstructPolicy {};\n\n  using MoveAssignmentPolicy = absl::conditional_t<\n      // Fast path: if the value type can be trivially move assigned and\n      // destroyed, and we know the allocator doesn't do anything fancy, then\n      // it's safe for us to simply adopt the contents of the storage for\n      // `other` and remove its own reference to them. It's as if we had\n      // individually move-assigned each value and then destroyed the original.\n      absl::conjunction<absl::is_trivially_move_assignable<ValueType<A>>,\n                        absl::is_trivially_destructible<ValueType<A>>,\n                        std::is_same<A, std::allocator<ValueType<A>>>>::value,\n      MemcpyPolicy,\n      // Otherwise we use move assignment if possible. If not, we simulate\n      // move assignment using move construction.\n      //\n      // Note that this is in contrast to e.g. std::vector and std::optional,\n      // which are themselves not move-assignable when their contained type is\n      // not.\n      absl::conditional_t<IsMoveAssignOk<A>::value, ElementwiseAssignPolicy,\n                          ElementwiseConstructPolicy>>;\n\n  // The policy to be used specifically when swapping inlined elements.\n  using SwapInlinedElementsPolicy = absl::conditional_t<\n      // Fast path: if the value type can be trivially move constructed/assigned\n      // and destroyed, and we know the allocator doesn't do anything fancy,\n      // then it's safe for us to simply swap the bytes in the inline storage.\n      // It's as if we had move-constructed a temporary vector, move-assigned\n      // one to the other, then move-assigned the first from the temporary.\n      absl::conjunction<absl::is_trivially_move_constructible<ValueType<A>>,\n                        absl::is_trivially_move_assignable<ValueType<A>>,\n                        absl::is_trivially_destructible<ValueType<A>>,\n                        std::is_same<A, std::allocator<ValueType<A>>>>::value,\n      MemcpyPolicy,\n      absl::conditional_t<IsSwapOk<A>::value, ElementwiseSwapPolicy,\n                          ElementwiseConstructPolicy>>;\n\n  static SizeType<A> NextCapacity(SizeType<A> current_capacity) {\n    return current_capacity * 2;\n  }\n\n  static SizeType<A> ComputeCapacity(SizeType<A> current_capacity,\n                                     SizeType<A> requested_capacity) {\n    return (std::max)(NextCapacity(current_capacity), requested_capacity);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Storage Constructors and Destructor\n  // ---------------------------------------------------------------------------\n\n  Storage() : metadata_(A(), /* size and is_allocated */ 0u) {}\n\n  explicit Storage(const A& allocator)\n      : metadata_(allocator, /* size and is_allocated */ 0u) {}\n\n  ~Storage() {\n    // Fast path: if we are empty and not allocated, there's nothing to do.\n    if (GetSizeAndIsAllocated() == 0) {\n      return;\n    }\n\n    // Fast path: if no destructors need to be run and we know the allocator\n    // doesn't do anything fancy, then all we need to do is deallocate (and\n    // maybe not even that).\n    if (absl::is_trivially_destructible<ValueType<A>>::value &&\n        std::is_same<A, std::allocator<ValueType<A>>>::value) {\n      DeallocateIfAllocated();\n      return;\n    }\n\n    DestroyContents();\n  }\n\n  // ---------------------------------------------------------------------------\n  // Storage Member Accessors\n  // ---------------------------------------------------------------------------\n\n  SizeType<A>& GetSizeAndIsAllocated() { return metadata_.template get<1>(); }\n\n  const SizeType<A>& GetSizeAndIsAllocated() const {\n    return metadata_.template get<1>();\n  }\n\n  SizeType<A> GetSize() const { return GetSizeAndIsAllocated() >> 1; }\n\n  bool GetIsAllocated() const { return GetSizeAndIsAllocated() & 1; }\n\n  Pointer<A> GetAllocatedData() {\n    // GCC 12 has a false-positive -Wmaybe-uninitialized warning here.\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n    return data_.allocated.allocated_data;\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)\n#pragma GCC diagnostic pop\n#endif\n  }\n\n  ConstPointer<A> GetAllocatedData() const {\n    return data_.allocated.allocated_data;\n  }\n\n  // ABSL_ATTRIBUTE_NO_SANITIZE_CFI is used because the memory pointed to may be\n  // uninitialized, a common pattern in allocate()+construct() APIs.\n  // https://clang.llvm.org/docs/ControlFlowIntegrity.html#bad-cast-checking\n  // NOTE: When this was written, LLVM documentation did not explicitly\n  // mention that casting `char*` and using `reinterpret_cast` qualifies\n  // as a bad cast.\n  ABSL_ATTRIBUTE_NO_SANITIZE_CFI Pointer<A> GetInlinedData() {\n    return reinterpret_cast<Pointer<A>>(data_.inlined.inlined_data);\n  }\n\n  ABSL_ATTRIBUTE_NO_SANITIZE_CFI ConstPointer<A> GetInlinedData() const {\n    return reinterpret_cast<ConstPointer<A>>(data_.inlined.inlined_data);\n  }\n\n  SizeType<A> GetAllocatedCapacity() const {\n    return data_.allocated.allocated_capacity;\n  }\n\n  SizeType<A> GetInlinedCapacity() const {\n    return static_cast<SizeType<A>>(kOptimalInlinedSize);\n  }\n\n  StorageView<A> MakeStorageView() {\n    return GetIsAllocated() ? StorageView<A>{GetAllocatedData(), GetSize(),\n                                             GetAllocatedCapacity()}\n                            : StorageView<A>{GetInlinedData(), GetSize(),\n                                             GetInlinedCapacity()};\n  }\n\n  A& GetAllocator() { return metadata_.template get<0>(); }\n\n  const A& GetAllocator() const { return metadata_.template get<0>(); }\n\n  // ---------------------------------------------------------------------------\n  // Storage Member Mutators\n  // ---------------------------------------------------------------------------\n\n  ABSL_ATTRIBUTE_NOINLINE void InitFrom(const Storage& other);\n\n  template <typename ValueAdapter>\n  void Initialize(ValueAdapter values, SizeType<A> new_size);\n\n  template <typename ValueAdapter>\n  void Assign(ValueAdapter values, SizeType<A> new_size);\n\n  template <typename ValueAdapter>\n  void Resize(ValueAdapter values, SizeType<A> new_size);\n\n  template <typename ValueAdapter>\n  Iterator<A> Insert(ConstIterator<A> pos, ValueAdapter values,\n                     SizeType<A> insert_count);\n\n  template <typename... Args>\n  Reference<A> EmplaceBack(Args&&... args);\n\n  Iterator<A> Erase(ConstIterator<A> from, ConstIterator<A> to);\n\n  void Reserve(SizeType<A> requested_capacity);\n\n  void ShrinkToFit();\n\n  void Swap(Storage* other_storage_ptr);\n\n  void SetIsAllocated() {\n    GetSizeAndIsAllocated() |= static_cast<SizeType<A>>(1);\n  }\n\n  void UnsetIsAllocated() {\n    GetSizeAndIsAllocated() &= ((std::numeric_limits<SizeType<A>>::max)() - 1);\n  }\n\n  void SetSize(SizeType<A> size) {\n    GetSizeAndIsAllocated() =\n        (size << 1) | static_cast<SizeType<A>>(GetIsAllocated());\n  }\n\n  void SetAllocatedSize(SizeType<A> size) {\n    GetSizeAndIsAllocated() = (size << 1) | static_cast<SizeType<A>>(1);\n  }\n\n  void SetInlinedSize(SizeType<A> size) {\n    GetSizeAndIsAllocated() = size << static_cast<SizeType<A>>(1);\n  }\n\n  void AddSize(SizeType<A> count) {\n    GetSizeAndIsAllocated() += count << static_cast<SizeType<A>>(1);\n  }\n\n  void SubtractSize(SizeType<A> count) {\n    ABSL_HARDENING_ASSERT(count <= GetSize());\n\n    GetSizeAndIsAllocated() -= count << static_cast<SizeType<A>>(1);\n  }\n\n  void SetAllocation(Allocation<A> allocation) {\n    data_.allocated.allocated_data = allocation.data;\n    data_.allocated.allocated_capacity = allocation.capacity;\n  }\n\n  void MemcpyFrom(const Storage& other_storage) {\n    // Assumption check: it doesn't make sense to memcpy inlined elements unless\n    // we know the allocator doesn't do anything fancy, and one of the following\n    // holds:\n    //\n    //  *  The elements are trivially relocatable.\n    //\n    //  *  It's possible to trivially assign the elements and then destroy the\n    //     source.\n    //\n    //  *  It's possible to trivially copy construct/assign the elements.\n    //\n    {\n      using V = ValueType<A>;\n      ABSL_HARDENING_ASSERT(\n          other_storage.GetIsAllocated() ||\n          (std::is_same<A, std::allocator<V>>::value &&\n           (\n               // First case above\n               absl::is_trivially_relocatable<V>::value ||\n               // Second case above\n               (absl::is_trivially_move_assignable<V>::value &&\n                absl::is_trivially_destructible<V>::value) ||\n               // Third case above\n               (absl::is_trivially_copy_constructible<V>::value ||\n                absl::is_trivially_copy_assignable<V>::value))));\n    }\n\n    GetSizeAndIsAllocated() = other_storage.GetSizeAndIsAllocated();\n    data_ = other_storage.data_;\n  }\n\n  void DeallocateIfAllocated() {\n    if (GetIsAllocated()) {\n      MallocAdapter<A>::Deallocate(GetAllocator(), GetAllocatedData(),\n                                   GetAllocatedCapacity());\n    }\n  }\n\n private:\n  ABSL_ATTRIBUTE_NOINLINE void DestroyContents();\n\n  using Metadata = container_internal::CompressedTuple<A, SizeType<A>>;\n\n  struct Allocated {\n    Pointer<A> allocated_data;\n    SizeType<A> allocated_capacity;\n  };\n\n  // `kOptimalInlinedSize` is an automatically adjusted inlined capacity of the\n  // `InlinedVector`. Sometimes, it is possible to increase the capacity (from\n  // the user requested `N`) without increasing the size of the `InlinedVector`.\n  static constexpr size_t kOptimalInlinedSize =\n      (std::max)(N, sizeof(Allocated) / sizeof(ValueType<A>));\n\n  struct Inlined {\n    alignas(ValueType<A>) char inlined_data[sizeof(\n        ValueType<A>[kOptimalInlinedSize])];\n  };\n\n  union Data {\n    Allocated allocated;\n    Inlined inlined;\n  };\n\n  void SwapN(ElementwiseSwapPolicy, Storage* other, SizeType<A> n);\n  void SwapN(ElementwiseConstructPolicy, Storage* other, SizeType<A> n);\n\n  void SwapInlinedElements(MemcpyPolicy, Storage* other);\n  template <typename NotMemcpyPolicy>\n  void SwapInlinedElements(NotMemcpyPolicy, Storage* other);\n\n  template <typename... Args>\n  ABSL_ATTRIBUTE_NOINLINE Reference<A> EmplaceBackSlow(Args&&... args);\n\n  Metadata metadata_;\n  Data data_;\n}",
  "id": "BLOCK-CPP-05091",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/inlined_vector.h",
  "source_line": 296,
  "validation_status": "validated"
}