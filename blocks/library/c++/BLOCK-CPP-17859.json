{
  "code": "#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Driver/Types.h\"\n#include \"llvm/Option/Arg.h\"\n#include \"llvm/Option/ArgList.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n#include <string>\n#include <vector>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17859_execute() {\n    {\nnamespace driver {\n\nclass ToolChain;\n\nclass SanitizerArgs {\n  SanitizerSet Sanitizers;\n  SanitizerSet RecoverableSanitizers;\n  SanitizerSet TrapSanitizers;\n\n  std::vector<std::string> UserIgnorelistFiles;\n  std::vector<std::string> SystemIgnorelistFiles;\n  std::vector<std::string> CoverageAllowlistFiles;\n  std::vector<std::string> CoverageIgnorelistFiles;\n  std::vector<std::string> BinaryMetadataIgnorelistFiles;\n  int CoverageFeatures = 0;\n  int BinaryMetadataFeatures = 0;\n  int MsanTrackOrigins = 0;\n  bool MsanUseAfterDtor = true;\n  bool MsanParamRetval = true;\n  bool CfiCrossDso = false;\n  bool CfiICallGeneralizePointers = false;\n  bool CfiICallNormalizeIntegers = false;\n  bool CfiCanonicalJumpTables = false;\n  int AsanFieldPadding = 0;\n  bool SharedRuntime = false;\n  bool StableABI = false;\n  bool AsanUseAfterScope = true;\n  bool AsanPoisonCustomArrayCookie = false;\n  bool AsanGlobalsDeadStripping = false;\n  bool AsanUseOdrIndicator = false;\n  bool AsanInvalidPointerCmp = false;\n  bool AsanInvalidPointerSub = false;\n  bool AsanOutlineInstrumentation = false;\n  llvm::AsanDtorKind AsanDtorKind = llvm::AsanDtorKind::Invalid;\n  std::string HwasanAbi;\n  bool LinkRuntimes = true;\n  bool LinkCXXRuntimes = false;\n  bool NeedPIE = false;\n  bool SafeStackRuntime = false;\n  bool Stats = false;\n  bool TsanMemoryAccess = true;\n  bool TsanFuncEntryExit = true;\n  bool TsanAtomics = true;\n  bool MinimalRuntime = false;\n  // True if cross-dso CFI support if provided by the system (i.e. Android).\n  bool ImplicitCfiRuntime = false;\n  bool NeedsMemProfRt = false;\n  bool HwasanUseAliases = false;\n  llvm::AsanDetectStackUseAfterReturnMode AsanUseAfterReturn =\n      llvm::AsanDetectStackUseAfterReturnMode::Invalid;\n\n  std::string MemtagMode;\n\npublic:\n  /// Parses the sanitizer arguments from an argument list.\n  SanitizerArgs(const ToolChain &TC, const llvm::opt::ArgList &Args,\n                bool DiagnoseErrors = true);\n\n  bool needsSharedRt() const { return SharedRuntime; }\n\n  bool needsMemProfRt() const { return NeedsMemProfRt; }\n  bool needsAsanRt() const { return Sanitizers.has(SanitizerKind::Address); }\n  bool needsHwasanRt() const {\n    return Sanitizers.has(SanitizerKind::HWAddress);\n  }\n  bool needsHwasanAliasesRt() const {\n    return needsHwasanRt() && HwasanUseAliases;\n  }\n  bool needsTsanRt() const { return Sanitizers.has(SanitizerKind::Thread); }\n  bool needsMsanRt() const { return Sanitizers.has(SanitizerKind::Memory); }\n  bool needsFuzzer() const { return Sanitizers.has(SanitizerKind::Fuzzer); }\n  bool needsLsanRt() const {\n    return Sanitizers.has(SanitizerKind::Leak) &&\n           !Sanitizers.has(SanitizerKind::Address) &&\n           !Sanitizers.has(SanitizerKind::HWAddress);\n  }\n  bool needsFuzzerInterceptors() const;\n  bool needsUbsanRt() const;\n  bool requiresMinimalRuntime() const { return MinimalRuntime; }\n  bool needsDfsanRt() const { return Sanitizers.has(SanitizerKind::DataFlow); }\n  bool needsSafeStackRt() const { return SafeStackRuntime; }\n  bool needsCfiRt() const;\n  bool needsCfiDiagRt() const;\n  bool needsStatsRt() const { return Stats; }\n  bool needsScudoRt() const { return Sanitizers.has(SanitizerKind::Scudo); }\n\n  bool hasMemTag() const {\n    return hasMemtagHeap() || hasMemtagStack() || hasMemtagGlobals();\n  }\n  bool hasMemtagHeap() const {\n    return Sanitizers.has(SanitizerKind::MemtagHeap);\n  }\n  bool hasMemtagStack() const {\n    return Sanitizers.has(SanitizerKind::MemtagStack);\n  }\n  bool hasMemtagGlobals() const {\n    return Sanitizers.has(SanitizerKind::MemtagGlobals);\n  }\n  const std::string &getMemtagMode() const {\n    assert(!MemtagMode.empty());\n    return MemtagMode;\n  }\n\n  bool hasShadowCallStack() const {\n    return Sanitizers.has(SanitizerKind::ShadowCallStack);\n  }\n\n  bool requiresPIE() const;\n  bool needsUnwindTables() const;\n  bool needsLTO() const;\n  bool linkRuntimes() const { return LinkRuntimes; }\n  bool linkCXXRuntimes() const { return LinkCXXRuntimes; }\n  bool hasCrossDsoCfi() const { return CfiCrossDso; }\n  bool hasAnySanitizer() const { return !Sanitizers.empty(); }\n  void addArgs(const ToolChain &TC, const llvm::opt::ArgList &Args,\n               llvm::opt::ArgStringList &CmdArgs, types::ID InputType) const;\n};\n\n}  // namespace driver\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17859",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/SanitizerArgs.h",
  "source_line": 19,
  "validation_status": "validated"
}