{
  "code": "{\n public:\n  constexpr Flag(const char* name, const char* filename, FlagHelpArg help,\n                 const FlagDefaultArg default_arg)\n      : impl_(name, filename, &FlagOps<T>, help,\n              flags_internal::StorageKind<T>(), default_arg),\n        value_() {}\n\n  // CommandLineFlag interface\n  absl::string_view Name() const { return impl_.Name(); }\n  std::string Filename() const { return impl_.Filename(); }\n  std::string Help() const { return impl_.Help(); }\n  // Do not use. To be removed.\n  bool IsSpecifiedOnCommandLine() const {\n    return impl_.IsSpecifiedOnCommandLine();\n  }\n  std::string DefaultValue() const { return impl_.DefaultValue(); }\n  std::string CurrentValue() const { return impl_.CurrentValue(); }\n\n private:\n  template <typename, bool>\n  friend class FlagRegistrar;\n  friend class FlagImplPeer;\n\n  T Get() const {\n    // See implementation notes in CommandLineFlag::Get().\n    union U {\n      T value;\n      U() {}\n      ~U() { value.~T(); }\n    };\n    U u;\n\n#if !defined(NDEBUG)\n    impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);\n#endif\n\n    if (ABSL_PREDICT_FALSE(!value_.Get(impl_.seq_lock_, u.value))) {\n      impl_.Read(&u.value);\n    }\n    return std::move(u.value);\n  }\n  void Set(const T& v) {\n    impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);\n    impl_.Write(&v);\n  }\n\n  // Access to the reflection.\n  const CommandLineFlag& Reflect() const { return impl_; }\n\n  // Flag's data\n  // The implementation depends on value_ field to be placed exactly after the\n  // impl_ field, so that impl_ can figure out the offset to the value and\n  // access it.\n  FlagImpl impl_;\n  FlagValue<T> value_;\n}",
  "id": "BLOCK-CPP-05519",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/internal/flag.h",
  "source_line": 632,
  "validation_status": "validated"
}