{
  "code": "{\n\n// Various helper functions on til::SExpr\nnamespace sx {\n\ninline bool equals(const til::SExpr *E1, const til::SExpr *E2) {\n  return til::EqualsComparator::compareExprs(E1, E2);\n}\n\ninline bool matches(const til::SExpr *E1, const til::SExpr *E2) {\n  // We treat a top-level wildcard as the \"univsersal\" lock.\n  // It matches everything for the purpose of checking locks, but not\n  // for unlocking them.\n  if (isa<til::Wildcard>(E1))\n    return isa<til::Wildcard>(E2);\n  if (isa<til::Wildcard>(E2))\n    return isa<til::Wildcard>(E1);\n\n  return til::MatchComparator::compareExprs(E1, E2);\n}\n\ninline bool partiallyMatches(const til::SExpr *E1, const til::SExpr *E2) {\n  const auto *PE1 = dyn_cast_or_null<til::Project>(E1);\n  if (!PE1)\n    return false;\n  const auto *PE2 = dyn_cast_or_null<til::Project>(E2);\n  if (!PE2)\n    return false;\n  return PE1->clangDecl() == PE2->clangDecl();\n}\n\ninline std::string toString(const til::SExpr *E) {\n  std::stringstream ss;\n  til::StdPrinter::print(E, ss);\n  return ss.str();\n}\n\n}  // namespace sx\n\n// This class defines the interface of a clang CFG Visitor.\n// CFGWalker will invoke the following methods.\n// Note that methods are not virtual; the visitor is templatized.\nclass CFGVisitor {\n  // Enter the CFG for Decl D, and perform any initial setup operations.\n  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First) {}\n\n  // Enter a CFGBlock.\n  void enterCFGBlock(const CFGBlock *B) {}\n\n  // Returns true if this visitor implements handlePredecessor\n  bool visitPredecessors() { return true; }\n\n  // Process a predecessor edge.\n  void handlePredecessor(const CFGBlock *Pred) {}\n\n  // Process a successor back edge to a previously visited block.\n  void handlePredecessorBackEdge(const CFGBlock *Pred) {}\n\n  // Called just before processing statements.\n  void enterCFGBlockBody(const CFGBlock *B) {}\n\n  // Process an ordinary statement.\n  void handleStatement(const Stmt *S) {}\n\n  // Process a destructor call\n  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD) {}\n\n  // Called after all statements have been handled.\n  void exitCFGBlockBody(const CFGBlock *B) {}\n\n  // Return true\n  bool visitSuccessors() { return true; }\n\n  // Process a successor edge.\n  void handleSuccessor(const CFGBlock *Succ) {}\n\n  // Process a successor back edge to a previously visited block.\n  void handleSuccessorBackEdge(const CFGBlock *Succ) {}\n\n  // Leave a CFGBlock.\n  void exitCFGBlock(const CFGBlock *B) {}\n\n  // Leave the CFG, and perform any final cleanup operations.\n  void exitCFG(const CFGBlock *Last) {}\n};\n\n// Walks the clang CFG, and invokes methods on a given CFGVisitor.\nclass CFGWalker {\npublic:\n  CFGWalker() = default;\n\n  // Initialize the CFGWalker.  This setup only needs to be done once, even\n  // if there are multiple passes over the CFG.\n  bool init(AnalysisDeclContext &AC) {\n    ACtx = &AC;\n    CFGraph = AC.getCFG();\n    if (!CFGraph)\n      return false;\n\n    // Ignore anonymous functions.\n    if (!isa_and_nonnull<NamedDecl>(AC.getDecl()))\n      return false;\n\n    SortedGraph = AC.getAnalysis<PostOrderCFGView>();\n    if (!SortedGraph)\n      return false;\n\n    return true;\n  }\n\n  // Traverse the CFG, calling methods on V as appropriate.\n  template <class Visitor>\n  void walk(Visitor &V) {\n    PostOrderCFGView::CFGBlockSet VisitedBlocks(CFGraph);\n\n    V.enterCFG(CFGraph, getDecl(), &CFGraph->getEntry());\n\n    for (const auto *CurrBlock : *SortedGraph) {\n      VisitedBlocks.insert(CurrBlock);\n\n      V.enterCFGBlock(CurrBlock);\n\n      // Process predecessors, handling back edges last\n      if (V.visitPredecessors()) {\n        SmallVector<CFGBlock*, 4> BackEdges;\n        // Process successors\n        for (CFGBlock::const_pred_iterator SI = CurrBlock->pred_begin(),\n                                           SE = CurrBlock->pred_end();\n             SI != SE; ++SI) {\n          if (*SI == nullptr)\n            continue;\n\n          if (!VisitedBlocks.alreadySet(*SI)) {\n            BackEdges.push_back(*SI);\n            continue;\n          }\n          V.handlePredecessor(*SI);\n        }\n\n        for (auto *Blk : BackEdges)\n          V.handlePredecessorBackEdge(Blk);\n      }\n\n      V.enterCFGBlockBody(CurrBlock);\n\n      // Process statements\n      for (const auto &BI : *CurrBlock) {\n        switch (BI.getKind()) {\n        case CFGElement::Statement:\n          V.handleStatement(BI.castAs<CFGStmt>().getStmt());\n          break;\n\n        case CFGElement::AutomaticObjectDtor: {\n          CFGAutomaticObjDtor AD = BI.castAs<CFGAutomaticObjDtor>();\n          auto *DD = const_cast<CXXDestructorDecl *>(\n              AD.getDestructorDecl(ACtx->getASTContext()));\n          auto *VD = const_cast<VarDecl *>(AD.getVarDecl());\n          V.handleDestructorCall(VD, DD);\n          break;\n        }\n        default:\n          break;\n        }\n      }\n\n      V.exitCFGBlockBody(CurrBlock);\n\n      // Process successors, handling back edges first.\n      if (V.visitSuccessors()) {\n        SmallVector<CFGBlock*, 8> ForwardEdges;\n\n        // Process successors\n        for (CFGBlock::const_succ_iterator SI = CurrBlock->succ_begin(),\n                                           SE = CurrBlock->succ_end();\n             SI != SE; ++SI) {\n          if (*SI == nullptr)\n            continue;\n\n          if (!VisitedBlocks.alreadySet(*SI)) {\n            ForwardEdges.push_back(*SI);\n            continue;\n          }\n          V.handleSuccessorBackEdge(*SI);\n        }\n\n        for (auto *Blk : ForwardEdges)\n          V.handleSuccessor(Blk);\n      }\n\n      V.exitCFGBlock(CurrBlock);\n    }\n    V.exitCFG(&CFGraph->getExit());\n  }\n\n  const CFG *getGraph() const { return CFGraph; }\n  CFG *getGraph() { return CFGraph; }\n\n  const NamedDecl *getDecl() const {\n    return dyn_cast<NamedDecl>(ACtx->getDecl());\n  }\n\n  const PostOrderCFGView *getSortedGraph() const { return SortedGraph; }\n\nprivate:\n  CFG *CFGraph = nullptr;\n  AnalysisDeclContext *ACtx = nullptr;\n  PostOrderCFGView *SortedGraph = nullptr;\n};\n\n// TODO: move this back into ThreadSafety.cpp\n// This is specific to thread safety.  It is here because\n// translateAttrExpr needs it, but that should be moved too.\nclass CapabilityExpr {\nprivate:\n  /// The capability expression and whether it's negated.\n  llvm::PointerIntPair<const til::SExpr *, 1, bool> CapExpr;\n\n  /// The kind of capability as specified by @ref CapabilityAttr::getName.\n  StringRef CapKind;\n\npublic:\n  CapabilityExpr() : CapExpr(nullptr, false) {}\n  CapabilityExpr(const til::SExpr *E, StringRef Kind, bool Neg)\n      : CapExpr(E, Neg), CapKind(Kind) {}\n\n  // Don't allow implicitly-constructed StringRefs since we'll capture them.\n  template <typename T> CapabilityExpr(const til::SExpr *, T, bool) = delete;\n\n  const til::SExpr *sexpr() const { return CapExpr.getPointer(); }\n  StringRef getKind() const { return CapKind; }\n  bool negative() const { return CapExpr.getInt(); }\n\n  CapabilityExpr operator!() const {\n    return CapabilityExpr(CapExpr.getPointer(), CapKind, !CapExpr.getInt());\n  }\n\n  bool equals(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::equals(sexpr(), other.sexpr());\n  }\n\n  bool matches(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::matches(sexpr(), other.sexpr());\n  }\n\n  bool matchesUniv(const CapabilityExpr &CapE) const {\n    return isUniversal() || matches(CapE);\n  }\n\n  bool partiallyMatches(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::partiallyMatches(sexpr(), other.sexpr());\n  }\n\n  const ValueDecl* valueDecl() const {\n    if (negative() || sexpr() == nullptr)\n      return nullptr;\n    if (const auto *P = dyn_cast<til::Project>(sexpr()))\n      return P->clangDecl();\n    if (const auto *P = dyn_cast<til::LiteralPtr>(sexpr()))\n      return P->clangDecl();\n    return nullptr;\n  }\n\n  std::string toString() const {\n    if (negative())\n      return \"!\" + sx::toString(sexpr());\n    return sx::toString(sexpr());\n  }\n\n  bool shouldIgnore() const { return sexpr() == nullptr; }\n\n  bool isInvalid() const { return sexpr() && isa<til::Undefined>(sexpr()); }\n\n  bool isUniversal() const { return sexpr() && isa<til::Wildcard>(sexpr()); }\n};\n\n// Translate clang::Expr to til::SExpr.\nclass SExprBuilder {\npublic:\n  /// Encapsulates the lexical context of a function call.  The lexical\n  /// context includes the arguments to the call, including the implicit object\n  /// argument.  When an attribute containing a mutex expression is attached to\n  /// a method, the expression may refer to formal parameters of the method.\n  /// Actual arguments must be substituted for formal parameters to derive\n  /// the appropriate mutex expression in the lexical context where the function\n  /// is called.  PrevCtx holds the context in which the arguments themselves\n  /// should be evaluated; multiple calling contexts can be chained together\n  /// by the lock_returned attribute.\n  struct CallingContext {\n    // The previous context; or 0 if none.\n    CallingContext  *Prev;\n\n    // The decl to which the attr is attached.\n    const NamedDecl *AttrDecl;\n\n    // Implicit object argument -- e.g. 'this'\n    llvm::PointerUnion<const Expr *, til::SExpr *> SelfArg = nullptr;\n\n    // Number of funArgs\n    unsigned NumArgs = 0;\n\n    // Function arguments\n    const Expr *const *FunArgs = nullptr;\n\n    // is Self referred to with -> or .?\n    bool SelfArrow = false;\n\n    CallingContext(CallingContext *P, const NamedDecl *D = nullptr)\n        : Prev(P), AttrDecl(D) {}\n  };\n\n  SExprBuilder(til::MemRegionRef A) : Arena(A) {\n    // FIXME: we don't always have a self-variable.\n    SelfVar = new (Arena) til::Variable(nullptr);\n    SelfVar->setKind(til::Variable::VK_SFun);\n  }\n\n  // Translate a clang expression in an attribute to a til::SExpr.\n  // Constructs the context from D, DeclExp, and SelfDecl.\n  CapabilityExpr translateAttrExpr(const Expr *AttrExp, const NamedDecl *D,\n                                   const Expr *DeclExp,\n                                   til::SExpr *Self = nullptr);\n\n  CapabilityExpr translateAttrExpr(const Expr *AttrExp, CallingContext *Ctx);\n\n  // Translate a variable reference.\n  til::LiteralPtr *createVariable(const VarDecl *VD);\n\n  // Create placeholder for this: we don't know the VarDecl on construction yet.\n  std::pair<til::LiteralPtr *, StringRef>\n  createThisPlaceholder(const Expr *Exp);\n\n  // Translate a clang statement or expression to a TIL expression.\n  // Also performs substitution of variables; Ctx provides the context.\n  // Dispatches on the type of S.\n  til::SExpr *translate(const Stmt *S, CallingContext *Ctx);\n  til::SCFG  *buildCFG(CFGWalker &Walker);\n\n  til::SExpr *lookupStmt(const Stmt *S);\n\n  til::BasicBlock *lookupBlock(const CFGBlock *B) {\n    return BlockMap[B->getBlockID()];\n  }\n\n  const til::SCFG *getCFG() const { return Scfg; }\n  til::SCFG *getCFG() { return Scfg; }\n\nprivate:\n  // We implement the CFGVisitor API\n  friend class CFGWalker;\n\n  til::SExpr *translateDeclRefExpr(const DeclRefExpr *DRE,\n                                   CallingContext *Ctx) ;\n  til::SExpr *translateCXXThisExpr(const CXXThisExpr *TE, CallingContext *Ctx);\n  til::SExpr *translateMemberExpr(const MemberExpr *ME, CallingContext *Ctx);\n  til::SExpr *translateObjCIVarRefExpr(const ObjCIvarRefExpr *IVRE,\n                                       CallingContext *Ctx);\n  til::SExpr *translateCallExpr(const CallExpr *CE, CallingContext *Ctx,\n                                const Expr *SelfE = nullptr);\n  til::SExpr *translateCXXMemberCallExpr(const CXXMemberCallExpr *ME,\n                                         CallingContext *Ctx);\n  til::SExpr *translateCXXOperatorCallExpr(const CXXOperatorCallExpr *OCE,\n                                           CallingContext *Ctx);\n  til::SExpr *translateUnaryOperator(const UnaryOperator *UO,\n                                     CallingContext *Ctx);\n  til::SExpr *translateBinOp(til::TIL_BinaryOpcode Op,\n                             const BinaryOperator *BO,\n                             CallingContext *Ctx, bool Reverse = false);\n  til::SExpr *translateBinAssign(til::TIL_BinaryOpcode Op,\n                                 const BinaryOperator *BO,\n                                 CallingContext *Ctx, bool Assign = false);\n  til::SExpr *translateBinaryOperator(const BinaryOperator *BO,\n                                      CallingContext *Ctx);\n  til::SExpr *translateCastExpr(const CastExpr *CE, CallingContext *Ctx);\n  til::SExpr *translateArraySubscriptExpr(const ArraySubscriptExpr *E,\n                                          CallingContext *Ctx);\n  til::SExpr *translateAbstractConditionalOperator(\n      const AbstractConditionalOperator *C, CallingContext *Ctx);\n\n  til::SExpr *translateDeclStmt(const DeclStmt *S, CallingContext *Ctx);\n\n  // Map from statements in the clang CFG to SExprs in the til::SCFG.\n  using StatementMap = llvm::DenseMap<const Stmt *, til::SExpr *>;\n\n  // Map from clang local variables to indices in a LVarDefinitionMap.\n  using LVarIndexMap = llvm::DenseMap<const ValueDecl *, unsigned>;\n\n  // Map from local variable indices to SSA variables (or constants).\n  using NameVarPair = std::pair<const ValueDecl *, til::SExpr *>;\n  using LVarDefinitionMap = CopyOnWriteVector<NameVarPair>;\n\n  struct BlockInfo {\n    LVarDefinitionMap ExitMap;\n    bool HasBackEdges = false;\n\n    // Successors yet to be processed\n    unsigned UnprocessedSuccessors = 0;\n\n    // Predecessors already processed\n    unsigned ProcessedPredecessors = 0;\n\n    BlockInfo() = default;\n    BlockInfo(BlockInfo &&) = default;\n    BlockInfo &operator=(BlockInfo &&) = default;\n  };\n\n  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First);\n  void enterCFGBlock(const CFGBlock *B);\n  bool visitPredecessors() { return true; }\n  void handlePredecessor(const CFGBlock *Pred);\n  void handlePredecessorBackEdge(const CFGBlock *Pred);\n  void enterCFGBlockBody(const CFGBlock *B);\n  void handleStatement(const Stmt *S);\n  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD);\n  void exitCFGBlockBody(const CFGBlock *B);\n  bool visitSuccessors() { return true; }\n  void handleSuccessor(const CFGBlock *Succ);\n  void handleSuccessorBackEdge(const CFGBlock *Succ);\n  void exitCFGBlock(const CFGBlock *B);\n  void exitCFG(const CFGBlock *Last);\n\n  void insertStmt(const Stmt *S, til::SExpr *E) {\n    SMap.insert(std::make_pair(S, E));\n  }\n\n  til::SExpr *addStatement(til::SExpr *E, const Stmt *S,\n                           const ValueDecl *VD = nullptr);\n  til::SExpr *lookupVarDecl(const ValueDecl *VD);\n  til::SExpr *addVarDecl(const ValueDecl *VD, til::SExpr *E);\n  til::SExpr *updateVarDecl(const ValueDecl *VD, til::SExpr *E);\n\n  void makePhiNodeVar(unsigned i, unsigned NPreds, til::SExpr *E);\n  void mergeEntryMap(LVarDefinitionMap Map);\n  void mergeEntryMapBackEdge();\n  void mergePhiNodesBackEdge(const CFGBlock *Blk);\n\nprivate:\n  // Set to true when parsing capability expressions, which get translated\n  // inaccurately in order to hack around smart pointers etc.\n  static const bool CapabilityExprMode = true;\n\n  til::MemRegionRef Arena;\n\n  // Variable to use for 'this'.  May be null.\n  til::Variable *SelfVar = nullptr;\n\n  til::SCFG *Scfg = nullptr;\n\n  // Map from Stmt to TIL Variables\n  StatementMap SMap;\n\n  // Indices of clang local vars.\n  LVarIndexMap LVarIdxMap;\n\n  // Map from clang to til BBs.\n  std::vector<til::BasicBlock *> BlockMap;\n\n  // Extra information per BB. Indexed by clang BlockID.\n  std::vector<BlockInfo> BBInfo;\n\n  LVarDefinitionMap CurrentLVarMap;\n  std::vector<til::Phi *> CurrentArguments;\n  std::vector<til::SExpr *> CurrentInstructions;\n  std::vector<til::Phi *> IncompleteArgs;\n  til::BasicBlock *CurrentBB = nullptr;\n  BlockInfo *CurrentBlockInfo = nullptr;\n};\n\n// Dump an SCFG to llvm::errs().\nvoid printSCFG(CFGWalker &Walker);\n\n}",
  "id": "BLOCK-CPP-21464",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h",
  "source_line": 60,
  "validation_status": "validated"
}