{
  "code": "{\n\nclass CXXBaseSpecifier;\nclass CXXCtorInitializer;\nclass Decl;\nclass Expr;\nclass ParsedTemplateArgument;\nclass QualType;\nclass Stmt;\nclass TemplateName;\nclass TemplateParameterList;\n\n  /// Wrapper for void* pointer.\n  /// \\tparam PtrTy Either a pointer type like 'T*' or a type that behaves like\n  ///               a pointer.\n  ///\n  /// This is a very simple POD type that wraps a pointer that the Parser\n  /// doesn't know about but that Sema or another client does.  The PtrTy\n  /// template argument is used to make sure that \"Decl\" pointers are not\n  /// compatible with \"Type\" pointers for example.\n  template <class PtrTy>\n  class OpaquePtr {\n    void *Ptr = nullptr;\n\n    explicit OpaquePtr(void *Ptr) : Ptr(Ptr) {}\n\n    using Traits = llvm::PointerLikeTypeTraits<PtrTy>;\n\n  public:\n    OpaquePtr(std::nullptr_t = nullptr) {}\n\n    static OpaquePtr make(PtrTy P) { OpaquePtr OP; OP.set(P); return OP; }\n\n    /// Returns plain pointer to the entity pointed by this wrapper.\n    /// \\tparam PointeeT Type of pointed entity.\n    ///\n    /// It is identical to getPtrAs<PointeeT*>.\n    template <typename PointeeT> PointeeT* getPtrTo() const {\n      return get();\n    }\n\n    /// Returns pointer converted to the specified type.\n    /// \\tparam PtrT Result pointer type.  There must be implicit conversion\n    ///              from PtrTy to PtrT.\n    ///\n    /// In contrast to getPtrTo, this method allows the return type to be\n    /// a smart pointer.\n    template <typename PtrT> PtrT getPtrAs() const {\n      return get();\n    }\n\n    PtrTy get() const {\n      return Traits::getFromVoidPointer(Ptr);\n    }\n\n    void set(PtrTy P) {\n      Ptr = Traits::getAsVoidPointer(P);\n    }\n\n    explicit operator bool() const { return Ptr != nullptr; }\n\n    void *getAsOpaquePtr() const { return Ptr; }\n    static OpaquePtr getFromOpaquePtr(void *P) { return OpaquePtr(P); }\n  };\n\n  /// UnionOpaquePtr - A version of OpaquePtr suitable for membership\n  /// in a union.\n  template <class T> struct UnionOpaquePtr {\n    void *Ptr;\n\n    static UnionOpaquePtr make(OpaquePtr<T> P) {\n      UnionOpaquePtr OP = { P.getAsOpaquePtr() };\n      return OP;\n    }\n\n    OpaquePtr<T> get() const { return OpaquePtr<T>::getFromOpaquePtr(Ptr); }\n    operator OpaquePtr<T>() const { return get(); }\n\n    UnionOpaquePtr &operator=(OpaquePtr<T> P) {\n      Ptr = P.getAsOpaquePtr();\n      return *this;\n    }\n  };\n\n}",
  "id": "BLOCK-CPP-20088",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Ownership.h",
  "source_line": 29,
  "validation_status": "validated"
}