{
  "code": "{\n  uint64_t value;\n  uint8_t width;\n  char fill;\n\n  template <typename Int>\n  explicit Hex(\n      Int v, PadSpec spec = absl::kNoPad,\n      typename std::enable_if<sizeof(Int) == 1 &&\n                              !std::is_pointer<Int>::value>::type* = nullptr)\n      : Hex(spec, static_cast<uint8_t>(v)) {}\n  template <typename Int>\n  explicit Hex(\n      Int v, PadSpec spec = absl::kNoPad,\n      typename std::enable_if<sizeof(Int) == 2 &&\n                              !std::is_pointer<Int>::value>::type* = nullptr)\n      : Hex(spec, static_cast<uint16_t>(v)) {}\n  template <typename Int>\n  explicit Hex(\n      Int v, PadSpec spec = absl::kNoPad,\n      typename std::enable_if<sizeof(Int) == 4 &&\n                              !std::is_pointer<Int>::value>::type* = nullptr)\n      : Hex(spec, static_cast<uint32_t>(v)) {}\n  template <typename Int>\n  explicit Hex(\n      Int v, PadSpec spec = absl::kNoPad,\n      typename std::enable_if<sizeof(Int) == 8 &&\n                              !std::is_pointer<Int>::value>::type* = nullptr)\n      : Hex(spec, static_cast<uint64_t>(v)) {}\n  template <typename Pointee>\n  explicit Hex(absl::Nullable<Pointee*> v, PadSpec spec = absl::kNoPad)\n      : Hex(spec, reinterpret_cast<uintptr_t>(v)) {}\n\n  template <typename S>\n  friend void AbslStringify(S& sink, Hex hex) {\n    static_assert(\n        numbers_internal::kFastToBufferSize >= 32,\n        \"This function only works when output buffer >= 32 bytes long\");\n    char buffer[numbers_internal::kFastToBufferSize];\n    char* const end = &buffer[numbers_internal::kFastToBufferSize];\n    auto real_width =\n        absl::numbers_internal::FastHexToBufferZeroPad16(hex.value, end - 16);\n    if (real_width >= hex.width) {\n      sink.Append(absl::string_view(end - real_width, real_width));\n    } else {\n      // Pad first 16 chars because FastHexToBufferZeroPad16 pads only to 16 and\n      // max pad width can be up to 20.\n      std::memset(end - 32, hex.fill, 16);\n      // Patch up everything else up to the real_width.\n      std::memset(end - real_width - 16, hex.fill, 16);\n      sink.Append(absl::string_view(end - hex.width, hex.width));\n    }\n  }\n\n private:\n  Hex(PadSpec spec, uint64_t v)\n      : value(v),\n        width(spec == absl::kNoPad\n                  ? 1\n                  : spec >= absl::kSpacePad2 ? spec - absl::kSpacePad2 + 2\n                                             : spec - absl::kZeroPad2 + 2),\n        fill(spec >= absl::kSpacePad2 ? ' ' : '0') {}\n}",
  "id": "BLOCK-CPP-04120",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.h",
  "source_line": 179,
  "validation_status": "validated"
}