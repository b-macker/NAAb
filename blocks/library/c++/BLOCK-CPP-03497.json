{
  "code": "{\n  static_assert(!std::is_array<T>::value || std::extent<T>::value > 0,\n                \"Arrays with unknown bounds cannot be used with FixedArray.\");\n\n  static constexpr size_t kInlineBytesDefault = 256;\n\n  using AllocatorTraits = std::allocator_traits<A>;\n  // std::iterator_traits isn't guaranteed to be SFINAE-friendly until C++17,\n  // but this seems to be mostly pedantic.\n  template <typename Iterator>\n  using EnableIfForwardIterator = absl::enable_if_t<std::is_convertible<\n      typename std::iterator_traits<Iterator>::iterator_category,\n      std::forward_iterator_tag>::value>;\n  static constexpr bool NoexceptCopyable() {\n    return std::is_nothrow_copy_constructible<StorageElement>::value &&\n           absl::allocator_is_nothrow<allocator_type>::value;\n  }\n  static constexpr bool NoexceptMovable() {\n    return std::is_nothrow_move_constructible<StorageElement>::value &&\n           absl::allocator_is_nothrow<allocator_type>::value;\n  }\n  static constexpr bool DefaultConstructorIsNonTrivial() {\n    return !absl::is_trivially_default_constructible<StorageElement>::value;\n  }\n\n public:\n  using allocator_type = typename AllocatorTraits::allocator_type;\n  using value_type = typename AllocatorTraits::value_type;\n  using pointer = typename AllocatorTraits::pointer;\n  using const_pointer = typename AllocatorTraits::const_pointer;\n  using reference = value_type&;\n  using const_reference = const value_type&;\n  using size_type = typename AllocatorTraits::size_type;\n  using difference_type = typename AllocatorTraits::difference_type;\n  using iterator = pointer;\n  using const_iterator = const_pointer;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  static constexpr size_type inline_elements =\n      (N == kFixedArrayUseDefault ? kInlineBytesDefault / sizeof(value_type)\n                                  : static_cast<size_type>(N));\n\n  FixedArray(const FixedArray& other) noexcept(NoexceptCopyable())\n      : FixedArray(other,\n                   AllocatorTraits::select_on_container_copy_construction(\n                       other.storage_.alloc())) {}\n\n  FixedArray(const FixedArray& other,\n             const allocator_type& a) noexcept(NoexceptCopyable())\n      : FixedArray(other.begin(), other.end(), a) {}\n\n  FixedArray(FixedArray&& other) noexcept(NoexceptMovable())\n      : FixedArray(std::move(other), other.storage_.alloc()) {}\n\n  FixedArray(FixedArray&& other,\n             const allocator_type& a) noexcept(NoexceptMovable())\n      : FixedArray(std::make_move_iterator(other.begin()),\n                   std::make_move_iterator(other.end()), a) {}\n\n  // Creates an array object that can store `n` elements.\n  // Note that trivially constructible elements will be uninitialized.\n  explicit FixedArray(size_type n, const allocator_type& a = allocator_type())\n      : storage_(n, a) {\n    if (DefaultConstructorIsNonTrivial()) {\n      memory_internal::ConstructRange(storage_.alloc(), storage_.begin(),\n                                      storage_.end());\n    }\n  }\n\n  // Creates an array initialized with `n` copies of `val`.\n  FixedArray(size_type n, const value_type& val,\n             const allocator_type& a = allocator_type())\n      : storage_(n, a) {\n    memory_internal::ConstructRange(storage_.alloc(), storage_.begin(),\n                                    storage_.end(), val);\n  }\n\n  // Creates an array initialized with the size and contents of `init_list`.\n  FixedArray(std::initializer_list<value_type> init_list,\n             const allocator_type& a = allocator_type())\n      : FixedArray(init_list.begin(), init_list.end(), a) {}\n\n  // Creates an array initialized with the elements from the input\n  // range. The array's size will always be `std::distance(first, last)`.\n  // REQUIRES: Iterator must be a forward_iterator or better.\n  template <typename Iterator, EnableIfForwardIterator<Iterator>* = nullptr>\n  FixedArray(Iterator first, Iterator last,\n             const allocator_type& a = allocator_type())\n      : storage_(std::distance(first, last), a) {\n    memory_internal::CopyRange(storage_.alloc(), storage_.begin(), first, last);\n  }\n\n  ~FixedArray() noexcept {\n    for (auto* cur = storage_.begin(); cur != storage_.end(); ++cur) {\n      AllocatorTraits::destroy(storage_.alloc(), cur);\n    }\n  }\n\n  // Assignments are deleted because they break the invariant that the size of a\n  // `FixedArray` never changes.\n  void operator=(FixedArray&&) = delete;\n  void operator=(const FixedArray&) = delete;\n\n  // FixedArray::size()\n  //\n  // Returns the length of the fixed array.\n  size_type size() const { return storage_.size(); }\n\n  // FixedArray::max_size()\n  //\n  // Returns the largest possible value of `std::distance(begin(), end())` for a\n  // `FixedArray<T>`. This is equivalent to the most possible addressable bytes\n  // over the number of bytes taken by T.\n  constexpr size_type max_size() const {\n    return (std::numeric_limits<difference_type>::max)() / sizeof(value_type);\n  }\n\n  // FixedArray::empty()\n  //\n  // Returns whether or not the fixed array is empty.\n  bool empty() const { return size() == 0; }\n\n  // FixedArray::memsize()\n  //\n  // Returns the memory size of the fixed array in bytes.\n  size_t memsize() const { return size() * sizeof(value_type); }\n\n  // FixedArray::data()\n  //\n  // Returns a const T* pointer to elements of the `FixedArray`. This pointer\n  // can be used to access (but not modify) the contained elements.\n  const_pointer data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return AsValueType(storage_.begin());\n  }\n\n  // Overload of FixedArray::data() to return a T* pointer to elements of the\n  // fixed array. This pointer can be used to access and modify the contained\n  // elements.\n  pointer data() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return AsValueType(storage_.begin());\n  }\n\n  // FixedArray::operator[]\n  //\n  // Returns a reference the ith element of the fixed array.\n  // REQUIRES: 0 <= i < size()\n  reference operator[](size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(i < size());\n    return data()[i];\n  }\n\n  // Overload of FixedArray::operator()[] to return a const reference to the\n  // ith element of the fixed array.\n  // REQUIRES: 0 <= i < size()\n  const_reference operator[](size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(i < size());\n    return data()[i];\n  }\n\n  // FixedArray::at\n  //\n  // Bounds-checked access.  Returns a reference to the ith element of the fixed\n  // array, or throws std::out_of_range\n  reference at(size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ABSL_PREDICT_FALSE(i >= size())) {\n      base_internal::ThrowStdOutOfRange(\"FixedArray::at failed bounds check\");\n    }\n    return data()[i];\n  }\n\n  // Overload of FixedArray::at() to return a const reference to the ith element\n  // of the fixed array.\n  const_reference at(size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ABSL_PREDICT_FALSE(i >= size())) {\n      base_internal::ThrowStdOutOfRange(\"FixedArray::at failed bounds check\");\n    }\n    return data()[i];\n  }\n\n  // FixedArray::front()\n  //\n  // Returns a reference to the first element of the fixed array.\n  reference front() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[0];\n  }\n\n  // Overload of FixedArray::front() to return a reference to the first element\n  // of a fixed array of const values.\n  const_reference front() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[0];\n  }\n\n  // FixedArray::back()\n  //\n  // Returns a reference to the last element of the fixed array.\n  reference back() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[size() - 1];\n  }\n\n  // Overload of FixedArray::back() to return a reference to the last element\n  // of a fixed array of const values.\n  const_reference back() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[size() - 1];\n  }\n\n  // FixedArray::begin()\n  //\n  // Returns an iterator to the beginning of the fixed array.\n  iterator begin() ABSL_ATTRIBUTE_LIFETIME_BOUND { return data(); }\n\n  // Overload of FixedArray::begin() to return a const iterator to the\n  // beginning of the fixed array.\n  const_iterator begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND { return data(); }\n\n  // FixedArray::cbegin()\n  //\n  // Returns a const iterator to the beginning of the fixed array.\n  const_iterator cbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return begin();\n  }\n\n  // FixedArray::end()\n  //\n  // Returns an iterator to the end of the fixed array.\n  iterator end() ABSL_ATTRIBUTE_LIFETIME_BOUND { return data() + size(); }\n\n  // Overload of FixedArray::end() to return a const iterator to the end of the\n  // fixed array.\n  const_iterator end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return data() + size();\n  }\n\n  // FixedArray::cend()\n  //\n  // Returns a const iterator to the end of the fixed array.\n  const_iterator cend() const ABSL_ATTRIBUTE_LIFETIME_BOUND { return end(); }\n\n  // FixedArray::rbegin()\n  //\n  // Returns a reverse iterator from the end of the fixed array.\n  reverse_iterator rbegin() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return reverse_iterator(end());\n  }\n\n  // Overload of FixedArray::rbegin() to return a const reverse iterator from\n  // the end of the fixed array.\n  const_reverse_iterator rbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return const_reverse_iterator(end());\n  }\n\n  // FixedArray::crbegin()\n  //\n  // Returns a const reverse iterator from the end of the fixed array.\n  const_reverse_iterator crbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return rbegin();\n  }\n\n  // FixedArray::rend()\n  //\n  // Returns a reverse iterator from the beginning of the fixed array.\n  reverse_iterator rend() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return reverse_iterator(begin());\n  }\n\n  // Overload of FixedArray::rend() for returning a const reverse iterator\n  // from the beginning of the fixed array.\n  const_reverse_iterator rend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return const_reverse_iterator(begin());\n  }\n\n  // FixedArray::crend()\n  //\n  // Returns a reverse iterator from the beginning of the fixed array.\n  const_reverse_iterator crend() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return rend();\n  }\n\n  // FixedArray::fill()\n  //\n  // Assigns the given `value` to all elements in the fixed array.\n  void fill(const value_type& val) { std::fill(begin(), end(), val); }\n\n  // Relational operators. Equality operators are elementwise using\n  // `operator==`, while order operators order FixedArrays lexicographically.\n  friend bool operator==(const FixedArray& lhs, const FixedArray& rhs) {\n    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n  }\n\n  friend bool operator!=(const FixedArray& lhs, const FixedArray& rhs) {\n    return !(lhs == rhs);\n  }\n\n  friend bool operator<(const FixedArray& lhs, const FixedArray& rhs) {\n    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),\n                                        rhs.end());\n  }\n\n  friend bool operator>(const FixedArray& lhs, const FixedArray& rhs) {\n    return rhs < lhs;\n  }\n\n  friend bool operator<=(const FixedArray& lhs, const FixedArray& rhs) {\n    return !(rhs < lhs);\n  }\n\n  friend bool operator>=(const FixedArray& lhs, const FixedArray& rhs) {\n    return !(lhs < rhs);\n  }\n\n  template <typename H>\n  friend H AbslHashValue(H h, const FixedArray& v) {\n    return H::combine(H::combine_contiguous(std::move(h), v.data(), v.size()),\n                      v.size());\n  }\n\n private:\n  // StorageElement\n  //\n  // For FixedArrays with a C-style-array value_type, StorageElement is a POD\n  // wrapper struct called StorageElementWrapper that holds the value_type\n  // instance inside. This is needed for construction and destruction of the\n  // entire array regardless of how many dimensions it has. For all other cases,\n  // StorageElement is just an alias of value_type.\n  //\n  // Maintainer's Note: The simpler solution would be to simply wrap value_type\n  // in a struct whether it's an array or not. That causes some paranoid\n  // diagnostics to misfire, believing that 'data()' returns a pointer to a\n  // single element, rather than the packed array that it really is.\n  // e.g.:\n  //\n  //     FixedArray<char> buf(1);\n  //     sprintf(buf.data(), \"foo\");\n  //\n  //     error: call to int __builtin___sprintf_chk(etc...)\n  //     will always overflow destination buffer [-Werror]\n  //\n  template <typename OuterT, typename InnerT = absl::remove_extent_t<OuterT>,\n            size_t InnerN = std::extent<OuterT>::value>\n  struct StorageElementWrapper {\n    InnerT array[InnerN];\n  };\n\n  using StorageElement =\n      absl::conditional_t<std::is_array<value_type>::value,\n                          StorageElementWrapper<value_type>, value_type>;\n\n  static pointer AsValueType(pointer ptr) { return ptr; }\n  static pointer AsValueType(StorageElementWrapper<value_type>* ptr) {\n    return std::addressof(ptr->array);\n  }\n\n  static_assert(sizeof(StorageElement) == sizeof(value_type), \"\");\n  static_assert(alignof(StorageElement) == alignof(value_type), \"\");\n\n  class NonEmptyInlinedStorage {\n   public:\n    StorageElement* data() { return reinterpret_cast<StorageElement*>(buff_); }\n    void AnnotateConstruct(size_type n);\n    void AnnotateDestruct(size_type n);\n\n#ifdef ABSL_HAVE_ADDRESS_SANITIZER\n    void* RedzoneBegin() { return &redzone_begin_; }\n    void* RedzoneEnd() { return &redzone_end_ + 1; }\n#endif  // ABSL_HAVE_ADDRESS_SANITIZER\n\n   private:\n    ABSL_ADDRESS_SANITIZER_REDZONE(redzone_begin_);\n    alignas(StorageElement) char buff_[sizeof(StorageElement[inline_elements])];\n    ABSL_ADDRESS_SANITIZER_REDZONE(redzone_end_);\n  };\n\n  class EmptyInlinedStorage {\n   public:\n    StorageElement* data() { return nullptr; }\n    void AnnotateConstruct(size_type) {}\n    void AnnotateDestruct(size_type) {}\n  };\n\n  using InlinedStorage =\n      absl::conditional_t<inline_elements == 0, EmptyInlinedStorage,\n                          NonEmptyInlinedStorage>;\n\n  // Storage\n  //\n  // An instance of Storage manages the inline and out-of-line memory for\n  // instances of FixedArray. This guarantees that even when construction of\n  // individual elements fails in the FixedArray constructor body, the\n  // destructor for Storage will still be called and out-of-line memory will be\n  // properly deallocated.\n  //\n  class Storage : public InlinedStorage {\n   public:\n    Storage(size_type n, const allocator_type& a)\n        : size_alloc_(n, a), data_(InitializeData()) {}\n\n    ~Storage() noexcept {\n      if (UsingInlinedStorage(size())) {\n        InlinedStorage::AnnotateDestruct(size());\n      } else {\n        AllocatorTraits::deallocate(alloc(), AsValueType(begin()), size());\n      }\n    }\n\n    size_type size() const { return size_alloc_.template get<0>(); }\n    StorageElement* begin() const { return data_; }\n    StorageElement* end() const { return begin() + size(); }\n    allocator_type& alloc() { return size_alloc_.template get<1>(); }\n    const allocator_type& alloc() const {\n      return size_alloc_.template get<1>();\n    }\n\n   private:\n    static bool UsingInlinedStorage(size_type n) {\n      return n <= inline_elements;\n    }\n\n#ifdef ABSL_HAVE_ADDRESS_SANITIZER\n    ABSL_ATTRIBUTE_NOINLINE\n#endif  // ABSL_HAVE_ADDRESS_SANITIZER\n    StorageElement* InitializeData() {\n      if (UsingInlinedStorage(size())) {\n        InlinedStorage::AnnotateConstruct(size());\n        return InlinedStorage::data();\n      } else {\n        return reinterpret_cast<StorageElement*>(\n            AllocatorTraits::allocate(alloc(), size()));\n      }\n    }\n\n    // `CompressedTuple` takes advantage of EBCO for stateless `allocator_type`s\n    container_internal::CompressedTuple<size_type, allocator_type> size_alloc_;\n    StorageElement* data_;\n  };\n\n  Storage storage_;\n}",
  "id": "BLOCK-CPP-03497",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/fixed_array.h",
  "source_line": 77,
  "validation_status": "validated"
}