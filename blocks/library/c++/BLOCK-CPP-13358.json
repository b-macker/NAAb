{
  "code": "{\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Children of this AST node.\n  enum {\n    LOOP_STMT,\n    DISTANCE_FUNC,\n    LOOPVAR_FUNC,\n    LOOPVAR_REF,\n    LastSubStmt = LOOPVAR_REF\n  };\n\nprivate:\n  /// This AST node's children.\n  Stmt *SubStmts[LastSubStmt + 1] = {};\n\n  OMPCanonicalLoop() : Stmt(StmtClass::OMPCanonicalLoopClass) {}\n\npublic:\n  /// Create a new OMPCanonicalLoop.\n  static OMPCanonicalLoop *create(const ASTContext &Ctx, Stmt *LoopStmt,\n                                  CapturedStmt *DistanceFunc,\n                                  CapturedStmt *LoopVarFunc,\n                                  DeclRefExpr *LoopVarRef) {\n    OMPCanonicalLoop *S = new (Ctx) OMPCanonicalLoop();\n    S->setLoopStmt(LoopStmt);\n    S->setDistanceFunc(DistanceFunc);\n    S->setLoopVarFunc(LoopVarFunc);\n    S->setLoopVarRef(LoopVarRef);\n    return S;\n  }\n\n  /// Create an empty OMPCanonicalLoop for deserialization.\n  static OMPCanonicalLoop *createEmpty(const ASTContext &Ctx) {\n    return new (Ctx) OMPCanonicalLoop();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == StmtClass::OMPCanonicalLoopClass;\n  }\n\n  SourceLocation getBeginLoc() const { return getLoopStmt()->getBeginLoc(); }\n  SourceLocation getEndLoc() const { return getLoopStmt()->getEndLoc(); }\n\n  /// Return this AST node's children.\n  /// @{\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  /// @}\n\n  /// The wrapped syntactic loop statement (ForStmt or CXXForRangeStmt).\n  /// @{\n  Stmt *getLoopStmt() { return SubStmts[LOOP_STMT]; }\n  const Stmt *getLoopStmt() const { return SubStmts[LOOP_STMT]; }\n  void setLoopStmt(Stmt *S) {\n    assert((isa<ForStmt>(S) || isa<CXXForRangeStmt>(S)) &&\n           \"Canonical loop must be a for loop (range-based or otherwise)\");\n    SubStmts[LOOP_STMT] = S;\n  }\n  /// @}\n\n  /// The function that computes the number of loop iterations. Can be evaluated\n  /// before entering the loop but after the syntactical loop's init\n  /// statement(s).\n  ///\n  /// Function signature: void(LogicalTy &Result)\n  /// Any values necessary to compute the distance are captures of the closure.\n  /// @{\n  CapturedStmt *getDistanceFunc() {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  const CapturedStmt *getDistanceFunc() const {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  void setDistanceFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[DISTANCE_FUNC] = S;\n  }\n  /// @}\n\n  /// The function that computes the loop user variable from a logical iteration\n  /// counter. Can be evaluated as first statement in the loop.\n  ///\n  /// Function signature: void(LoopVarTy &Result, LogicalTy Number)\n  /// Any other values required to compute the loop user variable (such as start\n  /// value, step size) are captured by the closure. In particular, the initial\n  /// value of loop iteration variable is captured by value to be unaffected by\n  /// previous iterations.\n  /// @{\n  CapturedStmt *getLoopVarFunc() {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  const CapturedStmt *getLoopVarFunc() const {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  void setLoopVarFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[LOOPVAR_FUNC] = S;\n  }\n  /// @}\n\n  /// Reference to the loop user variable as accessed in the loop body.\n  /// @{\n  DeclRefExpr *getLoopVarRef() {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  const DeclRefExpr *getLoopVarRef() const {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  void setLoopVarRef(DeclRefExpr *E) {\n    assert(E && \"Expected non-null loop variable\");\n    SubStmts[LOOPVAR_REF] = E;\n  }\n  /// @}\n}",
  "id": "BLOCK-CPP-13358",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 142,
  "validation_status": "validated"
}