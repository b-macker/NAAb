{
  "code": "#include \"absl/debugging/internal/demangle.h\"\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <limits>\n#include <string>\n#include \"absl/base/config.h\"\n#include <cxxabi.h>\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02576_execute() {\n    {\n  ComplexityGuard guard(state);\n  if (guard.IsTooComplex()) return false;\n  if (ParseTemplateParam(state) || ParseExprPrimary(state)) {\n    return true;\n  }\n\n  ParseState copy = state->parse_state;\n\n  // Object/function call expression.\n  if (ParseTwoCharToken(state, \"cl\") && OneOrMore(ParseExpression, state) &&\n      ParseOneCharToken(state, 'E')) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Clang-specific \"cp <simple-id> <expression>* E\"\n  //   https://clang.llvm.org/doxygen/ItaniumMangle_8cpp_source.html#l04338\n  if (ParseTwoCharToken(state, \"cp\") && ParseSimpleId(state) &&\n      ZeroOrMore(ParseExpression, state) && ParseOneCharToken(state, 'E')) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Function-param expression (level 0).\n  if (ParseTwoCharToken(state, \"fp\") && Optional(ParseCVQualifiers(state)) &&\n      Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Function-param expression (level 1+).\n  if (ParseTwoCharToken(state, \"fL\") && Optional(ParseNumber(state, nullptr)) &&\n      ParseOneCharToken(state, 'p') && Optional(ParseCVQualifiers(state)) &&\n      Optional(ParseNumber(state, nullptr)) && ParseOneCharToken(state, '_')) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Parse the conversion expressions jointly to avoid re-parsing the <type> in\n  // their common prefix.  Parsed as:\n  // <expression> ::= cv <type> <conversion-args>\n  // <conversion-args> ::= _ <expression>* E\n  //                   ::= <expression>\n  //\n  // Also don't try ParseOperatorName after seeing \"cv\", since ParseOperatorName\n  // also needs to accept \"cv <type>\" in other contexts.\n  if (ParseTwoCharToken(state, \"cv\")) {\n    if (ParseType(state)) {\n      ParseState copy2 = state->parse_state;\n      if (ParseOneCharToken(state, '_') && ZeroOrMore(ParseExpression, state) &&\n          ParseOneCharToken(state, 'E')) {\n        return true;\n      }\n      state->parse_state = copy2;\n      if (ParseExpression(state)) {\n        return true;\n      }\n    }\n  } else {\n    // Parse unary, binary, and ternary operator expressions jointly, taking\n    // care not to re-parse subexpressions repeatedly. Parse like:\n    //   <expression> ::= <operator-name> <expression>\n    //                    [<one-to-two-expressions>]\n    //   <one-to-two-expressions> ::= <expression> [<expression>]\n    int arity = -1;\n    if (ParseOperatorName(state, &arity) &&\n        arity > 0 &&  // 0 arity => disabled.\n        (arity < 3 || ParseExpression(state)) &&\n        (arity < 2 || ParseExpression(state)) &&\n        (arity < 1 || ParseExpression(state))) {\n      return true;\n    }\n  }\n  state->parse_state = copy;\n\n  // sizeof type\n  if (ParseTwoCharToken(state, \"st\") && ParseType(state)) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Object and pointer member access expressions.\n  if ((ParseTwoCharToken(state, \"dt\") || ParseTwoCharToken(state, \"pt\")) &&\n      ParseExpression(state) && ParseType(state)) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Pointer-to-member access expressions.  This parses the same as a binary\n  // operator, but it's implemented separately because \"ds\" shouldn't be\n  // accepted in other contexts that parse an operator name.\n  if (ParseTwoCharToken(state, \"ds\") && ParseExpression(state) &&\n      ParseExpression(state)) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // Parameter pack expansion\n  if (ParseTwoCharToken(state, \"sp\") && ParseExpression(state)) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  return ParseUnresolvedName(state);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02576",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/demangle.cc",
  "source_line": 1673,
  "validation_status": "validated"
}