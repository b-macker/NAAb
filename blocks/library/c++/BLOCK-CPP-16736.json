{
  "code": "{\nnamespace markup {\n\nusing FIDMap = llvm::DenseMap<FileID, unsigned>;\n\ninline unsigned AddFID(FIDMap &FIDs, SmallVectorImpl<FileID> &V,\n                   FileID FID) {\n  FIDMap::iterator I = FIDs.find(FID);\n  if (I != FIDs.end())\n    return I->second;\n  unsigned NewValue = V.size();\n  FIDs[FID] = NewValue;\n  V.push_back(FID);\n  return NewValue;\n}\n\ninline unsigned AddFID(FIDMap &FIDs, SmallVectorImpl<FileID> &V,\n                   const SourceManager &SM, SourceLocation L) {\n  FileID FID = SM.getFileID(SM.getExpansionLoc(L));\n  return AddFID(FIDs, V, FID);\n}\n\ninline unsigned GetFID(const FIDMap &FIDs, FileID FID) {\n  FIDMap::const_iterator I = FIDs.find(FID);\n  assert(I != FIDs.end());\n  return I->second;\n}\n\ninline unsigned GetFID(const FIDMap &FIDs, const SourceManager &SM,\n                       SourceLocation L) {\n  FileID FID = SM.getFileID(SM.getExpansionLoc(L));\n  return GetFID(FIDs, FID);\n}\n\ninline raw_ostream &Indent(raw_ostream &o, const unsigned indent) {\n  for (unsigned i = 0; i < indent; ++i)\n    o << ' ';\n  return o;\n}\n\ninline raw_ostream &EmitPlistHeader(raw_ostream &o) {\n  static const char *PlistHeader =\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n      \"<!DOCTYPE plist PUBLIC \\\"-//Apple Computer//DTD PLIST 1.0//EN\\\" \"\n      \"\\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\"\n      \"<plist version=\\\"1.0\\\">\\n\";\n  return o << PlistHeader;\n}\n\ninline raw_ostream &EmitInteger(raw_ostream &o, int64_t value) {\n  o << \"<integer>\";\n  o << value;\n  o << \"</integer>\";\n  return o;\n}\n\ninline raw_ostream &EmitString(raw_ostream &o, StringRef s) {\n  o << \"<string>\";\n  for (StringRef::const_iterator I = s.begin(), E = s.end(); I != E; ++I) {\n    char c = *I;\n    switch (c) {\n    default:\n      o << c;\n      break;\n    case '&':\n      o << \"&amp;\";\n      break;\n    case '<':\n      o << \"&lt;\";\n      break;\n    case '>':\n      o << \"&gt;\";\n      break;\n    case '\\'':\n      o << \"&apos;\";\n      break;\n    case '\\\"':\n      o << \"&quot;\";\n      break;\n    }\n  }\n  o << \"</string>\";\n  return o;\n}\n\ninline void EmitLocation(raw_ostream &o, const SourceManager &SM,\n                         SourceLocation L, const FIDMap &FM, unsigned indent) {\n  if (L.isInvalid()) return;\n\n  FullSourceLoc Loc(SM.getExpansionLoc(L), const_cast<SourceManager &>(SM));\n\n  Indent(o, indent) << \"<dict>\\n\";\n  Indent(o, indent) << \" <key>line</key>\";\n  EmitInteger(o, Loc.getExpansionLineNumber()) << '\\n';\n  Indent(o, indent) << \" <key>col</key>\";\n  EmitInteger(o, Loc.getExpansionColumnNumber()) << '\\n';\n  Indent(o, indent) << \" <key>file</key>\";\n  EmitInteger(o, GetFID(FM, SM, Loc)) << '\\n';\n  Indent(o, indent) << \"</dict>\\n\";\n}\n\ninline void EmitRange(raw_ostream &o, const SourceManager &SM,\n                      CharSourceRange R, const FIDMap &FM, unsigned indent) {\n  if (R.isInvalid()) return;\n\n  assert(R.isCharRange() && \"cannot handle a token range\");\n  Indent(o, indent) << \"<array>\\n\";\n  EmitLocation(o, SM, R.getBegin(), FM, indent + 1);\n\n  // The \".getLocWithOffset(-1)\" emulates the behavior of an off-by-one bug\n  // in Lexer that is already fixed. It is here for backwards compatibility\n  // even though it is incorrect.\n  EmitLocation(o, SM, R.getEnd().getLocWithOffset(-1), FM, indent + 1);\n  Indent(o, indent) << \"</array>\\n\";\n}\n\n} // namespace markup\n}",
  "id": "BLOCK-CPP-16736",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/PlistSupport.h",
  "source_line": 22,
  "validation_status": "validated"
}