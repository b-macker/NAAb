{
  "code": "{\n\nnamespace details {\nstatic const size_t default_async_q_size = 8192;\n}\n\n// async logger factory - creates async loggers backed with thread pool.\n// if a global thread pool doesn't already exist, create it with default queue\n// size of 8192 items and single thread.\ntemplate <async_overflow_policy OverflowPolicy = async_overflow_policy::block>\nstruct async_factory_impl {\n    template <typename Sink, typename... SinkArgs>\n    static std::shared_ptr<async_logger> create(std::string logger_name, SinkArgs &&...args) {\n        auto &registry_inst = details::registry::instance();\n\n        // create global thread pool if not already exists..\n\n        auto &mutex = registry_inst.tp_mutex();\n        std::lock_guard<std::recursive_mutex> tp_lock(mutex);\n        auto tp = registry_inst.get_tp();\n        if (tp == nullptr) {\n            tp = std::make_shared<details::thread_pool>(details::default_async_q_size, 1U);\n            registry_inst.set_tp(tp);\n        }\n\n        auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n        auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink),\n                                                         std::move(tp), OverflowPolicy);\n        registry_inst.initialize_logger(new_logger);\n        return new_logger;\n    }\n};\n\nusing async_factory = async_factory_impl<async_overflow_policy::block>;\nusing async_factory_nonblock = async_factory_impl<async_overflow_policy::overrun_oldest>;\n\ntemplate <typename Sink, typename... SinkArgs>\ninline std::shared_ptr<spdlog::logger> create_async(std::string logger_name,\n                                                    SinkArgs &&...sink_args) {\n    return async_factory::create<Sink>(std::move(logger_name),\n                                       std::forward<SinkArgs>(sink_args)...);\n}\n\ntemplate <typename Sink, typename... SinkArgs>\ninline std::shared_ptr<spdlog::logger> create_async_nb(std::string logger_name,\n                                                       SinkArgs &&...sink_args) {\n    return async_factory_nonblock::create<Sink>(std::move(logger_name),\n                                                std::forward<SinkArgs>(sink_args)...);\n}\n\n// set global thread pool.\ninline void init_thread_pool(size_t q_size,\n                             size_t thread_count,\n                             std::function<void()> on_thread_start,\n                             std::function<void()> on_thread_stop) {\n    auto tp = std::make_shared<details::thread_pool>(q_size, thread_count, on_thread_start,\n                                                     on_thread_stop);\n    details::registry::instance().set_tp(std::move(tp));\n}\n\ninline void init_thread_pool(size_t q_size,\n                             size_t thread_count,\n                             std::function<void()> on_thread_start) {\n    init_thread_pool(q_size, thread_count, on_thread_start, [] {});\n}\n\ninline void init_thread_pool(size_t q_size, size_t thread_count) {\n    init_thread_pool(\n        q_size, thread_count, [] {}, [] {});\n}\n\n// get the global thread pool.\ninline std::shared_ptr<spdlog::details::thread_pool> thread_pool() {\n    return details::registry::instance().get_tp();\n}\n}",
  "id": "BLOCK-CPP-00007",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/async.h",
  "source_line": 25,
  "validation_status": "validated"
}