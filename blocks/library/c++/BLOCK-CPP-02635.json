{
  "code": "{\n  if (format == HelpFormat::kHumanReadable) {\n    out << flags_internal::ShortProgramInvocationName() << \": \"\n        << program_usage_message << \"\\n\\n\";\n  } else {\n    // XML schema is not a part of our public API for now.\n    out << \"<?xml version=\\\"1.0\\\"?>\\n\"\n        << \"<!-- This output should be used with care. We do not report type \"\n           \"names for flags with user defined types -->\\n\"\n        << \"<!-- Prefer flag only_check_args for validating flag inputs -->\\n\"\n        // The document.\n        << \"<AllFlags>\\n\"\n        // The program name and usage.\n        << XMLElement(\"program\", flags_internal::ShortProgramInvocationName())\n        << '\\n'\n        << XMLElement(\"usage\", program_usage_message) << '\\n';\n  }\n\n  // Ordered map of package name to\n  //   map of file name to\n  //     vector of flags in the file.\n  // This map is used to output matching flags grouped by package and file\n  // name.\n  std::map<std::string,\n           std::map<std::string, std::vector<const absl::CommandLineFlag*>>>\n      matching_flags;\n\n  flags_internal::ForEachFlag([&](absl::CommandLineFlag& flag) {\n    // Ignore retired flags.\n    if (flag.IsRetired()) return;\n\n    // If the flag has been stripped, pretend that it doesn't exist.\n    if (flag.Help() == flags_internal::kStrippedFlagHelp) return;\n\n    // Make sure flag satisfies the filter\n    if (!filter_cb(flag)) return;\n\n    std::string flag_filename = flag.Filename();\n\n    matching_flags[std::string(flags_internal::Package(flag_filename))]\n                  [flag_filename]\n                      .push_back(&flag);\n  });\n\n  absl::string_view package_separator;  // controls blank lines between packages\n  absl::string_view file_separator;     // controls blank lines between files\n  for (auto& package : matching_flags) {\n    if (format == HelpFormat::kHumanReadable) {\n      out << package_separator;\n      package_separator = \"\\n\\n\";\n    }\n\n    file_separator = \"\";\n    for (auto& flags_in_file : package.second) {\n      if (format == HelpFormat::kHumanReadable) {\n        out << file_separator << \"  Flags from \" << flags_in_file.first\n            << \":\\n\";\n        file_separator = \"\\n\";\n      }\n\n      std::sort(std::begin(flags_in_file.second),\n                std::end(flags_in_file.second),\n                [](const CommandLineFlag* lhs, const CommandLineFlag* rhs) {\n                  return lhs->Name() < rhs->Name();\n                });\n\n      for (const auto* flag : flags_in_file.second) {\n        flags_internal::FlagHelp(out, *flag, format);\n      }\n    }\n  }\n\n  if (format == HelpFormat::kHumanReadable) {\n    FlagHelpPrettyPrinter printer(kHrfMaxLineLength, 0, 0, out);\n\n    if (filter_cb && matching_flags.empty()) {\n      printer.Write(\"No flags matched.\\n\", true);\n    }\n    printer.EndLine();\n    printer.Write(\n        \"Try --helpfull to get a list of all flags or --help=substring \"\n        \"shows help for flags which include specified substring in either \"\n        \"in the name, or description or path.\\n\",\n        true);\n  } else {\n    // The end of the document.\n    out << \"</AllFlags>\\n\";\n  }\n}",
  "id": "BLOCK-CPP-02635",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/internal/usage.cc",
  "source_line": 243,
  "validation_status": "validated"
}