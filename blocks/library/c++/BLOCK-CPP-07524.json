{
  "code": "#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-07524_execute() {\n    {\nprotected:\n  CanQual<T> Stored;\n\npublic:\n  /// Retrieve the pointer to the underlying Type\n  const T *getTypePtr() const { return Stored.getTypePtr(); }\n\n  /// Implicit conversion to the underlying pointer.\n  ///\n  /// Also provides the ability to use canonical type proxies in a Boolean\n  // context,e.g.,\n  /// @code\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) { ... }\n  /// @endcode\n  operator const T*() const { return this->Stored.getTypePtrOrNull(); }\n\n  /// Try to convert the given canonical type to a specific structural\n  /// type.\n  template<typename U> CanProxy<U> getAs() const {\n    return this->Stored.template getAs<U>();\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type::TypeClass, getTypeClass)\n\n  // Type predicates\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessBuiltinType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteOrObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariablyModifiedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isEnumeralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBooleanType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isWideCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArithmeticType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDerivedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isScalarType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAggregateType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isMemberFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureOrClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnionType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isNullPtrType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDependentType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isOverloadableType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArrayType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasObjCPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasSignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasUnsignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasFloatingRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isConstantSizeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSpecifierType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(CXXRecordDecl*, getAsCXXRecordDecl)\n\n  /// Retrieve the proxy-adaptor type.\n  ///\n  /// This arrow operator is used when CanProxyAdaptor has been specialized\n  /// for the given type T. In that case, we reference members of the\n  /// CanProxyAdaptor specialization. Otherwise, this operator will be hidden\n  /// by the arrow operator in the primary CanProxyAdaptor template.\n  const CanProxyAdaptor<T> *operator->() const {\n    return static_cast<const CanProxyAdaptor<T> *>(this);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-07524",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CanonicalType.h",
  "source_line": 238,
  "validation_status": "validated"
}