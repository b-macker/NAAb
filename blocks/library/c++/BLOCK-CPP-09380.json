{
  "code": "{\n  ///   template<convertible_to<Types> ...Convertibles>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Convertibles has (convertible_to<Types> && ...) as\n  /// its type-constraint. When \\c Types is supplied with template arguments by\n  /// instantiating \\c X, the instantiation of \\c Convertibles becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Convertibles being an expanded\n  /// parameter pack of size 2 (use getNumExpansionTypes() to get this number).\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of parameters in an expanded parameter pack.\n  unsigned getNumExpansionParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpanded;\n  }\n\n  /// Returns the type constraint associated with this template parameter (if\n  /// any).\n  const TypeConstraint *getTypeConstraint() const {\n    return TypeConstraintInitialized ? getTrailingObjects<TypeConstraint>() :\n         nullptr;\n  }\n\n  void setTypeConstraint(NestedNameSpecifierLoc NNS,\n                         DeclarationNameInfo NameInfo, NamedDecl *FoundDecl,\n                         ConceptDecl *CD,\n                         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                         Expr *ImmediatelyDeclaredConstraint);\n\n  /// Determine whether this template parameter has a type-constraint.\n  bool hasTypeConstraint() const {\n    return HasTypeConstraint;\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be the immediately-introduced constraint or empty.\n  ///\n  /// Use this instead of getTypeConstraint for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (HasTypeConstraint)\n      AC.push_back(getTypeConstraint()->getImmediatelyDeclaredConstraint());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTypeParm; }\n}",
  "id": "BLOCK-CPP-09380",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 1349,
  "validation_status": "validated"
}