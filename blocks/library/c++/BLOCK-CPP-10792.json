{
  "code": "{\n  friend class ASTStmtReader;\n\n  /// The base expression (that is being destroyed).\n  Stmt *Base = nullptr;\n\n  /// Whether the operator was an arrow ('->'); otherwise, it was a\n  /// period ('.').\n  bool IsArrow : 1;\n\n  /// The location of the '.' or '->' operator.\n  SourceLocation OperatorLoc;\n\n  /// The nested-name-specifier that follows the operator, if present.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The type that precedes the '::' in a qualified pseudo-destructor\n  /// expression.\n  TypeSourceInfo *ScopeType = nullptr;\n\n  /// The location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation ColonColonLoc;\n\n  /// The location of the '~'.\n  SourceLocation TildeLoc;\n\n  /// The type being destroyed, or its name if we were unable to\n  /// resolve the name.\n  PseudoDestructorTypeStorage DestroyedType;\n\npublic:\n  CXXPseudoDestructorExpr(const ASTContext &Context,\n                          Expr *Base, bool isArrow, SourceLocation OperatorLoc,\n                          NestedNameSpecifierLoc QualifierLoc,\n                          TypeSourceInfo *ScopeType,\n                          SourceLocation ColonColonLoc,\n                          SourceLocation TildeLoc,\n                          PseudoDestructorTypeStorage DestroyedType);\n\n  explicit CXXPseudoDestructorExpr(EmptyShell Shell)\n      : Expr(CXXPseudoDestructorExprClass, Shell), IsArrow(false) {}\n\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return QualifierLoc.hasQualifier(); }\n\n  /// Retrieves the nested-name-specifier that qualifies the type name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// null.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Determine whether this pseudo-destructor expression was written\n  /// using an '->' (otherwise, it used a '.').\n  bool isArrow() const { return IsArrow; }\n\n  /// Retrieve the location of the '.' or '->' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the scope type in a qualified pseudo-destructor\n  /// expression.\n  ///\n  /// Pseudo-destructor expressions can have extra qualification within them\n  /// that is not part of the nested-name-specifier, e.g., \\c p->T::~T().\n  /// Here, if the object type of the expression is (or may be) a scalar type,\n  /// \\p T may also be a scalar type and, therefore, cannot be part of a\n  /// nested-name-specifier. It is stored as the \"scope type\" of the pseudo-\n  /// destructor expression.\n  TypeSourceInfo *getScopeTypeInfo() const { return ScopeType; }\n\n  /// Retrieve the location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation getColonColonLoc() const { return ColonColonLoc; }\n\n  /// Retrieve the location of the '~'.\n  SourceLocation getTildeLoc() const { return TildeLoc; }\n\n  /// Retrieve the source location information for the type\n  /// being destroyed.\n  ///\n  /// This type-source information is available for non-dependent\n  /// pseudo-destructor expressions and some dependent pseudo-destructor\n  /// expressions. Returns null if we only have the identifier for a\n  /// dependent pseudo-destructor expression.\n  TypeSourceInfo *getDestroyedTypeInfo() const {\n    return DestroyedType.getTypeSourceInfo();\n  }\n\n  /// In a dependent pseudo-destructor expression for which we do not\n  /// have full type information on the destroyed type, provides the name\n  /// of the destroyed type.\n  IdentifierInfo *getDestroyedTypeIdentifier() const {\n    return DestroyedType.getIdentifier();\n  }\n\n  /// Retrieve the type being destroyed.\n  QualType getDestroyedType() const;\n\n  /// Retrieve the starting location of the type being destroyed.\n  SourceLocation getDestroyedTypeLoc() const {\n    return DestroyedType.getLocation();\n  }\n\n  /// Set the name of destroyed type for a dependent pseudo-destructor\n  /// expression.\n  void setDestroyedType(IdentifierInfo *II, SourceLocation Loc) {\n    DestroyedType = PseudoDestructorTypeStorage(II, Loc);\n  }\n\n  /// Set the destroyed type.\n  void setDestroyedType(TypeSourceInfo *Info) {\n    DestroyedType = PseudoDestructorTypeStorage(Info);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Base->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXPseudoDestructorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n}",
  "id": "BLOCK-CPP-10792",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 2600,
  "validation_status": "validated"
}