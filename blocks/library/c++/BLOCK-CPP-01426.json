{
  "code": "#include <cmath>         // std::signbit\n#include <cstdint>       // uint32_t\n#include <cstring>       // std::memcpy\n#include <limits>        // std::numeric_limits\n#include <memory>        // std::uninitialized_copy\n#include <stdexcept>     // std::runtime_error\n#include <system_error>  // std::system_error\n#include \"core.h\"\n\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail_exported;\nusing namespace detail_exported;\nusing namespace dragonbox;\nusing namespace dragonbox;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01426_execute() {\n    {\n private:\n  size_t count_;\n\n public:\n  using iterator_category = std::output_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n  using pointer = void;\n  using reference = void;\n  FMT_UNCHECKED_ITERATOR(counting_iterator);\n\n  struct value_type {\n    template <typename T> FMT_CONSTEXPR void operator=(const T&) {}\n  };\n\n  FMT_CONSTEXPR counting_iterator() : count_(0) {}\n\n  FMT_CONSTEXPR size_t count() const { return count_; }\n\n  FMT_CONSTEXPR counting_iterator& operator++() {\n    ++count_;\n    return *this;\n  }\n  FMT_CONSTEXPR counting_iterator operator++(int) {\n    auto it = *this;\n    ++*this;\n    return it;\n  }\n\n  FMT_CONSTEXPR friend counting_iterator operator+(counting_iterator it,\n                                                   difference_type n) {\n    it.count_ += static_cast<size_t>(n);\n    return it;\n  }\n\n  FMT_CONSTEXPR value_type operator*() const { return {}; }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01426",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 2138,
  "validation_status": "validated"
}