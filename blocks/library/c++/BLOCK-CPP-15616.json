{
  "code": "{\n\n// Specialize DenseMapInfo for clang::CallGraphNode::CallRecord.\ntemplate <> struct DenseMapInfo<clang::CallGraphNode::CallRecord> {\n  static inline clang::CallGraphNode::CallRecord getEmptyKey() {\n    return clang::CallGraphNode::CallRecord(\n        DenseMapInfo<clang::CallGraphNode *>::getEmptyKey(),\n        DenseMapInfo<clang::Expr *>::getEmptyKey());\n  }\n\n  static inline clang::CallGraphNode::CallRecord getTombstoneKey() {\n    return clang::CallGraphNode::CallRecord(\n        DenseMapInfo<clang::CallGraphNode *>::getTombstoneKey(),\n        DenseMapInfo<clang::Expr *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const clang::CallGraphNode::CallRecord &Val) {\n    // NOTE: we are comparing based on the callee only.\n    // Different call records with the same callee will compare equal!\n    return DenseMapInfo<clang::CallGraphNode *>::getHashValue(Val.Callee);\n  }\n\n  static bool isEqual(const clang::CallGraphNode::CallRecord &LHS,\n                      const clang::CallGraphNode::CallRecord &RHS) {\n    return LHS == RHS;\n  }\n};\n\n// Graph traits for iteration, viewing.\ntemplate <> struct GraphTraits<clang::CallGraphNode*> {\n  using NodeType = clang::CallGraphNode;\n  using NodeRef = clang::CallGraphNode *;\n  using ChildIteratorType = NodeType::iterator;\n\n  static NodeType *getEntryNode(clang::CallGraphNode *CGN) { return CGN; }\n  static ChildIteratorType child_begin(NodeType *N) { return N->begin();  }\n  static ChildIteratorType child_end(NodeType *N) { return N->end(); }\n};\n\ntemplate <> struct GraphTraits<const clang::CallGraphNode*> {\n  using NodeType = const clang::CallGraphNode;\n  using NodeRef = const clang::CallGraphNode *;\n  using ChildIteratorType = NodeType::const_iterator;\n\n  static NodeType *getEntryNode(const clang::CallGraphNode *CGN) { return CGN; }\n  static ChildIteratorType child_begin(NodeType *N) { return N->begin();}\n  static ChildIteratorType child_end(NodeType *N) { return N->end(); }\n};\n\ntemplate <> struct GraphTraits<clang::CallGraph*>\n  : public GraphTraits<clang::CallGraphNode*> {\n  static NodeType *getEntryNode(clang::CallGraph *CGN) {\n    return CGN->getRoot();  // Start at the external node!\n  }\n\n  static clang::CallGraphNode *\n  CGGetValue(clang::CallGraph::const_iterator::value_type &P) {\n    return P.second.get();\n  }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator =\n      mapped_iterator<clang::CallGraph::iterator, decltype(&CGGetValue)>;\n\n  static nodes_iterator nodes_begin(clang::CallGraph *CG) {\n    return nodes_iterator(CG->begin(), &CGGetValue);\n  }\n\n  static nodes_iterator nodes_end  (clang::CallGraph *CG) {\n    return nodes_iterator(CG->end(), &CGGetValue);\n  }\n\n  static unsigned size(clang::CallGraph *CG) { return CG->size(); }\n};\n\ntemplate <> struct GraphTraits<const clang::CallGraph*> :\n  public GraphTraits<const clang::CallGraphNode*> {\n  static NodeType *getEntryNode(const clang::CallGraph *CGN) {\n    return CGN->getRoot();\n  }\n\n  static clang::CallGraphNode *\n  CGGetValue(clang::CallGraph::const_iterator::value_type &P) {\n    return P.second.get();\n  }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator =\n      mapped_iterator<clang::CallGraph::const_iterator, decltype(&CGGetValue)>;\n\n  static nodes_iterator nodes_begin(const clang::CallGraph *CG) {\n    return nodes_iterator(CG->begin(), &CGGetValue);\n  }\n\n  static nodes_iterator nodes_end(const clang::CallGraph *CG) {\n    return nodes_iterator(CG->end(), &CGGetValue);\n  }\n\n  static unsigned size(const clang::CallGraph *CG) { return CG->size(); }\n};\n\n}",
  "id": "BLOCK-CPP-15616",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CallGraph.h",
  "source_line": 214,
  "validation_status": "validated"
}