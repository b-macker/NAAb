{
  "code": "{\npublic:\n  enum Kind {\n    MD_Define,\n    MD_Undefine,\n    MD_Visibility\n  };\n\nprotected:\n  /// Previous macro directive for the same identifier, or nullptr.\n  MacroDirective *Previous = nullptr;\n\n  SourceLocation Loc;\n\n  /// MacroDirective kind.\n  unsigned MDKind : 2;\n\n  /// True if the macro directive was loaded from a PCH file.\n  unsigned IsFromPCH : 1;\n\n  // Used by VisibilityMacroDirective ----------------------------------------//\n\n  /// Whether the macro has public visibility (when described in a\n  /// module).\n  unsigned IsPublic : 1;\n\n  MacroDirective(Kind K, SourceLocation Loc)\n      : Loc(Loc), MDKind(K), IsFromPCH(false), IsPublic(true) {}\n\npublic:\n  Kind getKind() const { return Kind(MDKind); }\n\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Set previous definition of the macro with the same name.\n  void setPrevious(MacroDirective *Prev) { Previous = Prev; }\n\n  /// Get previous definition of the macro with the same name.\n  const MacroDirective *getPrevious() const { return Previous; }\n\n  /// Get previous definition of the macro with the same name.\n  MacroDirective *getPrevious() { return Previous; }\n\n  /// Return true if the macro directive was loaded from a PCH file.\n  bool isFromPCH() const { return IsFromPCH; }\n\n  void setIsFromPCH() { IsFromPCH = true; }\n\n  class DefInfo {\n    DefMacroDirective *DefDirective = nullptr;\n    SourceLocation UndefLoc;\n    bool IsPublic = true;\n\n  public:\n    DefInfo() = default;\n    DefInfo(DefMacroDirective *DefDirective, SourceLocation UndefLoc,\n            bool isPublic)\n        : DefDirective(DefDirective), UndefLoc(UndefLoc), IsPublic(isPublic) {}\n\n    const DefMacroDirective *getDirective() const { return DefDirective; }\n    DefMacroDirective *getDirective() { return DefDirective; }\n\n    inline SourceLocation getLocation() const;\n    inline MacroInfo *getMacroInfo();\n\n    const MacroInfo *getMacroInfo() const {\n      return const_cast<DefInfo *>(this)->getMacroInfo();\n    }\n\n    SourceLocation getUndefLocation() const { return UndefLoc; }\n    bool isUndefined() const { return UndefLoc.isValid(); }\n\n    bool isPublic() const { return IsPublic; }\n\n    bool isValid() const { return DefDirective != nullptr; }\n    bool isInvalid() const { return !isValid(); }\n\n    explicit operator bool() const { return isValid(); }\n\n    inline DefInfo getPreviousDefinition();\n\n    const DefInfo getPreviousDefinition() const {\n      return const_cast<DefInfo *>(this)->getPreviousDefinition();\n    }\n  };\n\n  /// Traverses the macro directives history and returns the next\n  /// macro definition directive along with info about its undefined location\n  /// (if there is one) and if it is public or private.\n  DefInfo getDefinition();\n  const DefInfo getDefinition() const {\n    return const_cast<MacroDirective *>(this)->getDefinition();\n  }\n\n  bool isDefined() const {\n    if (const DefInfo Def = getDefinition())\n      return !Def.isUndefined();\n    return false;\n  }\n\n  const MacroInfo *getMacroInfo() const {\n    return getDefinition().getMacroInfo();\n  }\n  MacroInfo *getMacroInfo() { return getDefinition().getMacroInfo(); }\n\n  /// Find macro definition active in the specified source location. If\n  /// this macro was not defined there, return NULL.\n  const DefInfo findDirectiveAtLoc(SourceLocation L,\n                                   const SourceManager &SM) const;\n\n  void dump() const;\n\n  static bool classof(const MacroDirective *) { return true; }\n}",
  "id": "BLOCK-CPP-18759",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/MacroInfo.h",
  "source_line": 313,
  "validation_status": "validated"
}