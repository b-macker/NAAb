{
  "code": "{\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned SpacesBeforeTrailingComments;\n\n  /// Styles for adding spacing after ``<`` and before ``>``\n  ///  in template argument lists.\n  enum SpacesInAnglesStyle : int8_t {\n    /// Remove spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast<int>(arg);\n    ///    std::function<void(int)> fct;\n    /// \\endcode\n    SIAS_Never,\n    /// Add spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast< int >(arg);\n    ///    std::function< void(int) > fct;\n    /// \\endcode\n    SIAS_Always,\n    /// Keep a single space after ``<`` and before ``>`` if any spaces were\n    /// present. Option ``Standard: Cpp03`` takes precedence.\n    SIAS_Leave\n  };\n  /// The SpacesInAnglesStyle to use for template argument lists.\n  /// \\version 3.4\n  SpacesInAnglesStyle SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// This option is **deprecated**. See ``InConditionalStatements`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 10\n  // bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.  ObjC and\n  /// Javascript array and dict literals). For JSON, use\n  /// ``SpaceBeforeJsonColon`` instead.\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// This option is **deprecated**. See ``InCStyleCasts`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment.\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code\n  ///   Minimum = 1\n  ///   Maximum = -1\n  ///   // One space is forced\n  ///\n  ///   //  but more spaces are possible\n  ///\n  ///   Minimum = 0\n  ///   Maximum = 0\n  ///   //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  ///   before:                                   after:\n  ///   Minimum: 1\n  ///   //if (b) {                                // if (b) {\n  ///   //  return true;                          //   return true;\n  ///   //}                                       // }\n  ///\n  ///   Maximum: 0\n  ///   /// List:                                 ///List:\n  ///   ///  - Foo                                /// - Foo\n  ///   ///    - Bar                              ///   - Bar\n  /// \\endcode\n  ///\n  /// This option has only effect if ``ReflowComments`` is set to ``true``.\n  /// \\version 13\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// Different ways to put a space before opening and closing parentheses.\n  enum SpacesInParensStyle : int8_t {\n    /// Never put a space in parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SIPO_Never,\n    /// Configure each individual space in parentheses in\n    /// `SpacesInParensOptions`.\n    SIPO_Custom,\n  };\n\n  /// If ``true'', spaces will be inserted after ``(`` and before ``)``.\n  /// This option is **deprecated**. The previous behavior is preserved by using\n  /// ``SpacesInParens`` with ``Custom`` and by setting all\n  /// ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and\n  /// ``InEmptyParentheses``.\n  /// \\version 3.7\n  // bool SpacesInParentheses;\n\n  /// Defines in which cases spaces will be inserted after ``(`` and before\n  /// ``)``.\n  /// \\version 17\n  SpacesInParensStyle SpacesInParens;\n\n  /// Precise control over the spacing in parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     Other: true\n  /// \\endcode\n  struct SpacesInParensCustom {\n    /// Put a space in parentheses only inside conditional statements\n    /// (``for/if/while/switch...``).\n    /// \\code\n    ///    true:                                  false:\n    ///    if ( a )  { ... }              vs.     if (a) { ... }\n    ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n    /// \\endcode\n    bool InConditionalStatements;\n    /// Put a space in C style casts.\n    /// \\code\n    ///    true:                                  false:\n    ///    x = ( int32 )y                 vs.     x = (int32)y\n    /// \\endcode\n    bool InCStyleCasts;\n    /// Put a space in parentheses only if the parentheses are empty i.e. '()'\n    /// \\code\n    ///    true:                                false:\n    ///    void f( ) {                    vs.   void f() {\n    ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n    ///      if (true) {                          if (true) {\n    ///        f( );                                f();\n    ///      }                                    }\n    ///    }                                    }\n    /// \\endcode\n    bool InEmptyParentheses;\n    /// Put a space in parentheses not covered by preceding options.\n    /// \\code\n    ///    true:                                  false:\n    ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n    /// \\endcode\n    bool Other;\n\n    SpacesInParensCustom()\n        : InConditionalStatements(false), InCStyleCasts(false),\n          InEmptyParentheses(false), Other(false) {}\n\n    SpacesInParensCustom(bool InConditionalStatements, bool InCStyleCasts,\n        bool InEmptyParentheses, bool Other)\n        : InConditionalStatements(InConditionalStatements),\n          InCStyleCasts(InCStyleCasts),\n          InEmptyParentheses(InEmptyParentheses),\n          Other(Other) {}\n\n    bool operator==(const SpacesInParensCustom &R) const {\n      return InConditionalStatements == R.InConditionalStatements &&\n             InCStyleCasts == R.InCStyleCasts &&\n             InEmptyParentheses == R.InEmptyParentheses &&\n             Other == R.Other;\n    }\n    bool operator!=(const SpacesInParensCustom &R) const {\n      return !(*this == R);\n    }\n  };\n\n  /// Control of individual spaces in parentheses.\n  ///\n  /// If ``SpacesInParens`` is set to ``Custom``, use this to specify\n  /// how each individual space in parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     InEmptyParentheses: true\n  /// \\endcode\n  /// \\version 17\n  SpacesInParensCustom SpacesInParensOptions;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInSquareBrackets;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : int8_t {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  /// \\version 3.7\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  /// \\version 12\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  /// \\version 8\n  std::vector<std::string> StatementMacros;\n\n  /// The number of columns used for tab stops.\n  /// \\version 3.7\n  unsigned TabWidth;\n\n  /// A vector of non-keyword identifiers that should be interpreted as type\n  /// names.\n  ///\n  /// A ``*``, ``&``, or ``&&`` between a type name and another non-keyword\n  /// identifier is annotated as a pointer or reference token instead of a\n  /// binary operator.\n  ///\n  /// \\version 17\n  std::vector<std::string> TypeNames;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  /// \\version 9\n  std::vector<std::string> TypenameMacros;\n\n  /// This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``.\n  /// \\version 10\n  // bool UseCRLF;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : int8_t {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// The way to use tab characters in the resulting file.\n  /// \\version 3.7\n  UseTabStyle UseTab;\n\n  /// For Verilog, put each port on its own line in module instantiations.\n  /// \\code\n  ///    true:\n  ///    ffnand ff1(.q(),\n  ///               .qbar(out1),\n  ///               .clear(in1),\n  ///               .preset(in2));\n  ///\n  ///    false:\n  ///    ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));\n  /// \\endcode\n  /// \\version 17\n  bool VerilogBreakBetweenInstancePorts;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  /// \\version 11\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignArrayOfStructures == R.AlignArrayOfStructures &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignConsecutiveShortCaseStatements ==\n               R.AlignConsecutiveShortCaseStatements &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           BracedInitializerIndentWidth == R.BracedInitializerIndentWidth &&\n           BreakAfterAttributes == R.BreakAfterAttributes &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakArrays == R.BreakArrays &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeInlineASMColon == R.BreakBeforeInlineASMColon &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           CompactNamespaces == R.CompactNamespaces &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineAfterAccessModifier == R.EmptyLineAfterAccessModifier &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentRequiresClause == R.IndentRequiresClause &&\n           IndentWidth == R.IndentWidth &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           InsertBraces == R.InsertBraces &&\n           InsertNewlineAtEOF == R.InsertNewlineAtEOF &&\n           IntegerLiteralSeparator == R.IntegerLiteralSeparator &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtEOF == R.KeepEmptyLinesAtEOF &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           Language == R.Language &&\n           LambdaBodyIndentation == R.LambdaBodyIndentation &&\n           LineEnding == R.LineEnding && MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd && Macros == R.Macros &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PackConstructorInitializers == R.PackConstructorInitializers &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakOpenParenthesis == R.PenaltyBreakOpenParenthesis &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PointerAlignment == R.PointerAlignment &&\n           QualifierAlignment == R.QualifierAlignment &&\n           QualifierOrder == R.QualifierOrder &&\n           RawStringFormats == R.RawStringFormats &&\n           ReferenceAlignment == R.ReferenceAlignment &&\n           RemoveBracesLLVM == R.RemoveBracesLLVM &&\n           RemoveParentheses == R.RemoveParentheses &&\n           RemoveSemicolon == R.RemoveSemicolon &&\n           RequiresClausePosition == R.RequiresClausePosition &&\n           RequiresExpressionIndentation == R.RequiresExpressionIndentation &&\n           SeparateDefinitionBlocks == R.SeparateDefinitionBlocks &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeJsonColon == R.SpaceBeforeJsonColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceBeforeParensOptions == R.SpaceBeforeParensOptions &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParens == R.SpacesInParens &&\n           SpacesInParensOptions == R.SpacesInParensOptions &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           TypeNames == R.TypeNames && TypenameMacros == R.TypenameMacros &&\n           UseTab == R.UseTab &&\n           VerilogBreakBetweenInstancePorts ==\n               R.VerilogBreakBetweenInstancePorts &&\n           WhitespaceSensitiveMacros == R.WhitespaceSensitiveMacros;\n  }\n\n  std::optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    std::optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n}",
  "id": "BLOCK-CPP-18113",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 4170,
  "validation_status": "validated"
}