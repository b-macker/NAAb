{
  "code": "#include <stdint.h>\n#include <new>\n#include \"absl/base/internal/low_level_alloc.h\"\n#include \"absl/synchronization/internal/waiter.h\"\n#include <string.h>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/internal/spinlock.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/synchronization/internal/per_thread_sem.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03121_execute() {\n    {\n  base_internal::ThreadIdentity* identity =\n      static_cast<base_internal::ThreadIdentity*>(v);\n\n  // all_locks might have been allocated by the Mutex implementation.\n  // We free it here when we are notified that our thread is dying.\n  if (identity->per_thread_synch.all_locks != nullptr) {\n    base_internal::LowLevelAlloc::Free(identity->per_thread_synch.all_locks);\n  }\n\n  // We must explicitly clear the current thread's identity:\n  // (a) Subsequent (unrelated) per-thread destructors may require an identity.\n  //     We must guarantee a new identity is used in this case (this instructor\n  //     will be reinvoked up to PTHREAD_DESTRUCTOR_ITERATIONS in this case).\n  // (b) ThreadIdentity implementations may depend on memory that is not\n  //     reinitialized before reuse.  We must allow explicit clearing of the\n  //     association state in this case.\n  base_internal::ClearCurrentThreadIdentity();\n  {\n    base_internal::SpinLockHolder l(&freelist_lock);\n    identity->next = thread_identity_freelist;\n    thread_identity_freelist = identity;\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03121",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/create_thread_identity.cc",
  "source_line": 43,
  "validation_status": "validated"
}