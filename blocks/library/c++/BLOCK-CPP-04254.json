{
  "code": "{\n public:\n  using traits_type = std::char_traits<char>;\n  using value_type = char;\n  using pointer = absl::Nullable<char*>;\n  using const_pointer = absl::Nullable<const char*>;\n  using reference = char&;\n  using const_reference = const char&;\n  using const_iterator = absl::Nullable<const char*>;\n  using iterator = const_iterator;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = const_reverse_iterator;\n  using size_type = size_t;\n  using difference_type = std::ptrdiff_t;\n\n  static constexpr size_type npos = static_cast<size_type>(-1);\n\n  // Null `string_view` constructor\n  constexpr string_view() noexcept : ptr_(nullptr), length_(0) {}\n\n  // Implicit constructors\n\n  template <typename Allocator>\n  string_view(  // NOLINT(runtime/explicit)\n      const std::basic_string<char, std::char_traits<char>, Allocator>& str\n          ABSL_ATTRIBUTE_LIFETIME_BOUND) noexcept\n      // This is implemented in terms of `string_view(p, n)` so `str.size()`\n      // doesn't need to be reevaluated after `ptr_` is set.\n      // The length check is also skipped since it is unnecessary and causes\n      // code bloat.\n      : string_view(str.data(), str.size(), SkipCheckLengthTag{}) {}\n\n  // Implicit constructor of a `string_view` from NUL-terminated `str`. When\n  // accepting possibly null strings, use `absl::NullSafeStringView(str)`\n  // instead (see below).\n  // The length check is skipped since it is unnecessary and causes code bloat.\n  constexpr string_view(  // NOLINT(runtime/explicit)\n      absl::Nonnull<const char*> str)\n      : ptr_(str), length_(str ? StrlenInternal(str) : 0) {}\n\n  // Implicit constructor of a `string_view` from a `const char*` and length.\n  constexpr string_view(absl::Nullable<const char*> data, size_type len)\n      : ptr_(data), length_(CheckLengthInternal(len)) {}\n\n  // NOTE: Harmlessly omitted to work around gdb bug.\n  //   constexpr string_view(const string_view&) noexcept = default;\n  //   string_view& operator=(const string_view&) noexcept = default;\n\n  // Iterators\n\n  // string_view::begin()\n  //\n  // Returns an iterator pointing to the first character at the beginning of the\n  // `string_view`, or `end()` if the `string_view` is empty.\n  constexpr const_iterator begin() const noexcept { return ptr_; }\n\n  // string_view::end()\n  //\n  // Returns an iterator pointing just beyond the last character at the end of\n  // the `string_view`. This iterator acts as a placeholder; attempting to\n  // access it results in undefined behavior.\n  constexpr const_iterator end() const noexcept { return ptr_ + length_; }\n\n  // string_view::cbegin()\n  //\n  // Returns a const iterator pointing to the first character at the beginning\n  // of the `string_view`, or `end()` if the `string_view` is empty.\n  constexpr const_iterator cbegin() const noexcept { return begin(); }\n\n  // string_view::cend()\n  //\n  // Returns a const iterator pointing just beyond the last character at the end\n  // of the `string_view`. This pointer acts as a placeholder; attempting to\n  // access its element results in undefined behavior.\n  constexpr const_iterator cend() const noexcept { return end(); }\n\n  // string_view::rbegin()\n  //\n  // Returns a reverse iterator pointing to the last character at the end of the\n  // `string_view`, or `rend()` if the `string_view` is empty.\n  const_reverse_iterator rbegin() const noexcept {\n    return const_reverse_iterator(end());\n  }\n\n  // string_view::rend()\n  //\n  // Returns a reverse iterator pointing just before the first character at the\n  // beginning of the `string_view`. This pointer acts as a placeholder;\n  // attempting to access its element results in undefined behavior.\n  const_reverse_iterator rend() const noexcept {\n    return const_reverse_iterator(begin());\n  }\n\n  // string_view::crbegin()\n  //\n  // Returns a const reverse iterator pointing to the last character at the end\n  // of the `string_view`, or `crend()` if the `string_view` is empty.\n  const_reverse_iterator crbegin() const noexcept { return rbegin(); }\n\n  // string_view::crend()\n  //\n  // Returns a const reverse iterator pointing just before the first character\n  // at the beginning of the `string_view`. This pointer acts as a placeholder;\n  // attempting to access its element results in undefined behavior.\n  const_reverse_iterator crend() const noexcept { return rend(); }\n\n  // Capacity Utilities\n\n  // string_view::size()\n  //\n  // Returns the number of characters in the `string_view`.\n  constexpr size_type size() const noexcept { return length_; }\n\n  // string_view::length()\n  //\n  // Returns the number of characters in the `string_view`. Alias for `size()`.\n  constexpr size_type length() const noexcept { return size(); }\n\n  // string_view::max_size()\n  //\n  // Returns the maximum number of characters the `string_view` can hold.\n  constexpr size_type max_size() const noexcept { return kMaxSize; }\n\n  // string_view::empty()\n  //\n  // Checks if the `string_view` is empty (refers to no characters).\n  constexpr bool empty() const noexcept { return length_ == 0; }\n\n  // string_view::operator[]\n  //\n  // Returns the ith element of the `string_view` using the array operator.\n  // Note that this operator does not perform any bounds checking.\n  constexpr const_reference operator[](size_type i) const {\n    return ABSL_HARDENING_ASSERT(i < size()), ptr_[i];\n  }\n\n  // string_view::at()\n  //\n  // Returns the ith element of the `string_view`. Bounds checking is performed,\n  // and an exception of type `std::out_of_range` will be thrown on invalid\n  // access.\n  constexpr const_reference at(size_type i) const {\n    return ABSL_PREDICT_TRUE(i < size())\n               ? ptr_[i]\n               : ((void)base_internal::ThrowStdOutOfRange(\n                      \"absl::string_view::at\"),\n                  ptr_[i]);\n  }\n\n  // string_view::front()\n  //\n  // Returns the first element of a `string_view`.\n  constexpr const_reference front() const {\n    return ABSL_HARDENING_ASSERT(!empty()), ptr_[0];\n  }\n\n  // string_view::back()\n  //\n  // Returns the last element of a `string_view`.\n  constexpr const_reference back() const {\n    return ABSL_HARDENING_ASSERT(!empty()), ptr_[size() - 1];\n  }\n\n  // string_view::data()\n  //\n  // Returns a pointer to the underlying character array (which is of course\n  // stored elsewhere). Note that `string_view::data()` may contain embedded nul\n  // characters, but the returned buffer may or may not be NUL-terminated;\n  // therefore, do not pass `data()` to a routine that expects a NUL-terminated\n  // string.\n  constexpr const_pointer data() const noexcept { return ptr_; }\n\n  // Modifiers\n\n  // string_view::remove_prefix()\n  //\n  // Removes the first `n` characters from the `string_view`. Note that the\n  // underlying string is not changed, only the view.\n  constexpr void remove_prefix(size_type n) {\n    ABSL_HARDENING_ASSERT(n <= length_);\n    ptr_ += n;\n    length_ -= n;\n  }\n\n  // string_view::remove_suffix()\n  //\n  // Removes the last `n` characters from the `string_view`. Note that the\n  // underlying string is not changed, only the view.\n  constexpr void remove_suffix(size_type n) {\n    ABSL_HARDENING_ASSERT(n <= length_);\n    length_ -= n;\n  }\n\n  // string_view::swap()\n  //\n  // Swaps this `string_view` with another `string_view`.\n  constexpr void swap(string_view& s) noexcept {\n    auto t = *this;\n    *this = s;\n    s = t;\n  }\n\n  // Explicit conversion operators\n\n  // Converts to `std::basic_string`.\n  template <typename A>\n  explicit operator std::basic_string<char, traits_type, A>() const {\n    if (!data()) return {};\n    return std::basic_string<char, traits_type, A>(data(), size());\n  }\n\n  // string_view::copy()\n  //\n  // Copies the contents of the `string_view` at offset `pos` and length `n`\n  // into `buf`.\n  size_type copy(char* buf, size_type n, size_type pos = 0) const {\n    if (ABSL_PREDICT_FALSE(pos > length_)) {\n      base_internal::ThrowStdOutOfRange(\"absl::string_view::copy\");\n    }\n    size_type rlen = (std::min)(length_ - pos, n);\n    if (rlen > 0) {\n      const char* start = ptr_ + pos;\n      traits_type::copy(buf, start, rlen);\n    }\n    return rlen;\n  }\n\n  // string_view::substr()\n  //\n  // Returns a \"substring\" of the `string_view` (at offset `pos` and length\n  // `n`) as another string_view. This function throws `std::out_of_bounds` if\n  // `pos > size`.\n  // Use absl::ClippedSubstr if you need a truncating substr operation.\n  constexpr string_view substr(size_type pos = 0, size_type n = npos) const {\n    return ABSL_PREDICT_FALSE(pos > length_)\n               ? (base_internal::ThrowStdOutOfRange(\n                      \"absl::string_view::substr\"),\n                  string_view())\n               : string_view(ptr_ + pos, Min(n, length_ - pos));\n  }\n\n  // string_view::compare()\n  //\n  // Performs a lexicographical comparison between this `string_view` and\n  // another `string_view` `x`, returning a negative value if `*this` is less\n  // than `x`, 0 if `*this` is equal to `x`, and a positive value if `*this`\n  // is greater than `x`.\n  constexpr int compare(string_view x) const noexcept {\n    return CompareImpl(length_, x.length_,\n                       Min(length_, x.length_) == 0\n                           ? 0\n                           : ABSL_INTERNAL_STRING_VIEW_MEMCMP(\n                                 ptr_, x.ptr_, Min(length_, x.length_)));\n  }\n\n  // Overload of `string_view::compare()` for comparing a substring of the\n  // 'string_view` and another `absl::string_view`.\n  constexpr int compare(size_type pos1, size_type count1, string_view v) const {\n    return substr(pos1, count1).compare(v);\n  }\n\n  // Overload of `string_view::compare()` for comparing a substring of the\n  // `string_view` and a substring of another `absl::string_view`.\n  constexpr int compare(size_type pos1, size_type count1, string_view v,\n                        size_type pos2, size_type count2) const {\n    return substr(pos1, count1).compare(v.substr(pos2, count2));\n  }\n\n  // Overload of `string_view::compare()` for comparing a `string_view` and a\n  // a different C-style string `s`.\n  constexpr int compare(absl::Nonnull<const char*> s) const {\n    return compare(string_view(s));\n  }\n\n  // Overload of `string_view::compare()` for comparing a substring of the\n  // `string_view` and a different string C-style string `s`.\n  constexpr int compare(size_type pos1, size_type count1,\n                        absl::Nonnull<const char*> s) const {\n    return substr(pos1, count1).compare(string_view(s));\n  }\n\n  // Overload of `string_view::compare()` for comparing a substring of the\n  // `string_view` and a substring of a different C-style string `s`.\n  constexpr int compare(size_type pos1, size_type count1,\n                        absl::Nonnull<const char*> s, size_type count2) const {\n    return substr(pos1, count1).compare(string_view(s, count2));\n  }\n\n  // Find Utilities\n\n  // string_view::find()\n  //\n  // Finds the first occurrence of the substring `s` within the `string_view`,\n  // returning the position of the first character's match, or `npos` if no\n  // match was found.\n  size_type find(string_view s, size_type pos = 0) const noexcept;\n\n  // Overload of `string_view::find()` for finding the given character `c`\n  // within the `string_view`.\n  size_type find(char c, size_type pos = 0) const noexcept;\n\n  // Overload of `string_view::find()` for finding a substring of a different\n  // C-style string `s` within the `string_view`.\n  size_type find(absl::Nonnull<const char*> s, size_type pos,\n                 size_type count) const {\n    return find(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::find()` for finding a different C-style string\n  // `s` within the `string_view`.\n  size_type find(absl::Nonnull<const char *> s, size_type pos = 0) const {\n    return find(string_view(s), pos);\n  }\n\n  // string_view::rfind()\n  //\n  // Finds the last occurrence of a substring `s` within the `string_view`,\n  // returning the position of the first character's match, or `npos` if no\n  // match was found.\n  size_type rfind(string_view s, size_type pos = npos) const noexcept;\n\n  // Overload of `string_view::rfind()` for finding the last given character `c`\n  // within the `string_view`.\n  size_type rfind(char c, size_type pos = npos) const noexcept;\n\n  // Overload of `string_view::rfind()` for finding a substring of a different\n  // C-style string `s` within the `string_view`.\n  size_type rfind(absl::Nonnull<const char*> s, size_type pos,\n                  size_type count) const {\n    return rfind(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::rfind()` for finding a different C-style string\n  // `s` within the `string_view`.\n  size_type rfind(absl::Nonnull<const char*> s, size_type pos = npos) const {\n    return rfind(string_view(s), pos);\n  }\n\n  // string_view::find_first_of()\n  //\n  // Finds the first occurrence of any of the characters in `s` within the\n  // `string_view`, returning the start position of the match, or `npos` if no\n  // match was found.\n  size_type find_first_of(string_view s, size_type pos = 0) const noexcept;\n\n  // Overload of `string_view::find_first_of()` for finding a character `c`\n  // within the `string_view`.\n  size_type find_first_of(char c, size_type pos = 0) const noexcept {\n    return find(c, pos);\n  }\n\n  // Overload of `string_view::find_first_of()` for finding a substring of a\n  // different C-style string `s` within the `string_view`.\n  size_type find_first_of(absl::Nonnull<const char*> s, size_type pos,\n                          size_type count) const {\n    return find_first_of(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::find_first_of()` for finding a different C-style\n  // string `s` within the `string_view`.\n  size_type find_first_of(absl::Nonnull<const char*> s,\n                          size_type pos = 0) const {\n    return find_first_of(string_view(s), pos);\n  }\n\n  // string_view::find_last_of()\n  //\n  // Finds the last occurrence of any of the characters in `s` within the\n  // `string_view`, returning the start position of the match, or `npos` if no\n  // match was found.\n  size_type find_last_of(string_view s, size_type pos = npos) const noexcept;\n\n  // Overload of `string_view::find_last_of()` for finding a character `c`\n  // within the `string_view`.\n  size_type find_last_of(char c, size_type pos = npos) const noexcept {\n    return rfind(c, pos);\n  }\n\n  // Overload of `string_view::find_last_of()` for finding a substring of a\n  // different C-style string `s` within the `string_view`.\n  size_type find_last_of(absl::Nonnull<const char*> s, size_type pos,\n                         size_type count) const {\n    return find_last_of(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::find_last_of()` for finding a different C-style\n  // string `s` within the `string_view`.\n  size_type find_last_of(absl::Nonnull<const char*> s,\n                         size_type pos = npos) const {\n    return find_last_of(string_view(s), pos);\n  }\n\n  // string_view::find_first_not_of()\n  //\n  // Finds the first occurrence of any of the characters not in `s` within the\n  // `string_view`, returning the start position of the first non-match, or\n  // `npos` if no non-match was found.\n  size_type find_first_not_of(string_view s, size_type pos = 0) const noexcept;\n\n  // Overload of `string_view::find_first_not_of()` for finding a character\n  // that is not `c` within the `string_view`.\n  size_type find_first_not_of(char c, size_type pos = 0) const noexcept;\n\n  // Overload of `string_view::find_first_not_of()` for finding a substring of a\n  // different C-style string `s` within the `string_view`.\n  size_type find_first_not_of(absl::Nonnull<const char*> s, size_type pos,\n                              size_type count) const {\n    return find_first_not_of(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::find_first_not_of()` for finding a different\n  // C-style string `s` within the `string_view`.\n  size_type find_first_not_of(absl::Nonnull<const char*> s,\n                              size_type pos = 0) const {\n    return find_first_not_of(string_view(s), pos);\n  }\n\n  // string_view::find_last_not_of()\n  //\n  // Finds the last occurrence of any of the characters not in `s` within the\n  // `string_view`, returning the start position of the last non-match, or\n  // `npos` if no non-match was found.\n  size_type find_last_not_of(string_view s,\n                             size_type pos = npos) const noexcept;\n\n  // Overload of `string_view::find_last_not_of()` for finding a character\n  // that is not `c` within the `string_view`.\n  size_type find_last_not_of(char c, size_type pos = npos) const noexcept;\n\n  // Overload of `string_view::find_last_not_of()` for finding a substring of a\n  // different C-style string `s` within the `string_view`.\n  size_type find_last_not_of(absl::Nonnull<const char*> s, size_type pos,\n                             size_type count) const {\n    return find_last_not_of(string_view(s, count), pos);\n  }\n\n  // Overload of `string_view::find_last_not_of()` for finding a different\n  // C-style string `s` within the `string_view`.\n  size_type find_last_not_of(absl::Nonnull<const char*> s,\n                             size_type pos = npos) const {\n    return find_last_not_of(string_view(s), pos);\n  }\n\n#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 202002L\n  // string_view::starts_with()\n  //\n  // Returns true if the `string_view` starts with the prefix `s`.\n  //\n  // This method only exists when targeting at least C++20.\n  // If support for C++ prior to C++20 is required, use `absl::StartsWith()`\n  // from `//absl/strings/match.h` for compatibility.\n  constexpr bool starts_with(string_view s) const noexcept {\n    return s.empty() ||\n           (size() >= s.size() &&\n            ABSL_INTERNAL_STRING_VIEW_MEMCMP(data(), s.data(), s.size()) == 0);\n  }\n\n  // Overload of `string_view::starts_with()` that returns true if `c` is the\n  // first character of the `string_view`.\n  constexpr bool starts_with(char c) const noexcept {\n    return !empty() && front() == c;\n  }\n\n  // Overload of `string_view::starts_with()` that returns true if the\n  // `string_view` starts with the C-style prefix `s`.\n  constexpr bool starts_with(const char* s) const {\n    return starts_with(string_view(s));\n  }\n\n  // string_view::ends_with()\n  //\n  // Returns true if the `string_view` ends with the suffix `s`.\n  //\n  // This method only exists when targeting at least C++20.\n  // If support for C++ prior to C++20 is required, use `absl::EndsWith()`\n  // from `//absl/strings/match.h` for compatibility.\n  constexpr bool ends_with(string_view s) const noexcept {\n    return s.empty() || (size() >= s.size() && ABSL_INTERNAL_STRING_VIEW_MEMCMP(\n                                                   data() + (size() - s.size()),\n                                                   s.data(), s.size()) == 0);\n  }\n\n  // Overload of `string_view::ends_with()` that returns true if `c` is the\n  // last character of the `string_view`.\n  constexpr bool ends_with(char c) const noexcept {\n    return !empty() && back() == c;\n  }\n\n  // Overload of `string_view::ends_with()` that returns true if the\n  // `string_view` ends with the C-style suffix `s`.\n  constexpr bool ends_with(const char* s) const {\n    return ends_with(string_view(s));\n  }\n#endif  // ABSL_INTERNAL_CPLUSPLUS_LANG >= 202002L\n\n private:\n  // The constructor from std::string delegates to this constructor.\n  // See the comment on that constructor for the rationale.\n  struct SkipCheckLengthTag {};\n  string_view(absl::Nullable<const char*> data, size_type len,\n              SkipCheckLengthTag) noexcept\n      : ptr_(data), length_(len) {}\n\n  static constexpr size_type kMaxSize =\n      (std::numeric_limits<difference_type>::max)();\n\n  static constexpr size_type CheckLengthInternal(size_type len) {\n    return ABSL_HARDENING_ASSERT(len <= kMaxSize), len;\n  }\n\n  static constexpr size_type StrlenInternal(absl::Nonnull<const char*> str) {\n#if defined(_MSC_VER) && _MSC_VER >= 1910 && !defined(__clang__)\n    // MSVC 2017+ can evaluate this at compile-time.\n    const char* begin = str;\n    while (*str != '\\0') ++str;\n    return str - begin;\n#elif ABSL_HAVE_BUILTIN(__builtin_strlen) || \\\n    (defined(__GNUC__) && !defined(__clang__))\n    // GCC has __builtin_strlen according to\n    // https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Other-Builtins.html, but\n    // ABSL_HAVE_BUILTIN doesn't detect that, so we use the extra checks above.\n    // __builtin_strlen is constexpr.\n    return __builtin_strlen(str);\n#else\n    return str ? strlen(str) : 0;\n#endif\n  }\n\n  static constexpr size_t Min(size_type length_a, size_type length_b) {\n    return length_a < length_b ? length_a : length_b;\n  }\n\n  static constexpr int CompareImpl(size_type length_a, size_type length_b,\n                                   int compare_result) {\n    return compare_result == 0 ? static_cast<int>(length_a > length_b) -\n                                     static_cast<int>(length_a < length_b)\n                               : (compare_result < 0 ? -1 : 1);\n  }\n\n  absl::Nullable<const char*> ptr_;\n  size_type length_;\n}",
  "id": "BLOCK-CPP-04254",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/string_view.h",
  "source_line": 162,
  "validation_status": "validated"
}