{
  "code": "{\nnamespace tooling {\n\nextern llvm::cl::opt<std::string> ExecutorName;\n\n/// An abstraction for the result of a tool execution. For example, the\n/// underlying result can be in-memory or on-disk.\n///\n/// Results should be string key-value pairs. For example, a refactoring tool\n/// can use source location as key and a replacement in YAML format as value.\nclass ToolResults {\npublic:\n  virtual ~ToolResults() = default;\n  virtual void addResult(StringRef Key, StringRef Value) = 0;\n  virtual std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() = 0;\n  virtual void forEachResult(\n      llvm::function_ref<void(StringRef Key, StringRef Value)> Callback) = 0;\n};\n\n/// Stores the key-value results in memory. It maintains the lifetime of\n/// the result. Clang tools using this class are expected to generate a small\n/// set of different results, or a large set of duplicated results.\nclass InMemoryToolResults : public ToolResults {\npublic:\n  InMemoryToolResults() : Strings(Arena) {}\n  void addResult(StringRef Key, StringRef Value) override;\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() override;\n  void forEachResult(llvm::function_ref<void(StringRef Key, StringRef Value)>\n                         Callback) override;\n\nprivate:\n  llvm::BumpPtrAllocator Arena;\n  llvm::UniqueStringSaver Strings;\n\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>> KVResults;\n};\n\n/// The context of an execution, including the information about\n/// compilation and results.\nclass ExecutionContext {\npublic:\n  virtual ~ExecutionContext() {}\n\n  /// Initializes a context. This does not take ownership of `Results`.\n  explicit ExecutionContext(ToolResults *Results) : Results(Results) {}\n\n  /// Adds a KV pair to the result container of this execution.\n  void reportResult(StringRef Key, StringRef Value);\n\n  // Returns the source control system's revision number if applicable.\n  // Otherwise returns an empty string.\n  virtual std::string getRevision() { return \"\"; }\n\n  // Returns the corpus being analyzed, e.g. \"llvm\" for the LLVM codebase, if\n  // applicable.\n  virtual std::string getCorpus() { return \"\"; }\n\n  // Returns the currently processed compilation unit if available.\n  virtual std::string getCurrentCompilationUnit() { return \"\"; }\n\nprivate:\n  ToolResults *Results;\n};\n\n/// Interface for executing clang frontend actions.\n///\n/// This can be extended to support running tool actions in different\n/// execution mode, e.g. on a specific set of TUs or many TUs in parallel.\n///\n///  New executors can be registered as ToolExecutorPlugins via the\n///  `ToolExecutorPluginRegistry`. CLI tools can use\n///  `createExecutorFromCommandLineArgs` to create a specific registered\n///  executor according to the command-line arguments.\nclass ToolExecutor {\npublic:\n  virtual ~ToolExecutor() {}\n\n  /// Returns the name of a specific executor.\n  virtual StringRef getExecutorName() const = 0;\n\n  /// Executes each action with a corresponding arguments adjuster.\n  virtual llvm::Error\n  execute(llvm::ArrayRef<\n          std::pair<std::unique_ptr<FrontendActionFactory>, ArgumentsAdjuster>>\n              Actions) = 0;\n\n  /// Convenient functions for the above `execute`.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action);\n  /// Executes an action with an argument adjuster.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action,\n                      ArgumentsAdjuster Adjuster);\n\n  /// Returns a reference to the execution context.\n  ///\n  /// This should be passed to tool callbacks, and tool callbacks should report\n  /// results via the returned context.\n  virtual ExecutionContext *getExecutionContext() = 0;\n\n  /// Returns a reference to the result container.\n  ///\n  /// NOTE: This should only be used after the execution finishes. Tool\n  /// callbacks should report results via `ExecutionContext` instead.\n  virtual ToolResults *getToolResults() = 0;\n\n  /// Map a virtual file to be used while running the tool.\n  ///\n  /// \\param FilePath The path at which the content will be mapped.\n  /// \\param Content A buffer of the file's content.\n  virtual void mapVirtualFile(StringRef FilePath, StringRef Content) = 0;\n};\n\n/// Interface for factories that create specific executors. This is also\n/// used as a plugin to be registered into ToolExecutorPluginRegistry.\nclass ToolExecutorPlugin {\npublic:\n  virtual ~ToolExecutorPlugin() {}\n\n  /// Create an `ToolExecutor`.\n  ///\n  /// `OptionsParser` can be consumed (e.g. moved) if the creation succeeds.\n  virtual llvm::Expected<std::unique_ptr<ToolExecutor>>\n  create(CommonOptionsParser &OptionsParser) = 0;\n};\n\n/// This creates a ToolExecutor that is in the global registry based on\n/// commandline arguments.\n///\n/// This picks the right executor based on the `--executor` option. This parses\n/// the commandline arguments with `CommonOptionsParser`, so caller does not\n/// need to parse again.\n///\n/// By default, this creates a `StandaloneToolExecutor` (\"standalone\") if\n/// `--executor` is not provided.\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgs(int &argc, const char **argv,\n                                  llvm::cl::OptionCategory &Category,\n                                  const char *Overview = nullptr);\n\nnamespace internal {\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgsImpl(int &argc, const char **argv,\n                                      llvm::cl::OptionCategory &Category,\n                                      const char *Overview = nullptr);\n} // end namespace internal\n\n} // end namespace tooling\n}",
  "id": "BLOCK-CPP-21170",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/Execution.h",
  "source_line": 36,
  "validation_status": "validated"
}