{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// random_internal::is_widening_convertible<A, B>\n//\n// Returns whether a type A is widening-convertible to a type B.\n//\n// A is widening-convertible to B means:\n//   A a = <any number>;\n//   B b = a;\n//   A c = b;\n//   EXPECT_EQ(a, c);\ntemplate <typename A, typename B>\nclass is_widening_convertible {\n  // As long as there are enough bits in the exact part of a number:\n  // - unsigned can fit in float, signed, unsigned\n  // - signed can fit in float, signed\n  // - float can fit in float\n  // So we define rank to be:\n  // - rank(float) -> 2\n  // - rank(signed) -> 1\n  // - rank(unsigned) -> 0\n  template <class T>\n  static constexpr int rank() {\n    return !std::numeric_limits<T>::is_integer +\n           std::numeric_limits<T>::is_signed;\n  }\n\n public:\n  // If an arithmetic-type B can represent at least as many digits as a type A,\n  // and B belongs to a rank no lower than A, then A can be safely represented\n  // by B through a widening-conversion.\n  static constexpr bool value =\n      std::numeric_limits<A>::digits <= std::numeric_limits<B>::digits &&\n      rank<A>() <= rank<B>();\n};\n\ntemplate <typename T>\nstruct IsIntegral : std::is_integral<T> {};\ntemplate <>\nstruct IsIntegral<absl::int128> : std::true_type {};\ntemplate <>\nstruct IsIntegral<absl::uint128> : std::true_type {};\n\ntemplate <typename T>\nstruct MakeUnsigned : std::make_unsigned<T> {};\ntemplate <>\nstruct MakeUnsigned<absl::int128> {\n  using type = absl::uint128;\n};\ntemplate <>\nstruct MakeUnsigned<absl::uint128> {\n  using type = absl::uint128;\n};\n\ntemplate <typename T>\nstruct IsUnsigned : std::is_unsigned<T> {};\ntemplate <>\nstruct IsUnsigned<absl::int128> : std::false_type {};\ntemplate <>\nstruct IsUnsigned<absl::uint128> : std::true_type {};\n\n// unsigned_bits<N>::type returns the unsigned int type with the indicated\n// number of bits.\ntemplate <size_t N>\nstruct unsigned_bits;\n\ntemplate <>\nstruct unsigned_bits<8> {\n  using type = uint8_t;\n};\ntemplate <>\nstruct unsigned_bits<16> {\n  using type = uint16_t;\n};\ntemplate <>\nstruct unsigned_bits<32> {\n  using type = uint32_t;\n};\ntemplate <>\nstruct unsigned_bits<64> {\n  using type = uint64_t;\n};\n\ntemplate <>\nstruct unsigned_bits<128> {\n  using type = absl::uint128;\n};\n\n// 256-bit wrapper for wide multiplications.\nstruct U256 {\n  uint128 hi;\n  uint128 lo;\n};\ntemplate <>\nstruct unsigned_bits<256> {\n  using type = U256;\n};\n\ntemplate <typename IntType>\nstruct make_unsigned_bits {\n  using type = typename unsigned_bits<\n      std::numeric_limits<typename MakeUnsigned<IntType>::type>::digits>::type;\n};\n\ntemplate <typename T>\nint BitWidth(T v) {\n  // Workaround for bit_width not supporting int128.\n  // Don't hardcode `64` to make sure this code does not trigger compiler\n  // warnings in smaller types.\n  constexpr int half_bits = sizeof(T) * 8 / 2;\n  if (sizeof(T) == 16 && (v >> half_bits) != 0) {\n    return bit_width(static_cast<uint64_t>(v >> half_bits)) + half_bits;\n  } else {\n    return bit_width(static_cast<uint64_t>(v));\n  }\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05982",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/traits.h",
  "source_line": 26,
  "validation_status": "validated"
}