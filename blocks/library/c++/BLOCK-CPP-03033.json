{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace str_format_internal {\n\nnamespace {\n\ninline bool BindFromPosition(int position, int* value,\n                             absl::Span<const FormatArgImpl> pack) {\n  assert(position > 0);\n  if (static_cast<size_t>(position) > pack.size()) {\n    return false;\n  }\n  // -1 because positions are 1-based\n  return FormatArgImplFriend::ToInt(pack[static_cast<size_t>(position) - 1],\n                                    value);\n}\n\nclass ArgContext {\n public:\n  explicit ArgContext(absl::Span<const FormatArgImpl> pack) : pack_(pack) {}\n\n  // Fill 'bound' with the results of applying the context's argument pack\n  // to the specified 'unbound'. We synthesize a BoundConversion by\n  // lining up a UnboundConversion with a user argument. We also\n  // resolve any '*' specifiers for width and precision, so after\n  // this call, 'bound' has all the information it needs to be formatted.\n  // Returns false on failure.\n  bool Bind(const UnboundConversion* unbound, BoundConversion* bound);\n\n private:\n  absl::Span<const FormatArgImpl> pack_;\n};\n\ninline bool ArgContext::Bind(const UnboundConversion* unbound,\n                             BoundConversion* bound) {\n  const FormatArgImpl* arg = nullptr;\n  int arg_position = unbound->arg_position;\n  if (static_cast<size_t>(arg_position - 1) >= pack_.size()) return false;\n  arg = &pack_[static_cast<size_t>(arg_position - 1)];  // 1-based\n\n  if (unbound->flags != Flags::kBasic) {\n    int width = unbound->width.value();\n    bool force_left = false;\n    if (unbound->width.is_from_arg()) {\n      if (!BindFromPosition(unbound->width.get_from_arg(), &width, pack_))\n        return false;\n      if (width < 0) {\n        // \"A negative field width is taken as a '-' flag followed by a\n        // positive field width.\"\n        force_left = true;\n        // Make sure we don't overflow the width when negating it.\n        width = -std::max(width, -std::numeric_limits<int>::max());\n      }\n    }\n\n    int precision = unbound->precision.value();\n    if (unbound->precision.is_from_arg()) {\n      if (!BindFromPosition(unbound->precision.get_from_arg(), &precision,\n                            pack_))\n        return false;\n    }\n\n    FormatConversionSpecImplFriend::SetWidth(width, bound);\n    FormatConversionSpecImplFriend::SetPrecision(precision, bound);\n\n    if (force_left) {\n      FormatConversionSpecImplFriend::SetFlags(unbound->flags | Flags::kLeft,\n                                               bound);\n    } else {\n      FormatConversionSpecImplFriend::SetFlags(unbound->flags, bound);\n    }\n\n    FormatConversionSpecImplFriend::SetLengthMod(unbound->length_mod, bound);\n  } else {\n    FormatConversionSpecImplFriend::SetFlags(unbound->flags, bound);\n    FormatConversionSpecImplFriend::SetWidth(-1, bound);\n    FormatConversionSpecImplFriend::SetPrecision(-1, bound);\n  }\n  FormatConversionSpecImplFriend::SetConversionChar(unbound->conv, bound);\n  bound->set_arg(arg);\n  return true;\n}\n\ntemplate <typename Converter>\nclass ConverterConsumer {\n public:\n  ConverterConsumer(Converter converter, absl::Span<const FormatArgImpl> pack)\n      : converter_(converter), arg_context_(pack) {}\n\n  bool Append(string_view s) {\n    converter_.Append(s);\n    return true;\n  }\n  bool ConvertOne(const UnboundConversion& conv, string_view conv_string) {\n    BoundConversion bound;\n    if (!arg_context_.Bind(&conv, &bound)) return false;\n    return converter_.ConvertOne(bound, conv_string);\n  }\n\n private:\n  Converter converter_;\n  ArgContext arg_context_;\n};\n\ntemplate <typename Converter>\nbool ConvertAll(const UntypedFormatSpecImpl format,\n                absl::Span<const FormatArgImpl> args, Converter converter) {\n  if (format.has_parsed_conversion()) {\n    return format.parsed_conversion()->ProcessFormat(\n        ConverterConsumer<Converter>(converter, args));\n  } else {\n    return ParseFormatString(format.str(),\n                             ConverterConsumer<Converter>(converter, args));\n  }\n}\n\nclass DefaultConverter {\n public:\n  explicit DefaultConverter(FormatSinkImpl* sink) : sink_(sink) {}\n\n  void Append(string_view s) const { sink_->Append(s); }\n\n  bool ConvertOne(const BoundConversion& bound, string_view /*conv*/) const {\n    return FormatArgImplFriend::Convert(*bound.arg(), bound, sink_);\n  }\n\n private:\n  FormatSinkImpl* sink_;\n};\n\nclass SummarizingConverter {\n public:\n  explicit SummarizingConverter(FormatSinkImpl* sink) : sink_(sink) {}\n\n  void Append(string_view s) const { sink_->Append(s); }\n\n  bool ConvertOne(const BoundConversion& bound, string_view /*conv*/) const {\n    UntypedFormatSpecImpl spec(\"%d\");\n\n    std::ostringstream ss;\n    ss << \"{\" << Streamable(spec, {*bound.arg()}) << \":\"\n       << FormatConversionSpecImplFriend::FlagsToString(bound);\n    if (bound.width() >= 0) ss << bound.width();\n    if (bound.precision() >= 0) ss << \".\" << bound.precision();\n    ss << bound.conversion_char() << \"}\";\n    Append(ss.str());\n    return true;\n  }\n\n private:\n  FormatSinkImpl* sink_;\n};\n\n}  // namespace\n\nbool BindWithPack(const UnboundConversion* props,\n                  absl::Span<const FormatArgImpl> pack,\n                  BoundConversion* bound) {\n  return ArgContext(pack).Bind(props, bound);\n}\n\nstd::string Summarize(const UntypedFormatSpecImpl format,\n                      absl::Span<const FormatArgImpl> args) {\n  typedef SummarizingConverter Converter;\n  std::string out;\n  {\n    // inner block to destroy sink before returning out. It ensures a last\n    // flush.\n    FormatSinkImpl sink(&out);\n    if (!ConvertAll(format, args, Converter(&sink))) {\n      return \"\";\n    }\n  }\n  return out;\n}\n\nbool FormatUntyped(FormatRawSinkImpl raw_sink,\n                   const UntypedFormatSpecImpl format,\n                   absl::Span<const FormatArgImpl> args) {\n  FormatSinkImpl sink(raw_sink);\n  using Converter = DefaultConverter;\n  return ConvertAll(format, args, Converter(&sink));\n}\n\nstd::ostream& Streamable::Print(std::ostream& os) const {\n  if (!FormatUntyped(&os, format_, args_)) os.setstate(std::ios::failbit);\n  return os;\n}\n\nstd::string& AppendPack(std::string* out, const UntypedFormatSpecImpl format,\n                        absl::Span<const FormatArgImpl> args) {\n  size_t orig = out->size();\n  if (ABSL_PREDICT_FALSE(!FormatUntyped(out, format, args))) {\n    out->erase(orig);\n  }\n  return *out;\n}\n\nstd::string FormatPack(UntypedFormatSpecImpl format,\n                       absl::Span<const FormatArgImpl> args) {\n  std::string out;\n  if (ABSL_PREDICT_FALSE(!FormatUntyped(&out, format, args))) {\n    out.clear();\n  }\n  return out;\n}\n\nint FprintF(std::FILE* output, const UntypedFormatSpecImpl format,\n            absl::Span<const FormatArgImpl> args) {\n  FILERawSink sink(output);\n  if (!FormatUntyped(&sink, format, args)) {\n    errno = EINVAL;\n    return -1;\n  }\n  if (sink.error()) {\n    errno = sink.error();\n    return -1;\n  }\n  if (sink.count() > static_cast<size_t>(std::numeric_limits<int>::max())) {\n    errno = EFBIG;\n    return -1;\n  }\n  return static_cast<int>(sink.count());\n}\n\nint SnprintF(char* output, size_t size, const UntypedFormatSpecImpl format,\n             absl::Span<const FormatArgImpl> args) {\n  BufferRawSink sink(output, size ? size - 1 : 0);\n  if (!FormatUntyped(&sink, format, args)) {\n    errno = EINVAL;\n    return -1;\n  }\n  size_t total = sink.total_written();\n  if (size) output[std::min(total, size - 1)] = 0;\n  return static_cast<int>(total);\n}\n\n}  // namespace str_format_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03033",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/bind.cc",
  "source_line": 36,
  "validation_status": "validated"
}