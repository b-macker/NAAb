{
  "code": "{\n\ntemplate <class T>\nstruct NotAligned {};\n\ntemplate <class T, size_t N>\nstruct NotAligned<const Aligned<T, N>> {\n  static_assert(sizeof(T) == 0, \"Aligned<T, N> cannot be const-qualified\");\n};\n\ntemplate <size_t>\nusing IntToSize = size_t;\n\ntemplate <class>\nusing TypeToSize = size_t;\n\ntemplate <class T>\nstruct Type : NotAligned<T> {\n  using type = T;\n};\n\ntemplate <class T, size_t N>\nstruct Type<Aligned<T, N>> {\n  using type = T;\n};\n\ntemplate <class T>\nstruct SizeOf : NotAligned<T>, std::integral_constant<size_t, sizeof(T)> {};\n\ntemplate <class T, size_t N>\nstruct SizeOf<Aligned<T, N>> : std::integral_constant<size_t, sizeof(T)> {};\n\n// Note: workaround for https://gcc.gnu.org/PR88115\ntemplate <class T>\nstruct AlignOf : NotAligned<T> {\n  static constexpr size_t value = alignof(T);\n};\n\ntemplate <class T, size_t N>\nstruct AlignOf<Aligned<T, N>> {\n  static_assert(N % alignof(T) == 0,\n                \"Custom alignment can't be lower than the type's alignment\");\n  static constexpr size_t value = N;\n};\n\n// Does `Ts...` contain `T`?\ntemplate <class T, class... Ts>\nusing Contains = absl::disjunction<std::is_same<T, Ts>...>;\n\ntemplate <class From, class To>\nusing CopyConst =\n    typename std::conditional<std::is_const<From>::value, const To, To>::type;\n\n// Note: We're not qualifying this with absl:: because it doesn't compile under\n// MSVC.\ntemplate <class T>\nusing SliceType = Span<T>;\n\n// This namespace contains no types. It prevents functions defined in it from\n// being found by ADL.\nnamespace adl_barrier {\n\ntemplate <class Needle, class... Ts>\nconstexpr size_t Find(Needle, Needle, Ts...) {\n  static_assert(!Contains<Needle, Ts...>(), \"Duplicate element type\");\n  return 0;\n}\n\ntemplate <class Needle, class T, class... Ts>\nconstexpr size_t Find(Needle, T, Ts...) {\n  return adl_barrier::Find(Needle(), Ts()...) + 1;\n}\n\nconstexpr bool IsPow2(size_t n) { return !(n & (n - 1)); }\n\n// Returns `q * m` for the smallest `q` such that `q * m >= n`.\n// Requires: `m` is a power of two. It's enforced by IsLegalElementType below.\nconstexpr size_t Align(size_t n, size_t m) { return (n + m - 1) & ~(m - 1); }\n\nconstexpr size_t Min(size_t a, size_t b) { return b < a ? b : a; }\n\nconstexpr size_t Max(size_t a) { return a; }\n\ntemplate <class... Ts>\nconstexpr size_t Max(size_t a, size_t b, Ts... rest) {\n  return adl_barrier::Max(b < a ? a : b, rest...);\n}\n\ntemplate <class T>\nstd::string TypeName() {\n  std::string out;\n#if ABSL_INTERNAL_HAS_RTTI\n  absl::StrAppend(&out, \"<\",\n                  absl::debugging_internal::DemangleString(typeid(T).name()),\n                  \">\");\n#endif\n  return out;\n}\n\n}  // namespace adl_barrier\n\ntemplate <bool C>\nusing EnableIf = typename std::enable_if<C, int>::type;\n\n// Can `T` be a template argument of `Layout`?\ntemplate <class T>\nusing IsLegalElementType = std::integral_constant<\n    bool, !std::is_reference<T>::value && !std::is_volatile<T>::value &&\n              !std::is_reference<typename Type<T>::type>::value &&\n              !std::is_volatile<typename Type<T>::type>::value &&\n              adl_barrier::IsPow2(AlignOf<T>::value)>;\n\ntemplate <class Elements, class SizeSeq, class OffsetSeq>\nclass LayoutImpl;\n\n// Public base class of `Layout` and the result type of `Layout::Partial()`.\n//\n// `Elements...` contains all template arguments of `Layout` that created this\n// instance.\n//\n// `SizeSeq...` is `[0, NumSizes)` where `NumSizes` is the number of arguments\n// passed to `Layout::Partial()` or `Layout::Layout()`.\n//\n// `OffsetSeq...` is `[0, NumOffsets)` where `NumOffsets` is\n// `Min(sizeof...(Elements), NumSizes + 1)` (the number of arrays for which we\n// can compute offsets).\ntemplate <class... Elements, size_t... SizeSeq, size_t... OffsetSeq>\nclass LayoutImpl<std::tuple<Elements...>, absl::index_sequence<SizeSeq...>,\n                 absl::index_sequence<OffsetSeq...>> {\n private:\n  static_assert(sizeof...(Elements) > 0, \"At least one field is required\");\n  static_assert(absl::conjunction<IsLegalElementType<Elements>...>::value,\n                \"Invalid element type (see IsLegalElementType)\");\n\n  enum {\n    NumTypes = sizeof...(Elements),\n    NumSizes = sizeof...(SizeSeq),\n    NumOffsets = sizeof...(OffsetSeq),\n  };\n\n  // These are guaranteed by `Layout`.\n  static_assert(NumOffsets == adl_barrier::Min(NumTypes, NumSizes + 1),\n                \"Internal error\");\n  static_assert(NumTypes > 0, \"Internal error\");\n\n  // Returns the index of `T` in `Elements...`. Results in a compilation error\n  // if `Elements...` doesn't contain exactly one instance of `T`.\n  template <class T>\n  static constexpr size_t ElementIndex() {\n    static_assert(Contains<Type<T>, Type<typename Type<Elements>::type>...>(),\n                  \"Type not found\");\n    return adl_barrier::Find(Type<T>(),\n                             Type<typename Type<Elements>::type>()...);\n  }\n\n  template <size_t N>\n  using ElementAlignment =\n      AlignOf<typename std::tuple_element<N, std::tuple<Elements...>>::type>;\n\n public:\n  // Element types of all arrays packed in a tuple.\n  using ElementTypes = std::tuple<typename Type<Elements>::type...>;\n\n  // Element type of the Nth array.\n  template <size_t N>\n  using ElementType = typename std::tuple_element<N, ElementTypes>::type;\n\n  constexpr explicit LayoutImpl(IntToSize<SizeSeq>... sizes)\n      : size_{sizes...} {}\n\n  // Alignment of the layout, equal to the strictest alignment of all elements.\n  // All pointers passed to the methods of layout must be aligned to this value.\n  static constexpr size_t Alignment() {\n    return adl_barrier::Max(AlignOf<Elements>::value...);\n  }\n\n  // Offset in bytes of the Nth array.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   assert(x.Offset<0>() == 0);   // The ints starts from 0.\n  //   assert(x.Offset<1>() == 16);  // The doubles starts from 16.\n  //\n  // Requires: `N <= NumSizes && N < sizeof...(Ts)`.\n  template <size_t N, EnableIf<N == 0> = 0>\n  constexpr size_t Offset() const {\n    return 0;\n  }\n\n  template <size_t N, EnableIf<N != 0> = 0>\n  constexpr size_t Offset() const {\n    static_assert(N < NumOffsets, \"Index out of bounds\");\n    return adl_barrier::Align(\n        Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1],\n        ElementAlignment<N>::value);\n  }\n\n  // Offset in bytes of the array with the specified element type. There must\n  // be exactly one such array and its zero-based index must be at most\n  // `NumSizes`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   assert(x.Offset<int>() == 0);      // The ints starts from 0.\n  //   assert(x.Offset<double>() == 16);  // The doubles starts from 16.\n  template <class T>\n  constexpr size_t Offset() const {\n    return Offset<ElementIndex<T>()>();\n  }\n\n  // Offsets in bytes of all arrays for which the offsets are known.\n  constexpr std::array<size_t, NumOffsets> Offsets() const {\n    return {{Offset<OffsetSeq>()...}};\n  }\n\n  // The number of elements in the Nth array. This is the Nth argument of\n  // `Layout::Partial()` or `Layout::Layout()` (zero-based).\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   assert(x.Size<0>() == 3);\n  //   assert(x.Size<1>() == 4);\n  //\n  // Requires: `N < NumSizes`.\n  template <size_t N>\n  constexpr size_t Size() const {\n    static_assert(N < NumSizes, \"Index out of bounds\");\n    return size_[N];\n  }\n\n  // The number of elements in the array with the specified element type.\n  // There must be exactly one such array and its zero-based index must be\n  // at most `NumSizes`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   assert(x.Size<int>() == 3);\n  //   assert(x.Size<double>() == 4);\n  template <class T>\n  constexpr size_t Size() const {\n    return Size<ElementIndex<T>()>();\n  }\n\n  // The number of elements of all arrays for which they are known.\n  constexpr std::array<size_t, NumSizes> Sizes() const {\n    return {{Size<SizeSeq>()...}};\n  }\n\n  // Pointer to the beginning of the Nth array.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //   int* ints = x.Pointer<0>(p);\n  //   double* doubles = x.Pointer<1>(p);\n  //\n  // Requires: `N <= NumSizes && N < sizeof...(Ts)`.\n  // Requires: `p` is aligned to `Alignment()`.\n  template <size_t N, class Char>\n  CopyConst<Char, ElementType<N>>* Pointer(Char* p) const {\n    using C = typename std::remove_const<Char>::type;\n    static_assert(\n        std::is_same<C, char>() || std::is_same<C, unsigned char>() ||\n            std::is_same<C, signed char>(),\n        \"The argument must be a pointer to [const] [signed|unsigned] char\");\n    constexpr size_t alignment = Alignment();\n    (void)alignment;\n    assert(reinterpret_cast<uintptr_t>(p) % alignment == 0);\n    return reinterpret_cast<CopyConst<Char, ElementType<N>>*>(p + Offset<N>());\n  }\n\n  // Pointer to the beginning of the array with the specified element type.\n  // There must be exactly one such array and its zero-based index must be at\n  // most `NumSizes`.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //   int* ints = x.Pointer<int>(p);\n  //   double* doubles = x.Pointer<double>(p);\n  //\n  // Requires: `p` is aligned to `Alignment()`.\n  template <class T, class Char>\n  CopyConst<Char, T>* Pointer(Char* p) const {\n    return Pointer<ElementIndex<T>()>(p);\n  }\n\n  // Pointers to all arrays for which pointers are known.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //\n  //   int* ints;\n  //   double* doubles;\n  //   std::tie(ints, doubles) = x.Pointers(p);\n  //\n  // Requires: `p` is aligned to `Alignment()`.\n  //\n  // Note: We're not using ElementType alias here because it does not compile\n  // under MSVC.\n  template <class Char>\n  std::tuple<CopyConst<\n      Char, typename std::tuple_element<OffsetSeq, ElementTypes>::type>*...>\n  Pointers(Char* p) const {\n    return std::tuple<CopyConst<Char, ElementType<OffsetSeq>>*...>(\n        Pointer<OffsetSeq>(p)...);\n  }\n\n  // The Nth array.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //   Span<int> ints = x.Slice<0>(p);\n  //   Span<double> doubles = x.Slice<1>(p);\n  //\n  // Requires: `N < NumSizes`.\n  // Requires: `p` is aligned to `Alignment()`.\n  template <size_t N, class Char>\n  SliceType<CopyConst<Char, ElementType<N>>> Slice(Char* p) const {\n    return SliceType<CopyConst<Char, ElementType<N>>>(Pointer<N>(p), Size<N>());\n  }\n\n  // The array with the specified element type. There must be exactly one\n  // such array and its zero-based index must be less than `NumSizes`.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //   Span<int> ints = x.Slice<int>(p);\n  //   Span<double> doubles = x.Slice<double>(p);\n  //\n  // Requires: `p` is aligned to `Alignment()`.\n  template <class T, class Char>\n  SliceType<CopyConst<Char, T>> Slice(Char* p) const {\n    return Slice<ElementIndex<T>()>(p);\n  }\n\n  // All arrays with known sizes.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];\n  //\n  //   Span<int> ints;\n  //   Span<double> doubles;\n  //   std::tie(ints, doubles) = x.Slices(p);\n  //\n  // Requires: `p` is aligned to `Alignment()`.\n  //\n  // Note: We're not using ElementType alias here because it does not compile\n  // under MSVC.\n  template <class Char>\n  std::tuple<SliceType<CopyConst<\n      Char, typename std::tuple_element<SizeSeq, ElementTypes>::type>>...>\n  Slices(Char* p) const {\n    // Workaround for https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63875 (fixed\n    // in 6.1).\n    (void)p;\n    return std::tuple<SliceType<CopyConst<Char, ElementType<SizeSeq>>>...>(\n        Slice<SizeSeq>(p)...);\n  }\n\n  // The size of the allocation that fits all arrays.\n  //\n  //   // int[3], 4 bytes of padding, double[4].\n  //   Layout<int, double> x(3, 4);\n  //   unsigned char* p = new unsigned char[x.AllocSize()];  // 48 bytes\n  //\n  // Requires: `NumSizes == sizeof...(Ts)`.\n  constexpr size_t AllocSize() const {\n    static_assert(NumTypes == NumSizes, \"You must specify sizes of all fields\");\n    return Offset<NumTypes - 1>() +\n        SizeOf<ElementType<NumTypes - 1>>::value * size_[NumTypes - 1];\n  }\n\n  // If built with --config=asan, poisons padding bytes (if any) in the\n  // allocation. The pointer must point to a memory block at least\n  // `AllocSize()` bytes in length.\n  //\n  // `Char` must be `[const] [signed|unsigned] char`.\n  //\n  // Requires: `p` is aligned to `Alignment()`.\n  template <class Char, size_t N = NumOffsets - 1, EnableIf<N == 0> = 0>\n  void PoisonPadding(const Char* p) const {\n    Pointer<0>(p);  // verify the requirements on `Char` and `p`\n  }\n\n  template <class Char, size_t N = NumOffsets - 1, EnableIf<N != 0> = 0>\n  void PoisonPadding(const Char* p) const {\n    static_assert(N < NumOffsets, \"Index out of bounds\");\n    (void)p;\n#ifdef ABSL_HAVE_ADDRESS_SANITIZER\n    PoisonPadding<Char, N - 1>(p);\n    // The `if` is an optimization. It doesn't affect the observable behaviour.\n    if (ElementAlignment<N - 1>::value % ElementAlignment<N>::value) {\n      size_t start =\n          Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1];\n      ASAN_POISON_MEMORY_REGION(p + start, Offset<N>() - start);\n    }\n#endif\n  }\n\n  // Human-readable description of the memory layout. Useful for debugging.\n  // Slow.\n  //\n  //   // char[5], 3 bytes of padding, int[3], 4 bytes of padding, followed\n  //   // by an unknown number of doubles.\n  //   auto x = Layout<char, int, double>::Partial(5, 3);\n  //   assert(x.DebugString() ==\n  //          \"@0<char>(1)[5]; @8<int>(4)[3]; @24<double>(8)\");\n  //\n  // Each field is in the following format: @offset<type>(sizeof)[size] (<type>\n  // may be missing depending on the target platform). For example,\n  // @8<int>(4)[3] means that at offset 8 we have an array of ints, where each\n  // int is 4 bytes, and we have 3 of those ints. The size of the last field may\n  // be missing (as in the example above). Only fields with known offsets are\n  // described. Type names may differ across platforms: one compiler might\n  // produce \"unsigned*\" where another produces \"unsigned int *\".\n  std::string DebugString() const {\n    const auto offsets = Offsets();\n    const size_t sizes[] = {SizeOf<ElementType<OffsetSeq>>::value...};\n    const std::string types[] = {\n        adl_barrier::TypeName<ElementType<OffsetSeq>>()...};\n    std::string res = absl::StrCat(\"@0\", types[0], \"(\", sizes[0], \")\");\n    for (size_t i = 0; i != NumOffsets - 1; ++i) {\n      absl::StrAppend(&res, \"[\", size_[i], \"]; @\", offsets[i + 1], types[i + 1],\n                      \"(\", sizes[i + 1], \")\");\n    }\n    // NumSizes is a constant that may be zero. Some compilers cannot see that\n    // inside the if statement \"size_[NumSizes - 1]\" must be valid.\n    int last = static_cast<int>(NumSizes) - 1;\n    if (NumTypes == NumSizes && last >= 0) {\n      absl::StrAppend(&res, \"[\", size_[last], \"]\");\n    }\n    return res;\n  }\n\n private:\n  // Arguments of `Layout::Partial()` or `Layout::Layout()`.\n  size_t size_[NumSizes > 0 ? NumSizes : 1];\n};\n\ntemplate <size_t NumSizes, class... Ts>\nusing LayoutType = LayoutImpl<\n    std::tuple<Ts...>, absl::make_index_sequence<NumSizes>,\n    absl::make_index_sequence<adl_barrier::Min(sizeof...(Ts), NumSizes + 1)>>;\n\n}",
  "id": "BLOCK-CPP-05125",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/layout.h",
  "source_line": 199,
  "validation_status": "validated"
}