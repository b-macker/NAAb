{
  "code": "{\nprivate:\n  T *Begin = nullptr;\n  T *End = nullptr;\n  llvm::PointerIntPair<T *, 1, bool> Capacity;\n\n  void setEnd(T *P) { this->End = P; }\n\nprotected:\n  // Make a tag bit available to users of this class.\n  // FIXME: This is a horrible hack.\n  bool getTag() const { return Capacity.getInt(); }\n  void setTag(bool B) { Capacity.setInt(B); }\n\npublic:\n  // Default ctor - Initialize to empty.\n  ASTVector() : Capacity(nullptr, false) {}\n\n  ASTVector(ASTVector &&O) : Begin(O.Begin), End(O.End), Capacity(O.Capacity) {\n    O.Begin = O.End = nullptr;\n    O.Capacity.setPointer(nullptr);\n    O.Capacity.setInt(false);\n  }\n\n  ASTVector(const ASTContext &C, unsigned N) : Capacity(nullptr, false) {\n    reserve(C, N);\n  }\n\n  ASTVector &operator=(ASTVector &&RHS) {\n    ASTVector O(std::move(RHS));\n\n    using std::swap;\n\n    swap(Begin, O.Begin);\n    swap(End, O.End);\n    swap(Capacity, O.Capacity);\n    return *this;\n  }\n\n  ~ASTVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin()            { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend()              { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, const ASTContext &C) {\n    if (End < this->capacity_ptr()) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  void reserve(const ASTContext &C, unsigned N) {\n    if (unsigned(this->capacity_ptr()-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return this->capacity_ptr() - Begin; }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  template<typename in_iter>\n  void append(const ASTContext &C, in_iter in_start, in_iter in_end) {\n    size_type NumInputs = std::distance(in_start, in_end);\n\n    if (NumInputs == 0)\n      return;\n\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    // TODO: NEED To compile time dispatch on whether in_iter is a random access\n    // iterator to use the fast uninitialized_copy.\n    std::uninitialized_copy(in_start, in_end, this->end());\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  void append(const ASTContext &C, size_type NumInputs, const T &Elt) {\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    std::uninitialized_fill_n(this->end(), NumInputs, Elt);\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  iterator insert(const ASTContext &C, iterator I, const T &Elt) {\n    if (I == this->end()) {  // Important special case for empty vector.\n      push_back(Elt, C);\n      return this->end()-1;\n    }\n\n    if (this->End < this->capacity_ptr()) {\n    Retry:\n      new (this->end()) T(this->back());\n      this->setEnd(this->end()+1);\n      // Push everything else over.\n      std::copy_backward(I, this->end()-1, this->end());\n      *I = Elt;\n      return I;\n    }\n    size_t EltNo = I-this->begin();\n    this->grow(C);\n    I = this->begin()+EltNo;\n    goto Retry;\n  }\n\n  iterator insert(const ASTContext &C, iterator I, size_type NumToInsert,\n                  const T &Elt) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, NumToInsert, Elt);\n      return this->begin() + InsertElt;\n    }\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::fill_n(I, NumToInsert, Elt);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    std::fill_n(I, NumOverwritten, Elt);\n\n    // Insert the non-overwritten middle part.\n    std::uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt);\n    return I;\n  }\n\n  template<typename ItTy>\n  iterator insert(const ASTContext &C, iterator I, ItTy From, ItTy To) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, From, To);\n      return this->begin() + InsertElt;\n    }\n\n    size_t NumToInsert = std::distance(From, To);\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::copy(From, To, I);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    for (; NumOverwritten > 0; --NumOverwritten) {\n      *I = *From;\n      ++I; ++From;\n    }\n\n    // Insert the non-overwritten middle part.\n    this->uninitialized_copy(From, To, OldEnd);\n    return I;\n  }\n\n  void resize(const ASTContext &C, unsigned N, const T &NV) {\n    if (N < this->size()) {\n      this->destroy_range(this->begin()+N, this->end());\n      this->setEnd(this->begin()+N);\n    } else if (N > this->size()) {\n      if (this->capacity() < N)\n        this->grow(C, N);\n      construct_range(this->end(), this->begin()+N, NV);\n      this->setEnd(this->begin()+N);\n    }\n  }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(const ASTContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\nprotected:\n  const_iterator capacity_ptr() const {\n    return (iterator) Capacity.getPointer();\n  }\n\n  iterator capacity_ptr() { return (iterator)Capacity.getPointer(); }\n}",
  "id": "BLOCK-CPP-23090",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTVector.h",
  "source_line": 35,
  "validation_status": "validated"
}