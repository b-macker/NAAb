{
  "code": "{\n///     friend void foo<>(T);\n///   };\n/// \\endcode\nclass DependentFunctionTemplateSpecializationInfo final\n    : private llvm::TrailingObjects<DependentFunctionTemplateSpecializationInfo,\n                                    TemplateArgumentLoc,\n                                    FunctionTemplateDecl *> {\n  /// The number of potential template candidates.\n  unsigned NumTemplates;\n\n  /// The number of template arguments.\n  unsigned NumArgs;\n\n  /// The locations of the left and right angle brackets.\n  SourceRange AngleLocs;\n\n  size_t numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return NumArgs;\n  }\n  size_t numTrailingObjects(OverloadToken<FunctionTemplateDecl *>) const {\n    return NumTemplates;\n  }\n\n  DependentFunctionTemplateSpecializationInfo(\n                                 const UnresolvedSetImpl &Templates,\n                                 const TemplateArgumentListInfo &TemplateArgs);\n\npublic:\n  friend TrailingObjects;\n\n  static DependentFunctionTemplateSpecializationInfo *\n  Create(ASTContext &Context, const UnresolvedSetImpl &Templates,\n         const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Returns the number of function templates that this might\n  /// be a specialization of.\n  unsigned getNumTemplates() const { return NumTemplates; }\n\n  /// Returns the i'th template candidate.\n  FunctionTemplateDecl *getTemplate(unsigned I) const {\n    assert(I < getNumTemplates() && \"template index out of range\");\n    return getTrailingObjects<FunctionTemplateDecl *>()[I];\n  }\n\n  /// Returns the explicit template arguments that were given.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Returns the number of explicit template arguments that were given.\n  unsigned getNumTemplateArgs() const { return NumArgs; }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return llvm::ArrayRef(getTemplateArgs(), getNumTemplateArgs());\n  }\n\n  /// Returns the nth template argument.\n  const TemplateArgumentLoc &getTemplateArg(unsigned I) const {\n    assert(I < getNumTemplateArgs() && \"template arg index out of range\");\n    return getTemplateArgs()[I];\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return AngleLocs.getBegin();\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return AngleLocs.getEnd();\n  }\n};\n\n/// Declaration of a redeclarable template.\nclass RedeclarableTemplateDecl : public TemplateDecl,\n                                 public Redeclarable<RedeclarableTemplateDecl>\n{\n  using redeclarable_base = Redeclarable<RedeclarableTemplateDecl>;\n\n  RedeclarableTemplateDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  RedeclarableTemplateDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  RedeclarableTemplateDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  void anchor() override;\nprotected:\n  template <typename EntryType> struct SpecEntryTraits {\n    using DeclType = EntryType;\n\n    static DeclType *getDecl(EntryType *D) {\n      return D;\n    }\n\n    static ArrayRef<TemplateArgument> getTemplateArgs(EntryType *D) {\n      return D->getTemplateArgs().asArray();\n    }\n  };\n\n  template <typename EntryType, typename SETraits = SpecEntryTraits<EntryType>,\n            typename DeclType = typename SETraits::DeclType>\n  struct SpecIterator\n      : llvm::iterator_adaptor_base<\n            SpecIterator<EntryType, SETraits, DeclType>,\n            typename llvm::FoldingSetVector<EntryType>::iterator,\n            typename std::iterator_traits<typename llvm::FoldingSetVector<\n                EntryType>::iterator>::iterator_category,\n            DeclType *, ptrdiff_t, DeclType *, DeclType *> {\n    SpecIterator() = default;\n    explicit SpecIterator(\n        typename llvm::FoldingSetVector<EntryType>::iterator SetIter)\n        : SpecIterator::iterator_adaptor_base(std::move(SetIter)) {}\n\n    DeclType *operator*() const {\n      return SETraits::getDecl(&*this->I)->getMostRecentDecl();\n    }\n\n    DeclType *operator->() const { return **this; }\n  };\n\n  template <typename EntryType>\n  static SpecIterator<EntryType>\n  makeSpecIterator(llvm::FoldingSetVector<EntryType> &Specs, bool isEnd) {\n    return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());\n  }\n\n  void loadLazySpecializationsImpl() const;\n\n  template <class EntryType, typename ...ProfileArguments>\n  typename SpecEntryTraits<EntryType>::DeclType*\n  findSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                         void *&InsertPos, ProfileArguments &&...ProfileArgs);\n\n  template <class Derived, class EntryType>\n  void addSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                             EntryType *Entry, void *InsertPos);\n\n  struct CommonBase {\n    CommonBase() : InstantiatedFromMember(nullptr, false) {}\n\n    /// The template from which this was most\n    /// directly instantiated (or null).\n    ///\n    /// The boolean value indicates whether this template\n    /// was explicitly specialized.\n    llvm::PointerIntPair<RedeclarableTemplateDecl*, 1, bool>\n      InstantiatedFromMember;\n\n    /// If non-null, points to an array of specializations (including\n    /// partial specializations) known only by their external declaration IDs.\n    ///\n    /// The first value in the array is the number of specializations/partial\n    /// specializations that follow.\n    uint32_t *LazySpecializations = nullptr;\n\n    /// The set of \"injected\" template arguments used within this\n    /// template.\n    ///\n    /// This pointer refers to the template arguments (there are as\n    /// many template arguments as template parameters) for the\n    /// template, and is allocated lazily, since most templates do not\n    /// require the use of this information.\n    TemplateArgument *InjectedArgs = nullptr;\n  };\n\n  /// Pointer to the common data shared by all declarations of this\n  /// template.\n  mutable CommonBase *Common = nullptr;\n\n  /// Retrieves the \"common\" pointer shared by all (re-)declarations of\n  /// the same template. Calling this routine may implicitly allocate memory\n  /// for the common pointer.\n  CommonBase *getCommonPtr() const;\n\n  virtual CommonBase *newCommon(ASTContext &C) const = 0;\n\n  // Construct a template decl with name, parameters, and templated element.\n  RedeclarableTemplateDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                           SourceLocation L, DeclarationName Name,\n                           TemplateParameterList *Params, NamedDecl *Decl)\n      : TemplateDecl(DK, DC, L, Name, Params, Decl), redeclarable_base(C) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n  template <class decl_type> friend class RedeclarableTemplate;\n\n  /// Retrieves the canonical declaration of this template.\n  RedeclarableTemplateDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const RedeclarableTemplateDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Determines whether this template was a specialization of a\n  /// member template.\n  ///\n  /// In the following example, the function template \\c X<int>::f and the\n  /// member template \\c X<int>::Inner are member specializations.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  ///   template<typename U> struct Inner;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// void X<int>::f(int, T);\n  /// template<> template<typename T>\n  /// struct X<int>::Inner { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() const {\n    return getCommonPtr()->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    assert(getCommonPtr()->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    getCommonPtr()->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieve the member template from which this template was\n  /// instantiated, or nullptr if this template was not instantiated from a\n  /// member template.\n  ///\n  /// A template is instantiated from a member template when the member\n  /// template itself is part of a class template (or member thereof). For\n  /// example, given\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  /// };\n  ///\n  /// void test(X<int> x) {\n  ///   x.f(1, 'a');\n  /// };\n  /// \\endcode\n  ///\n  /// \\c X<int>::f is a FunctionTemplateDecl that describes the function\n  /// template\n  ///\n  /// \\code\n  /// template<typename U> void X<int>::f(int, U);\n  /// \\endcode\n  ///\n  /// which was itself created during the instantiation of \\c X<int>. Calling\n  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will\n  /// retrieve the FunctionTemplateDecl for the original template \\c f within\n  /// the class template \\c X<T>, i.e.,\n  ///\n  /// \\code\n  /// template<typename T>\n  /// template<typename U>\n  /// void X<T>::f(T, U);\n  /// \\endcode\n  RedeclarableTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return getCommonPtr()->InstantiatedFromMember.getPointer();\n  }\n\n  void setInstantiatedFromMemberTemplate(RedeclarableTemplateDecl *TD) {\n    assert(!getCommonPtr()->InstantiatedFromMember.getPointer());\n    getCommonPtr()->InstantiatedFromMember.setPointer(TD);\n  }\n\n  /// Retrieve the \"injected\" template arguments that correspond to the\n  /// template parameters of this template.\n  ///\n  /// Although the C++ standard has no notion of the \"injected\" template\n  /// arguments for a template, the notion is convenient when\n  /// we need to perform substitutions inside the definition of a template.\n  ArrayRef<TemplateArgument> getInjectedTemplateArgs();\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstRedeclarableTemplate && K <= lastRedeclarableTemplate;\n  }\n};\n\ntemplate <> struct RedeclarableTemplateDecl::\nSpecEntryTraits<FunctionTemplateSpecializationInfo> {\n  using DeclType = FunctionDecl;\n\n  static DeclType *getDecl(FunctionTemplateSpecializationInfo *I) {\n    return I->getFunction();\n  }\n\n  static ArrayRef<TemplateArgument>\n  getTemplateArgs(FunctionTemplateSpecializationInfo *I) {\n    return I->TemplateArguments->asArray();\n  }\n};\n\n/// Declaration of a template function.\nclass FunctionTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  friend class FunctionDecl;\n\n  /// Data that is common to all of the declarations of a given\n  /// function template.\n  struct Common : CommonBase {\n    /// The function template specializations for this function\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> Specializations;\n\n    Common() = default;\n  };\n\n  FunctionTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                       DeclarationName Name, TemplateParameterList *Params,\n                       NamedDecl *Decl)\n      : RedeclarableTemplateDecl(FunctionTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  /// Retrieve the set of function template specializations of this\n  /// function template.\n  llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> &\n  getSpecializations() const;\n\n  /// Add a specialization of this function template.\n  ///\n  /// \\param InsertPos Insert position in the FoldingSetVector, must have been\n  ///        retrieved by an earlier call to findSpecialization().\n  void addSpecialization(FunctionTemplateSpecializationInfo* Info,\n                         void *InsertPos);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying function declaration of the template.\n  FunctionDecl *getTemplatedDecl() const {\n    return static_cast<FunctionDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  FunctionDecl *findSpecialization(ArrayRef<TemplateArgument> Args,\n                                   void *&InsertPos);\n\n  FunctionTemplateDecl *getCanonicalDecl() override {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const FunctionTemplateDecl *getCanonicalDecl() const {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  FunctionTemplateDecl *getPreviousDecl() {\n    return cast_or_null<FunctionTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const FunctionTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<FunctionTemplateDecl>(\n       static_cast<const RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n\n  FunctionTemplateDecl *getMostRecentDecl() {\n    return cast<FunctionTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)\n            ->getMostRecentDecl());\n  }\n  const FunctionTemplateDecl *getMostRecentDecl() const {\n    return const_cast<FunctionTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  FunctionTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  using spec_iterator = SpecIterator<FunctionTemplateSpecializationInfo>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  /// Return whether this function template is an abbreviated function template,\n  /// e.g. `void foo(auto x)` or `template<typename T> void foo(auto x)`\n  bool isAbbreviated() const {\n    // Since the invented template parameters generated from 'auto' parameters\n    // are either appended to the end of the explicit template parameter list or\n    // form a new template parameter list, we can simply observe the last\n    // parameter to determine if such a thing happened.\n    const TemplateParameterList *TPL = getTemplateParameters();\n    return TPL->getParam(TPL->size() - 1)->isImplicit();\n  }\n\n  /// Merge \\p Prev with our RedeclarableTemplateDecl::Common.\n  void mergePrevDecl(FunctionTemplateDecl *Prev);\n\n  /// Create a function template node.\n  static FunctionTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      DeclarationName Name,\n                                      TemplateParameterList *Params,\n                                      NamedDecl *Decl);\n\n  /// Create an empty function template node.\n  static FunctionTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FunctionTemplate; }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Template Parameters\n//===----------------------------------------------------------------------===//\n\n/// Defines the position of a template parameter within a template\n/// parameter list.\n///\n/// Because template parameter can be listed\n/// sequentially for out-of-line template members, each template parameter is\n/// given a Depth - the nesting of template parameter scopes - and a Position -\n/// the occurrence within the parameter list.\n/// This class is inheritedly privately by different kinds of template\n/// parameters and is not part of the Decl hierarchy. Just a facility.\nclass TemplateParmPosition {\nprotected:\n  enum { DepthWidth = 20, PositionWidth = 12 };\n  unsigned Depth : DepthWidth;\n  unsigned Position : PositionWidth;\n\n  static constexpr unsigned MaxDepth = (1U << DepthWidth) - 1;\n  static constexpr unsigned MaxPosition = (1U << PositionWidth) - 1;\n\n  TemplateParmPosition(unsigned D, unsigned P) : Depth(D), Position(P) {\n    // The input may fill maximum values to show that it is invalid.\n    // Add one here to convert it to zero.\n    assert((D + 1) <= MaxDepth &&\n           \"The depth of template parmeter position is more than 2^20!\");\n    assert((P + 1) <= MaxPosition &&\n           \"The position of template parmeter position is more than 2^12!\");\n  }\n\npublic:\n  TemplateParmPosition() = delete;\n\n  /// Get the nesting depth of the template parameter.\n  unsigned getDepth() const { return Depth; }\n  void setDepth(unsigned D) {\n    assert((D + 1) <= MaxDepth &&\n           \"The depth of template parmeter position is more than 2^20!\");\n    Depth = D;\n  }\n\n  /// Get the position of the template parameter within its parameter list.\n  unsigned getPosition() const { return Position; }\n  void setPosition(unsigned P) {\n    assert((P + 1) <= MaxPosition &&\n           \"The position of template parmeter position is more than 2^12!\");\n    Position = P;\n  }\n\n  /// Get the index of the template parameter within its parameter list.\n  unsigned getIndex() const { return Position; }\n};\n\n/// Declaration of a template type parameter.\n///\n/// For example, \"T\" in\n/// \\code\n/// template<typename T> class vector;\n/// \\endcode\nclass TemplateTypeParmDecl final : public TypeDecl,\n    private llvm::TrailingObjects<TemplateTypeParmDecl, TypeConstraint> {\n  /// Sema creates these on the stack during auto type deduction.\n  friend class Sema;\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n\n  /// Whether this template type parameter was declaration with\n  /// the 'typename' keyword.\n  ///\n  /// If false, it was declared with the 'class' keyword.\n  bool Typename : 1;\n\n  /// Whether this template type parameter has a type-constraint construct.\n  bool HasTypeConstraint : 1;\n\n  /// Whether the type constraint has been initialized. This can be false if the\n  /// constraint was not initialized yet or if there was an error forming the\n  /// type constraint.\n  bool TypeConstraintInitialized : 1;\n\n  /// Whether this type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack : 1;\n\n  /// The number of type parameters in an expanded parameter pack.\n  unsigned NumExpanded = 0;\n\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTypeParmDecl, TypeSourceInfo *>;\n  DefArgStorage DefaultArgument;\n\n  TemplateTypeParmDecl(DeclContext *DC, SourceLocation KeyLoc,\n                       SourceLocation IdLoc, IdentifierInfo *Id, bool Typename,\n                       bool HasTypeConstraint,\n                       std::optional<unsigned> NumExpanded)\n      : TypeDecl(TemplateTypeParm, DC, IdLoc, Id, KeyLoc), Typename(Typename),\n        HasTypeConstraint(HasTypeConstraint), TypeConstraintInitialized(false),\n        ExpandedParameterPack(NumExpanded),\n        NumExpanded(NumExpanded.value_or(0)) {}\n\npublic:\n  static TemplateTypeParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation KeyLoc,\n         SourceLocation NameLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         bool Typename, bool ParameterPack, bool HasTypeConstraint = false,\n         std::optional<unsigned> NumExpanded = std::nullopt);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID,\n                                                  bool HasTypeConstraint);\n\n  /// Whether this template type parameter was declared with\n  /// the 'typename' keyword.\n  ///\n  /// If not, it was either declared with the 'class' keyword or with a\n  /// type-constraint (see hasTypeConstraint()).\n  bool wasDeclaredWithTypename() const {\n    return Typename && !HasTypeConstraint;\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  QualType getDefaultArgument() const {\n    return DefaultArgument.get()->getType();\n  }\n\n  /// Retrieves the default argument's source information, if any.\n  TypeSourceInfo *getDefaultArgumentInfo() const {\n    return DefaultArgument.get();\n  }\n\n  /// Retrieves the location of the default argument declaration.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter.\n  void setDefaultArgument(TypeSourceInfo *DefArg) {\n    DefaultArgument.set(DefArg);\n  }\n\n  /// Set that this default argument was inherited from another\n  /// parameter.\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTypeParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() {\n    DefaultArgument.clear();\n  }\n\n  /// Set whether this template type parameter was declared with\n  /// the 'typename' or 'class' keyword.\n  void setDeclaredWithTypename(bool withTypename) { Typename = withTypename; }\n\n  /// Retrieve the depth of the template parameter.\n  unsigned getDepth() const;\n\n  /// Retrieve the index of the template parameter.\n  unsigned getIndex() const;\n\n  /// Returns whether this is a parameter pack.\n  bool isParameterPack() const;\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template type template parameter pack can be a pack expansion if its\n  /// type-constraint contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    if (!isParameterPack())\n      return false;\n    if (const TypeConstraint *TC = getTypeConstraint())\n      if (TC->hasExplicitTemplateArgs())\n        for (const auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n          if (ArgLoc.getArgument().containsUnexpandedParameterPack())\n            return true;\n    return false;\n  }\n\n  /// Whether this parameter is a template type parameter pack that has a known\n  /// list of different type-constraints at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type-constraint was itself a pack expansion, and that\n  /// expansion has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<convertible_to<Types> ...Convertibles>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Convertibles has (convertible_to<Types> && ...) as\n  /// its type-constraint. When \\c Types is supplied with template arguments by\n  /// instantiating \\c X, the instantiation of \\c Convertibles becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Convertibles being an expanded\n  /// parameter pack of size 2 (use getNumExpansionTypes() to get this number).\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of parameters in an expanded parameter pack.\n  unsigned getNumExpansionParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpanded;\n  }\n\n  /// Returns the type constraint associated with this template parameter (if\n  /// any).\n  const TypeConstraint *getTypeConstraint() const {\n    return TypeConstraintInitialized ? getTrailingObjects<TypeConstraint>() :\n         nullptr;\n  }\n\n  void setTypeConstraint(NestedNameSpecifierLoc NNS,\n                         DeclarationNameInfo NameInfo, NamedDecl *FoundDecl,\n                         ConceptDecl *CD,\n                         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                         Expr *ImmediatelyDeclaredConstraint);\n\n  /// Determine whether this template parameter has a type-constraint.\n  bool hasTypeConstraint() const {\n    return HasTypeConstraint;\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be the immediately-introduced constraint or empty.\n  ///\n  /// Use this instead of getTypeConstraint for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (HasTypeConstraint)\n      AC.push_back(getTypeConstraint()->getImmediatelyDeclaredConstraint());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTypeParm; }\n};\n\n/// NonTypeTemplateParmDecl - Declares a non-type template parameter,\n/// e.g., \"Size\" in\n/// @code\n/// template<int Size> class array { };\n/// @endcode\nclass NonTypeTemplateParmDecl final\n    : public DeclaratorDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<NonTypeTemplateParmDecl,\n                                    std::pair<QualType, TypeSourceInfo *>,\n                                    Expr *> {\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  /// The default template argument, if any, and whether or not\n  /// it was inherited.\n  using DefArgStorage = DefaultArgStorage<NonTypeTemplateParmDecl, Expr *>;\n  DefArgStorage DefaultArgument;\n\n  // FIXME: Collapse this into TemplateParamPosition; or, just move depth/index\n  // down here to save memory.\n\n  /// Whether this non-type template parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of types in an expanded parameter pack.\n  unsigned NumExpandedTypes = 0;\n\n  size_t numTrailingObjects(\n      OverloadToken<std::pair<QualType, TypeSourceInfo *>>) const {\n    return NumExpandedTypes;\n  }\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          bool ParameterPack, TypeSourceInfo *TInfo)\n      : DeclaratorDecl(NonTypeTemplateParm, DC, IdLoc, Id, T, TInfo, StartLoc),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          TypeSourceInfo *TInfo,\n                          ArrayRef<QualType> ExpandedTypes,\n                          ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\npublic:\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, bool ParameterPack, TypeSourceInfo *TInfo);\n\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, TypeSourceInfo *TInfo, ArrayRef<QualType> ExpandedTypes,\n         ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     bool HasTypeConstraint);\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     unsigned NumExpandedTypes,\n                                                     bool HasTypeConstraint);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  Expr *getDefaultArgument() const { return DefaultArgument.get(); }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(Expr *DefArg) { DefaultArgument.set(DefArg); }\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   NonTypeTemplateParmDecl *Parm) {\n    DefaultArgument.setInherited(C, Parm);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  /// Whether this parameter is a non-type template parameter pack.\n  ///\n  /// If the parameter is a parameter pack, the type may be a\n  /// \\c PackExpansionType. In the following example, the \\c Dims parameter\n  /// is a parameter pack (whose type is 'unsigned').\n  ///\n  /// \\code\n  /// template<typename T, unsigned ...Dims> struct multi_array;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A non-type template parameter pack is a pack expansion if its type\n  /// contains an unexpanded parameter pack. In this case, we will have\n  /// built a PackExpansionType wrapping the type.\n  bool isPackExpansion() const {\n    return ParameterPack && getType()->getAs<PackExpansionType>();\n  }\n\n  /// Whether this parameter is a non-type template parameter pack\n  /// that has a known list of different types at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type was itself a pack expansion, and that expansion\n  /// has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<Types ...Values>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Values has a \\c PackExpansionType as its type,\n  /// which expands \\c Types. When \\c Types is supplied with template arguments\n  /// by instantiating \\c X, the instantiation of \\c Values becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Values being an expanded parameter\n  /// pack with expansion types \\c int and \\c unsigned int.\n  ///\n  /// The \\c getExpansionType() and \\c getExpansionTypeSourceInfo() functions\n  /// return the expansion types.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion types in an expanded parameter\n  /// pack.\n  unsigned getNumExpansionTypes() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedTypes;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  QualType getExpansionType(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].first;\n  }\n\n  /// Retrieve a particular expansion type source info within an\n  /// expanded parameter pack.\n  TypeSourceInfo *getExpansionTypeSourceInfo(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].second;\n  }\n\n  /// Return the constraint introduced by the placeholder type of this non-type\n  /// template parameter (if any).\n  Expr *getPlaceholderTypeConstraint() const {\n    return hasPlaceholderTypeConstraint() ? *getTrailingObjects<Expr *>() :\n        nullptr;\n  }\n\n  void setPlaceholderTypeConstraint(Expr *E) {\n    *getTrailingObjects<Expr *>() = E;\n  }\n\n  /// Determine whether this non-type template parameter's type has a\n  /// placeholder with a type-constraint.\n  bool hasPlaceholderTypeConstraint() const {\n    auto *AT = getType()->getContainedAutoType();\n    return AT && AT->isConstrained();\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be a vector of size 1 containing the immediately-declared\n  /// constraint introduced by the placeholder type, or an empty vector.\n  ///\n  /// Use this instead of getPlaceholderImmediatelyDeclaredConstraint for\n  /// concepts APIs that accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (Expr *E = getPlaceholderTypeConstraint())\n      AC.push_back(E);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }\n};\n\n/// TemplateTemplateParmDecl - Declares a template template parameter,\n/// e.g., \"T\" in\n/// @code\n/// template <template <typename> class T> class container { };\n/// @endcode\n/// A template template parameter is a TemplateDecl because it defines the\n/// name of a template and the template parameters allowable for substitution.\nclass TemplateTemplateParmDecl final\n    : public TemplateDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<TemplateTemplateParmDecl,\n                                    TemplateParameterList *> {\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTemplateParmDecl, TemplateArgumentLoc *>;\n  DefArgStorage DefaultArgument;\n\n  /// Whether this parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this template template parameter is an \"expanded\"\n  /// parameter pack, meaning that it is a pack expansion and we\n  /// already know the set of template parameters that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of parameters in an expanded parameter pack.\n  unsigned NumExpandedParams = 0;\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P, bool ParameterPack,\n                           IdentifierInfo *Id, TemplateParameterList *Params)\n      : TemplateDecl(TemplateTemplateParm, DC, L, Id, Params),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P,\n                           IdentifierInfo *Id, TemplateParameterList *Params,\n                           ArrayRef<TemplateParameterList *> Expansions);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P, bool ParameterPack,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params);\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params,\n                                 ArrayRef<TemplateParameterList *> Expansions);\n\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID);\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID,\n                                                      unsigned NumExpansions);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  /// Whether this template template parameter is a template\n  /// parameter pack.\n  ///\n  /// \\code\n  /// template<template <class T> ...MetaFunctions> struct Apply;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template template parameter pack is a pack expansion if its template\n  /// parameter list contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    return ParameterPack &&\n           getTemplateParameters()->containsUnexpandedParameterPack();\n  }\n\n  /// Whether this parameter is a template template parameter pack that\n  /// has a known list of different template parameter lists at different\n  /// positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original parameter\n  /// pack's template parameter list was itself a pack expansion, and that\n  /// expansion has already been expanded. For exampe, given:\n  ///\n  /// \\code\n  /// template<typename...Types> struct Outer {\n  ///   template<template<Types> class...Templates> struct Inner;\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Templates is a pack expansion, which expands the\n  /// pack \\c Types. When \\c Types is supplied with template arguments by\n  /// instantiating \\c Outer, the instantiation of \\c Templates is an expanded\n  /// parameter pack.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion template parameters in\n  /// an expanded parameter pack.\n  unsigned getNumExpansionTemplateParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedParams;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  TemplateParameterList *getExpansionTemplateParameters(unsigned I) const {\n    assert(I < NumExpandedParams && \"Out-of-range expansion type index\");\n    return getTrailingObjects<TemplateParameterList *>()[I];\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  const TemplateArgumentLoc &getDefaultArgument() const {\n    static const TemplateArgumentLoc NoneLoc;\n    return DefaultArgument.isSet() ? *DefaultArgument.get() : NoneLoc;\n  }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(const ASTContext &C,\n                          const TemplateArgumentLoc &DefArg);\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTemplateParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    SourceLocation End = getLocation();\n    if (hasDefaultArgument() && !defaultArgumentWasInherited())\n      End = getDefaultArgument().getSourceRange().getEnd();\n    return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTemplateParm; }\n};\n\n/// Represents the builtin template declaration which is used to\n/// implement __make_integer_seq and other builtin templates.  It serves\n/// no real purpose beyond existing as a place to hold template parameters.\nclass BuiltinTemplateDecl : public TemplateDecl {\n  BuiltinTemplateKind BTK;\n\n  BuiltinTemplateDecl(const ASTContext &C, DeclContext *DC,\n                      DeclarationName Name, BuiltinTemplateKind BTK);\n\n  void anchor() override;\n\npublic:\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == BuiltinTemplate; }\n\n  static BuiltinTemplateDecl *Create(const ASTContext &C, DeclContext *DC,\n                                     DeclarationName Name,\n                                     BuiltinTemplateKind BTK) {\n    return new (C, DC) BuiltinTemplateDecl(C, DC, Name, BTK);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return {};\n  }\n\n  BuiltinTemplateKind getBuiltinTemplateKind() const { return BTK; }\n};\n\n/// Represents a class template specialization, which refers to\n/// a class template with a given set of template arguments.\n///\n/// Class template specializations represent both explicit\n/// specialization of class templates, as in the example below, and\n/// implicit instantiations of class templates.\n///\n/// \\code\n/// template<typename T> class array;\n///\n/// template<>\n/// class array<bool> { }; // class template specialization array<bool>\n/// \\endcode\nclass ClassTemplateSpecializationDecl\n  : public CXXRecordDecl, public llvm::FoldingSetNode {\n  /// Structure that stores information about a class template\n  /// specialization that was instantiated from a class template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The class template partial specialization from which this\n    /// class template specialization was instantiated.\n    ClassTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the class template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes\n  llvm::PointerUnion<ClassTemplateDecl *, SpecializedPartialSpecialization *>\n    SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n\n  /// The point where this template was instantiated (if any)\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\nprotected:\n  ClassTemplateSpecializationDecl(ASTContext &Context, Kind DK, TagKind TK,\n                                  DeclContext *DC, SourceLocation StartLoc,\n                                  SourceLocation IdLoc,\n                                  ClassTemplateDecl *SpecializedTemplate,\n                                  ArrayRef<TemplateArgument> Args,\n                                  ClassTemplateSpecializationDecl *PrevDecl);\n\n  explicit ClassTemplateSpecializationDecl(ASTContext &C, Kind DK);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplateSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         ClassTemplateSpecializationDecl *PrevDecl);\n  static ClassTemplateSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  // FIXME: This is broken. CXXRecordDecl::getMostRecentDecl() returns a\n  // different \"most recent\" declaration from this function for the same\n  // declaration, because we don't override getMostRecentDeclImpl(). But\n  // it's not clear that we should override that, because the most recent\n  // declaration as a CXXRecordDecl sometimes is the injected-class-name.\n  ClassTemplateSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplateSpecializationDecl>(\n        getMostRecentNonInjectedDecl());\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  ClassTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the class template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const {\n    return *TemplateArgs;\n  }\n\n  void setTemplateArgs(TemplateArgumentList *Args) {\n    TemplateArgs = Args;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Is this an explicit specialization at class scope (within the class that\n  /// owns the primary template)? For example:\n  ///\n  /// \\code\n  /// template<typename T> struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<> struct Inner; // class-scope explicit specialization\n  /// };\n  /// \\endcode\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializedTemplate(ClassTemplateDecl *Specialized) {\n    SpecializedTemplate = Specialized;\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  /// If this class template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// class template or class template partial specialization from which it\n  /// was instantiated.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the class template or class template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<ClassTemplateDecl*>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate members of the class template or class template partial\n  /// specialization from which this class template specialization was\n  /// instantiated.\n  ///\n  /// \\returns For a class template specialization instantiated from the primary\n  /// template, this function will return the same template arguments as\n  /// getTemplateArgs(). For a class template specialization instantiated from\n  /// a class template partial specialization, this function will return the\n  /// deduced template arguments for the class template partial specialization\n  /// itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this class template specialization is actually an\n  /// instantiation of the given class template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Already set to a class template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this class template specialization is an instantiation\n  /// of the given class template.\n  void setInstantiationOf(ClassTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Previously set to a class template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user. This will be a class template specialization type.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          const ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstClassTemplateSpecialization &&\n           K <= lastClassTemplateSpecialization;\n  }\n};\n\nclass ClassTemplatePartialSpecializationDecl\n  : public ClassTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList* TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The class template partial specialization from which this\n  /// class template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this class template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<ClassTemplatePartialSpecializationDecl *, 1, bool>\n      InstantiatedFromMember;\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &Context, TagKind TK,\n                                         DeclContext *DC,\n                                         SourceLocation StartLoc,\n                                         SourceLocation IdLoc,\n                                         TemplateParameterList *Params,\n                                         ClassTemplateDecl *SpecializedTemplate,\n                                         ArrayRef<TemplateArgument> Args,\n                               const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                               ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &C)\n    : ClassTemplateSpecializationDecl(C, ClassTemplatePartialSpecialization),\n      InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         TemplateParameterList *Params,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos,\n         QualType CanonInjectedType,\n         ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  static ClassTemplatePartialSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ClassTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplatePartialSpecializationDecl>(\n             static_cast<ClassTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// Retrieve the member class template partial specialization from\n  /// which this particular class template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a class template.\nclass ClassTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// class template.\n  struct Common : CommonBase {\n    /// The class template specializations for this class\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<ClassTemplateSpecializationDecl> Specializations;\n\n    /// The class template partial specializations for this class\n    /// template.\n    llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl>\n      PartialSpecializations;\n\n    /// The injected-class-name type for this class template.\n    QualType InjectedClassNameType;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this class template.\n  llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  ClassTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName Name, TemplateParameterList *Params,\n                    NamedDecl *Decl)\n      : RedeclarableTemplateDecl(ClassTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  void setCommonPtr(Common *C) {\n    RedeclarableTemplateDecl::Common = C;\n  }\n\npublic:\n\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class TemplateDeclInstantiator;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying class declarations of the template.\n  CXXRecordDecl *getTemplatedDecl() const {\n    return static_cast<CXXRecordDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// class pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// \\brief Create a class template node.\n  static ClassTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L,\n                                   DeclarationName Name,\n                                   TemplateParameterList *Params,\n                                   NamedDecl *Decl);\n\n  /// Create an empty class template node.\n  static ClassTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  ClassTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(ClassTemplateSpecializationDecl *D, void *InsertPos);\n\n  ClassTemplateDecl *getCanonicalDecl() override {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const ClassTemplateDecl *getCanonicalDecl() const {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this class template, or\n  /// nullptr if no such declaration exists.\n  ClassTemplateDecl *getPreviousDecl() {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const ClassTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  ClassTemplateDecl *getMostRecentDecl() {\n    return cast<ClassTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const ClassTemplateDecl *getMostRecentDecl() const {\n    return const_cast<ClassTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  ClassTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(ClassTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<ClassTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a class template partial specialization with the given\n  /// type T.\n  ///\n  /// \\param T a dependent type that names a specialization of this class\n  /// template.\n  ///\n  /// \\returns the class template partial specialization that exactly matches\n  /// the type \\p T, or nullptr if no such partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *findPartialSpecialization(QualType T);\n\n  /// Find a class template partial specialization which was instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member class template partial specialization.\n  ///\n  /// \\returns the class template partial specialization which was instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecInstantiatedFromMember(\n                                     ClassTemplatePartialSpecializationDecl *D);\n\n  /// Retrieve the template specialization type of the\n  /// injected-class-name for this class template.\n  ///\n  /// The injected-class-name for a class template \\c X is \\c\n  /// X<template-args>, where \\c template-args is formed from the\n  /// template arguments that correspond to the template parameters of\n  /// \\c X. For example:\n  ///\n  /// \\code\n  /// template<typename T, int N>\n  /// struct array {\n  ///   typedef array this_type; // \"array\" is equivalent to \"array<T, N>\"\n  /// };\n  /// \\endcode\n  QualType getInjectedClassNameSpecialization();\n\n  using spec_iterator = SpecIterator<ClassTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ClassTemplate; }\n};\n\n/// Declaration of a friend template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> class A {\n///   friend class MyVector<T>; // not a friend template\n///   template \\<typename U> friend class B; // not a friend template\n///   template \\<typename U> friend class Foo<T>::Nested; // friend template\n/// };\n/// \\endcode\n///\n/// \\note This class is not currently in use.  All of the above\n/// will yield a FriendDecl, not a FriendTemplateDecl.\nclass FriendTemplateDecl : public Decl {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *,TypeSourceInfo *>;\n\nprivate:\n  // The number of template parameters;  always non-zero.\n  unsigned NumParams = 0;\n\n  // The parameter list.\n  TemplateParameterList **Params = nullptr;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  FriendTemplateDecl(DeclContext *DC, SourceLocation Loc,\n                     TemplateParameterList **Params, unsigned NumParams,\n                     FriendUnion Friend, SourceLocation FriendLoc)\n      : Decl(Decl::FriendTemplate, DC, Loc), NumParams(NumParams),\n        Params(Params), Friend(Friend), FriendLoc(FriendLoc) {}\n\n  FriendTemplateDecl(EmptyShell Empty) : Decl(Decl::FriendTemplate, Empty) {}\n\npublic:\n  friend class ASTDeclReader;\n\n  static FriendTemplateDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation Loc,\n         MutableArrayRef<TemplateParameterList *> Params, FriendUnion Friend,\n         SourceLocation FriendLoc);\n\n  static FriendTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// If this friend declaration names a templated type (or\n  /// a dependent member type of a templated type), return that\n  /// type;  otherwise return null.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// If this friend declaration names a templated function (or\n  /// a member function of a templated type), return that type;\n  /// otherwise return null.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl*>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i <= NumParams);\n    return Params[i];\n  }\n\n  unsigned getNumTemplateParameters() const {\n    return NumParams;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::FriendTemplate; }\n};\n\n/// Declaration of an alias template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> using V = std::map<T*, int, MyCompare<T>>;\n/// \\endcode\nclass TypeAliasTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  using Common = CommonBase;\n\n  TypeAliasTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                        DeclarationName Name, TemplateParameterList *Params,\n                        NamedDecl *Decl)\n      : RedeclarableTemplateDecl(TypeAliasTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the underlying function declaration of the template.\n  TypeAliasDecl *getTemplatedDecl() const {\n    return static_cast<TypeAliasDecl *>(TemplatedDecl);\n  }\n\n\n  TypeAliasTemplateDecl *getCanonicalDecl() override {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const TypeAliasTemplateDecl *getCanonicalDecl() const {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  TypeAliasTemplateDecl *getPreviousDecl() {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const TypeAliasTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  TypeAliasTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Create a function template node.\n  static TypeAliasTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                       SourceLocation L,\n                                       DeclarationName Name,\n                                       TemplateParameterList *Params,\n                                       NamedDecl *Decl);\n\n  /// Create an empty alias template node.\n  static TypeAliasTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAliasTemplate; }\n};\n\n/// Declaration of a function specialization at template class scope.\n///\n/// For example:\n/// \\code\n/// template <class T>\n/// class A {\n///    template <class U> void foo(U a) { }\n///    template<> void foo(int a) { }\n/// }\n/// \\endcode\n///\n/// \"template<> foo(int a)\" will be saved in Specialization as a normal\n/// CXXMethodDecl. Then during an instantiation of class A, it will be\n/// transformed into an actual function specialization.\n///\n/// FIXME: This is redundant; we could store the same information directly on\n/// the CXXMethodDecl as a DependentFunctionTemplateSpecializationInfo.\nclass ClassScopeFunctionSpecializationDecl : public Decl {\n  CXXMethodDecl *Specialization;\n  const ASTTemplateArgumentListInfo *TemplateArgs;\n\n  ClassScopeFunctionSpecializationDecl(\n      DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n      const ASTTemplateArgumentListInfo *TemplArgs)\n      : Decl(Decl::ClassScopeFunctionSpecialization, DC, Loc),\n        Specialization(FD), TemplateArgs(TemplArgs) {}\n\n  ClassScopeFunctionSpecializationDecl(EmptyShell Empty)\n      : Decl(Decl::ClassScopeFunctionSpecialization, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  CXXMethodDecl *getSpecialization() const { return Specialization; }\n  bool hasExplicitTemplateArgs() const { return TemplateArgs; }\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return TemplateArgs;\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n         bool HasExplicitTemplateArgs,\n         const TemplateArgumentListInfo &TemplateArgs) {\n    return new (C, DC) ClassScopeFunctionSpecializationDecl(\n        DC, Loc, FD,\n        HasExplicitTemplateArgs\n            ? ASTTemplateArgumentListInfo::Create(C, TemplateArgs)\n            : nullptr);\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  CreateDeserialized(ASTContext &Context, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == Decl::ClassScopeFunctionSpecialization;\n  }\n};\n\n/// Represents a variable template specialization, which refers to\n/// a variable template with a given set of template arguments.\n///\n/// Variable template specializations represent both explicit\n/// specializations of variable templates, as in the example below, and\n/// implicit instantiations of variable templates.\n///\n/// \\code\n/// template<typename T> constexpr T pi = T(3.1415926535897932385);\n///\n/// template<>\n/// constexpr float pi<float>; // variable template specialization pi<float>\n/// \\endcode\nclass VarTemplateSpecializationDecl : public VarDecl,\n                                      public llvm::FoldingSetNode {\n\n  /// Structure that stores information about a variable template\n  /// specialization that was instantiated from a variable template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The variable template partial specialization from which this\n    /// variable template specialization was instantiated.\n    VarTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the variable template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes.\n  llvm::PointerUnion<VarTemplateDecl *, SpecializedPartialSpecialization *>\n  SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n  const ASTTemplateArgumentListInfo *TemplateArgsInfo = nullptr;\n\n  /// The point where this template was instantiated (if any).\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\n  /// Whether this declaration is a complete definition of the\n  /// variable template specialization. We can't otherwise tell apart\n  /// an instantiated declaration from an instantiated definition with\n  /// no initializer.\n  unsigned IsCompleteDefinition : 1;\n\nprotected:\n  VarTemplateSpecializationDecl(Kind DK, ASTContext &Context, DeclContext *DC,\n                                SourceLocation StartLoc, SourceLocation IdLoc,\n                                VarTemplateDecl *SpecializedTemplate,\n                                QualType T, TypeSourceInfo *TInfo,\n                                StorageClass S,\n                                ArrayRef<TemplateArgument> Args);\n\n  explicit VarTemplateSpecializationDecl(Kind DK, ASTContext &Context);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class VarDecl;\n\n  static VarTemplateSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S,\n         ArrayRef<TemplateArgument> Args);\n  static VarTemplateSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  VarTemplateSpecializationDecl *getMostRecentDecl() {\n    VarDecl *Recent = static_cast<VarDecl *>(this)->getMostRecentDecl();\n    return cast<VarTemplateSpecializationDecl>(Recent);\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  VarTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the variable template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const { return *TemplateArgs; }\n\n  // TODO: Always set this when creating the new specialization?\n  void setTemplateArgsInfo(const TemplateArgumentListInfo &ArgsInfo);\n  void setTemplateArgsInfo(const ASTTemplateArgumentListInfo *ArgsInfo);\n\n  const ASTTemplateArgumentListInfo *getTemplateArgsInfo() const {\n    return TemplateArgsInfo;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  void setCompleteDefinition() { IsCompleteDefinition = true; }\n\n  /// If this variable template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// variable template or variable template partial specialization from which\n  /// it was instantiated.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<VarTemplateDecl *,\n                                VarTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the variable template or variable template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<VarTemplateDecl *>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate the initializer of the variable template or variable\n  /// template partial specialization from which this variable template\n  /// specialization was instantiated.\n  ///\n  /// \\returns For a variable template specialization instantiated from the\n  /// primary template, this function will return the same template arguments\n  /// as getTemplateArgs(). For a variable template specialization instantiated\n  /// from a variable template partial specialization, this function will the\n  /// return deduced template arguments for the variable template partial\n  /// specialization itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this variable template specialization is actually an\n  /// instantiation of the given variable template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(VarTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Already set to a variable template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this variable template specialization is an instantiation\n  /// of the given variable template.\n  void setInstantiationOf(VarTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Previously set to a variable template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ArrayRef<TemplateArgument> TemplateArgs,\n                      const ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstVarTemplateSpecialization &&\n           K <= lastVarTemplateSpecialization;\n  }\n};\n\nclass VarTemplatePartialSpecializationDecl\n    : public VarTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList *TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The variable template partial specialization from which this\n  /// variable template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this variable template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<VarTemplatePartialSpecializationDecl *, 1, bool>\n  InstantiatedFromMember;\n\n  VarTemplatePartialSpecializationDecl(\n      ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n      SourceLocation IdLoc, TemplateParameterList *Params,\n      VarTemplateDecl *SpecializedTemplate, QualType T, TypeSourceInfo *TInfo,\n      StorageClass S, ArrayRef<TemplateArgument> Args,\n      const ASTTemplateArgumentListInfo *ArgInfos);\n\n  VarTemplatePartialSpecializationDecl(ASTContext &Context)\n      : VarTemplateSpecializationDecl(VarTemplatePartialSpecialization,\n                                      Context),\n        InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static VarTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, TemplateParameterList *Params,\n         VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S, ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos);\n\n  static VarTemplatePartialSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                                  unsigned ID);\n\n  VarTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<VarTemplatePartialSpecializationDecl>(\n             static_cast<VarTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// \\brief Retrieve the member variable template partial specialization from\n  /// which this particular variable template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a variable template.\nclass VarTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// variable template.\n  struct Common : CommonBase {\n    /// The variable template specializations for this variable\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<VarTemplateSpecializationDecl> Specializations;\n\n    /// The variable template partial specializations for this variable\n    /// template.\n    llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl>\n    PartialSpecializations;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this variable template.\n  llvm::FoldingSetVector<VarTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  VarTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                  DeclarationName Name, TemplateParameterList *Params,\n                  NamedDecl *Decl)\n      : RedeclarableTemplateDecl(VarTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying variable declarations of the template.\n  VarDecl *getTemplatedDecl() const {\n    return static_cast<VarDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// variable pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  VarTemplateDecl *getDefinition();\n\n  /// Create a variable template node.\n  static VarTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, DeclarationName Name,\n                                 TemplateParameterList *Params,\n                                 VarDecl *Decl);\n\n  /// Create an empty variable template node.\n  static VarTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  VarTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(VarTemplateSpecializationDecl *D, void *InsertPos);\n\n  VarTemplateDecl *getCanonicalDecl() override {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const VarTemplateDecl *getCanonicalDecl() const {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this variable template, or\n  /// nullptr if no such declaration exists.\n  VarTemplateDecl *getPreviousDecl() {\n    return cast_or_null<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const VarTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<VarTemplateDecl>(\n            static_cast<const RedeclarableTemplateDecl *>(\n              this)->getPreviousDecl());\n  }\n\n  VarTemplateDecl *getMostRecentDecl() {\n    return cast<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const VarTemplateDecl *getMostRecentDecl() const {\n    return const_cast<VarTemplateDecl *>(this)->getMostRecentDecl();\n  }\n\n  VarTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<VarTemplateDecl>(\n        RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  VarTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(VarTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<VarTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member variable template partial specialization.\n  ///\n  /// \\returns the variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  VarTemplatePartialSpecializationDecl *findPartialSpecInstantiatedFromMember(\n      VarTemplatePartialSpecializationDecl *D);\n\n  using spec_iterator = SpecIterator<VarTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == VarTemplate; }\n};\n\n/// Declaration of a C++20 concept.\nclass ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl> {\nprotected:\n  Expr *ConstraintExpr;\n\n  ConceptDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n              TemplateParameterList *Params, Expr *ConstraintExpr)\n      : TemplateDecl(Concept, DC, L, Name, Params),\n        ConstraintExpr(ConstraintExpr) {};\npublic:\n  static ConceptDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation L, DeclarationName Name,\n                             TemplateParameterList *Params,\n                             Expr *ConstraintExpr);\n  static ConceptDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getConstraintExpr() const {\n    return ConstraintExpr;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       ConstraintExpr->getEndLoc());\n  }\n\n  bool isTypeConcept() const {\n    return isa<TemplateTypeParmDecl>(getTemplateParameters()->getParam(0));\n  }\n\n  ConceptDecl *getCanonicalDecl() override {\n    return cast<ConceptDecl>(getPrimaryMergedDecl(this));\n  }\n  const ConceptDecl *getCanonicalDecl() const {\n    return const_cast<ConceptDecl *>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Concept; }\n\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n};\n\n// An implementation detail of ConceptSpecialicationExpr that holds the template\n// arguments, so we can later use this to reconstitute the template arguments\n// during constraint checking.\nclass ImplicitConceptSpecializationDecl final\n    : public Decl,\n      private llvm::TrailingObjects<ImplicitConceptSpecializationDecl,\n                                    TemplateArgument> {\n  unsigned NumTemplateArgs;\n\n  ImplicitConceptSpecializationDecl(DeclContext *DC, SourceLocation SL,\n                                    ArrayRef<TemplateArgument> ConvertedArgs);\n  ImplicitConceptSpecializationDecl(EmptyShell Empty, unsigned NumTemplateArgs);\n\npublic:\n  static ImplicitConceptSpecializationDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation SL,\n         ArrayRef<TemplateArgument> ConvertedArgs);\n  static ImplicitConceptSpecializationDecl *\n  CreateDeserialized(const ASTContext &C, unsigned ID,\n                     unsigned NumTemplateArgs);\n\n  ArrayRef<TemplateArgument> getTemplateArguments() const {\n    return ArrayRef<TemplateArgument>(getTrailingObjects<TemplateArgument>(),\n                                      NumTemplateArgs);\n  }\n  void setTemplateArguments(ArrayRef<TemplateArgument> Converted);\n\n  static bool classofKind(Kind K) { return K == ImplicitConceptSpecialization; }\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n};\n\n/// A template parameter object.\n///\n/// Template parameter objects represent values of class type used as template\n/// arguments. There is one template parameter object for each such distinct\n/// value used as a template argument across the program.\n///\n/// \\code\n/// struct A { int x, y; };\n/// template<A> struct S;\n/// S<A{1, 2}> s1;\n/// S<A{1, 2}> s2; // same type, argument is same TemplateParamObjectDecl.\n/// \\endcode\nclass TemplateParamObjectDecl : public ValueDecl,\n                                public Mergeable<TemplateParamObjectDecl>,\n                                public llvm::FoldingSetNode {\nprivate:\n  /// The value of this template parameter object.\n  APValue Value;\n\n  TemplateParamObjectDecl(DeclContext *DC, QualType T, const APValue &V)\n      : ValueDecl(TemplateParamObject, DC, SourceLocation(), DeclarationName(),\n                  T),\n        Value(V) {}\n\n  static TemplateParamObjectDecl *Create(const ASTContext &C, QualType T,\n                                         const APValue &V);\n  static TemplateParamObjectDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Only ASTContext::getTemplateParamObjectDecl and deserialization\n  /// create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this template parameter object in a human-readable format.\n  void printName(llvm::raw_ostream &OS,\n                 const PrintingPolicy &Policy) const override;\n\n  /// Print this object as an equivalent expression.\n  void printAsExpr(llvm::raw_ostream &OS) const;\n  void printAsExpr(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print this object as an initializer suitable for a variable of the\n  /// object's type.\n  void printAsInit(llvm::raw_ostream &OS) const;\n  void printAsInit(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T,\n                      const APValue &V) {\n    ID.AddPointer(T.getCanonicalType().getAsOpaquePtr());\n    V.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  TemplateParamObjectDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const TemplateParamObjectDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateParamObject; }\n};\n\ninline NamedDecl *getAsNamedDecl(TemplateParameter P) {\n  if (auto *PD = P.dyn_cast<TemplateTypeParmDecl *>())\n    return PD;\n  if (auto *PD = P.dyn_cast<NonTypeTemplateParmDecl *>())\n    return PD;\n  return P.get<TemplateTemplateParmDecl *>();\n}\n\ninline TemplateDecl *getAsTypeTemplateDecl(Decl *D) {\n  auto *TD = dyn_cast<TemplateDecl>(D);\n  return TD && (isa<ClassTemplateDecl>(TD) ||\n                isa<ClassTemplatePartialSpecializationDecl>(TD) ||\n                isa<TypeAliasTemplateDecl>(TD) ||\n                isa<TemplateTemplateParmDecl>(TD))\n             ? TD\n             : nullptr;\n}\n\n/// Check whether the template parameter is a pack expansion, and if so,\n/// determine the number of parameters produced by that expansion. For instance:\n///\n/// \\code\n/// template<typename ...Ts> struct A {\n///   template<Ts ...NTs, template<Ts> class ...TTs, typename ...Us> struct B;\n/// };\n/// \\endcode\n///\n/// In \\c A<int,int>::B, \\c NTs and \\c TTs have expanded pack size 2, and \\c Us\n/// is not a pack expansion, so returns an empty Optional.\ninline std::optional<unsigned> getExpandedPackSize(const NamedDecl *Param) {\n  if (const auto *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionParameters();\n  }\n\n  if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (NTTP->isExpandedParameterPack())\n      return NTTP->getNumExpansionTypes();\n  }\n\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionTemplateParameters();\n  }\n\n  return std::nullopt;\n}\n\n/// Internal helper used by Subst* nodes to retrieve the parameter list\n/// for their AssociatedDecl.\nTemplateParameterList *getReplacedTemplateParameterList(Decl *D);\n\n}",
  "id": "BLOCK-CPP-09359",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 691,
  "validation_status": "validated"
}