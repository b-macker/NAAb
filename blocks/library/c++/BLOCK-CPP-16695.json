{
  "code": "{\n\npublic:\n  // OpenCL C v1.2 s6.5 - All program scope variables must be declared in the\n  // __constant address space.\n  // OpenCL C v2.0 s6.5.1 - Variables defined at program scope and static\n  // variables inside a function can also be declared in the global\n  // address space.\n  // OpenCL C v3.0 s6.7.1 - Variables at program scope or static or extern\n  // variables inside functions can be declared in global address space if\n  // the __opencl_c_program_scope_global_variables feature is supported\n  // C++ for OpenCL inherits rule from OpenCL C v2.0.\n  bool areProgramScopeVariablesSupported(const LangOptions &Opts) const {\n    return Opts.getOpenCLCompatibleVersion() == 200 ||\n           (Opts.getOpenCLCompatibleVersion() == 300 &&\n            isSupported(\"__opencl_c_program_scope_global_variables\", Opts));\n  }\n\n  struct OpenCLOptionInfo {\n    // Does this option have pragma.\n    bool WithPragma = false;\n\n    // Option starts to be available in this OpenCL version\n    unsigned Avail = 100U;\n\n    // Option becomes core feature in this OpenCL versions\n    unsigned Core = 0U;\n\n    // Option becomes optional core feature in this OpenCL versions\n    unsigned Opt = 0U;\n\n    // Is this option supported\n    bool Supported = false;\n\n    // Is this option enabled\n    bool Enabled = false;\n\n    OpenCLOptionInfo() = default;\n    OpenCLOptionInfo(bool Pragma, unsigned AvailV, unsigned CoreV,\n                     unsigned OptV)\n        : WithPragma(Pragma), Avail(AvailV), Core(CoreV), Opt(OptV) {}\n\n    bool isCore() const { return Core != 0U; }\n\n    bool isOptionalCore() const { return Opt != 0U; }\n\n    // Is option available in OpenCL version \\p LO.\n    bool isAvailableIn(const LangOptions &LO) const {\n      // In C++ mode all extensions should work at least as in v2.0.\n      return LO.getOpenCLCompatibleVersion() >= Avail;\n    }\n\n    // Is core option in OpenCL version \\p LO.\n    bool isCoreIn(const LangOptions &LO) const {\n      return isAvailableIn(LO) && isOpenCLVersionContainedInMask(LO, Core);\n    }\n\n    // Is optional core option in OpenCL version \\p LO.\n    bool isOptionalCoreIn(const LangOptions &LO) const {\n      return isAvailableIn(LO) && isOpenCLVersionContainedInMask(LO, Opt);\n    }\n  };\n\n  bool isKnown(llvm::StringRef Ext) const;\n\n  // For core or optional core feature check that it is supported\n  // by a target, for any other option (extension) check that it is\n  // enabled via pragma\n  bool isAvailableOption(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  bool isWithPragma(llvm::StringRef Ext) const;\n\n  // Is supported as either an extension or an (optional) core feature for\n  // OpenCL version \\p LO.\n  bool isSupported(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // Is supported OpenCL core feature for OpenCL version \\p LO.\n  // For supported extension, return false.\n  bool isSupportedCore(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // Is supported optional core OpenCL feature for OpenCL version \\p LO.\n  // For supported extension, return false.\n  bool isSupportedOptionalCore(llvm::StringRef Ext,\n                               const LangOptions &LO) const;\n\n  // Is supported optional core or core OpenCL feature for OpenCL version \\p\n  // LO. For supported extension, return false.\n  bool isSupportedCoreOrOptionalCore(llvm::StringRef Ext,\n                                     const LangOptions &LO) const;\n\n  // Is supported OpenCL extension for OpenCL version \\p LO.\n  // For supported core or optional core feature, return false.\n  bool isSupportedExtension(llvm::StringRef Ext, const LangOptions &LO) const;\n\n  // FIXME: Whether extension should accept pragma should not\n  // be reset dynamically. But it currently required when\n  // registering new extensions via pragmas.\n  void acceptsPragma(llvm::StringRef Ext, bool V = true);\n\n  void enable(llvm::StringRef Ext, bool V = true);\n\n  /// Enable or disable support for OpenCL extensions\n  /// \\param Ext name of the extension (not prefixed with '+' or '-')\n  /// \\param V value to set for a extension\n  void support(llvm::StringRef Ext, bool V = true);\n\n  OpenCLOptions();\n\n  // Set supported options based on target settings and language version\n  void addSupport(const llvm::StringMap<bool> &FeaturesMap,\n                  const LangOptions &Opts);\n\n  // Disable all extensions\n  void disableAll();\n\n  friend class ASTWriter;\n  friend class ASTReader;\n\n  using OpenCLOptionInfoMap = llvm::StringMap<OpenCLOptionInfo>;\n\n  template <typename... Args>\n  static bool isOpenCLOptionCoreIn(const LangOptions &LO, Args &&... args) {\n    return OpenCLOptionInfo(std::forward<Args>(args)...).isCoreIn(LO);\n  }\n\n  template <typename... Args>\n  static bool isOpenCLOptionAvailableIn(const LangOptions &LO,\n                                        Args &&... args) {\n    return OpenCLOptionInfo(std::forward<Args>(args)...).isAvailableIn(LO);\n  }\n\n  // Diagnose feature dependencies for OpenCL C 3.0. Return false if target\n  // doesn't follow these requirements.\n  static bool diagnoseUnsupportedFeatureDependencies(const TargetInfo &TI,\n                                                     DiagnosticsEngine &Diags);\n\n  // Diagnose that features and equivalent extension are set to same values.\n  // Return false if target doesn't follow these requirements.\n  static bool diagnoseFeatureExtensionDifferences(const TargetInfo &TI,\n                                                  DiagnosticsEngine &Diags);\n\nprivate:\n  // Option is enabled via pragma\n  bool isEnabled(llvm::StringRef Ext) const;\n\n  OpenCLOptionInfoMap OptMap;\n}",
  "id": "BLOCK-CPP-16695",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/OpenCLOptions.h",
  "source_line": 69,
  "validation_status": "validated"
}