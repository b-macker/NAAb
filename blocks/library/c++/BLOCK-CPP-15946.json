{
  "code": "{\n  typedef llvm::DenseMap<const FunctionDecl*, const RetainSummary *>\n          FuncSummariesTy;\n\n  typedef ObjCSummaryCache ObjCMethodSummariesTy;\n\n  typedef llvm::FoldingSetNodeWrapper<RetainSummary> CachedSummaryNode;\n\n  /// Ctx - The ASTContext object for the analyzed ASTs.\n  ASTContext &Ctx;\n\n  /// Records whether or not the analyzed code runs in ARC mode.\n  const bool ARCEnabled;\n\n  /// Track Objective-C and CoreFoundation objects.\n  const bool TrackObjCAndCFObjects;\n\n  /// Track sublcasses of OSObject.\n  const bool TrackOSObjects;\n\n  /// FuncSummaries - A map from FunctionDecls to summaries.\n  FuncSummariesTy FuncSummaries;\n\n  /// ObjCClassMethodSummaries - A map from selectors (for instance methods)\n  ///  to summaries.\n  ObjCMethodSummariesTy ObjCClassMethodSummaries;\n\n  /// ObjCMethodSummaries - A map from selectors to summaries.\n  ObjCMethodSummariesTy ObjCMethodSummaries;\n\n  /// BPAlloc - A BumpPtrAllocator used for allocating summaries, ArgEffects,\n  ///  and all other data used by the checker.\n  llvm::BumpPtrAllocator BPAlloc;\n\n  /// AF - A factory for ArgEffects objects.\n  ArgEffects::Factory AF;\n\n  /// ObjCAllocRetE - Default return effect for methods returning Objective-C\n  ///  objects.\n  RetEffect ObjCAllocRetE;\n\n  /// ObjCInitRetE - Default return effect for init methods returning\n  ///   Objective-C objects.\n  RetEffect ObjCInitRetE;\n\n  /// SimpleSummaries - Used for uniquing summaries that don't have special\n  /// effects.\n  llvm::FoldingSet<CachedSummaryNode> SimpleSummaries;\n\n  /// Create an OS object at +1.\n  const RetainSummary *getOSSummaryCreateRule(const FunctionDecl *FD);\n\n  /// Get an OS object at +0.\n  const RetainSummary *getOSSummaryGetRule(const FunctionDecl *FD);\n\n  /// Increment the reference count on OS object.\n  const RetainSummary *getOSSummaryRetainRule(const FunctionDecl *FD);\n\n  /// Decrement the reference count on OS object.\n  const RetainSummary *getOSSummaryReleaseRule(const FunctionDecl *FD);\n\n  /// Free the OS object.\n  const RetainSummary *getOSSummaryFreeRule(const FunctionDecl *FD);\n\n  const RetainSummary *getUnarySummary(const FunctionType* FT,\n                                       ArgEffectKind AE);\n\n  const RetainSummary *getCFSummaryCreateRule(const FunctionDecl *FD);\n  const RetainSummary *getCFSummaryGetRule(const FunctionDecl *FD);\n  const RetainSummary *getCFCreateGetRuleSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getPersistentSummary(const RetainSummary &OldSumm);\n\n  const RetainSummary *\n  getPersistentSummary(RetEffect RetEff, ArgEffects ScratchArgs,\n                       ArgEffect ReceiverEff = ArgEffect(DoNothing),\n                       ArgEffect DefaultEff = ArgEffect(MayEscape),\n                       ArgEffect ThisEff = ArgEffect(DoNothing)) {\n    RetainSummary Summ(ScratchArgs, RetEff, DefaultEff, ReceiverEff, ThisEff);\n    return getPersistentSummary(Summ);\n  }\n\n  const RetainSummary *getDoNothingSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(DoNothing));\n  }\n\n  const RetainSummary *getDefaultSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(MayEscape));\n  }\n\n  const RetainSummary *getPersistentStopSummary() {\n    return getPersistentSummary(\n        RetEffect::MakeNoRet(), ArgEffects(AF.getEmptyMap()),\n        ArgEffect(StopTracking), ArgEffect(StopTracking));\n  }\n\n  void InitializeClassMethodSummaries();\n  void InitializeMethodSummaries();\n\n  void addNSObjectClsMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCClassMethodSummaries[S] = Summ;\n  }\n\n  void addNSObjectMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCMethodSummaries[S] = Summ;\n  }\n\n  void addClassMethSummary(const char* Cls, const char* name,\n                           const RetainSummary *Summ, bool isNullary = true) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = isNullary ? GetNullarySelector(name, Ctx)\n                           : GetUnarySelector(name, Ctx);\n    ObjCClassMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  void addInstMethSummary(const char* Cls, const char* nullaryName,\n                          const RetainSummary *Summ) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = GetNullarySelector(nullaryName, Ctx);\n    ObjCMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  template <typename... Keywords>\n  void addMethodSummary(IdentifierInfo *ClsII, ObjCMethodSummariesTy &Summaries,\n                        const RetainSummary *Summ, Keywords *... Kws) {\n    Selector S = getKeywordSelector(Ctx, Kws...);\n    Summaries[ObjCSummaryKey(ClsII, S)] = Summ;\n  }\n\n  template <typename... Keywords>\n  void addInstMethSummary(const char *Cls, const RetainSummary *Summ,\n                          Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCMethodSummaries, Summ, Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(const char *Cls, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCClassMethodSummaries, Summ,\n                     Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(IdentifierInfo *II, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(II, ObjCClassMethodSummaries, Summ, Kws...);\n  }\n\n  const RetainSummary * generateSummary(const FunctionDecl *FD,\n                                        bool &AllowAnnotations);\n\n  /// Return a summary for OSObject, or nullptr if not found.\n  const RetainSummary *getSummaryForOSObject(const FunctionDecl *FD,\n                                             StringRef FName, QualType RetTy);\n\n  /// Return a summary for Objective-C or CF object, or nullptr if not found.\n  const RetainSummary *getSummaryForObjCOrCFObject(\n    const FunctionDecl *FD,\n    StringRef FName,\n    QualType RetTy,\n    const FunctionType *FT,\n    bool &AllowAnnotations);\n\n  /// Apply the annotation of @c pd in function @c FD\n  /// to the resulting summary stored in out-parameter @c Template.\n  /// \\return whether an annotation was applied.\n  bool applyParamAnnotationEffect(const ParmVarDecl *pd, unsigned parm_idx,\n                                  const NamedDecl *FD,\n                                  RetainSummaryTemplate &Template);\n\npublic:\n  RetainSummaryManager(ASTContext &ctx, bool trackObjCAndCFObjects,\n                       bool trackOSObjects)\n      : Ctx(ctx), ARCEnabled((bool)Ctx.getLangOpts().ObjCAutoRefCount),\n        TrackObjCAndCFObjects(trackObjCAndCFObjects),\n        TrackOSObjects(trackOSObjects), AF(BPAlloc),\n        ObjCAllocRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                 : RetEffect::MakeOwned(ObjKind::ObjC)),\n        ObjCInitRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                : RetEffect::MakeOwnedWhenTrackedReceiver()) {\n    InitializeClassMethodSummaries();\n    InitializeMethodSummaries();\n  }\n\n  enum class BehaviorSummary {\n    // Function does not return.\n    NoOp,\n\n    // Function returns the first argument.\n    Identity,\n\n    // Function returns \"this\" argument.\n    IdentityThis,\n\n    // Function either returns zero, or the input parameter.\n    IdentityOrZero\n  };\n\n  std::optional<BehaviorSummary>\n  canEval(const CallExpr *CE, const FunctionDecl *FD,\n          bool &hasTrustedImplementationAnnotation);\n\n  /// \\return Whether the type corresponds to a known smart pointer\n  /// implementation (that is, everything about it is inlineable).\n  static bool isKnownSmartPointer(QualType QT);\n\n  bool isTrustedReferenceCountImplementation(const Decl *FD);\n\n  const RetainSummary *getSummary(AnyCall C,\n                                  bool HasNonZeroCallbackArg=false,\n                                  bool IsReceiverUnconsumedSelf=false,\n                                  QualType ReceiverType={});\n\n  RetEffect getObjAllocRetEffect() const { return ObjCAllocRetE; }\n\nprivate:\n\n  /// getMethodSummary - This version of getMethodSummary is used to query\n  ///  the summary for the current method being analyzed.\n  const RetainSummary *getMethodSummary(const ObjCMethodDecl *MD);\n\n  const RetainSummary *getFunctionSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getMethodSummary(Selector S, const ObjCInterfaceDecl *ID,\n                                        const ObjCMethodDecl *MD,\n                                        QualType RetTy,\n                                        ObjCMethodSummariesTy &CachedSummaries);\n\n  const RetainSummary *\n  getInstanceMethodSummary(const ObjCMessageExpr *ME, QualType ReceiverType);\n\n  const RetainSummary *getClassMethodSummary(const ObjCMessageExpr *ME);\n\n  const RetainSummary *getStandardMethodSummary(const ObjCMethodDecl *MD,\n                                                Selector S, QualType RetTy);\n\n  /// Determine if there is a special return effect for this function or method.\n  std::optional<RetEffect> getRetEffectFromAnnotations(QualType RetTy,\n                                                       const Decl *D);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const ObjCMethodDecl *MD);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const FunctionDecl *FD);\n\n  const RetainSummary *updateSummaryForNonZeroCallbackArg(const RetainSummary *S,\n                                                          AnyCall &C);\n\n  /// Special case '[super init];' and '[self init];'\n  ///\n  /// Even though calling '[super init]' without assigning the result to self\n  /// and checking if the parent returns 'nil' is a bad pattern, it is common.\n  /// Additionally, our Self Init checker already warns about it. To avoid\n  /// overwhelming the user with messages from both checkers, we model the case\n  /// of '[super init]' in cases when it is not consumed by another expression\n  /// as if the call preserves the value of 'self'; essentially, assuming it can\n  /// never fail and return 'nil'.\n  /// Note, we don't want to just stop tracking the value since we want the\n  /// RetainCount checker to report leaks and use-after-free if SelfInit checker\n  /// is turned off.\n  void updateSummaryForReceiverUnconsumedSelf(const RetainSummary *&S);\n\n  /// Set argument types for arguments which are not doing anything.\n  void updateSummaryForArgumentTypes(const AnyCall &C, const RetainSummary *&RS);\n\n  /// Determine whether a declaration @c D of correspondent type (return\n  /// type for functions/methods) @c QT has any of the given attributes,\n  /// provided they pass necessary validation checks AND tracking the given\n  /// attribute is enabled.\n  /// Returns the object kind corresponding to the present attribute, or\n  /// std::nullopt, if none of the specified attributes are present.\n  /// Crashes if passed an attribute which is not explicitly handled.\n  template <class T>\n  std::optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  template <class T1, class T2, class... Others>\n  std::optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  friend class RetainSummaryTemplate;\n}",
  "id": "BLOCK-CPP-15946",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/RetainSummaryManager.h",
  "source_line": 450,
  "validation_status": "validated"
}