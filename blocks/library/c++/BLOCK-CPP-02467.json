{
  "code": "{\n\nnamespace {\n\n// Constants\n#if defined(__i386__) || defined(__x86_64__)\nconstexpr bool kNeedAlignedLoads = false;\n#else\nconstexpr bool kNeedAlignedLoads = true;\n#endif\n\n// We express the number of zeroes as a number in base ZEROES_BASE. By\n// pre-computing the zero extensions for all possible components of such an\n// expression (numbers in a form a*ZEROES_BASE**b), we can calculate the\n// resulting extension by multiplying the extensions for individual components\n// using log_{ZEROES_BASE}(num_zeroes) polynomial multiplications. The tables of\n// zero extensions contain (ZEROES_BASE - 1) * (log_{ZEROES_BASE}(64)) entries.\nconstexpr int ZEROES_BASE_LG = 4;                   // log_2(ZEROES_BASE)\nconstexpr int ZEROES_BASE = (1 << ZEROES_BASE_LG);  // must be a power of 2\n\nconstexpr uint32_t kCrc32cPoly = 0x82f63b78;\n\nuint32_t ReverseBits(uint32_t bits) {\n  bits = (bits & 0xaaaaaaaau) >> 1 | (bits & 0x55555555u) << 1;\n  bits = (bits & 0xccccccccu) >> 2 | (bits & 0x33333333u) << 2;\n  bits = (bits & 0xf0f0f0f0u) >> 4 | (bits & 0x0f0f0f0fu) << 4;\n  return absl::gbswap_32(bits);\n}\n\n// Polynomial long multiplication mod the polynomial of degree 32.\nvoid PolyMultiply(uint32_t* val, uint32_t m, uint32_t poly) {\n  uint32_t l = *val;\n  uint32_t result = 0;\n  auto onebit = uint32_t{0x80000000u};\n  for (uint32_t one = onebit; one != 0; one >>= 1) {\n    if ((l & one) != 0) {\n      result ^= m;\n    }\n    if (m & 1) {\n      m = (m >> 1) ^ poly;\n    } else {\n      m >>= 1;\n    }\n  }\n  *val = result;\n}\n}  // namespace\n\nvoid CRCImpl::FillWordTable(uint32_t poly, uint32_t last, int word_size,\n                            Uint32By256* t) {\n  for (int j = 0; j != word_size; j++) {  // for each byte of extension....\n    t[j][0] = 0;                          // a zero has no effect\n    for (int i = 128; i != 0; i >>= 1) {  // fill in entries for powers of 2\n      if (j == 0 && i == 128) {\n        t[j][i] = last;  // top bit in last byte is given\n      } else {\n        // each successive power of two is derived from the previous\n        // one, either in this table, or the last table\n        uint32_t pred;\n        if (i == 128) {\n          pred = t[j - 1][1];\n        } else {\n          pred = t[j][i << 1];\n        }\n        // Advance the CRC by one bit (multiply by X, and take remainder\n        // through one step of polynomial long division)\n        if (pred & 1) {\n          t[j][i] = (pred >> 1) ^ poly;\n        } else {\n          t[j][i] = pred >> 1;\n        }\n      }\n    }\n    // CRCs have the property that CRC(a xor b) == CRC(a) xor CRC(b)\n    // so we can make all the tables for non-powers of two by\n    // xoring previously created entries.\n    for (int i = 2; i != 256; i <<= 1) {\n      for (int k = i + 1; k != (i << 1); k++) {\n        t[j][k] = t[j][i] ^ t[j][k - i];\n      }\n    }\n  }\n}\n\nint CRCImpl::FillZeroesTable(uint32_t poly, Uint32By256* t) {\n  uint32_t inc = 1;\n  inc <<= 31;\n\n  // Extend by one zero bit. We know degree > 1 so (inc & 1) == 0.\n  inc >>= 1;\n\n  // Now extend by 2, 4, and 8 bits, so now `inc` is extended by one zero byte.\n  for (int i = 0; i < 3; ++i) {\n    PolyMultiply(&inc, inc, poly);\n  }\n\n  int j = 0;\n  for (uint64_t inc_len = 1; inc_len != 0; inc_len <<= ZEROES_BASE_LG) {\n    // Every entry in the table adds an additional inc_len zeroes.\n    uint32_t v = inc;\n    for (int a = 1; a != ZEROES_BASE; a++) {\n      t[0][j] = v;\n      PolyMultiply(&v, inc, poly);\n      j++;\n    }\n    inc = v;\n  }\n  ABSL_RAW_CHECK(j <= 256, \"\");\n  return j;\n}\n\n// Internal version of the \"constructor\".\nCRCImpl* CRCImpl::NewInternal() {\n  // Find an accelearated implementation first.\n  CRCImpl* result = TryNewCRC32AcceleratedX86ARMCombined();\n\n  // Fall back to generic implementions if no acceleration is available.\n  if (result == nullptr) {\n    result = new CRC32();\n  }\n\n  result->InitTables();\n\n  return result;\n}\n\n//  The 32-bit implementation\n\nvoid CRC32::InitTables() {\n  // Compute the table for extending a CRC by one byte.\n  Uint32By256* t = new Uint32By256[4];\n  FillWordTable(kCrc32cPoly, kCrc32cPoly, 1, t);\n  for (int i = 0; i != 256; i++) {\n    this->table0_[i] = t[0][i];\n  }\n\n  // Construct a table for updating the CRC by 4 bytes data followed by\n  // 12 bytes of zeroes.\n  //\n  // Note: the data word size could be larger than the CRC size; it might\n  // be slightly faster to use a 64-bit data word, but doing so doubles the\n  // table size.\n  uint32_t last = kCrc32cPoly;\n  const size_t size = 12;\n  for (size_t i = 0; i < size; ++i) {\n    last = (last >> 8) ^ this->table0_[last & 0xff];\n  }\n  FillWordTable(kCrc32cPoly, last, 4, t);\n  for (size_t b = 0; b < 4; ++b) {\n    for (int i = 0; i < 256; ++i) {\n      this->table_[b][i] = t[b][i];\n    }\n  }\n\n  int j = FillZeroesTable(kCrc32cPoly, t);\n  ABSL_RAW_CHECK(j <= static_cast<int>(ABSL_ARRAYSIZE(this->zeroes_)), \"\");\n  for (int i = 0; i < j; i++) {\n    this->zeroes_[i] = t[0][i];\n  }\n\n  delete[] t;\n\n  // Build up tables for _reversing_ the operation of doing CRC operations on\n  // zero bytes.\n\n  // In C++, extending `crc` by a single zero bit is done by the following:\n  // (A)  bool low_bit_set = (crc & 1);\n  //      crc >>= 1;\n  //      if (low_bit_set) crc ^= kCrc32cPoly;\n  //\n  // In particular note that the high bit of `crc` after this operation will be\n  // set if and only if the low bit of `crc` was set before it.  This means that\n  // no information is lost, and the operation can be reversed, as follows:\n  // (B)  bool high_bit_set = (crc & 0x80000000u);\n  //      if (high_bit_set) crc ^= kCrc32cPoly;\n  //      crc <<= 1;\n  //      if (high_bit_set) crc ^= 1;\n  //\n  // Or, equivalently:\n  // (C)  bool high_bit_set = (crc & 0x80000000u);\n  //      crc <<= 1;\n  //      if (high_bit_set) crc ^= ((kCrc32cPoly << 1) ^ 1);\n  //\n  // The last observation is, if we store our checksums in variable `rcrc`,\n  // with order of the bits reversed, the inverse operation becomes:\n  // (D)  bool low_bit_set = (rcrc & 1);\n  //      rcrc >>= 1;\n  //      if (low_bit_set) rcrc ^= ReverseBits((kCrc32cPoly << 1) ^ 1)\n  //\n  // This is the same algorithm (A) that we started with, only with a different\n  // polynomial bit pattern.  This means that by building up our tables with\n  // this alternate polynomial, we can apply the CRC algorithms to a\n  // bit-reversed CRC checksum to perform inverse zero-extension.\n\n  const uint32_t kCrc32cUnextendPoly =\n      ReverseBits(static_cast<uint32_t>((kCrc32cPoly << 1) ^ 1));\n  FillWordTable(kCrc32cUnextendPoly, kCrc32cUnextendPoly, 1, &reverse_table0_);\n\n  j = FillZeroesTable(kCrc32cUnextendPoly, &reverse_zeroes_);\n  ABSL_RAW_CHECK(j <= static_cast<int>(ABSL_ARRAYSIZE(this->reverse_zeroes_)),\n                 \"\");\n}\n\nvoid CRC32::Extend(uint32_t* crc, const void* bytes, size_t length) const {\n  const uint8_t* p = static_cast<const uint8_t*>(bytes);\n  const uint8_t* e = p + length;\n  uint32_t l = *crc;\n\n  auto step_one_byte = [this, &p, &l]() {\n    int c = (l & 0xff) ^ *p++;\n    l = this->table0_[c] ^ (l >> 8);\n  };\n\n  if (kNeedAlignedLoads) {\n    // point x at first 4-byte aligned byte in string. this might be past the\n    // end of the string.\n    const uint8_t* x = RoundUp<4>(p);\n    if (x <= e) {\n      // Process bytes until finished or p is 4-byte aligned\n      while (p != x) {\n        step_one_byte();\n      }\n    }\n  }\n\n  const size_t kSwathSize = 16;\n  if (static_cast<size_t>(e - p) >= kSwathSize) {\n    // Load one swath of data into the operating buffers.\n    uint32_t buf0 = absl::little_endian::Load32(p) ^ l;\n    uint32_t buf1 = absl::little_endian::Load32(p + 4);\n    uint32_t buf2 = absl::little_endian::Load32(p + 8);\n    uint32_t buf3 = absl::little_endian::Load32(p + 12);\n    p += kSwathSize;\n\n    // Increment a CRC value by a \"swath\"; this combines the four bytes\n    // starting at `ptr` and twelve zero bytes, so that four CRCs can be\n    // built incrementally and combined at the end.\n    const auto step_swath = [this](uint32_t crc_in, const std::uint8_t* ptr) {\n      return absl::little_endian::Load32(ptr) ^\n             this->table_[3][crc_in & 0xff] ^\n             this->table_[2][(crc_in >> 8) & 0xff] ^\n             this->table_[1][(crc_in >> 16) & 0xff] ^\n             this->table_[0][crc_in >> 24];\n    };\n\n    // Run one CRC calculation step over all swaths in one 16-byte stride\n    const auto step_stride = [&]() {\n      buf0 = step_swath(buf0, p);\n      buf1 = step_swath(buf1, p + 4);\n      buf2 = step_swath(buf2, p + 8);\n      buf3 = step_swath(buf3, p + 12);\n      p += 16;\n    };\n\n    // Process kStride interleaved swaths through the data in parallel.\n    while ((e - p) > kPrefetchHorizon) {\n      PrefetchToLocalCacheNta(\n          reinterpret_cast<const void*>(p + kPrefetchHorizon));\n      // Process 64 bytes at a time\n      step_stride();\n      step_stride();\n      step_stride();\n      step_stride();\n    }\n    while (static_cast<size_t>(e - p) >= kSwathSize) {\n      step_stride();\n    }\n\n    // Now advance one word at a time as far as possible. This isn't worth\n    // doing if we have word-advance tables.\n    while (static_cast<size_t>(e - p) >= 4) {\n      buf0 = step_swath(buf0, p);\n      uint32_t tmp = buf0;\n      buf0 = buf1;\n      buf1 = buf2;\n      buf2 = buf3;\n      buf3 = tmp;\n      p += 4;\n    }\n\n    // Combine the results from the different swaths. This is just a CRC\n    // on the data values in the bufX words.\n    auto combine_one_word = [this](uint32_t crc_in, uint32_t w) {\n      w ^= crc_in;\n      for (size_t i = 0; i < 4; ++i) {\n        w = (w >> 8) ^ this->table0_[w & 0xff];\n      }\n      return w;\n    };\n\n    l = combine_one_word(0, buf0);\n    l = combine_one_word(l, buf1);\n    l = combine_one_word(l, buf2);\n    l = combine_one_word(l, buf3);\n  }\n\n  // Process the last few bytes\n  while (p != e) {\n    step_one_byte();\n  }\n\n  *crc = l;\n}\n\nvoid CRC32::ExtendByZeroesImpl(uint32_t* crc, size_t length,\n                               const uint32_t zeroes_table[256],\n                               const uint32_t poly_table[256]) {\n  if (length != 0) {\n    uint32_t l = *crc;\n    // For each ZEROES_BASE_LG bits in length\n    // (after the low-order bits have been removed)\n    // we lookup the appropriate polynomial in the zeroes_ array\n    // and do a polynomial long multiplication (mod the CRC polynomial)\n    // to extend the CRC by the appropriate number of bits.\n    for (int i = 0; length != 0;\n         i += ZEROES_BASE - 1, length >>= ZEROES_BASE_LG) {\n      int c = length & (ZEROES_BASE - 1);  // pick next ZEROES_BASE_LG bits\n      if (c != 0) {                        // if they are not zero,\n                                           // multiply by entry in table\n        // Build a table to aid in multiplying 2 bits at a time.\n        // It takes too long to build tables for more bits.\n        uint64_t m = zeroes_table[c + i - 1];\n        m <<= 1;\n        uint64_t m2 = m << 1;\n        uint64_t mtab[4] = {0, m, m2, m2 ^ m};\n\n        // Do the multiply one byte at a time.\n        uint64_t result = 0;\n        for (int x = 0; x < 32; x += 8) {\n          // The carry-less multiply.\n          result ^= mtab[l & 3] ^ (mtab[(l >> 2) & 3] << 2) ^\n                    (mtab[(l >> 4) & 3] << 4) ^ (mtab[(l >> 6) & 3] << 6);\n          l >>= 8;\n\n          // Reduce modulo the polynomial\n          result = (result >> 8) ^ poly_table[result & 0xff];\n        }\n        l = static_cast<uint32_t>(result);\n      }\n    }\n    *crc = l;\n  }\n}\n\nvoid CRC32::ExtendByZeroes(uint32_t* crc, size_t length) const {\n  return CRC32::ExtendByZeroesImpl(crc, length, zeroes_, table0_);\n}\n\nvoid CRC32::UnextendByZeroes(uint32_t* crc, size_t length) const {\n  // See the comment in CRC32::InitTables() for an explanation of the algorithm\n  // below.\n  *crc = ReverseBits(*crc);\n  ExtendByZeroesImpl(crc, length, reverse_zeroes_, reverse_table0_);\n  *crc = ReverseBits(*crc);\n}\n\nvoid CRC32::Scramble(uint32_t* crc) const {\n  // Rotate by near half the word size plus 1.  See the scramble comment in\n  // crc_internal.h for an explanation.\n  constexpr int scramble_rotate = (32 / 2) + 1;\n  *crc = RotateRight<uint32_t>(static_cast<unsigned int>(*crc + kScrambleLo),\n                               32, scramble_rotate) &\n         MaskOfLength<uint32_t>(32);\n}\n\nvoid CRC32::Unscramble(uint32_t* crc) const {\n  constexpr int scramble_rotate = (32 / 2) + 1;\n  uint64_t rotated = RotateRight<uint32_t>(static_cast<unsigned int>(*crc), 32,\n                                           32 - scramble_rotate);\n  *crc = (rotated - kScrambleLo) & MaskOfLength<uint32_t>(32);\n}\n\n// Constructor and destructor for base class CRC.\nCRC::~CRC() {}\nCRC::CRC() {}\n\n// The \"constructor\" for a CRC32C with a standard polynomial.\nCRC* CRC::Crc32c() {\n  static CRC* singleton = CRCImpl::NewInternal();\n  return singleton;\n}\n\n}",
  "id": "BLOCK-CPP-02467",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc.cc",
  "source_line": 53,
  "validation_status": "validated"
}