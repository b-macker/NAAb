{
  "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/endian.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/base/options.h\"\n#include \"absl/base/port.h\"\n#include \"absl/base/prefetch.h\"\n#include \"absl/container/internal/common.h\"  // IWYU pragma: export // for node_handle\n#include \"absl/container/internal/compressed_tuple.h\"\n#include \"absl/container/internal/container_memory.h\"\n#include \"absl/container/internal/hash_policy_traits.h\"\n#include \"absl/container/internal/hashtable_debug_hooks.h\"\n#include \"absl/container/internal/hashtablez_sampler.h\"\n#include \"absl/memory/memory.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/utility/utility.h\"\n#include <emmintrin.h>\n#include <tmmintrin.h>\n#include <intrin.h>\n#include <arm_neon.h>\n\nusing namespace absl;\nusing namespace container_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05319_execute() {\n    {\n    const size_t cap = capacity();\n    if (cap > Group::kWidth &&\n        // Do these calculations in 64-bit to avoid overflow.\n        size() * uint64_t{32} <= cap * uint64_t{25}) {\n      // Squash DELETED without growing if there is enough capacity.\n      //\n      // Rehash in place if the current size is <= 25/32 of capacity.\n      // Rationale for such a high factor: 1) drop_deletes_without_resize() is\n      // faster than resize, and 2) it takes quite a bit of work to add\n      // tombstones.  In the worst case, seems to take approximately 4\n      // insert/erase pairs to create a single tombstone and so if we are\n      // rehashing because of tombstones, we can afford to rehash-in-place as\n      // long as we are reclaiming at least 1/8 the capacity without doing more\n      // than 2X the work.  (Where \"work\" is defined to be size() for rehashing\n      // or rehashing in place, and 1 for an insert or erase.)  But rehashing in\n      // place is faster per operation than inserting or even doubling the size\n      // of the table, so we actually afford to reclaim even less space from a\n      // resize-in-place.  The decision is to rehash in place if we can reclaim\n      // at about 1/8th of the usable capacity (specifically 3/28 of the\n      // capacity) which means that the total cost of rehashing will be a small\n      // fraction of the total work.\n      //\n      // Here is output of an experiment using the BM_CacheInSteadyState\n      // benchmark running the old case (where we rehash-in-place only if we can\n      // reclaim at least 7/16*capacity) vs. this code (which rehashes in place\n      // if we can recover 3/32*capacity).\n      //\n      // Note that although in the worst-case number of rehashes jumped up from\n      // 15 to 190, but the number of operations per second is almost the same.\n      //\n      // Abridged output of running BM_CacheInSteadyState benchmark from\n      // raw_hash_set_benchmark.   N is the number of insert/erase operations.\n      //\n      //      | OLD (recover >= 7/16        | NEW (recover >= 3/32)\n      // size |    N/s LoadFactor NRehashes |    N/s LoadFactor NRehashes\n      //  448 | 145284       0.44        18 | 140118       0.44        19\n      //  493 | 152546       0.24        11 | 151417       0.48        28\n      //  538 | 151439       0.26        11 | 151152       0.53        38\n      //  583 | 151765       0.28        11 | 150572       0.57        50\n      //  628 | 150241       0.31        11 | 150853       0.61        66\n      //  672 | 149602       0.33        12 | 150110       0.66        90\n      //  717 | 149998       0.35        12 | 149531       0.70       129\n      //  762 | 149836       0.37        13 | 148559       0.74       190\n      //  807 | 149736       0.39        14 | 151107       0.39        14\n      //  852 | 150204       0.42        15 | 151019       0.42        15\n      drop_deletes_without_resize();\n    } else {\n      // Otherwise grow the container.\n      resize(NextCapacity(cap));\n    }\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05319",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 2970,
  "validation_status": "validated"
}