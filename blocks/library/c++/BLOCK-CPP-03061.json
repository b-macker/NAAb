{
  "code": "#include \"absl/strings/internal/str_format/float_conversion.h\"\n#include <string.h>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <limits>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/functional/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/numeric/internal/representation.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03061_execute() {\n    {\n  constexpr int input_bits = sizeof(Int) * 8;\n\n  static constexpr size_t integral_size =\n      /* in case we need to round up an extra digit */ 1 +\n      /* decimal digits for uint128 */ 40 + 1;\n  char buffer[integral_size + /* . */ 1 + /* max digits uint128 */ 128];\n  buffer[integral_size] = '.';\n  char *const integral_digits_end = buffer + integral_size;\n  char *integral_digits_start;\n  char *const fractional_digits_start = buffer + integral_size + 1;\n  char *fractional_digits_end = fractional_digits_start;\n\n  if (exp >= 0) {\n    const int total_bits = input_bits - LeadingZeros(v) + exp;\n    integral_digits_start =\n        total_bits <= 64\n            ? PrintIntegralDigitsFromRightFast(static_cast<uint64_t>(v) << exp,\n                                               integral_digits_end)\n            : PrintIntegralDigitsFromRightFast(static_cast<uint128>(v) << exp,\n                                               integral_digits_end);\n  } else {\n    exp = -exp;\n\n    integral_digits_start = PrintIntegralDigitsFromRightFast(\n        exp < input_bits ? v >> exp : 0, integral_digits_end);\n    // PrintFractionalDigits may pull a carried 1 all the way up through the\n    // integral portion.\n    integral_digits_start[-1] = '0';\n\n    fractional_digits_end =\n        exp <= 64 ? PrintFractionalDigitsFast(v, fractional_digits_start, exp,\n                                              state.precision)\n                  : PrintFractionalDigitsFast(static_cast<uint128>(v),\n                                              fractional_digits_start, exp,\n                                              state.precision);\n    // There was a carry, so include the first digit too.\n    if (integral_digits_start[-1] != '0') --integral_digits_start;\n  }\n\n  size_t size =\n      static_cast<size_t>(fractional_digits_end - integral_digits_start);\n\n  // In `alt` mode (flag #) we keep the `.` even if there are no fractional\n  // digits. In non-alt mode, we strip it.\n  if (!state.ShouldPrintDot()) --size;\n  FinalPrint(state, absl::string_view(integral_digits_start, size),\n             /*padding_offset=*/0,\n             state.precision - static_cast<size_t>(fractional_digits_end -\n                                                   fractional_digits_start),\n             /*data_postfix=*/\"\");\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03061",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 518,
  "validation_status": "validated"
}