{
  "code": "{\n\n// public methods\nSPDLOG_INLINE logger::logger(const logger &other)\n    : name_(other.name_),\n      sinks_(other.sinks_),\n      level_(other.level_.load(std::memory_order_relaxed)),\n      flush_level_(other.flush_level_.load(std::memory_order_relaxed)),\n      custom_err_handler_(other.custom_err_handler_),\n      tracer_(other.tracer_) {}\n\nSPDLOG_INLINE logger::logger(logger &&other) SPDLOG_NOEXCEPT\n    : name_(std::move(other.name_)),\n      sinks_(std::move(other.sinks_)),\n      level_(other.level_.load(std::memory_order_relaxed)),\n      flush_level_(other.flush_level_.load(std::memory_order_relaxed)),\n      custom_err_handler_(std::move(other.custom_err_handler_)),\n      tracer_(std::move(other.tracer_))\n\n{}\n\nSPDLOG_INLINE logger &logger::operator=(logger other) SPDLOG_NOEXCEPT {\n    this->swap(other);\n    return *this;\n}\n\nSPDLOG_INLINE void logger::swap(spdlog::logger &other) SPDLOG_NOEXCEPT {\n    name_.swap(other.name_);\n    sinks_.swap(other.sinks_);\n\n    // swap level_\n    auto other_level = other.level_.load();\n    auto my_level = level_.exchange(other_level);\n    other.level_.store(my_level);\n\n    // swap flush level_\n    other_level = other.flush_level_.load();\n    my_level = flush_level_.exchange(other_level);\n    other.flush_level_.store(my_level);\n\n    custom_err_handler_.swap(other.custom_err_handler_);\n    std::swap(tracer_, other.tracer_);\n}\n\nSPDLOG_INLINE void swap(logger &a, logger &b) { a.swap(b); }\n\nSPDLOG_INLINE void logger::set_level(level::level_enum log_level) { level_.store(log_level); }\n\nSPDLOG_INLINE level::level_enum logger::level() const {\n    return static_cast<level::level_enum>(level_.load(std::memory_order_relaxed));\n}\n\nSPDLOG_INLINE const std::string &logger::name() const { return name_; }\n\n// set formatting for the sinks in this logger.\n// each sink will get a separate instance of the formatter object.\nSPDLOG_INLINE void logger::set_formatter(std::unique_ptr<formatter> f) {\n    for (auto it = sinks_.begin(); it != sinks_.end(); ++it) {\n        if (std::next(it) == sinks_.end()) {\n            // last element - we can be move it.\n            (*it)->set_formatter(std::move(f));\n            break;  // to prevent clang-tidy warning\n        } else {\n            (*it)->set_formatter(f->clone());\n        }\n    }\n}\n\nSPDLOG_INLINE void logger::set_pattern(std::string pattern, pattern_time_type time_type) {\n    auto new_formatter = details::make_unique<pattern_formatter>(std::move(pattern), time_type);\n    set_formatter(std::move(new_formatter));\n}\n\n// create new backtrace sink and move to it all our child sinks\nSPDLOG_INLINE void logger::enable_backtrace(size_t n_messages) { tracer_.enable(n_messages); }\n\n// restore orig sinks and level and delete the backtrace sink\nSPDLOG_INLINE void logger::disable_backtrace() { tracer_.disable(); }\n\nSPDLOG_INLINE void logger::dump_backtrace() { dump_backtrace_(); }\n\n// flush functions\nSPDLOG_INLINE void logger::flush() { flush_(); }\n\nSPDLOG_INLINE void logger::flush_on(level::level_enum log_level) { flush_level_.store(log_level); }\n\nSPDLOG_INLINE level::level_enum logger::flush_level() const {\n    return static_cast<level::level_enum>(flush_level_.load(std::memory_order_relaxed));\n}\n\n// sinks\nSPDLOG_INLINE const std::vector<sink_ptr> &logger::sinks() const { return sinks_; }\n\nSPDLOG_INLINE std::vector<sink_ptr> &logger::sinks() { return sinks_; }\n\n// error handler\nSPDLOG_INLINE void logger::set_error_handler(err_handler handler) {\n    custom_err_handler_ = std::move(handler);\n}\n\n// create new logger with same sinks and configuration.\nSPDLOG_INLINE std::shared_ptr<logger> logger::clone(std::string logger_name) {\n    auto cloned = std::make_shared<logger>(*this);\n    cloned->name_ = std::move(logger_name);\n    return cloned;\n}\n\n// protected methods\nSPDLOG_INLINE void logger::log_it_(const spdlog::details::log_msg &log_msg,\n                                   bool log_enabled,\n                                   bool traceback_enabled) {\n    if (log_enabled) {\n        sink_it_(log_msg);\n    }\n    if (traceback_enabled) {\n        tracer_.push_back(log_msg);\n    }\n}\n\nSPDLOG_INLINE void logger::sink_it_(const details::log_msg &msg) {\n    for (auto &sink : sinks_) {\n        if (sink->should_log(msg.level)) {\n            SPDLOG_TRY { sink->log(msg); }\n            SPDLOG_LOGGER_CATCH(msg.source)\n        }\n    }\n\n    if (should_flush_(msg)) {\n        flush_();\n    }\n}\n\nSPDLOG_INLINE void logger::flush_() {\n    for (auto &sink : sinks_) {\n        SPDLOG_TRY { sink->flush(); }\n        SPDLOG_LOGGER_CATCH(source_loc())\n    }\n}\n\nSPDLOG_INLINE void logger::dump_backtrace_() {\n    using details::log_msg;\n    if (tracer_.enabled() && !tracer_.empty()) {\n        sink_it_(\n            log_msg{name(), level::info, \"****************** Backtrace Start ******************\"});\n        tracer_.foreach_pop([this](const log_msg &msg) { this->sink_it_(msg); });\n        sink_it_(\n            log_msg{name(), level::info, \"****************** Backtrace End ********************\"});\n    }\n}\n\nSPDLOG_INLINE bool logger::should_flush_(const details::log_msg &msg) {\n    auto flush_level = flush_level_.load(std::memory_order_relaxed);\n    return (msg.level >= flush_level) && (msg.level != level::off);\n}\n\nSPDLOG_INLINE void logger::err_handler_(const std::string &msg) {\n    if (custom_err_handler_) {\n        custom_err_handler_(msg);\n    } else {\n        using std::chrono::system_clock;\n        static std::mutex mutex;\n        static std::chrono::system_clock::time_point last_report_time;\n        static size_t err_counter = 0;\n        std::lock_guard<std::mutex> lk{mutex};\n        auto now = system_clock::now();\n        err_counter++;\n        if (now - last_report_time < std::chrono::seconds(1)) {\n            return;\n        }\n        last_report_time = now;\n        auto tm_time = details::os::localtime(system_clock::to_time_t(now));\n        char date_buf[64];\n        std::strftime(date_buf, sizeof(date_buf), \"%Y-%m-%d %H:%M:%S\", &tm_time);\n#if defined(USING_R) && defined(R_R_H)  // if in R environment\n        REprintf(\"[*** LOG ERROR #%04zu ***] [%s] [%s] %s\\n\", err_counter, date_buf, name().c_str(),\n                 msg.c_str());\n#else\n        std::fprintf(stderr, \"[*** LOG ERROR #%04zu ***] [%s] [%s] %s\\n\", err_counter, date_buf,\n                     name().c_str(), msg.c_str());\n#endif\n    }\n}\n}",
  "id": "BLOCK-CPP-00034",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/logger-inl.h",
  "source_line": 16,
  "validation_status": "validated"
}