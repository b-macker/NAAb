{
  "code": "{\n\n// Constructs T into uninitialized storage pointed by `ptr` using the args\n// specified in the tuple.\ntemplate <class Alloc, class T, class Tuple, size_t... I>\nvoid ConstructFromTupleImpl(Alloc* alloc, T* ptr, Tuple&& t,\n                            absl::index_sequence<I...>) {\n  absl::allocator_traits<Alloc>::construct(\n      *alloc, ptr, std::get<I>(std::forward<Tuple>(t))...);\n}\n\ntemplate <class T, class F>\nstruct WithConstructedImplF {\n  template <class... Args>\n  decltype(std::declval<F>()(std::declval<T>())) operator()(\n      Args&&... args) const {\n    return std::forward<F>(f)(T(std::forward<Args>(args)...));\n  }\n  F&& f;\n};\n\ntemplate <class T, class Tuple, size_t... Is, class F>\ndecltype(std::declval<F>()(std::declval<T>())) WithConstructedImpl(\n    Tuple&& t, absl::index_sequence<Is...>, F&& f) {\n  return WithConstructedImplF<T, F>{std::forward<F>(f)}(\n      std::get<Is>(std::forward<Tuple>(t))...);\n}\n\ntemplate <class T, size_t... Is>\nauto TupleRefImpl(T&& t, absl::index_sequence<Is...>)\n    -> decltype(std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...)) {\n  return std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...);\n}\n\n// Returns a tuple of references to the elements of the input tuple. T must be a\n// tuple.\ntemplate <class T>\nauto TupleRef(T&& t) -> decltype(TupleRefImpl(\n    std::forward<T>(t),\n    absl::make_index_sequence<\n        std::tuple_size<typename std::decay<T>::type>::value>())) {\n  return TupleRefImpl(\n      std::forward<T>(t),\n      absl::make_index_sequence<\n          std::tuple_size<typename std::decay<T>::type>::value>());\n}\n\ntemplate <class F, class K, class V>\ndecltype(std::declval<F>()(std::declval<const K&>(), std::piecewise_construct,\n                           std::declval<std::tuple<K>>(), std::declval<V>()))\nDecomposePairImpl(F&& f, std::pair<std::tuple<K>, V> p) {\n  const auto& key = std::get<0>(p.first);\n  return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),\n                            std::move(p.second));\n}\n\n}",
  "id": "BLOCK-CPP-04985",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/container_memory.h",
  "source_line": 88,
  "validation_status": "validated"
}