{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::zipf_distribution produces random integer-values in the range [0, k],\n// distributed according to the unnormalized discrete probability function:\n//\n//  P(x) = (v + x) ^ -q\n//\n// The parameter `v` must be greater than 0 and the parameter `q` must be\n// greater than 1. If either of these parameters take invalid values then the\n// behavior is undefined.\n//\n// IntType is the result_type generated by the generator. It must be of integral\n// type; a static_assert ensures this is the case.\n//\n// The implementation is based on W.Hormann, G.Derflinger:\n//\n// \"Rejection-Inversion to Generate Variates from Monotone Discrete\n// Distributions\"\n//\n// http://eeyore.wu-wien.ac.at/papers/96-04-04.wh-der.ps.gz\n//\ntemplate <typename IntType = int>\nclass zipf_distribution {\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = zipf_distribution;\n\n    // Preconditions: k > 0, v > 0, q > 1\n    // The precondidtions are validated when NDEBUG is not defined via\n    // a pair of assert() directives.\n    // If NDEBUG is defined and either or both of these parameters take invalid\n    // values, the behavior of the class is undefined.\n    explicit param_type(result_type k = (std::numeric_limits<IntType>::max)(),\n                        double q = 2.0, double v = 1.0);\n\n    result_type k() const { return k_; }\n    double q() const { return q_; }\n    double v() const { return v_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.k_ == b.k_ && a.q_ == b.q_ && a.v_ == b.v_;\n    }\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class zipf_distribution;\n    inline double h(double x) const;\n    inline double hinv(double x) const;\n    inline double compute_s() const;\n    inline double pow_negative_q(double x) const;\n\n    // Parameters here are exactly the same as the parameters of Algorithm ZRI\n    // in the paper.\n    IntType k_;\n    double q_;\n    double v_;\n\n    double one_minus_q_;  // 1-q\n    double s_;\n    double one_minus_q_inv_;  // 1 / 1-q\n    double hxm_;              // h(k + 0.5)\n    double hx0_minus_hxm_;    // h(x0) - h(k + 0.5)\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::zipf_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  zipf_distribution()\n      : zipf_distribution((std::numeric_limits<IntType>::max)()) {}\n\n  explicit zipf_distribution(result_type k, double q = 2.0, double v = 1.0)\n      : param_(k, q, v) {}\n\n  explicit zipf_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  result_type k() const { return param_.k(); }\n  double q() const { return param_.q(); }\n  double v() const { return param_.v(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const { return k(); }\n\n  friend bool operator==(const zipf_distribution& a,\n                         const zipf_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const zipf_distribution& a,\n                         const zipf_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n};\n\n// --------------------------------------------------------------------------\n// Implementation details follow\n// --------------------------------------------------------------------------\n\ntemplate <typename IntType>\nzipf_distribution<IntType>::param_type::param_type(\n    typename zipf_distribution<IntType>::result_type k, double q, double v)\n    : k_(k), q_(q), v_(v), one_minus_q_(1 - q) {\n  assert(q > 1);\n  assert(v > 0);\n  assert(k > 0);\n  one_minus_q_inv_ = 1 / one_minus_q_;\n\n  // Setup for the ZRI algorithm (pg 17 of the paper).\n  // Compute: h(i max) => h(k + 0.5)\n  constexpr double kMax = 18446744073709549568.0;\n  double kd = static_cast<double>(k);\n  // TODO(absl-team): Determine if this check is needed, and if so, add a test\n  // that fails for k > kMax\n  if (kd > kMax) {\n    // Ensure that our maximum value is capped to a value which will\n    // round-trip back through double.\n    kd = kMax;\n  }\n  hxm_ = h(kd + 0.5);\n\n  // Compute: h(0)\n  const bool use_precomputed = (v == 1.0 && q == 2.0);\n  const double h0x5 = use_precomputed ? (-1.0 / 1.5)  // exp(-log(1.5))\n                                      : h(0.5);\n  const double elogv_q = (v_ == 1.0) ? 1 : pow_negative_q(v_);\n\n  // h(0) = h(0.5) - exp(log(v) * -q)\n  hx0_minus_hxm_ = (h0x5 - elogv_q) - hxm_;\n\n  // And s\n  s_ = use_precomputed ? 0.46153846153846123 : compute_s();\n}\n\ntemplate <typename IntType>\ndouble zipf_distribution<IntType>::param_type::h(double x) const {\n  // std::exp(one_minus_q_ * std::log(v_ + x)) * one_minus_q_inv_;\n  x += v_;\n  return (one_minus_q_ == -1.0)\n             ? (-1.0 / x)  // -exp(-log(x))\n             : (std::exp(std::log(x) * one_minus_q_) * one_minus_q_inv_);\n}\n\ntemplate <typename IntType>\ndouble zipf_distribution<IntType>::param_type::hinv(double x) const {\n  // std::exp(one_minus_q_inv_ * std::log(one_minus_q_ * x)) - v_;\n  return -v_ + ((one_minus_q_ == -1.0)\n                    ? (-1.0 / x)  // exp(-log(-x))\n                    : std::exp(one_minus_q_inv_ * std::log(one_minus_q_ * x)));\n}\n\ntemplate <typename IntType>\ndouble zipf_distribution<IntType>::param_type::compute_s() const {\n  // 1 - hinv(h(1.5) - std::exp(std::log(v_ + 1) * -q_));\n  return 1.0 - hinv(h(1.5) - pow_negative_q(v_ + 1.0));\n}\n\ntemplate <typename IntType>\ndouble zipf_distribution<IntType>::param_type::pow_negative_q(double x) const {\n  // std::exp(std::log(x) * -q_);\n  return q_ == 2.0 ? (1.0 / (x * x)) : std::exp(std::log(x) * -q_);\n}\n\ntemplate <typename IntType>\ntemplate <typename URBG>\ntypename zipf_distribution<IntType>::result_type\nzipf_distribution<IntType>::operator()(\n    URBG& g, const param_type& p) {  // NOLINT(runtime/references)\n  absl::uniform_real_distribution<double> uniform_double;\n  double k;\n  for (;;) {\n    const double v = uniform_double(g);\n    const double u = p.hxm_ + v * p.hx0_minus_hxm_;\n    const double x = p.hinv(u);\n    k = rint(x);              // std::floor(x + 0.5);\n    if (k > static_cast<double>(p.k())) continue;  // reject k > max_k\n    if (k - x <= p.s_) break;\n    const double h = p.h(k + 0.5);\n    const double r = p.pow_negative_q(p.v_ + k);\n    if (u >= h - r) break;\n  }\n  IntType ki = static_cast<IntType>(k);\n  assert(ki <= p.k_);\n  return ki;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const zipf_distribution<IntType>& x) {\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os.precision(random_internal::stream_precision_helper<double>::kPrecision);\n  os << static_cast<stream_type>(x.k()) << os.fill() << x.q() << os.fill()\n     << x.v();\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    zipf_distribution<IntType>& x) {        // NOLINT(runtime/references)\n  using result_type = typename zipf_distribution<IntType>::result_type;\n  using param_type = typename zipf_distribution<IntType>::param_type;\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n  stream_type k;\n  double q;\n  double v;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  is >> k >> q >> v;\n  if (!is.fail()) {\n    x.param(param_type(static_cast<result_type>(k), q, v));\n  }\n  return is;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03940",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/zipf_distribution.h",
  "source_line": 29,
  "validation_status": "validated"
}