{
  "code": "{\nconstexpr int kLogMessageBufferSize = 15000;\n\nclass LogMessage {\n public:\n  struct InfoTag {};\n  struct WarningTag {};\n  struct ErrorTag {};\n\n  // Used for `LOG`.\n  LogMessage(const char* file, int line,\n             absl::LogSeverity severity) ABSL_ATTRIBUTE_COLD;\n  // These constructors are slightly smaller/faster to call; the severity is\n  // curried into the function pointer.\n  LogMessage(const char* file, int line,\n             InfoTag) ABSL_ATTRIBUTE_COLD ABSL_ATTRIBUTE_NOINLINE;\n  LogMessage(const char* file, int line,\n             WarningTag) ABSL_ATTRIBUTE_COLD ABSL_ATTRIBUTE_NOINLINE;\n  LogMessage(const char* file, int line,\n             ErrorTag) ABSL_ATTRIBUTE_COLD ABSL_ATTRIBUTE_NOINLINE;\n  LogMessage(const LogMessage&) = delete;\n  LogMessage& operator=(const LogMessage&) = delete;\n  ~LogMessage() ABSL_ATTRIBUTE_COLD;\n\n  // Overrides the location inferred from the callsite.  The string pointed to\n  // by `file` must be valid until the end of the statement.\n  LogMessage& AtLocation(absl::string_view file, int line);\n  // Omits the prefix from this line.  The prefix includes metadata about the\n  // logged data such as source code location and timestamp.\n  LogMessage& NoPrefix();\n  // Sets the verbosity field of the logged message as if it was logged by\n  // `VLOG(verbose_level)`.  Unlike `VLOG`, this method does not affect\n  // evaluation of the statement when the specified `verbose_level` has been\n  // disabled.  The only effect is on `absl::LogSink` implementations which\n  // make use of the `absl::LogSink::verbosity()` value.  The value\n  // `absl::LogEntry::kNoVerbosityLevel` can be specified to mark the message\n  // not verbose.\n  LogMessage& WithVerbosity(int verbose_level);\n  // Uses the specified timestamp instead of one collected in the constructor.\n  LogMessage& WithTimestamp(absl::Time timestamp);\n  // Uses the specified thread ID instead of one collected in the constructor.\n  LogMessage& WithThreadID(absl::LogEntry::tid_t tid);\n  // Copies all metadata (but no data) from the specified `absl::LogEntry`.\n  LogMessage& WithMetadataFrom(const absl::LogEntry& entry);\n  // Appends to the logged message a colon, a space, a textual description of\n  // the current value of `errno` (as by strerror(3)), and the numerical value\n  // of `errno`.\n  LogMessage& WithPerror();\n  // Sends this message to `*sink` in addition to whatever other sinks it would\n  // otherwise have been sent to.  `sink` must not be null.\n  LogMessage& ToSinkAlso(absl::LogSink* sink);\n  // Sends this message to `*sink` and no others.  `sink` must not be null.\n  LogMessage& ToSinkOnly(absl::LogSink* sink);\n\n  // Don't call this method from outside this library.\n  LogMessage& InternalStream() { return *this; }\n\n  // By-value overloads for small, common types let us overlook common failures\n  // to define globals and static data members (i.e. in a .cc file).\n  // clang-format off\n  // The CUDA toolchain cannot handle these <<<'s:\n  LogMessage& operator<<(char v) { return operator<< <char>(v); }\n  LogMessage& operator<<(signed char v) { return operator<< <signed char>(v); }\n  LogMessage& operator<<(unsigned char v) {\n    return operator<< <unsigned char>(v);\n  }\n  LogMessage& operator<<(signed short v) {  // NOLINT\n    return operator<< <signed short>(v);  // NOLINT\n  }\n  LogMessage& operator<<(signed int v) { return operator<< <signed int>(v); }\n  LogMessage& operator<<(signed long v) {  // NOLINT\n    return operator<< <signed long>(v);  // NOLINT\n  }\n  LogMessage& operator<<(signed long long v) {  // NOLINT\n    return operator<< <signed long long>(v);  // NOLINT\n  }\n  LogMessage& operator<<(unsigned short v) {  // NOLINT\n    return operator<< <unsigned short>(v);  // NOLINT\n  }\n  LogMessage& operator<<(unsigned int v) {\n    return operator<< <unsigned int>(v);\n  }\n  LogMessage& operator<<(unsigned long v) {  // NOLINT\n    return operator<< <unsigned long>(v);  // NOLINT\n  }\n  LogMessage& operator<<(unsigned long long v) {  // NOLINT\n    return operator<< <unsigned long long>(v);  // NOLINT\n  }\n  LogMessage& operator<<(void* v) { return operator<< <void*>(v); }\n  LogMessage& operator<<(const void* v) { return operator<< <const void*>(v); }\n  LogMessage& operator<<(float v) { return operator<< <float>(v); }\n  LogMessage& operator<<(double v) { return operator<< <double>(v); }\n  LogMessage& operator<<(bool v) { return operator<< <bool>(v); }\n  // clang-format on\n\n  // These overloads are more efficient since no `ostream` is involved.\n  LogMessage& operator<<(const std::string& v);\n  LogMessage& operator<<(absl::string_view v);\n\n  // Handle stream manipulators e.g. std::endl.\n  LogMessage& operator<<(std::ostream& (*m)(std::ostream& os));\n  LogMessage& operator<<(std::ios_base& (*m)(std::ios_base& os));\n\n  // Literal strings.  This allows us to record C string literals as literals in\n  // the logging.proto.Value.\n  //\n  // Allow this overload to be inlined to prevent generating instantiations of\n  // this template for every value of `SIZE` encountered in each source code\n  // file. That significantly increases linker input sizes. Inlining is cheap\n  // because the argument to this overload is almost always a string literal so\n  // the call to `strlen` can be replaced at compile time. The overload for\n  // `char[]` below should not be inlined. The compiler typically does not have\n  // the string at compile time and cannot replace the call to `strlen` so\n  // inlining it increases the binary size. See the discussion on\n  // cl/107527369.\n  template <int SIZE>\n  LogMessage& operator<<(const char (&buf)[SIZE]);\n\n  // This prevents non-const `char[]` arrays from looking like literals.\n  template <int SIZE>\n  LogMessage& operator<<(char (&buf)[SIZE]) ABSL_ATTRIBUTE_NOINLINE;\n\n  // Types that support `AbslStringify()` are serialized that way.\n  template <typename T,\n            typename std::enable_if<absl::HasAbslStringify<T>::value,\n                                    int>::type = 0>\n  LogMessage& operator<<(const T& v) ABSL_ATTRIBUTE_NOINLINE;\n\n  // Types that don't support `AbslStringify()` but do support streaming into a\n  // `std::ostream&` are serialized that way.\n  template <typename T,\n            typename std::enable_if<!absl::HasAbslStringify<T>::value,\n                                    int>::type = 0>\n  LogMessage& operator<<(const T& v) ABSL_ATTRIBUTE_NOINLINE;\n\n  // Note: We explicitly do not support `operator<<` for non-const references\n  // because it breaks logging of non-integer bitfield types (i.e., enums).\n\n protected:\n  // Call `abort()` or similar to perform `LOG(FATAL)` crash.  It is assumed\n  // that the caller has already generated and written the trace as appropriate.\n  ABSL_ATTRIBUTE_NORETURN static void FailWithoutStackTrace();\n\n  // Similar to `FailWithoutStackTrace()`, but without `abort()`.  Terminates\n  // the process with an error exit code.\n  ABSL_ATTRIBUTE_NORETURN static void FailQuietly();\n\n  // Dispatches the completed `absl::LogEntry` to applicable `absl::LogSink`s.\n  // This might as well be inlined into `~LogMessage` except that\n  // `~LogMessageFatal` needs to call it early.\n  void Flush();\n\n  // After this is called, failures are done as quiet as possible for this log\n  // message.\n  void SetFailQuietly();\n\n private:\n  struct LogMessageData;  // Opaque type containing message state\n  friend class AsLiteralImpl;\n  friend class StringifySink;\n\n  // This streambuf writes directly into the structured logging buffer so that\n  // arbitrary types can be encoded as string data (using\n  // `operator<<(std::ostream &, ...)` without any extra allocation or copying.\n  // Space is reserved before the data to store the length field, which is\n  // filled in by `~OstreamView`.\n  class OstreamView final : public std::streambuf {\n   public:\n    explicit OstreamView(LogMessageData& message_data);\n    ~OstreamView() override;\n    OstreamView(const OstreamView&) = delete;\n    OstreamView& operator=(const OstreamView&) = delete;\n    std::ostream& stream();\n\n   private:\n    LogMessageData& data_;\n    absl::Span<char> encoded_remaining_copy_;\n    absl::Span<char> message_start_;\n    absl::Span<char> string_start_;\n  };\n\n  enum class StringType {\n    kLiteral,\n    kNotLiteral,\n  };\n  template <StringType str_type>\n  void CopyToEncodedBuffer(absl::string_view str) ABSL_ATTRIBUTE_NOINLINE;\n  template <StringType str_type>\n  void CopyToEncodedBuffer(char ch, size_t num) ABSL_ATTRIBUTE_NOINLINE;\n\n  // Returns `true` if the message is fatal or enabled debug-fatal.\n  bool IsFatal() const;\n\n  // Records some tombstone-type data in anticipation of `Die`.\n  void PrepareToDie();\n  void Die();\n\n  void SendToLog();\n\n  // Checks `FLAGS_log_backtrace_at` and appends a backtrace if appropriate.\n  void LogBacktraceIfNeeded();\n\n  // This should be the first data member so that its initializer captures errno\n  // before any other initializers alter it (e.g. with calls to new) and so that\n  // no other destructors run afterward an alter it (e.g. with calls to delete).\n  absl::base_internal::ErrnoSaver errno_saver_;\n\n  // We keep the data in a separate struct so that each instance of `LogMessage`\n  // uses less stack space.\n  std::unique_ptr<LogMessageData> data_;\n};\n\n// Helper class so that `AbslStringify()` can modify the LogMessage.\nclass StringifySink final {\n public:\n  explicit StringifySink(LogMessage& message) : message_(message) {}\n\n  void Append(size_t count, char ch) {\n    message_.CopyToEncodedBuffer<LogMessage::StringType::kNotLiteral>(ch,\n                                                                      count);\n  }\n\n  void Append(absl::string_view v) {\n    message_.CopyToEncodedBuffer<LogMessage::StringType::kNotLiteral>(v);\n  }\n\n  // For types that implement `AbslStringify` using `absl::Format()`.\n  friend void AbslFormatFlush(StringifySink* sink, absl::string_view v) {\n    sink->Append(v);\n  }\n\n private:\n  LogMessage& message_;\n};\n\n// Note: the following is declared `ABSL_ATTRIBUTE_NOINLINE`\ntemplate <typename T,\n          typename std::enable_if<absl::HasAbslStringify<T>::value, int>::type>\nLogMessage& LogMessage::operator<<(const T& v) {\n  StringifySink sink(*this);\n  // Replace with public API.\n  AbslStringify(sink, v);\n  return *this;\n}\n\n// Note: the following is declared `ABSL_ATTRIBUTE_NOINLINE`\ntemplate <typename T,\n          typename std::enable_if<!absl::HasAbslStringify<T>::value, int>::type>\nLogMessage& LogMessage::operator<<(const T& v) {\n  OstreamView view(*data_);\n  view.stream() << log_internal::NullGuard<T>().Guard(v);\n  return *this;\n}\n\ntemplate <int SIZE>\nLogMessage& LogMessage::operator<<(const char (&buf)[SIZE]) {\n  CopyToEncodedBuffer<StringType::kLiteral>(buf);\n  return *this;\n}\n\n// Note: the following is declared `ABSL_ATTRIBUTE_NOINLINE`\ntemplate <int SIZE>\nLogMessage& LogMessage::operator<<(char (&buf)[SIZE]) {\n  CopyToEncodedBuffer<StringType::kNotLiteral>(buf);\n  return *this;\n}\n// We instantiate these specializations in the library's TU to save space in\n// other TUs.  Since the template is marked `ABSL_ATTRIBUTE_NOINLINE` we will be\n// emitting a function call either way.\nextern template LogMessage& LogMessage::operator<<(const char& v);\nextern template LogMessage& LogMessage::operator<<(const signed char& v);\nextern template LogMessage& LogMessage::operator<<(const unsigned char& v);\nextern template LogMessage& LogMessage::operator<<(const short& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(\n    const unsigned short& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(const int& v);\nextern template LogMessage& LogMessage::operator<<(\n    const unsigned int& v);                                         // NOLINT\nextern template LogMessage& LogMessage::operator<<(const long& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(\n    const unsigned long& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(\n    const long long& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(\n    const unsigned long long& v);  // NOLINT\nextern template LogMessage& LogMessage::operator<<(void* const& v);\nextern template LogMessage& LogMessage::operator<<(const void* const& v);\nextern template LogMessage& LogMessage::operator<<(const float& v);\nextern template LogMessage& LogMessage::operator<<(const double& v);\nextern template LogMessage& LogMessage::operator<<(const bool& v);\n\nextern template void LogMessage::CopyToEncodedBuffer<\n    LogMessage::StringType::kLiteral>(absl::string_view str);\nextern template void LogMessage::CopyToEncodedBuffer<\n    LogMessage::StringType::kNotLiteral>(absl::string_view str);\nextern template void\nLogMessage::CopyToEncodedBuffer<LogMessage::StringType::kLiteral>(char ch,\n                                                                  size_t num);\nextern template void LogMessage::CopyToEncodedBuffer<\n    LogMessage::StringType::kNotLiteral>(char ch, size_t num);\n\n// `LogMessageFatal` ensures the process will exit in failure after logging this\n// message.\nclass LogMessageFatal final : public LogMessage {\n public:\n  LogMessageFatal(const char* file, int line) ABSL_ATTRIBUTE_COLD;\n  LogMessageFatal(const char* file, int line,\n                  absl::string_view failure_msg) ABSL_ATTRIBUTE_COLD;\n  ABSL_ATTRIBUTE_NORETURN ~LogMessageFatal();\n};\n\nclass LogMessageQuietlyFatal final : public LogMessage {\n public:\n  LogMessageQuietlyFatal(const char* file, int line) ABSL_ATTRIBUTE_COLD;\n  LogMessageQuietlyFatal(const char* file, int line,\n                         absl::string_view failure_msg) ABSL_ATTRIBUTE_COLD;\n  ABSL_ATTRIBUTE_NORETURN ~LogMessageQuietlyFatal();\n};\n\n}",
  "id": "BLOCK-CPP-05747",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/log_message.h",
  "source_line": 49,
  "validation_status": "validated"
}