{
  "code": "{\npublic:\n  enum class Kind { Basic, PathSensitive };\n\nprotected:\n  friend class BugReportEquivClass;\n  friend class BugReporter;\n\n  Kind K;\n  const BugType& BT;\n  std::string ShortDescription;\n  std::string Description;\n\n  SmallVector<SourceRange, 4> Ranges;\n  SmallVector<std::shared_ptr<PathDiagnosticNotePiece>, 4> Notes;\n  SmallVector<FixItHint, 4> Fixits;\n\n  BugReport(Kind kind, const BugType &bt, StringRef desc)\n      : BugReport(kind, bt, \"\", desc) {}\n\n  BugReport(Kind K, const BugType &BT, StringRef ShortDescription,\n            StringRef Description)\n      : K(K), BT(BT), ShortDescription(ShortDescription),\n        Description(Description) {}\n\npublic:\n  virtual ~BugReport() = default;\n\n  Kind getKind() const { return K; }\n\n  const BugType& getBugType() const { return BT; }\n\n  /// A verbose warning message that is appropriate for displaying next to\n  /// the source code that introduces the problem. The description should be\n  /// at least a full sentence starting with a capital letter. The period at\n  /// the end of the warning is traditionally omitted. If the description\n  /// consists of multiple sentences, periods between the sentences are\n  /// encouraged, but the period at the end of the description is still omitted.\n  StringRef getDescription() const { return Description; }\n\n  /// A short general warning message that is appropriate for displaying in\n  /// the list of all reported bugs. It should describe what kind of bug is found\n  /// but does not need to try to go into details of that specific bug.\n  /// Grammatical conventions of getDescription() apply here as well.\n  StringRef getShortDescription(bool UseFallback = true) const {\n    if (ShortDescription.empty() && UseFallback)\n      return Description;\n    return ShortDescription;\n  }\n\n  /// The primary location of the bug report that points at the undesirable\n  /// behavior in the code. UIs should attach the warning description to this\n  /// location. The warning description should describe the bad behavior\n  /// at this location.\n  virtual PathDiagnosticLocation getLocation() const = 0;\n\n  /// The smallest declaration that contains the bug location.\n  /// This is purely cosmetic; the declaration can be displayed to the user\n  /// but it does not affect whether the report is emitted.\n  virtual const Decl *getDeclWithIssue() const = 0;\n\n  /// Get the location on which the report should be uniqued. Two warnings are\n  /// considered to be equivalent whenever they have the same bug types,\n  /// descriptions, and uniqueing locations. Out of a class of equivalent\n  /// warnings only one gets displayed to the user. For most warnings the\n  /// uniqueing location coincides with their location, but sometimes\n  /// it makes sense to use different locations. For example, a leak\n  /// checker can place the warning at the location where the last reference\n  /// to the leaking resource is dropped but at the same time unique the warning\n  /// by where that resource is acquired (allocated).\n  virtual PathDiagnosticLocation getUniqueingLocation() const = 0;\n\n  /// Get the declaration that corresponds to (usually contains) the uniqueing\n  /// location. This is not actively used for uniqueing, i.e. otherwise\n  /// identical reports that have different uniqueing decls will be considered\n  /// equivalent.\n  virtual const Decl *getUniqueingDecl() const = 0;\n\n  /// Add new item to the list of additional notes that need to be attached to\n  /// this report. If the report is path-sensitive, these notes will not be\n  /// displayed as part of the execution path explanation, but will be displayed\n  /// separately. Use bug visitors if you need to add an extra path note.\n  void addNote(StringRef Msg, const PathDiagnosticLocation &Pos,\n               ArrayRef<SourceRange> Ranges = {}) {\n    auto P = std::make_shared<PathDiagnosticNotePiece>(Pos, Msg);\n\n    for (const auto &R : Ranges)\n      P->addRange(R);\n\n    Notes.push_back(std::move(P));\n  }\n\n  ArrayRef<std::shared_ptr<PathDiagnosticNotePiece>> getNotes() {\n    return Notes;\n  }\n\n  /// Add a range to a bug report.\n  ///\n  /// Ranges are used to highlight regions of interest in the source code.\n  /// They should be at the same source code line as the BugReport location.\n  /// By default, the source range of the statement corresponding to the error\n  /// node will be used; add a single invalid range to specify absence of\n  /// ranges.\n  void addRange(SourceRange R) {\n    assert((R.isValid() || Ranges.empty()) && \"Invalid range can only be used \"\n                           \"to specify that the report does not have a range.\");\n    Ranges.push_back(R);\n  }\n\n  /// Get the SourceRanges associated with the report.\n  virtual ArrayRef<SourceRange> getRanges() const {\n    return Ranges;\n  }\n\n  /// Add a fix-it hint to the bug report.\n  ///\n  /// Fix-it hints are the suggested edits to the code that would resolve\n  /// the problem explained by the bug report. Fix-it hints should be\n  /// as conservative as possible because it is not uncommon for the user\n  /// to blindly apply all fixits to their project. Note that it is very hard\n  /// to produce a good fix-it hint for most path-sensitive warnings.\n  void addFixItHint(const FixItHint &F) {\n    Fixits.push_back(F);\n  }\n\n  llvm::ArrayRef<FixItHint> getFixits() const { return Fixits; }\n\n  /// Reports are uniqued to ensure that we do not emit multiple diagnostics\n  /// for each bug.\n  virtual void Profile(llvm::FoldingSetNodeID& hash) const = 0;\n}",
  "id": "BLOCK-CPP-22425",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h",
  "source_line": 119,
  "validation_status": "validated"
}