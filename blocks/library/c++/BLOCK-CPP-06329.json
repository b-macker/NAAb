{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nclass UntypedFormatSpec;\n\nnamespace str_format_internal {\n\nclass BoundConversion : public FormatConversionSpecImpl {\n public:\n  const FormatArgImpl* arg() const { return arg_; }\n  void set_arg(const FormatArgImpl* a) { arg_ = a; }\n\n private:\n  const FormatArgImpl* arg_;\n};\n\n// This is the type-erased class that the implementation uses.\nclass UntypedFormatSpecImpl {\n public:\n  UntypedFormatSpecImpl() = delete;\n\n  explicit UntypedFormatSpecImpl(string_view s)\n      : data_(s.data()), size_(s.size()) {}\n  explicit UntypedFormatSpecImpl(\n      const str_format_internal::ParsedFormatBase* pc)\n      : data_(pc), size_(~size_t{}) {}\n\n  bool has_parsed_conversion() const { return size_ == ~size_t{}; }\n\n  string_view str() const {\n    assert(!has_parsed_conversion());\n    return string_view(static_cast<const char*>(data_), size_);\n  }\n  const str_format_internal::ParsedFormatBase* parsed_conversion() const {\n    assert(has_parsed_conversion());\n    return static_cast<const str_format_internal::ParsedFormatBase*>(data_);\n  }\n\n  template <typename T>\n  static const UntypedFormatSpecImpl& Extract(const T& s) {\n    return s.spec_;\n  }\n\n private:\n  const void* data_;\n  size_t size_;\n};\n\ntemplate <typename T, FormatConversionCharSet...>\nstruct MakeDependent {\n  using type = T;\n};\n\n// Implicitly convertible from `const char*`, `string_view`, and the\n// `ExtendedParsedFormat` type. This abstraction allows all format functions to\n// operate on any without providing too many overloads.\ntemplate <FormatConversionCharSet... Args>\nclass FormatSpecTemplate\n    : public MakeDependent<UntypedFormatSpec, Args...>::type {\n  using Base = typename MakeDependent<UntypedFormatSpec, Args...>::type;\n\n  template <bool res>\n  struct ErrorMaker {\n    constexpr bool operator()(int) const { return res; }\n  };\n\n  template <int i, int j>\n  static constexpr bool CheckArity(ErrorMaker<true> SpecifierCount = {},\n                                   ErrorMaker<i == j> ParametersPassed = {}) {\n    static_assert(SpecifierCount(i) == ParametersPassed(j),\n                  \"Number of arguments passed must match the number of \"\n                  \"conversion specifiers.\");\n    return true;\n  }\n\n  template <FormatConversionCharSet specified, FormatConversionCharSet passed,\n            int arg>\n  static constexpr bool CheckMatch(\n      ErrorMaker<Contains(specified, passed)> MismatchedArgumentNumber = {}) {\n    static_assert(MismatchedArgumentNumber(arg),\n                  \"Passed argument must match specified format.\");\n    return true;\n  }\n\n  template <FormatConversionCharSet... C, size_t... I>\n  static bool CheckMatches(absl::index_sequence<I...>) {\n    bool res[] = {true, CheckMatch<Args, C, I + 1>()...};\n    (void)res;\n    return true;\n  }\n\n public:\n#ifdef ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n\n  // Honeypot overload for when the string is not constexpr.\n  // We use the 'unavailable' attribute to give a better compiler error than\n  // just 'method is deleted'.\n  FormatSpecTemplate(...)  // NOLINT\n      __attribute__((unavailable(\"Format string is not constexpr.\")));\n\n  // Honeypot overload for when the format is constexpr and invalid.\n  // We use the 'unavailable' attribute to give a better compiler error than\n  // just 'method is deleted'.\n  // To avoid checking the format twice, we just check that the format is\n  // constexpr. If it is valid, then the overload below will kick in.\n  // We add the template here to make this overload have lower priority.\n  template <typename = void>\n  FormatSpecTemplate(const char* s)  // NOLINT\n      __attribute__((\n          enable_if(str_format_internal::EnsureConstexpr(s), \"constexpr trap\"),\n          unavailable(\n              \"Format specified does not match the arguments passed.\")));\n\n  template <typename T = void>\n  FormatSpecTemplate(string_view s)  // NOLINT\n      __attribute__((enable_if(str_format_internal::EnsureConstexpr(s),\n                               \"constexpr trap\")))\n      : Base(\"to avoid noise in the compiler error\") {\n    static_assert(sizeof(T*) == 0,\n                  \"Format specified does not match the arguments passed.\");\n  }\n\n  // Good format overload.\n  FormatSpecTemplate(const char* s)  // NOLINT\n      __attribute__((enable_if(ValidFormatImpl<Args...>(s), \"bad format trap\")))\n      : Base(s) {}\n\n  FormatSpecTemplate(string_view s)  // NOLINT\n      __attribute__((enable_if(ValidFormatImpl<Args...>(s), \"bad format trap\")))\n      : Base(s) {}\n\n#else  // ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n\n  FormatSpecTemplate(const char* s) : Base(s) {}  // NOLINT\n  FormatSpecTemplate(string_view s) : Base(s) {}  // NOLINT\n\n#endif  // ABSL_INTERNAL_ENABLE_FORMAT_CHECKER\n\n  template <FormatConversionCharSet... C>\n  FormatSpecTemplate(const ExtendedParsedFormat<C...>& pc)  // NOLINT\n      : Base(&pc) {\n    CheckArity<sizeof...(C), sizeof...(Args)>();\n    CheckMatches<C...>(absl::make_index_sequence<sizeof...(C)>{});\n  }\n};\n\nclass Streamable {\n public:\n  Streamable(const UntypedFormatSpecImpl& format,\n             absl::Span<const FormatArgImpl> args)\n      : format_(format), args_(args.begin(), args.end()) {}\n\n  std::ostream& Print(std::ostream& os) const;\n\n  friend std::ostream& operator<<(std::ostream& os, const Streamable& l) {\n    return l.Print(os);\n  }\n\n private:\n  const UntypedFormatSpecImpl& format_;\n  absl::InlinedVector<FormatArgImpl, 4> args_;\n};\n\n// for testing\nstd::string Summarize(UntypedFormatSpecImpl format,\n                      absl::Span<const FormatArgImpl> args);\nbool BindWithPack(const UnboundConversion* props,\n                  absl::Span<const FormatArgImpl> pack, BoundConversion* bound);\n\nbool FormatUntyped(FormatRawSinkImpl raw_sink, UntypedFormatSpecImpl format,\n                   absl::Span<const FormatArgImpl> args);\n\nstd::string& AppendPack(std::string* out, UntypedFormatSpecImpl format,\n                        absl::Span<const FormatArgImpl> args);\n\nstd::string FormatPack(UntypedFormatSpecImpl format,\n                       absl::Span<const FormatArgImpl> args);\n\nint FprintF(std::FILE* output, UntypedFormatSpecImpl format,\n            absl::Span<const FormatArgImpl> args);\nint SnprintF(char* output, size_t size, UntypedFormatSpecImpl format,\n             absl::Span<const FormatArgImpl> args);\n\n// Returned by Streamed(v). Converts via '%s' to the std::string created\n// by std::ostream << v.\ntemplate <typename T>\nclass StreamedWrapper {\n public:\n  explicit StreamedWrapper(const T& v) : v_(v) {}\n\n private:\n  template <typename S>\n  friend ArgConvertResult<FormatConversionCharSetUnion(\n      FormatConversionCharSetInternal::s, FormatConversionCharSetInternal::v)>\n  FormatConvertImpl(const StreamedWrapper<S>& v, FormatConversionSpecImpl conv,\n                    FormatSinkImpl* out);\n  const T& v_;\n};\n\n}  // namespace str_format_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06329",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/bind.h",
  "source_line": 34,
  "validation_status": "validated"
}