{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace {\n\n// These atomics represent logging library configuration.\n// Integer types are used instead of absl::LogSeverity to ensure that a\n// lock-free std::atomic is used when possible.\nABSL_CONST_INIT std::atomic<int> min_log_level{\n    static_cast<int>(absl::LogSeverityAtLeast::kInfo)};\nABSL_CONST_INIT std::atomic<int> stderrthreshold{\n    static_cast<int>(absl::LogSeverityAtLeast::kError)};\n// We evaluate this value as a hash comparison to avoid having to\n// hold a mutex or make a copy (to access the value of a string-typed flag) in\n// very hot codepath.\nABSL_CONST_INIT std::atomic<size_t> log_backtrace_at_hash{0};\nABSL_CONST_INIT std::atomic<bool> prepend_log_prefix{true};\n\nconstexpr char kDefaultAndroidTag[] = \"native\";\nABSL_CONST_INIT std::atomic<const char*> android_log_tag{kDefaultAndroidTag};\n\nABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES\nabsl::base_internal::AtomicHook<log_internal::LoggingGlobalsListener>\n    logging_globals_listener;\n\nsize_t HashSiteForLogBacktraceAt(absl::string_view file, int line) {\n  return absl::HashOf(file, line);\n}\n\nvoid TriggerLoggingGlobalsListener() {\n  auto* listener = logging_globals_listener.Load();\n  if (listener != nullptr) listener();\n}\n\n}  // namespace\n\nnamespace log_internal {\n\nvoid RawSetMinLogLevel(absl::LogSeverityAtLeast severity) {\n  min_log_level.store(static_cast<int>(severity), std::memory_order_release);\n}\n\nvoid RawSetStderrThreshold(absl::LogSeverityAtLeast severity) {\n  stderrthreshold.store(static_cast<int>(severity), std::memory_order_release);\n}\n\nvoid RawEnableLogPrefix(bool on_off) {\n  prepend_log_prefix.store(on_off, std::memory_order_release);\n}\n\nvoid SetLoggingGlobalsListener(LoggingGlobalsListener l) {\n  logging_globals_listener.Store(l);\n}\n\n}  // namespace log_internal\n\nabsl::LogSeverityAtLeast MinLogLevel() {\n  return static_cast<absl::LogSeverityAtLeast>(\n      min_log_level.load(std::memory_order_acquire));\n}\n\nvoid SetMinLogLevel(absl::LogSeverityAtLeast severity) {\n  log_internal::RawSetMinLogLevel(severity);\n  TriggerLoggingGlobalsListener();\n}\n\nnamespace log_internal {\n\nScopedMinLogLevel::ScopedMinLogLevel(absl::LogSeverityAtLeast severity)\n    : saved_severity_(absl::MinLogLevel()) {\n  absl::SetMinLogLevel(severity);\n}\nScopedMinLogLevel::~ScopedMinLogLevel() {\n  absl::SetMinLogLevel(saved_severity_);\n}\n\n}  // namespace log_internal\n\nabsl::LogSeverityAtLeast StderrThreshold() {\n  return static_cast<absl::LogSeverityAtLeast>(\n      stderrthreshold.load(std::memory_order_acquire));\n}\n\nvoid SetStderrThreshold(absl::LogSeverityAtLeast severity) {\n  log_internal::RawSetStderrThreshold(severity);\n  TriggerLoggingGlobalsListener();\n}\n\nScopedStderrThreshold::ScopedStderrThreshold(absl::LogSeverityAtLeast severity)\n    : saved_severity_(absl::StderrThreshold()) {\n  absl::SetStderrThreshold(severity);\n}\n\nScopedStderrThreshold::~ScopedStderrThreshold() {\n  absl::SetStderrThreshold(saved_severity_);\n}\n\nnamespace log_internal {\n\nconst char* GetAndroidNativeTag() {\n  return android_log_tag.load(std::memory_order_acquire);\n}\n\n}  // namespace log_internal\n\nvoid SetAndroidNativeTag(const char* tag) {\n  ABSL_CONST_INIT static std::atomic<const std::string*> user_log_tag(nullptr);\n  ABSL_INTERNAL_CHECK(tag, \"tag must be non-null.\");\n\n  const std::string* tag_str = new std::string(tag);\n  ABSL_INTERNAL_CHECK(\n      android_log_tag.exchange(tag_str->c_str(), std::memory_order_acq_rel) ==\n          kDefaultAndroidTag,\n      \"SetAndroidNativeTag() must only be called once per process!\");\n  user_log_tag.store(tag_str, std::memory_order_relaxed);\n}\n\nnamespace log_internal {\n\nbool ShouldLogBacktraceAt(absl::string_view file, int line) {\n  const size_t flag_hash =\n      log_backtrace_at_hash.load(std::memory_order_relaxed);\n\n  return flag_hash != 0 && flag_hash == HashSiteForLogBacktraceAt(file, line);\n}\n\n}  // namespace log_internal\n\nvoid SetLogBacktraceLocation(absl::string_view file, int line) {\n  log_backtrace_at_hash.store(HashSiteForLogBacktraceAt(file, line),\n                              std::memory_order_relaxed);\n}\n\nvoid ClearLogBacktraceLocation() {\n  log_backtrace_at_hash.store(0, std::memory_order_relaxed);\n}\n\nbool ShouldPrependLogPrefix() {\n  return prepend_log_prefix.load(std::memory_order_acquire);\n}\n\nvoid EnableLogPrefix(bool on_off) {\n  log_internal::RawEnableLogPrefix(on_off);\n  TriggerLoggingGlobalsListener();\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01778",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/globals.cc",
  "source_line": 32,
  "validation_status": "validated"
}