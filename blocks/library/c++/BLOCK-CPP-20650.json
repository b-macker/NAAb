{
  "code": "{\n  typedef SmallVector<TypoCorrection, 1> TypoResultList;\n  typedef llvm::StringMap<TypoResultList> TypoResultsMap;\n  typedef std::map<unsigned, TypoResultsMap> TypoEditDistanceMap;\n\npublic:\n  TypoCorrectionConsumer(Sema &SemaRef,\n                         const DeclarationNameInfo &TypoName,\n                         Sema::LookupNameKind LookupKind,\n                         Scope *S, CXXScopeSpec *SS,\n                         std::unique_ptr<CorrectionCandidateCallback> CCC,\n                         DeclContext *MemberContext,\n                         bool EnteringContext)\n      : Typo(TypoName.getName().getAsIdentifierInfo()), CurrentTCIndex(0),\n        SavedTCIndex(0), SemaRef(SemaRef), S(S),\n        SS(SS ? std::make_unique<CXXScopeSpec>(*SS) : nullptr),\n        CorrectionValidator(std::move(CCC)), MemberContext(MemberContext),\n        Result(SemaRef, TypoName, LookupKind),\n        Namespaces(SemaRef.Context, SemaRef.CurContext, SS),\n        EnteringContext(EnteringContext), SearchNamespaces(false) {\n    Result.suppressDiagnostics();\n    // Arrange for ValidatedCorrections[0] to always be an empty correction.\n    ValidatedCorrections.push_back(TypoCorrection());\n  }\n\n  bool includeHiddenDecls() const override { return true; }\n\n  // Methods for adding potential corrections to the consumer.\n  void FoundDecl(NamedDecl *ND, NamedDecl *Hiding, DeclContext *Ctx,\n                 bool InBaseClass) override;\n  void FoundName(StringRef Name);\n  void addKeywordResult(StringRef Keyword);\n  void addCorrection(TypoCorrection Correction);\n\n  bool empty() const {\n    return CorrectionResults.empty() && ValidatedCorrections.size() == 1;\n  }\n\n  /// Return the list of TypoCorrections for the given identifier from\n  /// the set of corrections that have the closest edit distance, if any.\n  TypoResultList &operator[](StringRef Name) {\n    return CorrectionResults.begin()->second[Name];\n  }\n\n  /// Return the edit distance of the corrections that have the\n  /// closest/best edit distance from the original typop.\n  unsigned getBestEditDistance(bool Normalized) {\n    if (CorrectionResults.empty())\n      return (std::numeric_limits<unsigned>::max)();\n\n    unsigned BestED = CorrectionResults.begin()->first;\n    return Normalized ? TypoCorrection::NormalizeEditDistance(BestED) : BestED;\n  }\n\n  /// Set-up method to add to the consumer the set of namespaces to use\n  /// in performing corrections to nested name specifiers. This method also\n  /// implicitly adds all of the known classes in the current AST context to the\n  /// to the consumer for correcting nested name specifiers.\n  void\n  addNamespaces(const llvm::MapVector<NamespaceDecl *, bool> &KnownNamespaces);\n\n  /// Return the next typo correction that passes all internal filters\n  /// and is deemed valid by the consumer's CorrectionCandidateCallback,\n  /// starting with the corrections that have the closest edit distance. An\n  /// empty TypoCorrection is returned once no more viable corrections remain\n  /// in the consumer.\n  const TypoCorrection &getNextCorrection();\n\n  /// Get the last correction returned by getNextCorrection().\n  const TypoCorrection &getCurrentCorrection() {\n    return CurrentTCIndex < ValidatedCorrections.size()\n               ? ValidatedCorrections[CurrentTCIndex]\n               : ValidatedCorrections[0];  // The empty correction.\n  }\n\n  /// Return the next typo correction like getNextCorrection, but keep\n  /// the internal state pointed to the current correction (i.e. the next time\n  /// getNextCorrection is called, it will return the same correction returned\n  /// by peekNextcorrection).\n  const TypoCorrection &peekNextCorrection() {\n    auto Current = CurrentTCIndex;\n    const TypoCorrection &TC = getNextCorrection();\n    CurrentTCIndex = Current;\n    return TC;\n  }\n\n  /// In the case of deeply invalid expressions, `getNextCorrection()` will\n  /// never be called since the transform never makes progress. If we don't\n  /// detect this we risk trying to correct typos forever.\n  bool hasMadeAnyCorrectionProgress() const { return CurrentTCIndex != 0; }\n\n  /// Reset the consumer's position in the stream of viable corrections\n  /// (i.e. getNextCorrection() will return each of the previously returned\n  /// corrections in order before returning any new corrections).\n  void resetCorrectionStream() {\n    CurrentTCIndex = 0;\n  }\n\n  /// Return whether the end of the stream of corrections has been\n  /// reached.\n  bool finished() {\n    return CorrectionResults.empty() &&\n           CurrentTCIndex >= ValidatedCorrections.size();\n  }\n\n  /// Save the current position in the correction stream (overwriting any\n  /// previously saved position).\n  void saveCurrentPosition() {\n    SavedTCIndex = CurrentTCIndex;\n  }\n\n  /// Restore the saved position in the correction stream.\n  void restoreSavedPosition() {\n    CurrentTCIndex = SavedTCIndex;\n  }\n\n  ASTContext &getContext() const { return SemaRef.Context; }\n  const LookupResult &getLookupResult() const { return Result; }\n\n  bool isAddressOfOperand() const { return CorrectionValidator->IsAddressOfOperand; }\n  const CXXScopeSpec *getSS() const { return SS.get(); }\n  Scope *getScope() const { return S; }\n  CorrectionCandidateCallback *getCorrectionValidator() const {\n    return CorrectionValidator.get();\n  }\n\nprivate:\n  class NamespaceSpecifierSet {\n    struct SpecifierInfo {\n      DeclContext* DeclCtx;\n      NestedNameSpecifier* NameSpecifier;\n      unsigned EditDistance;\n    };\n\n    typedef SmallVector<DeclContext*, 4> DeclContextList;\n    typedef SmallVector<SpecifierInfo, 16> SpecifierInfoList;\n\n    ASTContext &Context;\n    DeclContextList CurContextChain;\n    std::string CurNameSpecifier;\n    SmallVector<const IdentifierInfo*, 4> CurContextIdentifiers;\n    SmallVector<const IdentifierInfo*, 4> CurNameSpecifierIdentifiers;\n\n    std::map<unsigned, SpecifierInfoList> DistanceMap;\n\n    /// Helper for building the list of DeclContexts between the current\n    /// context and the top of the translation unit\n    static DeclContextList buildContextChain(DeclContext *Start);\n\n    unsigned buildNestedNameSpecifier(DeclContextList &DeclChain,\n                                      NestedNameSpecifier *&NNS);\n\n   public:\n    NamespaceSpecifierSet(ASTContext &Context, DeclContext *CurContext,\n                          CXXScopeSpec *CurScopeSpec);\n\n    /// Add the DeclContext (a namespace or record) to the set, computing\n    /// the corresponding NestedNameSpecifier and its distance in the process.\n    void addNameSpecifier(DeclContext *Ctx);\n\n    /// Provides flat iteration over specifiers, sorted by distance.\n    class iterator\n        : public llvm::iterator_facade_base<iterator, std::forward_iterator_tag,\n                                            SpecifierInfo> {\n      /// Always points to the last element in the distance map.\n      const std::map<unsigned, SpecifierInfoList>::iterator OuterBack;\n      /// Iterator on the distance map.\n      std::map<unsigned, SpecifierInfoList>::iterator Outer;\n      /// Iterator on an element in the distance map.\n      SpecifierInfoList::iterator Inner;\n\n    public:\n      iterator(NamespaceSpecifierSet &Set, bool IsAtEnd)\n          : OuterBack(std::prev(Set.DistanceMap.end())),\n            Outer(Set.DistanceMap.begin()),\n            Inner(!IsAtEnd ? Outer->second.begin() : OuterBack->second.end()) {\n        assert(!Set.DistanceMap.empty());\n      }\n\n      iterator &operator++() {\n        ++Inner;\n        if (Inner == Outer->second.end() && Outer != OuterBack) {\n          ++Outer;\n          Inner = Outer->second.begin();\n        }\n        return *this;\n      }\n\n      SpecifierInfo &operator*() { return *Inner; }\n      bool operator==(const iterator &RHS) const { return Inner == RHS.Inner; }\n    };\n\n    iterator begin() { return iterator(*this, /*IsAtEnd=*/false); }\n    iterator end() { return iterator(*this, /*IsAtEnd=*/true); }\n  };\n\n  void addName(StringRef Name, NamedDecl *ND,\n               NestedNameSpecifier *NNS = nullptr, bool isKeyword = false);\n\n  /// Find any visible decls for the given typo correction candidate.\n  /// If none are found, it to the set of candidates for which qualified lookups\n  /// will be performed to find possible nested name specifier changes.\n  bool resolveCorrection(TypoCorrection &Candidate);\n\n  /// Perform qualified lookups on the queued set of typo correction\n  /// candidates and add the nested name specifier changes to each candidate if\n  /// a lookup succeeds (at which point the candidate will be returned to the\n  /// main pool of potential corrections).\n  void performQualifiedLookups();\n\n  /// The name written that is a typo in the source.\n  IdentifierInfo *Typo;\n\n  /// The results found that have the smallest edit distance\n  /// found (so far) with the typo name.\n  ///\n  /// The pointer value being set to the current DeclContext indicates\n  /// whether there is a keyword with this name.\n  TypoEditDistanceMap CorrectionResults;\n\n  SmallVector<TypoCorrection, 4> ValidatedCorrections;\n  size_t CurrentTCIndex;\n  size_t SavedTCIndex;\n\n  Sema &SemaRef;\n  Scope *S;\n  std::unique_ptr<CXXScopeSpec> SS;\n  std::unique_ptr<CorrectionCandidateCallback> CorrectionValidator;\n  DeclContext *MemberContext;\n  LookupResult Result;\n  NamespaceSpecifierSet Namespaces;\n  SmallVector<TypoCorrection, 2> QualifiedResults;\n  bool EnteringContext;\n  bool SearchNamespaces;\n}",
  "id": "BLOCK-CPP-20650",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/SemaInternal.h",
  "source_line": 85,
  "validation_status": "validated"
}