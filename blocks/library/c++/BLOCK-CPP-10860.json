{
  "code": "{\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_SubstitutionFailure,\n      SS_Satisfied\n  };\nprivate:\n  llvm::PointerUnion<SubstitutionDiagnostic *, TypeSourceInfo *> Value;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a type requirement from a type. If the given type is not\n  /// dependent, this indicates that the type exists and the requirement will be\n  /// satisfied. Otherwise, the SubstitutionDiagnostic constructor is to be\n  /// used.\n  TypeRequirement(TypeSourceInfo *T);\n\n  /// \\brief Construct a type requirement when the nested name specifier is\n  /// invalid due to a bad substitution. The requirement is unsatisfied.\n  TypeRequirement(SubstitutionDiagnostic *Diagnostic) :\n      Requirement(RK_Type, false, false, false), Value(Diagnostic),\n      Status(SS_SubstitutionFailure) {}\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n  void setSatisfactionStatus(SatisfactionStatus Status) {\n    this->Status = Status;\n  }\n\n  bool isSubstitutionFailure() const {\n    return Status == SS_SubstitutionFailure;\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(Status == SS_SubstitutionFailure &&\n           \"Attempted to get substitution diagnostic when there has been no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  TypeSourceInfo *getType() const {\n    assert(!isSubstitutionFailure() &&\n           \"Attempted to get type when there has been a substitution failure.\");\n    return Value.get<TypeSourceInfo *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Type;\n  }\n}",
  "id": "BLOCK-CPP-10860",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprConcepts.h",
  "source_line": 203,
  "validation_status": "validated"
}