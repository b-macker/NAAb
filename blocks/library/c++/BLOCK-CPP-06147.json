{
  "code": "{\n public:\n  using ReadResult = CordRepBtreeNavigator::ReadResult;\n  using Position = CordRepBtreeNavigator::Position;\n\n  // Returns true if this instance is not empty.\n  explicit operator bool() const { return navigator_.btree() != nullptr; }\n\n  // Returns the tree referenced by this instance or nullptr if empty.\n  CordRepBtree* btree() const { return navigator_.btree(); }\n\n  // Returns the current data edge inside the referenced btree.\n  // Requires that the current instance is not empty.\n  CordRep* node() const { return navigator_.Current(); }\n\n  // Returns the length of the referenced tree.\n  // Requires that the current instance is not empty.\n  size_t length() const;\n\n  // Returns the number of remaining bytes available for iteration, which is the\n  // number of bytes directly following the end of the last chunk returned.\n  // This value will be zero if we iterated over the last edge in the bound\n  // tree, in which case any call to Next() or Skip() will return an empty\n  // string_view reflecting the EOF state.\n  // Note that a call to `Seek()` resets `remaining` to a value based on the\n  // end position of the chunk returned by that call.\n  size_t remaining() const { return remaining_; }\n\n  // Resets this instance to an empty value.\n  void Reset() { navigator_.Reset(); }\n\n  // Initializes this instance with `tree`. `tree` must not be null.\n  // Returns a reference to the first data edge of the provided tree.\n  absl::string_view Init(CordRepBtree* tree);\n\n  // Navigates to and returns the next data edge of the referenced tree.\n  // Returns an empty string_view if an attempt is made to read beyond the end\n  // of the tree, i.e.: if `remaining()` is zero indicating an EOF condition.\n  // Requires that the current instance is not empty.\n  absl::string_view Next();\n\n  // Skips the provided amount of bytes and returns a reference to the data\n  // directly following the skipped bytes.\n  absl::string_view Skip(size_t skip);\n\n  // Reads `n` bytes into `tree`.\n  // If `chunk_size` is zero, starts reading at the next data edge. If\n  // `chunk_size` is non zero, the read starts at the last `chunk_size` bytes of\n  // the last returned data edge. Effectively, this means that the read starts\n  // at offset `consumed() - chunk_size`.\n  // Requires that `chunk_size` is less than or equal to the length of the\n  // last returned data edge. The purpose of `chunk_size` is to simplify code\n  // partially consuming a returned chunk and wanting to include the remaining\n  // bytes in the Read call. For example, the below code will read 1000 bytes of\n  // data into a cord tree if the first chunk starts with \"big:\":\n  //\n  //   CordRepBtreeReader reader;\n  //   absl::string_view sv = reader.Init(tree);\n  //   if (absl::StartsWith(sv, \"big:\")) {\n  //     CordRepBtree tree;\n  //     sv = reader.Read(1000, sv.size() - 4 /* \"big:\" */, &tree);\n  //   }\n  //\n  // This method will return an empty string view if all remaining data was\n  // read. If `n` exceeded the amount of remaining data this function will\n  // return an empty string view and `tree` will be set to nullptr.\n  // In both cases, `consumed` will be set to `length`.\n  absl::string_view Read(size_t n, size_t chunk_size, CordRep*& tree);\n\n  // Navigates to the chunk at offset `offset`.\n  // Returns a reference into the navigated to chunk, adjusted for the relative\n  // position of `offset` into that chunk. For example, calling `Seek(13)` on a\n  // cord tree containing 2 chunks of 10 and 20 bytes respectively will return\n  // a string view into the second chunk starting at offset 3 with a size of 17.\n  // Returns an empty string view if `offset` is equal to or greater than the\n  // length of the referenced tree.\n  absl::string_view Seek(size_t offset);\n\n private:\n  size_t remaining_ = 0;\n  CordRepBtreeNavigator navigator_;\n}",
  "id": "BLOCK-CPP-06147",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree_reader.h",
  "source_line": 79,
  "validation_status": "validated"
}