{
  "code": "#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nusing namespace clang;\nusing namespace clang;\nusing namespace llvm;\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-07527_execute() {\n    {\n\n//----------------------------------------------------------------------------//\n// Canonical proxy adaptors for canonical type nodes.\n//----------------------------------------------------------------------------//\n\n/// Iterator adaptor that turns an iterator over canonical QualTypes\n/// into an iterator over CanQualTypes.\ntemplate <typename InputIterator>\nstruct CanTypeIterator\n    : llvm::iterator_adaptor_base<\n          CanTypeIterator<InputIterator>, InputIterator,\n          typename std::iterator_traits<InputIterator>::iterator_category,\n          CanQualType,\n          typename std::iterator_traits<InputIterator>::difference_type,\n          CanProxy<Type>, CanQualType> {\n  CanTypeIterator() = default;\n  explicit CanTypeIterator(InputIterator Iter)\n      : CanTypeIterator::iterator_adaptor_base(std::move(Iter)) {}\n\n  CanQualType operator*() const { return CanQualType::CreateUnsafe(*this->I); }\n  CanProxy<Type> operator->() const;\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ComplexType> : public CanProxyBase<ComplexType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<PointerType> : public CanProxyBase<PointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<BlockPointerType>\n  : public CanProxyBase<BlockPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ReferenceType> : public CanProxyBase<ReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<LValueReferenceType>\n  : public CanProxyBase<LValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RValueReferenceType>\n  : public CanProxyBase<RValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<MemberPointerType>\n  : public CanProxyBase<MemberPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Type *, getClass)\n};\n\n// CanProxyAdaptors for arrays are intentionally unimplemented because\n// they are not safe.\ntemplate<> struct CanProxyAdaptor<ArrayType>;\ntemplate<> struct CanProxyAdaptor<ConstantArrayType>;\ntemplate<> struct CanProxyAdaptor<IncompleteArrayType>;\ntemplate<> struct CanProxyAdaptor<VariableArrayType>;\ntemplate<> struct CanProxyAdaptor<DependentSizedArrayType>;\n\ntemplate<>\nstruct CanProxyAdaptor<DependentSizedExtVectorType>\n  : public CanProxyBase<DependentSizedExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Expr *, getSizeExpr)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(SourceLocation, getAttributeLoc)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<VectorType> : public CanProxyBase<VectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ExtVectorType> : public CanProxyBase<ExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionType> : public CanProxyBase<FunctionType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionNoProtoType>\n  : public CanProxyBase<FunctionNoProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionProtoType>\n  : public CanProxyBase<FunctionProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumParams)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasExtParameterInfos)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(\n            ArrayRef<FunctionProtoType::ExtParameterInfo>, getExtParameterInfos)\n\n  CanQualType getParamType(unsigned i) const {\n    return CanQualType::CreateUnsafe(this->getTypePtr()->getParamType(i));\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariadic)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Qualifiers, getMethodQuals)\n\n  using param_type_iterator =\n      CanTypeIterator<FunctionProtoType::param_type_iterator>;\n\n  param_type_iterator param_type_begin() const {\n    return param_type_iterator(this->getTypePtr()->param_type_begin());\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_iterator(this->getTypePtr()->param_type_end());\n  }\n\n  // Note: canonical function types never have exception specifications\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TypeOfType> : public CanProxyBase<TypeOfType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnmodifiedType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<DecltypeType> : public CanProxyBase<DecltypeType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Expr *, getUnderlyingExpr)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n};\n\ntemplate <>\nstruct CanProxyAdaptor<UnaryTransformType>\n    : public CanProxyBase<UnaryTransformType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(UnaryTransformType::UTTKind, getUTTKind)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TagType> : public CanProxyBase<TagType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TagDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RecordType> : public CanProxyBase<RecordType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(RecordDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasConstFields)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<EnumType> : public CanProxyBase<EnumType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(EnumDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TemplateTypeParmType>\n  : public CanProxyBase<TemplateTypeParmType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getDepth)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getIndex)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isParameterPack)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TemplateTypeParmDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(IdentifierInfo *, getIdentifier)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectType>\n  : public CanProxyBase<ObjCObjectType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceDecl *,\n                                      getInterface)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedClass)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClass)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectPointerType>\n  : public CanProxyBase<ObjCObjectPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceType *,\n                                      getInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClassType)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\n//----------------------------------------------------------------------------//\n// Method and function definitions\n//----------------------------------------------------------------------------//\ntemplate<typename T>\ninline CanQual<T> CanQual<T>::getUnqualifiedType() const {\n  return CanQual<T>::CreateUnsafe(Stored.getLocalUnqualifiedType());\n}\n\ntemplate<typename T>\ninline CanQual<Type> CanQual<T>::getNonReferenceType() const {\n  if (CanQual<ReferenceType> RefType = getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::getFromOpaquePtr(void *Ptr) {\n  CanQual<T> Result;\n  Result.Stored = QualType::getFromOpaquePtr(Ptr);\n  assert((!Result || Result.Stored.getAsOpaquePtr() == (void*)-1 ||\n          Result.Stored.isCanonical()) && \"Type is not canonical!\");\n  return Result;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::CreateUnsafe(QualType Other) {\n  assert((Other.isNull() || Other.isCanonical()) && \"Type is not canonical!\");\n  assert((Other.isNull() || isa<T>(Other.getTypePtr())) &&\n         \"Dynamic type does not meet the static type's requires\");\n  CanQual<T> Result;\n  Result.Stored = Other;\n  return Result;\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  if (Stored.isNull())\n    return CanProxy<U>();\n\n  if (isa<U>(Stored.getTypePtr()))\n    return CanQual<U>::CreateUnsafe(Stored);\n\n  return CanProxy<U>();\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::castAs() const {\n  static_assert(!TypeIsArrayType<U>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  assert(!Stored.isNull() && isa<U>(Stored.getTypePtr()));\n  return CanQual<U>::CreateUnsafe(Stored);\n}\n\ntemplate<typename T>\nCanProxy<T> CanQual<T>::operator->() const {\n  return CanProxy<T>(*this);\n}\n\ntemplate <typename InputIterator>\nCanProxy<Type> CanTypeIterator<InputIterator>::operator->() const {\n  return CanProxy<Type>(*this);\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-07527",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CanonicalType.h",
  "source_line": 393,
  "validation_status": "validated"
}