{
  "code": "#include \"absl/synchronization/internal/win32_waiter.h\"\n#include <windows.h>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/synchronization/internal/kernel_timeout.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03193_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\nconstexpr char Win32Waiter::kName[];\n#endif\n\nclass Win32Waiter::WinHelper {\n public:\n  static SRWLOCK *GetLock(Win32Waiter *w) {\n    return reinterpret_cast<SRWLOCK *>(&w->mu_storage_);\n  }\n\n  static CONDITION_VARIABLE *GetCond(Win32Waiter *w) {\n    return reinterpret_cast<CONDITION_VARIABLE *>(&w->cv_storage_);\n  }\n\n  static_assert(sizeof(SRWLOCK) == sizeof(void *),\n                \"`mu_storage_` does not have the same size as SRWLOCK\");\n  static_assert(alignof(SRWLOCK) == alignof(void *),\n                \"`mu_storage_` does not have the same alignment as SRWLOCK\");\n\n  static_assert(sizeof(CONDITION_VARIABLE) == sizeof(void *),\n                \"`ABSL_CONDITION_VARIABLE_STORAGE` does not have the same size \"\n                \"as `CONDITION_VARIABLE`\");\n  static_assert(\n      alignof(CONDITION_VARIABLE) == alignof(void *),\n      \"`cv_storage_` does not have the same alignment as `CONDITION_VARIABLE`\");\n\n  // The SRWLOCK and CONDITION_VARIABLE types must be trivially constructible\n  // and destructible because we never call their constructors or destructors.\n  static_assert(std::is_trivially_constructible<SRWLOCK>::value,\n                \"The `SRWLOCK` type must be trivially constructible\");\n  static_assert(\n      std::is_trivially_constructible<CONDITION_VARIABLE>::value,\n      \"The `CONDITION_VARIABLE` type must be trivially constructible\");\n  static_assert(std::is_trivially_destructible<SRWLOCK>::value,\n                \"The `SRWLOCK` type must be trivially destructible\");\n  static_assert(std::is_trivially_destructible<CONDITION_VARIABLE>::value,\n                \"The `CONDITION_VARIABLE` type must be trivially destructible\");\n};\n\nclass LockHolder {\n public:\n  explicit LockHolder(SRWLOCK* mu) : mu_(mu) {\n    AcquireSRWLockExclusive(mu_);\n  }\n\n  LockHolder(const LockHolder&) = delete;\n  LockHolder& operator=(const LockHolder&) = delete;\n\n  ~LockHolder() {\n    ReleaseSRWLockExclusive(mu_);\n  }\n\n private:\n  SRWLOCK* mu_;\n};\n\nWin32Waiter::Win32Waiter() {\n  auto *mu = ::new (static_cast<void *>(&mu_storage_)) SRWLOCK;\n  auto *cv = ::new (static_cast<void *>(&cv_storage_)) CONDITION_VARIABLE;\n  InitializeSRWLock(mu);\n  InitializeConditionVariable(cv);\n  waiter_count_ = 0;\n  wakeup_count_ = 0;\n}\n\nbool Win32Waiter::Wait(KernelTimeout t) {\n  SRWLOCK *mu = WinHelper::GetLock(this);\n  CONDITION_VARIABLE *cv = WinHelper::GetCond(this);\n\n  LockHolder h(mu);\n  ++waiter_count_;\n\n  // Loop until we find a wakeup to consume or timeout.\n  // Note that, since the thread ticker is just reset, we don't need to check\n  // whether the thread is idle on the very first pass of the loop.\n  bool first_pass = true;\n  while (wakeup_count_ == 0) {\n    if (!first_pass) MaybeBecomeIdle();\n    // No wakeups available, time to wait.\n    if (!SleepConditionVariableSRW(cv, mu, t.InMillisecondsFromNow(), 0)) {\n      // GetLastError() returns a Win32 DWORD, but we assign to\n      // unsigned long to simplify the ABSL_RAW_LOG case below.  The uniform\n      // initialization guarantees this is not a narrowing conversion.\n      const unsigned long err{GetLastError()};  // NOLINT(runtime/int)\n      if (err == ERROR_TIMEOUT) {\n        --waiter_count_;\n        return false;\n      } else {\n        ABSL_RAW_LOG(FATAL, \"SleepConditionVariableSRW failed: %lu\", err);\n      }\n    }\n    first_pass = false;\n  }\n  // Consume a wakeup and we're done.\n  --wakeup_count_;\n  --waiter_count_;\n  return true;\n}\n\nvoid Win32Waiter::Post() {\n  LockHolder h(WinHelper::GetLock(this));\n  ++wakeup_count_;\n  InternalCondVarPoke();\n}\n\nvoid Win32Waiter::Poke() {\n  LockHolder h(WinHelper::GetLock(this));\n  InternalCondVarPoke();\n}\n\nvoid Win32Waiter::InternalCondVarPoke() {\n  if (waiter_count_ != 0) {\n    WakeConditionVariable(WinHelper::GetCond(this));\n  }\n}\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03193",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/win32_waiter.cc",
  "source_line": 27,
  "validation_status": "validated"
}