{
  "code": "{\n   public:\n    static constexpr unsigned char kMaxInline = cord_internal::kMaxInline;\n    static_assert(kMaxInline >= sizeof(absl::cord_internal::CordRep*), \"\");\n\n    constexpr InlineRep() : data_() {}\n    explicit InlineRep(InlineData::DefaultInitType init) : data_(init) {}\n    InlineRep(const InlineRep& src);\n    InlineRep(InlineRep&& src);\n    InlineRep& operator=(const InlineRep& src);\n    InlineRep& operator=(InlineRep&& src) noexcept;\n\n    explicit constexpr InlineRep(absl::string_view sv,\n                                 absl::Nullable<CordRep*> rep);\n\n    void Swap(absl::Nonnull<InlineRep*> rhs);\n    size_t size() const;\n    // Returns nullptr if holding pointer\n    absl::Nullable<const char*> data() const;\n    // Discards pointer, if any\n    void set_data(absl::Nonnull<const char*> data, size_t n);\n    absl::Nonnull<char*> set_data(size_t n);  // Write data to the result\n    // Returns nullptr if holding bytes\n    absl::Nullable<absl::cord_internal::CordRep*> tree() const;\n    absl::Nonnull<absl::cord_internal::CordRep*> as_tree() const;\n    absl::Nonnull<const char*> as_chars() const;\n    // Returns non-null iff was holding a pointer\n    absl::Nullable<absl::cord_internal::CordRep*> clear();\n    // Converts to pointer if necessary.\n    void reduce_size(size_t n);    // REQUIRES: holding data\n    void remove_prefix(size_t n);  // REQUIRES: holding data\n    void AppendArray(absl::string_view src, MethodIdentifier method);\n    absl::string_view FindFlatStartPiece() const;\n\n    // Creates a CordRepFlat instance from the current inlined data with `extra'\n    // bytes of desired additional capacity.\n    absl::Nonnull<CordRepFlat*> MakeFlatWithExtraCapacity(size_t extra);\n\n    // Sets the tree value for this instance. `rep` must not be null.\n    // Requires the current instance to hold a tree, and a lock to be held on\n    // any CordzInfo referenced by this instance. The latter is enforced through\n    // the CordzUpdateScope argument. If the current instance is sampled, then\n    // the CordzInfo instance is updated to reference the new `rep` value.\n    void SetTree(absl::Nonnull<CordRep*> rep, const CordzUpdateScope& scope);\n\n    // Identical to SetTree(), except that `rep` is allowed to be null, in\n    // which case the current instance is reset to an empty value.\n    void SetTreeOrEmpty(absl::Nullable<CordRep*> rep,\n                        const CordzUpdateScope& scope);\n\n    // Sets the tree value for this instance, and randomly samples this cord.\n    // This function disregards existing contents in `data_`, and should be\n    // called when a Cord is 'promoted' from an 'uninitialized' or 'inlined'\n    // value to a non-inlined (tree / ring) value.\n    void EmplaceTree(absl::Nonnull<CordRep*> rep, MethodIdentifier method);\n\n    // Identical to EmplaceTree, except that it copies the parent stack from\n    // the provided `parent` data if the parent is sampled.\n    void EmplaceTree(absl::Nonnull<CordRep*> rep, const InlineData& parent,\n                     MethodIdentifier method);\n\n    // Commits the change of a newly created, or updated `rep` root value into\n    // this cord. `old_rep` indicates the old (inlined or tree) value of the\n    // cord, and determines if the commit invokes SetTree() or EmplaceTree().\n    void CommitTree(absl::Nullable<const CordRep*> old_rep,\n                    absl::Nonnull<CordRep*> rep, const CordzUpdateScope& scope,\n                    MethodIdentifier method);\n\n    void AppendTreeToInlined(absl::Nonnull<CordRep*> tree,\n                             MethodIdentifier method);\n    void AppendTreeToTree(absl::Nonnull<CordRep*> tree,\n                          MethodIdentifier method);\n    void AppendTree(absl::Nonnull<CordRep*> tree, MethodIdentifier method);\n    void PrependTreeToInlined(absl::Nonnull<CordRep*> tree,\n                              MethodIdentifier method);\n    void PrependTreeToTree(absl::Nonnull<CordRep*> tree,\n                           MethodIdentifier method);\n    void PrependTree(absl::Nonnull<CordRep*> tree, MethodIdentifier method);\n\n    bool IsSame(const InlineRep& other) const { return data_ == other.data_; }\n\n    void CopyTo(absl::Nonnull<std::string*> dst) const {\n      // memcpy is much faster when operating on a known size. On most supported\n      // platforms, the small string optimization is large enough that resizing\n      // to 15 bytes does not cause a memory allocation.\n      absl::strings_internal::STLStringResizeUninitialized(dst, kMaxInline);\n      data_.copy_max_inline_to(&(*dst)[0]);\n      // erase is faster than resize because the logic for memory allocation is\n      // not needed.\n      dst->erase(inline_size());\n    }\n\n    // Copies the inline contents into `dst`. Assumes the cord is not empty.\n    void CopyToArray(absl::Nonnull<char*> dst) const;\n\n    bool is_tree() const { return data_.is_tree(); }\n\n    // Returns true if the Cord is being profiled by cordz.\n    bool is_profiled() const { return data_.is_tree() && data_.is_profiled(); }\n\n    // Returns the available inlined capacity, or 0 if is_tree() == true.\n    size_t remaining_inline_capacity() const {\n      return data_.is_tree() ? 0 : kMaxInline - data_.inline_size();\n    }\n\n    // Returns the profiled CordzInfo, or nullptr if not sampled.\n    absl::Nullable<absl::cord_internal::CordzInfo*> cordz_info() const {\n      return data_.cordz_info();\n    }\n\n    // Sets the profiled CordzInfo.\n    void set_cordz_info(absl::Nonnull<cord_internal::CordzInfo*> cordz_info) {\n      assert(cordz_info != nullptr);\n      data_.set_cordz_info(cordz_info);\n    }\n\n    // Resets the current cordz_info to null / empty.\n    void clear_cordz_info() { data_.clear_cordz_info(); }\n\n   private:\n    friend class Cord;\n\n    void AssignSlow(const InlineRep& src);\n    // Unrefs the tree and stops profiling.\n    void UnrefTree();\n\n    void ResetToEmpty() { data_ = {}; }\n\n    void set_inline_size(size_t size) { data_.set_inline_size(size); }\n    size_t inline_size() const { return data_.inline_size(); }\n\n    // Empty cords that carry a checksum have a CordRepCrc node with a null\n    // child node. The code can avoid lots of special cases where it would\n    // otherwise transition from tree to inline storage if we just remove the\n    // CordRepCrc node before mutations. Must never be called inside a\n    // CordzUpdateScope since it untracks the cordz info.\n    void MaybeRemoveEmptyCrcNode();\n\n    cord_internal::InlineData data_;\n  }",
  "id": "BLOCK-CPP-04048",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord.h",
  "source_line": 854,
  "validation_status": "validated"
}