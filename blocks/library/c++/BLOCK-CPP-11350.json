{
  "code": "#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LangOptions.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-11350_execute() {\n    {\npublic:\n  ODRDiagsEmitter(DiagnosticsEngine &Diags, const ASTContext &Context,\n                  const LangOptions &LangOpts)\n      : Diags(Diags), Context(Context), LangOpts(LangOpts) {}\n\n  /// Diagnose ODR mismatch between 2 FunctionDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseMismatch(const FunctionDecl *FirstFunction,\n                        const FunctionDecl *SecondFunction) const;\n\n  /// Diagnose ODR mismatch between 2 EnumDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseMismatch(const EnumDecl *FirstEnum,\n                        const EnumDecl *SecondEnum) const;\n\n  /// Diagnose ODR mismatch between 2 CXXRecordDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  /// To compare 2 declarations with merged and identical definition data\n  /// you need to provide pre-merge definition data in \\p SecondDD.\n  bool\n  diagnoseMismatch(const CXXRecordDecl *FirstRecord,\n                   const CXXRecordDecl *SecondRecord,\n                   const struct CXXRecordDecl::DefinitionData *SecondDD) const;\n\n  /// Diagnose ODR mismatch between 2 RecordDecl that are not CXXRecordDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseMismatch(const RecordDecl *FirstRecord,\n                        const RecordDecl *SecondRecord) const;\n\n  /// Diagnose ODR mismatch between 2 ObjCInterfaceDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseMismatch(\n      const ObjCInterfaceDecl *FirstID, const ObjCInterfaceDecl *SecondID,\n      const struct ObjCInterfaceDecl::DefinitionData *SecondDD) const;\n\n  /// Diagnose ODR mismatch between ObjCInterfaceDecl with different\n  /// definitions.\n  bool diagnoseMismatch(const ObjCInterfaceDecl *FirstID,\n                        const ObjCInterfaceDecl *SecondID) const {\n    assert(FirstID->data().Definition != SecondID->data().Definition &&\n           \"Don't diagnose differences when definitions are merged already\");\n    return diagnoseMismatch(FirstID, SecondID, &SecondID->data());\n  }\n\n  /// Diagnose ODR mismatch between 2 ObjCProtocolDecl.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  /// To compare 2 declarations with merged and identical definition data\n  /// you need to provide pre-merge definition data in \\p SecondDD.\n  bool diagnoseMismatch(\n      const ObjCProtocolDecl *FirstProtocol,\n      const ObjCProtocolDecl *SecondProtocol,\n      const struct ObjCProtocolDecl::DefinitionData *SecondDD) const;\n\n  /// Diagnose ODR mismatch between ObjCProtocolDecl with different definitions.\n  bool diagnoseMismatch(const ObjCProtocolDecl *FirstProtocol,\n                        const ObjCProtocolDecl *SecondProtocol) const {\n    assert(FirstProtocol->data().Definition !=\n               SecondProtocol->data().Definition &&\n           \"Don't diagnose differences when definitions are merged already\");\n    return diagnoseMismatch(FirstProtocol, SecondProtocol,\n                            &SecondProtocol->data());\n  }\n\n  /// Get the best name we know for the module that owns the given\n  /// declaration, or an empty string if the declaration is not from a module.\n  static std::string getOwningModuleNameForDiagnostic(const Decl *D);\n\nprivate:\n  using DeclHashes = llvm::SmallVector<std::pair<const Decl *, unsigned>, 4>;\n\n  // Used with err_module_odr_violation_mismatch_decl,\n  // note_module_odr_violation_mismatch_decl,\n  // err_module_odr_violation_mismatch_decl_unknown,\n  // and note_module_odr_violation_mismatch_decl_unknown\n  // This list should be the same Decl's as in ODRHash::isSubDeclToBeProcessed\n  enum ODRMismatchDecl {\n    EndOfClass,\n    PublicSpecifer,\n    PrivateSpecifer,\n    ProtectedSpecifer,\n    StaticAssert,\n    Field,\n    CXXMethod,\n    TypeAlias,\n    TypeDef,\n    Var,\n    Friend,\n    FunctionTemplate,\n    ObjCMethod,\n    ObjCIvar,\n    ObjCProperty,\n    Other\n  };\n\n  struct DiffResult {\n    const Decl *FirstDecl = nullptr, *SecondDecl = nullptr;\n    ODRMismatchDecl FirstDiffType = Other, SecondDiffType = Other;\n  };\n\n  // If there is a diagnoseable difference, FirstDiffType and\n  // SecondDiffType will not be Other and FirstDecl and SecondDecl will be\n  // filled in if not EndOfClass.\n  static DiffResult FindTypeDiffs(DeclHashes &FirstHashes,\n                                  DeclHashes &SecondHashes);\n\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const {\n    return Diags.Report(Loc, DiagID);\n  }\n\n  // Use this to diagnose that an unexpected Decl was encountered\n  // or no difference was detected. This causes a generic error\n  // message to be emitted.\n  void diagnoseSubMismatchUnexpected(DiffResult &DR,\n                                     const NamedDecl *FirstRecord,\n                                     StringRef FirstModule,\n                                     const NamedDecl *SecondRecord,\n                                     StringRef SecondModule) const;\n\n  void diagnoseSubMismatchDifferentDeclKinds(DiffResult &DR,\n                                             const NamedDecl *FirstRecord,\n                                             StringRef FirstModule,\n                                             const NamedDecl *SecondRecord,\n                                             StringRef SecondModule) const;\n\n  bool diagnoseSubMismatchField(const NamedDecl *FirstRecord,\n                                StringRef FirstModule, StringRef SecondModule,\n                                const FieldDecl *FirstField,\n                                const FieldDecl *SecondField) const;\n\n  bool diagnoseSubMismatchTypedef(const NamedDecl *FirstRecord,\n                                  StringRef FirstModule, StringRef SecondModule,\n                                  const TypedefNameDecl *FirstTD,\n                                  const TypedefNameDecl *SecondTD,\n                                  bool IsTypeAlias) const;\n\n  bool diagnoseSubMismatchVar(const NamedDecl *FirstRecord,\n                              StringRef FirstModule, StringRef SecondModule,\n                              const VarDecl *FirstVD,\n                              const VarDecl *SecondVD) const;\n\n  /// Check if protocol lists are the same and diagnose if they are different.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseSubMismatchProtocols(const ObjCProtocolList &FirstProtocols,\n                                    const ObjCContainerDecl *FirstContainer,\n                                    StringRef FirstModule,\n                                    const ObjCProtocolList &SecondProtocols,\n                                    const ObjCContainerDecl *SecondContainer,\n                                    StringRef SecondModule) const;\n\n  /// Check if Objective-C methods are the same and diagnose if different.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool diagnoseSubMismatchObjCMethod(const NamedDecl *FirstObjCContainer,\n                                     StringRef FirstModule,\n                                     StringRef SecondModule,\n                                     const ObjCMethodDecl *FirstMethod,\n                                     const ObjCMethodDecl *SecondMethod) const;\n\n  /// Check if Objective-C properties are the same and diagnose if different.\n  ///\n  /// Returns true if found a mismatch and diagnosed it.\n  bool\n  diagnoseSubMismatchObjCProperty(const NamedDecl *FirstObjCContainer,\n                                  StringRef FirstModule, StringRef SecondModule,\n                                  const ObjCPropertyDecl *FirstProp,\n                                  const ObjCPropertyDecl *SecondProp) const;\n\nprivate:\n  DiagnosticsEngine &Diags;\n  const ASTContext &Context;\n  const LangOptions &LangOpts;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-11350",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ODRDiagsEmitter.h",
  "source_line": 20,
  "validation_status": "validated"
}