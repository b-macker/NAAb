{
  "code": "{\n  /// Implementation Class's super class.\n  ObjCInterfaceDecl *SuperClass;\n  SourceLocation SuperLoc;\n\n  /// \\@implementation may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  /// Support for ivar initialization.\n  /// The arguments used to initialize the ivars\n  LazyCXXCtorInitializersPtr IvarInitializers;\n  unsigned NumIvarInitializers = 0;\n\n  /// Do the ivars of this class require initialization other than\n  /// zero-initialization?\n  bool HasNonZeroConstructors : 1;\n\n  /// Do the ivars of this class require non-trivial destruction?\n  bool HasDestructors : 1;\n\n  ObjCImplementationDecl(DeclContext *DC,\n                         ObjCInterfaceDecl *classInterface,\n                         ObjCInterfaceDecl *superDecl,\n                         SourceLocation nameLoc, SourceLocation atStartLoc,\n                         SourceLocation superLoc = SourceLocation(),\n                         SourceLocation IvarLBraceLoc=SourceLocation(),\n                         SourceLocation IvarRBraceLoc=SourceLocation())\n      : ObjCImplDecl(ObjCImplementation, DC, classInterface,\n                     classInterface ? classInterface->getIdentifier()\n                                    : nullptr,\n                     nameLoc, atStartLoc),\n         SuperClass(superDecl), SuperLoc(superLoc),\n         IvarLBraceLoc(IvarLBraceLoc), IvarRBraceLoc(IvarRBraceLoc),\n         HasNonZeroConstructors(false), HasDestructors(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCImplementationDecl *Create(ASTContext &C, DeclContext *DC,\n                                        ObjCInterfaceDecl *classInterface,\n                                        ObjCInterfaceDecl *superDecl,\n                                        SourceLocation nameLoc,\n                                        SourceLocation atStartLoc,\n                                     SourceLocation superLoc = SourceLocation(),\n                                        SourceLocation IvarLBraceLoc=SourceLocation(),\n                                        SourceLocation IvarRBraceLoc=SourceLocation());\n\n  static ObjCImplementationDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// init_iterator - Iterates through the ivar initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// init_const_iterator - Iterates through the ivar initializer list.\n  using init_const_iterator = CXXCtorInitializer * const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// init_begin() - Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// begin() - Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// init_end() - Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// end() - Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// getNumArgs - Number of ivars which must be initialized.\n  unsigned getNumIvarInitializers() const {\n    return NumIvarInitializers;\n  }\n\n  void setNumIvarInitializers(unsigned numNumIvarInitializers) {\n    NumIvarInitializers = numNumIvarInitializers;\n  }\n\n  void setIvarInitializers(ASTContext &C,\n                           CXXCtorInitializer ** initializers,\n                           unsigned numInitializers);\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require construction other than zero-initialization?\n  bool hasNonZeroConstructors() const { return HasNonZeroConstructors; }\n  void setHasNonZeroConstructors(bool val) { HasNonZeroConstructors = val; }\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require non-trivial destruction?\n  bool hasDestructors() const { return HasDestructors; }\n  void setHasDestructors(bool val) { HasDestructors = val; }\n\n  /// getIdentifier - Get the identifier that names the class\n  /// interface associated with this implementation.\n  IdentifierInfo *getIdentifier() const {\n    return getClassInterface()->getIdentifier();\n  }\n\n  /// getName - Get the name of identifier for the class interface associated\n  /// with this implementation as a StringRef.\n  //\n  // FIXME: This is a bad API, we are hiding NamedDecl::getName with a different\n  // meaning.\n  StringRef getName() const {\n    assert(getIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier()->getName();\n  }\n\n  /// Get the name of the class associated with this interface.\n  //\n  // FIXME: Move to StringRef API.\n  std::string getNameAsString() const { return std::string(getName()); }\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// class's objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  const ObjCInterfaceDecl *getSuperClass() const { return SuperClass; }\n  ObjCInterfaceDecl *getSuperClass() { return SuperClass; }\n  SourceLocation getSuperClassLoc() const { return SuperLoc; }\n\n  void setSuperClass(ObjCInterfaceDecl * superCls) { SuperClass = superCls; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCImplementation; }\n}",
  "id": "BLOCK-CPP-09060",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclObjC.h",
  "source_line": 2584,
  "validation_status": "validated"
}