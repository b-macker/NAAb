{
  "code": "#include <algorithm>\n#include <cinttypes>\n#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <type_traits>\n#include \"absl/base/internal/endian.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/random/internal/iostream_state_saver.h\"\n#include \"absl/random/internal/randen.h\"\n\nusing namespace absl;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05944_execute() {\n    {\n    using sequence_result_type = typename SeedSequence::result_type;\n    static_assert(sizeof(sequence_result_type) == 4,\n                  \"SeedSequence::result_type must be 32-bit\");\n    constexpr size_t kBufferSize =\n        Randen::kSeedBytes / sizeof(sequence_result_type);\n    alignas(16) sequence_result_type buffer[kBufferSize];\n\n    // Randen::Absorb XORs the seed into state, which is then mixed by a call\n    // to Randen::Generate. Seeding with only the provided entropy is preferred\n    // to using an arbitrary generate() call, so use [rand.req.seed_seq]\n    // size as a proxy for the number of entropy units that can be generated\n    // without relying on seed sequence mixing...\n    const size_t entropy_size = seq.size();\n    if (entropy_size < kBufferSize) {\n      // ... and only request that many values, or 256-bits, when unspecified.\n      const size_t requested_entropy = (entropy_size == 0) ? 8u : entropy_size;\n      std::fill(buffer + requested_entropy, buffer + kBufferSize, 0);\n      seq.generate(buffer, buffer + requested_entropy);\n#ifdef ABSL_IS_BIG_ENDIAN\n      // Randen expects the seed buffer to be in Little Endian; reverse it on\n      // Big Endian platforms.\n      for (sequence_result_type& e : buffer) {\n        e = absl::little_endian::FromHost(e);\n      }\n#endif\n      // The Randen paper suggests preferentially initializing even-numbered\n      // 128-bit vectors of the randen state (there are 16 such vectors).\n      // The seed data is merged into the state offset by 128-bits, which\n      // implies preferring seed bytes [16..31, ..., 208..223]. Since the\n      // buffer is 32-bit values, we swap the corresponding buffer positions in\n      // 128-bit chunks.\n      size_t dst = kBufferSize;\n      while (dst > 7) {\n        // leave the odd bucket as-is.\n        dst -= 4;\n        size_t src = dst >> 1;\n        // swap 128-bits into the even bucket\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n      }\n    } else {\n      seq.generate(buffer, buffer + kBufferSize);\n    }\n    impl_.Absorb(buffer, state());\n\n    // Generate will be called when operator() is called\n    next_ = kStateSizeT;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05944",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/randen_engine.h",
  "source_line": 115,
  "validation_status": "validated"
}