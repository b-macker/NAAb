{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nABSL_DLL extern const char RFC3339_full[] = \"%Y-%m-%d%ET%H:%M:%E*S%Ez\";\nABSL_DLL extern const char RFC3339_sec[] = \"%Y-%m-%d%ET%H:%M:%S%Ez\";\n\nABSL_DLL extern const char RFC1123_full[] = \"%a, %d %b %E4Y %H:%M:%S %z\";\nABSL_DLL extern const char RFC1123_no_wday[] = \"%d %b %E4Y %H:%M:%S %z\";\n\nnamespace {\n\nconst char kInfiniteFutureStr[] = \"infinite-future\";\nconst char kInfinitePastStr[] = \"infinite-past\";\n\nstruct cctz_parts {\n  cctz::time_point<cctz::seconds> sec;\n  cctz::detail::femtoseconds fem;\n};\n\ninline cctz::time_point<cctz::seconds> unix_epoch() {\n  return std::chrono::time_point_cast<cctz::seconds>(\n      std::chrono::system_clock::from_time_t(0));\n}\n\n// Splits a Time into seconds and femtoseconds, which can be used with CCTZ.\n// Requires that 't' is finite. See duration.cc for details about rep_hi and\n// rep_lo.\ncctz_parts Split(absl::Time t) {\n  const auto d = time_internal::ToUnixDuration(t);\n  const int64_t rep_hi = time_internal::GetRepHi(d);\n  const int64_t rep_lo = time_internal::GetRepLo(d);\n  const auto sec = unix_epoch() + cctz::seconds(rep_hi);\n  const auto fem = cctz::detail::femtoseconds(rep_lo * (1000 * 1000 / 4));\n  return {sec, fem};\n}\n\n// Joins the given seconds and femtoseconds into a Time. See duration.cc for\n// details about rep_hi and rep_lo.\nabsl::Time Join(const cctz_parts& parts) {\n  const int64_t rep_hi = (parts.sec - unix_epoch()).count();\n  const uint32_t rep_lo =\n      static_cast<uint32_t>(parts.fem.count() / (1000 * 1000 / 4));\n  const auto d = time_internal::MakeDuration(rep_hi, rep_lo);\n  return time_internal::FromUnixDuration(d);\n}\n\n}  // namespace\n\nstd::string FormatTime(absl::string_view format, absl::Time t,\n                       absl::TimeZone tz) {\n  if (t == absl::InfiniteFuture()) return std::string(kInfiniteFutureStr);\n  if (t == absl::InfinitePast()) return std::string(kInfinitePastStr);\n  const auto parts = Split(t);\n  return cctz::detail::format(std::string(format), parts.sec, parts.fem,\n                              cctz::time_zone(tz));\n}\n\nstd::string FormatTime(absl::Time t, absl::TimeZone tz) {\n  return FormatTime(RFC3339_full, t, tz);\n}\n\nstd::string FormatTime(absl::Time t) {\n  return absl::FormatTime(RFC3339_full, t, absl::LocalTimeZone());\n}\n\nbool ParseTime(absl::string_view format, absl::string_view input,\n               absl::Time* time, std::string* err) {\n  return absl::ParseTime(format, input, absl::UTCTimeZone(), time, err);\n}\n\n// If the input string does not contain an explicit UTC offset, interpret\n// the fields with respect to the given TimeZone.\nbool ParseTime(absl::string_view format, absl::string_view input,\n               absl::TimeZone tz, absl::Time* time, std::string* err) {\n  auto strip_leading_space = [](absl::string_view* sv) {\n    while (!sv->empty()) {\n      if (!std::isspace(sv->front())) return;\n      sv->remove_prefix(1);\n    }\n  };\n\n  // Portable toolchains means we don't get nice constexpr here.\n  struct Literal {\n    const char* name;\n    size_t size;\n    absl::Time value;\n  };\n  static Literal literals[] = {\n      {kInfiniteFutureStr, strlen(kInfiniteFutureStr), InfiniteFuture()},\n      {kInfinitePastStr, strlen(kInfinitePastStr), InfinitePast()},\n  };\n  strip_leading_space(&input);\n  for (const auto& lit : literals) {\n    if (absl::StartsWith(input, absl::string_view(lit.name, lit.size))) {\n      absl::string_view tail = input;\n      tail.remove_prefix(lit.size);\n      strip_leading_space(&tail);\n      if (tail.empty()) {\n        *time = lit.value;\n        return true;\n      }\n    }\n  }\n\n  std::string error;\n  cctz_parts parts;\n  const bool b =\n      cctz::detail::parse(std::string(format), std::string(input),\n                          cctz::time_zone(tz), &parts.sec, &parts.fem, &error);\n  if (b) {\n    *time = Join(parts);\n  } else if (err != nullptr) {\n    *err = error;\n  }\n  return b;\n}\n\n// Functions required to support absl::Time flags.\nbool AbslParseFlag(absl::string_view text, absl::Time* t, std::string* error) {\n  return absl::ParseTime(RFC3339_full, text, absl::UTCTimeZone(), t, error);\n}\n\nstd::string AbslUnparseFlag(absl::Time t) {\n  return absl::FormatTime(RFC3339_full, t, absl::UTCTimeZone());\n}\nbool ParseFlag(const std::string& text, absl::Time* t, std::string* error) {\n  return absl::ParseTime(RFC3339_full, text, absl::UTCTimeZone(), t, error);\n}\n\nstd::string UnparseFlag(absl::Time t) {\n  return absl::FormatTime(RFC3339_full, t, absl::UTCTimeZone());\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02247",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/format.cc",
  "source_line": 27,
  "validation_status": "validated"
}