{
  "code": "{\n  uint64_t value;\n  uint8_t width;\n  char fill;\n  bool neg;\n\n  template <typename Int>\n  explicit Dec(Int v, PadSpec spec = absl::kNoPad,\n               typename std::enable_if<(sizeof(Int) <= 8)>::type* = nullptr)\n      : value(v >= 0 ? static_cast<uint64_t>(v)\n                     : uint64_t{0} - static_cast<uint64_t>(v)),\n        width(spec == absl::kNoPad       ? 1\n              : spec >= absl::kSpacePad2 ? spec - absl::kSpacePad2 + 2\n                                         : spec - absl::kZeroPad2 + 2),\n        fill(spec >= absl::kSpacePad2 ? ' ' : '0'),\n        neg(v < 0) {}\n\n  template <typename S>\n  friend void AbslStringify(S& sink, Dec dec) {\n    assert(dec.width <= numbers_internal::kFastToBufferSize);\n    char buffer[numbers_internal::kFastToBufferSize];\n    char* const end = &buffer[numbers_internal::kFastToBufferSize];\n    char* const minfill = end - dec.width;\n    char* writer = end;\n    uint64_t val = dec.value;\n    while (val > 9) {\n      *--writer = '0' + (val % 10);\n      val /= 10;\n    }\n    *--writer = '0' + static_cast<char>(val);\n    if (dec.neg) *--writer = '-';\n\n    ptrdiff_t fillers = writer - minfill;\n    if (fillers > 0) {\n      // Tricky: if the fill character is ' ', then it's <fill><+/-><digits>\n      // But...: if the fill character is '0', then it's <+/-><fill><digits>\n      bool add_sign_again = false;\n      if (dec.neg && dec.fill == '0') {  // If filling with '0',\n        ++writer;                    // ignore the sign we just added\n        add_sign_again = true;       // and re-add the sign later.\n      }\n      writer -= fillers;\n      std::fill_n(writer, fillers, dec.fill);\n      if (add_sign_again) *--writer = '-';\n    }\n\n    sink.Append(absl::string_view(writer, static_cast<size_t>(end - writer)));\n  }\n}",
  "id": "BLOCK-CPP-04121",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.h",
  "source_line": 250,
  "validation_status": "validated"
}