{
  "code": "#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/TemplateKinds.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <cstdlib>\n#include <new>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-20174_execute() {\n    {\n  public:\n    /// Describes the kind of template argument that was parsed.\n    enum KindType {\n      /// A template type parameter, stored as a type.\n      Type,\n      /// A non-type template parameter, stored as an expression.\n      NonType,\n      /// A template template argument, stored as a template name.\n      Template\n    };\n\n    /// Build an empty template argument.\n    ///\n    /// This template argument is invalid.\n    ParsedTemplateArgument() : Kind(Type), Arg(nullptr) { }\n\n    /// Create a template type argument or non-type template argument.\n    ///\n    /// \\param Arg the template type argument or non-type template argument.\n    /// \\param Loc the location of the type.\n    ParsedTemplateArgument(KindType Kind, void *Arg, SourceLocation Loc)\n      : Kind(Kind), Arg(Arg), Loc(Loc) { }\n\n    /// Create a template template argument.\n    ///\n    /// \\param SS the C++ scope specifier that precedes the template name, if\n    /// any.\n    ///\n    /// \\param Template the template to which this template template\n    /// argument refers.\n    ///\n    /// \\param TemplateLoc the location of the template name.\n    ParsedTemplateArgument(const CXXScopeSpec &SS,\n                           ParsedTemplateTy Template,\n                           SourceLocation TemplateLoc)\n      : Kind(ParsedTemplateArgument::Template),\n        Arg(Template.getAsOpaquePtr()), SS(SS), Loc(TemplateLoc) {}\n\n    /// Determine whether the given template argument is invalid.\n    bool isInvalid() const { return Arg == nullptr; }\n\n    /// Determine what kind of template argument we have.\n    KindType getKind() const { return Kind; }\n\n    /// Retrieve the template type argument's type.\n    ParsedType getAsType() const {\n      assert(Kind == Type && \"Not a template type argument\");\n      return ParsedType::getFromOpaquePtr(Arg);\n    }\n\n    /// Retrieve the non-type template argument's expression.\n    Expr *getAsExpr() const {\n      assert(Kind == NonType && \"Not a non-type template argument\");\n      return static_cast<Expr*>(Arg);\n    }\n\n    /// Retrieve the template template argument's template name.\n    ParsedTemplateTy getAsTemplate() const {\n      assert(Kind == Template && \"Not a template template argument\");\n      return ParsedTemplateTy::getFromOpaquePtr(Arg);\n    }\n\n    /// Retrieve the location of the template argument.\n    SourceLocation getLocation() const { return Loc; }\n\n    /// Retrieve the nested-name-specifier that precedes the template\n    /// name in a template template argument.\n    const CXXScopeSpec &getScopeSpec() const {\n      assert(Kind == Template &&\n             \"Only template template arguments can have a scope specifier\");\n      return SS;\n    }\n\n    /// Retrieve the location of the ellipsis that makes a template\n    /// template argument into a pack expansion.\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == Template &&\n             \"Only template template arguments can have an ellipsis\");\n      return EllipsisLoc;\n    }\n\n    /// Retrieve a pack expansion of the given template template\n    /// argument.\n    ///\n    /// \\param EllipsisLoc The location of the ellipsis.\n    ParsedTemplateArgument getTemplatePackExpansion(\n                                              SourceLocation EllipsisLoc) const;\n\n  private:\n    KindType Kind;\n\n    /// The actual template argument representation, which may be\n    /// an \\c Sema::TypeTy* (for a type), an Expr* (for an\n    /// expression), or an Sema::TemplateTy (for a template).\n    void *Arg;\n\n    /// The nested-name-specifier that can accompany a template template\n    /// argument.\n    CXXScopeSpec SS;\n\n    /// the location of the template argument.\n    SourceLocation Loc;\n\n    /// The ellipsis location that can accompany a template template\n    /// argument (turning it into a template template argument expansion).\n    SourceLocation EllipsisLoc;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-20174",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ParsedTemplate.h",
  "source_line": 29,
  "validation_status": "validated"
}