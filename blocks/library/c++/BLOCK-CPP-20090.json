{
  "code": "{\n\n  // Basic\nclass StreamingDiagnostic;\n\n// Determines whether the low bit of the result pointer for the\n// given UID is always zero. If so, ActionResult will use that bit\n// for it's \"invalid\" flag.\ntemplate <class Ptr> struct IsResultPtrLowBitFree {\n  static const bool value = false;\n  };\n\n  /// ActionResult - This structure is used while parsing/acting on\n  /// expressions, stmts, etc.  It encapsulates both the object returned by\n  /// the action, plus a sense of whether or not it is valid.\n  /// When CompressInvalid is true, the \"invalid\" flag will be\n  /// stored in the low bit of the Val pointer.\n  template<class PtrTy,\n           bool CompressInvalid = IsResultPtrLowBitFree<PtrTy>::value>\n  class ActionResult {\n    PtrTy Val;\n    bool Invalid;\n\n  public:\n    ActionResult(bool Invalid = false) : Val(PtrTy()), Invalid(Invalid) {}\n    ActionResult(PtrTy val) : Val(val), Invalid(false) {}\n    ActionResult(const DiagnosticBuilder &) : Val(PtrTy()), Invalid(true) {}\n\n    // These two overloads prevent void* -> bool conversions.\n    ActionResult(const void *) = delete;\n    ActionResult(volatile void *) = delete;\n\n    bool isInvalid() const { return Invalid; }\n    bool isUsable() const { return !Invalid && Val; }\n    bool isUnset() const { return !Invalid && !Val; }\n\n    PtrTy get() const { return Val; }\n    template <typename T> T *getAs() { return static_cast<T*>(get()); }\n\n    void set(PtrTy V) { Val = V; }\n\n    const ActionResult &operator=(PtrTy RHS) {\n      Val = RHS;\n      Invalid = false;\n      return *this;\n    }\n  };\n\n  // This ActionResult partial specialization places the \"invalid\"\n  // flag into the low bit of the pointer.\n  template<typename PtrTy>\n  class ActionResult<PtrTy, true> {\n    // A pointer whose low bit is 1 if this result is invalid, 0\n    // otherwise.\n    uintptr_t PtrWithInvalid;\n\n    using PtrTraits = llvm::PointerLikeTypeTraits<PtrTy>;\n\n  public:\n    ActionResult(bool Invalid = false)\n        : PtrWithInvalid(static_cast<uintptr_t>(Invalid)) {}\n\n    ActionResult(PtrTy V) {\n      void *VP = PtrTraits::getAsVoidPointer(V);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n    }\n\n    ActionResult(const DiagnosticBuilder &) : PtrWithInvalid(0x01) {}\n\n    // These two overloads prevent void* -> bool conversions.\n    ActionResult(const void *) = delete;\n    ActionResult(volatile void *) = delete;\n\n    bool isInvalid() const { return PtrWithInvalid & 0x01; }\n    bool isUsable() const { return PtrWithInvalid > 0x01; }\n    bool isUnset() const { return PtrWithInvalid == 0; }\n\n    PtrTy get() const {\n      void *VP = reinterpret_cast<void *>(PtrWithInvalid & ~0x01);\n      return PtrTraits::getFromVoidPointer(VP);\n    }\n\n    template <typename T> T *getAs() { return static_cast<T*>(get()); }\n\n    void set(PtrTy V) {\n      void *VP = PtrTraits::getAsVoidPointer(V);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n    }\n\n    const ActionResult &operator=(PtrTy RHS) {\n      void *VP = PtrTraits::getAsVoidPointer(RHS);\n      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);\n      assert((PtrWithInvalid & 0x01) == 0 && \"Badly aligned pointer\");\n      return *this;\n    }\n\n    // For types where we can fit a flag in with the pointer, provide\n    // conversions to/from pointer type.\n    static ActionResult getFromOpaquePointer(void *P) {\n      ActionResult Result;\n      Result.PtrWithInvalid = (uintptr_t)P;\n      return Result;\n    }\n    void *getAsOpaquePointer() const { return (void*)PtrWithInvalid; }\n  };\n\n  /// An opaque type for threading parsed type information through the\n  /// parser.\n  using ParsedType = OpaquePtr<QualType>;\n  using UnionParsedType = UnionOpaquePtr<QualType>;\n\n  // We can re-use the low bit of expression, statement, base, and\n  // member-initializer pointers for the \"invalid\" flag of\n  // ActionResult.\n  template<> struct IsResultPtrLowBitFree<Expr*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<Stmt*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<CXXBaseSpecifier*> {\n    static const bool value = true;\n  };\n  template<> struct IsResultPtrLowBitFree<CXXCtorInitializer*> {\n    static const bool value = true;\n  };\n\n  using ExprResult = ActionResult<Expr *>;\n  using StmtResult = ActionResult<Stmt *>;\n  using TypeResult = ActionResult<ParsedType>;\n  using BaseResult = ActionResult<CXXBaseSpecifier *>;\n  using MemInitResult = ActionResult<CXXCtorInitializer *>;\n\n  using DeclResult = ActionResult<Decl *>;\n  using ParsedTemplateTy = OpaquePtr<TemplateName>;\n  using UnionParsedTemplateTy = UnionOpaquePtr<TemplateName>;\n\n  using MultiExprArg = MutableArrayRef<Expr *>;\n  using MultiStmtArg = MutableArrayRef<Stmt *>;\n  using ASTTemplateArgsPtr = MutableArrayRef<ParsedTemplateArgument>;\n  using MultiTypeArg = MutableArrayRef<ParsedType>;\n  using MultiTemplateParamsArg = MutableArrayRef<TemplateParameterList *>;\n\n  inline ExprResult ExprError() { return ExprResult(true); }\n  inline StmtResult StmtError() { return StmtResult(true); }\n  inline TypeResult TypeError() { return TypeResult(true); }\n\n  inline ExprResult ExprError(const StreamingDiagnostic &) {\n    return ExprError();\n  }\n  inline StmtResult StmtError(const StreamingDiagnostic &) {\n    return StmtError();\n  }\n\n  inline ExprResult ExprEmpty() { return ExprResult(false); }\n  inline StmtResult StmtEmpty() { return StmtResult(false); }\n\n  inline Expr *AssertSuccess(ExprResult R) {\n    assert(!R.isInvalid() && \"operation was asserted to never fail!\");\n    return R.get();\n  }\n\n  inline Stmt *AssertSuccess(StmtResult R) {\n    assert(!R.isInvalid() && \"operation was asserted to never fail!\");\n    return R.get();\n  }\n\n}",
  "id": "BLOCK-CPP-20090",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Ownership.h",
  "source_line": 133,
  "validation_status": "validated"
}