{
  "code": "{\n public:\n  using result_type = ReturnType;\n\n  CoreImpl() noexcept : manager_(EmptyManager), invoker_(nullptr) {}\n\n  enum class TargetType {\n    kPointer,\n    kCompatibleAnyInvocable,\n    kIncompatibleAnyInvocable,\n    kOther,\n  };\n\n  // Note: QualDecayedTRef here includes the cv-ref qualifiers associated with\n  // the invocation of the Invocable. The unqualified type is the target object\n  // type to be stored.\n  template <class QualDecayedTRef, class F>\n  explicit CoreImpl(TypedConversionConstruct<QualDecayedTRef>, F&& f) {\n    using DecayedT = RemoveCVRef<QualDecayedTRef>;\n\n    constexpr TargetType kTargetType =\n        (std::is_pointer<DecayedT>::value ||\n         std::is_member_pointer<DecayedT>::value)\n            ? TargetType::kPointer\n        : IsCompatibleAnyInvocable<DecayedT>::value\n            ? TargetType::kCompatibleAnyInvocable\n        : IsAnyInvocable<DecayedT>::value\n            ? TargetType::kIncompatibleAnyInvocable\n            : TargetType::kOther;\n    // NOTE: We only use integers instead of enums as template parameters in\n    // order to work around a bug on C++14 under MSVC 2017.\n    // See b/236131881.\n    Initialize<kTargetType, QualDecayedTRef>(std::forward<F>(f));\n  }\n\n  // Note: QualTRef here includes the cv-ref qualifiers associated with the\n  // invocation of the Invocable. The unqualified type is the target object\n  // type to be stored.\n  template <class QualTRef, class... Args>\n  explicit CoreImpl(absl::in_place_type_t<QualTRef>, Args&&... args) {\n    InitializeStorage<QualTRef>(std::forward<Args>(args)...);\n  }\n\n  CoreImpl(CoreImpl&& other) noexcept {\n    other.manager_(FunctionToCall::relocate_from_to, &other.state_, &state_);\n    manager_ = other.manager_;\n    invoker_ = other.invoker_;\n    other.manager_ = EmptyManager;\n    other.invoker_ = nullptr;\n  }\n\n  CoreImpl& operator=(CoreImpl&& other) noexcept {\n    // Put the left-hand operand in an empty state.\n    //\n    // Note: A full reset that leaves us with an object that has its invariants\n    // intact is necessary in order to handle self-move. This is required by\n    // types that are used with certain operations of the standard library, such\n    // as the default definition of std::swap when both operands target the same\n    // object.\n    Clear();\n\n    // Perform the actual move/destroy operation on the target function.\n    other.manager_(FunctionToCall::relocate_from_to, &other.state_, &state_);\n    manager_ = other.manager_;\n    invoker_ = other.invoker_;\n    other.manager_ = EmptyManager;\n    other.invoker_ = nullptr;\n\n    return *this;\n  }\n\n  ~CoreImpl() { manager_(FunctionToCall::dispose, &state_, &state_); }\n\n  // Check whether or not the AnyInvocable is in the empty state.\n  bool HasValue() const { return invoker_ != nullptr; }\n\n  // Effects: Puts the object into its empty state.\n  void Clear() {\n    manager_(FunctionToCall::dispose, &state_, &state_);\n    manager_ = EmptyManager;\n    invoker_ = nullptr;\n  }\n\n  template <TargetType target_type, class QualDecayedTRef, class F,\n            absl::enable_if_t<target_type == TargetType::kPointer, int> = 0>\n  void Initialize(F&& f) {\n// This condition handles types that decay into pointers, which includes\n// function references. Since function references cannot be null, GCC warns\n// against comparing their decayed form with nullptr.\n// Since this is template-heavy code, we prefer to disable these warnings\n// locally instead of adding yet another overload of this function.\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"\n#pragma GCC diagnostic ignored \"-Waddress\"\n#pragma GCC diagnostic ignored \"-Wnonnull-compare\"\n#endif\n    if (static_cast<RemoveCVRef<QualDecayedTRef>>(f) == nullptr) {\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n      manager_ = EmptyManager;\n      invoker_ = nullptr;\n      return;\n    }\n    InitializeStorage<QualDecayedTRef>(std::forward<F>(f));\n  }\n\n  template <TargetType target_type, class QualDecayedTRef, class F,\n            absl::enable_if_t<\n                target_type == TargetType::kCompatibleAnyInvocable, int> = 0>\n  void Initialize(F&& f) {\n    // In this case we can \"steal the guts\" of the other AnyInvocable.\n    f.manager_(FunctionToCall::relocate_from_to, &f.state_, &state_);\n    manager_ = f.manager_;\n    invoker_ = f.invoker_;\n\n    f.manager_ = EmptyManager;\n    f.invoker_ = nullptr;\n  }\n\n  template <TargetType target_type, class QualDecayedTRef, class F,\n            absl::enable_if_t<\n                target_type == TargetType::kIncompatibleAnyInvocable, int> = 0>\n  void Initialize(F&& f) {\n    if (f.HasValue()) {\n      InitializeStorage<QualDecayedTRef>(std::forward<F>(f));\n    } else {\n      manager_ = EmptyManager;\n      invoker_ = nullptr;\n    }\n  }\n\n  template <TargetType target_type, class QualDecayedTRef, class F,\n            typename = absl::enable_if_t<target_type == TargetType::kOther>>\n  void Initialize(F&& f) {\n    InitializeStorage<QualDecayedTRef>(std::forward<F>(f));\n  }\n\n  // Use local (inline) storage for applicable target object types.\n  template <class QualTRef, class... Args,\n            typename = absl::enable_if_t<\n                IsStoredLocally<RemoveCVRef<QualTRef>>::value>>\n  void InitializeStorage(Args&&... args) {\n    using RawT = RemoveCVRef<QualTRef>;\n    ::new (static_cast<void*>(&state_.storage))\n        RawT(std::forward<Args>(args)...);\n\n    invoker_ = LocalInvoker<SigIsNoexcept, ReturnType, QualTRef, P...>;\n    // We can simplify our manager if we know the type is trivially copyable.\n    InitializeLocalManager<RawT>();\n  }\n\n  // Use remote storage for target objects that cannot be stored locally.\n  template <class QualTRef, class... Args,\n            absl::enable_if_t<!IsStoredLocally<RemoveCVRef<QualTRef>>::value,\n                              int> = 0>\n  void InitializeStorage(Args&&... args) {\n    InitializeRemoteManager<RemoveCVRef<QualTRef>>(std::forward<Args>(args)...);\n    // This is set after everything else in case an exception is thrown in an\n    // earlier step of the initialization.\n    invoker_ = RemoteInvoker<SigIsNoexcept, ReturnType, QualTRef, P...>;\n  }\n\n  template <class T,\n            typename = absl::enable_if_t<std::is_trivially_copyable<T>::value>>\n  void InitializeLocalManager() {\n    manager_ = LocalManagerTrivial;\n  }\n\n  template <class T,\n            absl::enable_if_t<!std::is_trivially_copyable<T>::value, int> = 0>\n  void InitializeLocalManager() {\n    manager_ = LocalManagerNontrivial<T>;\n  }\n\n  template <class T>\n  using HasTrivialRemoteStorage =\n      std::integral_constant<bool, std::is_trivially_destructible<T>::value &&\n                                       alignof(T) <=\n                                           ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT>;\n\n  template <class T, class... Args,\n            typename = absl::enable_if_t<HasTrivialRemoteStorage<T>::value>>\n  void InitializeRemoteManager(Args&&... args) {\n    // unique_ptr is used for exception-safety in case construction throws.\n    std::unique_ptr<void, TrivialDeleter> uninitialized_target(\n        ::operator new(sizeof(T)), TrivialDeleter(sizeof(T)));\n    ::new (uninitialized_target.get()) T(std::forward<Args>(args)...);\n    state_.remote.target = uninitialized_target.release();\n    state_.remote.size = sizeof(T);\n    manager_ = RemoteManagerTrivial;\n  }\n\n  template <class T, class... Args,\n            absl::enable_if_t<!HasTrivialRemoteStorage<T>::value, int> = 0>\n  void InitializeRemoteManager(Args&&... args) {\n    state_.remote.target = ::new T(std::forward<Args>(args)...);\n    manager_ = RemoteManagerNontrivial<T>;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Type trait to determine if the template argument is an AnyInvocable whose\n  // function type is compatible enough with ours such that we can\n  // \"move the guts\" out of it when moving, rather than having to place a new\n  // object into remote storage.\n\n  template <typename Other>\n  struct IsCompatibleAnyInvocable {\n    static constexpr bool value = false;\n  };\n\n  template <typename Sig>\n  struct IsCompatibleAnyInvocable<AnyInvocable<Sig>> {\n    static constexpr bool value =\n        (IsCompatibleConversion)(static_cast<\n                                     typename AnyInvocable<Sig>::CoreImpl*>(\n                                     nullptr),\n                                 static_cast<CoreImpl*>(nullptr));\n  };\n\n  //\n  //////////////////////////////////////////////////////////////////////////////\n\n  TypeErasedState state_;\n  ManagerType* manager_;\n  InvokerType<SigIsNoexcept, ReturnType, P...>* invoker_;\n}",
  "id": "BLOCK-CPP-05593",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/functional/internal/any_invocable.h",
  "source_line": 436,
  "validation_status": "validated"
}