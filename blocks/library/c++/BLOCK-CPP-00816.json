{
  "code": "{\ntemplate <typename T = void> struct null {};\ninline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }\ninline null<> localtime_s(...) { return null<>(); }\ninline null<> gmtime_r(...) { return null<>(); }\ninline null<> gmtime_s(...) { return null<>(); }\n\ninline const std::locale& get_classic_locale() {\n  static const auto& locale = std::locale::classic();\n  return locale;\n}\n\ntemplate <typename CodeUnit> struct codecvt_result {\n  static constexpr const size_t max_size = 32;\n  CodeUnit buf[max_size];\n  CodeUnit* end;\n};\ntemplate <typename CodeUnit>\nconstexpr const size_t codecvt_result<CodeUnit>::max_size;\n\ntemplate <typename CodeUnit>\nvoid write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,\n                   const std::locale& loc) {\n#if FMT_CLANG_VERSION\n#  pragma clang diagnostic push\n#  pragma clang diagnostic ignored \"-Wdeprecated\"\n  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);\n#  pragma clang diagnostic pop\n#else\n  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);\n#endif\n  auto mb = std::mbstate_t();\n  const char* from_next = nullptr;\n  auto result = f.in(mb, in_buf.begin(), in_buf.end(), from_next,\n                     std::begin(out.buf), std::end(out.buf), out.end);\n  if (result != std::codecvt_base::ok)\n    FMT_THROW(format_error(\"failed to format time\"));\n}\n\ntemplate <typename OutputIt>\nauto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)\n    -> OutputIt {\n  if (detail::is_utf8() && loc != get_classic_locale()) {\n    // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and\n    // gcc-4.\n#if FMT_MSC_VERSION != 0 || \\\n    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))\n    // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5\n    // and newer.\n    using code_unit = wchar_t;\n#else\n    using code_unit = char32_t;\n#endif\n\n    using unit_t = codecvt_result<code_unit>;\n    unit_t unit;\n    write_codecvt(unit, in, loc);\n    // In UTF-8 is used one to four one-byte code units.\n    auto&& buf = basic_memory_buffer<char, unit_t::max_size * 4>();\n    for (code_unit* p = unit.buf; p != unit.end; ++p) {\n      uint32_t c = static_cast<uint32_t>(*p);\n      if (sizeof(code_unit) == 2 && c >= 0xd800 && c <= 0xdfff) {\n        // surrogate pair\n        ++p;\n        if (p == unit.end || (c & 0xfc00) != 0xd800 ||\n            (*p & 0xfc00) != 0xdc00) {\n          FMT_THROW(format_error(\"failed to format time\"));\n        }\n        c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;\n      }\n      if (c < 0x80) {\n        buf.push_back(static_cast<char>(c));\n      } else if (c < 0x800) {\n        buf.push_back(static_cast<char>(0xc0 | (c >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else if ((c >= 0x800 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xffff)) {\n        buf.push_back(static_cast<char>(0xe0 | (c >> 12)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else if (c >= 0x10000 && c <= 0x10ffff) {\n        buf.push_back(static_cast<char>(0xf0 | (c >> 18)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0x3ffff) >> 12)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else {\n        FMT_THROW(format_error(\"failed to format time\"));\n      }\n    }\n    return copy_str<char>(buf.data(), buf.data() + buf.size(), out);\n  }\n  return copy_str<char>(in.data(), in.data() + in.size(), out);\n}\n\ntemplate <typename Char, typename OutputIt,\n          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>\nauto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)\n    -> OutputIt {\n  codecvt_result<Char> unit;\n  write_codecvt(unit, sv, loc);\n  return copy_str<Char>(unit.buf, unit.end, out);\n}\n\ntemplate <typename Char, typename OutputIt,\n          FMT_ENABLE_IF(std::is_same<Char, char>::value)>\nauto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)\n    -> OutputIt {\n  return write_encoded_tm_str(out, sv, loc);\n}\n\ntemplate <typename Char>\ninline void do_write(buffer<Char>& buf, const std::tm& time,\n                     const std::locale& loc, char format, char modifier) {\n  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);\n  auto&& os = std::basic_ostream<Char>(&format_buf);\n  os.imbue(loc);\n  using iterator = std::ostreambuf_iterator<Char>;\n  const auto& facet = std::use_facet<std::time_put<Char, iterator>>(loc);\n  auto end = facet.put(os, os, Char(' '), &time, format, modifier);\n  if (end.failed()) FMT_THROW(format_error(\"failed to format time\"));\n}\n\ntemplate <typename Char, typename OutputIt,\n          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>\nauto write(OutputIt out, const std::tm& time, const std::locale& loc,\n           char format, char modifier = 0) -> OutputIt {\n  auto&& buf = get_buffer<Char>(out);\n  do_write<Char>(buf, time, loc, format, modifier);\n  return buf.out();\n}\n\ntemplate <typename Char, typename OutputIt,\n          FMT_ENABLE_IF(std::is_same<Char, char>::value)>\nauto write(OutputIt out, const std::tm& time, const std::locale& loc,\n           char format, char modifier = 0) -> OutputIt {\n  auto&& buf = basic_memory_buffer<Char>();\n  do_write<char>(buf, time, loc, format, modifier);\n  return write_encoded_tm_str(out, string_view(buf.data(), buf.size()), loc);\n}\n\n}",
  "id": "BLOCK-CPP-00816",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/chrono.h",
  "source_line": 303,
  "validation_status": "validated"
}