{
  "code": "{\n  static constexpr size_t ChunksNeeded(int exp) {\n    // We will left shift a uint128 by `exp` bits, so we need `128+exp` total\n    // bits. Round up to 32.\n    // See constructor for details about adding `10%` to the value.\n    return static_cast<size_t>((128 + exp + 31) / 32 * 11 / 10);\n  }\n\n public:\n  // Run the conversion for `v * 2^exp` and call `f(binary_to_decimal)`.\n  // This function will allocate enough stack space to perform the conversion.\n  static void RunConversion(uint128 v, int exp,\n                            absl::FunctionRef<void(BinaryToDecimal)> f) {\n    assert(exp > 0);\n    assert(exp <= std::numeric_limits<MaxFloatType>::max_exponent);\n    static_assert(\n        StackArray::kMaxCapacity >=\n            ChunksNeeded(std::numeric_limits<MaxFloatType>::max_exponent),\n        \"\");\n\n    StackArray::RunWithCapacity(\n        ChunksNeeded(exp),\n        [=](absl::Span<uint32_t> input) { f(BinaryToDecimal(input, v, exp)); });\n  }\n\n  size_t TotalDigits() const {\n    return (decimal_end_ - decimal_start_) * kDigitsPerChunk +\n           CurrentDigits().size();\n  }\n\n  // See the current block of digits.\n  absl::string_view CurrentDigits() const {\n    return absl::string_view(digits_ + kDigitsPerChunk - size_, size_);\n  }\n\n  // Advance the current view of digits.\n  // Returns `false` when no more digits are available.\n  bool AdvanceDigits() {\n    if (decimal_start_ >= decimal_end_) return false;\n\n    uint32_t w = data_[decimal_start_++];\n    for (size_ = 0; size_ < kDigitsPerChunk; w /= 10) {\n      digits_[kDigitsPerChunk - ++size_] = w % 10 + '0';\n    }\n    return true;\n  }\n\n private:\n  BinaryToDecimal(absl::Span<uint32_t> data, uint128 v, int exp) : data_(data) {\n    // We need to print the digits directly into the sink object without\n    // buffering them all first. To do this we need two things:\n    // - to know the total number of digits to do padding when necessary\n    // - to generate the decimal digits from the left.\n    //\n    // In order to do this, we do a two pass conversion.\n    // On the first pass we convert the binary representation of the value into\n    // a decimal representation in which each uint32_t chunk holds up to 9\n    // decimal digits.  In the second pass we take each decimal-holding-uint32_t\n    // value and generate the ascii decimal digits into `digits_`.\n    //\n    // The binary and decimal representations actually share the same memory\n    // region. As we go converting the chunks from binary to decimal we free\n    // them up and reuse them for the decimal representation. One caveat is that\n    // the decimal representation is around 7% less efficient in space than the\n    // binary one. We allocate an extra 10% memory to account for this. See\n    // ChunksNeeded for this calculation.\n    size_t after_chunk_index = static_cast<size_t>(exp / 32 + 1);\n    decimal_start_ = decimal_end_ = ChunksNeeded(exp);\n    const int offset = exp % 32;\n    // Left shift v by exp bits.\n    data_[after_chunk_index - 1] = static_cast<uint32_t>(v << offset);\n    for (v >>= (32 - offset); v; v >>= 32)\n      data_[++after_chunk_index - 1] = static_cast<uint32_t>(v);\n\n    while (after_chunk_index > 0) {\n      // While we have more than one chunk available, go in steps of 1e9.\n      // `data_[after_chunk_index - 1]` holds the highest non-zero binary chunk,\n      // so keep the variable updated.\n      uint32_t carry = 0;\n      for (size_t i = after_chunk_index; i > 0; --i) {\n        uint64_t tmp = uint64_t{data_[i - 1]} + (uint64_t{carry} << 32);\n        data_[i - 1] = static_cast<uint32_t>(tmp / uint64_t{1000000000});\n        carry = static_cast<uint32_t>(tmp % uint64_t{1000000000});\n      }\n\n      // If the highest chunk is now empty, remove it from view.\n      if (data_[after_chunk_index - 1] == 0)\n        --after_chunk_index;\n\n      --decimal_start_;\n      assert(decimal_start_ != after_chunk_index - 1);\n      data_[decimal_start_] = carry;\n    }\n\n    // Fill the first set of digits. The first chunk might not be complete, so\n    // handle differently.\n    for (uint32_t first = data_[decimal_start_++]; first != 0; first /= 10) {\n      digits_[kDigitsPerChunk - ++size_] = first % 10 + '0';\n    }\n  }\n\n private:\n  static constexpr size_t kDigitsPerChunk = 9;\n\n  size_t decimal_start_;\n  size_t decimal_end_;\n\n  char digits_[kDigitsPerChunk];\n  size_t size_ = 0;\n\n  absl::Span<uint32_t> data_;\n}",
  "id": "BLOCK-CPP-03101",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 130,
  "validation_status": "validated"
}