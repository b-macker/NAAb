{
  "code": "{\n\n/// Specifies the type of tracking for an expression.\nenum class TrackingKind {\n  /// Default tracking kind -- specifies that as much information should be\n  /// gathered about the tracked expression value as possible.\n  Thorough,\n  /// Specifies that a more moderate tracking should be used for the expression\n  /// value. This will essentially make sure that functions relevant to it\n  /// aren't pruned, but otherwise relies on the user reading the code or\n  /// following the arrows.\n  Condition\n};\n\n/// Defines a set of options altering tracking behavior.\nstruct TrackingOptions {\n  /// Specifies the kind of tracking.\n  TrackingKind Kind = TrackingKind::Thorough;\n  /// Specifies whether we should employ false positive suppression\n  /// (inlined defensive checks, returned null).\n  bool EnableNullFPSuppression = true;\n};\n\n/// Describes an event when the value got stored into a memory region.\n///\n/// As opposed to checker checkBind API, it reacts also to binds\n/// generated by the checker as well.  It can be useful when the binding\n/// happened as a result of evalCall, for example.\nstruct StoreInfo {\n  enum Kind {\n    /// The value got stored into the region during initialization:\n    ///   int x = 42;\n    Initialization,\n    /// The value got stored into the region during assignment:\n    ///   int x;\n    ///   x = 42;\n    Assignment,\n    /// The value got stored into the parameter region as the result\n    /// of a call.\n    CallArgument,\n    /// The value got stored into the region as block capture.\n    /// Block data is modeled as a separate region, thus whenever\n    /// the analyzer sees a captured variable, its value is copied\n    /// into a special block region.\n    BlockCapture\n  };\n\n  /// The type of store operation.\n  Kind StoreKind;\n  /// The node where the store happened.\n  const ExplodedNode *StoreSite;\n  /// The expression where the value comes from.\n  /// NOTE: might be null.\n  const Expr *SourceOfTheValue;\n  /// Symbolic value that is being stored.\n  SVal Value;\n  /// Memory regions involved in the store operation.\n  ///   Dest <- Origin\n  /// NOTE: Origin might be null, when the stored value doesn't come\n  ///       from another region.\n  const MemRegion *Dest, *Origin;\n};\n\nclass Tracker;\nusing TrackerRef = llvm::IntrusiveRefCntPtr<Tracker>;\n\nclass ExpressionHandler;\nclass StoreHandler;\n\n/// A generalized component for tracking expressions, values, and stores.\n///\n/// Tracker aimes at providing a sensible set of default behaviors that can be\n/// used by any checker, while providing mechanisms to hook into any part of the\n/// tracking process and insert checker-specific logic.\nclass Tracker : public llvm::RefCountedBase<Tracker> {\nprivate:\n  using ExpressionHandlerPtr = std::unique_ptr<ExpressionHandler>;\n  using StoreHandlerPtr = std::unique_ptr<StoreHandler>;\n\n  PathSensitiveBugReport &Report;\n  std::list<ExpressionHandlerPtr> ExpressionHandlers;\n  std::list<StoreHandlerPtr> StoreHandlers;\n\nprotected:\n  /// \\param Report The bug report to which visitors should be attached.\n  Tracker(PathSensitiveBugReport &Report);\n\npublic:\n  virtual ~Tracker() = default;\n\n  static TrackerRef create(PathSensitiveBugReport &Report) {\n    return new Tracker(Report);\n  }\n\n  PathSensitiveBugReport &getReport() { return Report; }\n\n  /// Describes a tracking result with the most basic information of what was\n  /// actually done (or not done).\n  struct Result {\n    /// Usually it means that the tracker added visitors.\n    bool FoundSomethingToTrack = false;\n    /// Signifies that the tracking was interrupted at some point.\n    /// Usually this information is important only for sub-trackers.\n    bool WasInterrupted = false;\n\n    /// Combines the current result with the given result.\n    void combineWith(const Result &Other) {\n      // If we found something in one of the cases, we can\n      // say we found something overall.\n      FoundSomethingToTrack |= Other.FoundSomethingToTrack;\n      // The same goes to the interruption.\n      WasInterrupted |= Other.WasInterrupted;\n    }\n  };\n\n  /// Track expression value back to its point of origin.\n  ///\n  /// \\param E The expression value which we are tracking\n  /// \\param N A node \"downstream\" from the evaluation of the statement.\n  /// \\param Opts Tracking options specifying how we want to track the value.\n  virtual Result track(const Expr *E, const ExplodedNode *N,\n                       TrackingOptions Opts = {});\n\n  /// Track how the value got stored into the given region and where it came\n  /// from.\n  ///\n  /// \\param V We're searching for the store where \\c R received this value.\n  /// \\param R The region we're tracking.\n  /// \\param Opts Tracking options specifying how we want to track the value.\n  /// \\param Origin Only adds notes when the last store happened in a\n  ///        different stackframe to this one. Disregarded if the tracking kind\n  ///        is thorough.\n  ///        This is useful, because for non-tracked regions, notes about\n  ///        changes to its value in a nested stackframe could be pruned, and\n  ///        this visitor can prevent that without polluting the bugpath too\n  ///        much.\n  virtual Result track(SVal V, const MemRegion *R, TrackingOptions Opts = {},\n                       const StackFrameContext *Origin = nullptr);\n\n  /// Handle the store operation and produce the note.\n  ///\n  /// \\param SI The information fully describing the store.\n  /// \\param Opts Tracking options specifying how we got to it.\n  ///\n  /// NOTE: this method is designed for sub-trackers and visitors.\n  virtual PathDiagnosticPieceRef handle(StoreInfo SI, BugReporterContext &BRC,\n                                        TrackingOptions Opts);\n\n  /// Add custom expression handler with the highest priority.\n  ///\n  /// It means that it will be asked for handling first, and can prevent\n  /// other handlers from running if decides to interrupt.\n  void addHighPriorityHandler(ExpressionHandlerPtr SH) {\n    ExpressionHandlers.push_front(std::move(SH));\n  }\n\n  /// Add custom expression handler with the lowest priority.\n  ///\n  /// It means that it will be asked for handling last, and other handlers can\n  /// prevent it from running if any of them decides to interrupt.\n  void addLowPriorityHandler(ExpressionHandlerPtr SH) {\n    ExpressionHandlers.push_back(std::move(SH));\n  }\n\n  /// Add custom store handler with the highest priority.\n  ///\n  /// It means that it will be asked for handling first, and will prevent\n  /// other handlers from running if it produces non-null note.\n  void addHighPriorityHandler(StoreHandlerPtr SH) {\n    StoreHandlers.push_front(std::move(SH));\n  }\n\n  /// Add custom store handler with the lowest priority.\n  ///\n  /// It means that it will be asked for handling last, only\n  /// if all other handlers failed to produce the note.\n  void addLowPriorityHandler(StoreHandlerPtr SH) {\n    StoreHandlers.push_back(std::move(SH));\n  }\n\n  /// Add custom expression/store handler with the highest priority\n  ///\n  /// See other overloads for explanation.\n  template <class HandlerType, class... Args>\n  void addHighPriorityHandler(Args &&... ConstructorArgs) {\n    addHighPriorityHandler(std::make_unique<HandlerType>(\n        *this, std::forward<Args>(ConstructorArgs)...));\n  }\n\n  /// Add custom expression/store handler with the lowest priority\n  ///\n  /// See other overloads for explanation.\n  template <class HandlerType, class... Args>\n  void addLowPriorityHandler(Args &&... ConstructorArgs) {\n    addLowPriorityHandler(std::make_unique<HandlerType>(\n        *this, std::forward<Args>(ConstructorArgs)...));\n  }\n};\n\n/// Handles expressions during the tracking.\nclass ExpressionHandler {\nprivate:\n  Tracker &ParentTracker;\n\npublic:\n  ExpressionHandler(Tracker &ParentTracker) : ParentTracker(ParentTracker) {}\n  virtual ~ExpressionHandler() {}\n\n  /// Handle the given expression from the given node.\n  ///\n  /// \\param E The expression value which we are tracking\n  /// \\param Original A node \"downstream\" where the tracking started.\n  /// \\param ExprNode A node where the evaluation of \\c E actually happens.\n  /// \\param Opts Tracking options specifying how we are tracking the value.\n  virtual Tracker::Result handle(const Expr *E, const ExplodedNode *Original,\n                                 const ExplodedNode *ExprNode,\n                                 TrackingOptions Opts) = 0;\n\n  /// \\Return the tracker that initiated the process.\n  Tracker &getParentTracker() { return ParentTracker; }\n};\n\n/// Handles stores during the tracking.\nclass StoreHandler {\nprivate:\n  Tracker &ParentTracker;\n\npublic:\n  StoreHandler(Tracker &ParentTracker) : ParentTracker(ParentTracker) {}\n  virtual ~StoreHandler() {}\n\n  /// Handle the given store and produce the node.\n  ///\n  /// \\param SI The information fully describing the store.\n  /// \\param Opts Tracking options specifying how we are tracking the value.\n  ///\n  /// \\return the produced note, null if the handler doesn't support this kind\n  ///         of stores.\n  virtual PathDiagnosticPieceRef handle(StoreInfo SI, BugReporterContext &BRC,\n                                        TrackingOptions Opts) = 0;\n\n  Tracker &getParentTracker() { return ParentTracker; }\n\nprotected:\n  PathDiagnosticPieceRef constructNote(StoreInfo SI, BugReporterContext &BRC,\n                                       StringRef NodeText);\n};\n\n/// Visitor that tracks expressions and values.\nclass TrackingBugReporterVisitor : public BugReporterVisitor {\nprivate:\n  TrackerRef ParentTracker;\n\npublic:\n  TrackingBugReporterVisitor(TrackerRef ParentTracker)\n      : ParentTracker(ParentTracker) {}\n\n  Tracker &getParentTracker() { return *ParentTracker; }\n};\n\n/// Attempts to add visitors to track expression value back to its point of\n/// origin.\n///\n/// \\param N A node \"downstream\" from the evaluation of the statement.\n/// \\param E The expression value which we are tracking\n/// \\param R The bug report to which visitors should be attached.\n/// \\param Opts Tracking options specifying how we are tracking the value.\n///\n/// \\return Whether or not the function was able to add visitors for this\n///         statement. Note that returning \\c true does not actually imply\n///         that any visitors were added.\nbool trackExpressionValue(const ExplodedNode *N, const Expr *E,\n                          PathSensitiveBugReport &R, TrackingOptions Opts = {});\n\n/// Track how the value got stored into the given region and where it came\n/// from.\n///\n/// \\param V We're searching for the store where \\c R received this value.\n/// \\param R The region we're tracking.\n/// \\param Opts Tracking options specifying how we want to track the value.\n/// \\param Origin Only adds notes when the last store happened in a\n///        different stackframe to this one. Disregarded if the tracking kind\n///        is thorough.\n///        This is useful, because for non-tracked regions, notes about\n///        changes to its value in a nested stackframe could be pruned, and\n///        this visitor can prevent that without polluting the bugpath too\n///        much.\nvoid trackStoredValue(KnownSVal V, const MemRegion *R,\n                      PathSensitiveBugReport &Report, TrackingOptions Opts = {},\n                      const StackFrameContext *Origin = nullptr);\n\nconst Expr *getDerefExpr(const Stmt *S);\n\n}",
  "id": "BLOCK-CPP-22461",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h",
  "source_line": 99,
  "validation_status": "validated"
}