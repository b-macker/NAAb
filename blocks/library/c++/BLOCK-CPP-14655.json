{
  "code": "{\npublic:\n  enum Kind {\n    CK_VCallOffset,\n    CK_VBaseOffset,\n    CK_OffsetToTop,\n    CK_RTTI,\n    CK_FunctionPointer,\n\n    /// A pointer to the complete destructor.\n    CK_CompleteDtorPointer,\n\n    /// A pointer to the deleting destructor.\n    CK_DeletingDtorPointer,\n\n    /// An entry that is never used.\n    ///\n    /// In some cases, a vtable function pointer will end up never being\n    /// called. Such vtable function pointers are represented as a\n    /// CK_UnusedFunctionPointer.\n    CK_UnusedFunctionPointer\n  };\n\n  VTableComponent() = default;\n\n  static VTableComponent MakeVCallOffset(CharUnits Offset) {\n    return VTableComponent(CK_VCallOffset, Offset);\n  }\n\n  static VTableComponent MakeVBaseOffset(CharUnits Offset) {\n    return VTableComponent(CK_VBaseOffset, Offset);\n  }\n\n  static VTableComponent MakeOffsetToTop(CharUnits Offset) {\n    return VTableComponent(CK_OffsetToTop, Offset);\n  }\n\n  static VTableComponent MakeRTTI(const CXXRecordDecl *RD) {\n    return VTableComponent(CK_RTTI, reinterpret_cast<uintptr_t>(RD));\n  }\n\n  static VTableComponent MakeFunction(const CXXMethodDecl *MD) {\n    assert(!isa<CXXDestructorDecl>(MD) &&\n           \"Don't use MakeFunction with destructors!\");\n\n    return VTableComponent(CK_FunctionPointer,\n                           reinterpret_cast<uintptr_t>(MD));\n  }\n\n  static VTableComponent MakeCompleteDtor(const CXXDestructorDecl *DD) {\n    return VTableComponent(CK_CompleteDtorPointer,\n                           reinterpret_cast<uintptr_t>(DD));\n  }\n\n  static VTableComponent MakeDeletingDtor(const CXXDestructorDecl *DD) {\n    return VTableComponent(CK_DeletingDtorPointer,\n                           reinterpret_cast<uintptr_t>(DD));\n  }\n\n  static VTableComponent MakeUnusedFunction(const CXXMethodDecl *MD) {\n    assert(!isa<CXXDestructorDecl>(MD) &&\n           \"Don't use MakeUnusedFunction with destructors!\");\n    return VTableComponent(CK_UnusedFunctionPointer,\n                           reinterpret_cast<uintptr_t>(MD));\n  }\n\n  /// Get the kind of this vtable component.\n  Kind getKind() const {\n    return (Kind)(Value & 0x7);\n  }\n\n  CharUnits getVCallOffset() const {\n    assert(getKind() == CK_VCallOffset && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  CharUnits getVBaseOffset() const {\n    assert(getKind() == CK_VBaseOffset && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  CharUnits getOffsetToTop() const {\n    assert(getKind() == CK_OffsetToTop && \"Invalid component kind!\");\n\n    return getOffset();\n  }\n\n  const CXXRecordDecl *getRTTIDecl() const {\n    assert(isRTTIKind() && \"Invalid component kind!\");\n    return reinterpret_cast<CXXRecordDecl *>(getPointer());\n  }\n\n  const CXXMethodDecl *getFunctionDecl() const {\n    assert(isFunctionPointerKind() && \"Invalid component kind!\");\n    if (isDestructorKind())\n      return getDestructorDecl();\n    return reinterpret_cast<CXXMethodDecl *>(getPointer());\n  }\n\n  const CXXDestructorDecl *getDestructorDecl() const {\n    assert(isDestructorKind() && \"Invalid component kind!\");\n    return reinterpret_cast<CXXDestructorDecl *>(getPointer());\n  }\n\n  const CXXMethodDecl *getUnusedFunctionDecl() const {\n    assert(getKind() == CK_UnusedFunctionPointer && \"Invalid component kind!\");\n    return reinterpret_cast<CXXMethodDecl *>(getPointer());\n  }\n\n  bool isDestructorKind() const { return isDestructorKind(getKind()); }\n\n  bool isUsedFunctionPointerKind() const {\n    return isUsedFunctionPointerKind(getKind());\n  }\n\n  bool isFunctionPointerKind() const {\n    return isFunctionPointerKind(getKind());\n  }\n\n  bool isRTTIKind() const { return isRTTIKind(getKind()); }\n\n  GlobalDecl getGlobalDecl() const {\n    assert(isUsedFunctionPointerKind() &&\n           \"GlobalDecl can be created only from virtual function\");\n\n    auto *DtorDecl = dyn_cast<CXXDestructorDecl>(getFunctionDecl());\n    switch (getKind()) {\n    case CK_FunctionPointer:\n      return GlobalDecl(getFunctionDecl());\n    case CK_CompleteDtorPointer:\n      return GlobalDecl(DtorDecl, CXXDtorType::Dtor_Complete);\n    case CK_DeletingDtorPointer:\n      return GlobalDecl(DtorDecl, CXXDtorType::Dtor_Deleting);\n    case CK_VCallOffset:\n    case CK_VBaseOffset:\n    case CK_OffsetToTop:\n    case CK_RTTI:\n    case CK_UnusedFunctionPointer:\n      llvm_unreachable(\"Only function pointers kinds\");\n    }\n    llvm_unreachable(\"Should already return\");\n  }\n\nprivate:\n  static bool isFunctionPointerKind(Kind ComponentKind) {\n    return isUsedFunctionPointerKind(ComponentKind) ||\n           ComponentKind == CK_UnusedFunctionPointer;\n  }\n  static bool isUsedFunctionPointerKind(Kind ComponentKind) {\n    return ComponentKind == CK_FunctionPointer ||\n           isDestructorKind(ComponentKind);\n  }\n  static bool isDestructorKind(Kind ComponentKind) {\n    return ComponentKind == CK_CompleteDtorPointer ||\n           ComponentKind == CK_DeletingDtorPointer;\n  }\n  static bool isRTTIKind(Kind ComponentKind) {\n    return ComponentKind == CK_RTTI;\n  }\n\n  VTableComponent(Kind ComponentKind, CharUnits Offset) {\n    assert((ComponentKind == CK_VCallOffset ||\n            ComponentKind == CK_VBaseOffset ||\n            ComponentKind == CK_OffsetToTop) && \"Invalid component kind!\");\n    assert(Offset.getQuantity() < (1LL << 56) && \"Offset is too big!\");\n    assert(Offset.getQuantity() >= -(1LL << 56) && \"Offset is too small!\");\n\n    Value = (uint64_t(Offset.getQuantity()) << 3) | ComponentKind;\n  }\n\n  VTableComponent(Kind ComponentKind, uintptr_t Ptr) {\n    assert((isRTTIKind(ComponentKind) || isFunctionPointerKind(ComponentKind)) &&\n           \"Invalid component kind!\");\n\n    assert((Ptr & 7) == 0 && \"Pointer not sufficiently aligned!\");\n\n    Value = Ptr | ComponentKind;\n  }\n\n  CharUnits getOffset() const {\n    assert((getKind() == CK_VCallOffset || getKind() == CK_VBaseOffset ||\n            getKind() == CK_OffsetToTop) && \"Invalid component kind!\");\n\n    return CharUnits::fromQuantity(Value >> 3);\n  }\n\n  uintptr_t getPointer() const {\n    assert((getKind() == CK_RTTI || isFunctionPointerKind()) &&\n           \"Invalid component kind!\");\n\n    return static_cast<uintptr_t>(Value & ~7ULL);\n  }\n\n  /// The kind is stored in the lower 3 bits of the value. For offsets, we\n  /// make use of the facts that classes can't be larger than 2^55 bytes,\n  /// so we store the offset in the lower part of the 61 bits that remain.\n  /// (The reason that we're not simply using a PointerIntPair here is that we\n  /// need the offsets to be 64-bit, even when on a 32-bit machine).\n  int64_t Value;\n}",
  "id": "BLOCK-CPP-14655",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/VTableBuilder.h",
  "source_line": 30,
  "validation_status": "validated"
}