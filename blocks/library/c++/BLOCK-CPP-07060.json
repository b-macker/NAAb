{
  "code": "{\n  ///   void f();\n  /// };\n  ///\n  /// template<typename T>\n  /// struct B : A<T> {\n  ///   using A<T>::f;\n  /// };\n  ///\n  /// template struct B<int>;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the UsingDecl in\n  /// B<int> to the UnresolvedUsingDecl in B<T>.\n  llvm::DenseMap<NamedDecl *, NamedDecl *> InstantiatedFromUsingDecl;\n\n  /// Like InstantiatedFromUsingDecl, but for using-enum-declarations. Maps\n  /// from the instantiated using-enum to the templated decl from whence it\n  /// came.\n  /// Note that using-enum-declarations cannot be dependent and\n  /// thus will never be instantiated from an \"unresolved\"\n  /// version thereof (as with using-declarations), so each mapping is from\n  /// a (resolved) UsingEnumDecl to a (resolved) UsingEnumDecl.\n  llvm::DenseMap<UsingEnumDecl *, UsingEnumDecl *>\n      InstantiatedFromUsingEnumDecl;\n\n  /// Simlarly maps instantiated UsingShadowDecls to their origin.\n  llvm::DenseMap<UsingShadowDecl*, UsingShadowDecl*>\n    InstantiatedFromUsingShadowDecl;\n\n  llvm::DenseMap<FieldDecl *, FieldDecl *> InstantiatedFromUnnamedFieldDecl;\n\n  /// Mapping that stores the methods overridden by a given C++\n  /// member function.\n  ///\n  /// Since most C++ member functions aren't virtual and therefore\n  /// don't override anything, we store the overridden functions in\n  /// this map on the side rather than within the CXXMethodDecl structure.\n  using CXXMethodVector = llvm::TinyPtrVector<const CXXMethodDecl *>;\n  llvm::DenseMap<const CXXMethodDecl *, CXXMethodVector> OverriddenMethods;\n\n  /// Mapping from each declaration context to its corresponding\n  /// mangling numbering context (used for constructs like lambdas which\n  /// need to be consistently numbered for the mangler).\n  llvm::DenseMap<const DeclContext *, std::unique_ptr<MangleNumberingContext>>\n      MangleNumberingContexts;\n  llvm::DenseMap<const Decl *, std::unique_ptr<MangleNumberingContext>>\n      ExtraMangleNumberingContexts;\n\n  /// Side-table of mangling numbers for declarations which rarely\n  /// need them (like static local vars).\n  llvm::MapVector<const NamedDecl *, unsigned> MangleNumbers;\n  llvm::MapVector<const VarDecl *, unsigned> StaticLocalNumbers;\n  /// Mapping the associated device lambda mangling number if present.\n  mutable llvm::DenseMap<const CXXRecordDecl *, unsigned>\n      DeviceLambdaManglingNumbers;\n\n  /// Mapping that stores parameterIndex values for ParmVarDecls when\n  /// that value exceeds the bitfield size of ParmVarDeclBits.ParameterIndex.\n  using ParameterIndexTable = llvm::DenseMap<const VarDecl *, unsigned>;\n  ParameterIndexTable ParamIndices;\n\n  ImportDecl *FirstLocalImport = nullptr;\n  ImportDecl *LastLocalImport = nullptr;\n\n  TranslationUnitDecl *TUDecl = nullptr;\n  mutable ExternCContextDecl *ExternCContext = nullptr;\n  mutable BuiltinTemplateDecl *MakeIntegerSeqDecl = nullptr;\n  mutable BuiltinTemplateDecl *TypePackElementDecl = nullptr;\n\n  /// The associated SourceManager object.\n  SourceManager &SourceMgr;\n\n  /// The language options used to create the AST associated with\n  ///  this ASTContext object.\n  LangOptions &LangOpts;\n\n  /// NoSanitizeList object that is used by sanitizers to decide which\n  /// entities should not be instrumented.\n  std::unique_ptr<NoSanitizeList> NoSanitizeL;\n\n  /// Function filtering mechanism to determine whether a given function\n  /// should be imbued with the XRay \"always\" or \"never\" attributes.\n  std::unique_ptr<XRayFunctionFilter> XRayFilter;\n\n  /// ProfileList object that is used by the profile instrumentation\n  /// to decide which entities should be instrumented.\n  std::unique_ptr<ProfileList> ProfList;\n\n  /// The allocator used to create AST objects.\n  ///\n  /// AST objects are never destructed; rather, all memory associated with the\n  /// AST objects will be released when the ASTContext itself is destroyed.\n  mutable llvm::BumpPtrAllocator BumpAlloc;\n\n  /// Allocator for partial diagnostics.\n  PartialDiagnostic::DiagStorageAllocator DiagAllocator;\n\n  /// The current C++ ABI.\n  std::unique_ptr<CXXABI> ABI;\n  CXXABI *createCXXABI(const TargetInfo &T);\n\n  /// Address space map mangling must be used with language specific\n  /// address spaces (e.g. OpenCL/CUDA)\n  bool AddrSpaceMapMangling;\n\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  clang::PrintingPolicy PrintingPolicy;\n  std::unique_ptr<interp::Context> InterpContext;\n  std::unique_ptr<ParentMapContext> ParentMapCtx;\n\n  /// Keeps track of the deallocated DeclListNodes for future reuse.\n  DeclListNode *ListNodeFreeList = nullptr;\n\npublic:\n  IdentifierTable &Idents;\n  SelectorTable &Selectors;\n  Builtin::Context &BuiltinInfo;\n  const TranslationUnitKind TUKind;\n  mutable DeclarationNameTable DeclarationNames;\n  IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;\n  ASTMutationListener *Listener = nullptr;\n\n  /// Returns the clang bytecode interpreter context.\n  interp::Context &getInterpContext();\n\n  struct CUDAConstantEvalContext {\n    /// Do not allow wrong-sided variables in constant expressions.\n    bool NoWrongSidedVars = false;\n  } CUDAConstantEvalCtx;\n  struct CUDAConstantEvalContextRAII {\n    ASTContext &Ctx;\n    CUDAConstantEvalContext SavedCtx;\n    CUDAConstantEvalContextRAII(ASTContext &Ctx_, bool NoWrongSidedVars)\n        : Ctx(Ctx_), SavedCtx(Ctx_.CUDAConstantEvalCtx) {\n      Ctx_.CUDAConstantEvalCtx.NoWrongSidedVars = NoWrongSidedVars;\n    }\n    ~CUDAConstantEvalContextRAII() { Ctx.CUDAConstantEvalCtx = SavedCtx; }\n  };\n\n  /// Returns the dynamic AST node parent map context.\n  ParentMapContext &getParentMapContext();\n\n  // A traversal scope limits the parts of the AST visible to certain analyses.\n  // RecursiveASTVisitor only visits specified children of TranslationUnitDecl.\n  // getParents() will only observe reachable parent edges.\n  //\n  // The scope is defined by a set of \"top-level\" declarations which will be\n  // visible under the TranslationUnitDecl.\n  // Initially, it is the entire TU, represented by {getTranslationUnitDecl()}.\n  //\n  // After setTraversalScope({foo, bar}), the exposed AST looks like:\n  // TranslationUnitDecl\n  //  - foo\n  //    - ...\n  //  - bar\n  //    - ...\n  // All other siblings of foo and bar are pruned from the tree.\n  // (However they are still accessible via TranslationUnitDecl->decls())\n  //\n  // Changing the scope clears the parent cache, which is expensive to rebuild.\n  std::vector<Decl *> getTraversalScope() const { return TraversalScope; }\n  void setTraversalScope(const std::vector<Decl *> &);\n\n  /// Forwards to get node parents from the ParentMapContext. New callers should\n  /// use ParentMapContext::getParents() directly.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  const clang::PrintingPolicy &getPrintingPolicy() const {\n    return PrintingPolicy;\n  }\n\n  void setPrintingPolicy(const clang::PrintingPolicy &Policy) {\n    PrintingPolicy = Policy;\n  }\n\n  SourceManager& getSourceManager() { return SourceMgr; }\n  const SourceManager& getSourceManager() const { return SourceMgr; }\n\n  // Cleans up some of the data structures. This allows us to do cleanup\n  // normally done in the destructor earlier. Renders much of the ASTContext\n  // unusable, mostly the actual AST nodes, so should be called when we no\n  // longer need access to the AST.\n  void cleanup();\n\n  llvm::BumpPtrAllocator &getAllocator() const {\n    return BumpAlloc;\n  }\n\n  void *Allocate(size_t Size, unsigned Align = 8) const {\n    return BumpAlloc.Allocate(Size, Align);\n  }\n  template <typename T> T *Allocate(size_t Num = 1) const {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n  void Deallocate(void *Ptr) const {}\n\n  /// Allocates a \\c DeclListNode or returns one from the \\c ListNodeFreeList\n  /// pool.\n  DeclListNode *AllocateDeclListNode(clang::NamedDecl *ND) {\n    if (DeclListNode *Alloc = ListNodeFreeList) {\n      ListNodeFreeList = Alloc->Rest.dyn_cast<DeclListNode*>();\n      Alloc->D = ND;\n      Alloc->Rest = nullptr;\n      return Alloc;\n    }\n    return new (*this) DeclListNode(ND);\n  }\n  /// Deallcates a \\c DeclListNode by returning it to the \\c ListNodeFreeList\n  /// pool.\n  void DeallocateDeclListNode(DeclListNode *N) {\n    N->Rest = ListNodeFreeList;\n    ListNodeFreeList = N;\n  }\n\n  /// Return the total amount of physical memory allocated for representing\n  /// AST nodes and type information.\n  size_t getASTAllocatedMemory() const {\n    return BumpAlloc.getTotalMemory();\n  }\n\n  /// Return the total memory used for various side tables.\n  size_t getSideTableAllocatedMemory() const;\n\n  PartialDiagnostic::DiagStorageAllocator &getDiagAllocator() {\n    return DiagAllocator;\n  }\n\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n\n  /// getIntTypeForBitwidth -\n  /// sets integer QualTy according to specified details:\n  /// bitwidth, signed/unsigned.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getIntTypeForBitwidth(unsigned DestWidth,\n                                 unsigned Signed) const;\n\n  /// getRealTypeForBitwidth -\n  /// sets floating point QualTy according to specified bitwidth.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getRealTypeForBitwidth(unsigned DestWidth,\n                                  FloatModeKind ExplicitType) const;\n\n  bool AtomicUsesUnsupportedLibcall(const AtomicExpr *E) const;\n\n  const LangOptions& getLangOpts() const { return LangOpts; }\n\n  // If this condition is false, typo correction must be performed eagerly\n  // rather than delayed in many places, as it makes use of dependent types.\n  // the condition is false for clang's C-only codepath, as it doesn't support\n  // dependent types yet.\n  bool isDependenceAllowed() const {\n    return LangOpts.CPlusPlus || LangOpts.RecoveryAST;\n  }\n\n  const NoSanitizeList &getNoSanitizeList() const { return *NoSanitizeL; }\n\n  const XRayFunctionFilter &getXRayFilter() const {\n    return *XRayFilter;\n  }\n\n  const ProfileList &getProfileList() const { return *ProfList; }\n\n  DiagnosticsEngine &getDiagnostics() const;\n\n  FullSourceLoc getFullLoc(SourceLocation Loc) const {\n    return FullSourceLoc(Loc,SourceMgr);\n  }\n\n  /// Return the C++ ABI kind that should be used. The C++ ABI can be overriden\n  /// at compile time with `-fc++-abi=`. If this is not provided, we instead use\n  /// the default ABI set by the target.\n  TargetCXXABI::Kind getCXXABIKind() const;\n\n  /// All comments in this translation unit.\n  RawCommentList Comments;\n\n  /// True if comments are already loaded from ExternalASTSource.\n  mutable bool CommentsLoaded = false;\n\n  /// Mapping from declaration to directly attached comment.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const RawComment *> DeclRawComments;\n\n  /// Mapping from canonical declaration to the first redeclaration in chain\n  /// that has a comment attached.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const Decl *> RedeclChainComments;\n\n  /// Keeps track of redeclaration chains that don't have any comment attached.\n  /// Mapping from canonical declaration to redeclaration chain that has no\n  /// comments attached to any redeclaration. Specifically it's mapping to\n  /// the last redeclaration we've checked.\n  ///\n  /// Shall not contain declarations that have comments attached to any\n  /// redeclaration in their chain.\n  mutable llvm::DenseMap<const Decl *, const Decl *> CommentlessRedeclChains;\n\n  /// Mapping from declarations to parsed comments attached to any\n  /// redeclaration.\n  mutable llvm::DenseMap<const Decl *, comments::FullComment *> ParsedComments;\n\n  /// Attaches \\p Comment to \\p OriginalD and to its redeclaration chain\n  /// and removes the redeclaration chain from the set of commentless chains.\n  ///\n  /// Don't do anything if a comment has already been attached to \\p OriginalD\n  /// or its redeclaration chain.\n  void cacheRawCommentForDecl(const Decl &OriginalD,\n                              const RawComment &Comment) const;\n\n  /// \\returns searches \\p CommentsInFile for doc comment for \\p D.\n  ///\n  /// \\p RepresentativeLocForDecl is used as a location for searching doc\n  /// comments. \\p CommentsInFile is a mapping offset -> comment of files in the\n  /// same file where \\p RepresentativeLocForDecl is.\n  RawComment *getRawCommentForDeclNoCacheImpl(\n      const Decl *D, const SourceLocation RepresentativeLocForDecl,\n      const std::map<unsigned, RawComment *> &CommentsInFile) const;\n\n  /// Return the documentation comment attached to a given declaration,\n  /// without looking into cache.\n  RawComment *getRawCommentForDeclNoCache(const Decl *D) const;\n\npublic:\n  void addComment(const RawComment &RC);\n\n  /// Return the documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param OriginalDecl if not nullptr, is set to declaration AST node that\n  /// had the comment, if the comment we found comes from a redeclaration.\n  const RawComment *\n  getRawCommentForAnyRedecl(const Decl *D,\n                            const Decl **OriginalDecl = nullptr) const;\n\n  /// Searches existing comments for doc comments that should be attached to \\p\n  /// Decls. If any doc comment is found, it is parsed.\n  ///\n  /// Requirement: All \\p Decls are in the same file.\n  ///\n  /// If the last comment in the file is already attached we assume\n  /// there are not comments left to be attached to \\p Decls.\n  void attachCommentsToJustParsedDecls(ArrayRef<Decl *> Decls,\n                                       const Preprocessor *PP);\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param PP the Preprocessor used with this TU.  Could be nullptr if\n  /// preprocessor is not available.\n  comments::FullComment *getCommentForDecl(const Decl *D,\n                                           const Preprocessor *PP) const;\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached. Does not look at any\n  /// redeclarations of the declaration.\n  comments::FullComment *getLocalCommentForDeclUncached(const Decl *D) const;\n\n  comments::FullComment *cloneFullComment(comments::FullComment *FC,\n                                         const Decl *D) const;\n\nprivate:\n  mutable comments::CommandTraits CommentCommandTraits;\n\n  /// Iterator that visits import declarations.\n  class import_iterator {\n    ImportDecl *Import = nullptr;\n\n  public:\n    using value_type = ImportDecl *;\n    using reference = ImportDecl *;\n    using pointer = ImportDecl *;\n    using difference_type = int;\n    using iterator_category = std::forward_iterator_tag;\n\n    import_iterator() = default;\n    explicit import_iterator(ImportDecl *Import) : Import(Import) {}\n\n    reference operator*() const { return Import; }\n    pointer operator->() const { return Import; }\n\n    import_iterator &operator++() {\n      Import = ASTContext::getNextLocalImport(Import);\n      return *this;\n    }\n\n    import_iterator operator++(int) {\n      import_iterator Other(*this);\n      ++(*this);\n      return Other;\n    }\n\n    friend bool operator==(import_iterator X, import_iterator Y) {\n      return X.Import == Y.Import;\n    }\n\n    friend bool operator!=(import_iterator X, import_iterator Y) {\n      return X.Import != Y.Import;\n    }\n  };\n\npublic:\n  comments::CommandTraits &getCommentCommandTraits() const {\n    return CommentCommandTraits;\n  }\n\n  /// Retrieve the attributes for the given declaration.\n  AttrVec& getDeclAttrs(const Decl *D);\n\n  /// Erase the attributes corresponding to the given declaration.\n  void eraseDeclAttrs(const Decl *D);\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  // FIXME: Remove ?\n  MemberSpecializationInfo *getInstantiatedFromStaticDataMember(\n                                                           const VarDecl *Var);\n\n  /// Note that the static data member \\p Inst is an instantiation of\n  /// the static data member template \\p Tmpl of a class template.\n  void setInstantiatedFromStaticDataMember(VarDecl *Inst, VarDecl *Tmpl,\n                                           TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  TemplateOrSpecializationInfo\n  getTemplateOrSpecializationInfo(const VarDecl *Var);\n\n  void setTemplateOrSpecializationInfo(VarDecl *Inst,\n                                       TemplateOrSpecializationInfo TSI);\n\n  /// If the given using decl \\p Inst is an instantiation of\n  /// another (possibly unresolved) using decl, return it.\n  NamedDecl *getInstantiatedFromUsingDecl(NamedDecl *Inst);\n\n  /// Remember that the using decl \\p Inst is an instantiation\n  /// of the using decl \\p Pattern of a class template.\n  void setInstantiatedFromUsingDecl(NamedDecl *Inst, NamedDecl *Pattern);\n\n  /// If the given using-enum decl \\p Inst is an instantiation of\n  /// another using-enum decl, return it.\n  UsingEnumDecl *getInstantiatedFromUsingEnumDecl(UsingEnumDecl *Inst);\n\n  /// Remember that the using enum decl \\p Inst is an instantiation\n  /// of the using enum decl \\p Pattern of a class template.\n  void setInstantiatedFromUsingEnumDecl(UsingEnumDecl *Inst,\n                                        UsingEnumDecl *Pattern);\n\n  UsingShadowDecl *getInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst);\n  void setInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst,\n                                          UsingShadowDecl *Pattern);\n\n  FieldDecl *getInstantiatedFromUnnamedFieldDecl(FieldDecl *Field);\n\n  void setInstantiatedFromUnnamedFieldDecl(FieldDecl *Inst, FieldDecl *Tmpl);\n\n  // Access to the set of methods overridden by the given C++ method.\n  using overridden_cxx_method_iterator = CXXMethodVector::const_iterator;\n  overridden_cxx_method_iterator\n  overridden_methods_begin(const CXXMethodDecl *Method) const;\n\n  overridden_cxx_method_iterator\n  overridden_methods_end(const CXXMethodDecl *Method) const;\n\n  unsigned overridden_methods_size(const CXXMethodDecl *Method) const;\n\n  using overridden_method_range =\n      llvm::iterator_range<overridden_cxx_method_iterator>;\n\n  overridden_method_range overridden_methods(const CXXMethodDecl *Method) const;\n\n  /// Note that the given C++ \\p Method overrides the given \\p\n  /// Overridden method.\n  void addOverriddenMethod(const CXXMethodDecl *Method,\n                           const CXXMethodDecl *Overridden);\n\n  /// Return C++ or ObjC overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                        const NamedDecl *Method,\n                        SmallVectorImpl<const NamedDecl *> &Overridden) const;\n\n  /// Notify the AST context that a new import declaration has been\n  /// parsed or implicitly created within this translation unit.\n  void addedLocalImportDecl(ImportDecl *Import);\n\n  static ImportDecl *getNextLocalImport(ImportDecl *Import) {\n    return Import->getNextLocalImport();\n  }\n\n  using import_range = llvm::iterator_range<import_iterator>;\n\n  import_range local_imports() const {\n    return import_range(import_iterator(FirstLocalImport), import_iterator());\n  }\n\n  Decl *getPrimaryMergedDecl(Decl *D) {\n    Decl *Result = MergedDecls.lookup(D);\n    return Result ? Result : D;\n  }\n  void setPrimaryMergedDecl(Decl *D, Decl *Primary) {\n    MergedDecls[D] = Primary;\n  }\n\n  /// Note that the definition \\p ND has been merged into module \\p M,\n  /// and should be visible whenever \\p M is visible.\n  void mergeDefinitionIntoModule(NamedDecl *ND, Module *M,\n                                 bool NotifyListeners = true);\n\n  /// Clean up the merged definition list. Call this if you might have\n  /// added duplicates into the list.\n  void deduplicateMergedDefinitonsFor(NamedDecl *ND);\n\n  /// Get the additional modules in which the definition \\p Def has\n  /// been merged.\n  ArrayRef<Module*> getModulesWithMergedDefinition(const NamedDecl *Def);\n\n  /// Add a declaration to the list of declarations that are initialized\n  /// for a module. This will typically be a global variable (with internal\n  /// linkage) that runs module initializers, such as the iostream initializer,\n  /// or an ImportDecl nominating another module that has initializers.\n  void addModuleInitializer(Module *M, Decl *Init);\n\n  void addLazyModuleInitializers(Module *M, ArrayRef<uint32_t> IDs);\n\n  /// Get the initializations to perform when importing a module, if any.\n  ArrayRef<Decl*> getModuleInitializers(Module *M);\n\n  /// Set the (C++20) module we are building.\n  void setCurrentNamedModule(Module *M);\n\n  /// Get module under construction, nullptr if this is not a C++20 module.\n  Module *getCurrentNamedModule() const { return CurrentCXXNamedModule; }\n\n  TranslationUnitDecl *getTranslationUnitDecl() const {\n    return TUDecl->getMostRecentDecl();\n  }\n  void addTranslationUnitDecl() {\n    assert(!TUDecl || TUKind == TU_Incremental);\n    TranslationUnitDecl *NewTUDecl = TranslationUnitDecl::Create(*this);\n    if (TraversalScope.empty() || TraversalScope.back() == TUDecl)\n      TraversalScope = {NewTUDecl};\n    if (TUDecl)\n      NewTUDecl->setPreviousDecl(TUDecl);\n    TUDecl = NewTUDecl;\n  }\n\n  ExternCContextDecl *getExternCContextDecl() const;\n  BuiltinTemplateDecl *getMakeIntegerSeqDecl() const;\n  BuiltinTemplateDecl *getTypePackElementDecl() const;\n\n  // Builtin Types.\n  CanQualType VoidTy;\n  CanQualType BoolTy;\n  CanQualType CharTy;\n  CanQualType WCharTy;  // [C++ 3.9.1p5].\n  CanQualType WideCharTy; // Same as WCharTy in C++, integer type in C99.\n  CanQualType WIntTy;   // [C99 7.24.1], integer type unchanged by default promotions.\n  CanQualType Char8Ty;  // [C++20 proposal]\n  CanQualType Char16Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType Char32Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType SignedCharTy, ShortTy, IntTy, LongTy, LongLongTy, Int128Ty;\n  CanQualType UnsignedCharTy, UnsignedShortTy, UnsignedIntTy, UnsignedLongTy;\n  CanQualType UnsignedLongLongTy, UnsignedInt128Ty;\n  CanQualType FloatTy, DoubleTy, LongDoubleTy, Float128Ty, Ibm128Ty;\n  CanQualType ShortAccumTy, AccumTy,\n      LongAccumTy;  // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n  CanQualType UnsignedShortAccumTy, UnsignedAccumTy, UnsignedLongAccumTy;\n  CanQualType ShortFractTy, FractTy, LongFractTy;\n  CanQualType UnsignedShortFractTy, UnsignedFractTy, UnsignedLongFractTy;\n  CanQualType SatShortAccumTy, SatAccumTy, SatLongAccumTy;\n  CanQualType SatUnsignedShortAccumTy, SatUnsignedAccumTy,\n      SatUnsignedLongAccumTy;\n  CanQualType SatShortFractTy, SatFractTy, SatLongFractTy;\n  CanQualType SatUnsignedShortFractTy, SatUnsignedFractTy,\n      SatUnsignedLongFractTy;\n  CanQualType HalfTy; // [OpenCL 6.1.1.1], ARM NEON\n  CanQualType BFloat16Ty;\n  CanQualType Float16Ty; // C11 extension ISO/IEC TS 18661-3\n  CanQualType VoidPtrTy, NullPtrTy;\n  CanQualType DependentTy, OverloadTy, BoundMemberTy, UnknownAnyTy;\n  CanQualType BuiltinFnTy;\n  CanQualType PseudoObjectTy, ARCUnbridgedCastTy;\n  CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;\n  CanQualType ObjCBuiltinBoolTy;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;\n  CanQualType OCLQueueTy, OCLReserveIDTy;\n  CanQualType IncompleteMatrixIdxTy;\n  CanQualType OMPArraySectionTy, OMPArrayShapingTy, OMPIteratorTy;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/RISCVVTypes.def\"\n#define WASM_TYPE(Name, Id, SingletonId) CanQualType SingletonId;\n#include \"clang/Basic/WebAssemblyReferenceTypes.def\"\n\n  // Types for deductions in C++0x [stmt.ranged]'s desugaring. Built on demand.\n  mutable QualType AutoDeductTy;     // Deduction against 'auto'.\n  mutable QualType AutoRRefDeductTy; // Deduction against 'auto &&'.\n\n  // Decl used to help define __builtin_va_list for some targets.\n  // The decl is built when constructing 'BuiltinVaListDecl'.\n  mutable Decl *VaListTagDecl = nullptr;\n\n  // Implicitly-declared type 'struct _GUID'.\n  mutable TagDecl *MSGuidTagDecl = nullptr;\n\n  /// Keep track of CUDA/HIP device-side variables ODR-used by host code.\n  llvm::DenseSet<const VarDecl *> CUDADeviceVarODRUsedByHost;\n\n  /// Keep track of CUDA/HIP external kernels or device variables ODR-used by\n  /// host code.\n  llvm::DenseSet<const ValueDecl *> CUDAExternalDeviceDeclODRUsedByHost;\n\n  ASTContext(LangOptions &LOpts, SourceManager &SM, IdentifierTable &idents,\n             SelectorTable &sels, Builtin::Context &builtins,\n             TranslationUnitKind TUKind);\n  ASTContext(const ASTContext &) = delete;\n  ASTContext &operator=(const ASTContext &) = delete;\n  ~ASTContext();\n\n  /// Attach an external AST source to the AST context.\n  ///\n  /// The external AST source provides the ability to load parts of\n  /// the abstract syntax tree as needed from some external storage,\n  /// e.g., a precompiled header.\n  void setExternalSource(IntrusiveRefCntPtr<ExternalASTSource> Source);\n\n  /// Retrieve a pointer to the external AST source associated\n  /// with this AST context, if any.\n  ExternalASTSource *getExternalSource() const {\n    return ExternalSource.get();\n  }\n\n  /// Attach an AST mutation listener to the AST context.\n  ///\n  /// The AST mutation listener provides the ability to track modifications to\n  /// the abstract syntax tree entities committed after they were initially\n  /// created.\n  void setASTMutationListener(ASTMutationListener *Listener) {\n    this->Listener = Listener;\n  }\n\n  /// Retrieve a pointer to the AST mutation listener associated\n  /// with this AST context, if any.\n  ASTMutationListener *getASTMutationListener() const { return Listener; }\n\n  void PrintStats() const;\n  const SmallVectorImpl<Type *>& getTypes() const { return Types; }\n\n  BuiltinTemplateDecl *buildBuiltinTemplateDecl(BuiltinTemplateKind BTK,\n                                                const IdentifierInfo *II) const;\n\n  /// Create a new implicit TU-level CXXRecordDecl or RecordDecl\n  /// declaration.\n  RecordDecl *buildImplicitRecord(StringRef Name,\n                                  RecordDecl::TagKind TK = TTK_Struct) const;\n\n  /// Create a new implicit TU-level typedef declaration.\n  TypedefDecl *buildImplicitTypedef(QualType T, StringRef Name) const;\n\n  /// Retrieve the declaration for the 128-bit signed integer type.\n  TypedefDecl *getInt128Decl() const;\n\n  /// Retrieve the declaration for the 128-bit unsigned integer type.\n  TypedefDecl *getUInt128Decl() const;\n\n  //===--------------------------------------------------------------------===//\n  //                           Type Constructors\n  //===--------------------------------------------------------------------===//\n\nprivate:\n  /// Return a type with extended qualifiers.\n  QualType getExtQualType(const Type *Base, Qualifiers Quals) const;\n\n  QualType getTypeDeclTypeSlow(const TypeDecl *Decl) const;\n\n  QualType getPipeType(QualType T, bool ReadOnly) const;\n\npublic:\n  /// Return the uniqued reference to the type for an address space\n  /// qualified type with the specified type and address space.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the address\n  /// space. If T already has an address space specifier, it is silently\n  /// replaced.\n  QualType getAddrSpaceQualType(QualType T, LangAS AddressSpace) const;\n\n  /// Remove any existing address space on the type and returns the type\n  /// with qualifiers intact (or that's the idea anyway)\n  ///\n  /// The return type should be T with all prior qualifiers minus the address\n  /// space.\n  QualType removeAddrSpaceQualType(QualType T) const;\n\n  /// Apply Objective-C protocol qualifiers to the given type.\n  /// \\param allowOnPointerType specifies if we can apply protocol\n  /// qualifiers on ObjCObjectPointerType. It can be set to true when\n  /// constructing the canonical type of a Objective-C type parameter.\n  QualType applyObjCProtocolQualifiers(QualType type,\n      ArrayRef<ObjCProtocolDecl *> protocols, bool &hasError,\n      bool allowOnPointerType = false) const;\n\n  /// Return the uniqued reference to the type for an Objective-C\n  /// gc-qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the gc\n  /// attribute.\n  QualType getObjCGCQualType(QualType T, Qualifiers::GC gcAttr) const;\n\n  /// Remove the existing address space on the type if it is a pointer size\n  /// address space and return the type with qualifiers intact.\n  QualType removePtrSizeAddrSpace(QualType T) const;\n\n  /// Return the uniqued reference to the type for a \\c restrict\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c restrict.\n  QualType getRestrictType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  /// Return the uniqued reference to the type for a \\c volatile\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c volatile.\n  QualType getVolatileType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Return the uniqued reference to the type for a \\c const\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and \\c const.\n  ///\n  /// It can be reasonably expected that this will always be equivalent to\n  /// calling T.withConst().\n  QualType getConstType(QualType T) const { return T.withConst(); }\n\n  /// Change the ExtInfo on a function type.\n  const FunctionType *adjustFunctionType(const FunctionType *Fn,\n                                         FunctionType::ExtInfo EInfo);\n\n  /// Adjust the given function result type.\n  CanQualType getCanonicalFunctionResultType(QualType ResultType) const;\n\n  /// Change the result type of a function type once it is deduced.\n  void adjustDeducedFunctionResultType(FunctionDecl *FD, QualType ResultType);\n\n  /// Get a function type and produce the equivalent function type with the\n  /// specified exception specification. Type sugar that can be present on a\n  /// declaration of a function with an exception specification is permitted\n  /// and preserved. Other type sugar (for instance, typedefs) is not.\n  QualType getFunctionTypeWithExceptionSpec(\n      QualType Orig, const FunctionProtoType::ExceptionSpecInfo &ESI) const;\n\n  /// Determine whether two function types are the same, ignoring\n  /// exception specifications in cases where they're part of the type.\n  bool hasSameFunctionTypeIgnoringExceptionSpec(QualType T, QualType U) const;\n\n  /// Change the exception specification on a function once it is\n  /// delay-parsed, instantiated, or computed.\n  void adjustExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI,\n                           bool AsWritten = false);\n\n  /// Get a function type and produce the equivalent function type where\n  /// pointer size address spaces in the return type and parameter tyeps are\n  /// replaced with the default address space.\n  QualType getFunctionTypeWithoutPtrSizes(QualType T);\n\n  /// Determine whether two function types are the same, ignoring pointer sizes\n  /// in the return type and parameter types.\n  bool hasSameFunctionTypeIgnoringPtrSizes(QualType T, QualType U);\n\n  /// Return the uniqued reference to the type for a complex\n  /// number with the specified element type.\n  QualType getComplexType(QualType T) const;\n  CanQualType getComplexType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getComplexType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the type for a pointer to\n  /// the specified type.\n  QualType getPointerType(QualType T) const;\n  CanQualType getPointerType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getPointerType((QualType) T));\n  }\n\n  /// Return the uniqued reference to a type adjusted from the original\n  /// type to a new type.\n  QualType getAdjustedType(QualType Orig, QualType New) const;\n  CanQualType getAdjustedType(CanQualType Orig, CanQualType New) const {\n    return CanQualType::CreateUnsafe(\n        getAdjustedType((QualType)Orig, (QualType)New));\n  }\n\n  /// Return the uniqued reference to the decayed version of the given\n  /// type.  Can only be called on array and function types which decay to\n  /// pointer types.\n  QualType getDecayedType(QualType T) const;\n  CanQualType getDecayedType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getDecayedType((QualType) T));\n  }\n  /// Return the uniqued reference to a specified decay from the original\n  /// type to the decayed type.\n  QualType getDecayedType(QualType Orig, QualType Decayed) const;\n\n  /// Return the uniqued reference to the atomic type for the specified\n  /// type.\n  QualType getAtomicType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a block of the\n  /// specified type.\n  QualType getBlockPointerType(QualType T) const;\n\n  /// Gets the struct used to keep track of the descriptor for pointer to\n  /// blocks.\n  QualType getBlockDescriptorType() const;\n\n  /// Return a read_only pipe type for the specified type.\n  QualType getReadPipeType(QualType T) const;\n\n  /// Return a write_only pipe type for the specified type.\n  QualType getWritePipeType(QualType T) const;\n\n  /// Return a bit-precise integer type with the specified signedness and bit\n  /// count.\n  QualType getBitIntType(bool Unsigned, unsigned NumBits) const;\n\n  /// Return a dependent bit-precise integer type with the specified signedness\n  /// and bit count.\n  QualType getDependentBitIntType(bool Unsigned, Expr *BitsExpr) const;\n\n  /// Gets the struct used to keep track of the extended descriptor for\n  /// pointer to blocks.\n  QualType getBlockDescriptorExtendedType() const;\n\n  /// Map an AST Type to an OpenCLTypeKind enum value.\n  OpenCLTypeKind getOpenCLTypeKind(const Type *T) const;\n\n  /// Get address space for OpenCL type.\n  LangAS getOpenCLTypeAddrSpace(const Type *T) const;\n\n  /// Returns default address space based on OpenCL version and enabled features\n  inline LangAS getDefaultOpenCLPointeeAddrSpace() {\n    return LangOpts.OpenCLGenericAddressSpace ? LangAS::opencl_generic\n                                              : LangAS::opencl_private;\n  }\n\n  void setcudaConfigureCallDecl(FunctionDecl *FD) {\n    cudaConfigureCallDecl = FD;\n  }\n\n  FunctionDecl *getcudaConfigureCallDecl() {\n    return cudaConfigureCallDecl;\n  }\n\n  /// Returns true iff we need copy/dispose helpers for the given type.\n  bool BlockRequiresCopying(QualType Ty, const VarDecl *D);\n\n  /// Returns true, if given type has a known lifetime. HasByrefExtendedLayout\n  /// is set to false in this case. If HasByrefExtendedLayout returns true,\n  /// byref variable has extended lifetime.\n  bool getByrefLifetime(QualType Ty,\n                        Qualifiers::ObjCLifetime &Lifetime,\n                        bool &HasByrefExtendedLayout) const;\n\n  /// Return the uniqued reference to the type for an lvalue reference\n  /// to the specified type.\n  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true)\n    const;\n\n  /// Return the uniqued reference to the type for an rvalue reference\n  /// to the specified type.\n  QualType getRValueReferenceType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a member pointer to\n  /// the specified type in the specified class.\n  ///\n  /// The class \\p Cls is a \\c Type because it could be a dependent name.\n  QualType getMemberPointerType(QualType T, const Type *Cls) const;\n\n  /// Return a non-unique reference to the type for a variable array of\n  /// the specified element type.\n  QualType getVariableArrayType(QualType EltTy, Expr *NumElts,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals,\n                                SourceRange Brackets) const;\n\n  /// Return a non-unique reference to the type for a dependently-sized\n  /// array of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedArrayType(QualType EltTy, Expr *NumElts,\n                                      ArrayType::ArraySizeModifier ASM,\n                                      unsigned IndexTypeQuals,\n                                      SourceRange Brackets) const;\n\n  /// Return a unique reference to the type for an incomplete array of\n  /// the specified element type.\n  QualType getIncompleteArrayType(QualType EltTy,\n                                  ArrayType::ArraySizeModifier ASM,\n                                  unsigned IndexTypeQuals) const;\n\n  /// Return the unique reference to the type for a constant array of\n  /// the specified element type.\n  QualType getConstantArrayType(QualType EltTy, const llvm::APInt &ArySize,\n                                const Expr *SizeExpr,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals) const;\n\n  /// Return a type for a constant array for a string literal of the\n  /// specified element type and length.\n  QualType getStringLiteralArrayType(QualType EltTy, unsigned Length) const;\n\n  /// Returns a vla type where known sizes are replaced with [*].\n  QualType getVariableArrayDecayedType(QualType Ty) const;\n\n  // Convenience struct to return information about a builtin vector type.\n  struct BuiltinVectorTypeInfo {\n    QualType ElementType;\n    llvm::ElementCount EC;\n    unsigned NumVectors;\n    BuiltinVectorTypeInfo(QualType ElementType, llvm::ElementCount EC,\n                          unsigned NumVectors)\n        : ElementType(ElementType), EC(EC), NumVectors(NumVectors) {}\n  };\n\n  /// Returns the element type, element count and number of vectors\n  /// (in case of tuple) for a builtin vector type.\n  BuiltinVectorTypeInfo\n  getBuiltinVectorTypeInfo(const BuiltinType *VecTy) const;\n\n  /// Return the unique reference to a scalable vector type of the specified\n  /// element type and scalable number of elements.\n  /// For RISC-V, number of fields is also provided when it fetching for\n  /// tuple type.\n  ///\n  /// \\pre \\p EltTy must be a built-in type.\n  QualType getScalableVectorType(QualType EltTy, unsigned NumElts,\n                                 unsigned NumFields = 1) const;\n\n  /// Return a WebAssembly externref type.\n  QualType getWebAssemblyExternrefType() const;\n\n  /// Return the unique reference to a vector type of the specified\n  /// element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getVectorType(QualType VectorType, unsigned NumElts,\n                         VectorType::VectorKind VecKind) const;\n  /// Return the unique reference to the type for a dependently sized vector of\n  /// the specified element type.\n  QualType getDependentVectorType(QualType VectorType, Expr *SizeExpr,\n                                  SourceLocation AttrLoc,\n                                  VectorType::VectorKind VecKind) const;\n\n  /// Return the unique reference to an extended vector type\n  /// of the specified element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getExtVectorType(QualType VectorType, unsigned NumElts) const;\n\n  /// \\pre Return a non-unique reference to the type for a dependently-sized\n  /// vector of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedExtVectorType(QualType VectorType,\n                                          Expr *SizeExpr,\n                                          SourceLocation AttrLoc) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  ///\n  /// \\pre \\p ElementType must be a valid matrix element type (see\n  /// MatrixType::isValidElementType).\n  QualType getConstantMatrixType(QualType ElementType, unsigned NumRows,\n                                 unsigned NumColumns) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  QualType getDependentSizedMatrixType(QualType ElementType, Expr *RowExpr,\n                                       Expr *ColumnExpr,\n                                       SourceLocation AttrLoc) const;\n\n  QualType getDependentAddressSpaceType(QualType PointeeType,\n                                        Expr *AddrSpaceExpr,\n                                        SourceLocation AttrLoc) const;\n\n  /// Return a K&R style C function type like 'int()'.\n  QualType getFunctionNoProtoType(QualType ResultTy,\n                                  const FunctionType::ExtInfo &Info) const;\n\n  QualType getFunctionNoProtoType(QualType ResultTy) const {\n    return getFunctionNoProtoType(ResultTy, FunctionType::ExtInfo());\n  }\n\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionType(QualType ResultTy, ArrayRef<QualType> Args,\n                           const FunctionProtoType::ExtProtoInfo &EPI) const {\n    return getFunctionTypeInternal(ResultTy, Args, EPI, false);\n  }\n\n  QualType adjustStringLiteralBaseType(QualType StrLTy) const;\n\nprivate:\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionTypeInternal(QualType ResultTy, ArrayRef<QualType> Args,\n                                   const FunctionProtoType::ExtProtoInfo &EPI,\n                                   bool OnlyWantCanonical) const;\n  QualType\n  getAutoTypeInternal(QualType DeducedType, AutoTypeKeyword Keyword,\n                      bool IsDependent, bool IsPack = false,\n                      ConceptDecl *TypeConstraintConcept = nullptr,\n                      ArrayRef<TemplateArgument> TypeConstraintArgs = {},\n                      bool IsCanon = false) const;\n\npublic:\n  /// Return the unique reference to the type for the specified type\n  /// declaration.\n  QualType getTypeDeclType(const TypeDecl *Decl,\n                           const TypeDecl *PrevDecl = nullptr) const {\n    assert(Decl && \"Passed null for Decl param\");\n    if (Decl->TypeForDecl) return QualType(Decl->TypeForDecl, 0);\n\n    if (PrevDecl) {\n      assert(PrevDecl->TypeForDecl && \"previous decl has no TypeForDecl\");\n      Decl->TypeForDecl = PrevDecl->TypeForDecl;\n      return QualType(PrevDecl->TypeForDecl, 0);\n    }\n\n    return getTypeDeclTypeSlow(Decl);\n  }\n\n  QualType getUsingType(const UsingShadowDecl *Found,\n                        QualType Underlying) const;\n\n  /// Return the unique reference to the type for the specified\n  /// typedef-name decl.\n  QualType getTypedefType(const TypedefNameDecl *Decl,\n                          QualType Underlying = QualType()) const;\n\n  QualType getRecordType(const RecordDecl *Decl) const;\n\n  QualType getEnumType(const EnumDecl *Decl) const;\n\n  QualType\n  getUnresolvedUsingType(const UnresolvedUsingTypenameDecl *Decl) const;\n\n  QualType getInjectedClassNameType(CXXRecordDecl *Decl, QualType TST) const;\n\n  QualType getAttributedType(attr::Kind attrKind, QualType modifiedType,\n                             QualType equivalentType) const;\n\n  QualType getBTFTagAttributedType(const BTFTypeTagAttr *BTFAttr,\n                                   QualType Wrapped);\n\n  QualType\n  getSubstTemplateTypeParmType(QualType Replacement, Decl *AssociatedDecl,\n                               unsigned Index,\n                               std::optional<unsigned> PackIndex) const;\n  QualType getSubstTemplateTypeParmPackType(Decl *AssociatedDecl,\n                                            unsigned Index, bool Final,\n                                            const TemplateArgument &ArgPack);\n\n  QualType\n  getTemplateTypeParmType(unsigned Depth, unsigned Index,\n                          bool ParameterPack,\n                          TemplateTypeParmDecl *ParmDecl = nullptr) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args,\n                                         QualType Canon = QualType()) const;\n\n  QualType\n  getCanonicalTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgumentLoc> Args,\n                                         QualType Canon = QualType()) const;\n\n  TypeSourceInfo *\n  getTemplateSpecializationTypeInfo(TemplateName T, SourceLocation TLoc,\n                                    const TemplateArgumentListInfo &Args,\n                                    QualType Canon = QualType()) const;\n\n  QualType getParenType(QualType NamedType) const;\n\n  QualType getMacroQualifiedType(QualType UnderlyingTy,\n                                 const IdentifierInfo *MacroII) const;\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             NestedNameSpecifier *NNS, QualType NamedType,\n                             TagDecl *OwnedTagDecl = nullptr) const;\n  QualType getDependentNameType(ElaboratedTypeKeyword Keyword,\n                                NestedNameSpecifier *NNS,\n                                const IdentifierInfo *Name,\n                                QualType Canon = QualType()) const;\n\n  QualType getDependentTemplateSpecializationType(\n      ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n      const IdentifierInfo *Name, ArrayRef<TemplateArgumentLoc> Args) const;\n  QualType getDependentTemplateSpecializationType(\n      ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n      const IdentifierInfo *Name, ArrayRef<TemplateArgument> Args) const;\n\n  TemplateArgument getInjectedTemplateArg(NamedDecl *ParamDecl);\n\n  /// Get a template argument list with one argument per template parameter\n  /// in a template parameter list, such as for the injected class name of\n  /// a class template.\n  void getInjectedTemplateArgs(const TemplateParameterList *Params,\n                               SmallVectorImpl<TemplateArgument> &Args);\n\n  /// Form a pack expansion type with the given pattern.\n  /// \\param NumExpansions The number of expansions for the pack, if known.\n  /// \\param ExpectPackInType If \\c false, we should not expect \\p Pattern to\n  ///        contain an unexpanded pack. This only makes sense if the pack\n  ///        expansion is used in a context where the arity is inferred from\n  ///        elsewhere, such as if the pattern contains a placeholder type or\n  ///        if this is the canonical type of another pack expansion type.\n  QualType getPackExpansionType(QualType Pattern,\n                                std::optional<unsigned> NumExpansions,\n                                bool ExpectPackInType = true);\n\n  QualType getObjCInterfaceType(const ObjCInterfaceDecl *Decl,\n                                ObjCInterfaceDecl *PrevDecl = nullptr) const;\n\n  /// Legacy interface: cannot provide type arguments or __kindof.\n  QualType getObjCObjectType(QualType Base,\n                             ObjCProtocolDecl * const *Protocols,\n                             unsigned NumProtocols) const;\n\n  QualType getObjCObjectType(QualType Base,\n                             ArrayRef<QualType> typeArgs,\n                             ArrayRef<ObjCProtocolDecl *> protocols,\n                             bool isKindOf) const;\n\n  QualType getObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                ArrayRef<ObjCProtocolDecl *> protocols) const;\n  void adjustObjCTypeParamBoundType(const ObjCTypeParamDecl *Orig,\n                                    ObjCTypeParamDecl *New) const;\n\n  bool ObjCObjectAdoptsQTypeProtocols(QualType QT, ObjCInterfaceDecl *Decl);\n\n  /// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in\n  /// QT's qualified-id protocol list adopt all protocols in IDecl's list\n  /// of protocols.\n  bool QIdProtocolsAdoptObjCObjectProtocols(QualType QT,\n                                            ObjCInterfaceDecl *IDecl);\n\n  /// Return a ObjCObjectPointerType type for the given ObjCObjectType.\n  QualType getObjCObjectPointerType(QualType OIT) const;\n\n  /// C2x feature and GCC extension.\n  QualType getTypeOfExprType(Expr *E, TypeOfKind Kind) const;\n  QualType getTypeOfType(QualType QT, TypeOfKind Kind) const;\n\n  QualType getReferenceQualifiedType(const Expr *e) const;\n\n  /// C++11 decltype.\n  QualType getDecltypeType(Expr *e, QualType UnderlyingType) const;\n\n  /// Unary type transforms\n  QualType getUnaryTransformType(QualType BaseType, QualType UnderlyingType,\n                                 UnaryTransformType::UTTKind UKind) const;\n\n  /// C++11 deduced auto type.\n  QualType getAutoType(QualType DeducedType, AutoTypeKeyword Keyword,\n                       bool IsDependent, bool IsPack = false,\n                       ConceptDecl *TypeConstraintConcept = nullptr,\n                       ArrayRef<TemplateArgument> TypeConstraintArgs ={}) const;\n\n  /// C++11 deduction pattern for 'auto' type.\n  QualType getAutoDeductType() const;\n\n  /// C++11 deduction pattern for 'auto &&' type.\n  QualType getAutoRRefDeductType() const;\n\n  /// Remove any type constraints from a template parameter type, for\n  /// equivalence comparison of template parameters.\n  QualType getUnconstrainedType(QualType T) const;\n\n  /// C++17 deduced class template specialization type.\n  QualType getDeducedTemplateSpecializationType(TemplateName Template,\n                                                QualType DeducedType,\n                                                bool IsDependent) const;\n\n  /// Return the unique reference to the type for the specified TagDecl\n  /// (struct/union/class/enum) decl.\n  QualType getTagDeclType(const TagDecl *Decl) const;\n\n  /// Return the unique type for \"size_t\" (C99 7.17), defined in\n  /// <stddef.h>.\n  ///\n  /// The sizeof operator requires this (C99 6.5.3.4p4).\n  CanQualType getSizeType() const;\n\n  /// Return the unique signed counterpart of\n  /// the integer type corresponding to size_t.\n  CanQualType getSignedSizeType() const;\n\n  /// Return the unique type for \"intmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getIntMaxType() const;\n\n  /// Return the unique type for \"uintmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getUIntMaxType() const;\n\n  /// Return the unique wchar_t type available in C++ (and available as\n  /// __wchar_t as a Microsoft extension).\n  QualType getWCharType() const { return WCharTy; }\n\n  /// Return the type of wide characters. In C++, this returns the\n  /// unique wchar_t type. In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWideCharType() const { return WideCharTy; }\n\n  /// Return the type of \"signed wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getSignedWCharType() const;\n\n  /// Return the type of \"unsigned wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getUnsignedWCharType() const;\n\n  /// In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWIntType() const { return WIntTy; }\n\n  /// Return a type compatible with \"intptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getIntPtrType() const;\n\n  /// Return a type compatible with \"uintptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getUIntPtrType() const;\n\n  /// Return the unique type for \"ptrdiff_t\" (C99 7.17) defined in\n  /// <stddef.h>. Pointer - pointer requires this (C99 6.5.6p9).\n  QualType getPointerDiffType() const;\n\n  /// Return the unique unsigned counterpart of \"ptrdiff_t\"\n  /// integer type. The standard (C11 7.21.6.1p7) refers to this type\n  /// in the definition of %tu format specifier.\n  QualType getUnsignedPointerDiffType() const;\n\n  /// Return the unique type for \"pid_t\" defined in\n  /// <sys/types.h>. We need this to compute the correct type for vfork().\n  QualType getProcessIDType() const;\n\n  /// Return the C structure type used to represent constant CFStrings.\n  QualType getCFConstantStringType() const;\n\n  /// Returns the C struct type for objc_super\n  QualType getObjCSuperType() const;\n  void setObjCSuperType(QualType ST) { ObjCSuperType = ST; }\n\n  /// Get the structure type used to representation CFStrings, or NULL\n  /// if it hasn't yet been built.\n  QualType getRawCFConstantStringType() const {\n    if (CFConstantStringTypeDecl)\n      return getTypedefType(CFConstantStringTypeDecl);\n    return QualType();\n  }\n  void setCFConstantStringType(QualType T);\n  TypedefDecl *getCFConstantStringDecl() const;\n  RecordDecl *getCFConstantStringTagDecl() const;\n\n  // This setter/getter represents the ObjC type for an NSConstantString.\n  void setObjCConstantStringInterface(ObjCInterfaceDecl *Decl);\n  QualType getObjCConstantStringInterface() const {\n    return ObjCConstantStringType;\n  }\n\n  QualType getObjCNSStringType() const {\n    return ObjCNSStringType;\n  }\n\n  void setObjCNSStringType(QualType T) {\n    ObjCNSStringType = T;\n  }\n\n  /// Retrieve the type that \\c id has been defined to, which may be\n  /// different from the built-in \\c id if \\c id has been typedef'd.\n  QualType getObjCIdRedefinitionType() const {\n    if (ObjCIdRedefinitionType.isNull())\n      return getObjCIdType();\n    return ObjCIdRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines \\c id.\n  void setObjCIdRedefinitionType(QualType RedefType) {\n    ObjCIdRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that \\c Class has been defined to, which may be\n  /// different from the built-in \\c Class if \\c Class has been typedef'd.\n  QualType getObjCClassRedefinitionType() const {\n    if (ObjCClassRedefinitionType.isNull())\n      return getObjCClassType();\n    return ObjCClassRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCClassRedefinitionType(QualType RedefType) {\n    ObjCClassRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that 'SEL' has been defined to, which may be\n  /// different from the built-in 'SEL' if 'SEL' has been typedef'd.\n  QualType getObjCSelRedefinitionType() const {\n    if (ObjCSelRedefinitionType.isNull())\n      return getObjCSelType();\n    return ObjCSelRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCSelRedefinitionType(QualType RedefType) {\n    ObjCSelRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the identifier 'NSObject'.\n  IdentifierInfo *getNSObjectName() const {\n    if (!NSObjectName) {\n      NSObjectName = &Idents.get(\"NSObject\");\n    }\n\n    return NSObjectName;\n  }\n\n  /// Retrieve the identifier 'NSCopying'.\n  IdentifierInfo *getNSCopyingName() {\n    if (!NSCopyingName) {\n      NSCopyingName = &Idents.get(\"NSCopying\");\n    }\n\n    return NSCopyingName;\n  }\n\n  CanQualType getNSUIntegerType() const;\n\n  CanQualType getNSIntegerType() const;\n\n  /// Retrieve the identifier 'bool'.\n  IdentifierInfo *getBoolName() const {\n    if (!BoolName)\n      BoolName = &Idents.get(\"bool\");\n    return BoolName;\n  }\n\n  IdentifierInfo *getMakeIntegerSeqName() const {\n    if (!MakeIntegerSeqName)\n      MakeIntegerSeqName = &Idents.get(\"__make_integer_seq\");\n    return MakeIntegerSeqName;\n  }\n\n  IdentifierInfo *getTypePackElementName() const {\n    if (!TypePackElementName)\n      TypePackElementName = &Idents.get(\"__type_pack_element\");\n    return TypePackElementName;\n  }\n\n  /// Retrieve the Objective-C \"instancetype\" type, if already known;\n  /// otherwise, returns a NULL type;\n  QualType getObjCInstanceType() {\n    return getTypeDeclType(getObjCInstanceTypeDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the Objective-C\n  /// \"instancetype\" type.\n  TypedefDecl *getObjCInstanceTypeDecl();\n\n  /// Set the type for the C FILE type.\n  void setFILEDecl(TypeDecl *FILEDecl) { this->FILEDecl = FILEDecl; }\n\n  /// Retrieve the C FILE type.\n  QualType getFILEType() const {\n    if (FILEDecl)\n      return getTypeDeclType(FILEDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C jmp_buf type.\n  void setjmp_bufDecl(TypeDecl *jmp_bufDecl) {\n    this->jmp_bufDecl = jmp_bufDecl;\n  }\n\n  /// Retrieve the C jmp_buf type.\n  QualType getjmp_bufType() const {\n    if (jmp_bufDecl)\n      return getTypeDeclType(jmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C sigjmp_buf type.\n  void setsigjmp_bufDecl(TypeDecl *sigjmp_bufDecl) {\n    this->sigjmp_bufDecl = sigjmp_bufDecl;\n  }\n\n  /// Retrieve the C sigjmp_buf type.\n  QualType getsigjmp_bufType() const {\n    if (sigjmp_bufDecl)\n      return getTypeDeclType(sigjmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C ucontext_t type.\n  void setucontext_tDecl(TypeDecl *ucontext_tDecl) {\n    this->ucontext_tDecl = ucontext_tDecl;\n  }\n\n  /// Retrieve the C ucontext_t type.\n  QualType getucontext_tType() const {\n    if (ucontext_tDecl)\n      return getTypeDeclType(ucontext_tDecl);\n    return QualType();\n  }\n\n  /// The result type of logical operations, '<', '>', '!=', etc.\n  QualType getLogicalOperationType() const {\n    return getLangOpts().CPlusPlus ? BoolTy : IntTy;\n  }\n\n  /// Emit the Objective-CC type encoding for the given type \\p T into\n  /// \\p S.\n  ///\n  /// If \\p Field is specified then record field names are also encoded.\n  void getObjCEncodingForType(QualType T, std::string &S,\n                              const FieldDecl *Field=nullptr,\n                              QualType *NotEncodedT=nullptr) const;\n\n  /// Emit the Objective-C property type encoding for the given\n  /// type \\p T into \\p S.\n  void getObjCEncodingForPropertyType(QualType T, std::string &S) const;\n\n  void getLegacyIntegralTypeEncoding(QualType &t) const;\n\n  /// Put the string version of the type qualifiers \\p QT into \\p S.\n  void getObjCEncodingForTypeQualifier(Decl::ObjCDeclQualifier QT,\n                                       std::string &S) const;\n\n  /// Emit the encoded type for the function \\p Decl into \\p S.\n  ///\n  /// This is in the same format as Objective-C method encodings.\n  ///\n  /// \\returns true if an error occurred (e.g., because one of the parameter\n  /// types is incomplete), false otherwise.\n  std::string getObjCEncodingForFunctionDecl(const FunctionDecl *Decl) const;\n\n  /// Emit the encoded type for the method declaration \\p Decl into\n  /// \\p S.\n  std::string getObjCEncodingForMethodDecl(const ObjCMethodDecl *Decl,\n                                           bool Extended = false) const;\n\n  /// Return the encoded type for this block declaration.\n  std::string getObjCEncodingForBlock(const BlockExpr *blockExpr) const;\n\n  /// getObjCEncodingForPropertyDecl - Return the encoded type for\n  /// this method declaration. If non-NULL, Container must be either\n  /// an ObjCCategoryImplDecl or ObjCImplementationDecl; it should\n  /// only be NULL when getting encodings for protocol properties.\n  std::string getObjCEncodingForPropertyDecl(const ObjCPropertyDecl *PD,\n                                             const Decl *Container) const;\n\n  bool ProtocolCompatibleWithProtocol(ObjCProtocolDecl *lProto,\n                                      ObjCProtocolDecl *rProto) const;\n\n  ObjCPropertyImplDecl *getObjCPropertyImplDeclForPropertyDecl(\n                                                  const ObjCPropertyDecl *PD,\n                                                  const Decl *Container) const;\n\n  /// Return the size of type \\p T for Objective-C encoding purpose,\n  /// in characters.\n  CharUnits getObjCEncodingTypeSize(QualType T) const;\n\n  /// Retrieve the typedef corresponding to the predefined \\c id type\n  /// in Objective-C.\n  TypedefDecl *getObjCIdDecl() const;\n\n  /// Represents the Objective-CC \\c id type.\n  ///\n  /// This is set up lazily, by Sema.  \\c id is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCIdType() const {\n    return getTypeDeclType(getObjCIdDecl());\n  }\n\n  /// Retrieve the typedef corresponding to the predefined 'SEL' type\n  /// in Objective-C.\n  TypedefDecl *getObjCSelDecl() const;\n\n  /// Retrieve the type that corresponds to the predefined Objective-C\n  /// 'SEL' type.\n  QualType getObjCSelType() const {\n    return getTypeDeclType(getObjCSelDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the predefined\n  /// Objective-C 'Class' type.\n  TypedefDecl *getObjCClassDecl() const;\n\n  /// Represents the Objective-C \\c Class type.\n  ///\n  /// This is set up lazily, by Sema.  \\c Class is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCClassType() const {\n    return getTypeDeclType(getObjCClassDecl());\n  }\n\n  /// Retrieve the Objective-C class declaration corresponding to\n  /// the predefined \\c Protocol class.\n  ObjCInterfaceDecl *getObjCProtocolDecl() const;\n\n  /// Retrieve declaration of 'BOOL' typedef\n  TypedefDecl *getBOOLDecl() const {\n    return BOOLDecl;\n  }\n\n  /// Save declaration of 'BOOL' typedef\n  void setBOOLDecl(TypedefDecl *TD) {\n    BOOLDecl = TD;\n  }\n\n  /// type of 'BOOL' type.\n  QualType getBOOLType() const {\n    return getTypeDeclType(getBOOLDecl());\n  }\n\n  /// Retrieve the type of the Objective-C \\c Protocol class.\n  QualType getObjCProtoType() const {\n    return getObjCInterfaceType(getObjCProtocolDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_va_list type.\n  TypedefDecl *getBuiltinVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_va_list type.\n  QualType getBuiltinVaListType() const {\n    return getTypeDeclType(getBuiltinVaListDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __va_list_tag type used to help define the \\c __builtin_va_list type\n  /// for some targets.\n  Decl *getVaListTagDecl() const;\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_ms_va_list type.\n  TypedefDecl *getBuiltinMSVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_ms_va_list type.\n  QualType getBuiltinMSVaListType() const {\n    return getTypeDeclType(getBuiltinMSVaListDecl());\n  }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' declaration.\n  TagDecl *getMSGuidTagDecl() const { return MSGuidTagDecl; }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' type.\n  QualType getMSGuidType() const {\n    assert(MSGuidTagDecl && \"asked for GUID type but MS extensions disabled\");\n    return getTagDeclType(MSGuidTagDecl);\n  }\n\n  /// Return whether a declaration to a builtin is allowed to be\n  /// overloaded/redeclared.\n  bool canBuiltinBeRedeclared(const FunctionDecl *) const;\n\n  /// Return a type with additional \\c const, \\c volatile, or\n  /// \\c restrict qualifiers.\n  QualType getCVRQualifiedType(QualType T, unsigned CVR) const {\n    return getQualifiedType(T, Qualifiers::fromCVRMask(CVR));\n  }\n\n  /// Un-split a SplitQualType.\n  QualType getQualifiedType(SplitQualType split) const {\n    return getQualifiedType(split.Ty, split.Quals);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(QualType T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return T.withFastQualifiers(Qs.getFastQualifiers());\n    QualifierCollector Qc(Qs);\n    const Type *Ptr = Qc.strip(T);\n    return getExtQualType(Ptr, Qc);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(const Type *T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return QualType(T, Qs.getFastQualifiers());\n    return getExtQualType(T, Qs);\n  }\n\n  /// Return a type with the given lifetime qualifier.\n  ///\n  /// \\pre Neither type.ObjCLifetime() nor \\p lifetime may be \\c OCL_None.\n  QualType getLifetimeQualifiedType(QualType type,\n                                    Qualifiers::ObjCLifetime lifetime) {\n    assert(type.getObjCLifetime() == Qualifiers::OCL_None);\n    assert(lifetime != Qualifiers::OCL_None);\n\n    Qualifiers qs;\n    qs.addObjCLifetime(lifetime);\n    return getQualifiedType(type, qs);\n  }\n\n  /// getUnqualifiedObjCPointerType - Returns version of\n  /// Objective-C pointer type with lifetime qualifier removed.\n  QualType getUnqualifiedObjCPointerType(QualType type) const {\n    if (!type.getTypePtr()->isObjCObjectPointerType() ||\n        !type.getQualifiers().hasObjCLifetime())\n      return type;\n    Qualifiers Qs = type.getQualifiers();\n    Qs.removeObjCLifetime();\n    return getQualifiedType(type.getUnqualifiedType(), Qs);\n  }\n\n  unsigned char getFixedPointScale(QualType Ty) const;\n  unsigned char getFixedPointIBits(QualType Ty) const;\n  llvm::FixedPointSemantics getFixedPointSemantics(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMax(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMin(QualType Ty) const;\n\n  DeclarationNameInfo getNameForTemplate(TemplateName Name,\n                                         SourceLocation NameLoc) const;\n\n  TemplateName getOverloadedTemplateName(UnresolvedSetIterator Begin,\n                                         UnresolvedSetIterator End) const;\n  TemplateName getAssumedTemplateName(DeclarationName Name) const;\n\n  TemplateName getQualifiedTemplateName(NestedNameSpecifier *NNS,\n                                        bool TemplateKeyword,\n                                        TemplateName Template) const;\n\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        const IdentifierInfo *Name) const;\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        OverloadedOperatorKind Operator) const;\n  TemplateName\n  getSubstTemplateTemplateParm(TemplateName replacement, Decl *AssociatedDecl,\n                               unsigned Index,\n                               std::optional<unsigned> PackIndex) const;\n  TemplateName getSubstTemplateTemplateParmPack(const TemplateArgument &ArgPack,\n                                                Decl *AssociatedDecl,\n                                                unsigned Index,\n                                                bool Final) const;\n\n  enum GetBuiltinTypeError {\n    /// No error\n    GE_None,\n\n    /// Missing a type\n    GE_Missing_type,\n\n    /// Missing a type from <stdio.h>\n    GE_Missing_stdio,\n\n    /// Missing a type from <setjmp.h>\n    GE_Missing_setjmp,\n\n    /// Missing a type from <ucontext.h>\n    GE_Missing_ucontext\n  };\n\n  QualType DecodeTypeStr(const char *&Str, const ASTContext &Context,\n                         ASTContext::GetBuiltinTypeError &Error,\n                         bool &RequireICE, bool AllowTypeModifiers) const;\n\n  /// Return the type for the specified builtin.\n  ///\n  /// If \\p IntegerConstantArgs is non-null, it is filled in with a bitmask of\n  /// arguments to the builtin that are required to be integer constant\n  /// expressions.\n  QualType GetBuiltinType(unsigned ID, GetBuiltinTypeError &Error,\n                          unsigned *IntegerConstantArgs = nullptr) const;\n\n  /// Types and expressions required to build C++2a three-way comparisons\n  /// using operator<=>, including the values return by builtin <=> operators.\n  ComparisonCategories CompCategories;\n\nprivate:\n  CanQualType getFromTargetType(unsigned Type) const;\n  TypeInfo getTypeInfoImpl(const Type *T) const;\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Predicates.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// Return one of the GCNone, Weak or Strong Objective-C garbage\n  /// collection attributes.\n  Qualifiers::GC getObjCGCAttrKind(QualType Ty) const;\n\n  /// Return true if the given vector types are of the same unqualified\n  /// type or if they are equivalent to the same GCC vector type.\n  ///\n  /// \\note This ignores whether they are target-specific (AltiVec or Neon)\n  /// types.\n  bool areCompatibleVectorTypes(QualType FirstVec, QualType SecondVec);\n\n  /// Return true if the given types are an SVE builtin and a VectorType that\n  /// is a fixed-length representation of the SVE builtin for a specific\n  /// vector-length.\n  bool areCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given vector types are lax-compatible SVE vector types,\n  /// false otherwise.\n  bool areLaxCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given types are an RISC-V vector builtin type and a\n  /// VectorType that is a fixed-length representation of the RISC-V vector\n  /// builtin type for a specific vector-length.\n  bool areCompatibleRVVTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given vector types are lax-compatible RISC-V vector\n  /// types as defined by -flax-vector-conversions=, which permits implicit\n  /// conversions between vectors with different number of elements and/or\n  /// incompatible element types, false otherwise.\n  bool areLaxCompatibleRVVTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the type has been explicitly qualified with ObjC ownership.\n  /// A type may be implicitly qualified with ownership under ObjC ARC, and in\n  /// some cases the compiler treats these differently.\n  bool hasDirectOwnershipQualifier(QualType Ty) const;\n\n  /// Return true if this is an \\c NSObject object with its \\c NSObject\n  /// attribute set.\n  static bool isObjCNSObjectType(QualType Ty) {\n    return Ty->isObjCNSObjectType();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Sizing and Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return the APFloat 'semantics' for the specified scalar floating\n  /// point type.\n  const llvm::fltSemantics &getFloatTypeSemantics(QualType T) const;\n\n  /// Get the size and alignment of the specified complete type in bits.\n  TypeInfo getTypeInfo(const Type *T) const;\n  TypeInfo getTypeInfo(QualType T) const { return getTypeInfo(T.getTypePtr()); }\n\n  /// Get default simd alignment of the specified complete type in bits.\n  unsigned getOpenMPDefaultSimdAlign(QualType T) const;\n\n  /// Return the size of the specified (complete) type \\p T, in bits.\n  uint64_t getTypeSize(QualType T) const { return getTypeInfo(T).Width; }\n  uint64_t getTypeSize(const Type *T) const { return getTypeInfo(T).Width; }\n\n  /// Return the size of the character type, in bits.\n  uint64_t getCharWidth() const {\n    return getTypeSize(CharTy);\n  }\n\n  /// Convert a size in bits to a size in characters.\n  CharUnits toCharUnitsFromBits(int64_t BitSize) const;\n\n  /// Convert a size in characters to a size in bits.\n  int64_t toBits(CharUnits CharSize) const;\n\n  /// Return the size of the specified (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeSizeInChars(QualType T) const;\n  CharUnits getTypeSizeInChars(const Type *T) const;\n\n  std::optional<CharUnits> getTypeSizeInCharsIfKnown(QualType Ty) const {\n    if (Ty->isIncompleteType() || Ty->isDependentType())\n      return std::nullopt;\n    return getTypeSizeInChars(Ty);\n  }\n\n  std::optional<CharUnits> getTypeSizeInCharsIfKnown(const Type *Ty) const {\n    return getTypeSizeInCharsIfKnown(QualType(Ty, 0));\n  }\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// bits.\n  unsigned getTypeAlign(QualType T) const { return getTypeInfo(T).Align; }\n  unsigned getTypeAlign(const Type *T) const { return getTypeInfo(T).Align; }\n\n  /// Return the ABI-specified natural alignment of a (complete) type \\p T,\n  /// before alignment adjustments, in bits.\n  ///\n  /// This alignment is curently used only by ARM and AArch64 when passing\n  /// arguments of a composite type.\n  unsigned getTypeUnadjustedAlign(QualType T) const {\n    return getTypeUnadjustedAlign(T.getTypePtr());\n  }\n  unsigned getTypeUnadjustedAlign(const Type *T) const;\n\n  /// Return the alignment of a type, in bits, or 0 if\n  /// the type is incomplete and we cannot determine the alignment (for\n  /// example, from alignment attributes). The returned alignment is the\n  /// Preferred alignment if NeedsPreferredAlignment is true, otherwise is the\n  /// ABI alignment.\n  unsigned getTypeAlignIfKnown(QualType T,\n                               bool NeedsPreferredAlignment = false) const;\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeAlignInChars(QualType T) const;\n  CharUnits getTypeAlignInChars(const Type *T) const;\n\n  /// Return the PreferredAlignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getPreferredTypeAlignInChars(QualType T) const {\n    return toCharUnitsFromBits(getPreferredTypeAlign(T));\n  }\n\n  /// getTypeUnadjustedAlignInChars - Return the ABI-specified alignment of a type,\n  /// in characters, before alignment adjustments. This method does not work on\n  /// incomplete types.\n  CharUnits getTypeUnadjustedAlignInChars(QualType T) const;\n  CharUnits getTypeUnadjustedAlignInChars(const Type *T) const;\n\n  // getTypeInfoDataSizeInChars - Return the size of a type, in chars. If the\n  // type is a record, its data size is returned.\n  TypeInfoChars getTypeInfoDataSizeInChars(QualType T) const;\n\n  TypeInfoChars getTypeInfoInChars(const Type *T) const;\n  TypeInfoChars getTypeInfoInChars(QualType T) const;\n\n  /// Determine if the alignment the type has was required using an\n  /// alignment attribute.\n  bool isAlignmentRequired(const Type *T) const;\n  bool isAlignmentRequired(QualType T) const;\n\n  /// More type predicates useful for type checking/promotion\n  bool isPromotableIntegerType(QualType T) const; // C99 6.3.1.1p2\n\n  /// Return the \"preferred\" alignment of the specified type \\p T for\n  /// the current target, in bits.\n  ///\n  /// This can be different than the ABI alignment in cases where it is\n  /// beneficial for performance or backwards compatibility preserving to\n  /// overalign a data type. (Note: despite the name, the preferred alignment\n  /// is ABI-impacting, and not an optimization.)\n  unsigned getPreferredTypeAlign(QualType T) const {\n    return getPreferredTypeAlign(T.getTypePtr());\n  }\n  unsigned getPreferredTypeAlign(const Type *T) const;\n\n  /// Return the default alignment for __attribute__((aligned)) on\n  /// this target, to be used if no alignment value is specified.\n  unsigned getTargetDefaultAlignForAttributeAligned() const;\n\n  /// Return the alignment in bits that should be given to a\n  /// global variable with type \\p T.\n  unsigned getAlignOfGlobalVar(QualType T) const;\n\n  /// Return the alignment in characters that should be given to a\n  /// global variable with type \\p T.\n  CharUnits getAlignOfGlobalVarInChars(QualType T) const;\n\n  /// Return a conservative estimate of the alignment of the specified\n  /// decl \\p D.\n  ///\n  /// \\pre \\p D must not be a bitfield type, as bitfields do not have a valid\n  /// alignment.\n  ///\n  /// If \\p ForAlignof, references are treated like their underlying type\n  /// and  large arrays don't get any special treatment. If not \\p ForAlignof\n  /// it computes the value expected by CodeGen: references are treated like\n  /// pointers and large arrays get extra alignment.\n  CharUnits getDeclAlign(const Decl *D, bool ForAlignof = false) const;\n\n  /// Return the alignment (in bytes) of the thrown exception object. This is\n  /// only meaningful for targets that allocate C++ exceptions in a system\n  /// runtime, such as those using the Itanium C++ ABI.\n  CharUnits getExnObjectAlignment() const;\n\n  /// Get or compute information about the layout of the specified\n  /// record (struct/union/class) \\p D, which indicates its size and field\n  /// position information.\n  const ASTRecordLayout &getASTRecordLayout(const RecordDecl *D) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C interface.\n  const ASTRecordLayout &getASTObjCInterfaceLayout(const ObjCInterfaceDecl *D)\n    const;\n\n  void DumpRecordLayout(const RecordDecl *RD, raw_ostream &OS,\n                        bool Simple = false) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C implementation.\n  ///\n  /// This may differ from the interface if synthesized ivars are present.\n  const ASTRecordLayout &\n  getASTObjCImplementationLayout(const ObjCImplementationDecl *D) const;\n\n  /// Get our current best idea for the key function of the\n  /// given record decl, or nullptr if there isn't one.\n  ///\n  /// The key function is, according to the Itanium C++ ABI section 5.2.3:\n  ///   ...the first non-pure virtual function that is not inline at the\n  ///   point of class definition.\n  ///\n  /// Other ABIs use the same idea.  However, the ARM C++ ABI ignores\n  /// virtual functions that are defined 'inline', which means that\n  /// the result of this computation can change.\n  const CXXMethodDecl *getCurrentKeyFunction(const CXXRecordDecl *RD);\n\n  /// Observe that the given method cannot be a key function.\n  /// Checks the key-function cache for the method's class and clears it\n  /// if matches the given declaration.\n  ///\n  /// This is used in ABIs where out-of-line definitions marked\n  /// inline are not considered to be key functions.\n  ///\n  /// \\param method should be the declaration from the class definition\n  void setNonKeyFunction(const CXXMethodDecl *method);\n\n  /// Loading virtual member pointers using the virtual inheritance model\n  /// always results in an adjustment using the vbtable even if the index is\n  /// zero.\n  ///\n  /// This is usually OK because the first slot in the vbtable points\n  /// backwards to the top of the MDC.  However, the MDC might be reusing a\n  /// vbptr from an nv-base.  In this case, the first slot in the vbtable\n  /// points to the start of the nv-base which introduced the vbptr and *not*\n  /// the MDC.  Modify the NonVirtualBaseAdjustment to account for this.\n  CharUnits getOffsetOfBaseWithVBPtr(const CXXRecordDecl *RD) const;\n\n  /// Get the offset of a FieldDecl or IndirectFieldDecl, in bits.\n  uint64_t getFieldOffset(const ValueDecl *FD) const;\n\n  /// Get the offset of an ObjCIvarDecl in bits.\n  uint64_t lookupFieldBitOffset(const ObjCInterfaceDecl *OID,\n                                const ObjCImplementationDecl *ID,\n                                const ObjCIvarDecl *Ivar) const;\n\n  /// Find the 'this' offset for the member path in a pointer-to-member\n  /// APValue.\n  CharUnits getMemberPointerPathAdjustment(const APValue &MP) const;\n\n  bool isNearlyEmpty(const CXXRecordDecl *RD) const;\n\n  VTableContextBase *getVTableContext();\n\n  /// If \\p T is null pointer, assume the target in ASTContext.\n  MangleContext *createMangleContext(const TargetInfo *T = nullptr);\n\n  /// Creates a device mangle context to correctly mangle lambdas in a mixed\n  /// architecture compile by setting the lambda mangling number source to the\n  /// DeviceLambdaManglingNumber. Currently this asserts that the TargetInfo\n  /// (from the AuxTargetInfo) is a an itanium target.\n  MangleContext *createDeviceMangleContext(const TargetInfo &T);\n\n  void DeepCollectObjCIvars(const ObjCInterfaceDecl *OI, bool leafClass,\n                            SmallVectorImpl<const ObjCIvarDecl*> &Ivars) const;\n\n  unsigned CountNonClassIvars(const ObjCInterfaceDecl *OI) const;\n  void CollectInheritedProtocols(const Decl *CDecl,\n                          llvm::SmallPtrSet<ObjCProtocolDecl*, 8> &Protocols);\n\n  /// Return true if the specified type has unique object representations\n  /// according to (C++17 [meta.unary.prop]p9)\n  bool\n  hasUniqueObjectRepresentations(QualType Ty,\n                                 bool CheckIfTriviallyCopyable = true) const;\n\n  //===--------------------------------------------------------------------===//\n  //                            Type Operators\n  //===--------------------------------------------------------------------===//\n\n  /// Return the canonical (structural) type corresponding to the\n  /// specified potentially non-canonical type \\p T.\n  ///\n  /// The non-canonical version of a type may have many \"decorated\" versions of\n  /// types.  Decorators can include typedefs, 'typeof' operators, etc. The\n  /// returned type is guaranteed to be free of any of these, allowing two\n  /// canonical types to be compared for exact equality with a simple pointer\n  /// comparison.\n  CanQualType getCanonicalType(QualType T) const {\n    return CanQualType::CreateUnsafe(T.getCanonicalType());\n  }\n\n  const Type *getCanonicalType(const Type *T) const {\n    return T->getCanonicalTypeInternal().getTypePtr();\n  }\n\n  /// Return the canonical parameter type corresponding to the specific\n  /// potentially non-canonical one.\n  ///\n  /// Qualifiers are stripped off, functions are turned into function\n  /// pointers, and arrays decay one level into pointers.\n  CanQualType getCanonicalParamType(QualType T) const;\n\n  /// Determine whether the given types \\p T1 and \\p T2 are equivalent.\n  bool hasSameType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n  bool hasSameType(const Type *T1, const Type *T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n\n  /// Determine whether the given expressions \\p X and \\p Y are equivalent.\n  bool hasSameExpr(const Expr *X, const Expr *Y) const;\n\n  /// Return this type as a completely-unqualified array type,\n  /// capturing the qualifiers in \\p Quals.\n  ///\n  /// This will remove the minimal amount of sugaring from the types, similar\n  /// to the behavior of QualType::getUnqualifiedType().\n  ///\n  /// \\param T is the qualified type, which may be an ArrayType\n  ///\n  /// \\param Quals will receive the full set of qualifiers that were\n  /// applied to the array.\n  ///\n  /// \\returns if this is an array type, the completely unqualified array type\n  /// that corresponds to it. Otherwise, returns T.getUnqualifiedType().\n  QualType getUnqualifiedArrayType(QualType T, Qualifiers &Quals);\n\n  /// Determine whether the given types are equivalent after\n  /// cvr-qualifiers have been removed.\n  bool hasSameUnqualifiedType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1).getTypePtr() ==\n           getCanonicalType(T2).getTypePtr();\n  }\n\n  bool hasSameNullabilityTypeQualifier(QualType SubT, QualType SuperT,\n                                       bool IsParam) const {\n    auto SubTnullability = SubT->getNullability();\n    auto SuperTnullability = SuperT->getNullability();\n    if (SubTnullability.has_value() == SuperTnullability.has_value()) {\n      // Neither has nullability; return true\n      if (!SubTnullability)\n        return true;\n      // Both have nullability qualifier.\n      if (*SubTnullability == *SuperTnullability ||\n          *SubTnullability == NullabilityKind::Unspecified ||\n          *SuperTnullability == NullabilityKind::Unspecified)\n        return true;\n\n      if (IsParam) {\n        // Ok for the superclass method parameter to be \"nonnull\" and the subclass\n        // method parameter to be \"nullable\"\n        return (*SuperTnullability == NullabilityKind::NonNull &&\n                *SubTnullability == NullabilityKind::Nullable);\n      }\n      // For the return type, it's okay for the superclass method to specify\n      // \"nullable\" and the subclass method specify \"nonnull\"\n      return (*SuperTnullability == NullabilityKind::Nullable &&\n              *SubTnullability == NullabilityKind::NonNull);\n    }\n    return true;\n  }\n\n  bool ObjCMethodsAreEqual(const ObjCMethodDecl *MethodDecl,\n                           const ObjCMethodDecl *MethodImp);\n\n  bool UnwrapSimilarTypes(QualType &T1, QualType &T2,\n                          bool AllowPiMismatch = true);\n  void UnwrapSimilarArrayTypes(QualType &T1, QualType &T2,\n                               bool AllowPiMismatch = true);\n\n  /// Determine if two types are similar, according to the C++ rules. That is,\n  /// determine if they are the same other than qualifiers on the initial\n  /// sequence of pointer / pointer-to-member / array (and in Clang, object\n  /// pointer) types and their element types.\n  ///\n  /// Clang offers a number of qualifiers in addition to the C++ qualifiers;\n  /// those qualifiers are also ignored in the 'similarity' check.\n  bool hasSimilarType(QualType T1, QualType T2);\n\n  /// Determine if two types are similar, ignoring only CVR qualifiers.\n  bool hasCvrSimilarType(QualType T1, QualType T2);\n\n  /// Retrieves the \"canonical\" nested name specifier for a\n  /// given nested name specifier.\n  ///\n  /// The canonical nested name specifier is a nested name specifier\n  /// that uniquely identifies a type or namespace within the type\n  /// system. For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   struct S {\n  ///     template<typename T> struct X { typename T* type; };\n  ///   };\n  /// }\n  ///\n  /// template<typename T> struct Y {\n  ///   typename N::S::X<T>::type member;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, the nested-name-specifier for N::S::X<T>:: will be\n  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined\n  /// by declarations in the type system and the canonical type for\n  /// the template type parameter 'T' is template-param-0-0.\n  NestedNameSpecifier *\n  getCanonicalNestedNameSpecifier(NestedNameSpecifier *NNS) const;\n\n  /// Retrieves the default calling convention for the current target.\n  CallingConv getDefaultCallingConvention(bool IsVariadic,\n                                          bool IsCXXMethod,\n                                          bool IsBuiltin = false) const;\n\n  /// Retrieves the \"canonical\" template name that refers to a\n  /// given template.\n  ///\n  /// The canonical template name is the simplest expression that can\n  /// be used to refer to a given template. For most templates, this\n  /// expression is just the template declaration itself. For example,\n  /// the template std::vector can be referred to via a variety of\n  /// names---std::vector, \\::std::vector, vector (if vector is in\n  /// scope), etc.---but all of these names map down to the same\n  /// TemplateDecl, which is used to form the canonical template name.\n  ///\n  /// Dependent template names are more interesting. Here, the\n  /// template name could be something like T::template apply or\n  /// std::allocator<T>::template rebind, where the nested name\n  /// specifier itself is dependent. In this case, the canonical\n  /// template name uses the shortest form of the dependent\n  /// nested-name-specifier, which itself contains all canonical\n  /// types, values, and templates.\n  TemplateName getCanonicalTemplateName(const TemplateName &Name) const;\n\n  /// Determine whether the given template names refer to the same\n  /// template.\n  bool hasSameTemplateName(const TemplateName &X, const TemplateName &Y) const;\n\n  /// Determine whether the two declarations refer to the same entity.\n  bool isSameEntity(const NamedDecl *X, const NamedDecl *Y) const;\n\n  /// Determine whether two template parameter lists are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameTemplateParameterList(const TemplateParameterList *X,\n                                   const TemplateParameterList *Y) const;\n\n  /// Determine whether two template parameters are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameTemplateParameter(const NamedDecl *X, const NamedDecl *Y) const;\n\n  /// Determine whether two 'requires' expressions are similar enough that they\n  /// may be used in re-declarations.\n  ///\n  /// Use of 'requires' isn't mandatory, works with constraints expressed in\n  /// other ways too.\n  bool isSameConstraintExpr(const Expr *XCE, const Expr *YCE) const;\n\n  /// Determine whether two type contraint are similar enough that they could\n  /// used in declarations of the same template.\n  bool isSameTypeConstraint(const TypeConstraint *XTC,\n                            const TypeConstraint *YTC) const;\n\n  /// Determine whether two default template arguments are similar enough\n  /// that they may be used in declarations of the same template.\n  bool isSameDefaultTemplateArgument(const NamedDecl *X,\n                                     const NamedDecl *Y) const;\n\n  /// Retrieve the \"canonical\" template argument.\n  ///\n  /// The canonical template argument is the simplest template argument\n  /// (which may be a type, value, expression, or declaration) that\n  /// expresses the value of the argument.\n  TemplateArgument getCanonicalTemplateArgument(const TemplateArgument &Arg)\n    const;\n\n  /// Type Query functions.  If the type is an instance of the specified class,\n  /// return the Type pointer for the underlying maximally pretty type.  This\n  /// is a member of ASTContext because this may need to do some amount of\n  /// canonicalization, e.g. to move type qualifiers into the element type.\n  const ArrayType *getAsArrayType(QualType T) const;\n  const ConstantArrayType *getAsConstantArrayType(QualType T) const {\n    return dyn_cast_or_null<ConstantArrayType>(getAsArrayType(T));\n  }\n  const VariableArrayType *getAsVariableArrayType(QualType T) const {\n    return dyn_cast_or_null<VariableArrayType>(getAsArrayType(T));\n  }\n  const IncompleteArrayType *getAsIncompleteArrayType(QualType T) const {\n    return dyn_cast_or_null<IncompleteArrayType>(getAsArrayType(T));\n  }\n  const DependentSizedArrayType *getAsDependentSizedArrayType(QualType T)\n    const {\n    return dyn_cast_or_null<DependentSizedArrayType>(getAsArrayType(T));\n  }\n\n  /// Return the innermost element type of an array type.\n  ///\n  /// For example, will return \"int\" for int[m][n]\n  QualType getBaseElementType(const ArrayType *VAT) const;\n\n  /// Return the innermost element type of a type (which needn't\n  /// actually be an array type).\n  QualType getBaseElementType(QualType QT) const;\n\n  /// Return number of constant array elements.\n  uint64_t getConstantArrayElementCount(const ConstantArrayType *CA) const;\n\n  /// Return number of elements initialized in an ArrayInitLoopExpr.\n  uint64_t\n  getArrayInitLoopExprElementCount(const ArrayInitLoopExpr *AILE) const;\n\n  /// Perform adjustment on the parameter type of a function.\n  ///\n  /// This routine adjusts the given parameter type @p T to the actual\n  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],\n  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.\n  QualType getAdjustedParameterType(QualType T) const;\n\n  /// Retrieve the parameter type as adjusted for use in the signature\n  /// of a function, decaying array and function types and removing top-level\n  /// cv-qualifiers.\n  QualType getSignatureParameterType(QualType T) const;\n\n  QualType getExceptionObjectType(QualType T) const;\n\n  /// Return the properly qualified result of decaying the specified\n  /// array type to a pointer.\n  ///\n  /// This operation is non-trivial when handling typedefs etc.  The canonical\n  /// type of \\p T must be an array type, this returns a pointer to a properly\n  /// qualified element of the array.\n  ///\n  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.\n  QualType getArrayDecayedType(QualType T) const;\n\n  /// Return the type that \\p PromotableType will promote to: C99\n  /// 6.3.1.1p2, assuming that \\p PromotableType is a promotable integer type.\n  QualType getPromotedIntegerType(QualType PromotableType) const;\n\n  /// Recurses in pointer/array types until it finds an Objective-C\n  /// retainable type and returns its ownership.\n  Qualifiers::ObjCLifetime getInnerObjCOwnership(QualType T) const;\n\n  /// Whether this is a promotable bitfield reference according\n  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).\n  ///\n  /// \\returns the type this bit-field will promote to, or NULL if no\n  /// promotion occurs.\n  QualType isPromotableBitField(Expr *E) const;\n\n  /// Return the highest ranked integer type, see C99 6.3.1.8p1.\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getIntegerTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of the two specified floating point types,\n  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getFloatingTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of two floating point types as above, but compare equal\n  /// if both types have the same floating-point semantics on the target (i.e.\n  /// long double and double on AArch64 will return 0).\n  int getFloatingTypeSemanticOrder(QualType LHS, QualType RHS) const;\n\n  unsigned getTargetAddressSpace(LangAS AS) const;\n\n  LangAS getLangASForBuiltinAddressSpace(unsigned AS) const;\n\n  /// Get target-dependent integer value for null pointer which is used for\n  /// constant folding.\n  uint64_t getTargetNullPointerValue(QualType QT) const;\n\n  bool addressSpaceMapManglingFor(LangAS AS) const {\n    return AddrSpaceMapMangling || isTargetAddressSpace(AS);\n  }\n\n  // Merges two exception specifications, such that the resulting\n  // exception spec is the union of both. For example, if either\n  // of them can throw something, the result can throw it as well.\n  FunctionProtoType::ExceptionSpecInfo\n  mergeExceptionSpecs(FunctionProtoType::ExceptionSpecInfo ESI1,\n                      FunctionProtoType::ExceptionSpecInfo ESI2,\n                      SmallVectorImpl<QualType> &ExceptionTypeStorage,\n                      bool AcceptDependent);\n\n  // For two \"same\" types, return a type which has\n  // the common sugar between them. If Unqualified is true,\n  // both types need only be the same unqualified type.\n  // The result will drop the qualifiers which do not occur\n  // in both types.\n  QualType getCommonSugaredType(QualType X, QualType Y,\n                                bool Unqualified = false);\n\nprivate:\n  // Helper for integer ordering\n  unsigned getIntegerRank(const Type *T) const;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  //                    Type Compatibility Predicates\n  //===--------------------------------------------------------------------===//\n\n  /// Compatibility predicates used to check assignment expressions.\n  bool typesAreCompatible(QualType T1, QualType T2,\n                          bool CompareUnqualified = false); // C99 6.2.7p1\n\n  bool propertyTypesAreCompatible(QualType, QualType);\n  bool typesAreBlockPointerCompatible(QualType, QualType);\n\n  bool isObjCIdType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCIdType();\n  }\n\n  bool isObjCClassType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCClassType();\n  }\n\n  bool isObjCSelType(QualType T) const {\n    if (const auto *ET = dyn_cast<ElaboratedType>(T))\n      T = ET->getNamedType();\n    return T == getObjCSelType();\n  }\n\n  bool ObjCQualifiedIdTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                         const ObjCObjectPointerType *RHS,\n                                         bool ForCompare);\n\n  bool ObjCQualifiedClassTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                            const ObjCObjectPointerType *RHS);\n\n  // Check the safety of assignment from LHS to RHS\n  bool canAssignObjCInterfaces(const ObjCObjectPointerType *LHSOPT,\n                               const ObjCObjectPointerType *RHSOPT);\n  bool canAssignObjCInterfaces(const ObjCObjectType *LHS,\n                               const ObjCObjectType *RHS);\n  bool canAssignObjCInterfacesInBlockPointer(\n                                          const ObjCObjectPointerType *LHSOPT,\n                                          const ObjCObjectPointerType *RHSOPT,\n                                          bool BlockReturnType);\n  bool areComparableObjCPointerTypes(QualType LHS, QualType RHS);\n  QualType areCommonBaseCompatible(const ObjCObjectPointerType *LHSOPT,\n                                   const ObjCObjectPointerType *RHSOPT);\n  bool canBindObjCObjectType(QualType To, QualType From);\n\n  // Functions for calculating composite types\n  QualType mergeTypes(QualType, QualType, bool OfBlockPointer = false,\n                      bool Unqualified = false, bool BlockReturnType = false,\n                      bool IsConditionalOperator = false);\n  QualType mergeFunctionTypes(QualType, QualType, bool OfBlockPointer = false,\n                              bool Unqualified = false, bool AllowCXX = false,\n                              bool IsConditionalOperator = false);\n  QualType mergeFunctionParameterTypes(QualType, QualType,\n                                       bool OfBlockPointer = false,\n                                       bool Unqualified = false);\n  QualType mergeTransparentUnionType(QualType, QualType,\n                                     bool OfBlockPointer=false,\n                                     bool Unqualified = false);\n\n  QualType mergeObjCGCQualifiers(QualType, QualType);\n\n  /// This function merges the ExtParameterInfo lists of two functions. It\n  /// returns true if the lists are compatible. The merged list is returned in\n  /// NewParamInfos.\n  ///\n  /// \\param FirstFnType The type of the first function.\n  ///\n  /// \\param SecondFnType The type of the second function.\n  ///\n  /// \\param CanUseFirst This flag is set to true if the first function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param CanUseSecond This flag is set to true if the second function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param NewParamInfos The composite list of ExtParameterInfo. The list is\n  /// empty if none of the flags are set.\n  ///\n  bool mergeExtParameterInfo(\n      const FunctionProtoType *FirstFnType,\n      const FunctionProtoType *SecondFnType,\n      bool &CanUseFirst, bool &CanUseSecond,\n      SmallVectorImpl<FunctionProtoType::ExtParameterInfo> &NewParamInfos);\n\n  void ResetObjCLayout(const ObjCContainerDecl *CD);\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Predicates\n  //===--------------------------------------------------------------------===//\n\n  // The width of an integer, as defined in C99 6.2.6.2. This is the number\n  // of bits in an integer type excluding any padding bits.\n  unsigned getIntWidth(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes a signed type, and returns the\n  // corresponding unsigned integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding unsigned type for\n  // a given fixed point type.\n  QualType getCorrespondingUnsignedType(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes an unsigned type, and returns the\n  // corresponding signed integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding signed type for\n  // a given fixed point type.\n  QualType getCorrespondingSignedType(QualType T) const;\n\n  // Per ISO N1169, this method accepts fixed point types and returns the\n  // corresponding saturated type for a given fixed point type.\n  QualType getCorrespondingSaturatedType(QualType Ty) const;\n\n  // This method accepts fixed point types and returns the corresponding signed\n  // type. Unlike getCorrespondingUnsignedType(), this only accepts unsigned\n  // fixed point types because there are unsigned integer types like bool and\n  // char8_t that don't have signed equivalents.\n  QualType getCorrespondingSignedFixedPointType(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Values\n  //===--------------------------------------------------------------------===//\n\n  /// Make an APSInt of the appropriate width and signedness for the\n  /// given \\p Value and integer \\p Type.\n  llvm::APSInt MakeIntValue(uint64_t Value, QualType Type) const {\n    // If Type is a signed integer type larger than 64 bits, we need to be sure\n    // to sign extend Res appropriately.\n    llvm::APSInt Res(64, !Type->isSignedIntegerOrEnumerationType());\n    Res = Value;\n    unsigned Width = getIntWidth(Type);\n    if (Width != Res.getBitWidth())\n      return Res.extOrTrunc(Width);\n    return Res;\n  }\n\n  bool isSentinelNullExpr(const Expr *E);\n\n  /// Get the implementation of the ObjCInterfaceDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCImplementationDecl *getObjCImplementation(ObjCInterfaceDecl *D);\n\n  /// Get the implementation of the ObjCCategoryDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCCategoryImplDecl *getObjCImplementation(ObjCCategoryDecl *D);\n\n  /// Return true if there is at least one \\@implementation in the TU.\n  bool AnyObjCImplementation() {\n    return !ObjCImpls.empty();\n  }\n\n  /// Set the implementation of ObjCInterfaceDecl.\n  void setObjCImplementation(ObjCInterfaceDecl *IFaceD,\n                             ObjCImplementationDecl *ImplD);\n\n  /// Set the implementation of ObjCCategoryDecl.\n  void setObjCImplementation(ObjCCategoryDecl *CatD,\n                             ObjCCategoryImplDecl *ImplD);\n\n  /// Get the duplicate declaration of a ObjCMethod in the same\n  /// interface, or null if none exists.\n  const ObjCMethodDecl *\n  getObjCMethodRedeclaration(const ObjCMethodDecl *MD) const;\n\n  void setObjCMethodRedeclaration(const ObjCMethodDecl *MD,\n                                  const ObjCMethodDecl *Redecl);\n\n  /// Returns the Objective-C interface that \\p ND belongs to if it is\n  /// an Objective-C method/property/ivar etc. that is part of an interface,\n  /// otherwise returns null.\n  const ObjCInterfaceDecl *getObjContainingInterface(const NamedDecl *ND) const;\n\n  /// Set the copy initialization expression of a block var decl. \\p CanThrow\n  /// indicates whether the copy expression can throw or not.\n  void setBlockVarCopyInit(const VarDecl* VD, Expr *CopyExpr, bool CanThrow);\n\n  /// Get the copy initialization expression of the VarDecl \\p VD, or\n  /// nullptr if none exists.\n  BlockVarCopyInit getBlockVarCopyInit(const VarDecl* VD) const;\n\n  /// Allocate an uninitialized TypeSourceInfo.\n  ///\n  /// The caller should initialize the memory held by TypeSourceInfo using\n  /// the TypeLoc wrappers.\n  ///\n  /// \\param T the type that will be the basis for type source info. This type\n  /// should refer to how the declarator was written in source code, not to\n  /// what type semantic analysis resolved the declarator to.\n  ///\n  /// \\param Size the size of the type info to create, or 0 if the size\n  /// should be calculated based on the type.\n  TypeSourceInfo *CreateTypeSourceInfo(QualType T, unsigned Size = 0) const;\n\n  /// Allocate a TypeSourceInfo where all locations have been\n  /// initialized to a given location, which defaults to the empty\n  /// location.\n  TypeSourceInfo *\n  getTrivialTypeSourceInfo(QualType T,\n                           SourceLocation Loc = SourceLocation()) const;\n\n  /// Add a deallocation callback that will be invoked when the\n  /// ASTContext is destroyed.\n  ///\n  /// \\param Callback A callback function that will be invoked on destruction.\n  ///\n  /// \\param Data Pointer data that will be provided to the callback function\n  /// when it is called.\n  void AddDeallocation(void (*Callback)(void *), void *Data) const;\n\n  /// If T isn't trivially destructible, calls AddDeallocation to register it\n  /// for destruction.\n  template <typename T> void addDestruction(T *Ptr) const {\n    if (!std::is_trivially_destructible<T>::value) {\n      auto DestroyPtr = [](void *V) { static_cast<T *>(V)->~T(); };\n      AddDeallocation(DestroyPtr, Ptr);\n    }\n  }\n\n  GVALinkage GetGVALinkageForFunction(const FunctionDecl *FD) const;\n  GVALinkage GetGVALinkageForVariable(const VarDecl *VD) const;\n\n  /// Determines if the decl can be CodeGen'ed or deserialized from PCH\n  /// lazily, only when used; this is only relevant for function or file scoped\n  /// var definitions.\n  ///\n  /// \\returns true if the function/var must be CodeGen'ed/deserialized even if\n  /// it is not used.\n  bool DeclMustBeEmitted(const Decl *D);\n\n  /// Visits all versions of a multiversioned function with the passed\n  /// predicate.\n  void forEachMultiversionedFunctionVersion(\n      const FunctionDecl *FD,\n      llvm::function_ref<void(FunctionDecl *)> Pred) const;\n\n  const CXXConstructorDecl *\n  getCopyConstructorForExceptionObject(CXXRecordDecl *RD);\n\n  void addCopyConstructorForExceptionObject(CXXRecordDecl *RD,\n                                            CXXConstructorDecl *CD);\n\n  void addTypedefNameForUnnamedTagDecl(TagDecl *TD, TypedefNameDecl *TND);\n\n  TypedefNameDecl *getTypedefNameForUnnamedTagDecl(const TagDecl *TD);\n\n  void addDeclaratorForUnnamedTagDecl(TagDecl *TD, DeclaratorDecl *DD);\n\n  DeclaratorDecl *getDeclaratorForUnnamedTagDecl(const TagDecl *TD);\n\n  void setManglingNumber(const NamedDecl *ND, unsigned Number);\n  unsigned getManglingNumber(const NamedDecl *ND,\n                             bool ForAuxTarget = false) const;\n\n  void setStaticLocalNumber(const VarDecl *VD, unsigned Number);\n  unsigned getStaticLocalNumber(const VarDecl *VD) const;\n\n  /// Retrieve the context for computing mangling numbers in the given\n  /// DeclContext.\n  MangleNumberingContext &getManglingNumberContext(const DeclContext *DC);\n  enum NeedExtraManglingDecl_t { NeedExtraManglingDecl };\n  MangleNumberingContext &getManglingNumberContext(NeedExtraManglingDecl_t,\n                                                   const Decl *D);\n\n  std::unique_ptr<MangleNumberingContext> createMangleNumberingContext() const;\n\n  /// Used by ParmVarDecl to store on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  void setParameterIndex(const ParmVarDecl *D, unsigned index);\n\n  /// Used by ParmVarDecl to retrieve on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  unsigned getParameterIndex(const ParmVarDecl *D) const;\n\n  /// Return a string representing the human readable name for the specified\n  /// function declaration or file name. Used by SourceLocExpr and\n  /// PredefinedExpr to cache evaluated results.\n  StringLiteral *getPredefinedStringLiteralFromCache(StringRef Key) const;\n\n  /// Return a declaration for the global GUID object representing the given\n  /// GUID value.\n  MSGuidDecl *getMSGuidDecl(MSGuidDeclParts Parts) const;\n\n  /// Return a declaration for a uniquified anonymous global constant\n  /// corresponding to a given APValue.\n  UnnamedGlobalConstantDecl *\n  getUnnamedGlobalConstantDecl(QualType Ty, const APValue &Value) const;\n\n  /// Return the template parameter object of the given type with the given\n  /// value.\n  TemplateParamObjectDecl *getTemplateParamObjectDecl(QualType T,\n                                                      const APValue &V) const;\n\n  /// Parses the target attributes passed in, and returns only the ones that are\n  /// valid feature names.\n  ParsedTargetAttr filterFunctionTargetAttrs(const TargetAttr *TD) const;\n\n  std::vector<std::string>\n  filterFunctionTargetVersionAttrs(const TargetVersionAttr *TV) const;\n\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             const FunctionDecl *) const;\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             GlobalDecl GD) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Statistics\n  //===--------------------------------------------------------------------===//\n\n  /// The number of implicitly-declared default constructors.\n  unsigned NumImplicitDefaultConstructors = 0;\n\n  /// The number of implicitly-declared default constructors for\n  /// which declarations were built.\n  unsigned NumImplicitDefaultConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy constructors.\n  unsigned NumImplicitCopyConstructors = 0;\n\n  /// The number of implicitly-declared copy constructors for\n  /// which declarations were built.\n  unsigned NumImplicitCopyConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared move constructors.\n  unsigned NumImplicitMoveConstructors = 0;\n\n  /// The number of implicitly-declared move constructors for\n  /// which declarations were built.\n  unsigned NumImplicitMoveConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy assignment operators.\n  unsigned NumImplicitCopyAssignmentOperators = 0;\n\n  /// The number of implicitly-declared copy assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitCopyAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared move assignment operators.\n  unsigned NumImplicitMoveAssignmentOperators = 0;\n\n  /// The number of implicitly-declared move assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitMoveAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared destructors.\n  unsigned NumImplicitDestructors = 0;\n\n  /// The number of implicitly-declared destructors for which\n  /// declarations were built.\n  unsigned NumImplicitDestructorsDeclared = 0;\n\npublic:\n  /// Initialize built-in types.\n  ///\n  /// This routine may only be invoked once for a given ASTContext object.\n  /// It is normally invoked after ASTContext construction.\n  ///\n  /// \\param Target The target\n  void InitBuiltinTypes(const TargetInfo &Target,\n                        const TargetInfo *AuxTarget = nullptr);\n\nprivate:\n  void InitBuiltinType(CanQualType &R, BuiltinType::Kind K);\n\n  class ObjCEncOptions {\n    unsigned Bits;\n\n    ObjCEncOptions(unsigned Bits) : Bits(Bits) {}\n\n  public:\n    ObjCEncOptions() : Bits(0) {}\n\n#define OPT_LIST(V)                                                            \\\n  V(ExpandPointedToStructures, 0)                                              \\\n  V(ExpandStructures, 1)                                                       \\\n  V(IsOutermostType, 2)                                                        \\\n  V(EncodingProperty, 3)                                                       \\\n  V(IsStructField, 4)                                                          \\\n  V(EncodeBlockParameters, 5)                                                  \\\n  V(EncodeClassNames, 6)                                                       \\\n\n#define V(N,I) ObjCEncOptions& set##N() { Bits |= 1 << I; return *this; }\nOPT_LIST(V)\n#undef V\n\n#define V(N,I) bool N() const { return Bits & 1 << I; }\nOPT_LIST(V)\n#undef V\n\n#undef OPT_LIST\n\n    [[nodiscard]] ObjCEncOptions keepingOnly(ObjCEncOptions Mask) const {\n      return Bits & Mask.Bits;\n    }\n\n    [[nodiscard]] ObjCEncOptions forComponentType() const {\n      ObjCEncOptions Mask = ObjCEncOptions()\n                                .setIsOutermostType()\n                                .setIsStructField();\n      return Bits & ~Mask.Bits;\n    }\n  };\n\n  // Return the Objective-C type encoding for a given type.\n  void getObjCEncodingForTypeImpl(QualType t, std::string &S,\n                                  ObjCEncOptions Options,\n                                  const FieldDecl *Field,\n                                  QualType *NotEncodedT = nullptr) const;\n\n  // Adds the encoding of the structure's members.\n  void getObjCEncodingForStructureImpl(RecordDecl *RD, std::string &S,\n                                       const FieldDecl *Field,\n                                       bool includeVBases = true,\n                                       QualType *NotEncodedT=nullptr) const;\n\npublic:\n  // Adds the encoding of a method parameter or return type.\n  void getObjCEncodingForMethodParameter(Decl::ObjCDeclQualifier QT,\n                                         QualType T, std::string& S,\n                                         bool Extended) const;\n\n  /// Returns true if this is an inline-initialized static data member\n  /// which is treated as a definition for MSVC compatibility.\n  bool isMSStaticDataMemberInlineDefinition(const VarDecl *VD) const;\n\n  enum class InlineVariableDefinitionKind {\n    /// Not an inline variable.\n    None,\n\n    /// Weak definition of inline variable.\n    Weak,\n\n    /// Weak for now, might become strong later in this TU.\n    WeakUnknown,\n\n    /// Strong definition.\n    Strong\n  };\n\n  /// Determine whether a definition of this inline variable should\n  /// be treated as a weak or strong definition. For compatibility with\n  /// C++14 and before, for a constexpr static data member, if there is an\n  /// out-of-line declaration of the member, we may promote it from weak to\n  /// strong.\n  InlineVariableDefinitionKind\n  getInlineVariableDefinitionKind(const VarDecl *VD) const;\n\nprivate:\n  friend class DeclarationNameTable;\n  friend class DeclContext;\n\n  const ASTRecordLayout &\n  getObjCLayout(const ObjCInterfaceDecl *D,\n                const ObjCImplementationDecl *Impl) const;\n\n  /// A set of deallocations that should be performed when the\n  /// ASTContext is destroyed.\n  // FIXME: We really should have a better mechanism in the ASTContext to\n  // manage running destructors for types which do variable sized allocation\n  // within the AST. In some places we thread the AST bump pointer allocator\n  // into the datastructures which avoids this mess during deallocation but is\n  // wasteful of memory, and here we require a lot of error prone book keeping\n  // in order to track and run destructors while we're tearing things down.\n  using DeallocationFunctionsAndArguments =\n      llvm::SmallVector<std::pair<void (*)(void *), void *>, 16>;\n  mutable DeallocationFunctionsAndArguments Deallocations;\n\n  // FIXME: This currently contains the set of StoredDeclMaps used\n  // by DeclContext objects.  This probably should not be in ASTContext,\n  // but we include it here so that ASTContext can quickly deallocate them.\n  llvm::PointerIntPair<StoredDeclsMap *, 1> LastSDM;\n\n  std::vector<Decl *> TraversalScope;\n\n  std::unique_ptr<VTableContextBase> VTContext;\n\n  void ReleaseDeclContextMaps();\n\npublic:\n  enum PragmaSectionFlag : unsigned {\n    PSF_None = 0,\n    PSF_Read = 0x1,\n    PSF_Write = 0x2,\n    PSF_Execute = 0x4,\n    PSF_Implicit = 0x8,\n    PSF_ZeroInit = 0x10,\n    PSF_Invalid = 0x80000000U,\n  };\n\n  struct SectionInfo {\n    NamedDecl *Decl;\n    SourceLocation PragmaSectionLocation;\n    int SectionFlags;\n\n    SectionInfo() = default;\n    SectionInfo(NamedDecl *Decl, SourceLocation PragmaSectionLocation,\n                int SectionFlags)\n        : Decl(Decl), PragmaSectionLocation(PragmaSectionLocation),\n          SectionFlags(SectionFlags) {}\n  };\n\n  llvm::StringMap<SectionInfo> SectionInfos;\n\n  /// Return a new OMPTraitInfo object owned by this context.\n  OMPTraitInfo &getNewOMPTraitInfo();\n\n  /// Whether a C++ static variable or CUDA/HIP kernel may be externalized.\n  bool mayExternalize(const Decl *D) const;\n\n  /// Whether a C++ static variable or CUDA/HIP kernel should be externalized.\n  bool shouldExternalize(const Decl *D) const;\n\n  StringRef getCUIDHash() const;\n\nprivate:\n  /// All OMPTraitInfo objects live in this collection, one per\n  /// `pragma omp [begin] declare variant` directive.\n  SmallVector<std::unique_ptr<OMPTraitInfo>, 4> OMPTraitInfoVector;\n}",
  "id": "BLOCK-CPP-07060",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTContext.h",
  "source_line": 514,
  "validation_status": "validated"
}