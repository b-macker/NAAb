{
  "code": "{\n  optional_detail::OptionalStorage<T> Storage;\n\npublic:\n  using value_type = T;\n\n  constexpr CustomizableOptional() = default;\n  constexpr CustomizableOptional(std::nullopt_t) {}\n\n  constexpr CustomizableOptional(const T &y) : Storage(std::in_place, y) {}\n  constexpr CustomizableOptional(const CustomizableOptional &O) = default;\n\n  constexpr CustomizableOptional(T &&y)\n      : Storage(std::in_place, std::move(y)) {}\n  constexpr CustomizableOptional(CustomizableOptional &&O) = default;\n\n  template <typename... ArgTypes>\n  constexpr CustomizableOptional(std::in_place_t, ArgTypes &&...Args)\n      : Storage(std::in_place, std::forward<ArgTypes>(Args)...) {}\n\n  // Allow conversion from std::optional<T>.\n  constexpr CustomizableOptional(const std::optional<T> &y)\n      : CustomizableOptional(y ? *y : CustomizableOptional()) {}\n  constexpr CustomizableOptional(std::optional<T> &&y)\n      : CustomizableOptional(y ? std::move(*y) : CustomizableOptional()) {}\n\n  CustomizableOptional &operator=(T &&y) {\n    Storage = std::move(y);\n    return *this;\n  }\n  CustomizableOptional &operator=(CustomizableOptional &&O) = default;\n\n  /// Create a new object by constructing it in place with the given arguments.\n  template <typename... ArgTypes> void emplace(ArgTypes &&...Args) {\n    Storage.emplace(std::forward<ArgTypes>(Args)...);\n  }\n\n  CustomizableOptional &operator=(const T &y) {\n    Storage = y;\n    return *this;\n  }\n  CustomizableOptional &operator=(const CustomizableOptional &O) = default;\n\n  void reset() { Storage.reset(); }\n\n  LLVM_DEPRECATED(\"Use &*X instead.\", \"&*X\")\n  constexpr const T *getPointer() const { return &Storage.value(); }\n  LLVM_DEPRECATED(\"Use &*X instead.\", \"&*X\")\n  T *getPointer() { return &Storage.value(); }\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  constexpr const T &value() const & { return Storage.value(); }\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  T &value() & { return Storage.value(); }\n\n  constexpr explicit operator bool() const { return has_value(); }\n  constexpr bool has_value() const { return Storage.has_value(); }\n  constexpr const T *operator->() const { return &Storage.value(); }\n  T *operator->() { return &Storage.value(); }\n  constexpr const T &operator*() const & { return Storage.value(); }\n  T &operator*() & { return Storage.value(); }\n\n  template <typename U> constexpr T value_or(U &&alt) const & {\n    return has_value() ? operator*() : std::forward<U>(alt);\n  }\n\n  LLVM_DEPRECATED(\"std::optional::value is throwing. Use *X instead\", \"*X\")\n  T &&value() && { return std::move(Storage.value()); }\n  T &&operator*() && { return std::move(Storage.value()); }\n\n  template <typename U> T value_or(U &&alt) && {\n    return has_value() ? std::move(operator*()) : std::forward<U>(alt);\n  }\n\n  // Allow conversion to std::optional<T>.\n  explicit operator std::optional<T> &() const & {\n    return *this ? **this : std::optional<T>();\n  }\n  explicit operator std::optional<T> &&() const && {\n    return *this ? std::move(**this) : std::optional<T>();\n  }\n}",
  "id": "BLOCK-CPP-16104",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/CustomizableOptional.h",
  "source_line": 28,
  "validation_status": "validated"
}