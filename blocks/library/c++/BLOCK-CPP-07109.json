{
  "code": "{\n\n  /// Pointer to the import specific lookup table.\n  std::unique_ptr<ASTImporterLookupTable> LookupTable;\n\n  /// Mapping from the already-imported declarations in the \"to\"\n  /// context to the error status of the import of that declaration.\n  /// This map contains only the declarations that were not correctly\n  /// imported. The same declaration may or may not be included in\n  /// ImportedFromDecls. This map is updated continuously during imports and\n  /// never cleared (like ImportedFromDecls).\n  llvm::DenseMap<Decl *, ASTImportError> ImportErrors;\n\n  /// Set of the newly created declarations.\n  llvm::DenseSet<Decl *> NewDecls;\n\n  // FIXME put ImportedFromDecls here!\n  // And from that point we can better encapsulate the lookup table.\n\npublic:\n  ASTImporterSharedState() = default;\n\n  ASTImporterSharedState(TranslationUnitDecl &ToTU) {\n    LookupTable = std::make_unique<ASTImporterLookupTable>(ToTU);\n  }\n\n  ASTImporterLookupTable *getLookupTable() { return LookupTable.get(); }\n\n  void addDeclToLookup(Decl *D) {\n    if (LookupTable)\n      if (auto *ND = dyn_cast<NamedDecl>(D))\n        LookupTable->add(ND);\n  }\n\n  void removeDeclFromLookup(Decl *D) {\n    if (LookupTable)\n      if (auto *ND = dyn_cast<NamedDecl>(D))\n        LookupTable->remove(ND);\n  }\n\n  std::optional<ASTImportError> getImportDeclErrorIfAny(Decl *ToD) const {\n    auto Pos = ImportErrors.find(ToD);\n    if (Pos != ImportErrors.end())\n      return Pos->second;\n    else\n      return std::nullopt;\n  }\n\n  void setImportDeclError(Decl *To, ASTImportError Error) {\n    ImportErrors[To] = Error;\n  }\n\n  bool isNewDecl(const Decl *ToD) const { return NewDecls.count(ToD); }\n\n  void markAsNewDecl(Decl *ToD) { NewDecls.insert(ToD); }\n}",
  "id": "BLOCK-CPP-07109",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTImporterSharedState.h",
  "source_line": 29,
  "validation_status": "validated"
}