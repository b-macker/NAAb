{
  "code": "#include <iostream>\n#include <ostream>\n#include <string>\n#include <vector>\n#include \"absl/base/config.h\"\n#include \"absl/flags/declare.h\"\n#include \"absl/flags/internal/usage.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05533_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace flags_internal {\n\nenum class UsageFlagsAction { kHandleUsage, kIgnoreUsage };\nenum class OnUndefinedFlag {\n  kIgnoreUndefined,\n  kReportUndefined,\n  kAbortIfUndefined\n};\n\n// This is not a public interface. This interface exists to expose the ability\n// to change help output stream in case of parsing errors. This is used by\n// internal unit tests to validate expected outputs.\n// When this was written, `EXPECT_EXIT` only supported matchers on stderr,\n// but not on stdout.\nstd::vector<char*> ParseCommandLineImpl(\n    int argc, char* argv[], UsageFlagsAction usage_flag_action,\n    OnUndefinedFlag undef_flag_action,\n    std::ostream& error_help_output = std::cout);\n\n// --------------------------------------------------------------------\n// Inspect original command line\n\n// Returns true if flag with specified name was either present on the original\n// command line or specified in flag file present on the original command line.\nbool WasPresentOnCommandLine(absl::string_view flag_name);\n\n// Return existing flags similar to the parameter, in order to help in case of\n// misspellings.\nstd::vector<std::string> GetMisspellingHints(absl::string_view flag);\n\n}  // namespace flags_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05533",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/internal/parse.h",
  "source_line": 34,
  "validation_status": "validated"
}