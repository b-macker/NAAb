{
  "code": "{\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const { return data().IsAnyDestructorNoReturn; }\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Retrieve the index of this lambda within the context declaration returned\n  /// by getLambdaContextDecl().\n  unsigned getLambdaIndexInContext() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().IndexInContext;\n  }\n\n  /// Information about how a lambda is numbered within its context.\n  struct LambdaNumbering {\n    Decl *ContextDecl = nullptr;\n    unsigned IndexInContext = 0;\n    unsigned ManglingNumber = 0;\n    unsigned DeviceManglingNumber = 0;\n    bool HasKnownInternalLinkage = false;\n  };\n\n  /// Set the mangling numbers and context declaration for a lambda class.\n  void setLambdaNumbering(LambdaNumbering Numbering);\n\n  // Get the mangling numbers and context declaration for a lambda class.\n  LambdaNumbering getLambdaNumbering() const {\n    return {getLambdaContextDecl(), getLambdaIndexInContext(),\n            getLambdaManglingNumber(), getDeviceLambdaManglingNumber(),\n            hasKnownLambdaInternalLinkage()};\n  }\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().DependencyKind == LDK_AlwaysDependent;\n  }\n\n  bool isNeverDependentLambda() const {\n    return isLambda() && getLambdaData().DependencyKind == LDK_NeverDependent;\n  }\n\n  unsigned getLambdaDependencyKind() const {\n    if (!isLambda())\n      return LDK_Unknown;\n    return getLambdaData().DependencyKind;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  void setLambdaTypeInfo(TypeSourceInfo *TS) {\n    assert(DefinitionData && DefinitionData->IsLambda &&\n           \"setting lambda property of non-lambda class\");\n    auto &DL = static_cast<LambdaDefinitionData &>(*DefinitionData);\n    DL.MethodTyInfo = TS;\n  }\n\n  void setLambdaIsGeneric(bool IsGeneric) {\n    assert(DefinitionData && DefinitionData->IsLambda &&\n           \"setting lambda property of non-lambda class\");\n    auto &DL = static_cast<LambdaDefinitionData &>(*DefinitionData);\n    DL.IsGenericLambda = IsGeneric;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n  void markAbstract() { data().Abstract = true; }\n}",
  "id": "BLOCK-CPP-08720",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 1473,
  "validation_status": "validated"
}