{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// HaveLeakSanitizer()\n//\n// Returns true if a leak-checking sanitizer (either ASan or standalone LSan) is\n// currently built into this target.\nbool HaveLeakSanitizer();\n\n// LeakCheckerIsActive()\n//\n// Returns true if a leak-checking sanitizer (either ASan or standalone LSan) is\n// currently built into this target and is turned on.\nbool LeakCheckerIsActive();\n\n// DoIgnoreLeak()\n//\n// Implements `IgnoreLeak()` below. This function should usually\n// not be called directly; calling `IgnoreLeak()` is preferred.\nvoid DoIgnoreLeak(const void* ptr);\n\n// IgnoreLeak()\n//\n// Instruct the leak sanitizer to ignore leak warnings on the object referenced\n// by the passed pointer, as well as all heap objects transitively referenced\n// by it. The passed object pointer can point to either the beginning of the\n// object or anywhere within it.\n//\n// Example:\n//\n//   static T* obj = IgnoreLeak(new T(...));\n//\n// If the passed `ptr` does not point to an actively allocated object at the\n// time `IgnoreLeak()` is called, the call is a no-op; if it is actively\n// allocated, leak sanitizer will assume this object is referenced even if\n// there is no actual reference in user memory.\n//\ntemplate <typename T>\nT* IgnoreLeak(T* ptr) {\n  DoIgnoreLeak(ptr);\n  return ptr;\n}\n\n// FindAndReportLeaks()\n//\n// If any leaks are detected, prints a leak report and returns true.  This\n// function may be called repeatedly, and does not affect end-of-process leak\n// checking.\n//\n// Example:\n// if (FindAndReportLeaks()) {\n//   ... diagnostic already printed. Exit with failure code.\n//   exit(1)\n// }\nbool FindAndReportLeaks();\n\n// LeakCheckDisabler\n//\n// This helper class indicates that any heap allocations done in the code block\n// covered by the scoped object, which should be allocated on the stack, will\n// not be reported as leaks. Leak check disabling will occur within the code\n// block and any nested function calls within the code block.\n//\n// Example:\n//\n//   void Foo() {\n//     LeakCheckDisabler disabler;\n//     ... code that allocates objects whose leaks should be ignored ...\n//   }\n//\n// REQUIRES: Destructor runs in same thread as constructor\nclass LeakCheckDisabler {\n public:\n  LeakCheckDisabler();\n  LeakCheckDisabler(const LeakCheckDisabler&) = delete;\n  LeakCheckDisabler& operator=(const LeakCheckDisabler&) = delete;\n  ~LeakCheckDisabler();\n};\n\n// RegisterLivePointers()\n//\n// Registers `ptr[0,size-1]` as pointers to memory that is still actively being\n// referenced and for which leak checking should be ignored. This function is\n// useful if you store pointers in mapped memory, for memory ranges that we know\n// are correct but for which normal analysis would flag as leaked code.\nvoid RegisterLivePointers(const void* ptr, size_t size);\n\n// UnRegisterLivePointers()\n//\n// Deregisters the pointers previously marked as active in\n// `RegisterLivePointers()`, enabling leak checking of those pointers.\nvoid UnRegisterLivePointers(const void* ptr, size_t size);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03576",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/leak_check.h",
  "source_line": 54,
  "validation_status": "validated"
}