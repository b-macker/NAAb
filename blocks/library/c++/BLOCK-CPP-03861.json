{
  "code": "#include <cmath>\n#include <cstdint>\n#include <istream>\n#include <limits>\n#include <type_traits>\n#include \"absl/base/config.h\"\n#include \"absl/random/internal/fast_uniform_bits.h\"\n#include \"absl/random/internal/generate_real.h\"\n#include \"absl/random/internal/iostream_state_saver.h\"\n\nusing namespace absl;\nusing namespace random_internal;\nusing namespace random_internal;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03861_execute() {\n    {\n\ntemplate <typename URBG>\ninline double gaussian_distribution_base::zignor_fallback(URBG& g, bool neg) {\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n\n  // This fallback path happens approximately 0.05% of the time.\n  double x, y;\n  do {\n    // kRInv = 1/r, U(0, 1)\n    x = kRInv *\n        std::log(GenerateRealFromBits<double, GeneratePositiveTag, false>(\n            fast_u64_(g)));\n    y = -std::log(\n        GenerateRealFromBits<double, GeneratePositiveTag, false>(fast_u64_(g)));\n  } while ((y + y) < (x * x));\n  return neg ? (x - kR) : (kR - x);\n}\n\ntemplate <typename URBG>\ninline double gaussian_distribution_base::zignor(\n    URBG& g) {  // NOLINT(runtime/references)\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n  using random_internal::GenerateSignedTag;\n\n  while (true) {\n    // We use a single uint64_t to generate both a double and a strip.\n    // These bits are unused when the generated double is > 1/2^5.\n    // This may introduce some bias from the duplicated low bits of small\n    // values (those smaller than 1/2^5, which all end up on the left tail).\n    uint64_t bits = fast_u64_(g);\n    int i = static_cast<int>(bits & kMask);  // pick a random strip\n    double j = GenerateRealFromBits<double, GenerateSignedTag, false>(\n        bits);  // U(-1, 1)\n    const double x = j * zg_.x[i];\n\n    // Retangular box. Handles >97% of all cases.\n    // For any given box, this handles between 75% and 99% of values.\n    // Equivalent to U(01) < (x[i+1] / x[i]), and when i == 0, ~93.5%\n    if (std::abs(x) < zg_.x[i + 1]) {\n      return x;\n    }\n\n    // i == 0: Base box. Sample using a ratio of uniforms.\n    if (i == 0) {\n      // This path happens about 0.05% of the time.\n      return zignor_fallback(g, j < 0);\n    }\n\n    // i > 0: Wedge samples using precomputed values.\n    double v = GenerateRealFromBits<double, GeneratePositiveTag, false>(\n        fast_u64_(g));  // U(0, 1)\n    if ((zg_.f[i + 1] + v * (zg_.f[i] - zg_.f[i + 1])) <\n        std::exp(-0.5 * x * x)) {\n      return x;\n    }\n\n    // The wedge was missed; reject the value and try again.\n  }\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03861",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/gaussian_distribution.h",
  "source_line": 208,
  "validation_status": "validated"
}