{
  "code": "{\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  llvm::PointerUnion<Stmt *, LifetimeExtendedTemporaryDecl *> State;\n\npublic:\n  MaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                           bool BoundToLvalueReference,\n                           LifetimeExtendedTemporaryDecl *MTD = nullptr);\n\n  MaterializeTemporaryExpr(EmptyShell Empty)\n      : Expr(MaterializeTemporaryExprClass, Empty) {}\n\n  /// Retrieve the temporary-generating subexpression whose value will\n  /// be materialized into a glvalue.\n  Expr *getSubExpr() const {\n    return cast<Expr>(\n        State.is<Stmt *>()\n            ? State.get<Stmt *>()\n            : State.get<LifetimeExtendedTemporaryDecl *>()->getTemporaryExpr());\n  }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const {\n    return State.is<Stmt *>() ? SD_FullExpression\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getStorageDuration();\n  }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const {\n    assert(State.is<LifetimeExtendedTemporaryDecl *>() &&\n           \"the temporary has not been lifetime extended\");\n    return State.get<LifetimeExtendedTemporaryDecl *>()->getOrCreateValue(\n        MayCreate);\n  }\n\n  LifetimeExtendedTemporaryDecl *getLifetimeExtendedTemporaryDecl() {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n  const LifetimeExtendedTemporaryDecl *\n  getLifetimeExtendedTemporaryDecl() const {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n\n  /// Get the declaration which triggered the lifetime-extension of this\n  /// temporary, if any.\n  ValueDecl *getExtendingDecl() {\n    return State.is<Stmt *>() ? nullptr\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getExtendingDecl();\n  }\n  const ValueDecl *getExtendingDecl() const {\n    return const_cast<MaterializeTemporaryExpr *>(this)->getExtendingDecl();\n  }\n\n  void setExtendingDecl(ValueDecl *ExtendedBy, unsigned ManglingNumber);\n\n  unsigned getManglingNumber() const {\n    return State.is<Stmt *>() ? 0\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getManglingNumber();\n  }\n\n  /// Determine whether this materialized temporary is bound to an\n  /// lvalue reference; otherwise, it's bound to an rvalue reference.\n  bool isBoundToLvalueReference() const { return isLValue(); }\n\n  /// Determine whether this temporary object is usable in constant\n  /// expressions, as specified in C++20 [expr.const]p4.\n  bool isUsableInConstantExpressions(const ASTContext &Context) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MaterializeTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return State.is<Stmt *>()\n               ? child_range(State.getAddrOfPtr1(), State.getAddrOfPtr1() + 1)\n               : State.get<LifetimeExtendedTemporaryDecl *>()->childrenExpr();\n  }\n\n  const_child_range children() const {\n    return State.is<Stmt *>()\n               ? const_child_range(State.getAddrOfPtr1(),\n                                   State.getAddrOfPtr1() + 1)\n               : const_cast<const LifetimeExtendedTemporaryDecl *>(\n                     State.get<LifetimeExtendedTemporaryDecl *>())\n                     ->childrenExpr();\n  }\n}",
  "id": "BLOCK-CPP-10800",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 4572,
  "validation_status": "validated"
}