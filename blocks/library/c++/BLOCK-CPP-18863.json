{
  "code": "{\npublic:\n  virtual ~PPCallbacks();\n\n  enum FileChangeReason {\n    EnterFile, ExitFile, SystemHeaderPragma, RenameFile\n  };\n\n  /// Callback invoked whenever a source file is entered or exited.\n  ///\n  /// \\param Loc Indicates the new location.\n  /// \\param PrevFID the file that was exited if \\p Reason is ExitFile or the\n  /// the file before the new one entered for \\p Reason EnterFile.\n  virtual void FileChanged(SourceLocation Loc, FileChangeReason Reason,\n                           SrcMgr::CharacteristicKind FileType,\n                           FileID PrevFID = FileID()) {\n  }\n\n  enum class LexedFileChangeReason { EnterFile, ExitFile };\n\n  /// Callback invoked whenever the \\p Lexer moves to a different file for\n  /// lexing. Unlike \\p FileChanged line number directives and other related\n  /// pragmas do not trigger callbacks to \\p LexedFileChanged.\n  ///\n  /// \\param FID The \\p FileID that the \\p Lexer moved to.\n  ///\n  /// \\param Reason Whether the \\p Lexer entered a new file or exited one.\n  ///\n  /// \\param FileType The \\p CharacteristicKind of the file the \\p Lexer moved\n  /// to.\n  ///\n  /// \\param PrevFID The \\p FileID the \\p Lexer was using before the change.\n  ///\n  /// \\param Loc The location where the \\p Lexer entered a new file from or the\n  /// location that the \\p Lexer moved into after exiting a file.\n  virtual void LexedFileChanged(FileID FID, LexedFileChangeReason Reason,\n                                SrcMgr::CharacteristicKind FileType,\n                                FileID PrevFID, SourceLocation Loc) {}\n\n  /// Callback invoked whenever a source file is skipped as the result\n  /// of header guard optimization.\n  ///\n  /// \\param SkippedFile The file that is skipped instead of entering \\#include\n  ///\n  /// \\param FilenameTok The file name token in \\#include \"FileName\" directive\n  /// or macro expanded file name token from \\#include MACRO(PARAMS) directive.\n  /// Note that FilenameTok contains corresponding quotes/angles symbols.\n  virtual void FileSkipped(const FileEntryRef &SkippedFile,\n                           const Token &FilenameTok,\n                           SrcMgr::CharacteristicKind FileType) {}\n\n  /// Callback invoked whenever the preprocessor cannot find a file for an\n  /// inclusion directive.\n  ///\n  /// \\param FileName The name of the file being included, as written in the\n  /// source code.\n  ///\n  /// \\returns true to indicate that the preprocessor should skip this file\n  /// and not issue any diagnostic.\n  virtual bool FileNotFound(StringRef FileName) { return false; }\n\n  /// Callback invoked whenever an inclusion directive of\n  /// any kind (\\c \\#include, \\c \\#import, etc.) has been processed, regardless\n  /// of whether the inclusion will actually result in an inclusion.\n  ///\n  /// \\param HashLoc The location of the '#' that starts the inclusion\n  /// directive.\n  ///\n  /// \\param IncludeTok The token that indicates the kind of inclusion\n  /// directive, e.g., 'include' or 'import'.\n  ///\n  /// \\param FileName The name of the file being included, as written in the\n  /// source code.\n  ///\n  /// \\param IsAngled Whether the file name was enclosed in angle brackets;\n  /// otherwise, it was enclosed in quotes.\n  ///\n  /// \\param FilenameRange The character range of the quotes or angle brackets\n  /// for the written file name.\n  ///\n  /// \\param File The actual file that may be included by this inclusion\n  /// directive.\n  ///\n  /// \\param SearchPath Contains the search path which was used to find the file\n  /// in the file system. If the file was found via an absolute include path,\n  /// SearchPath will be empty. For framework includes, the SearchPath and\n  /// RelativePath will be split up. For example, if an include of \"Some/Some.h\"\n  /// is found via the framework path\n  /// \"path/to/Frameworks/Some.framework/Headers/Some.h\", SearchPath will be\n  /// \"path/to/Frameworks/Some.framework/Headers\" and RelativePath will be\n  /// \"Some.h\".\n  ///\n  /// \\param RelativePath The path relative to SearchPath, at which the include\n  /// file was found. This is equal to FileName except for framework includes.\n  ///\n  /// \\param Imported The module, whenever an inclusion directive was\n  /// automatically turned into a module import or null otherwise.\n  ///\n  /// \\param FileType The characteristic kind, indicates whether a file or\n  /// directory holds normal user code, system code, or system code which is\n  /// implicitly 'extern \"C\"' in C++ mode.\n  ///\n  virtual void InclusionDirective(SourceLocation HashLoc,\n                                  const Token &IncludeTok, StringRef FileName,\n                                  bool IsAngled, CharSourceRange FilenameRange,\n                                  OptionalFileEntryRef File,\n                                  StringRef SearchPath, StringRef RelativePath,\n                                  const Module *Imported,\n                                  SrcMgr::CharacteristicKind FileType) {}\n\n  /// Callback invoked whenever a submodule was entered.\n  ///\n  /// \\param M The submodule we have entered.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param ForPragma If entering from pragma directive.\n  ///\n  virtual void EnteredSubmodule(Module *M, SourceLocation ImportLoc,\n                                bool ForPragma) { }\n\n  /// Callback invoked whenever a submodule was left.\n  ///\n  /// \\param M The submodule we have left.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param ForPragma If entering from pragma directive.\n  ///\n  virtual void LeftSubmodule(Module *M, SourceLocation ImportLoc,\n                             bool ForPragma) { }\n\n  /// Callback invoked whenever there was an explicit module-import\n  /// syntax.\n  ///\n  /// \\param ImportLoc The location of import directive token.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Imported The imported module; can be null if importing failed.\n  ///\n  virtual void moduleImport(SourceLocation ImportLoc,\n                            ModuleIdPath Path,\n                            const Module *Imported) {\n  }\n\n  /// Callback invoked when the end of the main file is reached.\n  ///\n  /// No subsequent callbacks will be made.\n  virtual void EndOfMainFile() {\n  }\n\n  /// Callback invoked when a \\#ident or \\#sccs directive is read.\n  /// \\param Loc The location of the directive.\n  /// \\param str The text of the directive.\n  ///\n  virtual void Ident(SourceLocation Loc, StringRef str) {\n  }\n\n  /// Callback invoked when start reading any pragma directive.\n  virtual void PragmaDirective(SourceLocation Loc,\n                               PragmaIntroducerKind Introducer) {\n  }\n\n  /// Callback invoked when a \\#pragma comment directive is read.\n  virtual void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind,\n                             StringRef Str) {\n  }\n\n  /// Callback invoked when a \\#pragma mark comment is read.\n  virtual void PragmaMark(SourceLocation Loc, StringRef Trivia) {\n  }\n\n  /// Callback invoked when a \\#pragma detect_mismatch directive is\n  /// read.\n  virtual void PragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                                    StringRef Value) {\n  }\n\n  /// Callback invoked when a \\#pragma clang __debug directive is read.\n  /// \\param Loc The location of the debug directive.\n  /// \\param DebugType The identifier following __debug.\n  virtual void PragmaDebug(SourceLocation Loc, StringRef DebugType) {\n  }\n\n  /// Determines the kind of \\#pragma invoking a call to PragmaMessage.\n  enum PragmaMessageKind {\n    /// \\#pragma message has been invoked.\n    PMK_Message,\n\n    /// \\#pragma GCC warning has been invoked.\n    PMK_Warning,\n\n    /// \\#pragma GCC error has been invoked.\n    PMK_Error\n  };\n\n  /// Callback invoked when a \\#pragma message directive is read.\n  /// \\param Loc The location of the message directive.\n  /// \\param Namespace The namespace of the message directive.\n  /// \\param Kind The type of the message directive.\n  /// \\param Str The text of the message directive.\n  virtual void PragmaMessage(SourceLocation Loc, StringRef Namespace,\n                             PragmaMessageKind Kind, StringRef Str) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic push directive\n  /// is read.\n  virtual void PragmaDiagnosticPush(SourceLocation Loc,\n                                    StringRef Namespace) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic pop directive\n  /// is read.\n  virtual void PragmaDiagnosticPop(SourceLocation Loc,\n                                   StringRef Namespace) {\n  }\n\n  /// Callback invoked when a \\#pragma gcc diagnostic directive is read.\n  virtual void PragmaDiagnostic(SourceLocation Loc, StringRef Namespace,\n                                diag::Severity mapping, StringRef Str) {}\n\n  /// Called when an OpenCL extension is either disabled or\n  /// enabled with a pragma.\n  virtual void PragmaOpenCLExtension(SourceLocation NameLoc,\n                                     const IdentifierInfo *Name,\n                                     SourceLocation StateLoc, unsigned State) {\n  }\n\n  /// Callback invoked when a \\#pragma warning directive is read.\n  enum PragmaWarningSpecifier {\n    PWS_Default,\n    PWS_Disable,\n    PWS_Error,\n    PWS_Once,\n    PWS_Suppress,\n    PWS_Level1,\n    PWS_Level2,\n    PWS_Level3,\n    PWS_Level4,\n  };\n  virtual void PragmaWarning(SourceLocation Loc,\n                             PragmaWarningSpecifier WarningSpec,\n                             ArrayRef<int> Ids) {}\n\n  /// Callback invoked when a \\#pragma warning(push) directive is read.\n  virtual void PragmaWarningPush(SourceLocation Loc, int Level) {\n  }\n\n  /// Callback invoked when a \\#pragma warning(pop) directive is read.\n  virtual void PragmaWarningPop(SourceLocation Loc) {\n  }\n\n  /// Callback invoked when a \\#pragma execution_character_set(push) directive\n  /// is read.\n  virtual void PragmaExecCharsetPush(SourceLocation Loc, StringRef Str) {}\n\n  /// Callback invoked when a \\#pragma execution_character_set(pop) directive\n  /// is read.\n  virtual void PragmaExecCharsetPop(SourceLocation Loc) {}\n\n  /// Callback invoked when a \\#pragma clang assume_nonnull begin directive\n  /// is read.\n  virtual void PragmaAssumeNonNullBegin(SourceLocation Loc) {}\n\n  /// Callback invoked when a \\#pragma clang assume_nonnull end directive\n  /// is read.\n  virtual void PragmaAssumeNonNullEnd(SourceLocation Loc) {}\n\n  /// Called by Preprocessor::HandleMacroExpandedIdentifier when a\n  /// macro invocation is found.\n  virtual void MacroExpands(const Token &MacroNameTok,\n                            const MacroDefinition &MD, SourceRange Range,\n                            const MacroArgs *Args) {}\n\n  /// Hook called whenever a macro definition is seen.\n  virtual void MacroDefined(const Token &MacroNameTok,\n                            const MacroDirective *MD) {\n  }\n\n  /// Hook called whenever a macro \\#undef is seen.\n  /// \\param MacroNameTok The active Token\n  /// \\param MD A MacroDefinition for the named macro.\n  /// \\param Undef New MacroDirective if the macro was defined, null otherwise.\n  ///\n  /// MD is released immediately following this callback.\n  virtual void MacroUndefined(const Token &MacroNameTok,\n                              const MacroDefinition &MD,\n                              const MacroDirective *Undef) {\n  }\n\n  /// Hook called whenever the 'defined' operator is seen.\n  /// \\param MD The MacroDirective if the name was a macro, null otherwise.\n  virtual void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n                       SourceRange Range) {\n  }\n\n  /// Hook called when a '__has_include' or '__has_include_next' directive is\n  /// read.\n  virtual void HasInclude(SourceLocation Loc, StringRef FileName, bool IsAngled,\n                          OptionalFileEntryRef File,\n                          SrcMgr::CharacteristicKind FileType);\n\n  /// Hook called when a source range is skipped.\n  /// \\param Range The SourceRange that was skipped. The range begins at the\n  /// \\#if/\\#else directive and ends after the \\#endif/\\#else directive.\n  /// \\param EndifLoc The end location of the 'endif' token, which may precede\n  /// the range skipped by the directive (e.g excluding comments after an\n  /// 'endif').\n  virtual void SourceRangeSkipped(SourceRange Range, SourceLocation EndifLoc) {\n  }\n\n  enum ConditionValueKind {\n    CVK_NotEvaluated, CVK_False, CVK_True\n  };\n\n  /// Hook called whenever an \\#if is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param ConditionValue The evaluated value of the condition.\n  ///\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void If(SourceLocation Loc, SourceRange ConditionRange,\n                  ConditionValueKind ConditionValue) {\n  }\n\n  /// Hook called whenever an \\#elif is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param ConditionValue The evaluated value of the condition.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void Elif(SourceLocation Loc, SourceRange ConditionRange,\n                    ConditionValueKind ConditionValue, SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#ifdef is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefinition if the name was a macro, null otherwise.\n  virtual void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n                     const MacroDefinition &MD) {\n  }\n\n  /// Hook called whenever an \\#elifdef branch is taken.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefinition if the name was a macro, null otherwise.\n  virtual void Elifdef(SourceLocation Loc, const Token &MacroNameTok,\n                       const MacroDefinition &MD) {\n  }\n  /// Hook called whenever an \\#elifdef is skipped.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void Elifdef(SourceLocation Loc, SourceRange ConditionRange,\n                       SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#ifndef is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefiniton if the name was a macro, null otherwise.\n  virtual void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n                      const MacroDefinition &MD) {\n  }\n\n  /// Hook called whenever an \\#elifndef branch is taken.\n  /// \\param Loc the source location of the directive.\n  /// \\param MacroNameTok Information on the token being tested.\n  /// \\param MD The MacroDefinition if the name was a macro, null otherwise.\n  virtual void Elifndef(SourceLocation Loc, const Token &MacroNameTok,\n                        const MacroDefinition &MD) {\n  }\n  /// Hook called whenever an \\#elifndef is skipped.\n  /// \\param Loc the source location of the directive.\n  /// \\param ConditionRange The SourceRange of the expression being tested.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  // FIXME: better to pass in a list (or tree!) of Tokens.\n  virtual void Elifndef(SourceLocation Loc, SourceRange ConditionRange,\n                        SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#else is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  virtual void Else(SourceLocation Loc, SourceLocation IfLoc) {\n  }\n\n  /// Hook called whenever an \\#endif is seen.\n  /// \\param Loc the source location of the directive.\n  /// \\param IfLoc the source location of the \\#if/\\#ifdef/\\#ifndef directive.\n  virtual void Endif(SourceLocation Loc, SourceLocation IfLoc) {\n  }\n}",
  "id": "BLOCK-CPP-18863",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/PPCallbacks.h",
  "source_line": 35,
  "validation_status": "validated"
}