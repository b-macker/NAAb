{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/base/log_severity.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/time/time.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05732_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\n\n// IsInitialized returns true if the logging library is initialized.\n// This function is async-signal-safe\nbool IsInitialized();\n\n// SetLoggingInitialized is called once after logging initialization is done.\nvoid SetInitialized();\n\n// Unconditionally write a `message` to stderr. If `severity` exceeds kInfo\n// we also flush the stderr stream.\nvoid WriteToStderr(absl::string_view message, absl::LogSeverity severity);\n\n// Set the TimeZone used for human-friendly times (for example, the log message\n// prefix) printed by the logging library. This may only be called once.\nvoid SetTimeZone(absl::TimeZone tz);\n\n// Returns the TimeZone used for human-friendly times (for example, the log\n// message prefix) printed by the logging library Returns nullptr prior to\n// initialization.\nconst absl::TimeZone* TimeZone();\n\n// Returns true if stack traces emitted by the logging library should be\n// symbolized. This function is async-signal-safe.\nbool ShouldSymbolizeLogStackTrace();\n\n// Enables or disables symbolization of stack traces emitted by the\n// logging library. This function is async-signal-safe.\nvoid EnableSymbolizeLogStackTrace(bool on_off);\n\n// Returns the maximum number of frames that appear in stack traces\n// emitted by the logging library. This function is async-signal-safe.\nint MaxFramesInLogStackTrace();\n\n// Sets the maximum number of frames that appear in stack traces emitted by\n// the logging library. This function is async-signal-safe.\nvoid SetMaxFramesInLogStackTrace(int max_num_frames);\n\n// Determines whether we exit the program for a LOG(DFATAL) message in\n// debug mode.  It does this by skipping the call to Fail/FailQuietly.\n// This is intended for testing only.\n//\n// This can have some effects on LOG(FATAL) as well. Failure messages\n// are always allocated (rather than sharing a buffer), the crash\n// reason is not recorded, the \"gwq\" status message is not updated,\n// and the stack trace is not recorded.  The LOG(FATAL) *will* still\n// exit the program. Since this function is used only in testing,\n// these differences are acceptable.\n//\n// Additionally, LOG(LEVEL(FATAL)) is indistinguishable from LOG(DFATAL) and\n// will not terminate the program if SetExitOnDFatal(false) has been called.\nbool ExitOnDFatal();\n\n// SetExitOnDFatal() sets the ExitOnDFatal() status\nvoid SetExitOnDFatal(bool on_off);\n\n// Determines if the logging library should suppress logging of stacktraces in\n// the `SIGABRT` handler, typically because we just logged a stacktrace as part\n// of `LOG(FATAL)` and are about to send ourselves a `SIGABRT` to end the\n// program.\nbool SuppressSigabortTrace();\n\n// Sets the SuppressSigabortTrace() status and returns the previous state.\nbool SetSuppressSigabortTrace(bool on_off);\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05732",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/globals.h",
  "source_line": 30,
  "validation_status": "validated"
}