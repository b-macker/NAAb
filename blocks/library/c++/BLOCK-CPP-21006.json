{
  "code": "{\npublic:\n  using value_type = std::pair<Int, V>;\n  using reference = value_type &;\n  using const_reference = const value_type &;\n  using pointer = value_type *;\n  using const_pointer = const value_type *;\n\nprivate:\n  using Representation = SmallVector<value_type, InitialCapacity>;\n\n  Representation Rep;\n\n  struct Compare {\n    bool operator ()(const_reference L, Int R) const {\n      return L.first < R;\n    }\n    bool operator ()(Int L, const_reference R) const {\n      return L < R.first;\n    }\n    bool operator ()(Int L, Int R) const {\n      return L < R;\n    }\n    bool operator ()(const_reference L, const_reference R) const {\n      return L.first < R.first;\n    }\n  };\n\npublic:\n  void insert(const value_type &Val) {\n    if (!Rep.empty() && Rep.back() == Val)\n      return;\n\n    assert((Rep.empty() || Rep.back().first < Val.first) &&\n           \"Must insert keys in order.\");\n    Rep.push_back(Val);\n  }\n\n  void insertOrReplace(const value_type &Val) {\n    iterator I = llvm::lower_bound(Rep, Val, Compare());\n    if (I != Rep.end() && I->first == Val.first) {\n      I->second = Val.second;\n      return;\n    }\n\n    Rep.insert(I, Val);\n  }\n\n  using iterator = typename Representation::iterator;\n  using const_iterator = typename Representation::const_iterator;\n\n  iterator begin() { return Rep.begin(); }\n  iterator end() { return Rep.end(); }\n  const_iterator begin() const { return Rep.begin(); }\n  const_iterator end() const { return Rep.end(); }\n\n  iterator find(Int K) {\n    iterator I = llvm::upper_bound(Rep, K, Compare());\n    // I points to the first entry with a key > K, which is the range that\n    // follows the one containing K.\n    if (I == Rep.begin())\n      return Rep.end();\n    --I;\n    return I;\n  }\n  const_iterator find(Int K) const {\n    return const_cast<ContinuousRangeMap*>(this)->find(K);\n  }\n\n  reference back() { return Rep.back(); }\n  const_reference back() const { return Rep.back(); }\n\n  /// An object that helps properly build a continuous range map\n  /// from a set of values.\n  class Builder {\n    ContinuousRangeMap &Self;\n\n  public:\n    explicit Builder(ContinuousRangeMap &Self) : Self(Self) {}\n    Builder(const Builder&) = delete;\n    Builder &operator=(const Builder&) = delete;\n\n    ~Builder() {\n      llvm::sort(Self.Rep, Compare());\n      Self.Rep.erase(\n          std::unique(\n              Self.Rep.begin(), Self.Rep.end(),\n              [](const_reference A, const_reference B) {\n                // FIXME: we should not allow any duplicate keys, but there are\n                // a lot of duplicate 0 -> 0 mappings to remove first.\n                assert((A == B || A.first != B.first) &&\n                       \"ContinuousRangeMap::Builder given non-unique keys\");\n                return A == B;\n              }),\n          Self.Rep.end());\n    }\n\n    void insert(const value_type &Val) {\n      Self.Rep.push_back(Val);\n    }\n  };\n\n  friend class Builder;\n}",
  "id": "BLOCK-CPP-21006",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ContinuousRangeMap.h",
  "source_line": 36,
  "validation_status": "validated"
}