{
  "code": "#include <Availability.h>\n#include <TargetConditionals.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cmath>\n#include <cstddef>\n#include <cstring>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/unaligned_access.h\"\n#include \"absl/base/port.h\"\n#include \"absl/container/fixed_array.h\"\n#include \"absl/hash/internal/city.h\"\n#include \"absl/hash/internal/low_level_hash.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/variant.h\"\n#include \"absl/utility/utility.h\"\n#include <filesystem>  // NOLINT\n#include <string_view>\n\nusing namespace absl;\nusing namespace hash_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05622_execute() {\n    {\n  const int category = std::fpclassify(value);\n  switch (category) {\n    case FP_INFINITE:\n      // Add the sign bit to differentiate between +Inf and -Inf\n      hash_state = H::combine(std::move(hash_state), std::signbit(value));\n      break;\n\n    case FP_NAN:\n    case FP_ZERO:\n    default:\n      // Category is enough for these.\n      break;\n\n    case FP_NORMAL:\n    case FP_SUBNORMAL:\n      // We can't convert `value` directly to double because this would have\n      // undefined behavior if the value is out of range.\n      // std::frexp gives us a value in the range (-1, -.5] or [.5, 1) that is\n      // guaranteed to be in range for `double`. The truncation is\n      // implementation defined, but that works as long as it is deterministic.\n      int exp;\n      auto mantissa = static_cast<double>(std::frexp(value, &exp));\n      hash_state = H::combine(std::move(hash_state), mantissa, exp);\n  }\n\n  return H::combine(std::move(hash_state), category);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05622",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/internal/hash.h",
  "source_line": 392,
  "validation_status": "validated"
}