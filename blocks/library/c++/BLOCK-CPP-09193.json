{
  "code": "{\n  ///   x.f(1, 'a');\n  /// };\n  /// \\endcode\n  ///\n  /// \\c X<int>::f is a FunctionTemplateDecl that describes the function\n  /// template\n  ///\n  /// \\code\n  /// template<typename U> void X<int>::f(int, U);\n  /// \\endcode\n  ///\n  /// which was itself created during the instantiation of \\c X<int>. Calling\n  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will\n  /// retrieve the FunctionTemplateDecl for the original template \\c f within\n  /// the class template \\c X<T>, i.e.,\n  ///\n  /// \\code\n  /// template<typename T>\n  /// template<typename U>\n  /// void X<T>::f(T, U);\n  /// \\endcode\n  RedeclarableTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return getCommonPtr()->InstantiatedFromMember.getPointer();\n  }\n\n  void setInstantiatedFromMemberTemplate(RedeclarableTemplateDecl *TD) {\n    assert(!getCommonPtr()->InstantiatedFromMember.getPointer());\n    getCommonPtr()->InstantiatedFromMember.setPointer(TD);\n  }\n\n  /// Retrieve the \"injected\" template arguments that correspond to the\n  /// template parameters of this template.\n  ///\n  /// Although the C++ standard has no notion of the \"injected\" template\n  /// arguments for a template, the notion is convenient when\n  /// we need to perform substitutions inside the definition of a template.\n  ArrayRef<TemplateArgument> getInjectedTemplateArgs();\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstRedeclarableTemplate && K <= lastRedeclarableTemplate;\n  }\n}",
  "id": "BLOCK-CPP-09193",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 935,
  "validation_status": "validated"
}