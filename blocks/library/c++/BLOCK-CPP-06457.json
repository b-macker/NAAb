{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n// Opaque identifier for a graph node.\nstruct GraphId {\n  uint64_t handle;\n\n  bool operator==(const GraphId& x) const { return handle == x.handle; }\n  bool operator!=(const GraphId& x) const { return handle != x.handle; }\n};\n\n// Return an invalid graph id that will never be assigned by GraphCycles.\ninline GraphId InvalidGraphId() {\n  return GraphId{0};\n}\n\nclass GraphCycles {\n public:\n  GraphCycles();\n  ~GraphCycles();\n\n  // Return the id to use for ptr, assigning one if necessary.\n  // Subsequent calls with the same ptr value will return the same id\n  // until Remove().\n  GraphId GetId(void* ptr);\n\n  // Remove \"ptr\" from the graph.  Its corresponding node and all\n  // edges to and from it are removed.\n  void RemoveNode(void* ptr);\n\n  // Return the pointer associated with id, or nullptr if id is not\n  // currently in the graph.\n  void* Ptr(GraphId id);\n\n  // Attempt to insert an edge from source_node to dest_node.  If the\n  // edge would introduce a cycle, return false without making any\n  // changes. Otherwise add the edge and return true.\n  bool InsertEdge(GraphId source_node, GraphId dest_node);\n\n  // Remove any edge that exists from source_node to dest_node.\n  void RemoveEdge(GraphId source_node, GraphId dest_node);\n\n  // Return whether node exists in the graph.\n  bool HasNode(GraphId node);\n\n  // Return whether there is an edge directly from source_node to dest_node.\n  bool HasEdge(GraphId source_node, GraphId dest_node) const;\n\n  // Return whether dest_node is reachable from source_node\n  // by following edges.\n  bool IsReachable(GraphId source_node, GraphId dest_node) const;\n\n  // Find a path from \"source\" to \"dest\".  If such a path exists,\n  // place the nodes on the path in the array path[], and return\n  // the number of nodes on the path.  If the path is longer than\n  // max_path_len nodes, only the first max_path_len nodes are placed\n  // in path[].  The client should compare the return value with\n  // max_path_len\" to see when this occurs.  If no path exists, return\n  // 0.  Any valid path stored in path[] will start with \"source\" and\n  // end with \"dest\".  There is no guarantee that the path is the\n  // shortest, but no node will appear twice in the path, except the\n  // source and destination node if they are identical; therefore, the\n  // return value is at most one greater than the number of nodes in\n  // the graph.\n  int FindPath(GraphId source, GraphId dest, int max_path_len,\n               GraphId path[]) const;\n\n  // Update the stack trace recorded for id with the current stack\n  // trace if the last time it was updated had a smaller priority\n  // than the priority passed on this call.\n  //\n  // *get_stack_trace is called to get the stack trace.\n  void UpdateStackTrace(GraphId id, int priority,\n                        int (*get_stack_trace)(void**, int));\n\n  // Set *ptr to the beginning of the array that holds the recorded\n  // stack trace for id and return the depth of the stack trace.\n  int GetStackTrace(GraphId id, void*** ptr);\n\n  // Check internal invariants. Crashes on failure, returns true on success.\n  // Expensive: should only be called from graphcycles_test.cc.\n  bool CheckInvariants() const;\n\n  // ----------------------------------------------------\n  struct Rep;\n private:\n  Rep *rep_;      // opaque representation\n  GraphCycles(const GraphCycles&) = delete;\n  GraphCycles& operator=(const GraphCycles&) = delete;\n};\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06457",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/graphcycles.h",
  "source_line": 45,
  "validation_status": "validated"
}