{
  "code": "{\n  friend class ASTStmtReader;\n\n  /// Offsets to the stored exprs.\n  /// This enumeration contains offsets to all the pointers to children\n  /// expressions stored in OMPLoopDirective.\n  /// The first 9 children are necessary for all the loop directives,\n  /// the next 8 are specific to the worksharing ones, and the next 11 are\n  /// used for combined constructs containing two pragmas associated to loops.\n  /// After the fixed children, three arrays of length NumAssociatedLoops are\n  /// allocated: loop counters, their updates and final values.\n  /// PrevLowerBound and PrevUpperBound are used to communicate blocking\n  /// information in composite constructs which require loop blocking\n  /// DistInc is used to generate the increment expression for the distribute\n  /// loop when combined with a further nested loop\n  /// PrevEnsureUpperBound is used as the EnsureUpperBound expression for the\n  /// for loop when combined with a previous distribute loop in the same pragma\n  /// (e.g. 'distribute parallel for')\n  ///\n  enum {\n    IterationVariableOffset = 0,\n    LastIterationOffset = 1,\n    CalcLastIterationOffset = 2,\n    PreConditionOffset = 3,\n    CondOffset = 4,\n    InitOffset = 5,\n    IncOffset = 6,\n    PreInitsOffset = 7,\n    // The '...End' enumerators do not correspond to child expressions - they\n    // specify the offset to the end (and start of the following counters/\n    // updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays).\n    DefaultEnd = 8,\n    // The following 8 exprs are used by worksharing and distribute loops only.\n    IsLastIterVariableOffset = 8,\n    LowerBoundVariableOffset = 9,\n    UpperBoundVariableOffset = 10,\n    StrideVariableOffset = 11,\n    EnsureUpperBoundOffset = 12,\n    NextLowerBoundOffset = 13,\n    NextUpperBoundOffset = 14,\n    NumIterationsOffset = 15,\n    // Offset to the end for worksharing loop directives.\n    WorksharingEnd = 16,\n    PrevLowerBoundVariableOffset = 16,\n    PrevUpperBoundVariableOffset = 17,\n    DistIncOffset = 18,\n    PrevEnsureUpperBoundOffset = 19,\n    CombinedLowerBoundVariableOffset = 20,\n    CombinedUpperBoundVariableOffset = 21,\n    CombinedEnsureUpperBoundOffset = 22,\n    CombinedInitOffset = 23,\n    CombinedConditionOffset = 24,\n    CombinedNextLowerBoundOffset = 25,\n    CombinedNextUpperBoundOffset = 26,\n    CombinedDistConditionOffset = 27,\n    CombinedParForInDistConditionOffset = 28,\n    // Offset to the end (and start of the following\n    // counters/updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays) for combined distribute loop directives.\n    CombinedDistributeEnd = 29,\n  };\n\n  /// Get the counters storage.\n  MutableArrayRef<Expr *> getCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind())]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the private counters storage.\n  MutableArrayRef<Expr *> getPrivateCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             2 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getUpdates() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             3 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the final counter updates storage.\n  MutableArrayRef<Expr *> getFinals() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             4 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent counters storage.\n  MutableArrayRef<Expr *> getDependentCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             5 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent inits storage.\n  MutableArrayRef<Expr *> getDependentInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             6 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the finals conditions storage.\n  MutableArrayRef<Expr *> getFinalsConditions() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             7 * getLoopsNumber()]);\n    return llvm::MutableArrayRef(Storage, getLoopsNumber());\n  }\n\nprotected:\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops from 'collapse' clause.\n  ///\n  OMPLoopDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                   SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopBasedDirective(SC, Kind, StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Offset to the start of children expression arrays.\n  static unsigned getArraysOffset(OpenMPDirectiveKind Kind) {\n    if (isOpenMPLoopBoundSharingDirective(Kind))\n      return CombinedDistributeEnd;\n    if (isOpenMPWorksharingDirective(Kind) || isOpenMPTaskLoopDirective(Kind) ||\n        isOpenMPGenericLoopDirective(Kind) || isOpenMPDistributeDirective(Kind))\n      return WorksharingEnd;\n    return DefaultEnd;\n  }\n\n  /// Children number.\n  static unsigned numLoopChildren(unsigned CollapsedNum,\n                                  OpenMPDirectiveKind Kind) {\n    return getArraysOffset(Kind) +\n           8 * CollapsedNum; // Counters, PrivateCounters, Inits,\n                             // Updates, Finals, DependentCounters,\n                             // DependentInits, FinalsConditions.\n  }\n\n  void setIterationVariable(Expr *IV) {\n    Data->getChildren()[IterationVariableOffset] = IV;\n  }\n  void setLastIteration(Expr *LI) {\n    Data->getChildren()[LastIterationOffset] = LI;\n  }\n  void setCalcLastIteration(Expr *CLI) {\n    Data->getChildren()[CalcLastIterationOffset] = CLI;\n  }\n  void setPreCond(Expr *PC) { Data->getChildren()[PreConditionOffset] = PC; }\n  void setCond(Expr *Cond) { Data->getChildren()[CondOffset] = Cond; }\n  void setInit(Expr *Init) { Data->getChildren()[InitOffset] = Init; }\n  void setInc(Expr *Inc) { Data->getChildren()[IncOffset] = Inc; }\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n  void setIsLastIterVariable(Expr *IL) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[IsLastIterVariableOffset] = IL;\n  }\n  void setLowerBoundVariable(Expr *LB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[LowerBoundVariableOffset] = LB;\n  }\n  void setUpperBoundVariable(Expr *UB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[UpperBoundVariableOffset] = UB;\n  }\n  void setStrideVariable(Expr *ST) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[StrideVariableOffset] = ST;\n  }\n  void setEnsureUpperBound(Expr *EUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[EnsureUpperBoundOffset] = EUB;\n  }\n  void setNextLowerBound(Expr *NLB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextLowerBoundOffset] = NLB;\n  }\n  void setNextUpperBound(Expr *NUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextUpperBoundOffset] = NUB;\n  }\n  void setNumIterations(Expr *NI) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NumIterationsOffset] = NI;\n  }\n  void setPrevLowerBoundVariable(Expr *PrevLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevLowerBoundVariableOffset] = PrevLB;\n  }\n  void setPrevUpperBoundVariable(Expr *PrevUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevUpperBoundVariableOffset] = PrevUB;\n  }\n  void setDistInc(Expr *DistInc) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[DistIncOffset] = DistInc;\n  }\n  void setPrevEnsureUpperBound(Expr *PrevEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevEnsureUpperBoundOffset] = PrevEUB;\n  }\n  void setCombinedLowerBoundVariable(Expr *CombLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedLowerBoundVariableOffset] = CombLB;\n  }\n  void setCombinedUpperBoundVariable(Expr *CombUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedUpperBoundVariableOffset] = CombUB;\n  }\n  void setCombinedEnsureUpperBound(Expr *CombEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedEnsureUpperBoundOffset] = CombEUB;\n  }\n  void setCombinedInit(Expr *CombInit) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedInitOffset] = CombInit;\n  }\n  void setCombinedCond(Expr *CombCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedConditionOffset] = CombCond;\n  }\n  void setCombinedNextLowerBound(Expr *CombNLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextLowerBoundOffset] = CombNLB;\n  }\n  void setCombinedNextUpperBound(Expr *CombNUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextUpperBoundOffset] = CombNUB;\n  }\n  void setCombinedDistCond(Expr *CombDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedDistConditionOffset] = CombDistCond;\n  }\n  void setCombinedParForInDistCond(Expr *CombParForInDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedParForInDistConditionOffset] =\n        CombParForInDistCond;\n  }\n  void setCounters(ArrayRef<Expr *> A);\n  void setPrivateCounters(ArrayRef<Expr *> A);\n  void setInits(ArrayRef<Expr *> A);\n  void setUpdates(ArrayRef<Expr *> A);\n  void setFinals(ArrayRef<Expr *> A);\n  void setDependentCounters(ArrayRef<Expr *> A);\n  void setDependentInits(ArrayRef<Expr *> A);\n  void setFinalsConditions(ArrayRef<Expr *> A);\n\npublic:\n  Expr *getIterationVariable() const {\n    return cast<Expr>(Data->getChildren()[IterationVariableOffset]);\n  }\n  Expr *getLastIteration() const {\n    return cast<Expr>(Data->getChildren()[LastIterationOffset]);\n  }\n  Expr *getCalcLastIteration() const {\n    return cast<Expr>(Data->getChildren()[CalcLastIterationOffset]);\n  }\n  Expr *getPreCond() const {\n    return cast<Expr>(Data->getChildren()[PreConditionOffset]);\n  }\n  Expr *getCond() const { return cast<Expr>(Data->getChildren()[CondOffset]); }\n  Expr *getInit() const { return cast<Expr>(Data->getChildren()[InitOffset]); }\n  Expr *getInc() const { return cast<Expr>(Data->getChildren()[IncOffset]); }\n  const Stmt *getPreInits() const {\n    return Data->getChildren()[PreInitsOffset];\n  }\n  Stmt *getPreInits() { return Data->getChildren()[PreInitsOffset]; }\n  Expr *getIsLastIterVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[IsLastIterVariableOffset]);\n  }\n  Expr *getLowerBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[LowerBoundVariableOffset]);\n  }\n  Expr *getUpperBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[UpperBoundVariableOffset]);\n  }\n  Expr *getStrideVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[StrideVariableOffset]);\n  }\n  Expr *getEnsureUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[EnsureUpperBoundOffset]);\n  }\n  Expr *getNextLowerBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextLowerBoundOffset]);\n  }\n  Expr *getNextUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextUpperBoundOffset]);\n  }\n  Expr *getNumIterations() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPGenericLoopDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NumIterationsOffset]);\n  }\n  Expr *getPrevLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevLowerBoundVariableOffset]);\n  }\n  Expr *getPrevUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevUpperBoundVariableOffset]);\n  }\n  Expr *getDistInc() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[DistIncOffset]);\n  }\n  Expr *getPrevEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedLowerBoundVariableOffset]);\n  }\n  Expr *getCombinedUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedUpperBoundVariableOffset]);\n  }\n  Expr *getCombinedEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedInit() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedInitOffset]);\n  }\n  Expr *getCombinedCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedConditionOffset]);\n  }\n  Expr *getCombinedNextLowerBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextLowerBoundOffset]);\n  }\n  Expr *getCombinedNextUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextUpperBoundOffset]);\n  }\n  Expr *getCombinedDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedDistConditionOffset]);\n  }\n  Expr *getCombinedParForInDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedParForInDistConditionOffset]);\n  }\n  Stmt *getBody();\n  const Stmt *getBody() const {\n    return const_cast<OMPLoopDirective *>(this)->getBody();\n  }\n\n  ArrayRef<Expr *> counters() { return getCounters(); }\n\n  ArrayRef<Expr *> counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getCounters();\n  }\n\n  ArrayRef<Expr *> private_counters() { return getPrivateCounters(); }\n\n  ArrayRef<Expr *> private_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getPrivateCounters();\n  }\n\n  ArrayRef<Expr *> inits() { return getInits(); }\n\n  ArrayRef<Expr *> inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getInits();\n  }\n\n  ArrayRef<Expr *> updates() { return getUpdates(); }\n\n  ArrayRef<Expr *> updates() const {\n    return const_cast<OMPLoopDirective *>(this)->getUpdates();\n  }\n\n  ArrayRef<Expr *> finals() { return getFinals(); }\n\n  ArrayRef<Expr *> finals() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinals();\n  }\n\n  ArrayRef<Expr *> dependent_counters() { return getDependentCounters(); }\n\n  ArrayRef<Expr *> dependent_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentCounters();\n  }\n\n  ArrayRef<Expr *> dependent_inits() { return getDependentInits(); }\n\n  ArrayRef<Expr *> dependent_inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentInits();\n  }\n\n  ArrayRef<Expr *> finals_conditions() { return getFinalsConditions(); }\n\n  ArrayRef<Expr *> finals_conditions() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinalsConditions();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass ||\n           T->getStmtClass() == OMPForDirectiveClass ||\n           T->getStmtClass() == OMPForSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelForDirectiveClass ||\n           T->getStmtClass() == OMPParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPMaskedTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPMaskedTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPGenericLoopDirectiveClass ||\n           T->getStmtClass() == OMPTeamsGenericLoopDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsGenericLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelGenericLoopDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelGenericLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMaskedTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMaskedTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n}",
  "id": "BLOCK-CPP-13363",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 1003,
  "validation_status": "validated"
}