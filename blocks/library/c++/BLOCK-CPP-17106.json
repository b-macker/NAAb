{
  "code": "{\n\n/// The basic abstraction for the target C++ ABI.\nclass TargetCXXABI {\npublic:\n  /// The basic C++ ABI kind.\n  enum Kind {\n#define CXXABI(Name, Str) Name,\n#include \"TargetCXXABI.def\"\n  };\n\nprivate:\n  // Right now, this class is passed around as a cheap value type.\n  // If you add more members, especially non-POD members, please\n  // audit the users to pass it by reference instead.\n  Kind TheKind;\n\n  static const auto &getABIMap() {\n    static llvm::StringMap<Kind> ABIMap = {\n#define CXXABI(Name, Str) {Str, Name},\n#include \"TargetCXXABI.def\"\n    };\n    return ABIMap;\n  }\n\n  static const auto &getSpellingMap() {\n    static std::map<Kind, std::string> SpellingMap = {\n#define CXXABI(Name, Str) {Name, Str},\n#include \"TargetCXXABI.def\"\n    };\n    return SpellingMap;\n  }\n\npublic:\n  static Kind getKind(StringRef Name) { return getABIMap().lookup(Name); }\n  static const auto &getSpelling(Kind ABIKind) {\n    return getSpellingMap().find(ABIKind)->second;\n  }\n  static bool isABI(StringRef Name) { return getABIMap().contains(Name); }\n\n  // Return true if this target should use the relative vtables C++ ABI by\n  // default.\n  static bool usesRelativeVTables(const llvm::Triple &T) {\n    return T.isOSFuchsia();\n  }\n\n  /// A bogus initialization of the platform ABI.\n  TargetCXXABI() : TheKind(GenericItanium) {}\n\n  TargetCXXABI(Kind kind) : TheKind(kind) {}\n\n  void set(Kind kind) {\n    TheKind = kind;\n  }\n\n  Kind getKind() const { return TheKind; }\n\n  // Check that the kind provided by the fc++-abi flag is supported on this\n  // target. Users who want to experiment using different ABIs on specific\n  // platforms can change this freely, but this function should be conservative\n  // enough such that not all ABIs are allowed on all platforms. For example, we\n  // probably don't want to allow usage of an ARM ABI on an x86 architecture.\n  static bool isSupportedCXXABI(const llvm::Triple &T, Kind Kind) {\n    switch (Kind) {\n    case GenericARM:\n      return T.isARM() || T.isAArch64();\n\n    case iOS:\n    case WatchOS:\n    case AppleARM64:\n      return T.isOSDarwin();\n\n    case Fuchsia:\n      return T.isOSFuchsia();\n\n    case GenericAArch64:\n      return T.isAArch64();\n\n    case GenericMIPS:\n      return T.isMIPS();\n\n    case WebAssembly:\n      return T.isWasm();\n\n    case XL:\n      return T.isOSAIX();\n\n    case GenericItanium:\n      return true;\n\n    case Microsoft:\n      return T.isKnownWindowsMSVCEnvironment();\n    }\n    llvm_unreachable(\"invalid CXXABI kind\");\n  };\n\n  /// Does this ABI generally fall into the Itanium family of ABIs?\n  bool isItaniumFamily() const {\n    switch (getKind()) {\n#define CXXABI(Name, Str)\n#define ITANIUM_CXXABI(Name, Str) case Name:\n#include \"TargetCXXABI.def\"\n      return true;\n\n    default:\n      return false;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Is this ABI an MSVC-compatible ABI?\n  bool isMicrosoft() const {\n    switch (getKind()) {\n#define CXXABI(Name, Str)\n#define MICROSOFT_CXXABI(Name, Str) case Name:\n#include \"TargetCXXABI.def\"\n      return true;\n\n    default:\n      return false;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Are member functions differently aligned?\n  ///\n  /// Many Itanium-style C++ ABIs require member functions to be aligned, so\n  /// that a pointer to such a function is guaranteed to have a zero in the\n  /// least significant bit, so that pointers to member functions can use that\n  /// bit to distinguish between virtual and non-virtual functions. However,\n  /// some Itanium-style C++ ABIs differentiate between virtual and non-virtual\n  /// functions via other means, and consequently don't require that member\n  /// functions be aligned.\n  bool areMemberFunctionsAligned() const {\n    switch (getKind()) {\n    case WebAssembly:\n      // WebAssembly doesn't require any special alignment for member functions.\n      return false;\n    case AppleARM64:\n    case Fuchsia:\n    case GenericARM:\n    case GenericAArch64:\n    case GenericMIPS:\n      // TODO: ARM-style pointers to member functions put the discriminator in\n      //       the this adjustment, so they don't require functions to have any\n      //       special alignment and could therefore also return false.\n    case GenericItanium:\n    case iOS:\n    case WatchOS:\n    case Microsoft:\n    case XL:\n      return true;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// Are arguments to a call destroyed left to right in the callee?\n  /// This is a fundamental language change, since it implies that objects\n  /// passed by value do *not* live to the end of the full expression.\n  /// Temporaries passed to a function taking a const reference live to the end\n  /// of the full expression as usual.  Both the caller and the callee must\n  /// have access to the destructor, while only the caller needs the\n  /// destructor if this is false.\n  bool areArgsDestroyedLeftToRightInCallee() const {\n    return isMicrosoft();\n  }\n\n  /// Does this ABI have different entrypoints for complete-object\n  /// and base-subobject constructors?\n  bool hasConstructorVariants() const {\n    return isItaniumFamily();\n  }\n\n  /// Does this ABI allow virtual bases to be primary base classes?\n  bool hasPrimaryVBases() const {\n    return isItaniumFamily();\n  }\n\n  /// Does this ABI use key functions?  If so, class data such as the\n  /// vtable is emitted with strong linkage by the TU containing the key\n  /// function.\n  bool hasKeyFunctions() const {\n    return isItaniumFamily();\n  }\n\n  /// Can an out-of-line inline function serve as a key function?\n  ///\n  /// This flag is only useful in ABIs where type data (for example,\n  /// vtables and type_info objects) are emitted only after processing\n  /// the definition of a special \"key\" virtual function.  (This is safe\n  /// because the ODR requires that every virtual function be defined\n  /// somewhere in a program.)  This usually permits such data to be\n  /// emitted in only a single object file, as opposed to redundantly\n  /// in every object file that requires it.\n  ///\n  /// One simple and common definition of \"key function\" is the first\n  /// virtual function in the class definition which is not defined there.\n  /// This rule works very well when that function has a non-inline\n  /// definition in some non-header file.  Unfortunately, when that\n  /// function is defined inline, this rule requires the type data\n  /// to be emitted weakly, as if there were no key function.\n  ///\n  /// The ARM ABI observes that the ODR provides an additional guarantee:\n  /// a virtual function is always ODR-used, so if it is defined inline,\n  /// that definition must appear in every translation unit that defines\n  /// the class.  Therefore, there is no reason to allow such functions\n  /// to serve as key functions.\n  ///\n  /// Because this changes the rules for emitting type data,\n  /// it can cause type data to be emitted with both weak and strong\n  /// linkage, which is not allowed on all platforms.  Therefore,\n  /// exploiting this observation requires an ABI break and cannot be\n  /// done on a generic Itanium platform.\n  bool canKeyFunctionBeInline() const {\n    switch (getKind()) {\n    case AppleARM64:\n    case Fuchsia:\n    case GenericARM:\n    case WebAssembly:\n    case WatchOS:\n      return false;\n\n    case GenericAArch64:\n    case GenericItanium:\n    case iOS:   // old iOS compilers did not follow this rule\n    case Microsoft:\n    case GenericMIPS:\n    case XL:\n      return true;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  /// When is record layout allowed to allocate objects in the tail\n  /// padding of a base class?\n  ///\n  /// This decision cannot be changed without breaking platform ABI\n  /// compatibility. In ISO C++98, tail padding reuse was only permitted for\n  /// non-POD base classes, but that restriction was removed retroactively by\n  /// DR 43, and tail padding reuse is always permitted in all de facto C++\n  /// language modes. However, many platforms use a variant of the old C++98\n  /// rule for compatibility.\n  enum TailPaddingUseRules {\n    /// The tail-padding of a base class is always theoretically\n    /// available, even if it's POD.\n    AlwaysUseTailPadding,\n\n    /// Only allocate objects in the tail padding of a base class if\n    /// the base class is not POD according to the rules of C++ TR1.\n    UseTailPaddingUnlessPOD03,\n\n    /// Only allocate objects in the tail padding of a base class if\n    /// the base class is not POD according to the rules of C++11.\n    UseTailPaddingUnlessPOD11\n  };\n  TailPaddingUseRules getTailPaddingUseRules() const {\n    switch (getKind()) {\n    // To preserve binary compatibility, the generic Itanium ABI has\n    // permanently locked the definition of POD to the rules of C++ TR1,\n    // and that trickles down to derived ABIs.\n    case GenericItanium:\n    case GenericAArch64:\n    case GenericARM:\n    case iOS:\n    case GenericMIPS:\n    case XL:\n      return UseTailPaddingUnlessPOD03;\n\n    // AppleARM64 and WebAssembly use the C++11 POD rules.  They do not honor\n    // the Itanium exception about classes with over-large bitfields.\n    case AppleARM64:\n    case Fuchsia:\n    case WebAssembly:\n    case WatchOS:\n      return UseTailPaddingUnlessPOD11;\n\n    // MSVC always allocates fields in the tail-padding of a base class\n    // subobject, even if they're POD.\n    case Microsoft:\n      return AlwaysUseTailPadding;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n\n  friend bool operator==(const TargetCXXABI &left, const TargetCXXABI &right) {\n    return left.getKind() == right.getKind();\n  }\n\n  friend bool operator!=(const TargetCXXABI &left, const TargetCXXABI &right) {\n    return !(left == right);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-17106",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/TargetCXXABI.h",
  "source_line": 25,
  "validation_status": "validated"
}