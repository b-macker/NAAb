{
  "code": "#include \"absl/base/config.h\"\n#include <compare>  // IWYU pragma: export\n#include <type_traits>\n#include \"absl/meta/type_traits.h\"\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <type_traits>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/meta/type_traits.h\"\n\nusing namespace absl;\nusing namespace compare_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04478_execute() {\n    {\n\nusing value_type = int8_t;\n\nclass OnlyLiteralZero {\n public:\n#if ABSL_HAVE_ATTRIBUTE(enable_if)\n  // On clang, we can avoid triggering modernize-use-nullptr by only enabling\n  // this overload when the value is a compile time integer constant equal to 0.\n  //\n  // In c++20, this could be a static_assert in a consteval function.\n  constexpr OnlyLiteralZero(int n)  // NOLINT\n      __attribute__((enable_if(n == 0, \"Only literal `0` is allowed.\"))) {}\n#else  // ABSL_HAVE_ATTRIBUTE(enable_if)\n  // Accept only literal zero since it can be implicitly converted to a pointer\n  // to member type. nullptr constants will be caught by the other constructor\n  // which accepts a nullptr_t.\n  //\n  // This constructor is not used for clang since it triggers\n  // modernize-use-nullptr.\n  constexpr OnlyLiteralZero(int OnlyLiteralZero::*) noexcept {}  // NOLINT\n#endif\n\n  // Fails compilation when `nullptr` or integral type arguments other than\n  // `int` are passed. This constructor doesn't accept `int` because literal `0`\n  // has type `int`. Literal `0` arguments will be implicitly converted to\n  // `std::nullptr_t` and accepted by the above constructor, while other `int`\n  // arguments will fail to be converted and cause compilation failure.\n  template <typename T, typename = typename std::enable_if<\n                            std::is_same<T, std::nullptr_t>::value ||\n                            (std::is_integral<T>::value &&\n                             !std::is_same<T, int>::value)>::type>\n  OnlyLiteralZero(T) {  // NOLINT\n    static_assert(sizeof(T) < 0, \"Only literal `0` is allowed.\");\n  }\n};\n\nenum class eq : value_type {\n  equal = 0,\n  equivalent = equal,\n  nonequal = 1,\n  nonequivalent = nonequal,\n};\n\nenum class ord : value_type { less = -1, greater = 1 };\n\nenum class ncmp : value_type { unordered = -127 };\n\n// Define macros to allow for creation or emulation of C++17 inline variables\n// based on whether the feature is supported. Note: we can't use\n// ABSL_INTERNAL_INLINE_CONSTEXPR here because the variables here are of\n// incomplete types so they need to be defined after the types are complete.\n#ifdef __cpp_inline_variables\n\n// A no-op expansion that can be followed by a semicolon at class level.\n#define ABSL_COMPARE_INLINE_BASECLASS_DECL(name) static_assert(true, \"\")\n\n#define ABSL_COMPARE_INLINE_SUBCLASS_DECL(type, name) \\\n  static const type name\n\n#define ABSL_COMPARE_INLINE_INIT(type, name, init) \\\n  inline constexpr type type::name(init)\n\n#else  // __cpp_inline_variables\n\n#define ABSL_COMPARE_INLINE_BASECLASS_DECL(name) \\\n  ABSL_CONST_INIT static const T name\n\n// A no-op expansion that can be followed by a semicolon at class level.\n#define ABSL_COMPARE_INLINE_SUBCLASS_DECL(type, name) static_assert(true, \"\")\n\n#define ABSL_COMPARE_INLINE_INIT(type, name, init) \\\n  template <typename T>                            \\\n  const T compare_internal::type##_base<T>::name(init)\n\n#endif  // __cpp_inline_variables\n\n// These template base classes allow for defining the values of the constants\n// in the header file (for performance) without using inline variables (which\n// aren't available in C++11).\ntemplate <typename T>\nstruct partial_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(unordered);\n};\n\ntemplate <typename T>\nstruct weak_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n};\n\ntemplate <typename T>\nstruct strong_ordering_base {\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(less);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equal);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(equivalent);\n  ABSL_COMPARE_INLINE_BASECLASS_DECL(greater);\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04478",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/compare.h",
  "source_line": 66,
  "validation_status": "validated"
}