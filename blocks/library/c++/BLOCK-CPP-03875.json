{
  "code": "#include <limits>\n#include <type_traits>\n#include <utility>\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/random/distributions.h\"\n#include \"absl/random/internal/mock_overload_set.h\"\n#include \"absl/random/mocking_bit_gen.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03875_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// absl::MockUniform\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Uniform.\n//\n// `absl::MockUniform` is a class template used in conjunction with Googletest's\n// `ON_CALL()` and `EXPECT_CALL()` macros. To use it, default-construct an\n// instance of it inside `ON_CALL()` or `EXPECT_CALL()`, and use `Call(...)` the\n// same way one would define mocks on a Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockUniform<uint32_t>(), Call(mock))\n//     .WillOnce(Return(123456));\n//  auto x = absl::Uniform<uint32_t>(mock);\n//  assert(x == 123456)\n//\ntemplate <typename R>\nusing MockUniform = random_internal::MockOverloadSet<\n    random_internal::UniformDistributionWrapper<R>,\n    R(IntervalClosedOpenTag, MockingBitGen&, R, R),\n    R(IntervalClosedClosedTag, MockingBitGen&, R, R),\n    R(IntervalOpenOpenTag, MockingBitGen&, R, R),\n    R(IntervalOpenClosedTag, MockingBitGen&, R, R), R(MockingBitGen&, R, R),\n    R(MockingBitGen&)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockBernoulli\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Bernoulli.\n//\n// `absl::MockBernoulli` is a class used in conjunction with Googletest's\n// `ON_CALL()` and `EXPECT_CALL()` macros. To use it, default-construct an\n// instance of it inside `ON_CALL()` or `EXPECT_CALL()`, and use `Call(...)` the\n// same way one would define mocks on a Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockBernoulli(), Call(mock, testing::_))\n//     .WillOnce(Return(false));\n//  assert(absl::Bernoulli(mock, 0.5) == false);\n//\nusing MockBernoulli =\n    random_internal::MockOverloadSet<absl::bernoulli_distribution,\n                                     bool(MockingBitGen&, double)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockBeta\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Beta.\n//\n// `absl::MockBeta` is a class used in conjunction with Googletest's `ON_CALL()`\n// and `EXPECT_CALL()` macros. To use it, default-construct an instance of it\n// inside `ON_CALL()` or `EXPECT_CALL()`, and use `Call(...)` the same way one\n// would define mocks on a Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockBeta(), Call(mock, 3.0, 2.0))\n//     .WillOnce(Return(0.567));\n//  auto x = absl::Beta<double>(mock, 3.0, 2.0);\n//  assert(x == 0.567);\n//\ntemplate <typename RealType>\nusing MockBeta =\n    random_internal::MockOverloadSet<absl::beta_distribution<RealType>,\n                                     RealType(MockingBitGen&, RealType,\n                                              RealType)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockExponential\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Exponential.\n//\n// `absl::MockExponential` is a class template used in conjunction with\n// Googletest's `ON_CALL()` and `EXPECT_CALL()` macros. To use it,\n// default-construct an instance of it inside `ON_CALL()` or `EXPECT_CALL()`,\n// and use `Call(...)` the same way one would define mocks on a\n// Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockExponential<double>(), Call(mock, 0.5))\n//     .WillOnce(Return(12.3456789));\n//  auto x = absl::Exponential<double>(mock, 0.5);\n//  assert(x == 12.3456789)\n//\ntemplate <typename RealType>\nusing MockExponential =\n    random_internal::MockOverloadSet<absl::exponential_distribution<RealType>,\n                                     RealType(MockingBitGen&, RealType)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockGaussian\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Gaussian.\n//\n// `absl::MockGaussian` is a class template used in conjunction with\n// Googletest's `ON_CALL()` and `EXPECT_CALL()` macros. To use it,\n// default-construct an instance of it inside `ON_CALL()` or `EXPECT_CALL()`,\n// and use `Call(...)` the same way one would define mocks on a\n// Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockGaussian<double>(), Call(mock, 16.3, 3.3))\n//     .WillOnce(Return(12.3456789));\n//  auto x = absl::Gaussian<double>(mock, 16.3, 3.3);\n//  assert(x == 12.3456789)\n//\ntemplate <typename RealType>\nusing MockGaussian =\n    random_internal::MockOverloadSet<absl::gaussian_distribution<RealType>,\n                                     RealType(MockingBitGen&, RealType,\n                                              RealType)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockLogUniform\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::LogUniform.\n//\n// `absl::MockLogUniform` is a class template used in conjunction with\n// Googletest's `ON_CALL()` and `EXPECT_CALL()` macros. To use it,\n// default-construct an instance of it inside `ON_CALL()` or `EXPECT_CALL()`,\n// and use `Call(...)` the same way one would define mocks on a\n// Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockLogUniform<int>(), Call(mock, 10, 10000, 10))\n//     .WillOnce(Return(1221));\n//  auto x = absl::LogUniform<int>(mock, 10, 10000, 10);\n//  assert(x == 1221)\n//\ntemplate <typename IntType>\nusing MockLogUniform = random_internal::MockOverloadSet<\n    absl::log_uniform_int_distribution<IntType>,\n    IntType(MockingBitGen&, IntType, IntType, IntType)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockPoisson\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Poisson.\n//\n// `absl::MockPoisson` is a class template used in conjunction with Googletest's\n// `ON_CALL()` and `EXPECT_CALL()` macros. To use it, default-construct an\n// instance of it inside `ON_CALL()` or `EXPECT_CALL()`, and use `Call(...)` the\n// same way one would define mocks on a Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockPoisson<int>(), Call(mock, 2.0))\n//     .WillOnce(Return(1221));\n//  auto x = absl::Poisson<int>(mock, 2.0);\n//  assert(x == 1221)\n//\ntemplate <typename IntType>\nusing MockPoisson =\n    random_internal::MockOverloadSet<absl::poisson_distribution<IntType>,\n                                     IntType(MockingBitGen&, double)>;\n\n// -----------------------------------------------------------------------------\n// absl::MockZipf\n// -----------------------------------------------------------------------------\n//\n// Matches calls to absl::Zipf.\n//\n// `absl::MockZipf` is a class template used in conjunction with Googletest's\n// `ON_CALL()` and `EXPECT_CALL()` macros. To use it, default-construct an\n// instance of it inside `ON_CALL()` or `EXPECT_CALL()`, and use `Call(...)` the\n// same way one would define mocks on a Googletest `MockFunction()`.\n//\n// Example:\n//\n//  absl::MockingBitGen mock;\n//  EXPECT_CALL(absl::MockZipf<int>(), Call(mock, 1000000, 2.0, 1.0))\n//     .WillOnce(Return(1221));\n//  auto x = absl::Zipf<int>(mock, 1000000, 2.0, 1.0);\n//  assert(x == 1221)\n//\ntemplate <typename IntType>\nusing MockZipf =\n    random_internal::MockOverloadSet<absl::zipf_distribution<IntType>,\n                                     IntType(MockingBitGen&, IntType, double,\n                                             double)>;\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03875",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/mock_distributions.h",
  "source_line": 60,
  "validation_status": "validated"
}