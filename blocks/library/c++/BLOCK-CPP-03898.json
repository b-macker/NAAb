{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// absl::SeedSeq\n// -----------------------------------------------------------------------------\n//\n// `absl::SeedSeq` constructs a seed sequence according to [rand.req.seedseq]\n// for use within bit generators. `absl::SeedSeq`, unlike `std::seed_seq`\n// additionally salts the generated seeds with extra implementation-defined\n// entropy. For that reason, you can use `absl::SeedSeq` in combination with\n// standard library bit generators (e.g. `std::mt19937`) to introduce\n// non-determinism in your seeds.\n//\n// Example:\n//\n//   absl::SeedSeq my_seed_seq({a, b, c});\n//   std::mt19937 my_bitgen(my_seed_seq);\n//\nusing SeedSeq = random_internal::SaltedSeedSeq<std::seed_seq>;\n\n// -----------------------------------------------------------------------------\n// absl::CreateSeedSeqFrom(bitgen*)\n// -----------------------------------------------------------------------------\n//\n// Constructs a seed sequence conforming to [rand.req.seedseq] using variates\n// produced by a provided bit generator.\n//\n// You should generally avoid direct construction of seed sequences, but\n// use-cases for reuse of a seed sequence to construct identical bit generators\n// may be helpful (eg. replaying a simulation whose state is derived from bit\n// generator values).\n//\n// If bitgen == nullptr, then behavior is undefined.\n//\n// Example:\n//\n//   absl::BitGen my_bitgen;\n//   auto seed_seq = absl::CreateSeedSeqFrom(&my_bitgen);\n//   absl::BitGen new_engine(seed_seq); // derived from my_bitgen, but not\n//                                      // correlated.\n//\ntemplate <typename URBG>\nSeedSeq CreateSeedSeqFrom(URBG* urbg) {\n  SeedSeq::result_type\n      seed_material[random_internal::kEntropyBlocksNeeded];\n\n  if (!random_internal::ReadSeedMaterialFromURBG(\n          urbg, absl::MakeSpan(seed_material))) {\n    random_internal::ThrowSeedGenException();\n  }\n  return SeedSeq(std::begin(seed_material), std::end(seed_material));\n}\n\n// -----------------------------------------------------------------------------\n// absl::MakeSeedSeq()\n// -----------------------------------------------------------------------------\n//\n// Constructs an `absl::SeedSeq` salting the generated values using\n// implementation-defined entropy. The returned sequence can be used to create\n// equivalent bit generators correlated using this sequence.\n//\n// Example:\n//\n//   auto my_seed_seq = absl::MakeSeedSeq();\n//   std::mt19937 rng1(my_seed_seq);\n//   std::mt19937 rng2(my_seed_seq);\n//   EXPECT_EQ(rng1(), rng2());\n//\nSeedSeq MakeSeedSeq();\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03898",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/seed_sequences.h",
  "source_line": 37,
  "validation_status": "validated"
}