{
  "code": "{\n\n// PeriodicSamplerBase provides the basic period sampler implementation.\n//\n// This is the base class for the templated PeriodicSampler class, which holds\n// a global std::atomic value identified by a user defined tag, such that\n// each specific PeriodSampler implementation holds its own global period.\n//\n// PeriodicSamplerBase is thread-compatible except where stated otherwise.\nclass PeriodicSamplerBase {\n public:\n  // PeriodicSamplerBase is trivial / copyable / movable / destructible.\n  PeriodicSamplerBase() = default;\n  PeriodicSamplerBase(PeriodicSamplerBase&&) = default;\n  PeriodicSamplerBase(const PeriodicSamplerBase&) = default;\n\n  // Returns true roughly once every `period` calls. This is established by a\n  // randomly picked `stride` that is counted down on each call to `Sample`.\n  // This stride is picked such that the probability of `Sample()` returning\n  // true is 1 in `period`.\n  inline bool Sample() noexcept;\n\n  // The below methods are intended for optimized use cases where the\n  // size of the inlined fast path code is highly important. Applications\n  // should use the `Sample()` method unless they have proof that their\n  // specific use case requires the optimizations offered by these methods.\n  //\n  // An example of such a use case is SwissTable sampling. All sampling checks\n  // are in inlined SwissTable methods, and the number of call sites is huge.\n  // In this case, the inlined code size added to each translation unit calling\n  // SwissTable methods is non-trivial.\n  //\n  // The `SubtleMaybeSample()` function spuriously returns true even if the\n  // function should not be sampled, applications MUST match each call to\n  // 'SubtleMaybeSample()' returning true with a `SubtleConfirmSample()` call,\n  // and use the result of the latter as the sampling decision.\n  // In other words: the code should logically be equivalent to:\n  //\n  //    if (SubtleMaybeSample() && SubtleConfirmSample()) {\n  //      // Sample this call\n  //    }\n  //\n  // In the 'inline-size' optimized case, the `SubtleConfirmSample()` call can\n  // be placed out of line, for example, the typical use case looks as follows:\n  //\n  //   // --- frobber.h -----------\n  //   void FrobberSampled();\n  //\n  //   inline void FrobberImpl() {\n  //     // ...\n  //   }\n  //\n  //   inline void Frobber() {\n  //     if (ABSL_PREDICT_FALSE(sampler.SubtleMaybeSample())) {\n  //       FrobberSampled();\n  //     } else {\n  //       FrobberImpl();\n  //     }\n  //   }\n  //\n  //   // --- frobber.cc -----------\n  //   void FrobberSampled() {\n  //     if (!sampler.SubtleConfirmSample())) {\n  //       // Spurious false positive\n  //       FrobberImpl();\n  //       return;\n  //     }\n  //\n  //     // Sampled execution\n  //     // ...\n  //   }\n  inline bool SubtleMaybeSample() noexcept;\n  bool SubtleConfirmSample() noexcept;\n\n protected:\n  // We explicitly don't use a virtual destructor as this class is never\n  // virtually destroyed, and it keeps the class trivial, which avoids TLS\n  // prologue and epilogue code for our TLS instances.\n  ~PeriodicSamplerBase() = default;\n\n  // Returns the next stride for our sampler.\n  // This function is virtual for testing purposes only.\n  virtual int64_t GetExponentialBiased(int period) noexcept;\n\n private:\n  // Returns the current period of this sampler. Thread-safe.\n  virtual int period() const noexcept = 0;\n\n  // Keep and decrement stride_ as an unsigned integer, but compare the value\n  // to zero casted as a signed int. clang and msvc do not create optimum code\n  // if we use signed for the combined decrement and sign comparison.\n  //\n  // Below 3 alternative options, all compiles generate the best code\n  // using the unsigned increment <---> signed int comparison option.\n  //\n  // Option 1:\n  //   int64_t stride_;\n  //   if (ABSL_PREDICT_TRUE(++stride_ < 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/R5MzzA\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/z7NZAt\n  //   Clang x64 (BAD): https://gcc.godbolt.org/z/t4gPsd\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/rE6s8W\n  //   MSVC  x64 (OK) : https://gcc.godbolt.org/z/ARMXqS\n  //\n  // Option 2:\n  //   int64_t stride_ = 0;\n  //   if (ABSL_PREDICT_TRUE(--stride_ >= 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/jSQxYK\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/VJdYaA\n  //   Clang x64 (BAD): https://gcc.godbolt.org/z/Xm4NjX\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/4snaFd\n  //   MSVC  x64 (BAD): https://gcc.godbolt.org/z/BgnEKE\n  //\n  // Option 3:\n  //   uint64_t stride_;\n  //   if (ABSL_PREDICT_TRUE(static_cast<int64_t>(++stride_) < 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/bFbfPy\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/S9KkUE\n  //   Clang x64 (OK) : https://gcc.godbolt.org/z/UYzRb4\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/ptTNfD\n  //   MSVC  x64 (OK) : https://gcc.godbolt.org/z/76j4-5\n  uint64_t stride_ = 0;\n  absl::profiling_internal::ExponentialBiased rng_;\n};\n\ninline bool PeriodicSamplerBase::SubtleMaybeSample() noexcept {\n  // See comments on `stride_` for the unsigned increment / signed compare.\n  if (ABSL_PREDICT_TRUE(static_cast<int64_t>(++stride_) < 0)) {\n    return false;\n  }\n  return true;\n}\n\ninline bool PeriodicSamplerBase::Sample() noexcept {\n  return ABSL_PREDICT_FALSE(SubtleMaybeSample()) ? SubtleConfirmSample()\n                                                 : false;\n}\n\n// PeriodicSampler is a concreted periodic sampler implementation.\n// The user provided Tag identifies the implementation, and is required to\n// isolate the global state of this instance from other instances.\n//\n// Typical use case:\n//\n//   struct HashTablezTag {};\n//   thread_local PeriodicSampler sampler;\n//\n//   void HashTableSamplingLogic(...) {\n//     if (sampler.Sample()) {\n//       HashTableSlowSamplePath(...);\n//     }\n//   }\n//\ntemplate <typename Tag, int default_period = 0>\nclass PeriodicSampler final : public PeriodicSamplerBase {\n public:\n  ~PeriodicSampler() = default;\n\n  int period() const noexcept final {\n    return period_.load(std::memory_order_relaxed);\n  }\n\n  // Sets the global period for this sampler. Thread-safe.\n  // Setting a period of 0 disables the sampler, i.e., every call to Sample()\n  // will return false. Setting a period of 1 puts the sampler in 'always on'\n  // mode, i.e., every call to Sample() returns true.\n  static void SetGlobalPeriod(int period) {\n    period_.store(period, std::memory_order_relaxed);\n  }\n\n private:\n  static std::atomic<int> period_;\n};\n\ntemplate <typename Tag, int default_period>\nstd::atomic<int> PeriodicSampler<Tag, default_period>::period_(default_period);\n\n}",
  "id": "BLOCK-CPP-05831",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/profiling/internal/periodic_sampler.h",
  "source_line": 27,
  "validation_status": "validated"
}