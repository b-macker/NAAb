{
  "code": "{\n public:\n  time_zone() : time_zone(nullptr) {}  // Equivalent to UTC\n  time_zone(const time_zone&) = default;\n  time_zone& operator=(const time_zone&) = default;\n\n  std::string name() const;\n\n  // An absolute_lookup represents the civil time (cctz::civil_second) within\n  // this time_zone at the given absolute time (time_point). There are\n  // additionally a few other fields that may be useful when working with\n  // older APIs, such as std::tm.\n  //\n  // Example:\n  //   const cctz::time_zone tz = ...\n  //   const auto tp = std::chrono::system_clock::now();\n  //   const cctz::time_zone::absolute_lookup al = tz.lookup(tp);\n  struct absolute_lookup {\n    civil_second cs;\n    // Note: The following fields exist for backward compatibility with older\n    // APIs. Accessing these fields directly is a sign of imprudent logic in\n    // the calling code. Modern time-related code should only access this data\n    // indirectly by way of cctz::format().\n    int offset;        // civil seconds east of UTC\n    bool is_dst;       // is offset non-standard?\n    const char* abbr;  // time-zone abbreviation (e.g., \"PST\")\n  };\n  absolute_lookup lookup(const time_point<seconds>& tp) const;\n  template <typename D>\n  absolute_lookup lookup(const time_point<D>& tp) const {\n    return lookup(detail::split_seconds(tp).first);\n  }\n\n  // A civil_lookup represents the absolute time(s) (time_point) that\n  // correspond to the given civil time (cctz::civil_second) within this\n  // time_zone. Usually the given civil time represents a unique instant\n  // in time, in which case the conversion is unambiguous. However,\n  // within this time zone, the given civil time may be skipped (e.g.,\n  // during a positive UTC offset shift), or repeated (e.g., during a\n  // negative UTC offset shift). To account for these possibilities,\n  // civil_lookup is richer than just a single time_point.\n  //\n  // In all cases the civil_lookup::kind enum will indicate the nature\n  // of the given civil-time argument, and the pre, trans, and post\n  // members will give the absolute time answers using the pre-transition\n  // offset, the transition point itself, and the post-transition offset,\n  // respectively (all three times are equal if kind == UNIQUE). If any\n  // of these three absolute times is outside the representable range of a\n  // time_point<seconds> the field is set to its maximum/minimum value.\n  //\n  // Example:\n  //   cctz::time_zone lax;\n  //   if (!cctz::load_time_zone(\"America/Los_Angeles\", &lax)) { ... }\n  //\n  //   // A unique civil time.\n  //   auto jan01 = lax.lookup(cctz::civil_second(2011, 1, 1, 0, 0, 0));\n  //   // jan01.kind == cctz::time_zone::civil_lookup::UNIQUE\n  //   // jan01.pre    is 2011/01/01 00:00:00 -0800\n  //   // jan01.trans  is 2011/01/01 00:00:00 -0800\n  //   // jan01.post   is 2011/01/01 00:00:00 -0800\n  //\n  //   // A Spring DST transition, when there is a gap in civil time.\n  //   auto mar13 = lax.lookup(cctz::civil_second(2011, 3, 13, 2, 15, 0));\n  //   // mar13.kind == cctz::time_zone::civil_lookup::SKIPPED\n  //   // mar13.pre   is 2011/03/13 03:15:00 -0700\n  //   // mar13.trans is 2011/03/13 03:00:00 -0700\n  //   // mar13.post  is 2011/03/13 01:15:00 -0800\n  //\n  //   // A Fall DST transition, when civil times are repeated.\n  //   auto nov06 = lax.lookup(cctz::civil_second(2011, 11, 6, 1, 15, 0));\n  //   // nov06.kind == cctz::time_zone::civil_lookup::REPEATED\n  //   // nov06.pre   is 2011/11/06 01:15:00 -0700\n  //   // nov06.trans is 2011/11/06 01:00:00 -0800\n  //   // nov06.post  is 2011/11/06 01:15:00 -0800\n  struct civil_lookup {\n    enum civil_kind {\n      UNIQUE,    // the civil time was singular (pre == trans == post)\n      SKIPPED,   // the civil time did not exist (pre >= trans > post)\n      REPEATED,  // the civil time was ambiguous (pre < trans <= post)\n    } kind;\n    time_point<seconds> pre;    // uses the pre-transition offset\n    time_point<seconds> trans;  // instant of civil-offset change\n    time_point<seconds> post;   // uses the post-transition offset\n  };\n  civil_lookup lookup(const civil_second& cs) const;\n\n  // Finds the time of the next/previous offset change in this time zone.\n  //\n  // By definition, next_transition(tp, &trans) returns false when tp has\n  // its maximum value, and prev_transition(tp, &trans) returns false\n  // when tp has its minimum value. If the zone has no transitions, the\n  // result will also be false no matter what the argument.\n  //\n  // Otherwise, when tp has its minimum value, next_transition(tp, &trans)\n  // returns true and sets trans to the first recorded transition. Chains\n  // of calls to next_transition()/prev_transition() will eventually return\n  // false, but it is unspecified exactly when next_transition(tp, &trans)\n  // jumps to false, or what time is set by prev_transition(tp, &trans) for\n  // a very distant tp.\n  //\n  // Note: Enumeration of time-zone transitions is for informational purposes\n  // only. Modern time-related code should not care about when offset changes\n  // occur.\n  //\n  // Example:\n  //   cctz::time_zone nyc;\n  //   if (!cctz::load_time_zone(\"America/New_York\", &nyc)) { ... }\n  //   const auto now = std::chrono::system_clock::now();\n  //   auto tp = cctz::time_point<cctz::seconds>::min();\n  //   cctz::time_zone::civil_transition trans;\n  //   while (tp <= now && nyc.next_transition(tp, &trans)) {\n  //     // transition: trans.from -> trans.to\n  //     tp = nyc.lookup(trans.to).trans;\n  //   }\n  struct civil_transition {\n    civil_second from;  // the civil time we jump from\n    civil_second to;    // the civil time we jump to\n  };\n  bool next_transition(const time_point<seconds>& tp,\n                       civil_transition* trans) const;\n  template <typename D>\n  bool next_transition(const time_point<D>& tp, civil_transition* trans) const {\n    return next_transition(detail::split_seconds(tp).first, trans);\n  }\n  bool prev_transition(const time_point<seconds>& tp,\n                       civil_transition* trans) const;\n  template <typename D>\n  bool prev_transition(const time_point<D>& tp, civil_transition* trans) const {\n    return prev_transition(detail::split_seconds(tp).first, trans);\n  }\n\n  // version() and description() provide additional information about the\n  // time zone. The content of each of the returned strings is unspecified,\n  // however, when the IANA Time Zone Database is the underlying data source\n  // the version() string will be in the familar form (e.g, \"2018e\") or\n  // empty when unavailable.\n  //\n  // Note: These functions are for informational or testing purposes only.\n  std::string version() const;  // empty when unknown\n  std::string description() const;\n\n  // Relational operators.\n  friend bool operator==(time_zone lhs, time_zone rhs) {\n    return &lhs.effective_impl() == &rhs.effective_impl();\n  }\n  friend bool operator!=(time_zone lhs, time_zone rhs) { return !(lhs == rhs); }\n\n  template <typename H>\n  friend H AbslHashValue(H h, time_zone tz) {\n    return H::combine(std::move(h), &tz.effective_impl());\n  }\n\n  class Impl;\n\n private:\n  explicit time_zone(const Impl* impl) : impl_(impl) {}\n  const Impl& effective_impl() const;  // handles implicit UTC\n  const Impl* impl_;\n}",
  "id": "BLOCK-CPP-06609",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/time_zone.h",
  "source_line": 69,
  "validation_status": "validated"
}