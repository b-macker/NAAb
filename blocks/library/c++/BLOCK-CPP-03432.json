{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::LogSeverity\n//\n// Four severity levels are defined. Logging APIs should terminate the program\n// when a message is logged at severity `kFatal`; the other levels have no\n// special semantics.\n//\n// Values other than the four defined levels (e.g. produced by `static_cast`)\n// are valid, but their semantics when passed to a function, macro, or flag\n// depend on the function, macro, or flag. The usual behavior is to normalize\n// such values to a defined severity level, however in some cases values other\n// than the defined levels are useful for comparison.\n//\n// Example:\n//\n//   // Effectively disables all logging:\n//   SetMinLogLevel(static_cast<absl::LogSeverity>(100));\n//\n// Abseil flags may be defined with type `LogSeverity`. Dependency layering\n// constraints require that the `AbslParseFlag()` overload be declared and\n// defined in the flags library itself rather than here. The `AbslUnparseFlag()`\n// overload is defined there as well for consistency.\n//\n// absl::LogSeverity Flag String Representation\n//\n// An `absl::LogSeverity` has a string representation used for parsing\n// command-line flags based on the enumerator name (e.g. `kFatal`) or\n// its unprefixed name (without the `k`) in any case-insensitive form. (E.g.\n// \"FATAL\", \"fatal\" or \"Fatal\" are all valid.) Unparsing such flags produces an\n// unprefixed string representation in all caps (e.g. \"FATAL\") or an integer.\n//\n// Additionally, the parser accepts arbitrary integers (as if the type were\n// `int`).\n//\n// Examples:\n//\n//   --my_log_level=kInfo\n//   --my_log_level=INFO\n//   --my_log_level=info\n//   --my_log_level=0\n//\n// `DFATAL` and `kLogDebugFatal` are similarly accepted.\n//\n// Unparsing a flag produces the same result as `absl::LogSeverityName()` for\n// the standard levels and a base-ten integer otherwise.\nenum class LogSeverity : int {\n  kInfo = 0,\n  kWarning = 1,\n  kError = 2,\n  kFatal = 3,\n};\n\n// LogSeverities()\n//\n// Returns an iterable of all standard `absl::LogSeverity` values, ordered from\n// least to most severe.\nconstexpr std::array<absl::LogSeverity, 4> LogSeverities() {\n  return {{absl::LogSeverity::kInfo, absl::LogSeverity::kWarning,\n           absl::LogSeverity::kError, absl::LogSeverity::kFatal}};\n}\n\n// `absl::kLogDebugFatal` equals `absl::LogSeverity::kFatal` in debug builds\n// (i.e. when `NDEBUG` is not defined) and `absl::LogSeverity::kError`\n// otherwise.  Avoid ODR-using this variable as it has internal linkage and thus\n// distinct storage in different TUs.\n#ifdef NDEBUG\nstatic constexpr absl::LogSeverity kLogDebugFatal = absl::LogSeverity::kError;\n#else\nstatic constexpr absl::LogSeverity kLogDebugFatal = absl::LogSeverity::kFatal;\n#endif\n\n// LogSeverityName()\n//\n// Returns the all-caps string representation (e.g. \"INFO\") of the specified\n// severity level if it is one of the standard levels and \"UNKNOWN\" otherwise.\nconstexpr const char* LogSeverityName(absl::LogSeverity s) {\n  switch (s) {\n    case absl::LogSeverity::kInfo: return \"INFO\";\n    case absl::LogSeverity::kWarning: return \"WARNING\";\n    case absl::LogSeverity::kError: return \"ERROR\";\n    case absl::LogSeverity::kFatal: return \"FATAL\";\n  }\n  return \"UNKNOWN\";\n}\n\n// NormalizeLogSeverity()\n//\n// Values less than `kInfo` normalize to `kInfo`; values greater than `kFatal`\n// normalize to `kError` (**NOT** `kFatal`).\nconstexpr absl::LogSeverity NormalizeLogSeverity(absl::LogSeverity s) {\n  absl::LogSeverity n = s;\n  if (n < absl::LogSeverity::kInfo) n = absl::LogSeverity::kInfo;\n  if (n > absl::LogSeverity::kFatal) n = absl::LogSeverity::kError;\n  return n;\n}\nconstexpr absl::LogSeverity NormalizeLogSeverity(int s) {\n  return absl::NormalizeLogSeverity(static_cast<absl::LogSeverity>(s));\n}\n\n// operator<<\n//\n// The exact representation of a streamed `absl::LogSeverity` is deliberately\n// unspecified; do not rely on it.\nstd::ostream& operator<<(std::ostream& os, absl::LogSeverity s);\n\n// Enums representing a lower bound for LogSeverity. APIs that only operate on\n// messages of at least a certain level (for example, `SetMinLogLevel()`) use\n// this type to specify that level. absl::LogSeverityAtLeast::kInfinity is\n// a level above all threshold levels and therefore no log message will\n// ever meet this threshold.\nenum class LogSeverityAtLeast : int {\n  kInfo = static_cast<int>(absl::LogSeverity::kInfo),\n  kWarning = static_cast<int>(absl::LogSeverity::kWarning),\n  kError = static_cast<int>(absl::LogSeverity::kError),\n  kFatal = static_cast<int>(absl::LogSeverity::kFatal),\n  kInfinity = 1000,\n};\n\nstd::ostream& operator<<(std::ostream& os, absl::LogSeverityAtLeast s);\n\n// Enums representing an upper bound for LogSeverity. APIs that only operate on\n// messages of at most a certain level (for example, buffer all messages at or\n// below a certain level) use this type to specify that level.\n// absl::LogSeverityAtMost::kNegativeInfinity is a level below all threshold\n// levels and therefore will exclude all log messages.\nenum class LogSeverityAtMost : int {\n  kNegativeInfinity = -1000,\n  kInfo = static_cast<int>(absl::LogSeverity::kInfo),\n  kWarning = static_cast<int>(absl::LogSeverity::kWarning),\n  kError = static_cast<int>(absl::LogSeverity::kError),\n  kFatal = static_cast<int>(absl::LogSeverity::kFatal),\n};\n\nstd::ostream& operator<<(std::ostream& os, absl::LogSeverityAtMost s);\n\n#define COMPOP(op1, op2, T)                                         \\\n  constexpr bool operator op1(absl::T lhs, absl::LogSeverity rhs) { \\\n    return static_cast<absl::LogSeverity>(lhs) op1 rhs;             \\\n  }                                                                 \\\n  constexpr bool operator op2(absl::LogSeverity lhs, absl::T rhs) { \\\n    return lhs op2 static_cast<absl::LogSeverity>(rhs);             \\\n  }\n\n// Comparisons between `LogSeverity` and `LogSeverityAtLeast`/\n// `LogSeverityAtMost` are only supported in one direction.\n// Valid checks are:\n//   LogSeverity >= LogSeverityAtLeast\n//   LogSeverity < LogSeverityAtLeast\n//   LogSeverity <= LogSeverityAtMost\n//   LogSeverity > LogSeverityAtMost\nCOMPOP(>, <, LogSeverityAtLeast)\nCOMPOP(<=, >=, LogSeverityAtLeast)\nCOMPOP(<, >, LogSeverityAtMost)\nCOMPOP(>=, <=, LogSeverityAtMost)\n#undef COMPOP\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03432",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/log_severity.h",
  "source_line": 24,
  "validation_status": "validated"
}