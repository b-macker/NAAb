{
  "code": "{\nnamespace dynamic {\n\n/// Kind identifier.\n///\n/// It supports all types that VariantValue can contain.\nclass ArgKind {\n public:\n  enum Kind {\n    AK_Matcher,\n    AK_Node,\n    AK_Boolean,\n    AK_Double,\n    AK_Unsigned,\n    AK_String\n  };\n  /// Constructor for non-matcher types.\n  ArgKind(Kind K) : K(K) { assert(K != AK_Matcher); }\n\n  /// Constructor for matcher types.\n  static ArgKind MakeMatcherArg(ASTNodeKind MatcherKind) {\n    return ArgKind{AK_Matcher, MatcherKind};\n  }\n\n  static ArgKind MakeNodeArg(ASTNodeKind MatcherKind) {\n    return ArgKind{AK_Node, MatcherKind};\n  }\n\n  Kind getArgKind() const { return K; }\n  ASTNodeKind getMatcherKind() const {\n    assert(K == AK_Matcher);\n    return NodeKind;\n  }\n  ASTNodeKind getNodeKind() const {\n    assert(K == AK_Node);\n    return NodeKind;\n  }\n\n  /// Determines if this type can be converted to \\p To.\n  ///\n  /// \\param To the requested destination type.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion.\n  bool isConvertibleTo(ArgKind To, unsigned *Specificity) const;\n\n  bool operator<(const ArgKind &Other) const {\n    if ((K == AK_Matcher && Other.K == AK_Matcher) ||\n        (K == AK_Node && Other.K == AK_Node))\n      return NodeKind < Other.NodeKind;\n    return K < Other.K;\n  }\n\n  /// String representation of the type.\n  std::string asString() const;\n\nprivate:\n  ArgKind(Kind K, ASTNodeKind NK) : K(K), NodeKind(NK) {}\n  Kind K;\n  ASTNodeKind NodeKind;\n};\n\nusing ast_matchers::internal::DynTypedMatcher;\n\n/// A variant matcher object.\n///\n/// The purpose of this object is to abstract simple and polymorphic matchers\n/// into a single object type.\n/// Polymorphic matchers might be implemented as a list of all the possible\n/// overloads of the matcher. \\c VariantMatcher knows how to select the\n/// appropriate overload when needed.\n/// To get a real matcher object out of a \\c VariantMatcher you can do:\n///  - getSingleMatcher() which returns a matcher, only if it is not ambiguous\n///    to decide which matcher to return. Eg. it contains only a single\n///    matcher, or a polymorphic one with only one overload.\n///  - hasTypedMatcher<T>()/getTypedMatcher<T>(): These calls will determine if\n///    the underlying matcher(s) can unambiguously return a Matcher<T>.\nclass VariantMatcher {\n  /// Methods that depend on T from hasTypedMatcher/getTypedMatcher.\n  class MatcherOps {\n  public:\n    MatcherOps(ASTNodeKind NodeKind) : NodeKind(NodeKind) {}\n\n    bool canConstructFrom(const DynTypedMatcher &Matcher,\n                          bool &IsExactMatch) const;\n\n    /// Convert \\p Matcher the destination type and return it as a new\n    /// DynTypedMatcher.\n    DynTypedMatcher convertMatcher(const DynTypedMatcher &Matcher) const;\n\n    /// Constructs a variadic typed matcher from \\p InnerMatchers.\n    /// Will try to convert each inner matcher to the destination type and\n    /// return std::nullopt if it fails to do so.\n    std::optional<DynTypedMatcher>\n    constructVariadicOperator(DynTypedMatcher::VariadicOperator Op,\n                              ArrayRef<VariantMatcher> InnerMatchers) const;\n\n  private:\n    ASTNodeKind NodeKind;\n  };\n\n  /// Payload interface to be specialized by each matcher type.\n  ///\n  /// It follows a similar interface as VariantMatcher itself.\n  class Payload {\n  public:\n    virtual ~Payload();\n    virtual std::optional<DynTypedMatcher> getSingleMatcher() const = 0;\n    virtual std::string getTypeAsString() const = 0;\n    virtual std::optional<DynTypedMatcher>\n    getTypedMatcher(const MatcherOps &Ops) const = 0;\n    virtual bool isConvertibleTo(ASTNodeKind Kind,\n                                 unsigned *Specificity) const = 0;\n  };\n\npublic:\n  /// A null matcher.\n  VariantMatcher();\n\n  /// Clones the provided matcher.\n  static VariantMatcher SingleMatcher(const DynTypedMatcher &Matcher);\n\n  /// Clones the provided matchers.\n  ///\n  /// They should be the result of a polymorphic matcher.\n  static VariantMatcher\n  PolymorphicMatcher(std::vector<DynTypedMatcher> Matchers);\n\n  /// Creates a 'variadic' operator matcher.\n  ///\n  /// It will bind to the appropriate type on getTypedMatcher<T>().\n  static VariantMatcher\n  VariadicOperatorMatcher(DynTypedMatcher::VariadicOperator Op,\n                          std::vector<VariantMatcher> Args);\n\n  /// Makes the matcher the \"null\" matcher.\n  void reset();\n\n  /// Whether the matcher is null.\n  bool isNull() const { return !Value; }\n\n  /// Return a single matcher, if there is no ambiguity.\n  ///\n  /// \\returns the matcher, if there is only one matcher. An empty Optional, if\n  /// the underlying matcher is a polymorphic matcher with more than one\n  /// representation.\n  std::optional<DynTypedMatcher> getSingleMatcher() const;\n\n  /// Determines if the contained matcher can be converted to\n  ///   \\c Matcher<T>.\n  ///\n  /// For the Single case, it returns true if it can be converted to\n  /// \\c Matcher<T>.\n  /// For the Polymorphic case, it returns true if one, and only one, of the\n  /// overloads can be converted to \\c Matcher<T>. If there are more than one\n  /// that can, the result would be ambiguous and false is returned.\n  template <class T>\n  bool hasTypedMatcher() const {\n    return hasTypedMatcher(ASTNodeKind::getFromNodeKind<T>());\n  }\n\n  bool hasTypedMatcher(ASTNodeKind NK) const {\n    if (!Value) return false;\n    return Value->getTypedMatcher(MatcherOps(NK)).has_value();\n  }\n\n  /// Determines if the contained matcher can be converted to \\p Kind.\n  ///\n  /// \\param Kind the requested destination type.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion.\n  bool isConvertibleTo(ASTNodeKind Kind, unsigned *Specificity) const {\n    if (Value)\n      return Value->isConvertibleTo(Kind, Specificity);\n    return false;\n  }\n\n  /// Return this matcher as a \\c Matcher<T>.\n  ///\n  /// Handles the different types (Single, Polymorphic) accordingly.\n  /// Asserts that \\c hasTypedMatcher<T>() is true.\n  template <class T>\n  ast_matchers::internal::Matcher<T> getTypedMatcher() const {\n    assert(hasTypedMatcher<T>() && \"hasTypedMatcher<T>() == false\");\n    return Value->getTypedMatcher(MatcherOps(ASTNodeKind::getFromNodeKind<T>()))\n        ->template convertTo<T>();\n  }\n\n  DynTypedMatcher getTypedMatcher(ASTNodeKind NK) const {\n    assert(hasTypedMatcher(NK) && \"hasTypedMatcher(NK) == false\");\n    return *Value->getTypedMatcher(MatcherOps(NK));\n  }\n\n  /// String representation of the type of the value.\n  ///\n  /// If the underlying matcher is a polymorphic one, the string will show all\n  /// the types.\n  std::string getTypeAsString() const;\n\nprivate:\n  explicit VariantMatcher(std::shared_ptr<Payload> Value)\n      : Value(std::move(Value)) {}\n\n\n  class SinglePayload;\n  class PolymorphicPayload;\n  class VariadicOpPayload;\n\n  std::shared_ptr<const Payload> Value;\n};\n\n/// Variant value class.\n///\n/// Basically, a tagged union with value type semantics.\n/// It is used by the registry as the return value and argument type for the\n/// matcher factory methods.\n/// It can be constructed from any of the supported types. It supports\n/// copy/assignment.\n///\n/// Supported types:\n///  - \\c bool\n//   - \\c double\n///  - \\c unsigned\n///  - \\c llvm::StringRef\n///  - \\c VariantMatcher (\\c DynTypedMatcher / \\c Matcher<T>)\nclass VariantValue {\npublic:\n  VariantValue() : Type(VT_Nothing) {}\n\n  VariantValue(const VariantValue &Other);\n  ~VariantValue();\n  VariantValue &operator=(const VariantValue &Other);\n\n  /// Specific constructors for each supported type.\n  VariantValue(bool Boolean);\n  VariantValue(double Double);\n  VariantValue(unsigned Unsigned);\n  VariantValue(StringRef String);\n  VariantValue(ASTNodeKind NodeKind);\n  VariantValue(const VariantMatcher &Matchers);\n\n  /// Constructs an \\c unsigned value (disambiguation from bool).\n  VariantValue(int Signed) : VariantValue(static_cast<unsigned>(Signed)) {}\n\n  /// Returns true iff this is not an empty value.\n  explicit operator bool() const { return hasValue(); }\n  bool hasValue() const { return Type != VT_Nothing; }\n\n  /// Boolean value functions.\n  bool isBoolean() const;\n  bool getBoolean() const;\n  void setBoolean(bool Boolean);\n\n  /// Double value functions.\n  bool isDouble() const;\n  double getDouble() const;\n  void setDouble(double Double);\n\n  /// Unsigned value functions.\n  bool isUnsigned() const;\n  unsigned getUnsigned() const;\n  void setUnsigned(unsigned Unsigned);\n\n  /// String value functions.\n  bool isString() const;\n  const std::string &getString() const;\n  void setString(StringRef String);\n\n  bool isNodeKind() const;\n  const ASTNodeKind &getNodeKind() const;\n  void setNodeKind(ASTNodeKind NodeKind);\n\n  /// Matcher value functions.\n  bool isMatcher() const;\n  const VariantMatcher &getMatcher() const;\n  void setMatcher(const VariantMatcher &Matcher);\n\n  /// Determines if the contained value can be converted to \\p Kind.\n  ///\n  /// \\param Kind the requested destination type.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion.\n  bool isConvertibleTo(ArgKind Kind, unsigned* Specificity) const;\n\n  /// Determines if the contained value can be converted to any kind\n  /// in \\p Kinds.\n  ///\n  /// \\param Kinds the requested destination types.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion. It is the maximum specificity of all the possible\n  ///   conversions.\n  bool isConvertibleTo(ArrayRef<ArgKind> Kinds, unsigned *Specificity) const;\n\n  /// String representation of the type of the value.\n  std::string getTypeAsString() const;\n\nprivate:\n  void reset();\n\n  /// All supported value types.\n  enum ValueType {\n    VT_Nothing,\n    VT_Boolean,\n    VT_Double,\n    VT_Unsigned,\n    VT_String,\n    VT_Matcher,\n    VT_NodeKind\n  };\n\n  /// All supported value types.\n  union AllValues {\n    unsigned Unsigned;\n    double Double;\n    bool Boolean;\n    std::string *String;\n    VariantMatcher *Matcher;\n    ASTNodeKind *NodeKind;\n  };\n\n  ValueType Type;\n  AllValues Value;\n};\n\n} // end namespace dynamic\n}",
  "id": "BLOCK-CPP-21304",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/Dynamic/VariantValue.h",
  "source_line": 28,
  "validation_status": "validated"
}