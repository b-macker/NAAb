{
  "code": "{\n\n  /// Define the meaning of possible values of the kind in ExplicitSpecifier.\n  enum class ExplicitSpecKind : unsigned {\n    ResolvedFalse,\n    ResolvedTrue,\n    Unresolved,\n  };\n\n  /// Define the kind of constexpr specifier.\n  enum class ConstexprSpecKind { Unspecified, Constexpr, Consteval, Constinit };\n\n  /// In an if statement, this denotes whether the statement is\n  /// a constexpr or consteval if statement.\n  enum class IfStatementKind : unsigned {\n    Ordinary,\n    Constexpr,\n    ConstevalNonNegated,\n    ConstevalNegated\n  };\n\n  /// Specifies the width of a type, e.g., short, long, or long long.\n  enum class TypeSpecifierWidth { Unspecified, Short, Long, LongLong };\n\n  /// Specifies the signedness of a type, e.g., signed or unsigned.\n  enum class TypeSpecifierSign { Unspecified, Signed, Unsigned };\n\n  enum class TypeSpecifiersPipe { Unspecified, Pipe };\n\n  /// Specifies the kind of type.\n  enum TypeSpecifierType {\n    TST_unspecified,\n    TST_void,\n    TST_char,\n    TST_wchar,  // C++ wchar_t\n    TST_char8,  // C++20 char8_t (proposed)\n    TST_char16, // C++11 char16_t\n    TST_char32, // C++11 char32_t\n    TST_int,\n    TST_int128,\n    TST_bitint,  // Bit-precise integer types.\n    TST_half,    // OpenCL half, ARM NEON __fp16\n    TST_Float16, // C11 extension ISO/IEC TS 18661-3\n    TST_Accum,   // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n    TST_Fract,\n    TST_BFloat16,\n    TST_float,\n    TST_double,\n    TST_float128,\n    TST_ibm128,\n    TST_bool,       // _Bool\n    TST_decimal32,  // _Decimal32\n    TST_decimal64,  // _Decimal64\n    TST_decimal128, // _Decimal128\n    TST_enum,\n    TST_union,\n    TST_struct,\n    TST_class,     // C++ class type\n    TST_interface, // C++ (Microsoft-specific) __interface type\n    TST_typename,  // Typedef, C++ class-name or enum name, etc.\n    TST_typeofType,        // C2x (and GNU extension) typeof(type-name)\n    TST_typeofExpr,        // C2x (and GNU extension) typeof(expression)\n    TST_typeof_unqualType, // C2x typeof_unqual(type-name)\n    TST_typeof_unqualExpr, // C2x typeof_unqual(expression)\n    TST_decltype, // C++11 decltype\n#define TRANSFORM_TYPE_TRAIT_DEF(_, Trait) TST_##Trait,\n#include \"clang/Basic/TransformTypeTraits.def\"\n    TST_auto,            // C++11 auto\n    TST_decltype_auto,   // C++1y decltype(auto)\n    TST_auto_type,       // __auto_type extension\n    TST_unknown_anytype, // __unknown_anytype extension\n    TST_atomic,          // C11 _Atomic\n#define GENERIC_IMAGE_TYPE(ImgType, Id) TST_##ImgType##_t, // OpenCL image types\n#include \"clang/Basic/OpenCLImageTypes.def\"\n    TST_error // erroneous type\n  };\n\n  /// Structure that packs information about the type specifiers that\n  /// were written in a particular type specifier sequence.\n  struct WrittenBuiltinSpecs {\n    static_assert(TST_error < 1 << 7, \"Type bitfield not wide enough for TST\");\n    /*DeclSpec::TST*/ unsigned Type : 7;\n    /*DeclSpec::TSS*/ unsigned Sign  : 2;\n    /*TypeSpecifierWidth*/ unsigned Width : 2;\n    unsigned ModeAttr : 1;\n  };\n\n  /// A C++ access specifier (public, private, protected), plus the\n  /// special value \"none\" which means different things in different contexts.\n  enum AccessSpecifier {\n    AS_public,\n    AS_protected,\n    AS_private,\n    AS_none\n  };\n\n  /// The categorization of expression values, currently following the\n  /// C++11 scheme.\n  enum ExprValueKind {\n    /// A pr-value expression (in the C++11 taxonomy)\n    /// produces a temporary value.\n    VK_PRValue,\n\n    /// An l-value expression is a reference to an object with\n    /// independent storage.\n    VK_LValue,\n\n    /// An x-value expression is a reference to an object with\n    /// independent storage but which can be \"moved\", i.e.\n    /// efficiently cannibalized for its resources.\n    VK_XValue\n  };\n\n  /// A further classification of the kind of object referenced by an\n  /// l-value or x-value.\n  enum ExprObjectKind {\n    /// An ordinary object is located at an address in memory.\n    OK_Ordinary,\n\n    /// A bitfield object is a bitfield on a C or C++ record.\n    OK_BitField,\n\n    /// A vector component is an element or range of elements on a vector.\n    OK_VectorComponent,\n\n    /// An Objective-C property is a logical field of an Objective-C\n    /// object which is read and written via Objective-C method calls.\n    OK_ObjCProperty,\n\n    /// An Objective-C array/dictionary subscripting which reads an\n    /// object or writes at the subscripted array/dictionary element via\n    /// Objective-C method calls.\n    OK_ObjCSubscript,\n\n    /// A matrix component is a single element of a matrix.\n    OK_MatrixComponent\n  };\n\n  /// The reason why a DeclRefExpr does not constitute an odr-use.\n  enum NonOdrUseReason {\n    /// This is an odr-use.\n    NOUR_None = 0,\n    /// This name appears in an unevaluated operand.\n    NOUR_Unevaluated,\n    /// This name appears as a potential result of an lvalue-to-rvalue\n    /// conversion that is a constant expression.\n    NOUR_Constant,\n    /// This name appears as a potential result of a discarded value\n    /// expression.\n    NOUR_Discarded,\n  };\n\n  /// Describes the kind of template specialization that a\n  /// particular template specialization declaration represents.\n  enum TemplateSpecializationKind {\n    /// This template specialization was formed from a template-id but\n    /// has not yet been declared, defined, or instantiated.\n    TSK_Undeclared = 0,\n    /// This template specialization was implicitly instantiated from a\n    /// template. (C++ [temp.inst]).\n    TSK_ImplicitInstantiation,\n    /// This template specialization was declared or defined by an\n    /// explicit specialization (C++ [temp.expl.spec]) or partial\n    /// specialization (C++ [temp.class.spec]).\n    TSK_ExplicitSpecialization,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation declaration request\n    /// (C++11 [temp.explicit]).\n    TSK_ExplicitInstantiationDeclaration,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation definition request\n    /// (C++ [temp.explicit]).\n    TSK_ExplicitInstantiationDefinition\n  };\n\n  /// Determine whether this template specialization kind refers\n  /// to an instantiation of an entity (as opposed to a non-template or\n  /// an explicit specialization).\n  inline bool isTemplateInstantiation(TemplateSpecializationKind Kind) {\n    return Kind != TSK_Undeclared && Kind != TSK_ExplicitSpecialization;\n  }\n\n  /// True if this template specialization kind is an explicit\n  /// specialization, explicit instantiation declaration, or explicit\n  /// instantiation definition.\n  inline bool isTemplateExplicitInstantiationOrSpecialization(\n      TemplateSpecializationKind Kind) {\n    switch (Kind) {\n    case TSK_ExplicitSpecialization:\n    case TSK_ExplicitInstantiationDeclaration:\n    case TSK_ExplicitInstantiationDefinition:\n      return true;\n\n    case TSK_Undeclared:\n    case TSK_ImplicitInstantiation:\n      return false;\n    }\n    llvm_unreachable(\"bad template specialization kind\");\n  }\n\n  /// Thread storage-class-specifier.\n  enum ThreadStorageClassSpecifier {\n    TSCS_unspecified,\n    /// GNU __thread.\n    TSCS___thread,\n    /// C++11 thread_local. Implies 'static' at block scope, but not at\n    /// class scope.\n    TSCS_thread_local,\n    /// C11 _Thread_local. Must be combined with either 'static' or 'extern'\n    /// if used at block scope.\n    TSCS__Thread_local\n  };\n\n  /// Storage classes.\n  enum StorageClass {\n    // These are legal on both functions and variables.\n    SC_None,\n    SC_Extern,\n    SC_Static,\n    SC_PrivateExtern,\n\n    // These are only legal on variables.\n    SC_Auto,\n    SC_Register\n  };\n\n  /// Checks whether the given storage class is legal for functions.\n  inline bool isLegalForFunction(StorageClass SC) {\n    return SC <= SC_PrivateExtern;\n  }\n\n  /// Checks whether the given storage class is legal for variables.\n  inline bool isLegalForVariable(StorageClass SC) {\n    return true;\n  }\n\n  /// In-class initialization styles for non-static data members.\n  enum InClassInitStyle {\n    ICIS_NoInit,   ///< No in-class initializer.\n    ICIS_CopyInit, ///< Copy initialization.\n    ICIS_ListInit  ///< Direct list-initialization.\n  };\n\n  /// CallingConv - Specifies the calling convention that a function uses.\n  enum CallingConv {\n    CC_C,           // __attribute__((cdecl))\n    CC_X86StdCall,  // __attribute__((stdcall))\n    CC_X86FastCall, // __attribute__((fastcall))\n    CC_X86ThisCall, // __attribute__((thiscall))\n    CC_X86VectorCall, // __attribute__((vectorcall))\n    CC_X86Pascal,   // __attribute__((pascal))\n    CC_Win64,       // __attribute__((ms_abi))\n    CC_X86_64SysV,  // __attribute__((sysv_abi))\n    CC_X86RegCall, // __attribute__((regcall))\n    CC_AAPCS,       // __attribute__((pcs(\"aapcs\")))\n    CC_AAPCS_VFP,   // __attribute__((pcs(\"aapcs-vfp\")))\n    CC_IntelOclBicc, // __attribute__((intel_ocl_bicc))\n    CC_SpirFunction, // default for OpenCL functions on SPIR target\n    CC_OpenCLKernel, // inferred for OpenCL kernels\n    CC_Swift,        // __attribute__((swiftcall))\n    CC_SwiftAsync,        // __attribute__((swiftasynccall))\n    CC_PreserveMost, // __attribute__((preserve_most))\n    CC_PreserveAll,  // __attribute__((preserve_all))\n    CC_AArch64VectorCall, // __attribute__((aarch64_vector_pcs))\n    CC_AArch64SVEPCS, // __attribute__((aarch64_sve_pcs))\n    CC_AMDGPUKernelCall, // __attribute__((amdgpu_kernel))\n  };\n\n  /// Checks whether the given calling convention supports variadic\n  /// calls. Unprototyped calls also use the variadic call rules.\n  inline bool supportsVariadicCall(CallingConv CC) {\n    switch (CC) {\n    case CC_X86StdCall:\n    case CC_X86FastCall:\n    case CC_X86ThisCall:\n    case CC_X86RegCall:\n    case CC_X86Pascal:\n    case CC_X86VectorCall:\n    case CC_SpirFunction:\n    case CC_OpenCLKernel:\n    case CC_Swift:\n    case CC_SwiftAsync:\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /// The storage duration for an object (per C++ [basic.stc]).\n  enum StorageDuration {\n    SD_FullExpression, ///< Full-expression storage duration (for temporaries).\n    SD_Automatic,      ///< Automatic storage duration (most local variables).\n    SD_Thread,         ///< Thread storage duration.\n    SD_Static,         ///< Static storage duration.\n    SD_Dynamic         ///< Dynamic storage duration.\n  };\n\n  /// Describes the nullability of a particular type.\n  enum class NullabilityKind : uint8_t {\n    /// Values of this type can never be null.\n    NonNull = 0,\n    /// Values of this type can be null.\n    Nullable,\n    /// Whether values of this type can be null is (explicitly)\n    /// unspecified. This captures a (fairly rare) case where we\n    /// can't conclude anything about the nullability of the type even\n    /// though it has been considered.\n    Unspecified,\n    // Generally behaves like Nullable, except when used in a block parameter\n    // that was imported into a swift async method. There, swift will assume\n    // that the parameter can get null even if no error occurred. _Nullable\n    // parameters are assumed to only get null on error.\n    NullableResult,\n  };\n  /// Prints human-readable debug representation.\n  llvm::raw_ostream &operator<<(llvm::raw_ostream&, NullabilityKind);\n\n  /// Return true if \\p L has a weaker nullability annotation than \\p R. The\n  /// ordering is: Unspecified < Nullable < NonNull.\n  inline bool hasWeakerNullability(NullabilityKind L, NullabilityKind R) {\n    return uint8_t(L) > uint8_t(R);\n  }\n\n  /// Retrieve the spelling of the given nullability kind.\n  llvm::StringRef getNullabilitySpelling(NullabilityKind kind,\n                                         bool isContextSensitive = false);\n\n  /// Kinds of parameter ABI.\n  enum class ParameterABI {\n    /// This parameter uses ordinary ABI rules for its type.\n    Ordinary,\n\n    /// This parameter (which must have pointer type) is a Swift\n    /// indirect result parameter.\n    SwiftIndirectResult,\n\n    /// This parameter (which must have pointer-to-pointer type) uses\n    /// the special Swift error-result ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftErrorResult,\n\n    /// This parameter (which must have pointer type) uses the special\n    /// Swift context-pointer ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftContext,\n\n    /// This parameter (which must have pointer type) uses the special\n    /// Swift asynchronous context-pointer ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftAsyncContext,\n  };\n\n  /// Assigned inheritance model for a class in the MS C++ ABI. Must match order\n  /// of spellings in MSInheritanceAttr.\n  enum class MSInheritanceModel {\n    Single = 0,\n    Multiple = 1,\n    Virtual = 2,\n    Unspecified = 3,\n  };\n\n  llvm::StringRef getParameterABISpelling(ParameterABI kind);\n\n  inline llvm::StringRef getAccessSpelling(AccessSpecifier AS) {\n    switch (AS) {\n    case AccessSpecifier::AS_public:\n      return \"public\";\n    case AccessSpecifier::AS_protected:\n      return \"protected\";\n    case AccessSpecifier::AS_private:\n      return \"private\";\n    case AccessSpecifier::AS_none:\n      return {};\n    }\n    llvm_unreachable(\"Unknown AccessSpecifier\");\n  }\n}",
  "id": "BLOCK-CPP-17014",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Specifiers.h",
  "source_line": 25,
  "validation_status": "validated"
}