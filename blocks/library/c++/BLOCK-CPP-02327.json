{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace raw_log_internal {\nnamespace {\n\n// TODO(gfalcon): We want raw-logging to work on as many platforms as possible.\n// Explicitly `#error` out when not `ABSL_LOW_LEVEL_WRITE_SUPPORTED`, except for\n// a selected set of platforms for which we expect not to be able to raw log.\n\n#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED\nconstexpr char kTruncated[] = \" ... (message truncated)\\n\";\n\n// sprintf the format to the buffer, adjusting *buf and *size to reflect the\n// consumed bytes, and return whether the message fit without truncation.  If\n// truncation occurred, if possible leave room in the buffer for the message\n// kTruncated[].\nbool VADoRawLog(char** buf, int* size, const char* format, va_list ap)\n    ABSL_PRINTF_ATTRIBUTE(3, 0);\nbool VADoRawLog(char** buf, int* size, const char* format, va_list ap) {\n  if (*size < 0) return false;\n  int n = vsnprintf(*buf, static_cast<size_t>(*size), format, ap);\n  bool result = true;\n  if (n < 0 || n > *size) {\n    result = false;\n    if (static_cast<size_t>(*size) > sizeof(kTruncated)) {\n      n = *size - static_cast<int>(sizeof(kTruncated));\n    } else {\n      n = 0;  // no room for truncation message\n    }\n  }\n  *size -= n;\n  *buf += n;\n  return result;\n}\n#endif  // ABSL_LOW_LEVEL_WRITE_SUPPORTED\n\nconstexpr int kLogBufSize = 3000;\n\n// CAVEAT: vsnprintf called from *DoRawLog below has some (exotic) code paths\n// that invoke malloc() and getenv() that might acquire some locks.\n\n// Helper for RawLog below.\n// *DoRawLog writes to *buf of *size and move them past the written portion.\n// It returns true iff there was no overflow or error.\nbool DoRawLog(char** buf, int* size, const char* format, ...)\n    ABSL_PRINTF_ATTRIBUTE(3, 4);\nbool DoRawLog(char** buf, int* size, const char* format, ...) {\n  if (*size < 0) return false;\n  va_list ap;\n  va_start(ap, format);\n  int n = vsnprintf(*buf, static_cast<size_t>(*size), format, ap);\n  va_end(ap);\n  if (n < 0 || n > *size) return false;\n  *size -= n;\n  *buf += n;\n  return true;\n}\n\nbool DefaultLogFilterAndPrefix(absl::LogSeverity, const char* file, int line,\n                               char** buf, int* buf_size) {\n  DoRawLog(buf, buf_size, \"[%s : %d] RAW: \", file, line);\n  return true;\n}\n\nABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES\nabsl::base_internal::AtomicHook<LogFilterAndPrefixHook>\n    log_filter_and_prefix_hook(DefaultLogFilterAndPrefix);\nABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES\nabsl::base_internal::AtomicHook<AbortHook> abort_hook;\n\nvoid RawLogVA(absl::LogSeverity severity, const char* file, int line,\n              const char* format, va_list ap) ABSL_PRINTF_ATTRIBUTE(4, 0);\nvoid RawLogVA(absl::LogSeverity severity, const char* file, int line,\n              const char* format, va_list ap) {\n  char buffer[kLogBufSize];\n  char* buf = buffer;\n  int size = sizeof(buffer);\n#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED\n  bool enabled = true;\n#else\n  bool enabled = false;\n#endif\n\n#ifdef ABSL_MIN_LOG_LEVEL\n  if (severity < static_cast<absl::LogSeverity>(ABSL_MIN_LOG_LEVEL) &&\n      severity < absl::LogSeverity::kFatal) {\n    enabled = false;\n  }\n#endif\n\n  enabled = log_filter_and_prefix_hook(severity, file, line, &buf, &size);\n  const char* const prefix_end = buf;\n\n#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED\n  if (enabled) {\n    bool no_chop = VADoRawLog(&buf, &size, format, ap);\n    if (no_chop) {\n      DoRawLog(&buf, &size, \"\\n\");\n    } else {\n      DoRawLog(&buf, &size, \"%s\", kTruncated);\n    }\n    AsyncSignalSafeWriteError(buffer, strlen(buffer));\n  }\n#else\n  static_cast<void>(format);\n  static_cast<void>(ap);\n  static_cast<void>(enabled);\n#endif\n\n  // Abort the process after logging a FATAL message, even if the output itself\n  // was suppressed.\n  if (severity == absl::LogSeverity::kFatal) {\n    abort_hook(file, line, buffer, prefix_end, buffer + kLogBufSize);\n    abort();\n  }\n}\n\n// Non-formatting version of RawLog().\n//\n// TODO(gfalcon): When string_view no longer depends on base, change this\n// interface to take its message as a string_view instead.\nvoid DefaultInternalLog(absl::LogSeverity severity, const char* file, int line,\n                        const std::string& message) {\n  RawLog(severity, file, line, \"%.*s\", static_cast<int>(message.size()),\n         message.data());\n}\n\n}  // namespace\n\nvoid AsyncSignalSafeWriteError(const char* s, size_t len) {\n  if (!len) return;\n  absl::base_internal::ErrnoSaver errno_saver;\n#if defined(__EMSCRIPTEN__)\n  // In WebAssembly, bypass filesystem emulation via fwrite.\n  if (s[len - 1] == '\\n') {\n    // Skip a trailing newline character as emscripten_errn adds one itself.\n    len--;\n  }\n  // emscripten_errn was introduced in 3.1.41 but broken in standalone mode\n  // until 3.1.43.\n#if ABSL_INTERNAL_EMSCRIPTEN_VERSION >= 3001043\n  emscripten_errn(s, len);\n#else\n  char buf[kLogBufSize];\n  if (len >= kLogBufSize) {\n    len = kLogBufSize - 1;\n    constexpr size_t trunc_len = sizeof(kTruncated) - 2;\n    memcpy(buf + len - trunc_len, kTruncated, trunc_len);\n    buf[len] = '\\0';\n    len -= trunc_len;\n  } else {\n    buf[len] = '\\0';\n  }\n  memcpy(buf, s, len);\n  _emscripten_err(buf);\n#endif\n#elif defined(ABSL_HAVE_SYSCALL_WRITE)\n  // We prefer calling write via `syscall` to minimize the risk of libc doing\n  // something \"helpful\".\n  syscall(SYS_write, STDERR_FILENO, s, len);\n#elif defined(ABSL_HAVE_POSIX_WRITE)\n  write(STDERR_FILENO, s, len);\n#elif defined(ABSL_HAVE_RAW_IO)\n  _write(/* stderr */ 2, s, static_cast<unsigned>(len));\n#else\n  // stderr logging unsupported on this platform\n  (void)s;\n  (void)len;\n#endif\n}\n\nvoid RawLog(absl::LogSeverity severity, const char* file, int line,\n            const char* format, ...) {\n  va_list ap;\n  va_start(ap, format);\n  RawLogVA(severity, file, line, format, ap);\n  va_end(ap);\n}\n\nbool RawLoggingFullySupported() {\n#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED\n  return true;\n#else   // !ABSL_LOW_LEVEL_WRITE_SUPPORTED\n  return false;\n#endif  // !ABSL_LOW_LEVEL_WRITE_SUPPORTED\n}\n\nABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES ABSL_DLL\n    absl::base_internal::AtomicHook<InternalLogFunction>\n        internal_log_function(DefaultInternalLog);\n\nvoid RegisterLogFilterAndPrefixHook(LogFilterAndPrefixHook func) {\n  log_filter_and_prefix_hook.Store(func);\n}\n\nvoid RegisterAbortHook(AbortHook func) { abort_hook.Store(func); }\n\nvoid RegisterInternalLogFunction(InternalLogFunction func) {\n  internal_log_function.Store(func);\n}\n\n}  // namespace raw_log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02327",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/raw_logging.cc",
  "source_line": 77,
  "validation_status": "validated"
}