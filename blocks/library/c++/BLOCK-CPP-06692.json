{
  "code": "{\n  template <class VariantType>\n  static typename VariantType::Variant& Derived(VariantType& self) {  // NOLINT\n    return static_cast<typename VariantType::Variant&>(self);\n  }\n\n  template <class VariantType>\n  static const typename VariantType::Variant& Derived(\n      const VariantType& self) {  // NOLINT\n    return static_cast<const typename VariantType::Variant&>(self);\n  }\n\n  template <class VariantType>\n  static void Destroy(VariantType& self) {  // NOLINT\n    Derived(self).destroy();\n    self.index_ = absl::variant_npos;\n  }\n\n  template <class Variant>\n  static void SetIndex(Variant& self, std::size_t i) {  // NOLINT\n    self.index_ = i;\n  }\n\n  template <class Variant>\n  static void InitFrom(Variant& self, Variant&& other) {  // NOLINT\n    VisitIndices<absl::variant_size<Variant>::value>::Run(\n        InitFromVisitor<Variant, Variant&&>{&self,\n                                            std::forward<Variant>(other)},\n        other.index());\n    self.index_ = other.index();\n  }\n\n  // Access a variant alternative, assuming the index is correct.\n  template <std::size_t I, class Variant>\n  static VariantAccessResult<I, Variant> Access(Variant&& self) {\n    // This cast instead of invocation of AccessUnion with an rvalue is a\n    // workaround for msvc. Without this there is a runtime failure when dealing\n    // with rvalues.\n    // TODO(calabrese) Reduce test case and find a simpler workaround.\n    return static_cast<VariantAccessResult<I, Variant>>(\n        variant_internal::AccessUnion(self.state_, SizeT<I>()));\n  }\n\n  // Access a variant alternative, throwing if the index is incorrect.\n  template <std::size_t I, class Variant>\n  static VariantAccessResult<I, Variant> CheckedAccess(Variant&& self) {\n    if (ABSL_PREDICT_FALSE(self.index_ != I)) {\n      TypedThrowBadVariantAccess<VariantAccessResult<I, Variant>>();\n    }\n\n    return Access<I>(absl::forward<Variant>(self));\n  }\n\n  // The implementation of the move-assignment operation for a variant.\n  template <class VType>\n  struct MoveAssignVisitor {\n    using DerivedType = typename VType::Variant;\n    template <std::size_t NewIndex>\n    void operator()(SizeT<NewIndex> /*new_i*/) const {\n      if (left->index_ == NewIndex) {\n        Access<NewIndex>(*left) = std::move(Access<NewIndex>(*right));\n      } else {\n        Derived(*left).template emplace<NewIndex>(\n            std::move(Access<NewIndex>(*right)));\n      }\n    }\n\n    void operator()(SizeT<absl::variant_npos> /*new_i*/) const {\n      Destroy(*left);\n    }\n\n    VType* left;\n    VType* right;\n  };\n\n  template <class VType>\n  static MoveAssignVisitor<VType> MakeMoveAssignVisitor(VType* left,\n                                                        VType* other) {\n    return {left, other};\n  }\n\n  // The implementation of the assignment operation for a variant.\n  template <class VType>\n  struct CopyAssignVisitor {\n    using DerivedType = typename VType::Variant;\n    template <std::size_t NewIndex>\n    void operator()(SizeT<NewIndex> /*new_i*/) const {\n      using New =\n          typename absl::variant_alternative<NewIndex, DerivedType>::type;\n\n      if (left->index_ == NewIndex) {\n        Access<NewIndex>(*left) = Access<NewIndex>(*right);\n      } else if (std::is_nothrow_copy_constructible<New>::value ||\n                 !std::is_nothrow_move_constructible<New>::value) {\n        Derived(*left).template emplace<NewIndex>(Access<NewIndex>(*right));\n      } else {\n        Derived(*left) = DerivedType(Derived(*right));\n      }\n    }\n\n    void operator()(SizeT<absl::variant_npos> /*new_i*/) const {\n      Destroy(*left);\n    }\n\n    VType* left;\n    const VType* right;\n  };\n\n  template <class VType>\n  static CopyAssignVisitor<VType> MakeCopyAssignVisitor(VType* left,\n                                                        const VType& other) {\n    return {left, &other};\n  }\n\n  // The implementation of conversion-assignment operations for variant.\n  template <class Left, class QualifiedNew>\n  struct ConversionAssignVisitor {\n    using NewIndex =\n        variant_internal::IndexOfConstructedType<Left, QualifiedNew>;\n\n    void operator()(SizeT<NewIndex::value> /*old_i*/\n    ) const {\n      Access<NewIndex::value>(*left) = absl::forward<QualifiedNew>(other);\n    }\n\n    template <std::size_t OldIndex>\n    void operator()(SizeT<OldIndex> /*old_i*/\n    ) const {\n      using New =\n          typename absl::variant_alternative<NewIndex::value, Left>::type;\n      if (std::is_nothrow_constructible<New, QualifiedNew>::value ||\n          !std::is_nothrow_move_constructible<New>::value) {\n        left->template emplace<NewIndex::value>(\n            absl::forward<QualifiedNew>(other));\n      } else {\n        // the standard says \"equivalent to\n        // operator=(variant(std::forward<T>(t)))\", but we use `emplace` here\n        // because the variant's move assignment operator could be deleted.\n        left->template emplace<NewIndex::value>(\n            New(absl::forward<QualifiedNew>(other)));\n      }\n    }\n\n    Left* left;\n    QualifiedNew&& other;\n  };\n\n  template <class Left, class QualifiedNew>\n  static ConversionAssignVisitor<Left, QualifiedNew>\n  MakeConversionAssignVisitor(Left* left, QualifiedNew&& qual) {\n    return {left, absl::forward<QualifiedNew>(qual)};\n  }\n\n  // Backend for operations for `emplace()` which destructs `*self` then\n  // construct a new alternative with `Args...`.\n  template <std::size_t NewIndex, class Self, class... Args>\n  static typename absl::variant_alternative<NewIndex, Self>::type& Replace(\n      Self* self, Args&&... args) {\n    Destroy(*self);\n    using New = typename absl::variant_alternative<NewIndex, Self>::type;\n    New* const result = ::new (static_cast<void*>(&self->state_))\n        New(absl::forward<Args>(args)...);\n    self->index_ = NewIndex;\n    return *result;\n  }\n\n  template <class LeftVariant, class QualifiedRightVariant>\n  struct InitFromVisitor {\n    template <std::size_t NewIndex>\n    void operator()(SizeT<NewIndex> /*new_i*/) const {\n      using Alternative =\n          typename variant_alternative<NewIndex, LeftVariant>::type;\n      ::new (static_cast<void*>(&left->state_)) Alternative(\n          Access<NewIndex>(std::forward<QualifiedRightVariant>(right)));\n    }\n\n    void operator()(SizeT<absl::variant_npos> /*new_i*/) const {\n      // This space intentionally left blank.\n    }\n    LeftVariant* left;\n    QualifiedRightVariant&& right;\n  };\n}",
  "id": "BLOCK-CPP-06692",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/internal/variant.h",
  "source_line": 565,
  "validation_status": "validated"
}