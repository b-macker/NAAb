{
  "code": "{\n\n#if defined(__x86_64__) || defined(_M_X64)\n\nnamespace {\n\nenum class Vendor {\n  kUnknown,\n  kIntel,\n  kAmd,\n};\n\nVendor GetVendor() {\n  // Get the vendor string (issue CPUID with eax = 0).\n  int cpu_info[4];\n  __cpuid(cpu_info, 0);\n\n  std::string vendor;\n  vendor.append(reinterpret_cast<char*>(&cpu_info[1]), 4);\n  vendor.append(reinterpret_cast<char*>(&cpu_info[3]), 4);\n  vendor.append(reinterpret_cast<char*>(&cpu_info[2]), 4);\n  if (vendor == \"GenuineIntel\") {\n    return Vendor::kIntel;\n  } else if (vendor == \"AuthenticAMD\") {\n    return Vendor::kAmd;\n  } else {\n    return Vendor::kUnknown;\n  }\n}\n\nCpuType GetIntelCpuType() {\n  // To get general information and extended features we send eax = 1 and\n  // ecx = 0 to cpuid.  The response is returned in eax, ebx, ecx and edx.\n  // (See Intel 64 and IA-32 Architectures Software Developer's Manual\n  // Volume 2A: Instruction Set Reference, A-M CPUID).\n  // https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html\n  // https://learn.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex\n  int cpu_info[4];\n  __cpuid(cpu_info, 1);\n\n  // Response in eax bits as follows:\n  // 0-3 (stepping id)\n  // 4-7 (model number),\n  // 8-11 (family code),\n  // 12-13 (processor type),\n  // 16-19 (extended model)\n  // 20-27 (extended family)\n\n  int family = (cpu_info[0] >> 8) & 0x0f;\n  int model_num = (cpu_info[0] >> 4) & 0x0f;\n  int ext_family = (cpu_info[0] >> 20) & 0xff;\n  int ext_model_num = (cpu_info[0] >> 16) & 0x0f;\n\n  int brand_id = cpu_info[1] & 0xff;\n\n  // Process the extended family and model info if necessary\n  if (family == 0x0f) {\n    family += ext_family;\n  }\n\n  if (family == 0x0f || family == 0x6) {\n    model_num += (ext_model_num << 4);\n  }\n\n  switch (brand_id) {\n    case 0:  // no brand ID, so parse CPU family/model\n      switch (family) {\n        case 6:  // Most PentiumIII processors are in this category\n          switch (model_num) {\n            case 0x2c:  // Westmere: Gulftown\n              return CpuType::kIntelWestmere;\n            case 0x2d:  // Sandybridge\n              return CpuType::kIntelSandybridge;\n            case 0x3e:  // Ivybridge\n              return CpuType::kIntelIvybridge;\n            case 0x3c:  // Haswell (client)\n            case 0x3f:  // Haswell\n              return CpuType::kIntelHaswell;\n            case 0x4f:  // Broadwell\n            case 0x56:  // BroadwellDE\n              return CpuType::kIntelBroadwell;\n            case 0x55:                 // Skylake Xeon\n              if ((cpu_info[0] & 0x0f) < 5) {  // stepping < 5 is skylake\n                return CpuType::kIntelSkylakeXeon;\n              } else {  // stepping >= 5 is cascadelake\n                return CpuType::kIntelCascadelakeXeon;\n              }\n            case 0x5e:  // Skylake (client)\n              return CpuType::kIntelSkylake;\n            default:\n              return CpuType::kUnknown;\n          }\n        default:\n          return CpuType::kUnknown;\n      }\n    default:\n      return CpuType::kUnknown;\n  }\n}\n\nCpuType GetAmdCpuType() {\n  // To get general information and extended features we send eax = 1 and\n  // ecx = 0 to cpuid.  The response is returned in eax, ebx, ecx and edx.\n  // (See Intel 64 and IA-32 Architectures Software Developer's Manual\n  // Volume 2A: Instruction Set Reference, A-M CPUID).\n  // https://learn.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex\n  int cpu_info[4];\n  __cpuid(cpu_info, 1);\n\n  // Response in eax bits as follows:\n  // 0-3 (stepping id)\n  // 4-7 (model number),\n  // 8-11 (family code),\n  // 12-13 (processor type),\n  // 16-19 (extended model)\n  // 20-27 (extended family)\n\n  int family = (cpu_info[0] >> 8) & 0x0f;\n  int model_num = (cpu_info[0] >> 4) & 0x0f;\n  int ext_family = (cpu_info[0] >> 20) & 0xff;\n  int ext_model_num = (cpu_info[0] >> 16) & 0x0f;\n\n  if (family == 0x0f) {\n    family += ext_family;\n    model_num += (ext_model_num << 4);\n  }\n\n  switch (family) {\n    case 0x17:\n      switch (model_num) {\n        case 0x0:  // Stepping Ax\n        case 0x1:  // Stepping Bx\n          return CpuType::kAmdNaples;\n        case 0x30:  // Stepping Ax\n        case 0x31:  // Stepping Bx\n          return CpuType::kAmdRome;\n        default:\n          return CpuType::kUnknown;\n      }\n      break;\n    case 0x19:\n      switch (model_num) {\n        case 0x0:  // Stepping Ax\n        case 0x1:  // Stepping B0\n          return CpuType::kAmdMilan;\n        case 0x10:  // Stepping A0\n        case 0x11:  // Stepping B0\n          return CpuType::kAmdGenoa;\n        case 0x44:  // Stepping A0\n          return CpuType::kAmdRyzenV3000;\n        default:\n          return CpuType::kUnknown;\n      }\n      break;\n    default:\n      return CpuType::kUnknown;\n  }\n}\n\n}  // namespace\n\nCpuType GetCpuType() {\n  switch (GetVendor()) {\n    case Vendor::kIntel:\n      return GetIntelCpuType();\n    case Vendor::kAmd:\n      return GetAmdCpuType();\n    default:\n      return CpuType::kUnknown;\n  }\n}\n\nbool SupportsArmCRC32PMULL() { return false; }\n\n#elif defined(__aarch64__) && defined(__linux__)\n\n#ifndef HWCAP_CPUID\n#define HWCAP_CPUID (1 << 11)\n#endif\n\n#define ABSL_INTERNAL_AARCH64_ID_REG_READ(id, val) \\\n  asm(\"mrs %0, \" #id : \"=r\"(val))\n\nCpuType GetCpuType() {\n  // MIDR_EL1 is not visible to EL0, however the access will be emulated by\n  // linux if AT_HWCAP has HWCAP_CPUID set.\n  //\n  // This method will be unreliable on heterogeneous computing systems (ex:\n  // big.LITTLE) since the value of MIDR_EL1 will change based on the calling\n  // thread.\n  uint64_t hwcaps = getauxval(AT_HWCAP);\n  if (hwcaps & HWCAP_CPUID) {\n    uint64_t midr = 0;\n    ABSL_INTERNAL_AARCH64_ID_REG_READ(MIDR_EL1, midr);\n    uint32_t implementer = (midr >> 24) & 0xff;\n    uint32_t part_number = (midr >> 4) & 0xfff;\n    switch (implementer) {\n      case 0x41:\n        switch (part_number) {\n          case 0xd0c: return CpuType::kArmNeoverseN1;\n          case 0xd40: return CpuType::kArmNeoverseV1;\n          case 0xd49: return CpuType::kArmNeoverseN2;\n          case 0xd4f: return CpuType::kArmNeoverseV2;\n          default:\n            return CpuType::kUnknown;\n        }\n        break;\n      case 0xc0:\n        switch (part_number) {\n          case 0xac3: return CpuType::kAmpereSiryn;\n          default:\n            return CpuType::kUnknown;\n        }\n        break;\n      default:\n        return CpuType::kUnknown;\n    }\n  }\n  return CpuType::kUnknown;\n}\n\nbool SupportsArmCRC32PMULL() {\n  uint64_t hwcaps = getauxval(AT_HWCAP);\n  return (hwcaps & HWCAP_CRC32) && (hwcaps & HWCAP_PMULL);\n}\n\n#else\n\nCpuType GetCpuType() { return CpuType::kUnknown; }\n\nbool SupportsArmCRC32PMULL() { return false; }\n\n#endif\n\n}",
  "id": "BLOCK-CPP-02458",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/cpu_detect.cc",
  "source_line": 50,
  "validation_status": "validated"
}