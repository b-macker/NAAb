{
  "code": "{\n\nclass Expr;\nclass IdentifierInfo;\n\n/// Designator - A designator in a C99 designated initializer.\n///\n/// This class is a discriminated union which holds the various\n/// different sorts of designators possible. A Designation is an array of\n/// these.  An example of a designator are things like this:\n///\n///      [8] .field [47]        // C99 designation: 3 designators\n///      [8 ... 47]  field:     // GNU extensions: 2 designators\n///\n/// These occur in initializers, e.g.:\n///\n///      int a[10] = {2, 4, [8]=9, 10};\n///\nclass Designator {\n  /// A field designator, e.g., \".x = 42\".\n  struct FieldDesignatorInfo {\n    /// Refers to the field being initialized.\n    const IdentifierInfo *FieldName;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n\n    FieldDesignatorInfo(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n                        SourceLocation FieldLoc)\n        : FieldName(FieldName), DotLoc(DotLoc), FieldLoc(FieldLoc) {}\n  };\n\n  /// An array designator, e.g., \"[42] = 0\".\n  struct ArrayDesignatorInfo {\n    Expr *Index;\n\n    // The location of the '[' in the designated initializer.\n    SourceLocation LBracketLoc;\n\n    // The location of the ']' in the designated initializer.\n    mutable SourceLocation RBracketLoc;\n\n    ArrayDesignatorInfo(Expr *Index, SourceLocation LBracketLoc)\n        : Index(Index), LBracketLoc(LBracketLoc) {}\n  };\n\n  /// An array range designator, e.g. \"[42 ... 50] = 1\".\n  struct ArrayRangeDesignatorInfo {\n    Expr *Start;\n    Expr *End;\n\n    // The location of the '[' in the designated initializer.\n    SourceLocation LBracketLoc;\n\n    // The location of the '...' in the designated initializer.\n    SourceLocation EllipsisLoc;\n\n    // The location of the ']' in the designated initializer.\n    mutable SourceLocation RBracketLoc;\n\n    ArrayRangeDesignatorInfo(Expr *Start, Expr *End, SourceLocation LBracketLoc,\n                             SourceLocation EllipsisLoc)\n        : Start(Start), End(End), LBracketLoc(LBracketLoc),\n          EllipsisLoc(EllipsisLoc) {}\n  };\n\n  /// The kind of designator this describes.\n  enum DesignatorKind {\n    FieldDesignator,\n    ArrayDesignator,\n    ArrayRangeDesignator\n  };\n\n  DesignatorKind Kind;\n\n  union {\n    FieldDesignatorInfo FieldInfo;\n    ArrayDesignatorInfo ArrayInfo;\n    ArrayRangeDesignatorInfo ArrayRangeInfo;\n  };\n\n  Designator(DesignatorKind Kind) : Kind(Kind) {}\n\npublic:\n  bool isFieldDesignator() const { return Kind == FieldDesignator; }\n  bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n  bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n  //===--------------------------------------------------------------------===//\n  // FieldDesignatorInfo\n\n  /// Creates a field designator.\n  static Designator CreateFieldDesignator(const IdentifierInfo *FieldName,\n                                          SourceLocation DotLoc,\n                                          SourceLocation FieldLoc) {\n    Designator D(FieldDesignator);\n    new (&D.FieldInfo) FieldDesignatorInfo(FieldName, DotLoc, FieldLoc);\n    return D;\n  }\n\n  const IdentifierInfo *getFieldDecl() const {\n    assert(isFieldDesignator() && \"Invalid accessor\");\n    return FieldInfo.FieldName;\n  }\n\n  SourceLocation getDotLoc() const {\n    assert(isFieldDesignator() && \"Invalid accessor\");\n    return FieldInfo.DotLoc;\n  }\n\n  SourceLocation getFieldLoc() const {\n    assert(isFieldDesignator() && \"Invalid accessor\");\n    return FieldInfo.FieldLoc;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // ArrayDesignatorInfo:\n\n  /// Creates an array designator.\n  static Designator CreateArrayDesignator(Expr *Index,\n                                          SourceLocation LBracketLoc) {\n    Designator D(ArrayDesignator);\n    new (&D.ArrayInfo) ArrayDesignatorInfo(Index, LBracketLoc);\n    return D;\n  }\n\n  Expr *getArrayIndex() const {\n    assert(isArrayDesignator() && \"Invalid accessor\");\n    return ArrayInfo.Index;\n  }\n\n  SourceLocation getLBracketLoc() const {\n    assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n           \"Invalid accessor\");\n    return isArrayDesignator() ? ArrayInfo.LBracketLoc\n                               : ArrayRangeInfo.LBracketLoc;\n  }\n\n  SourceLocation getRBracketLoc() const {\n    assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n           \"Invalid accessor\");\n    return isArrayDesignator() ? ArrayInfo.RBracketLoc\n                               : ArrayRangeInfo.RBracketLoc;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // ArrayRangeDesignatorInfo:\n\n  /// Creates a GNU array-range designator.\n  static Designator CreateArrayRangeDesignator(Expr *Start, Expr *End,\n                                               SourceLocation LBracketLoc,\n                                               SourceLocation EllipsisLoc) {\n    Designator D(ArrayRangeDesignator);\n    new (&D.ArrayRangeInfo)\n        ArrayRangeDesignatorInfo(Start, End, LBracketLoc, EllipsisLoc);\n    return D;\n  }\n\n  Expr *getArrayRangeStart() const {\n    assert(isArrayRangeDesignator() && \"Invalid accessor\");\n    return ArrayRangeInfo.Start;\n  }\n\n  Expr *getArrayRangeEnd() const {\n    assert(isArrayRangeDesignator() && \"Invalid accessor\");\n    return ArrayRangeInfo.End;\n  }\n\n  SourceLocation getEllipsisLoc() const {\n    assert(isArrayRangeDesignator() && \"Invalid accessor\");\n    return ArrayRangeInfo.EllipsisLoc;\n  }\n\n  void setRBracketLoc(SourceLocation RBracketLoc) const {\n    assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n           \"Invalid accessor\");\n    if (isArrayDesignator())\n      ArrayInfo.RBracketLoc = RBracketLoc;\n    else\n      ArrayRangeInfo.RBracketLoc = RBracketLoc;\n  }\n};\n\n/// Designation - Represent a full designation, which is a sequence of\n/// designators.  This class is mostly a helper for InitListDesignations.\nclass Designation {\n  /// Designators - The actual designators for this initializer.\n  SmallVector<Designator, 2> Designators;\n\npublic:\n  /// AddDesignator - Add a designator to the end of this list.\n  void AddDesignator(Designator D) { Designators.push_back(D); }\n\n  bool empty() const { return Designators.empty(); }\n\n  unsigned getNumDesignators() const { return Designators.size(); }\n  const Designator &getDesignator(unsigned Idx) const {\n    assert(Idx < Designators.size());\n    return Designators[Idx];\n  }\n};\n\n}",
  "id": "BLOCK-CPP-19783",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Designator.h",
  "source_line": 20,
  "validation_status": "validated"
}