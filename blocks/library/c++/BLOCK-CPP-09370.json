{
  "code": "{\n///    template <class U> void foo(U a) { }\n///    template<> void foo(int a) { }\n/// }\n/// \\endcode\n///\n/// \"template<> foo(int a)\" will be saved in Specialization as a normal\n/// CXXMethodDecl. Then during an instantiation of class A, it will be\n/// transformed into an actual function specialization.\n///\n/// FIXME: This is redundant; we could store the same information directly on\n/// the CXXMethodDecl as a DependentFunctionTemplateSpecializationInfo.\nclass ClassScopeFunctionSpecializationDecl : public Decl {\n  CXXMethodDecl *Specialization;\n  const ASTTemplateArgumentListInfo *TemplateArgs;\n\n  ClassScopeFunctionSpecializationDecl(\n      DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n      const ASTTemplateArgumentListInfo *TemplArgs)\n      : Decl(Decl::ClassScopeFunctionSpecialization, DC, Loc),\n        Specialization(FD), TemplateArgs(TemplArgs) {}\n\n  ClassScopeFunctionSpecializationDecl(EmptyShell Empty)\n      : Decl(Decl::ClassScopeFunctionSpecialization, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  CXXMethodDecl *getSpecialization() const { return Specialization; }\n  bool hasExplicitTemplateArgs() const { return TemplateArgs; }\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return TemplateArgs;\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n         bool HasExplicitTemplateArgs,\n         const TemplateArgumentListInfo &TemplateArgs) {\n    return new (C, DC) ClassScopeFunctionSpecializationDecl(\n        DC, Loc, FD,\n        HasExplicitTemplateArgs\n            ? ASTTemplateArgumentListInfo::Create(C, TemplateArgs)\n            : nullptr);\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  CreateDeserialized(ASTContext &Context, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == Decl::ClassScopeFunctionSpecialization;\n  }\n};\n\n/// Represents a variable template specialization, which refers to\n/// a variable template with a given set of template arguments.\n///\n/// Variable template specializations represent both explicit\n/// specializations of variable templates, as in the example below, and\n/// implicit instantiations of variable templates.\n///\n/// \\code\n/// template<typename T> constexpr T pi = T(3.1415926535897932385);\n///\n/// template<>\n/// constexpr float pi<float>; // variable template specialization pi<float>\n/// \\endcode\nclass VarTemplateSpecializationDecl : public VarDecl,\n                                      public llvm::FoldingSetNode {\n\n  /// Structure that stores information about a variable template\n  /// specialization that was instantiated from a variable template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The variable template partial specialization from which this\n    /// variable template specialization was instantiated.\n    VarTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the variable template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes.\n  llvm::PointerUnion<VarTemplateDecl *, SpecializedPartialSpecialization *>\n  SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n  const ASTTemplateArgumentListInfo *TemplateArgsInfo = nullptr;\n\n  /// The point where this template was instantiated (if any).\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\n  /// Whether this declaration is a complete definition of the\n  /// variable template specialization. We can't otherwise tell apart\n  /// an instantiated declaration from an instantiated definition with\n  /// no initializer.\n  unsigned IsCompleteDefinition : 1;\n\nprotected:\n  VarTemplateSpecializationDecl(Kind DK, ASTContext &Context, DeclContext *DC,\n                                SourceLocation StartLoc, SourceLocation IdLoc,\n                                VarTemplateDecl *SpecializedTemplate,\n                                QualType T, TypeSourceInfo *TInfo,\n                                StorageClass S,\n                                ArrayRef<TemplateArgument> Args);\n\n  explicit VarTemplateSpecializationDecl(Kind DK, ASTContext &Context);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class VarDecl;\n\n  static VarTemplateSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S,\n         ArrayRef<TemplateArgument> Args);\n  static VarTemplateSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  VarTemplateSpecializationDecl *getMostRecentDecl() {\n    VarDecl *Recent = static_cast<VarDecl *>(this)->getMostRecentDecl();\n    return cast<VarTemplateSpecializationDecl>(Recent);\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  VarTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the variable template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const { return *TemplateArgs; }\n\n  // TODO: Always set this when creating the new specialization?\n  void setTemplateArgsInfo(const TemplateArgumentListInfo &ArgsInfo);\n  void setTemplateArgsInfo(const ASTTemplateArgumentListInfo *ArgsInfo);\n\n  const ASTTemplateArgumentListInfo *getTemplateArgsInfo() const {\n    return TemplateArgsInfo;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  void setCompleteDefinition() { IsCompleteDefinition = true; }\n\n  /// If this variable template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// variable template or variable template partial specialization from which\n  /// it was instantiated.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<VarTemplateDecl *,\n                                VarTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the variable template or variable template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<VarTemplateDecl *>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate the initializer of the variable template or variable\n  /// template partial specialization from which this variable template\n  /// specialization was instantiated.\n  ///\n  /// \\returns For a variable template specialization instantiated from the\n  /// primary template, this function will return the same template arguments\n  /// as getTemplateArgs(). For a variable template specialization instantiated\n  /// from a variable template partial specialization, this function will the\n  /// return deduced template arguments for the variable template partial\n  /// specialization itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this variable template specialization is actually an\n  /// instantiation of the given variable template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(VarTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Already set to a variable template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this variable template specialization is an instantiation\n  /// of the given variable template.\n  void setInstantiationOf(VarTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Previously set to a variable template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ArrayRef<TemplateArgument> TemplateArgs,\n                      const ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstVarTemplateSpecialization &&\n           K <= lastVarTemplateSpecialization;\n  }\n};\n\nclass VarTemplatePartialSpecializationDecl\n    : public VarTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList *TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The variable template partial specialization from which this\n  /// variable template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this variable template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<VarTemplatePartialSpecializationDecl *, 1, bool>\n  InstantiatedFromMember;\n\n  VarTemplatePartialSpecializationDecl(\n      ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n      SourceLocation IdLoc, TemplateParameterList *Params,\n      VarTemplateDecl *SpecializedTemplate, QualType T, TypeSourceInfo *TInfo,\n      StorageClass S, ArrayRef<TemplateArgument> Args,\n      const ASTTemplateArgumentListInfo *ArgInfos);\n\n  VarTemplatePartialSpecializationDecl(ASTContext &Context)\n      : VarTemplateSpecializationDecl(VarTemplatePartialSpecialization,\n                                      Context),\n        InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static VarTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, TemplateParameterList *Params,\n         VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S, ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos);\n\n  static VarTemplatePartialSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                                  unsigned ID);\n\n  VarTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<VarTemplatePartialSpecializationDecl>(\n             static_cast<VarTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// \\brief Retrieve the member variable template partial specialization from\n  /// which this particular variable template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a variable template.\nclass VarTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// variable template.\n  struct Common : CommonBase {\n    /// The variable template specializations for this variable\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<VarTemplateSpecializationDecl> Specializations;\n\n    /// The variable template partial specializations for this variable\n    /// template.\n    llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl>\n    PartialSpecializations;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this variable template.\n  llvm::FoldingSetVector<VarTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  VarTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                  DeclarationName Name, TemplateParameterList *Params,\n                  NamedDecl *Decl)\n      : RedeclarableTemplateDecl(VarTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying variable declarations of the template.\n  VarDecl *getTemplatedDecl() const {\n    return static_cast<VarDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// variable pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  VarTemplateDecl *getDefinition();\n\n  /// Create a variable template node.\n  static VarTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, DeclarationName Name,\n                                 TemplateParameterList *Params,\n                                 VarDecl *Decl);\n\n  /// Create an empty variable template node.\n  static VarTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  VarTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(VarTemplateSpecializationDecl *D, void *InsertPos);\n\n  VarTemplateDecl *getCanonicalDecl() override {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const VarTemplateDecl *getCanonicalDecl() const {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this variable template, or\n  /// nullptr if no such declaration exists.\n  VarTemplateDecl *getPreviousDecl() {\n    return cast_or_null<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const VarTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<VarTemplateDecl>(\n            static_cast<const RedeclarableTemplateDecl *>(\n              this)->getPreviousDecl());\n  }\n\n  VarTemplateDecl *getMostRecentDecl() {\n    return cast<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const VarTemplateDecl *getMostRecentDecl() const {\n    return const_cast<VarTemplateDecl *>(this)->getMostRecentDecl();\n  }\n\n  VarTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<VarTemplateDecl>(\n        RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  VarTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(VarTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<VarTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member variable template partial specialization.\n  ///\n  /// \\returns the variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  VarTemplatePartialSpecializationDecl *findPartialSpecInstantiatedFromMember(\n      VarTemplatePartialSpecializationDecl *D);\n\n  using spec_iterator = SpecIterator<VarTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == VarTemplate; }\n};\n\n/// Declaration of a C++20 concept.\nclass ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl> {\nprotected:\n  Expr *ConstraintExpr;\n\n  ConceptDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n              TemplateParameterList *Params, Expr *ConstraintExpr)\n      : TemplateDecl(Concept, DC, L, Name, Params),\n        ConstraintExpr(ConstraintExpr) {};\npublic:\n  static ConceptDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation L, DeclarationName Name,\n                             TemplateParameterList *Params,\n                             Expr *ConstraintExpr);\n  static ConceptDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getConstraintExpr() const {\n    return ConstraintExpr;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       ConstraintExpr->getEndLoc());\n  }\n\n  bool isTypeConcept() const {\n    return isa<TemplateTypeParmDecl>(getTemplateParameters()->getParam(0));\n  }\n\n  ConceptDecl *getCanonicalDecl() override {\n    return cast<ConceptDecl>(getPrimaryMergedDecl(this));\n  }\n  const ConceptDecl *getCanonicalDecl() const {\n    return const_cast<ConceptDecl *>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Concept; }\n\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n};\n\n// An implementation detail of ConceptSpecialicationExpr that holds the template\n// arguments, so we can later use this to reconstitute the template arguments\n// during constraint checking.\nclass ImplicitConceptSpecializationDecl final\n    : public Decl,\n      private llvm::TrailingObjects<ImplicitConceptSpecializationDecl,\n                                    TemplateArgument> {\n  unsigned NumTemplateArgs;\n\n  ImplicitConceptSpecializationDecl(DeclContext *DC, SourceLocation SL,\n                                    ArrayRef<TemplateArgument> ConvertedArgs);\n  ImplicitConceptSpecializationDecl(EmptyShell Empty, unsigned NumTemplateArgs);\n\npublic:\n  static ImplicitConceptSpecializationDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation SL,\n         ArrayRef<TemplateArgument> ConvertedArgs);\n  static ImplicitConceptSpecializationDecl *\n  CreateDeserialized(const ASTContext &C, unsigned ID,\n                     unsigned NumTemplateArgs);\n\n  ArrayRef<TemplateArgument> getTemplateArguments() const {\n    return ArrayRef<TemplateArgument>(getTrailingObjects<TemplateArgument>(),\n                                      NumTemplateArgs);\n  }\n  void setTemplateArguments(ArrayRef<TemplateArgument> Converted);\n\n  static bool classofKind(Kind K) { return K == ImplicitConceptSpecialization; }\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n};\n\n/// A template parameter object.\n///\n/// Template parameter objects represent values of class type used as template\n/// arguments. There is one template parameter object for each such distinct\n/// value used as a template argument across the program.\n///\n/// \\code\n/// struct A { int x, y; };\n/// template<A> struct S;\n/// S<A{1, 2}> s1;\n/// S<A{1, 2}> s2; // same type, argument is same TemplateParamObjectDecl.\n/// \\endcode\nclass TemplateParamObjectDecl : public ValueDecl,\n                                public Mergeable<TemplateParamObjectDecl>,\n                                public llvm::FoldingSetNode {\nprivate:\n  /// The value of this template parameter object.\n  APValue Value;\n\n  TemplateParamObjectDecl(DeclContext *DC, QualType T, const APValue &V)\n      : ValueDecl(TemplateParamObject, DC, SourceLocation(), DeclarationName(),\n                  T),\n        Value(V) {}\n\n  static TemplateParamObjectDecl *Create(const ASTContext &C, QualType T,\n                                         const APValue &V);\n  static TemplateParamObjectDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Only ASTContext::getTemplateParamObjectDecl and deserialization\n  /// create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this template parameter object in a human-readable format.\n  void printName(llvm::raw_ostream &OS,\n                 const PrintingPolicy &Policy) const override;\n\n  /// Print this object as an equivalent expression.\n  void printAsExpr(llvm::raw_ostream &OS) const;\n  void printAsExpr(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print this object as an initializer suitable for a variable of the\n  /// object's type.\n  void printAsInit(llvm::raw_ostream &OS) const;\n  void printAsInit(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T,\n                      const APValue &V) {\n    ID.AddPointer(T.getCanonicalType().getAsOpaquePtr());\n    V.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  TemplateParamObjectDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const TemplateParamObjectDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateParamObject; }\n};\n\ninline NamedDecl *getAsNamedDecl(TemplateParameter P) {\n  if (auto *PD = P.dyn_cast<TemplateTypeParmDecl *>())\n    return PD;\n  if (auto *PD = P.dyn_cast<NonTypeTemplateParmDecl *>())\n    return PD;\n  return P.get<TemplateTemplateParmDecl *>();\n}\n\ninline TemplateDecl *getAsTypeTemplateDecl(Decl *D) {\n  auto *TD = dyn_cast<TemplateDecl>(D);\n  return TD && (isa<ClassTemplateDecl>(TD) ||\n                isa<ClassTemplatePartialSpecializationDecl>(TD) ||\n                isa<TypeAliasTemplateDecl>(TD) ||\n                isa<TemplateTemplateParmDecl>(TD))\n             ? TD\n             : nullptr;\n}\n\n/// Check whether the template parameter is a pack expansion, and if so,\n/// determine the number of parameters produced by that expansion. For instance:\n///\n/// \\code\n/// template<typename ...Ts> struct A {\n///   template<Ts ...NTs, template<Ts> class ...TTs, typename ...Us> struct B;\n/// };\n/// \\endcode\n///\n/// In \\c A<int,int>::B, \\c NTs and \\c TTs have expanded pack size 2, and \\c Us\n/// is not a pack expansion, so returns an empty Optional.\ninline std::optional<unsigned> getExpandedPackSize(const NamedDecl *Param) {\n  if (const auto *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionParameters();\n  }\n\n  if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (NTTP->isExpandedParameterPack())\n      return NTTP->getNumExpansionTypes();\n  }\n\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionTemplateParameters();\n  }\n\n  return std::nullopt;\n}\n\n/// Internal helper used by Subst* nodes to retrieve the parameter list\n/// for their AssociatedDecl.\nTemplateParameterList *getReplacedTemplateParameterList(Decl *D);\n\n}",
  "id": "BLOCK-CPP-09370",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 2623,
  "validation_status": "validated"
}