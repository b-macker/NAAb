{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::discrete_distribution\n//\n// A discrete distribution produces random integers i, where 0 <= i < n\n// distributed according to the discrete probability function:\n//\n//     P(i|p0,...,pnâˆ’1)=pi\n//\n// This class is an implementation of discrete_distribution (see\n// [rand.dist.samp.discrete]).\n//\n// The algorithm used is Walker's Aliasing algorithm, described in Knuth, Vol 2.\n// absl::discrete_distribution takes O(N) time to precompute the probabilities\n// (where N is the number of possible outcomes in the distribution) at\n// construction, and then takes O(1) time for each variate generation.  Many\n// other implementations also take O(N) time to construct an ordered sequence of\n// partial sums, plus O(log N) time per variate to binary search.\n//\ntemplate <typename IntType = int>\nclass discrete_distribution {\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = discrete_distribution;\n\n    param_type() { init(); }\n\n    template <typename InputIterator>\n    explicit param_type(InputIterator begin, InputIterator end)\n        : p_(begin, end) {\n      init();\n    }\n\n    explicit param_type(std::initializer_list<double> weights) : p_(weights) {\n      init();\n    }\n\n    template <class UnaryOperation>\n    explicit param_type(size_t nw, double xmin, double xmax,\n                        UnaryOperation fw) {\n      if (nw > 0) {\n        p_.reserve(nw);\n        double delta = (xmax - xmin) / static_cast<double>(nw);\n        assert(delta > 0);\n        double t = delta * 0.5;\n        for (size_t i = 0; i < nw; ++i) {\n          p_.push_back(fw(xmin + i * delta + t));\n        }\n      }\n      init();\n    }\n\n    const std::vector<double>& probabilities() const { return p_; }\n    size_t n() const { return p_.size() - 1; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.probabilities() == b.probabilities();\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class discrete_distribution;\n\n    void init();\n\n    std::vector<double> p_;                     // normalized probabilities\n    std::vector<std::pair<double, size_t>> q_;  // (acceptance, alternate) pairs\n\n    static_assert(std::is_integral<result_type>::value,\n                  \"Class-template absl::discrete_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  discrete_distribution() : param_() {}\n\n  explicit discrete_distribution(const param_type& p) : param_(p) {}\n\n  template <typename InputIterator>\n  explicit discrete_distribution(InputIterator begin, InputIterator end)\n      : param_(begin, end) {}\n\n  explicit discrete_distribution(std::initializer_list<double> weights)\n      : param_(weights) {}\n\n  template <class UnaryOperation>\n  explicit discrete_distribution(size_t nw, double xmin, double xmax,\n                                 UnaryOperation fw)\n      : param_(nw, xmin, xmax, std::move(fw)) {}\n\n  void reset() {}\n\n  // generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  const param_type& param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const {\n    return static_cast<result_type>(param_.n());\n  }  // inclusive\n\n  // NOTE [rand.dist.sample.discrete] returns a std::vector<double> not a\n  // const std::vector<double>&.\n  const std::vector<double>& probabilities() const {\n    return param_.probabilities();\n  }\n\n  friend bool operator==(const discrete_distribution& a,\n                         const discrete_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const discrete_distribution& a,\n                         const discrete_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n};\n\n// --------------------------------------------------------------------------\n// Implementation details only below\n// --------------------------------------------------------------------------\n\nnamespace random_internal {\n\n// Using the vector `*probabilities`, whose values are the weights or\n// probabilities of an element being selected, constructs the proportional\n// probabilities used by the discrete distribution.  `*probabilities` will be\n// scaled, if necessary, so that its entries sum to a value sufficiently close\n// to 1.0.\nstd::vector<std::pair<double, size_t>> InitDiscreteDistribution(\n    std::vector<double>* probabilities);\n\n}  // namespace random_internal\n\ntemplate <typename IntType>\nvoid discrete_distribution<IntType>::param_type::init() {\n  if (p_.empty()) {\n    p_.push_back(1.0);\n    q_.emplace_back(1.0, 0);\n  } else {\n    assert(n() <= (std::numeric_limits<IntType>::max)());\n    q_ = random_internal::InitDiscreteDistribution(&p_);\n  }\n}\n\ntemplate <typename IntType>\ntemplate <typename URBG>\ntypename discrete_distribution<IntType>::result_type\ndiscrete_distribution<IntType>::operator()(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  const auto idx = absl::uniform_int_distribution<result_type>(0, p.n())(g);\n  const auto& q = p.q_[idx];\n  const bool selected = absl::bernoulli_distribution(q.first)(g);\n  return selected ? idx : static_cast<result_type>(q.second);\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const discrete_distribution<IntType>& x) {\n  auto saver = random_internal::make_ostream_state_saver(os);\n  const auto& probabilities = x.param().probabilities();\n  os << probabilities.size();\n\n  os.precision(random_internal::stream_precision_helper<double>::kPrecision);\n  for (const auto& p : probabilities) {\n    os << os.fill() << p;\n  }\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    discrete_distribution<IntType>& x) {    // NOLINT(runtime/references)\n  using param_type = typename discrete_distribution<IntType>::param_type;\n  auto saver = random_internal::make_istream_state_saver(is);\n\n  size_t n;\n  std::vector<double> p;\n\n  is >> n;\n  if (is.fail()) return is;\n  if (n > 0) {\n    p.reserve(n);\n    for (IntType i = 0; i < n && !is.fail(); ++i) {\n      auto tmp = random_internal::read_floating_point<double>(is);\n      if (is.fail()) return is;\n      p.push_back(tmp);\n    }\n  }\n  x.param(param_type(p.begin(), p.end()));\n  return is;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03832",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/discrete_distribution.h",
  "source_line": 31,
  "validation_status": "validated"
}