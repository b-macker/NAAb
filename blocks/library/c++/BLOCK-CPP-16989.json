{
  "code": "{\n\n/// Indicates whether a file or directory holds normal user code,\n/// system code, or system code which is implicitly 'extern \"C\"' in C++ mode.\n///\n/// Entire directories can be tagged with this (this is maintained by\n/// DirectoryLookup and friends) as can specific FileInfos when a \\#pragma\n/// system_header is seen or in various other cases.\n///\nenum CharacteristicKind {\n  C_User,\n  C_System,\n  C_ExternCSystem,\n  C_User_ModuleMap,\n  C_System_ModuleMap\n};\n\n/// Determine whether a file / directory characteristic is for system code.\ninline bool isSystem(CharacteristicKind CK) {\n  return CK != C_User && CK != C_User_ModuleMap;\n}\n\n/// Determine whether a file characteristic is for a module map.\ninline bool isModuleMap(CharacteristicKind CK) {\n  return CK == C_User_ModuleMap || CK == C_System_ModuleMap;\n}\n\n/// Mapping of line offsets into a source file. This does not own the storage\n/// for the line numbers.\nclass LineOffsetMapping {\npublic:\n  explicit operator bool() const { return Storage; }\n  unsigned size() const {\n    assert(Storage);\n    return Storage[0];\n  }\n  ArrayRef<unsigned> getLines() const {\n    assert(Storage);\n    return ArrayRef<unsigned>(Storage + 1, Storage + 1 + size());\n  }\n  const unsigned *begin() const { return getLines().begin(); }\n  const unsigned *end() const { return getLines().end(); }\n  const unsigned &operator[](int I) const { return getLines()[I]; }\n\n  static LineOffsetMapping get(llvm::MemoryBufferRef Buffer,\n                               llvm::BumpPtrAllocator &Alloc);\n\n  LineOffsetMapping() = default;\n  LineOffsetMapping(ArrayRef<unsigned> LineOffsets,\n                    llvm::BumpPtrAllocator &Alloc);\n\nprivate:\n  /// First element is the size, followed by elements at off-by-one indexes.\n  unsigned *Storage = nullptr;\n};\n\n/// One instance of this struct is kept for every file loaded or used.\n///\n/// This object owns the MemoryBuffer object.\nclass alignas(8) ContentCache {\n  /// The actual buffer containing the characters from the input\n  /// file.\n  mutable std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\npublic:\n  /// Reference to the file entry representing this ContentCache.\n  ///\n  /// This reference does not own the FileEntry object.\n  ///\n  /// It is possible for this to be NULL if the ContentCache encapsulates\n  /// an imaginary text buffer.\n  ///\n  /// FIXME: Make non-optional using a virtual file as needed, remove \\c\n  /// Filename and use \\c OrigEntry.getNameAsRequested() instead.\n  OptionalFileEntryRefDegradesToFileEntryPtr OrigEntry;\n\n  /// References the file which the contents were actually loaded from.\n  ///\n  /// Can be different from 'Entry' if we overridden the contents of one file\n  /// with the contents of another file.\n  const FileEntry *ContentsEntry;\n\n  /// The filename that is used to access OrigEntry.\n  ///\n  /// FIXME: Remove this once OrigEntry is a FileEntryRef with a stable name.\n  StringRef Filename;\n\n  /// A bump pointer allocated array of offsets for each source line.\n  ///\n  /// This is lazily computed.  The lines are owned by the SourceManager\n  /// BumpPointerAllocator object.\n  mutable LineOffsetMapping SourceLineCache;\n\n  /// Indicates whether the buffer itself was provided to override\n  /// the actual file contents.\n  ///\n  /// When true, the original entry may be a virtual file that does not\n  /// exist.\n  unsigned BufferOverridden : 1;\n\n  /// True if this content cache was initially created for a source file\n  /// considered to be volatile (likely to change between stat and open).\n  unsigned IsFileVolatile : 1;\n\n  /// True if this file may be transient, that is, if it might not\n  /// exist at some later point in time when this content entry is used,\n  /// after serialization and deserialization.\n  unsigned IsTransient : 1;\n\n  mutable unsigned IsBufferInvalid : 1;\n\n  ContentCache()\n      : OrigEntry(std::nullopt), ContentsEntry(nullptr),\n        BufferOverridden(false), IsFileVolatile(false), IsTransient(false),\n        IsBufferInvalid(false) {}\n\n  ContentCache(FileEntryRef Ent) : ContentCache(Ent, Ent) {}\n\n  ContentCache(FileEntryRef Ent, const FileEntry *contentEnt)\n      : OrigEntry(Ent), ContentsEntry(contentEnt), BufferOverridden(false),\n        IsFileVolatile(false), IsTransient(false), IsBufferInvalid(false) {}\n\n  /// The copy ctor does not allow copies where source object has either\n  /// a non-NULL Buffer or SourceLineCache.  Ownership of allocated memory\n  /// is not transferred, so this is a logical error.\n  ContentCache(const ContentCache &RHS)\n      : BufferOverridden(false), IsFileVolatile(false), IsTransient(false),\n        IsBufferInvalid(false) {\n    OrigEntry = RHS.OrigEntry;\n    ContentsEntry = RHS.ContentsEntry;\n\n    assert(!RHS.Buffer && !RHS.SourceLineCache &&\n           \"Passed ContentCache object cannot own a buffer.\");\n  }\n\n  ContentCache &operator=(const ContentCache &RHS) = delete;\n\n  /// Returns the memory buffer for the associated content.\n  ///\n  /// \\param Diag Object through which diagnostics will be emitted if the\n  ///   buffer cannot be retrieved.\n  ///\n  /// \\param Loc If specified, is the location that invalid file diagnostics\n  ///   will be emitted at.\n  std::optional<llvm::MemoryBufferRef>\n  getBufferOrNone(DiagnosticsEngine &Diag, FileManager &FM,\n                  SourceLocation Loc = SourceLocation()) const;\n\n  /// Returns the size of the content encapsulated by this\n  /// ContentCache.\n  ///\n  /// This can be the size of the source file or the size of an\n  /// arbitrary scratch buffer.  If the ContentCache encapsulates a source\n  /// file this size is retrieved from the file's FileEntry.\n  unsigned getSize() const;\n\n  /// Returns the number of bytes actually mapped for this\n  /// ContentCache.\n  ///\n  /// This can be 0 if the MemBuffer was not actually expanded.\n  unsigned getSizeBytesMapped() const;\n\n  /// Returns the kind of memory used to back the memory buffer for\n  /// this content cache.  This is used for performance analysis.\n  llvm::MemoryBuffer::BufferKind getMemoryBufferKind() const;\n\n  /// Return the buffer, only if it has been loaded.\n  std::optional<llvm::MemoryBufferRef> getBufferIfLoaded() const {\n    if (Buffer)\n      return Buffer->getMemBufferRef();\n    return std::nullopt;\n  }\n\n  /// Return a StringRef to the source buffer data, only if it has already\n  /// been loaded.\n  std::optional<StringRef> getBufferDataIfLoaded() const {\n    if (Buffer)\n      return Buffer->getBuffer();\n    return std::nullopt;\n  }\n\n  /// Set the buffer.\n  void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {\n    IsBufferInvalid = false;\n    Buffer = std::move(B);\n  }\n\n  /// Set the buffer to one that's not owned (or to nullptr).\n  ///\n  /// \\pre Buffer cannot already be set.\n  void setUnownedBuffer(std::optional<llvm::MemoryBufferRef> B) {\n    assert(!Buffer && \"Expected to be called right after construction\");\n    if (B)\n      setBuffer(llvm::MemoryBuffer::getMemBuffer(*B));\n  }\n\n  // If BufStr has an invalid BOM, returns the BOM name; otherwise, returns\n  // nullptr\n  static const char *getInvalidBOM(StringRef BufStr);\n};\n\n// Assert that the \\c ContentCache objects will always be 8-byte aligned so\n// that we can pack 3 bits of integer into pointers to such objects.\nstatic_assert(alignof(ContentCache) >= 8,\n              \"ContentCache must be 8-byte aligned.\");\n\n/// Information about a FileID, basically just the logical file\n/// that it represents and include stack information.\n///\n/// Each FileInfo has include stack information, indicating where it came\n/// from. This information encodes the \\#include chain that a token was\n/// expanded from. The main include file has an invalid IncludeLoc.\n///\n/// FileInfo should not grow larger than ExpansionInfo. Doing so will\n/// cause memory to bloat in compilations with many unloaded macro\n/// expansions, since the two data structurs are stored in a union in\n/// SLocEntry. Extra fields should instead go in \"ContentCache *\", which\n/// stores file contents and other bits on the side.\n///\nclass FileInfo {\n  friend class clang::SourceManager;\n  friend class clang::ASTWriter;\n  friend class clang::ASTReader;\n\n  /// The location of the \\#include that brought in this file.\n  ///\n  /// This is an invalid SLOC for the main file (top of the \\#include chain).\n  SourceLocation IncludeLoc;\n\n  /// Number of FileIDs (files and macros) that were created during\n  /// preprocessing of this \\#include, including this SLocEntry.\n  ///\n  /// Zero means the preprocessor didn't provide such info for this SLocEntry.\n  unsigned NumCreatedFIDs : 31;\n\n  /// Whether this FileInfo has any \\#line directives.\n  unsigned HasLineDirectives : 1;\n\n  /// The content cache and the characteristic of the file.\n  llvm::PointerIntPair<const ContentCache *, 3, CharacteristicKind>\n      ContentAndKind;\n\npublic:\n  /// Return a FileInfo object.\n  static FileInfo get(SourceLocation IL, ContentCache &Con,\n                      CharacteristicKind FileCharacter, StringRef Filename) {\n    FileInfo X;\n    X.IncludeLoc = IL;\n    X.NumCreatedFIDs = 0;\n    X.HasLineDirectives = false;\n    X.ContentAndKind.setPointer(&Con);\n    X.ContentAndKind.setInt(FileCharacter);\n    Con.Filename = Filename;\n    return X;\n  }\n\n  SourceLocation getIncludeLoc() const {\n    return IncludeLoc;\n  }\n\n  const ContentCache &getContentCache() const {\n    return *ContentAndKind.getPointer();\n  }\n\n  /// Return whether this is a system header or not.\n  CharacteristicKind getFileCharacteristic() const {\n    return ContentAndKind.getInt();\n  }\n\n  /// Return true if this FileID has \\#line directives in it.\n  bool hasLineDirectives() const { return HasLineDirectives; }\n\n  /// Set the flag that indicates that this FileID has\n  /// line table entries associated with it.\n  void setHasLineDirectives() { HasLineDirectives = true; }\n\n  /// Returns the name of the file that was used when the file was loaded from\n  /// the underlying file system.\n  StringRef getName() const { return getContentCache().Filename; }\n};\n\n/// Each ExpansionInfo encodes the expansion location - where\n/// the token was ultimately expanded, and the SpellingLoc - where the actual\n/// character data for the token came from.\nclass ExpansionInfo {\n  // Really these are all SourceLocations.\n\n  /// Where the spelling for the token can be found.\n  SourceLocation SpellingLoc;\n\n  /// In a macro expansion, ExpansionLocStart and ExpansionLocEnd\n  /// indicate the start and end of the expansion. In object-like macros,\n  /// they will be the same. In a function-like macro expansion, the start\n  /// will be the identifier and the end will be the ')'. Finally, in\n  /// macro-argument instantiations, the end will be 'SourceLocation()', an\n  /// invalid location.\n  SourceLocation ExpansionLocStart, ExpansionLocEnd;\n\n  /// Whether the expansion range is a token range.\n  bool ExpansionIsTokenRange;\n\npublic:\n  SourceLocation getSpellingLoc() const {\n    return SpellingLoc.isInvalid() ? getExpansionLocStart() : SpellingLoc;\n  }\n\n  SourceLocation getExpansionLocStart() const {\n    return ExpansionLocStart;\n  }\n\n  SourceLocation getExpansionLocEnd() const {\n    return ExpansionLocEnd.isInvalid() ? getExpansionLocStart()\n                                       : ExpansionLocEnd;\n  }\n\n  bool isExpansionTokenRange() const { return ExpansionIsTokenRange; }\n\n  CharSourceRange getExpansionLocRange() const {\n    return CharSourceRange(\n        SourceRange(getExpansionLocStart(), getExpansionLocEnd()),\n        isExpansionTokenRange());\n  }\n\n  bool isMacroArgExpansion() const {\n    // Note that this needs to return false for default constructed objects.\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isInvalid();\n  }\n\n  bool isMacroBodyExpansion() const {\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isValid();\n  }\n\n  bool isFunctionMacroExpansion() const {\n    return getExpansionLocStart().isValid() &&\n           getExpansionLocStart() != getExpansionLocEnd();\n  }\n\n  /// Return a ExpansionInfo for an expansion.\n  ///\n  /// Start and End specify the expansion range (where the macro is\n  /// expanded), and SpellingLoc specifies the spelling location (where\n  /// the characters from the token come from). All three can refer to\n  /// normal File SLocs or expansion locations.\n  static ExpansionInfo create(SourceLocation SpellingLoc, SourceLocation Start,\n                              SourceLocation End,\n                              bool ExpansionIsTokenRange = true) {\n    ExpansionInfo X;\n    X.SpellingLoc = SpellingLoc;\n    X.ExpansionLocStart = Start;\n    X.ExpansionLocEnd = End;\n    X.ExpansionIsTokenRange = ExpansionIsTokenRange;\n    return X;\n  }\n\n  /// Return a special ExpansionInfo for the expansion of\n  /// a macro argument into a function-like macro's body.\n  ///\n  /// ExpansionLoc specifies the expansion location (where the macro is\n  /// expanded). This doesn't need to be a range because a macro is always\n  /// expanded at a macro parameter reference, and macro parameters are\n  /// always exactly one token. SpellingLoc specifies the spelling location\n  /// (where the characters from the token come from). ExpansionLoc and\n  /// SpellingLoc can both refer to normal File SLocs or expansion locations.\n  ///\n  /// Given the code:\n  /// \\code\n  ///   #define F(x) f(x)\n  ///   F(42);\n  /// \\endcode\n  ///\n  /// When expanding '\\c F(42)', the '\\c x' would call this with an\n  /// SpellingLoc pointing at '\\c 42' and an ExpansionLoc pointing at its\n  /// location in the definition of '\\c F'.\n  static ExpansionInfo createForMacroArg(SourceLocation SpellingLoc,\n                                         SourceLocation ExpansionLoc) {\n    // We store an intentionally invalid source location for the end of the\n    // expansion range to mark that this is a macro argument location rather\n    // than a normal one.\n    return create(SpellingLoc, ExpansionLoc, SourceLocation());\n  }\n\n  /// Return a special ExpansionInfo representing a token that ends\n  /// prematurely. This is used to model a '>>' token that has been split\n  /// into '>' tokens and similar cases. Unlike for the other forms of\n  /// expansion, the expansion range in this case is a character range, not\n  /// a token range.\n  static ExpansionInfo createForTokenSplit(SourceLocation SpellingLoc,\n                                           SourceLocation Start,\n                                           SourceLocation End) {\n    return create(SpellingLoc, Start, End, false);\n  }\n};\n\n// Assert that the \\c FileInfo objects are no bigger than \\c ExpansionInfo\n// objects. This controls the size of \\c SLocEntry, of which we have one for\n// each macro expansion. The number of (unloaded) macro expansions can be\n// very large. Any other fields needed in FileInfo should go in ContentCache.\nstatic_assert(sizeof(FileInfo) <= sizeof(ExpansionInfo),\n              \"FileInfo must be no larger than ExpansionInfo.\");\n\n/// This is a discriminated union of FileInfo and ExpansionInfo.\n///\n/// SourceManager keeps an array of these objects, and they are uniquely\n/// identified by the FileID datatype.\nclass SLocEntry {\n  static constexpr int OffsetBits = 8 * sizeof(SourceLocation::UIntTy) - 1;\n  SourceLocation::UIntTy Offset : OffsetBits;\n  SourceLocation::UIntTy IsExpansion : 1;\n  union {\n    FileInfo File;\n    ExpansionInfo Expansion;\n  };\n\npublic:\n  SLocEntry() : Offset(), IsExpansion(), File() {}\n\n  SourceLocation::UIntTy getOffset() const { return Offset; }\n\n  bool isExpansion() const { return IsExpansion; }\n  bool isFile() const { return !isExpansion(); }\n\n  const FileInfo &getFile() const {\n    assert(isFile() && \"Not a file SLocEntry!\");\n    return File;\n  }\n\n  const ExpansionInfo &getExpansion() const {\n    assert(isExpansion() && \"Not a macro expansion SLocEntry!\");\n    return Expansion;\n  }\n\n  static SLocEntry get(SourceLocation::UIntTy Offset, const FileInfo &FI) {\n    assert(!(Offset & (1ULL << OffsetBits)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = false;\n    E.File = FI;\n    return E;\n  }\n\n  static SLocEntry get(SourceLocation::UIntTy Offset,\n                       const ExpansionInfo &Expansion) {\n    assert(!(Offset & (1ULL << OffsetBits)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = true;\n    new (&E.Expansion) ExpansionInfo(Expansion);\n    return E;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-16989",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceManager.h",
  "source_line": 71,
  "validation_status": "validated"
}