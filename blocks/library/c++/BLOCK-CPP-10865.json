{
  "code": "{\n\n/// \\brief A static requirement that can be used in a requires-expression to\n/// check properties of types and expression.\nclass Requirement {\npublic:\n  // Note - simple and compound requirements are both represented by the same\n  // class (ExprRequirement).\n  enum RequirementKind { RK_Type, RK_Simple, RK_Compound, RK_Nested };\nprivate:\n  const RequirementKind Kind;\n  // FIXME: use RequirementDependence to model dependence?\n  bool Dependent : 1;\n  bool ContainsUnexpandedParameterPack : 1;\n  bool Satisfied : 1;\npublic:\n  struct SubstitutionDiagnostic {\n    StringRef SubstitutedEntity;\n    // FIXME: Store diagnostics semantically and not as prerendered strings.\n    //  Fixing this probably requires serialization of PartialDiagnostic\n    //  objects.\n    SourceLocation DiagLoc;\n    StringRef DiagMessage;\n  };\n\n  Requirement(RequirementKind Kind, bool IsDependent,\n              bool ContainsUnexpandedParameterPack, bool IsSatisfied = true) :\n      Kind(Kind), Dependent(IsDependent),\n      ContainsUnexpandedParameterPack(ContainsUnexpandedParameterPack),\n      Satisfied(IsSatisfied) {}\n\n  RequirementKind getKind() const { return Kind; }\n\n  bool isSatisfied() const {\n    assert(!Dependent &&\n           \"isSatisfied can only be called on non-dependent requirements.\");\n    return Satisfied;\n  }\n\n  void setSatisfied(bool IsSatisfied) {\n    assert(!Dependent &&\n           \"setSatisfied can only be called on non-dependent requirements.\");\n    Satisfied = IsSatisfied;\n  }\n\n  void setDependent(bool IsDependent) { Dependent = IsDependent; }\n  bool isDependent() const { return Dependent; }\n\n  void setContainsUnexpandedParameterPack(bool Contains) {\n    ContainsUnexpandedParameterPack = Contains;\n  }\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the existence of a\n/// type name or type template specialization ('type' requirements).\nclass TypeRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_SubstitutionFailure,\n      SS_Satisfied\n  };\nprivate:\n  llvm::PointerUnion<SubstitutionDiagnostic *, TypeSourceInfo *> Value;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a type requirement from a type. If the given type is not\n  /// dependent, this indicates that the type exists and the requirement will be\n  /// satisfied. Otherwise, the SubstitutionDiagnostic constructor is to be\n  /// used.\n  TypeRequirement(TypeSourceInfo *T);\n\n  /// \\brief Construct a type requirement when the nested name specifier is\n  /// invalid due to a bad substitution. The requirement is unsatisfied.\n  TypeRequirement(SubstitutionDiagnostic *Diagnostic) :\n      Requirement(RK_Type, false, false, false), Value(Diagnostic),\n      Status(SS_SubstitutionFailure) {}\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n  void setSatisfactionStatus(SatisfactionStatus Status) {\n    this->Status = Status;\n  }\n\n  bool isSubstitutionFailure() const {\n    return Status == SS_SubstitutionFailure;\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(Status == SS_SubstitutionFailure &&\n           \"Attempted to get substitution diagnostic when there has been no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  TypeSourceInfo *getType() const {\n    assert(!isSubstitutionFailure() &&\n           \"Attempted to get type when there has been a substitution failure.\");\n    return Value.get<TypeSourceInfo *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Type;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the validity and\n/// properties of an expression ('simple' and 'compound' requirements).\nclass ExprRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_ExprSubstitutionFailure,\n      SS_NoexceptNotMet,\n      SS_TypeRequirementSubstitutionFailure,\n      SS_ConstraintsNotSatisfied,\n      SS_Satisfied\n  };\n  class ReturnTypeRequirement {\n      llvm::PointerIntPair<\n          llvm::PointerUnion<TemplateParameterList *, SubstitutionDiagnostic *>,\n          1, bool>\n          TypeConstraintInfo;\n  public:\n      friend ASTStmtReader;\n      friend ASTStmtWriter;\n\n      /// \\brief No return type requirement was specified.\n      ReturnTypeRequirement() : TypeConstraintInfo(nullptr, false) {}\n\n      /// \\brief A return type requirement was specified but it was a\n      /// substitution failure.\n      ReturnTypeRequirement(SubstitutionDiagnostic *SubstDiag) :\n          TypeConstraintInfo(SubstDiag, false) {}\n\n      /// \\brief A 'type constraint' style return type requirement.\n      /// \\param TPL an invented template parameter list containing a single\n      /// type parameter with a type-constraint.\n      // TODO: Can we maybe not save the whole template parameter list and just\n      //  the type constraint? Saving the whole TPL makes it easier to handle in\n      //  serialization but is less elegant.\n      ReturnTypeRequirement(TemplateParameterList *TPL);\n\n      bool isDependent() const {\n        return TypeConstraintInfo.getInt();\n      }\n\n      bool containsUnexpandedParameterPack() const {\n        if (!isTypeConstraint())\n          return false;\n        return getTypeConstraintTemplateParameterList()\n                ->containsUnexpandedParameterPack();\n      }\n\n      bool isEmpty() const {\n        return TypeConstraintInfo.getPointer().isNull();\n      }\n\n      bool isSubstitutionFailure() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<SubstitutionDiagnostic *>();\n      }\n\n      bool isTypeConstraint() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<TemplateParameterList *>();\n      }\n\n      SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n        assert(isSubstitutionFailure());\n        return TypeConstraintInfo.getPointer().get<SubstitutionDiagnostic *>();\n      }\n\n      const TypeConstraint *getTypeConstraint() const;\n\n      TemplateParameterList *getTypeConstraintTemplateParameterList() const {\n        assert(isTypeConstraint());\n        return TypeConstraintInfo.getPointer().get<TemplateParameterList *>();\n      }\n  };\nprivate:\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  SourceLocation NoexceptLoc; // May be empty if noexcept wasn't specified.\n  ReturnTypeRequirement TypeReq;\n  ConceptSpecializationExpr *SubstitutedConstraintExpr;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a compound requirement.\n  /// \\param E the expression which is checked by this requirement.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression.\n  /// \\param Status the satisfaction status of this requirement.\n  ExprRequirement(\n      Expr *E, bool IsSimple, SourceLocation NoexceptLoc,\n      ReturnTypeRequirement Req, SatisfactionStatus Status,\n      ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr);\n\n  /// \\brief Construct a compound requirement whose expression was a\n  /// substitution failure. The requirement is not satisfied.\n  /// \\param E the diagnostic emitted while instantiating the original\n  /// expression.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression (omit\n  /// if no requirement was specified).\n  ExprRequirement(SubstitutionDiagnostic *E, bool IsSimple,\n                  SourceLocation NoexceptLoc, ReturnTypeRequirement Req = {});\n\n  bool isSimple() const { return getKind() == RK_Simple; }\n  bool isCompound() const { return getKind() == RK_Compound; }\n\n  bool hasNoexceptRequirement() const { return NoexceptLoc.isValid(); }\n  SourceLocation getNoexceptLoc() const { return NoexceptLoc; }\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n\n  bool isExprSubstitutionFailure() const {\n    return Status == SS_ExprSubstitutionFailure;\n  }\n\n  const ReturnTypeRequirement &getReturnTypeRequirement() const {\n    return TypeReq;\n  }\n\n  ConceptSpecializationExpr *\n  getReturnTypeRequirementSubstitutedConstraintExpr() const {\n    assert(Status >= SS_TypeRequirementSubstitutionFailure);\n    return SubstitutedConstraintExpr;\n  }\n\n  SubstitutionDiagnostic *getExprSubstitutionDiagnostic() const {\n    assert(isExprSubstitutionFailure() &&\n           \"Attempted to get expression substitution diagnostic when there has \"\n           \"been no expression substitution failure\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getExpr() const {\n    assert(!isExprSubstitutionFailure() &&\n           \"ExprRequirement has no expression because there has been a \"\n           \"substitution failure.\");\n    return Value.get<Expr *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Compound || R->getKind() == RK_Simple;\n  }\n};\n\n/// \\brief A requires-expression requirement which is satisfied when a general\n/// constraint expression is satisfied ('nested' requirements).\nclass NestedRequirement : public Requirement {\n  Expr *Constraint = nullptr;\n  const ASTConstraintSatisfaction *Satisfaction = nullptr;\n  bool HasInvalidConstraint = false;\n  StringRef InvalidConstraintEntity;\n\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  NestedRequirement(Expr *Constraint)\n      : Requirement(RK_Nested, /*IsDependent=*/true,\n                    Constraint->containsUnexpandedParameterPack()),\n        Constraint(Constraint) {\n    assert(Constraint->isInstantiationDependent() &&\n           \"Nested requirement with non-dependent constraint must be \"\n           \"constructed with a ConstraintSatisfaction object\");\n  }\n\n  NestedRequirement(ASTContext &C, Expr *Constraint,\n                    const ConstraintSatisfaction &Satisfaction)\n      : Requirement(RK_Nested, Constraint->isInstantiationDependent(),\n                    Constraint->containsUnexpandedParameterPack(),\n                    Satisfaction.IsSatisfied),\n        Constraint(Constraint),\n        Satisfaction(ASTConstraintSatisfaction::Create(C, Satisfaction)) {}\n\n  NestedRequirement(StringRef InvalidConstraintEntity,\n                    const ASTConstraintSatisfaction *Satisfaction)\n      : Requirement(RK_Nested,\n                    /*IsDependent=*/false,\n                    /*ContainsUnexpandedParameterPack*/ false,\n                    Satisfaction->IsSatisfied),\n        Satisfaction(Satisfaction), HasInvalidConstraint(true),\n        InvalidConstraintEntity(InvalidConstraintEntity) {}\n\n  NestedRequirement(ASTContext &C, StringRef InvalidConstraintEntity,\n                    const ConstraintSatisfaction &Satisfaction)\n      : NestedRequirement(InvalidConstraintEntity,\n                          ASTConstraintSatisfaction::Create(C, Satisfaction)) {}\n\n  bool hasInvalidConstraint() const { return HasInvalidConstraint; }\n\n  StringRef getInvalidConstraintEntity() {\n    assert(hasInvalidConstraint());\n    return InvalidConstraintEntity;\n  }\n\n  Expr *getConstraintExpr() const {\n    assert(!hasInvalidConstraint() &&\n           \"getConstraintExpr() may not be called \"\n           \"on nested requirements with invalid constraint.\");\n    return Constraint;\n  }\n\n  const ASTConstraintSatisfaction &getConstraintSatisfaction() const {\n    return *Satisfaction;\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Nested;\n  }\n};\n\nusing EntityPrinter = llvm::function_ref<void(llvm::raw_ostream &)>;\n\n/// \\brief create a Requirement::SubstitutionDiagnostic with only a\n/// SubstitutedEntity and DiagLoc using Sema's allocator.\nRequirement::SubstitutionDiagnostic *\ncreateSubstDiagAt(Sema &S, SourceLocation Location, EntityPrinter Printer);\n\n}",
  "id": "BLOCK-CPP-10865",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprConcepts.h",
  "source_line": 145,
  "validation_status": "validated"
}