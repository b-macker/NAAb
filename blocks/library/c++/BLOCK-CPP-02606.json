{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace debugging_internal {\nnamespace {\n\n// This code requires that we know the direction in which the stack\n// grows. It is commonly believed that this can be detected by putting\n// a variable on the stack and then passing its address to a function\n// that compares the address of this variable to the address of a\n// variable on the function's own stack. However, this is unspecified\n// behavior in C++: If two pointers p and q of the same type point to\n// different objects that are not members of the same object or\n// elements of the same array or to different functions, or if only\n// one of them is null, the results of p<q, p>q, p<=q, and p>=q are\n// unspecified. Therefore, instead we hardcode the direction of the\n// stack on platforms we know about.\n#if defined(__i386__) || defined(__x86_64__) || defined(__ppc__) || \\\n    defined(__aarch64__) || defined(__riscv)\nconstexpr bool kStackGrowsDown = true;\n#else\n#error Need to define kStackGrowsDown\n#endif\n\n// To measure the stack footprint of some code, we create a signal handler\n// (for SIGUSR2 say) that exercises this code on an alternate stack. This\n// alternate stack is initialized to some known pattern (0x55, 0x55, 0x55,\n// ...). We then self-send this signal, and after the signal handler returns,\n// look at the alternate stack buffer to see what portion has been touched.\n//\n// This trick gives us the the stack footprint of the signal handler.  But the\n// signal handler, even before the code for it is exercised, consumes some\n// stack already. We however only want the stack usage of the code inside the\n// signal handler. To measure this accurately, we install two signal handlers:\n// one that does nothing and just returns, and the user-provided signal\n// handler. The difference between the stack consumption of these two signals\n// handlers should give us the stack foorprint of interest.\n\nvoid EmptySignalHandler(int) {}\n\n// This is arbitrary value, and could be increase further, at the cost of\n// memset()ting it all to known sentinel value.\nconstexpr int kAlternateStackSize = 64 << 10;  // 64KiB\n\nconstexpr int kSafetyMargin = 32;\nconstexpr char kAlternateStackFillValue = 0x55;\n\n// These helper functions look at the alternate stack buffer, and figure\n// out what portion of this buffer has been touched - this is the stack\n// consumption of the signal handler running on this alternate stack.\n// This function will return -1 if the alternate stack buffer has not been\n// touched. It will abort the program if the buffer has overflowed or is about\n// to overflow.\nint GetStackConsumption(const void* const altstack) {\n  const char* begin;\n  int increment;\n  if (kStackGrowsDown) {\n    begin = reinterpret_cast<const char*>(altstack);\n    increment = 1;\n  } else {\n    begin = reinterpret_cast<const char*>(altstack) + kAlternateStackSize - 1;\n    increment = -1;\n  }\n\n  for (int usage_count = kAlternateStackSize; usage_count > 0; --usage_count) {\n    if (*begin != kAlternateStackFillValue) {\n      ABSL_RAW_CHECK(usage_count <= kAlternateStackSize - kSafetyMargin,\n                     \"Buffer has overflowed or is about to overflow\");\n      return usage_count;\n    }\n    begin += increment;\n  }\n\n  ABSL_RAW_LOG(FATAL, \"Unreachable code\");\n  return -1;\n}\n\n}  // namespace\n\nint GetSignalHandlerStackConsumption(void (*signal_handler)(int)) {\n  // The alt-signal-stack cannot be heap allocated because there is a\n  // bug in glibc-2.2 where some signal handler setup code looks at the\n  // current stack pointer to figure out what thread is currently running.\n  // Therefore, the alternate stack must be allocated from the main stack\n  // itself.\n  void* altstack = mmap(nullptr, kAlternateStackSize, PROT_READ | PROT_WRITE,\n                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  ABSL_RAW_CHECK(altstack != MAP_FAILED, \"mmap() failed\");\n\n  // Set up the alt-signal-stack (and save the older one).\n  stack_t sigstk;\n  memset(&sigstk, 0, sizeof(sigstk));\n  sigstk.ss_sp = altstack;\n  sigstk.ss_size = kAlternateStackSize;\n  sigstk.ss_flags = 0;\n  stack_t old_sigstk;\n  memset(&old_sigstk, 0, sizeof(old_sigstk));\n  ABSL_RAW_CHECK(sigaltstack(&sigstk, &old_sigstk) == 0,\n                 \"sigaltstack() failed\");\n\n  // Set up SIGUSR1 and SIGUSR2 signal handlers (and save the older ones).\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  struct sigaction old_sa1, old_sa2;\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = SA_ONSTACK;\n\n  // SIGUSR1 maps to EmptySignalHandler.\n  sa.sa_handler = EmptySignalHandler;\n  ABSL_RAW_CHECK(sigaction(SIGUSR1, &sa, &old_sa1) == 0, \"sigaction() failed\");\n\n  // SIGUSR2 maps to signal_handler.\n  sa.sa_handler = signal_handler;\n  ABSL_RAW_CHECK(sigaction(SIGUSR2, &sa, &old_sa2) == 0, \"sigaction() failed\");\n\n  // Send SIGUSR1 signal and measure the stack consumption of the empty\n  // signal handler.\n  // The first signal might use more stack space. Run once and ignore the\n  // results to get that out of the way.\n  ABSL_RAW_CHECK(kill(getpid(), SIGUSR1) == 0, \"kill() failed\");\n\n  memset(altstack, kAlternateStackFillValue, kAlternateStackSize);\n  ABSL_RAW_CHECK(kill(getpid(), SIGUSR1) == 0, \"kill() failed\");\n  int base_stack_consumption = GetStackConsumption(altstack);\n\n  // Send SIGUSR2 signal and measure the stack consumption of signal_handler.\n  ABSL_RAW_CHECK(kill(getpid(), SIGUSR2) == 0, \"kill() failed\");\n  int signal_handler_stack_consumption = GetStackConsumption(altstack);\n\n  // Now restore the old alt-signal-stack and signal handlers.\n  if (old_sigstk.ss_sp == nullptr && old_sigstk.ss_size == 0 &&\n      (old_sigstk.ss_flags & SS_DISABLE)) {\n    // https://git.musl-libc.org/cgit/musl/commit/src/signal/sigaltstack.c?id=7829f42a2c8944555439380498ab8b924d0f2070\n    // The original stack has ss_size==0 and ss_flags==SS_DISABLE, but some\n    // versions of musl have a bug that rejects ss_size==0. Work around this by\n    // setting ss_size to MINSIGSTKSZ, which should be ignored by the kernel\n    // when SS_DISABLE is set.\n    old_sigstk.ss_size = static_cast<size_t>(MINSIGSTKSZ);\n  }\n  ABSL_RAW_CHECK(sigaltstack(&old_sigstk, nullptr) == 0,\n                 \"sigaltstack() failed\");\n  ABSL_RAW_CHECK(sigaction(SIGUSR1, &old_sa1, nullptr) == 0,\n                 \"sigaction() failed\");\n  ABSL_RAW_CHECK(sigaction(SIGUSR2, &old_sa2, nullptr) == 0,\n                 \"sigaction() failed\");\n\n  ABSL_RAW_CHECK(munmap(altstack, kAlternateStackSize) == 0, \"munmap() failed\");\n  if (signal_handler_stack_consumption != -1 && base_stack_consumption != -1) {\n    return signal_handler_stack_consumption - base_stack_consumption;\n  }\n  return -1;\n}\n\n}  // namespace debugging_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02606",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/stack_consumption.cc",
  "source_line": 32,
  "validation_status": "validated"
}