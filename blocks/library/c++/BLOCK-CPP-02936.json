{
  "code": "{\n// Calculate DamerauLevenshtein (adjacent transpositions) distance\n// between two strings,\n// https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance. The\n// algorithm follows the condition that no substring is edited more than once.\n// While this can reduce is larger distance, it's a) a much simpler algorithm\n// and b) more realistic for the case that typographic mistakes should be\n// detected.\n// When the distance is larger than cutoff, or one of the strings has more\n// than MAX_SIZE=100 characters, the code returns min(MAX_SIZE, cutoff) + 1.\nuint8_t CappedDamerauLevenshteinDistance(absl::string_view s1,\n                                         absl::string_view s2, uint8_t cutoff) {\n  const uint8_t MAX_SIZE = 100;\n  const uint8_t _cutoff = std::min(MAX_SIZE, cutoff);\n  const uint8_t cutoff_plus_1 = static_cast<uint8_t>(_cutoff + 1);\n\n  if (s1.size() > s2.size()) std::swap(s1, s2);\n  if (s1.size() + _cutoff < s2.size() || s2.size() > MAX_SIZE)\n    return cutoff_plus_1;\n\n  if (s1.empty())\n    return static_cast<uint8_t>(s2.size());\n\n  // Lower diagonal bound: y = x - lower_diag\n  const uint8_t lower_diag =\n      _cutoff - static_cast<uint8_t>(s2.size() - s1.size());\n  // Upper diagonal bound: y = x + upper_diag\n  const uint8_t upper_diag = _cutoff;\n\n  // d[i][j] is the number of edits required to convert s1[0, i] to s2[0, j]\n  std::array<std::array<uint8_t, MAX_SIZE + 2>, MAX_SIZE + 2> d;\n  std::iota(d[0].begin(), d[0].begin() + upper_diag + 1, 0);\n  d[0][cutoff_plus_1] = cutoff_plus_1;\n  for (size_t i = 1; i <= s1.size(); ++i) {\n    // Deduce begin of relevant window.\n    size_t j_begin = 1;\n    if (i > lower_diag) {\n      j_begin = i - lower_diag;\n      d[i][j_begin - 1] = cutoff_plus_1;\n    } else {\n      d[i][0] = static_cast<uint8_t>(i);\n    }\n\n    // Deduce end of relevant window.\n    size_t j_end = i + upper_diag;\n    if (j_end > s2.size()) {\n      j_end = s2.size();\n    } else {\n      d[i][j_end + 1] = cutoff_plus_1;\n    }\n\n    for (size_t j = j_begin; j <= j_end; ++j) {\n      const uint8_t deletion_distance = d[i - 1][j] + 1;\n      const uint8_t insertion_distance = d[i][j - 1] + 1;\n      const uint8_t mismatched_tail_cost = s1[i - 1] == s2[j - 1] ? 0 : 1;\n      const uint8_t mismatch_distance = d[i - 1][j - 1] + mismatched_tail_cost;\n      uint8_t transposition_distance = _cutoff + 1;\n      if (i > 1 && j > 1 && s1[i - 1] == s2[j - 2] && s1[i - 2] == s2[j - 1])\n        transposition_distance = d[i - 2][j - 2] + 1;\n      d[i][j] = std::min({cutoff_plus_1, deletion_distance, insertion_distance,\n                          mismatch_distance, transposition_distance});\n    }\n  }\n  return d[s1.size()][s2.size()];\n}\n\n}",
  "id": "BLOCK-CPP-02936",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/damerau_levenshtein_distance.cc",
  "source_line": 24,
  "validation_status": "validated"
}