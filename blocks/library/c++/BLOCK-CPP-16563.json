{
  "code": "{\npublic:\n  // We start by defining the layout.\n  using storage_type = uint32_t;\n\n  using RoundingMode = llvm::RoundingMode;\n\n  static constexpr unsigned StorageBitSize = 8 * sizeof(storage_type);\n\n  // Define a fake option named \"First\" so that we have a PREVIOUS even for the\n  // real first option.\n  static constexpr storage_type FirstShift = 0, FirstWidth = 0;\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  static constexpr storage_type NAME##Shift =                                  \\\n      PREVIOUS##Shift + PREVIOUS##Width;                                       \\\n  static constexpr storage_type NAME##Width = WIDTH;                           \\\n  static constexpr storage_type NAME##Mask = ((1 << NAME##Width) - 1)          \\\n                                             << NAME##Shift;\n#include \"clang/Basic/FPOptions.def\"\n\n  static constexpr storage_type TotalWidth = 0\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS) +WIDTH\n#include \"clang/Basic/FPOptions.def\"\n      ;\n  static_assert(TotalWidth <= StorageBitSize, \"Too short type for FPOptions\");\n\nprivate:\n  storage_type Value;\n\n  FPOptionsOverride getChangesSlow(const FPOptions &Base) const;\n\npublic:\n  FPOptions() : Value(0) {\n    setFPContractMode(LangOptions::FPM_Off);\n    setConstRoundingMode(RoundingMode::Dynamic);\n    setSpecifiedExceptionMode(LangOptions::FPE_Default);\n  }\n  explicit FPOptions(const LangOptions &LO) {\n    Value = 0;\n    // The language fp contract option FPM_FastHonorPragmas has the same effect\n    // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in\n    // frontend.\n    auto LangOptContractMode = LO.getDefaultFPContractMode();\n    if (LangOptContractMode == LangOptions::FPM_FastHonorPragmas)\n      LangOptContractMode = LangOptions::FPM_Fast;\n    setFPContractMode(LangOptContractMode);\n    setRoundingMath(LO.RoundingMath);\n    setConstRoundingMode(LangOptions::RoundingMode::Dynamic);\n    setSpecifiedExceptionMode(LO.getFPExceptionMode());\n    setAllowFPReassociate(LO.AllowFPReassoc);\n    setNoHonorNaNs(LO.NoHonorNaNs);\n    setNoHonorInfs(LO.NoHonorInfs);\n    setNoSignedZero(LO.NoSignedZero);\n    setAllowReciprocal(LO.AllowRecip);\n    setAllowApproxFunc(LO.ApproxFunc);\n    if (getFPContractMode() == LangOptions::FPM_On &&\n        getRoundingMode() == llvm::RoundingMode::Dynamic &&\n        getExceptionMode() == LangOptions::FPE_Strict)\n      // If the FP settings are set to the \"strict\" model, then\n      // FENV access is set to true. (ffp-model=strict)\n      setAllowFEnvAccess(true);\n    else\n      setAllowFEnvAccess(LangOptions::FPM_Off);\n  }\n\n  bool allowFPContractWithinStatement() const {\n    return getFPContractMode() == LangOptions::FPM_On;\n  }\n  void setAllowFPContractWithinStatement() {\n    setFPContractMode(LangOptions::FPM_On);\n  }\n\n  bool allowFPContractAcrossStatement() const {\n    return getFPContractMode() == LangOptions::FPM_Fast;\n  }\n  void setAllowFPContractAcrossStatement() {\n    setFPContractMode(LangOptions::FPM_Fast);\n  }\n\n  bool isFPConstrained() const {\n    return getRoundingMode() != llvm::RoundingMode::NearestTiesToEven ||\n           getExceptionMode() != LangOptions::FPE_Ignore ||\n           getAllowFEnvAccess();\n  }\n\n  RoundingMode getRoundingMode() const {\n    RoundingMode RM = getConstRoundingMode();\n    if (RM == RoundingMode::Dynamic) {\n      // C2x: 7.6.2p3  If the FE_DYNAMIC mode is specified and FENV_ACCESS is\n      // \"off\", the translator may assume that the default rounding mode is in\n      // effect.\n      if (!getAllowFEnvAccess() && !getRoundingMath())\n        RM = RoundingMode::NearestTiesToEven;\n    }\n    return RM;\n  }\n\n  LangOptions::FPExceptionModeKind getExceptionMode() const {\n    LangOptions::FPExceptionModeKind EM = getSpecifiedExceptionMode();\n    if (EM == LangOptions::FPExceptionModeKind::FPE_Default) {\n      if (getAllowFEnvAccess())\n        return LangOptions::FPExceptionModeKind::FPE_Strict;\n      else\n        return LangOptions::FPExceptionModeKind::FPE_Ignore;\n    }\n    return EM;\n  }\n\n  bool operator==(FPOptions other) const { return Value == other.Value; }\n\n  /// Return the default value of FPOptions that's used when trailing\n  /// storage isn't required.\n  static FPOptions defaultWithoutTrailingStorage(const LangOptions &LO);\n\n  storage_type getAsOpaqueInt() const { return Value; }\n  static FPOptions getFromOpaqueInt(storage_type Value) {\n    FPOptions Opts;\n    Opts.Value = Value;\n    return Opts;\n  }\n\n  /// Return difference with the given option set.\n  FPOptionsOverride getChangesFrom(const FPOptions &Base) const;\n\n  // We can define most of the accessors automatically:\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  TYPE get##NAME() const {                                                     \\\n    return static_cast<TYPE>((Value & NAME##Mask) >> NAME##Shift);             \\\n  }                                                                            \\\n  void set##NAME(TYPE value) {                                                 \\\n    Value = (Value & ~NAME##Mask) | (storage_type(value) << NAME##Shift);      \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n}",
  "id": "BLOCK-CPP-16563",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/LangOptions.h",
  "source_line": 661,
  "validation_status": "validated"
}