{
  "code": "{\n///   T data[Size];\n/// };\n/// \\endcode\n///\n/// For these types, we won't actually know what the array bound is\n/// until template instantiation occurs, at which point this will\n/// become either a ConstantArrayType or a VariableArrayType.\nclass DependentSizedArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  const ASTContext &Context;\n\n  /// An assignment expression that will instantiate to the\n  /// size of the array.\n  ///\n  /// The expression itself might be null, in which case the array\n  /// type will have its size deduced from an initializer.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  DependentSizedArrayType(const ASTContext &Context, QualType et, QualType can,\n                          Expr *e, ArraySizeModifier sm, unsigned tq,\n                          SourceRange brackets);\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(),\n            getSizeModifier(), getIndexTypeCVRQualifiers(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ET, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals, Expr *E);\n};\n\n/// Represents an extended address space qualifier where the input address space\n/// value is dependent. Non-dependent address spaces are not represented with a\n/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.\n///\n/// For example:\n/// \\code\n/// template<typename T, int AddrSpace>\n/// class AddressSpace {\n///   typedef T __attribute__((address_space(AddrSpace))) type;\n/// }\n/// \\endcode\nclass DependentAddressSpaceType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *AddrSpaceExpr;\n  QualType PointeeType;\n  SourceLocation loc;\n\n  DependentAddressSpaceType(const ASTContext &Context, QualType PointeeType,\n                            QualType can, Expr *AddrSpaceExpr,\n                            SourceLocation loc);\n\npublic:\n  Expr *getAddrSpaceExpr() const { return AddrSpaceExpr; }\n  QualType getPointeeType() const { return PointeeType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentAddressSpace;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getPointeeType(), getAddrSpaceExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType PointeeType, Expr *AddrSpaceExpr);\n};\n\n/// Represents an extended vector type where either the type or size is\n/// dependent.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((ext_vector_type(Size))) type;\n/// }\n/// \\endcode\nclass DependentSizedExtVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *SizeExpr;\n\n  /// The element type of the array.\n  QualType ElementType;\n\n  SourceLocation loc;\n\n  DependentSizedExtVectorType(const ASTContext &Context, QualType ElementType,\n                              QualType can, Expr *SizeExpr, SourceLocation loc);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedExtVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *SizeExpr);\n};\n\n\n/// Represents a GCC generic vector type. This type is created using\n/// __attribute__((vector_size(n)), where \"n\" specifies the vector size in\n/// bytes; or from an Altivec __vector or vector declaration.\n/// Since the constructor takes the number of vector elements, the\n/// client is responsible for converting the size into the number of elements.\nclass VectorType : public Type, public llvm::FoldingSetNode {\npublic:\n  enum VectorKind {\n    /// not a target-specific vector type\n    GenericVector,\n\n    /// is AltiVec vector\n    AltiVecVector,\n\n    /// is AltiVec 'vector Pixel'\n    AltiVecPixel,\n\n    /// is AltiVec 'vector bool ...'\n    AltiVecBool,\n\n    /// is ARM Neon vector\n    NeonVector,\n\n    /// is ARM Neon polynomial vector\n    NeonPolyVector,\n\n    /// is AArch64 SVE fixed-length data vector\n    SveFixedLengthDataVector,\n\n    /// is AArch64 SVE fixed-length predicate vector\n    SveFixedLengthPredicateVector,\n\n    /// is RISC-V RVV fixed-length data vector\n    RVVFixedLengthDataVector,\n  };\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  /// The element type of the vector.\n  QualType ElementType;\n\n  VectorType(QualType vecType, unsigned nElements, QualType canonType,\n             VectorKind vecKind);\n\n  VectorType(TypeClass tc, QualType vecType, unsigned nElements,\n             QualType canonType, VectorKind vecKind);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  unsigned getNumElements() const { return VectorTypeBits.NumElements; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  VectorKind getVectorKind() const {\n    return VectorKind(VectorTypeBits.VecKind);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumElements(),\n            getTypeClass(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumElements, TypeClass TypeClass,\n                      VectorKind VecKind) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumElements);\n    ID.AddInteger(TypeClass);\n    ID.AddInteger(VecKind);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Vector || T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a vector type where either the type or size is dependent.\n////\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((vector_size(Size))) type;\n/// }\n/// \\endcode\nclass DependentVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  QualType ElementType;\n  Expr *SizeExpr;\n  SourceLocation Loc;\n\n  DependentVectorType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonType, Expr *SizeExpr,\n                           SourceLocation Loc, VectorType::VectorKind vecKind);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return Loc; }\n  VectorType::VectorKind getVectorKind() const {\n    return VectorType::VectorKind(VectorTypeBits.VecKind);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, const Expr *SizeExpr,\n                      VectorType::VectorKind VecKind);\n};\n\n/// ExtVectorType - Extended vector type. This type is created using\n/// __attribute__((ext_vector_type(n)), where \"n\" is the number of elements.\n/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This\n/// class enables syntactic extensions, like Vector Components for accessing\n/// points (as .xyzw), colors (as .rgba), and textures (modeled after OpenGL\n/// Shading Language).\nclass ExtVectorType : public VectorType {\n  friend class ASTContext; // ASTContext creates these.\n\n  ExtVectorType(QualType vecType, unsigned nElements, QualType canonType)\n      : VectorType(ExtVector, vecType, nElements, canonType, GenericVector) {}\n\npublic:\n  static int getPointAccessorIdx(char c) {\n    switch (c) {\n    default: return -1;\n    case 'x': case 'r': return 0;\n    case 'y': case 'g': return 1;\n    case 'z': case 'b': return 2;\n    case 'w': case 'a': return 3;\n    }\n  }\n\n  static int getNumericAccessorIdx(char c) {\n    switch (c) {\n      default: return -1;\n      case '0': return 0;\n      case '1': return 1;\n      case '2': return 2;\n      case '3': return 3;\n      case '4': return 4;\n      case '5': return 5;\n      case '6': return 6;\n      case '7': return 7;\n      case '8': return 8;\n      case '9': return 9;\n      case 'A':\n      case 'a': return 10;\n      case 'B':\n      case 'b': return 11;\n      case 'C':\n      case 'c': return 12;\n      case 'D':\n      case 'd': return 13;\n      case 'E':\n      case 'e': return 14;\n      case 'F':\n      case 'f': return 15;\n    }\n  }\n\n  static int getAccessorIdx(char c, bool isNumericAccessor) {\n    if (isNumericAccessor)\n      return getNumericAccessorIdx(c);\n    else\n      return getPointAccessorIdx(c);\n  }\n\n  bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const {\n    if (int idx = getAccessorIdx(c, isNumericAccessor)+1)\n      return unsigned(idx-1) < getNumElements();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a matrix type, as defined in the Matrix Types clang extensions.\n/// __attribute__((matrix_type(rows, columns))), where \"rows\" specifies\n/// number of rows and \"columns\" specifies the number of columns.\nclass MatrixType : public Type, public llvm::FoldingSetNode {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  QualType ElementType;\n\n  MatrixType(QualType ElementTy, QualType CanonElementTy);\n\n  MatrixType(TypeClass TypeClass, QualType ElementTy, QualType CanonElementTy,\n             const Expr *RowExpr = nullptr, const Expr *ColumnExpr = nullptr);\n\npublic:\n  /// Returns type of the elements being stored in the matrix\n  QualType getElementType() const { return ElementType; }\n\n  /// Valid elements types are the following:\n  /// * an integer type (as in C2x 6.2.5p19), but excluding enumerated types\n  ///   and _Bool\n  /// * the standard floating types float or double\n  /// * a half-precision floating point type, if one is supported on the target\n  static bool isValidElementType(QualType T) {\n    return T->isDependentType() ||\n           (T->isRealType() && !T->isBooleanType() && !T->isEnumeralType());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix ||\n           T->getTypeClass() == DependentSizedMatrix;\n  }\n};\n\n/// Represents a concrete matrix type with constant number of rows and columns\nclass ConstantMatrixType final : public MatrixType {\nprotected:\n  friend class ASTContext;\n\n  /// Number of rows and columns.\n  unsigned NumRows;\n  unsigned NumColumns;\n\n  static constexpr unsigned MaxElementsPerDimension = (1 << 20) - 1;\n\n  ConstantMatrixType(QualType MatrixElementType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\n  ConstantMatrixType(TypeClass typeClass, QualType MatrixType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\npublic:\n  /// Returns the number of rows in the matrix.\n  unsigned getNumRows() const { return NumRows; }\n\n  /// Returns the number of columns in the matrix.\n  unsigned getNumColumns() const { return NumColumns; }\n\n  /// Returns the number of elements required to embed the matrix into a vector.\n  unsigned getNumElementsFlattened() const {\n    return getNumRows() * getNumColumns();\n  }\n\n  /// Returns true if \\p NumElements is a valid matrix dimension.\n  static constexpr bool isDimensionValid(size_t NumElements) {\n    return NumElements > 0 && NumElements <= MaxElementsPerDimension;\n  }\n\n  /// Returns the maximum number of elements per dimension.\n  static constexpr unsigned getMaxElementsPerDimension() {\n    return MaxElementsPerDimension;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumRows(), getNumColumns(),\n            getTypeClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumRows, unsigned NumColumns,\n                      TypeClass TypeClass) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumRows);\n    ID.AddInteger(NumColumns);\n    ID.AddInteger(TypeClass);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix;\n  }\n};\n\n/// Represents a matrix type where the type and the number of rows and columns\n/// is dependent on a template.\nclass DependentSizedMatrixType final : public MatrixType {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *RowExpr;\n  Expr *ColumnExpr;\n\n  SourceLocation loc;\n\n  DependentSizedMatrixType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonicalType, Expr *RowExpr,\n                           Expr *ColumnExpr, SourceLocation loc);\n\npublic:\n  Expr *getRowExpr() const { return RowExpr; }\n  Expr *getColumnExpr() const { return ColumnExpr; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedMatrix;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getRowExpr(), getColumnExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *RowExpr, Expr *ColumnExpr);\n};\n\n/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base\n/// class of FunctionNoProtoType and FunctionProtoType.\nclass FunctionType : public Type {\n  // The type returned by the function.\n  QualType ResultType;\n\npublic:\n  /// Interesting information about a specific parameter that can't simply\n  /// be reflected in parameter's type. This is only used by FunctionProtoType\n  /// but is in FunctionType to make this class available during the\n  /// specification of the bases of FunctionProtoType.\n  ///\n  /// It makes sense to model language features this way when there's some\n  /// sort of parameter-specific override (such as an attribute) that\n  /// affects how the function is called.  For example, the ARC ns_consumed\n  /// attribute changes whether a parameter is passed at +0 (the default)\n  /// or +1 (ns_consumed).  This must be reflected in the function type,\n  /// but isn't really a change to the parameter type.\n  ///\n  /// One serious disadvantage of modelling language features this way is\n  /// that they generally do not work with language features that attempt\n  /// to destructure types.  For example, template argument deduction will\n  /// not be able to match a parameter declared as\n  ///   T (*)(U)\n  /// against an argument of type\n  ///   void (*)(__attribute__((ns_consumed)) id)\n  /// because the substitution of T=void, U=id into the former will\n  /// not produce the latter.\n  class ExtParameterInfo {\n    enum {\n      ABIMask = 0x0F,\n      IsConsumed = 0x10,\n      HasPassObjSize = 0x20,\n      IsNoEscape = 0x40,\n    };\n    unsigned char Data = 0;\n\n  public:\n    ExtParameterInfo() = default;\n\n    /// Return the ABI treatment of this parameter.\n    ParameterABI getABI() const { return ParameterABI(Data & ABIMask); }\n    ExtParameterInfo withABI(ParameterABI kind) const {\n      ExtParameterInfo copy = *this;\n      copy.Data = (copy.Data & ~ABIMask) | unsigned(kind);\n      return copy;\n    }\n\n    /// Is this parameter considered \"consumed\" by Objective-C ARC?\n    /// Consumed parameters must have retainable object type.\n    bool isConsumed() const { return (Data & IsConsumed); }\n    ExtParameterInfo withIsConsumed(bool consumed) const {\n      ExtParameterInfo copy = *this;\n      if (consumed)\n        copy.Data |= IsConsumed;\n      else\n        copy.Data &= ~IsConsumed;\n      return copy;\n    }\n\n    bool hasPassObjectSize() const { return Data & HasPassObjSize; }\n    ExtParameterInfo withHasPassObjectSize() const {\n      ExtParameterInfo Copy = *this;\n      Copy.Data |= HasPassObjSize;\n      return Copy;\n    }\n\n    bool isNoEscape() const { return Data & IsNoEscape; }\n    ExtParameterInfo withIsNoEscape(bool NoEscape) const {\n      ExtParameterInfo Copy = *this;\n      if (NoEscape)\n        Copy.Data |= IsNoEscape;\n      else\n        Copy.Data &= ~IsNoEscape;\n      return Copy;\n    }\n\n    unsigned char getOpaqueValue() const { return Data; }\n    static ExtParameterInfo getFromOpaqueValue(unsigned char data) {\n      ExtParameterInfo result;\n      result.Data = data;\n      return result;\n    }\n\n    friend bool operator==(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data == rhs.Data;\n    }\n\n    friend bool operator!=(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data != rhs.Data;\n    }\n  };\n\n  /// A class which abstracts out some details necessary for\n  /// making a call.\n  ///\n  /// It is not actually used directly for storing this information in\n  /// a FunctionType, although FunctionType does currently use the\n  /// same bit-pattern.\n  ///\n  // If you add a field (say Foo), other than the obvious places (both,\n  // constructors, compile failures), what you need to update is\n  // * Operator==\n  // * getFoo\n  // * withFoo\n  // * functionType. Add Foo, getFoo.\n  // * ASTContext::getFooType\n  // * ASTContext::mergeFunctionTypes\n  // * FunctionNoProtoType::Profile\n  // * FunctionProtoType::Profile\n  // * TypePrinter::PrintFunctionProto\n  // * AST read and write\n  // * Codegen\n  class ExtInfo {\n    friend class FunctionType;\n\n    // Feel free to rearrange or add bits, but if you go over 16, you'll need to\n    // adjust the Bits field below, and if you add bits, you'll need to adjust\n    // Type::FunctionTypeBitfields::ExtInfo as well.\n\n    // |  CC  |noreturn|produces|nocallersavedregs|regparm|nocfcheck|cmsenscall|\n    // |0 .. 4|   5    |    6   |       7         |8 .. 10|    11   |    12    |\n    //\n    // regparm is either 0 (no regparm attribute) or the regparm value+1.\n    enum { CallConvMask = 0x1F };\n    enum { NoReturnMask = 0x20 };\n    enum { ProducesResultMask = 0x40 };\n    enum { NoCallerSavedRegsMask = 0x80 };\n    enum {\n      RegParmMask =  0x700,\n      RegParmOffset = 8\n    };\n    enum { NoCfCheckMask = 0x800 };\n    enum { CmseNSCallMask = 0x1000 };\n    uint16_t Bits = CC_C;\n\n    ExtInfo(unsigned Bits) : Bits(static_cast<uint16_t>(Bits)) {}\n\n  public:\n    // Constructor with no defaults. Use this when you know that you\n    // have all the elements (when reading an AST file for example).\n    ExtInfo(bool noReturn, bool hasRegParm, unsigned regParm, CallingConv cc,\n            bool producesResult, bool noCallerSavedRegs, bool NoCfCheck,\n            bool cmseNSCall) {\n      assert((!hasRegParm || regParm < 7) && \"Invalid regparm value\");\n      Bits = ((unsigned)cc) | (noReturn ? NoReturnMask : 0) |\n             (producesResult ? ProducesResultMask : 0) |\n             (noCallerSavedRegs ? NoCallerSavedRegsMask : 0) |\n             (hasRegParm ? ((regParm + 1) << RegParmOffset) : 0) |\n             (NoCfCheck ? NoCfCheckMask : 0) |\n             (cmseNSCall ? CmseNSCallMask : 0);\n    }\n\n    // Constructor with all defaults. Use when for example creating a\n    // function known to use defaults.\n    ExtInfo() = default;\n\n    // Constructor with just the calling convention, which is an important part\n    // of the canonical type.\n    ExtInfo(CallingConv CC) : Bits(CC) {}\n\n    bool getNoReturn() const { return Bits & NoReturnMask; }\n    bool getProducesResult() const { return Bits & ProducesResultMask; }\n    bool getCmseNSCall() const { return Bits & CmseNSCallMask; }\n    bool getNoCallerSavedRegs() const { return Bits & NoCallerSavedRegsMask; }\n    bool getNoCfCheck() const { return Bits & NoCfCheckMask; }\n    bool getHasRegParm() const { return ((Bits & RegParmMask) >> RegParmOffset) != 0; }\n\n    unsigned getRegParm() const {\n      unsigned RegParm = (Bits & RegParmMask) >> RegParmOffset;\n      if (RegParm > 0)\n        --RegParm;\n      return RegParm;\n    }\n\n    CallingConv getCC() const { return CallingConv(Bits & CallConvMask); }\n\n    bool operator==(ExtInfo Other) const {\n      return Bits == Other.Bits;\n    }\n    bool operator!=(ExtInfo Other) const {\n      return Bits != Other.Bits;\n    }\n\n    // Note that we don't have setters. That is by design, use\n    // the following with methods instead of mutating these objects.\n\n    ExtInfo withNoReturn(bool noReturn) const {\n      if (noReturn)\n        return ExtInfo(Bits | NoReturnMask);\n      else\n        return ExtInfo(Bits & ~NoReturnMask);\n    }\n\n    ExtInfo withProducesResult(bool producesResult) const {\n      if (producesResult)\n        return ExtInfo(Bits | ProducesResultMask);\n      else\n        return ExtInfo(Bits & ~ProducesResultMask);\n    }\n\n    ExtInfo withCmseNSCall(bool cmseNSCall) const {\n      if (cmseNSCall)\n        return ExtInfo(Bits | CmseNSCallMask);\n      else\n        return ExtInfo(Bits & ~CmseNSCallMask);\n    }\n\n    ExtInfo withNoCallerSavedRegs(bool noCallerSavedRegs) const {\n      if (noCallerSavedRegs)\n        return ExtInfo(Bits | NoCallerSavedRegsMask);\n      else\n        return ExtInfo(Bits & ~NoCallerSavedRegsMask);\n    }\n\n    ExtInfo withNoCfCheck(bool noCfCheck) const {\n      if (noCfCheck)\n        return ExtInfo(Bits | NoCfCheckMask);\n      else\n        return ExtInfo(Bits & ~NoCfCheckMask);\n    }\n\n    ExtInfo withRegParm(unsigned RegParm) const {\n      assert(RegParm < 7 && \"Invalid regparm value\");\n      return ExtInfo((Bits & ~RegParmMask) |\n                     ((RegParm + 1) << RegParmOffset));\n    }\n\n    ExtInfo withCallingConv(CallingConv cc) const {\n      return ExtInfo((Bits & ~CallConvMask) | (unsigned) cc);\n    }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const {\n      ID.AddInteger(Bits);\n    }\n  };\n\n  /// A simple holder for a QualType representing a type in an\n  /// exception specification. Unfortunately needed by FunctionProtoType\n  /// because TrailingObjects cannot handle repeated types.\n  struct ExceptionType { QualType Type; };\n\n  /// A simple holder for various uncommon bits which do not fit in\n  /// FunctionTypeBitfields. Aligned to alignof(void *) to maintain the\n  /// alignment of subsequent objects in TrailingObjects.\n  struct alignas(void *) FunctionTypeExtraBitfields {\n    /// The number of types in the exception specification.\n    /// A whole unsigned is not needed here and according to\n    /// [implimits] 8 bits would be enough here.\n    uint16_t NumExceptionType = 0;\n  };\n\nprotected:\n  FunctionType(TypeClass tc, QualType res, QualType Canonical,\n               TypeDependence Dependence, ExtInfo Info)\n      : Type(tc, Canonical, Dependence), ResultType(res) {\n    FunctionTypeBits.ExtInfo = Info.Bits;\n  }\n\n  Qualifiers getFastTypeQuals() const {\n    if (isFunctionProtoType())\n      return Qualifiers::fromFastMask(FunctionTypeBits.FastTypeQuals);\n\n    return Qualifiers();\n  }\n\npublic:\n  QualType getReturnType() const { return ResultType; }\n\n  bool getHasRegParm() const { return getExtInfo().getHasRegParm(); }\n  unsigned getRegParmType() const { return getExtInfo().getRegParm(); }\n\n  /// Determine whether this function type includes the GNU noreturn\n  /// attribute. The C++11 [[noreturn]] attribute does not affect the function\n  /// type.\n  bool getNoReturnAttr() const { return getExtInfo().getNoReturn(); }\n\n  bool getCmseNSCallAttr() const { return getExtInfo().getCmseNSCall(); }\n  CallingConv getCallConv() const { return getExtInfo().getCC(); }\n  ExtInfo getExtInfo() const { return ExtInfo(FunctionTypeBits.ExtInfo); }\n\n  static_assert((~Qualifiers::FastMask & Qualifiers::CVRMask) == 0,\n                \"Const, volatile and restrict are assumed to be a subset of \"\n                \"the fast qualifiers.\");\n\n  bool isConst() const { return getFastTypeQuals().hasConst(); }\n  bool isVolatile() const { return getFastTypeQuals().hasVolatile(); }\n  bool isRestrict() const { return getFastTypeQuals().hasRestrict(); }\n\n  /// Determine the type of an expression that calls a function of\n  /// this type.\n  QualType getCallResultType(const ASTContext &Context) const {\n    return getReturnType().getNonLValueExprType(Context);\n  }\n\n  static StringRef getNameForCallConv(CallingConv CC);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto ||\n           T->getTypeClass() == FunctionProto;\n  }\n};\n\n/// Represents a K&R-style 'int foo()' function, which has\n/// no information available about its arguments.\nclass FunctionNoProtoType : public FunctionType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  FunctionNoProtoType(QualType Result, QualType Canonical, ExtInfo Info)\n      : FunctionType(FunctionNoProto, Result, Canonical,\n                     Result->getDependence() &\n                         ~(TypeDependence::DependentInstantiation |\n                           TypeDependence::UnexpandedPack),\n                     Info) {}\n\npublic:\n  // No additional state past what FunctionType provides.\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReturnType(), getExtInfo());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ResultType,\n                      ExtInfo Info) {\n    Info.Profile(ID);\n    ID.AddPointer(ResultType.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto;\n  }\n};\n\n/// Represents a prototype with parameter type info, e.g.\n/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no\n/// parameters, not as having a single void parameter. Such a type can have\n/// an exception specification, but this specification is not part of the\n/// canonical type. FunctionProtoType has several trailing objects, some of\n/// which optional. For more information about the trailing objects see\n/// the first comment inside FunctionProtoType.\nclass FunctionProtoType final\n    : public FunctionType,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<\n          FunctionProtoType, QualType, SourceLocation,\n          FunctionType::FunctionTypeExtraBitfields, FunctionType::ExceptionType,\n          Expr *, FunctionDecl *, FunctionType::ExtParameterInfo, Qualifiers> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  // FunctionProtoType is followed by several trailing objects, some of\n  // which optional. They are in order:\n  //\n  // * An array of getNumParams() QualType holding the parameter types.\n  //   Always present. Note that for the vast majority of FunctionProtoType,\n  //   these will be the only trailing objects.\n  //\n  // * Optionally if the function is variadic, the SourceLocation of the\n  //   ellipsis.\n  //\n  // * Optionally if some extra data is stored in FunctionTypeExtraBitfields\n  //   (see FunctionTypeExtraBitfields and FunctionTypeBitfields):\n  //   a single FunctionTypeExtraBitfields. Present if and only if\n  //   hasExtraBitfields() is true.\n  //\n  // * Optionally exactly one of:\n  //   * an array of getNumExceptions() ExceptionType,\n  //   * a single Expr *,\n  //   * a pair of FunctionDecl *,\n  //   * a single FunctionDecl *\n  //   used to store information about the various types of exception\n  //   specification. See getExceptionSpecSize for the details.\n  //\n  // * Optionally an array of getNumParams() ExtParameterInfo holding\n  //   an ExtParameterInfo for each of the parameters. Present if and\n  //   only if hasExtParameterInfos() is true.\n  //\n  // * Optionally a Qualifiers object to represent extra qualifiers that can't\n  //   be represented by FunctionTypeBitfields.FastTypeQuals. Present if and only\n  //   if hasExtQualifiers() is true.\n  //\n  // The optional FunctionTypeExtraBitfields has to be before the data\n  // related to the exception specification since it contains the number\n  // of exception types.\n  //\n  // We put the ExtParameterInfos last.  If all were equal, it would make\n  // more sense to put these before the exception specification, because\n  // it's much easier to skip past them compared to the elaborate switch\n  // required to skip the exception specification.  However, all is not\n  // equal; ExtParameterInfos are used to model very uncommon features,\n  // and it's better not to burden the more common paths.\n\npublic:\n  /// Holds information about the various types of exception specification.\n  /// ExceptionSpecInfo is not stored as such in FunctionProtoType but is\n  /// used to group together the various bits of information about the\n  /// exception specification.\n  struct ExceptionSpecInfo {\n    /// The kind of exception specification this is.\n    ExceptionSpecificationType Type = EST_None;\n\n    /// Explicitly-specified list of exception types.\n    ArrayRef<QualType> Exceptions;\n\n    /// Noexcept expression, if this is a computed noexcept specification.\n    Expr *NoexceptExpr = nullptr;\n\n    /// The function whose exception specification this is, for\n    /// EST_Unevaluated and EST_Uninstantiated.\n    FunctionDecl *SourceDecl = nullptr;\n\n    /// The function template whose exception specification this is instantiated\n    /// from, for EST_Uninstantiated.\n    FunctionDecl *SourceTemplate = nullptr;\n\n    ExceptionSpecInfo() = default;\n\n    ExceptionSpecInfo(ExceptionSpecificationType EST) : Type(EST) {}\n  };\n\n  /// Extra information about a function prototype. ExtProtoInfo is not\n  /// stored as such in FunctionProtoType but is used to group together\n  /// the various bits of extra information about a function prototype.\n  struct ExtProtoInfo {\n    FunctionType::ExtInfo ExtInfo;\n    bool Variadic : 1;\n    bool HasTrailingReturn : 1;\n    Qualifiers TypeQuals;\n    RefQualifierKind RefQualifier = RQ_None;\n    ExceptionSpecInfo ExceptionSpec;\n    const ExtParameterInfo *ExtParameterInfos = nullptr;\n    SourceLocation EllipsisLoc;\n\n    ExtProtoInfo() : Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo(CallingConv CC)\n        : ExtInfo(CC), Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo withExceptionSpec(const ExceptionSpecInfo &ESI) {\n      ExtProtoInfo Result(*this);\n      Result.ExceptionSpec = ESI;\n      return Result;\n    }\n\n    bool requiresFunctionProtoTypeExtraBitfields() const {\n      return ExceptionSpec.Type == EST_Dynamic;\n    }\n  };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<QualType>) const {\n    return getNumParams();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return isVariadic();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionTypeExtraBitfields>) const {\n    return hasExtraBitfields();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExceptionType>) const {\n    return getExceptionSpecSize().NumExceptionType;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return getExceptionSpecSize().NumExprPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionDecl *>) const {\n    return getExceptionSpecSize().NumFunctionDeclPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExtParameterInfo>) const {\n    return hasExtParameterInfos() ? getNumParams() : 0;\n  }\n\n  /// Determine whether there are any argument types that\n  /// contain an unexpanded parameter pack.\n  static bool containsAnyUnexpandedParameterPack(const QualType *ArgArray,\n                                                 unsigned numArgs) {\n    for (unsigned Idx = 0; Idx < numArgs; ++Idx)\n      if (ArgArray[Idx]->containsUnexpandedParameterPack())\n        return true;\n\n    return false;\n  }\n\n  FunctionProtoType(QualType result, ArrayRef<QualType> params,\n                    QualType canonical, const ExtProtoInfo &epi);\n\n  /// This struct is returned by getExceptionSpecSize and is used to\n  /// translate an ExceptionSpecificationType to the number and kind\n  /// of trailing objects related to the exception specification.\n  struct ExceptionSpecSizeHolder {\n    unsigned NumExceptionType;\n    unsigned NumExprPtr;\n    unsigned NumFunctionDeclPtr;\n  };\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  static ExceptionSpecSizeHolder\n  getExceptionSpecSize(ExceptionSpecificationType EST, unsigned NumExceptions) {\n    switch (EST) {\n    case EST_None:\n    case EST_DynamicNone:\n    case EST_MSAny:\n    case EST_BasicNoexcept:\n    case EST_Unparsed:\n    case EST_NoThrow:\n      return {0, 0, 0};\n\n    case EST_Dynamic:\n      return {NumExceptions, 0, 0};\n\n    case EST_DependentNoexcept:\n    case EST_NoexceptFalse:\n    case EST_NoexceptTrue:\n      return {0, 1, 0};\n\n    case EST_Uninstantiated:\n      return {0, 0, 2};\n\n    case EST_Unevaluated:\n      return {0, 0, 1};\n    }\n    llvm_unreachable(\"bad exception specification kind\");\n  }\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  ExceptionSpecSizeHolder getExceptionSpecSize() const {\n    return getExceptionSpecSize(getExceptionSpecType(), getNumExceptions());\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  bool hasExtraBitfields() const {\n    assert((getExceptionSpecType() != EST_Dynamic ||\n            FunctionTypeBits.HasExtraBitfields) &&\n           \"ExtraBitfields are required for given ExceptionSpecType\");\n    return FunctionTypeBits.HasExtraBitfields;\n\n  }\n\n  bool hasExtQualifiers() const {\n    return FunctionTypeBits.HasExtQuals;\n  }\n\npublic:\n  unsigned getNumParams() const { return FunctionTypeBits.NumParams; }\n\n  QualType getParamType(unsigned i) const {\n    assert(i < getNumParams() && \"invalid parameter index\");\n    return param_type_begin()[i];\n  }\n\n  ArrayRef<QualType> getParamTypes() const {\n    return llvm::ArrayRef(param_type_begin(), param_type_end());\n  }\n\n  ExtProtoInfo getExtProtoInfo() const {\n    ExtProtoInfo EPI;\n    EPI.ExtInfo = getExtInfo();\n    EPI.Variadic = isVariadic();\n    EPI.EllipsisLoc = getEllipsisLoc();\n    EPI.HasTrailingReturn = hasTrailingReturn();\n    EPI.ExceptionSpec = getExceptionSpecInfo();\n    EPI.TypeQuals = getMethodQuals();\n    EPI.RefQualifier = getRefQualifier();\n    EPI.ExtParameterInfos = getExtParameterInfosOrNull();\n    return EPI;\n  }\n\n  /// Get the kind of exception specification on this function.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    return static_cast<ExceptionSpecificationType>(\n        FunctionTypeBits.ExceptionSpecType);\n  }\n\n  /// Return whether this function has any kind of exception spec.\n  bool hasExceptionSpec() const { return getExceptionSpecType() != EST_None; }\n\n  /// Return whether this function has a dynamic (throw) exception spec.\n  bool hasDynamicExceptionSpec() const {\n    return isDynamicExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a noexcept exception spec.\n  bool hasNoexceptExceptionSpec() const {\n    return isNoexceptExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a dependent exception spec.\n  bool hasDependentExceptionSpec() const;\n\n  /// Return whether this function has an instantiation-dependent exception\n  /// spec.\n  bool hasInstantiationDependentExceptionSpec() const;\n\n  /// Return all the available information about this type's exception spec.\n  ExceptionSpecInfo getExceptionSpecInfo() const {\n    ExceptionSpecInfo Result;\n    Result.Type = getExceptionSpecType();\n    if (Result.Type == EST_Dynamic) {\n      Result.Exceptions = exceptions();\n    } else if (isComputedNoexcept(Result.Type)) {\n      Result.NoexceptExpr = getNoexceptExpr();\n    } else if (Result.Type == EST_Uninstantiated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n      Result.SourceTemplate = getExceptionSpecTemplate();\n    } else if (Result.Type == EST_Unevaluated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n    }\n    return Result;\n  }\n\n  /// Return the number of types in the exception specification.\n  unsigned getNumExceptions() const {\n    return getExceptionSpecType() == EST_Dynamic\n               ? getTrailingObjects<FunctionTypeExtraBitfields>()\n                     ->NumExceptionType\n               : 0;\n  }\n\n  /// Return the ith exception type, where 0 <= i < getNumExceptions().\n  QualType getExceptionType(unsigned i) const {\n    assert(i < getNumExceptions() && \"Invalid exception number!\");\n    return exception_begin()[i];\n  }\n\n  /// Return the expression inside noexcept(expression), or a null pointer\n  /// if there is none (because the exception spec is not of this form).\n  Expr *getNoexceptExpr() const {\n    if (!isComputedNoexcept(getExceptionSpecType()))\n      return nullptr;\n    return *getTrailingObjects<Expr *>();\n  }\n\n  /// If this function type has an exception specification which hasn't\n  /// been determined yet (either because it has not been evaluated or because\n  /// it has not been instantiated), this is the function whose exception\n  /// specification is represented by this type.\n  FunctionDecl *getExceptionSpecDecl() const {\n    if (getExceptionSpecType() != EST_Uninstantiated &&\n        getExceptionSpecType() != EST_Unevaluated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[0];\n  }\n\n  /// If this function type has an uninstantiated exception\n  /// specification, this is the function whose exception specification\n  /// should be instantiated to find the exception specification for\n  /// this type.\n  FunctionDecl *getExceptionSpecTemplate() const {\n    if (getExceptionSpecType() != EST_Uninstantiated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[1];\n  }\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification.\n  CanThrowResult canThrow() const;\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification. If this depends on template arguments, returns\n  /// \\c ResultIfDependent.\n  bool isNothrow(bool ResultIfDependent = false) const {\n    return ResultIfDependent ? canThrow() != CT_Can : canThrow() == CT_Cannot;\n  }\n\n  /// Whether this function prototype is variadic.\n  bool isVariadic() const { return FunctionTypeBits.Variadic; }\n\n  SourceLocation getEllipsisLoc() const {\n    return isVariadic() ? *getTrailingObjects<SourceLocation>()\n                        : SourceLocation();\n  }\n\n  /// Determines whether this function prototype contains a\n  /// parameter pack at the end.\n  ///\n  /// A function template whose last parameter is a parameter pack can be\n  /// called with an arbitrary number of arguments, much like a variadic\n  /// function.\n  bool isTemplateVariadic() const;\n\n  /// Whether this function prototype has a trailing return type.\n  bool hasTrailingReturn() const { return FunctionTypeBits.HasTrailingReturn; }\n\n  Qualifiers getMethodQuals() const {\n    if (hasExtQualifiers())\n      return *getTrailingObjects<Qualifiers>();\n    else\n      return getFastTypeQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this function type.\n  RefQualifierKind getRefQualifier() const {\n    return static_cast<RefQualifierKind>(FunctionTypeBits.RefQualifier);\n  }\n\n  using param_type_iterator = const QualType *;\n\n  ArrayRef<QualType> param_types() const {\n    return llvm::ArrayRef(param_type_begin(), param_type_end());\n  }\n\n  param_type_iterator param_type_begin() const {\n    return getTrailingObjects<QualType>();\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_begin() + getNumParams();\n  }\n\n  using exception_iterator = const QualType *;\n\n  ArrayRef<QualType> exceptions() const {\n    return llvm::ArrayRef(exception_begin(), exception_end());\n  }\n\n  exception_iterator exception_begin() const {\n    return reinterpret_cast<exception_iterator>(\n        getTrailingObjects<ExceptionType>());\n  }\n\n  exception_iterator exception_end() const {\n    return exception_begin() + getNumExceptions();\n  }\n\n  /// Is there any interesting extra information for any of the parameters\n  /// of this function type?\n  bool hasExtParameterInfos() const {\n    return FunctionTypeBits.HasExtParameterInfos;\n  }\n\n  ArrayRef<ExtParameterInfo> getExtParameterInfos() const {\n    assert(hasExtParameterInfos());\n    return ArrayRef<ExtParameterInfo>(getTrailingObjects<ExtParameterInfo>(),\n                                      getNumParams());\n  }\n\n  /// Return a pointer to the beginning of the array of extra parameter\n  /// information, if present, or else null if none of the parameters\n  /// carry it.  This is equivalent to getExtProtoInfo().ExtParameterInfos.\n  const ExtParameterInfo *getExtParameterInfosOrNull() const {\n    if (!hasExtParameterInfos())\n      return nullptr;\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n\n  ExtParameterInfo getExtParameterInfo(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I];\n    return ExtParameterInfo();\n  }\n\n  ParameterABI getParameterABI(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].getABI();\n    return ParameterABI::Ordinary;\n  }\n\n  bool isParamConsumed(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].isConsumed();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void printExceptionSpecification(raw_ostream &OS,\n                                   const PrintingPolicy &Policy) const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionProto;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx);\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Result,\n                      param_type_iterator ArgTys, unsigned NumArgs,\n                      const ExtProtoInfo &EPI, const ASTContext &Context,\n                      bool Canonical);\n};\n\n/// Represents the dependent type named by a dependently-scoped\n/// typename using declaration, e.g.\n///   using typename Base<T>::foo;\n///\n/// Template instantiation turns these into the underlying type.\nclass UnresolvedUsingType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  UnresolvedUsingTypenameDecl *Decl;\n\n  UnresolvedUsingType(const UnresolvedUsingTypenameDecl *D)\n      : Type(UnresolvedUsing, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(const_cast<UnresolvedUsingTypenameDecl *>(D)) {}\n\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnresolvedUsing;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    return Profile(ID, Decl);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      UnresolvedUsingTypenameDecl *D) {\n    ID.AddPointer(D);\n  }\n};\n\nclass UsingType final : public Type,\n                        public llvm::FoldingSetNode,\n                        private llvm::TrailingObjects<UsingType, QualType> {\n  UsingShadowDecl *Found;\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  UsingType(const UsingShadowDecl *Found, QualType Underlying, QualType Canon);\n\npublic:\n  UsingShadowDecl *getFoundDecl() const { return Found; }\n  QualType getUnderlyingType() const;\n\n  bool isSugared() const { return true; }\n\n  // This always has the 'same' type as declared, but not necessarily identical.\n  QualType desugar() const { return getUnderlyingType(); }\n\n  // Internal helper, for debugging purposes.\n  bool typeMatchesDecl() const { return !UsingBits.hasTypeDifferentFromDecl; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Found, typeMatchesDecl() ? QualType() : getUnderlyingType());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const UsingShadowDecl *Found,\n                      QualType Underlying) {\n    ID.AddPointer(Found);\n    if (!Underlying.isNull())\n      Underlying.Profile(ID);\n  }\n  static bool classof(const Type *T) { return T->getTypeClass() == Using; }\n};\n\nclass TypedefType final : public Type,\n                          public llvm::FoldingSetNode,\n                          private llvm::TrailingObjects<TypedefType, QualType> {\n  TypedefNameDecl *Decl;\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  TypedefType(TypeClass tc, const TypedefNameDecl *D, QualType underlying,\n              QualType can);\n\npublic:\n  TypedefNameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return true; }\n\n  // This always has the 'same' type as declared, but not necessarily identical.\n  QualType desugar() const;\n\n  // Internal helper, for debugging purposes.\n  bool typeMatchesDecl() const { return !TypedefBits.hasTypeDifferentFromDecl; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Decl, typeMatchesDecl() ? QualType() : desugar());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const TypedefNameDecl *Decl,\n                      QualType Underlying) {\n    ID.AddPointer(Decl);\n    if (!Underlying.isNull())\n      Underlying.Profile(ID);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Typedef; }\n};\n\n/// Sugar type that represents a type that was qualified by a qualifier written\n/// as a macro invocation.\nclass MacroQualifiedType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType UnderlyingTy;\n  const IdentifierInfo *MacroII;\n\n  MacroQualifiedType(QualType UnderlyingTy, QualType CanonTy,\n                     const IdentifierInfo *MacroII)\n      : Type(MacroQualified, CanonTy, UnderlyingTy->getDependence()),\n        UnderlyingTy(UnderlyingTy), MacroII(MacroII) {\n    assert(isa<AttributedType>(UnderlyingTy) &&\n           \"Expected a macro qualified type to only wrap attributed types.\");\n  }\n\npublic:\n  const IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n  QualType getUnderlyingType() const { return UnderlyingTy; }\n\n  /// Return this attributed type's modified type with no qualifiers attached to\n  /// it.\n  QualType getModifiedType() const;\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MacroQualified;\n  }\n};\n\n/// Represents a `typeof` (or __typeof__) expression (a C2x feature and GCC\n/// extension) or a `typeof_unqual` expression (a C2x feature).\nclass TypeOfExprType : public Type {\n  Expr *TOExpr;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypeOfExprType(Expr *E, TypeOfKind Kind, QualType Can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return TOExpr; }\n\n  /// Returns the kind of 'typeof' type this is.\n  TypeOfKind getKind() const {\n    return TypeOfBits.IsUnqual ? TypeOfKind::Unqualified\n                               : TypeOfKind::Qualified;\n  }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOfExpr; }\n};\n\n/// Internal representation of canonical, dependent\n/// `typeof(expr)` types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via TypeOfExprType nodes.\nclass DependentTypeOfExprType\n  : public TypeOfExprType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentTypeOfExprType(const ASTContext &Context, Expr *E, TypeOfKind Kind)\n      : TypeOfExprType(E, Kind), Context(Context) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr(),\n            getKind() == TypeOfKind::Unqualified);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E, bool IsUnqual);\n};\n\n/// Represents `typeof(type)`, a C2x feature and GCC extension, or\n/// `typeof_unqual(type), a C2x feature.\nclass TypeOfType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType TOType;\n\n  TypeOfType(QualType T, QualType Can, TypeOfKind Kind)\n      : Type(TypeOf,\n             Kind == TypeOfKind::Unqualified ? Can.getAtomicUnqualifiedType()\n                                             : Can,\n             T->getDependence()),\n        TOType(T) {\n    TypeOfBits.IsUnqual = Kind == TypeOfKind::Unqualified;\n  }\n\npublic:\n  QualType getUnmodifiedType() const { return TOType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const {\n    QualType QT = getUnmodifiedType();\n    return TypeOfBits.IsUnqual ? QT.getAtomicUnqualifiedType() : QT;\n  }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  /// Returns the kind of 'typeof' type this is.\n  TypeOfKind getKind() const {\n    return TypeOfBits.IsUnqual ? TypeOfKind::Unqualified\n                               : TypeOfKind::Qualified;\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOf; }\n};\n\n/// Represents the type `decltype(expr)` (C++11).\nclass DecltypeType : public Type {\n  Expr *E;\n  QualType UnderlyingType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  DecltypeType(Expr *E, QualType underlyingType, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return E; }\n  QualType getUnderlyingType() const { return UnderlyingType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decltype; }\n};\n\n/// Internal representation of canonical, dependent\n/// decltype(expr) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via DecltypeType nodes.\nclass DependentDecltypeType : public DecltypeType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentDecltypeType(const ASTContext &Context, Expr *E);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// A unary type transform, which is a type constructed from another.\nclass UnaryTransformType : public Type {\npublic:\n  enum UTTKind {\n#define TRANSFORM_TYPE_TRAIT_DEF(Enum, _) Enum,\n#include \"clang/Basic/TransformTypeTraits.def\"\n  };\n\nprivate:\n  /// The untransformed type.\n  QualType BaseType;\n\n  /// The transformed type if not dependent, otherwise the same as BaseType.\n  QualType UnderlyingType;\n\n  UTTKind UKind;\n\nprotected:\n  friend class ASTContext;\n\n  UnaryTransformType(QualType BaseTy, QualType UnderlyingTy, UTTKind UKind,\n                     QualType CanonicalTy);\n\npublic:\n  bool isSugared() const { return !isDependentType(); }\n  QualType desugar() const { return UnderlyingType; }\n\n  QualType getUnderlyingType() const { return UnderlyingType; }\n  QualType getBaseType() const { return BaseType; }\n\n  UTTKind getUTTKind() const { return UKind; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnaryTransform;\n  }\n};\n\n/// Internal representation of canonical, dependent\n/// __underlying_type(type) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via UnaryTransformType nodes.\nclass DependentUnaryTransformType : public UnaryTransformType,\n                                    public llvm::FoldingSetNode {\npublic:\n  DependentUnaryTransformType(const ASTContext &C, QualType BaseType,\n                              UTTKind UKind);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getBaseType(), getUTTKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType BaseType,\n                      UTTKind UKind) {\n    ID.AddPointer(BaseType.getAsOpaquePtr());\n    ID.AddInteger((unsigned)UKind);\n  }\n};\n\nclass TagType : public Type {\n  friend class ASTReader;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  /// Stores the TagDecl associated with this type. The decl may point to any\n  /// TagDecl that declares the entity.\n  TagDecl *decl;\n\nprotected:\n  TagType(TypeClass TC, const TagDecl *D, QualType can);\n\npublic:\n  TagDecl *getDecl() const;\n\n  /// Determines whether this type is in the process of being defined.\n  bool isBeingDefined() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Enum || T->getTypeClass() == Record;\n  }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of structs/unions/classes.\nclass RecordType : public TagType {\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit RecordType(const RecordDecl *D)\n      : TagType(Record, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n  explicit RecordType(TypeClass TC, RecordDecl *D)\n      : TagType(TC, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  RecordDecl *getDecl() const {\n    return reinterpret_cast<RecordDecl*>(TagType::getDecl());\n  }\n\n  /// Recursively check all fields in the record for const-ness. If any field\n  /// is declared const, return true. Otherwise, return false.\n  bool hasConstFields() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Record; }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of enums.\nclass EnumType : public TagType {\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit EnumType(const EnumDecl *D)\n      : TagType(Enum, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  EnumDecl *getDecl() const {\n    return reinterpret_cast<EnumDecl*>(TagType::getDecl());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Enum; }\n};\n\n/// An attributed type is a type to which a type attribute has been applied.\n///\n/// The \"modified type\" is the fully-sugared type to which the attributed\n/// type was applied; generally it is not canonically equivalent to the\n/// attributed type. The \"equivalent type\" is the minimally-desugared type\n/// which the type is canonically equivalent to.\n///\n/// For example, in the following attributed type:\n///     int32_t __attribute__((vector_size(16)))\n///   - the modified type is the TypedefType for int32_t\n///   - the equivalent type is VectorType(16, int32_t)\n///   - the canonical type is VectorType(16, int)\nclass AttributedType : public Type, public llvm::FoldingSetNode {\npublic:\n  using Kind = attr::Kind;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these\n\n  QualType ModifiedType;\n  QualType EquivalentType;\n\n  AttributedType(QualType canon, attr::Kind attrKind, QualType modified,\n                 QualType equivalent)\n      : Type(Attributed, canon, equivalent->getDependence()),\n        ModifiedType(modified), EquivalentType(equivalent) {\n    AttributedTypeBits.AttrKind = attrKind;\n  }\n\npublic:\n  Kind getAttrKind() const {\n    return static_cast<Kind>(AttributedTypeBits.AttrKind);\n  }\n\n  QualType getModifiedType() const { return ModifiedType; }\n  QualType getEquivalentType() const { return EquivalentType; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getEquivalentType(); }\n\n  /// Does this attribute behave like a type qualifier?\n  ///\n  /// A type qualifier adjusts a type to provide specialized rules for\n  /// a specific object, like the standard const and volatile qualifiers.\n  /// This includes attributes controlling things like nullability,\n  /// address spaces, and ARC ownership.  The value of the object is still\n  /// largely described by the modified type.\n  ///\n  /// In contrast, many type attributes \"rewrite\" their modified type to\n  /// produce a fundamentally different type, not necessarily related in any\n  /// formalizable way to the original type.  For example, calling convention\n  /// and vector attributes are not simple type qualifiers.\n  ///\n  /// Type qualifiers are often, but not always, reflected in the canonical\n  /// type.\n  bool isQualifier() const;\n\n  bool isMSTypeSpec() const;\n\n  bool isWebAssemblyFuncrefSpec() const;\n\n  bool isCallingConv() const;\n\n  std::optional<NullabilityKind> getImmediateNullability() const;\n\n  /// Retrieve the attribute kind corresponding to the given\n  /// nullability kind.\n  static Kind getNullabilityAttrKind(NullabilityKind kind) {\n    switch (kind) {\n    case NullabilityKind::NonNull:\n      return attr::TypeNonNull;\n\n    case NullabilityKind::Nullable:\n      return attr::TypeNullable;\n\n    case NullabilityKind::NullableResult:\n      return attr::TypeNullableResult;\n\n    case NullabilityKind::Unspecified:\n      return attr::TypeNullUnspecified;\n    }\n    llvm_unreachable(\"Unknown nullability kind.\");\n  }\n\n  /// Strip off the top-level nullability annotation on the given\n  /// type, if it's there.\n  ///\n  /// \\param T The type to strip. If the type is exactly an\n  /// AttributedType specifying nullability (without looking through\n  /// type sugar), the nullability is returned and this type changed\n  /// to the underlying modified type.\n  ///\n  /// \\returns the top-level nullability, if present.\n  static std::optional<NullabilityKind> stripOuterNullability(QualType &T);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getAttrKind(), ModifiedType, EquivalentType);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Kind attrKind,\n                      QualType modified, QualType equivalent) {\n    ID.AddInteger(attrKind);\n    ID.AddPointer(modified.getAsOpaquePtr());\n    ID.AddPointer(equivalent.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Attributed;\n  }\n};\n\nclass BTFTagAttributedType : public Type, public llvm::FoldingSetNode {\nprivate:\n  friend class ASTContext; // ASTContext creates these\n\n  QualType WrappedType;\n  const BTFTypeTagAttr *BTFAttr;\n\n  BTFTagAttributedType(QualType Canon, QualType Wrapped,\n                       const BTFTypeTagAttr *BTFAttr)\n      : Type(BTFTagAttributed, Canon, Wrapped->getDependence()),\n        WrappedType(Wrapped), BTFAttr(BTFAttr) {}\n\npublic:\n  QualType getWrappedType() const { return WrappedType; }\n  const BTFTypeTagAttr *getAttr() const { return BTFAttr; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getWrappedType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, WrappedType, BTFAttr);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Wrapped,\n                      const BTFTypeTagAttr *BTFAttr) {\n    ID.AddPointer(Wrapped.getAsOpaquePtr());\n    ID.AddPointer(BTFAttr);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == BTFTagAttributed;\n  }\n};\n\nclass TemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  // Helper data collector for canonical types.\n  struct CanonicalTTPTInfo {\n    unsigned Depth : 15;\n    unsigned ParameterPack : 1;\n    unsigned Index : 16;\n  };\n\n  union {\n    // Info for the canonical type.\n    CanonicalTTPTInfo CanTTPTInfo;\n\n    // Info for the non-canonical type.\n    TemplateTypeParmDecl *TTPDecl;\n  };\n\n  /// Build a non-canonical type.\n  TemplateTypeParmType(TemplateTypeParmDecl *TTPDecl, QualType Canon)\n      : Type(TemplateTypeParm, Canon,\n             TypeDependence::DependentInstantiation |\n                 (Canon->getDependence() & TypeDependence::UnexpandedPack)),\n        TTPDecl(TTPDecl) {}\n\n  /// Build the canonical type.\n  TemplateTypeParmType(unsigned D, unsigned I, bool PP)\n      : Type(TemplateTypeParm, QualType(this, 0),\n             TypeDependence::DependentInstantiation |\n                 (PP ? TypeDependence::UnexpandedPack : TypeDependence::None)) {\n    CanTTPTInfo.Depth = D;\n    CanTTPTInfo.Index = I;\n    CanTTPTInfo.ParameterPack = PP;\n  }\n\n  const CanonicalTTPTInfo& getCanTTPTInfo() const {\n    QualType Can = getCanonicalTypeInternal();\n    return Can->castAs<TemplateTypeParmType>()->CanTTPTInfo;\n  }\n\npublic:\n  unsigned getDepth() const { return getCanTTPTInfo().Depth; }\n  unsigned getIndex() const { return getCanTTPTInfo().Index; }\n  bool isParameterPack() const { return getCanTTPTInfo().ParameterPack; }\n\n  TemplateTypeParmDecl *getDecl() const {\n    return isCanonicalUnqualified() ? nullptr : TTPDecl;\n  }\n\n  IdentifierInfo *getIdentifier() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getDepth(), getIndex(), isParameterPack(), getDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, unsigned Depth,\n                      unsigned Index, bool ParameterPack,\n                      TemplateTypeParmDecl *TTPDecl) {\n    ID.AddInteger(Depth);\n    ID.AddInteger(Index);\n    ID.AddBoolean(ParameterPack);\n    ID.AddPointer(TTPDecl);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a type for a template\n/// type parameter.\n///\n/// Within an instantiated template, all template type parameters have\n/// been replaced with these.  They are used solely to record that a\n/// type was originally written as a template type parameter;\n/// therefore they are never canonical.\nclass SubstTemplateTypeParmType final\n    : public Type,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<SubstTemplateTypeParmType, QualType> {\n  friend class ASTContext;\n  friend class llvm::TrailingObjects<SubstTemplateTypeParmType, QualType>;\n\n  Decl *AssociatedDecl;\n\n  SubstTemplateTypeParmType(QualType Replacement, Decl *AssociatedDecl,\n                            unsigned Index, std::optional<unsigned> PackIndex);\n\npublic:\n  /// Gets the type that was substituted for the template\n  /// parameter.\n  QualType getReplacementType() const {\n    return SubstTemplateTypeParmTypeBits.HasNonCanonicalUnderlyingType\n               ? *getTrailingObjects<QualType>()\n               : getCanonicalTypeInternal();\n  }\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will usually own a set of template parameters, or in some\n  /// cases might even be a template parameter itself.\n  Decl *getAssociatedDecl() const { return AssociatedDecl; }\n\n  /// Gets the template parameter declaration that was substituted for.\n  const TemplateTypeParmDecl *getReplacedParameter() const;\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getReplacedParameter()->getIndex()`.\n  unsigned getIndex() const { return SubstTemplateTypeParmTypeBits.Index; }\n\n  std::optional<unsigned> getPackIndex() const {\n    if (SubstTemplateTypeParmTypeBits.PackIndex == 0)\n      return std::nullopt;\n    return SubstTemplateTypeParmTypeBits.PackIndex - 1;\n  }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getReplacementType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReplacementType(), getAssociatedDecl(), getIndex(),\n            getPackIndex());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Replacement,\n                      const Decl *AssociatedDecl, unsigned Index,\n                      std::optional<unsigned> PackIndex) {\n    Replacement.Profile(ID);\n    ID.AddPointer(AssociatedDecl);\n    ID.AddInteger(Index);\n    ID.AddInteger(PackIndex ? *PackIndex - 1 : 0);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a set of types for a template\n/// type parameter pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this type node is used to represent a template type\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the \\c SubstTemplateTypeParmType\n/// at the current pack substitution index.\nclass SubstTemplateTypeParmPackType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndFinal;\n\n  SubstTemplateTypeParmPackType(QualType Canon, Decl *AssociatedDecl,\n                                unsigned Index, bool Final,\n                                const TemplateArgument &ArgPack);\n\npublic:\n  IdentifierInfo *getIdentifier() const;\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will usually own a set of template parameters, or in some\n  /// cases might even be a template parameter itself.\n  Decl *getAssociatedDecl() const;\n\n  /// Gets the template parameter declaration that was substituted for.\n  const TemplateTypeParmDecl *getReplacedParameter() const;\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getReplacedParameter()->getIndex()`.\n  unsigned getIndex() const { return SubstTemplateTypeParmPackTypeBits.Index; }\n\n  // When true the substitution will be 'Final' (subst node won't be placed).\n  bool getFinal() const;\n\n  unsigned getNumArgs() const {\n    return SubstTemplateTypeParmPackTypeBits.NumArgs;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  TemplateArgument getArgumentPack() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID, const Decl *AssociatedDecl,\n                      unsigned Index, bool Final,\n                      const TemplateArgument &ArgPack);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParmPack;\n  }\n};\n\n/// Common base class for placeholders for types that get replaced by\n/// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced\n/// class template types, and constrained type names.\n///\n/// These types are usually a placeholder for a deduced type. However, before\n/// the initializer is attached, or (usually) if the initializer is\n/// type-dependent, there is no deduced type and the type is canonical. In\n/// the latter case, it is also a dependent type.\nclass DeducedType : public Type {\n  QualType DeducedAsType;\n\nprotected:\n  DeducedType(TypeClass TC, QualType DeducedAsType,\n              TypeDependence ExtraDependence, QualType Canon)\n      : Type(TC, Canon,\n             ExtraDependence | (DeducedAsType.isNull()\n                                    ? TypeDependence::None\n                                    : DeducedAsType->getDependence() &\n                                          ~TypeDependence::VariablyModified)),\n        DeducedAsType(DeducedAsType) {}\n\npublic:\n  bool isSugared() const { return !DeducedAsType.isNull(); }\n  QualType desugar() const {\n    return isSugared() ? DeducedAsType : QualType(this, 0);\n  }\n\n  /// Get the type deduced for this placeholder type, or null if it\n  /// has not been deduced.\n  QualType getDeducedType() const { return DeducedAsType; }\n  bool isDeduced() const {\n    return !DeducedAsType.isNull() || isDependentType();\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto ||\n           T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained\n/// by a type-constraint.\nclass alignas(8) AutoType : public DeducedType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  ConceptDecl *TypeConstraintConcept;\n\n  AutoType(QualType DeducedAsType, AutoTypeKeyword Keyword,\n           TypeDependence ExtraDependence, QualType Canon, ConceptDecl *CD,\n           ArrayRef<TemplateArgument> TypeConstraintArgs);\n\npublic:\n  ArrayRef<TemplateArgument> getTypeConstraintArguments() const {\n    return {reinterpret_cast<const TemplateArgument *>(this + 1),\n            AutoTypeBits.NumArgs};\n  }\n\n  ConceptDecl *getTypeConstraintConcept() const {\n    return TypeConstraintConcept;\n  }\n\n  bool isConstrained() const {\n    return TypeConstraintConcept != nullptr;\n  }\n\n  bool isDecltypeAuto() const {\n    return getKeyword() == AutoTypeKeyword::DecltypeAuto;\n  }\n\n  bool isGNUAutoType() const {\n    return getKeyword() == AutoTypeKeyword::GNUAutoType;\n  }\n\n  AutoTypeKeyword getKeyword() const {\n    return (AutoTypeKeyword)AutoTypeBits.Keyword;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context);\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType Deduced, AutoTypeKeyword Keyword,\n                      bool IsDependent, ConceptDecl *CD,\n                      ArrayRef<TemplateArgument> Arguments);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto;\n  }\n};\n\n/// Represents a C++17 deduced template specialization type.\nclass DeducedTemplateSpecializationType : public DeducedType,\n                                          public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template whose arguments will be deduced.\n  TemplateName Template;\n\n  DeducedTemplateSpecializationType(TemplateName Template,\n                                    QualType DeducedAsType,\n                                    bool IsDeducedAsDependent)\n      : DeducedType(DeducedTemplateSpecialization, DeducedAsType,\n                    toTypeDependence(Template.getDependence()) |\n                        (IsDeducedAsDependent\n                             ? TypeDependence::DependentInstantiation\n                             : TypeDependence::None),\n                    DeducedAsType.isNull() ? QualType(this, 0)\n                                           : DeducedAsType.getCanonicalType()),\n        Template(Template) {}\n\npublic:\n  /// Retrieve the name of the template that we are deducing.\n  TemplateName getTemplateName() const { return Template;}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getTemplateName(), getDeducedType(), isDependentType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName Template,\n                      QualType Deduced, bool IsDependent) {\n    Template.Profile(ID);\n    QualType CanonicalType =\n        Deduced.isNull() ? Deduced : Deduced.getCanonicalType();\n    ID.AddPointer(CanonicalType.getAsOpaquePtr());\n    ID.AddBoolean(IsDependent || Template.isDependent());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a type template specialization; the template\n/// must be a class template, a type alias template, or a template\n/// template parameter.  A template which cannot be resolved to one of\n/// these, e.g. because it is written with a dependent scope\n/// specifier, is instead represented as a\n/// @c DependentTemplateSpecializationType.\n///\n/// A non-dependent template specialization type is always \"sugar\",\n/// typically for a \\c RecordType.  For example, a class template\n/// specialization type of \\c vector<int> will refer to a tag type for\n/// the instantiation \\c std::vector<int, std::allocator<int>>\n///\n/// Template specializations are dependent if either the template or\n/// any of the template arguments are dependent, in which case the\n/// type may also be canonical.\n///\n/// Instances of this type are allocated with a trailing array of\n/// TemplateArguments, followed by a QualType representing the\n/// non-canonical aliased type when the template is a type alias\n/// template.\nclass alignas(8) TemplateSpecializationType\n    : public Type,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template being specialized.  This is\n  /// either a TemplateName::Template (in which case it is a\n  /// ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a\n  /// TypeAliasTemplateDecl*), a\n  /// TemplateName::SubstTemplateTemplateParmPack, or a\n  /// TemplateName::SubstTemplateTemplateParm (in which case the\n  /// replacement must, recursively, be one of these).\n  TemplateName Template;\n\n  TemplateSpecializationType(TemplateName T,\n                             ArrayRef<TemplateArgument> Args,\n                             QualType Canon,\n                             QualType Aliased);\n\npublic:\n  /// Determine whether any of the given template arguments are dependent.\n  ///\n  /// The converted arguments should be supplied when known; whether an\n  /// argument is dependent can depend on the conversions performed on it\n  /// (for example, a 'const int' passed as a template argument might be\n  /// dependent if the parameter is a reference but non-dependent if the\n  /// parameter is an int).\n  ///\n  /// Note that the \\p Args parameter is unused: this is intentional, to remind\n  /// the caller that they need to pass in the converted arguments, not the\n  /// specified arguments.\n  static bool\n  anyDependentTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool\n  anyDependentTemplateArguments(const TemplateArgumentListInfo &,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool anyInstantiationDependentTemplateArguments(\n      ArrayRef<TemplateArgumentLoc> Args);\n\n  /// True if this template specialization type matches a current\n  /// instantiation in the context in which it is found.\n  bool isCurrentInstantiation() const {\n    return isa<InjectedClassNameType>(getCanonicalTypeInternal());\n  }\n\n  /// Determine if this template specialization type is for a type alias\n  /// template that has been substituted.\n  ///\n  /// Nearly every template specialization type whose template is an alias\n  /// template will be substituted. However, this is not the case when\n  /// the specialization contains a pack expansion but the template alias\n  /// does not have a corresponding parameter pack, e.g.,\n  ///\n  /// \\code\n  /// template<typename T, typename U, typename V> struct S;\n  /// template<typename T, typename U> using A = S<T, int, U>;\n  /// template<typename... Ts> struct X {\n  ///   typedef A<Ts...> type; // not a type alias\n  /// };\n  /// \\endcode\n  bool isTypeAlias() const { return TemplateSpecializationTypeBits.TypeAlias; }\n\n  /// Get the aliased type, if this is a specialization of a type alias\n  /// template.\n  QualType getAliasedType() const;\n\n  /// Retrieve the name of the template that we are specializing.\n  TemplateName getTemplateName() const { return Template; }\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {reinterpret_cast<const TemplateArgument *>(this + 1),\n            TemplateSpecializationTypeBits.NumArgs};\n  }\n\n  bool isSugared() const {\n    return !isDependentType() || isCurrentInstantiation() || isTypeAlias();\n  }\n\n  QualType desugar() const {\n    return isTypeAlias() ? getAliasedType() : getCanonicalTypeInternal();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx);\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName T,\n                      ArrayRef<TemplateArgument> Args,\n                      const ASTContext &Context);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateSpecialization;\n  }\n};\n\n/// Print a template argument list, including the '<' and '>'\n/// enclosing the template arguments.\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgument> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgumentLoc> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               const TemplateArgumentListInfo &Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\n/// Make a best-effort determination of whether the type T can be produced by\n/// substituting Args into the default argument of Param.\nbool isSubstitutedDefaultArgument(ASTContext &Ctx, TemplateArgument Arg,\n                                  const NamedDecl *Param,\n                                  ArrayRef<TemplateArgument> Args,\n                                  unsigned Depth);\n\n/// The injected class name of a C++ class template or class\n/// template partial specialization.  Used to record that a type was\n/// spelled with a bare identifier rather than as a template-id; the\n/// equivalent for non-templated classes is just RecordType.\n///\n/// Injected class name types are always dependent.  Template\n/// instantiation turns these into RecordTypes.\n///\n/// Injected class name types are always canonical.  This works\n/// because it is impossible to compare an injected class name type\n/// with the corresponding non-injected template type, for the same\n/// reason that it is impossible to directly compare template\n/// parameters from different dependent contexts: injected class name\n/// types can only occur within the scope of a particular templated\n/// declaration, and within that scope every template specialization\n/// will canonicalize to the injected class name (when appropriate\n/// according to the rules of the language).\nclass InjectedClassNameType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTNodeImporter;\n  friend class ASTReader; // FIXME: ASTContext::getInjectedClassNameType is not\n                          // currently suitable for AST reading, too much\n                          // interdependencies.\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  CXXRecordDecl *Decl;\n\n  /// The template specialization which this type represents.\n  /// For example, in\n  ///   template <class T> class A { ... };\n  /// this is A<T>, whereas in\n  ///   template <class X, class Y> class A<B<X,Y> > { ... };\n  /// this is A<B<X,Y> >.\n  ///\n  /// It is always unqualified, always a template specialization type,\n  /// and always dependent.\n  QualType InjectedType;\n\n  InjectedClassNameType(CXXRecordDecl *D, QualType TST)\n      : Type(InjectedClassName, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(D), InjectedType(TST) {\n    assert(isa<TemplateSpecializationType>(TST));\n    assert(!TST.hasQualifiers());\n    assert(TST->isDependentType());\n  }\n\npublic:\n  QualType getInjectedSpecializationType() const { return InjectedType; }\n\n  const TemplateSpecializationType *getInjectedTST() const {\n    return cast<TemplateSpecializationType>(InjectedType.getTypePtr());\n  }\n\n  TemplateName getTemplateName() const {\n    return getInjectedTST()->getTemplateName();\n  }\n\n  CXXRecordDecl *getDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == InjectedClassName;\n  }\n};\n\n/// The kind of a tag type.\nenum TagTypeKind {\n  /// The \"struct\" keyword.\n  TTK_Struct,\n\n  /// The \"__interface\" keyword.\n  TTK_Interface,\n\n  /// The \"union\" keyword.\n  TTK_Union,\n\n  /// The \"class\" keyword.\n  TTK_Class,\n\n  /// The \"enum\" keyword.\n  TTK_Enum\n};\n\n/// The elaboration keyword that precedes a qualified type name or\n/// introduces an elaborated-type-specifier.\nenum ElaboratedTypeKeyword {\n  /// The \"struct\" keyword introduces the elaborated-type-specifier.\n  ETK_Struct,\n\n  /// The \"__interface\" keyword introduces the elaborated-type-specifier.\n  ETK_Interface,\n\n  /// The \"union\" keyword introduces the elaborated-type-specifier.\n  ETK_Union,\n\n  /// The \"class\" keyword introduces the elaborated-type-specifier.\n  ETK_Class,\n\n  /// The \"enum\" keyword introduces the elaborated-type-specifier.\n  ETK_Enum,\n\n  /// The \"typename\" keyword precedes the qualified type name, e.g.,\n  /// \\c typename T::type.\n  ETK_Typename,\n\n  /// No keyword precedes the qualified type name.\n  ETK_None\n};\n\n/// A helper class for Type nodes having an ElaboratedTypeKeyword.\n/// The keyword in stored in the free bits of the base class.\n/// Also provides a few static helpers for converting and printing\n/// elaborated type keyword and tag type kind enumerations.\nclass TypeWithKeyword : public Type {\nprotected:\n  TypeWithKeyword(ElaboratedTypeKeyword Keyword, TypeClass tc,\n                  QualType Canonical, TypeDependence Dependence)\n      : Type(tc, Canonical, Dependence) {\n    TypeWithKeywordBits.Keyword = Keyword;\n  }\n\npublic:\n  ElaboratedTypeKeyword getKeyword() const {\n    return static_cast<ElaboratedTypeKeyword>(TypeWithKeywordBits.Keyword);\n  }\n\n  /// Converts a type specifier (DeclSpec::TST) into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a type specifier (DeclSpec::TST) into a tag type kind.\n  /// It is an error to provide a type specifier which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a TagTypeKind into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTagTypeKind(TagTypeKind Tag);\n\n  /// Converts an elaborated type keyword into a TagTypeKind.\n  /// It is an error to provide an elaborated type keyword\n  /// which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForKeyword(ElaboratedTypeKeyword Keyword);\n\n  static bool KeywordIsTagTypeKind(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getKeywordName(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getTagTypeKindName(TagTypeKind Kind) {\n    return getKeywordName(getKeywordForTagTypeKind(Kind));\n  }\n\n  class CannotCastToThisType {};\n  static CannotCastToThisType classof(const Type *);\n};\n\n/// Represents a type that was referred to using an elaborated type\n/// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type,\n/// or both.\n///\n/// This type is used to keep track of a type name as written in the\n/// source code, including tag keywords and any nested-name-specifiers.\n/// The type itself is always \"sugar\", used to express what was written\n/// in the source code but containing no additional semantic information.\nclass ElaboratedType final\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<ElaboratedType, TagDecl *> {\n  friend class ASTContext; // ASTContext creates these\n  friend TrailingObjects;\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this qualified name refers to.\n  QualType NamedType;\n\n  /// The (re)declaration of this tag type owned by this occurrence is stored\n  /// as a trailing object if there is one. Use getOwnedTagDecl to obtain\n  /// it, or obtain a null pointer if there is none.\n\n  ElaboratedType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                 QualType NamedType, QualType CanonType, TagDecl *OwnedTagDecl)\n      : TypeWithKeyword(Keyword, Elaborated, CanonType,\n                        // Any semantic dependence on the qualifier will have\n                        // been incorporated into NamedType. We still need to\n                        // track syntactic (instantiation / error / pack)\n                        // dependence on the qualifier.\n                        NamedType->getDependence() |\n                            (NNS ? toSyntacticDependence(\n                                       toTypeDependence(NNS->getDependence()))\n                                 : TypeDependence::None)),\n        NNS(NNS), NamedType(NamedType) {\n    ElaboratedTypeBits.HasOwnedTagDecl = false;\n    if (OwnedTagDecl) {\n      ElaboratedTypeBits.HasOwnedTagDecl = true;\n      *getTrailingObjects<TagDecl *>() = OwnedTagDecl;\n    }\n  }\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the qualified-id.\n  QualType getNamedType() const { return NamedType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getNamedType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  /// Return the (re)declaration of this type owned by this occurrence of this\n  /// type, or nullptr if there is none.\n  TagDecl *getOwnedTagDecl() const {\n    return ElaboratedTypeBits.HasOwnedTagDecl ? *getTrailingObjects<TagDecl *>()\n                                              : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, NamedType, getOwnedTagDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, QualType NamedType,\n                      TagDecl *OwnedTagDecl) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    NamedType.Profile(ID);\n    ID.AddPointer(OwnedTagDecl);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Elaborated; }\n};\n\n/// Represents a qualified type name for which the type name is\n/// dependent.\n///\n/// DependentNameType represents a class of dependent types that involve a\n/// possibly dependent nested-name-specifier (e.g., \"T::\") followed by a\n/// name of a type. The DependentNameType may start with a \"typename\" (for a\n/// typename-specifier), \"class\", \"struct\", \"union\", or \"enum\" (for a\n/// dependent elaborated-type-specifier), or nothing (in contexts where we\n/// know that we must be referring to a type, e.g., in a base class specifier).\n/// Typically the nested-name-specifier is dependent, but in MSVC compatibility\n/// mode, this type is used with non-dependent names to delay name lookup until\n/// instantiation.\nclass DependentNameType : public TypeWithKeyword, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this typename specifier refers to.\n  const IdentifierInfo *Name;\n\n  DependentNameType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                    const IdentifierInfo *Name, QualType CanonType)\n      : TypeWithKeyword(Keyword, DependentName, CanonType,\n                        TypeDependence::DependentInstantiation |\n                            toTypeDependence(NNS->getDependence())),\n        NNS(NNS), Name(Name) {}\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the typename specifier as an identifier.\n  ///\n  /// This routine will return a non-NULL identifier pointer when the\n  /// form of the original typename was terminated by an identifier,\n  /// e.g., \"typename T::type\".\n  const IdentifierInfo *getIdentifier() const {\n    return Name;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, Name);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, const IdentifierInfo *Name) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    ID.AddPointer(Name);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentName;\n  }\n};\n\n/// Represents a template specialization type whose template cannot be\n/// resolved, e.g.\n///   A<T>::template B<T>\nclass alignas(8) DependentTemplateSpecializationType\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The identifier of the template.\n  const IdentifierInfo *Name;\n\n  DependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                      NestedNameSpecifier *NNS,\n                                      const IdentifierInfo *Name,\n                                      ArrayRef<TemplateArgument> Args,\n                                      QualType Canon);\n\npublic:\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n  const IdentifierInfo *getIdentifier() const { return Name; }\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {reinterpret_cast<const TemplateArgument *>(this + 1),\n            DependentTemplateSpecializationTypeBits.NumArgs};\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getKeyword(), NNS, Name, template_arguments());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ASTContext &Context,\n                      ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *Qualifier,\n                      const IdentifierInfo *Name,\n                      ArrayRef<TemplateArgument> Args);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentTemplateSpecialization;\n  }\n};\n\n/// Represents a pack expansion of types.\n///\n/// Pack expansions are part of C++11 variadic templates. A pack\n/// expansion contains a pattern, which itself contains one or more\n/// \"unexpanded\" parameter packs. When instantiated, a pack expansion\n/// produces a series of types, each instantiated from the pattern of\n/// the expansion, where the Ith instantiation of the pattern uses the\n/// Ith arguments bound to each of the unexpanded parameter packs. The\n/// pack expansion is considered to \"expand\" these unexpanded\n/// parameter packs.\n///\n/// \\code\n/// template<typename ...Types> struct tuple;\n///\n/// template<typename ...Types>\n/// struct tuple_of_references {\n///   typedef tuple<Types&...> type;\n/// };\n/// \\endcode\n///\n/// Here, the pack expansion \\c Types&... is represented via a\n/// PackExpansionType whose pattern is Types&.\nclass PackExpansionType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The pattern of the pack expansion.\n  QualType Pattern;\n\n  PackExpansionType(QualType Pattern, QualType Canon,\n                    std::optional<unsigned> NumExpansions)\n      : Type(PackExpansion, Canon,\n             (Pattern->getDependence() | TypeDependence::Dependent |\n              TypeDependence::Instantiation) &\n                 ~TypeDependence::UnexpandedPack),\n        Pattern(Pattern) {\n    PackExpansionTypeBits.NumExpansions =\n        NumExpansions ? *NumExpansions + 1 : 0;\n  }\n\npublic:\n  /// Retrieve the pattern of this pack expansion, which is the\n  /// type that will be repeatedly instantiated when instantiating the\n  /// pack expansion itself.\n  QualType getPattern() const { return Pattern; }\n\n  /// Retrieve the number of expansions that this pack expansion will\n  /// generate, if known.\n  std::optional<unsigned> getNumExpansions() const {\n    if (PackExpansionTypeBits.NumExpansions)\n      return PackExpansionTypeBits.NumExpansions - 1;\n    return std::nullopt;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPattern(), getNumExpansions());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pattern,\n                      std::optional<unsigned> NumExpansions) {\n    ID.AddPointer(Pattern.getAsOpaquePtr());\n    ID.AddBoolean(NumExpansions.has_value());\n    if (NumExpansions)\n      ID.AddInteger(*NumExpansions);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == PackExpansion;\n  }\n};\n\n/// This class wraps the list of protocol qualifiers. For types that can\n/// take ObjC protocol qualifers, they can subclass this class.\ntemplate <class T>\nclass ObjCProtocolQualifiers {\nprotected:\n  ObjCProtocolQualifiers() = default;\n\n  ObjCProtocolDecl * const *getProtocolStorage() const {\n    return const_cast<ObjCProtocolQualifiers*>(this)->getProtocolStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorage() {\n    return static_cast<T*>(this)->getProtocolStorageImpl();\n  }\n\n  void setNumProtocols(unsigned N) {\n    static_cast<T*>(this)->setNumProtocolsImpl(N);\n  }\n\n  void initialize(ArrayRef<ObjCProtocolDecl *> protocols) {\n    setNumProtocols(protocols.size());\n    assert(getNumProtocols() == protocols.size() &&\n           \"bitfield overflow in protocol count\");\n    if (!protocols.empty())\n      memcpy(getProtocolStorage(), protocols.data(),\n             protocols.size() * sizeof(ObjCProtocolDecl*));\n  }\n\npublic:\n  using qual_iterator = ObjCProtocolDecl * const *;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n  qual_iterator qual_begin() const { return getProtocolStorage(); }\n  qual_iterator qual_end() const { return qual_begin() + getNumProtocols(); }\n\n  bool qual_empty() const { return getNumProtocols() == 0; }\n\n  /// Return the number of qualifying protocols in this type, or 0 if\n  /// there are none.\n  unsigned getNumProtocols() const {\n    return static_cast<const T*>(this)->getNumProtocolsImpl();\n  }\n\n  /// Fetch a protocol by index.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    assert(I < getNumProtocols() && \"Out-of-range protocol access\");\n    return qual_begin()[I];\n  }\n\n  /// Retrieve all of the protocol qualifiers.\n  ArrayRef<ObjCProtocolDecl *> getProtocols() const {\n    return ArrayRef<ObjCProtocolDecl *>(qual_begin(), getNumProtocols());\n  }\n};\n\n/// Represents a type parameter type in Objective C. It can take\n/// a list of protocols.\nclass ObjCTypeParamType : public Type,\n                          public ObjCProtocolQualifiers<ObjCTypeParamType>,\n                          public llvm::FoldingSetNode {\n  friend class ASTContext;\n  friend class ObjCProtocolQualifiers<ObjCTypeParamType>;\n\n  /// The number of protocols stored on this type.\n  unsigned NumProtocols : 6;\n\n  ObjCTypeParamDecl *OTPDecl;\n\n  /// The protocols are stored after the ObjCTypeParamType node. In the\n  /// canonical type, the list of protocols are sorted alphabetically\n  /// and uniqued.\n  ObjCProtocolDecl **getProtocolStorageImpl();\n\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return NumProtocols;\n  }\n\n  void setNumProtocolsImpl(unsigned N) {\n    NumProtocols = N;\n  }\n\n  ObjCTypeParamType(const ObjCTypeParamDecl *D,\n                    QualType can,\n                    ArrayRef<ObjCProtocolDecl *> protocols);\n\npublic:\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCTypeParam;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ObjCTypeParamDecl *OTPDecl,\n                      QualType CanonicalType,\n                      ArrayRef<ObjCProtocolDecl *> protocols);\n\n  ObjCTypeParamDecl *getDecl() const { return OTPDecl; }\n};\n\n/// Represents a class type in Objective C.\n///\n/// Every Objective C type is a combination of a base type, a set of\n/// type arguments (optional, for parameterized classes) and a list of\n/// protocols.\n///\n/// Given the following declarations:\n/// \\code\n///   \\@class C<T>;\n///   \\@protocol P;\n/// \\endcode\n///\n/// 'C' is an ObjCInterfaceType C.  It is sugar for an ObjCObjectType\n/// with base C and no protocols.\n///\n/// 'C<P>' is an unspecialized ObjCObjectType with base C and protocol list [P].\n/// 'C<C*>' is a specialized ObjCObjectType with type arguments 'C*' and no\n/// protocol list.\n/// 'C<C*><P>' is a specialized ObjCObjectType with base C, type arguments 'C*',\n/// and protocol list [P].\n///\n/// 'id' is a TypedefType which is sugar for an ObjCObjectPointerType whose\n/// pointee is an ObjCObjectType with base BuiltinType::ObjCIdType\n/// and no protocols.\n///\n/// 'id<P>' is an ObjCObjectPointerType whose pointee is an ObjCObjectType\n/// with base BuiltinType::ObjCIdType and protocol list [P].  Eventually\n/// this should get its own sugar class to better represent the source.\nclass ObjCObjectType : public Type,\n                       public ObjCProtocolQualifiers<ObjCObjectType> {\n  friend class ObjCProtocolQualifiers<ObjCObjectType>;\n\n  // ObjCObjectType.NumTypeArgs - the number of type arguments stored\n  // after the ObjCObjectPointerType node.\n  // ObjCObjectType.NumProtocols - the number of protocols stored\n  // after the type arguments of ObjCObjectPointerType node.\n  //\n  // These protocols are those written directly on the type.  If\n  // protocol qualifiers ever become additive, the iterators will need\n  // to get kindof complicated.\n  //\n  // In the canonical object type, these are sorted alphabetically\n  // and uniqued.\n\n  /// Either a BuiltinType or an InterfaceType or sugar for either.\n  QualType BaseType;\n\n  /// Cached superclass type.\n  mutable llvm::PointerIntPair<const ObjCObjectType *, 1, bool>\n    CachedSuperClassType;\n\n  QualType *getTypeArgStorage();\n  const QualType *getTypeArgStorage() const {\n    return const_cast<ObjCObjectType *>(this)->getTypeArgStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorageImpl();\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return ObjCObjectTypeBits.NumProtocols;\n  }\n  void setNumProtocolsImpl(unsigned N) {\n    ObjCObjectTypeBits.NumProtocols = N;\n  }\n\nprotected:\n  enum Nonce_ObjCInterface { Nonce_ObjCInterface };\n\n  ObjCObjectType(QualType Canonical, QualType Base,\n                 ArrayRef<QualType> typeArgs,\n                 ArrayRef<ObjCProtocolDecl *> protocols,\n                 bool isKindOf);\n\n  ObjCObjectType(enum Nonce_ObjCInterface)\n      : Type(ObjCInterface, QualType(), TypeDependence::None),\n        BaseType(QualType(this_(), 0)) {\n    ObjCObjectTypeBits.NumProtocols = 0;\n    ObjCObjectTypeBits.NumTypeArgs = 0;\n    ObjCObjectTypeBits.IsKindOf = 0;\n  }\n\n  void computeSuperClassTypeSlow() const;\n\npublic:\n  /// Gets the base type of this object type.  This is always (possibly\n  /// sugar for) one of:\n  ///  - the 'id' builtin type (as opposed to the 'id' type visible to the\n  ///    user, which is a typedef for an ObjCObjectPointerType)\n  ///  - the 'Class' builtin type (same caveat)\n  ///  - an ObjCObjectType (currently always an ObjCInterfaceType)\n  QualType getBaseType() const { return BaseType; }\n\n  bool isObjCId() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCId);\n  }\n\n  bool isObjCClass() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCClass);\n  }\n\n  bool isObjCUnqualifiedId() const { return qual_empty() && isObjCId(); }\n  bool isObjCUnqualifiedClass() const { return qual_empty() && isObjCClass(); }\n  bool isObjCUnqualifiedIdOrClass() const {\n    if (!qual_empty()) return false;\n    if (const BuiltinType *T = getBaseType()->getAs<BuiltinType>())\n      return T->getKind() == BuiltinType::ObjCId ||\n             T->getKind() == BuiltinType::ObjCClass;\n    return false;\n  }\n  bool isObjCQualifiedId() const { return !qual_empty() && isObjCId(); }\n  bool isObjCQualifiedClass() const { return !qual_empty() && isObjCClass(); }\n\n  /// Gets the interface declaration for this object type, if the base type\n  /// really is an interface.\n  ObjCInterfaceDecl *getInterface() const;\n\n  /// Determine whether this object type is \"specialized\", meaning\n  /// that it has type arguments.\n  bool isSpecialized() const;\n\n  /// Determine whether this object type was written with type arguments.\n  bool isSpecializedAsWritten() const {\n    return ObjCObjectTypeBits.NumTypeArgs > 0;\n  }\n\n  /// Determine whether this object type is \"unspecialized\", meaning\n  /// that it has no type arguments.\n  bool isUnspecialized() const { return !isSpecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments of this object type (semantically).\n  ArrayRef<QualType> getTypeArgs() const;\n\n  /// Retrieve the type arguments of this object type as they were\n  /// written.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return llvm::ArrayRef(getTypeArgStorage(), ObjCObjectTypeBits.NumTypeArgs);\n  }\n\n  /// Whether this is a \"__kindof\" type as written.\n  bool isKindOfTypeAsWritten() const { return ObjCObjectTypeBits.IsKindOf; }\n\n  /// Whether this ia a \"__kindof\" type (semantically).\n  bool isKindOfType() const;\n\n  /// Retrieve the type of the superclass of this object type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// specialization of the superclass type. Produces a null type if\n  /// there is no superclass.\n  QualType getSuperClassType() const {\n    if (!CachedSuperClassType.getInt())\n      computeSuperClassTypeSlow();\n\n    assert(CachedSuperClassType.getInt() && \"Superclass not set?\");\n    return QualType(CachedSuperClassType.getPointer(), 0);\n  }\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  QualType stripObjCKindOfTypeAndQuals(const ASTContext &ctx) const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObject ||\n           T->getTypeClass() == ObjCInterface;\n  }\n};\n\n/// A class providing a concrete implementation\n/// of ObjCObjectType, so as to not increase the footprint of\n/// ObjCInterfaceType.  Code outside of ASTContext and the core type\n/// system should not reference this type.\nclass ObjCObjectTypeImpl : public ObjCObjectType, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // If anyone adds fields here, ObjCObjectType::getProtocolStorage()\n  // will need to be modified.\n\n  ObjCObjectTypeImpl(QualType Canonical, QualType Base,\n                     ArrayRef<QualType> typeArgs,\n                     ArrayRef<ObjCProtocolDecl *> protocols,\n                     bool isKindOf)\n      : ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Base,\n                      ArrayRef<QualType> typeArgs,\n                      ArrayRef<ObjCProtocolDecl *> protocols,\n                      bool isKindOf);\n};\n\ninline QualType *ObjCObjectType::getTypeArgStorage() {\n  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl*>(this)+1);\n}\n\ninline ObjCProtocolDecl **ObjCObjectType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs);\n}\n\ninline ObjCProtocolDecl **ObjCTypeParamType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             static_cast<ObjCTypeParamType*>(this)+1);\n}\n\n/// Interfaces are the core concept in Objective-C for object oriented design.\n/// They basically correspond to C++ classes.  There are two kinds of interface\n/// types: normal interfaces like `NSString`, and qualified interfaces, which\n/// are qualified with a protocol list like `NSString<NSCopyable, NSAmazing>`.\n///\n/// ObjCInterfaceType guarantees the following properties when considered\n/// as a subtype of its superclass, ObjCObjectType:\n///   - There are no protocol qualifiers.  To reinforce this, code which\n///     tries to invoke the protocol methods via an ObjCInterfaceType will\n///     fail to compile.\n///   - It is its own base type.  That is, if T is an ObjCInterfaceType*,\n///     T->getBaseType() == QualType(T, 0).\nclass ObjCInterfaceType : public ObjCObjectType {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTReader;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  ObjCInterfaceDecl *Decl;\n\n  ObjCInterfaceType(const ObjCInterfaceDecl *D)\n      : ObjCObjectType(Nonce_ObjCInterface),\n        Decl(const_cast<ObjCInterfaceDecl*>(D)) {}\n\npublic:\n  /// Get the declaration of this interface.\n  ObjCInterfaceDecl *getDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCInterface;\n  }\n\n  // Nonsense to \"hide\" certain members of ObjCObjectType within this\n  // class.  People asking for protocols on an ObjCInterfaceType are\n  // not going to get what they want: ObjCInterfaceTypes are\n  // guaranteed to have no protocols.\n  enum {\n    qual_iterator,\n    qual_begin,\n    qual_end,\n    getNumProtocols,\n    getProtocol\n  };\n};\n\ninline ObjCInterfaceDecl *ObjCObjectType::getInterface() const {\n  QualType baseType = getBaseType();\n  while (const auto *ObjT = baseType->getAs<ObjCObjectType>()) {\n    if (const auto *T = dyn_cast<ObjCInterfaceType>(ObjT))\n      return T->getDecl();\n\n    baseType = ObjT->getBaseType();\n  }\n\n  return nullptr;\n}\n\n/// Represents a pointer to an Objective C object.\n///\n/// These are constructed from pointer declarators when the pointee type is\n/// an ObjCObjectType (or sugar for one).  In addition, the 'id' and 'Class'\n/// types are typedefs for these, and the protocol-qualified types 'id<P>'\n/// and 'Class<P>' are translated into these.\n///\n/// Pointers to pointers to Objective C objects are still PointerTypes;\n/// only the first level of pointer gets it own type implementation.\nclass ObjCObjectPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  ObjCObjectPointerType(QualType Canonical, QualType Pointee)\n      : Type(ObjCObjectPointer, Canonical, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  /// Gets the type pointed to by this ObjC pointer.\n  /// The result will always be an ObjCObjectType or sugar thereof.\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Gets the type pointed to by this ObjC pointer.  Always returns non-null.\n  ///\n  /// This method is equivalent to getPointeeType() except that\n  /// it discards any typedefs (or other sugar) between this\n  /// type and the \"outermost\" object type.  So for:\n  /// \\code\n  ///   \\@class A; \\@protocol P; \\@protocol Q;\n  ///   typedef A<P> AP;\n  ///   typedef A A1;\n  ///   typedef A1<P> A1P;\n  ///   typedef A1P<Q> A1PQ;\n  /// \\endcode\n  /// For 'A*', getObjectType() will return 'A'.\n  /// For 'A<P>*', getObjectType() will return 'A<P>'.\n  /// For 'AP*', getObjectType() will return 'A<P>'.\n  /// For 'A1*', getObjectType() will return 'A'.\n  /// For 'A1<P>*', getObjectType() will return 'A1<P>'.\n  /// For 'A1P*', getObjectType() will return 'A1<P>'.\n  /// For 'A1PQ*', getObjectType() will return 'A1<Q>', because\n  ///   adding protocols to a protocol-qualified base discards the\n  ///   old qualifiers (for now).  But if it didn't, getObjectType()\n  ///   would return 'A1P<Q>' (and we'd have to make iterating over\n  ///   qualifiers more complicated).\n  const ObjCObjectType *getObjectType() const {\n    return PointeeType->castAs<ObjCObjectType>();\n  }\n\n  /// If this pointer points to an Objective C\n  /// \\@interface type, gets the type for that interface.  Any protocol\n  /// qualifiers on the interface are ignored.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  const ObjCInterfaceType *getInterfaceType() const;\n\n  /// If this pointer points to an Objective \\@interface\n  /// type, gets the declaration for that interface.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  ObjCInterfaceDecl *getInterfaceDecl() const {\n    return getObjectType()->getInterface();\n  }\n\n  /// True if this is equivalent to the 'id' type, i.e. if\n  /// its object type is the primitive 'id' type with no protocols.\n  bool isObjCIdType() const {\n    return getObjectType()->isObjCUnqualifiedId();\n  }\n\n  /// True if this is equivalent to the 'Class' type,\n  /// i.e. if its object tive is the primitive 'Class' type with no protocols.\n  bool isObjCClassType() const {\n    return getObjectType()->isObjCUnqualifiedClass();\n  }\n\n  /// True if this is equivalent to the 'id' or 'Class' type,\n  bool isObjCIdOrClassType() const {\n    return getObjectType()->isObjCUnqualifiedIdOrClass();\n  }\n\n  /// True if this is equivalent to 'id<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedIdType() const {\n    return getObjectType()->isObjCQualifiedId();\n  }\n\n  /// True if this is equivalent to 'Class<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedClassType() const {\n    return getObjectType()->isObjCQualifiedClass();\n  }\n\n  /// Whether this is a \"__kindof\" type.\n  bool isKindOfType() const { return getObjectType()->isKindOfType(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecialized() const { return getObjectType()->isSpecialized(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecializedAsWritten() const {\n    return getObjectType()->isSpecializedAsWritten();\n  }\n\n  /// Whether this type is unspecialized, meaning that is has no type arguments.\n  bool isUnspecialized() const { return getObjectType()->isUnspecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgs() const {\n    return getObjectType()->getTypeArgs();\n  }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return getObjectType()->getTypeArgsAsWritten();\n  }\n\n  /// An iterator over the qualifiers on the object type.  Provided\n  /// for convenience.  This will always iterate over the full set of\n  /// protocols on a type, not just those provided directly.\n  using qual_iterator = ObjCObjectType::qual_iterator;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n\n  qual_iterator qual_begin() const {\n    return getObjectType()->qual_begin();\n  }\n\n  qual_iterator qual_end() const {\n    return getObjectType()->qual_end();\n  }\n\n  bool qual_empty() const { return getObjectType()->qual_empty(); }\n\n  /// Return the number of qualifying protocols on the object type.\n  unsigned getNumProtocols() const {\n    return getObjectType()->getNumProtocols();\n  }\n\n  /// Retrieve a qualifying protocol by index on the object type.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    return getObjectType()->getProtocol(I);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Retrieve the type of the superclass of this object pointer type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// pointer to a specialization of the superclass type. Produces a\n  /// null type if there is no superclass.\n  QualType getSuperClassType() const;\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  const ObjCObjectPointerType *stripObjCKindOfTypeAndQuals(\n                                 const ASTContext &ctx) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObjectPointer;\n  }\n};\n\nclass AtomicType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ValueType;\n\n  AtomicType(QualType ValTy, QualType Canonical)\n      : Type(Atomic, Canonical, ValTy->getDependence()), ValueType(ValTy) {}\n\npublic:\n  /// Gets the type contained by this atomic type, i.e.\n  /// the type returned by performing an atomic load of this atomic type.\n  QualType getValueType() const { return ValueType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getValueType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Atomic;\n  }\n};\n\n/// PipeType - OpenCL20.\nclass PipeType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n  bool isRead;\n\n  PipeType(QualType elemType, QualType CanonicalPtr, bool isRead)\n      : Type(Pipe, CanonicalPtr, elemType->getDependence()),\n        ElementType(elemType), isRead(isRead) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), isReadOnly());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T, bool isRead) {\n    ID.AddPointer(T.getAsOpaquePtr());\n    ID.AddBoolean(isRead);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Pipe;\n  }\n\n  bool isReadOnly() const { return isRead; }\n};\n\n/// A fixed int type of a specified bitwidth.\nclass BitIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  unsigned IsUnsigned : 1;\n  unsigned NumBits : 24;\n\nprotected:\n  BitIntType(bool isUnsigned, unsigned NumBits);\n\npublic:\n  bool isUnsigned() const { return IsUnsigned; }\n  bool isSigned() const { return !IsUnsigned; }\n  unsigned getNumBits() const { return NumBits; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, isUnsigned(), getNumBits());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, bool IsUnsigned,\n                      unsigned NumBits) {\n    ID.AddBoolean(IsUnsigned);\n    ID.AddInteger(NumBits);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == BitInt; }\n};\n\nclass DependentBitIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  const ASTContext &Context;\n  llvm::PointerIntPair<Expr*, 1, bool> ExprAndUnsigned;\n\nprotected:\n  DependentBitIntType(const ASTContext &Context, bool IsUnsigned,\n                      Expr *NumBits);\n\npublic:\n  bool isUnsigned() const;\n  bool isSigned() const { return !isUnsigned(); }\n  Expr *getNumBitsExpr() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, isUnsigned(), getNumBitsExpr());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      bool IsUnsigned, Expr *NumBitsExpr);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentBitInt;\n  }\n};\n\n/// A qualifier set is used to build a set of qualifiers.\nclass QualifierCollector : public Qualifiers {\npublic:\n  QualifierCollector(Qualifiers Qs = Qualifiers()) : Qualifiers(Qs) {}\n\n  /// Collect any qualifiers on the given type and return an\n  /// unqualified type.  The qualifiers are assumed to be consistent\n  /// with those already in the type.\n  const Type *strip(QualType type) {\n    addFastQualifiers(type.getLocalFastQualifiers());\n    if (!type.hasLocalNonFastQualifiers())\n      return type.getTypePtrUnsafe();\n\n    const ExtQuals *extQuals = type.getExtQualsUnsafe();\n    addConsistentQualifiers(extQuals->getQualifiers());\n    return extQuals->getBaseType();\n  }\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, QualType QT) const;\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, const Type* T) const;\n};\n\n/// A container of type source information.\n///\n/// A client can read the relevant info using TypeLoc wrappers, e.g:\n/// @code\n/// TypeLoc TL = TypeSourceInfo->getTypeLoc();\n/// TL.getBeginLoc().print(OS, SrcMgr);\n/// @endcode\nclass alignas(8) TypeSourceInfo {\n  // Contains a memory block after the class, used for type source information,\n  // allocated by ASTContext.\n  friend class ASTContext;\n\n  QualType Ty;\n\n  TypeSourceInfo(QualType ty, size_t DataSize); // implemented in TypeLoc.h\n\npublic:\n  /// Return the type wrapped by this type source info.\n  QualType getType() const { return Ty; }\n\n  /// Return the TypeLoc wrapper for the type source info.\n  TypeLoc getTypeLoc() const; // implemented in TypeLoc.h\n\n  /// Override the type stored in this TypeSourceInfo. Use with caution!\n  void overrideType(QualType T) { Ty = T; }\n};\n\n// Inline function definitions.\n\ninline SplitQualType SplitQualType::getSingleStepDesugaredType() const {\n  SplitQualType desugar =\n    Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();\n  desugar.Quals.addConsistentQualifiers(Quals);\n  return desugar;\n}\n\ninline const Type *QualType::getTypePtr() const {\n  return getCommonPtr()->BaseType;\n}\n\ninline const Type *QualType::getTypePtrOrNull() const {\n  return (isNull() ? nullptr : getCommonPtr()->BaseType);\n}\n\ninline bool QualType::isReferenceable() const {\n  // C++ [defns.referenceable]\n  //   type that is either an object type, a function type that does not have\n  //   cv-qualifiers or a ref-qualifier, or a reference type.\n  const Type &Self = **this;\n  if (Self.isObjectType() || Self.isReferenceType())\n    return true;\n  if (const auto *F = Self.getAs<FunctionProtoType>())\n    return F->getMethodQuals().empty() && F->getRefQualifier() == RQ_None;\n\n  return false;\n}\n\ninline SplitQualType QualType::split() const {\n  if (!hasLocalNonFastQualifiers())\n    return SplitQualType(getTypePtrUnsafe(),\n                         Qualifiers::fromFastMask(getLocalFastQualifiers()));\n\n  const ExtQuals *eq = getExtQualsUnsafe();\n  Qualifiers qs = eq->getQualifiers();\n  qs.addFastQualifiers(getLocalFastQualifiers());\n  return SplitQualType(eq->getBaseType(), qs);\n}\n\ninline Qualifiers QualType::getLocalQualifiers() const {\n  Qualifiers Quals;\n  if (hasLocalNonFastQualifiers())\n    Quals = getExtQualsUnsafe()->getQualifiers();\n  Quals.addFastQualifiers(getLocalFastQualifiers());\n  return Quals;\n}\n\ninline Qualifiers QualType::getQualifiers() const {\n  Qualifiers quals = getCommonPtr()->CanonicalType.getLocalQualifiers();\n  quals.addFastQualifiers(getLocalFastQualifiers());\n  return quals;\n}\n\ninline unsigned QualType::getCVRQualifiers() const {\n  unsigned cvr = getCommonPtr()->CanonicalType.getLocalCVRQualifiers();\n  cvr |= getLocalCVRQualifiers();\n  return cvr;\n}\n\ninline QualType QualType::getCanonicalType() const {\n  QualType canon = getCommonPtr()->CanonicalType;\n  return canon.withFastQualifiers(getLocalFastQualifiers());\n}\n\ninline bool QualType::isCanonical() const {\n  return getTypePtr()->isCanonicalUnqualified();\n}\n\ninline bool QualType::isCanonicalAsParam() const {\n  if (!isCanonical()) return false;\n  if (hasLocalQualifiers()) return false;\n\n  const Type *T = getTypePtr();\n  if (T->isVariablyModifiedType() && T->hasSizedVLAType())\n    return false;\n\n  return !isa<FunctionType>(T) && !isa<ArrayType>(T);\n}\n\ninline bool QualType::isConstQualified() const {\n  return isLocalConstQualified() ||\n         getCommonPtr()->CanonicalType.isLocalConstQualified();\n}\n\ninline bool QualType::isRestrictQualified() const {\n  return isLocalRestrictQualified() ||\n         getCommonPtr()->CanonicalType.isLocalRestrictQualified();\n}\n\n\ninline bool QualType::isVolatileQualified() const {\n  return isLocalVolatileQualified() ||\n         getCommonPtr()->CanonicalType.isLocalVolatileQualified();\n}\n\ninline bool QualType::hasQualifiers() const {\n  return hasLocalQualifiers() ||\n         getCommonPtr()->CanonicalType.hasLocalQualifiers();\n}\n\ninline QualType QualType::getUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return QualType(getTypePtr(), 0);\n\n  return QualType(getSplitUnqualifiedTypeImpl(*this).Ty, 0);\n}\n\ninline SplitQualType QualType::getSplitUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return split();\n\n  return getSplitUnqualifiedTypeImpl(*this);\n}\n\ninline void QualType::removeLocalConst() {\n  removeLocalFastQualifiers(Qualifiers::Const);\n}\n\ninline void QualType::removeLocalRestrict() {\n  removeLocalFastQualifiers(Qualifiers::Restrict);\n}\n\ninline void QualType::removeLocalVolatile() {\n  removeLocalFastQualifiers(Qualifiers::Volatile);\n}\n\n/// Check if this type has any address space qualifier.\ninline bool QualType::hasAddressSpace() const {\n  return getQualifiers().hasAddressSpace();\n}\n\n/// Return the address space of this type.\ninline LangAS QualType::getAddressSpace() const {\n  return getQualifiers().getAddressSpace();\n}\n\n/// Return the gc attribute of this type.\ninline Qualifiers::GC QualType::getObjCGCAttr() const {\n  return getQualifiers().getObjCGCAttr();\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDefaultInitializeCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDestructCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDestructCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveCopyCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveCopyCUnion(RD);\n  return false;\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(const Type &t) {\n  if (const auto *PT = t.getAs<PointerType>()) {\n    if (const auto *FT = PT->getPointeeType()->getAs<FunctionType>())\n      return FT->getExtInfo();\n  } else if (const auto *FT = t.getAs<FunctionType>())\n    return FT->getExtInfo();\n\n  return FunctionType::ExtInfo();\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(QualType t) {\n  return getFunctionExtInfo(*t);\n}\n\n/// Determine whether this type is more\n/// qualified than the Other type. For example, \"const volatile int\"\n/// is more qualified than \"const int\", \"volatile int\", and\n/// \"int\". However, it is not more qualified than \"const volatile\n/// int\".\ninline bool QualType::isMoreQualifiedThan(QualType other) const {\n  Qualifiers MyQuals = getQualifiers();\n  Qualifiers OtherQuals = other.getQualifiers();\n  return (MyQuals != OtherQuals && MyQuals.compatiblyIncludes(OtherQuals));\n}\n\n/// Determine whether this type is at last\n/// as qualified as the Other type. For example, \"const volatile\n/// int\" is at least as qualified as \"const int\", \"volatile int\",\n/// \"int\", and \"const volatile int\".\ninline bool QualType::isAtLeastAsQualifiedAs(QualType other) const {\n  Qualifiers OtherQuals = other.getQualifiers();\n\n  // Ignore __unaligned qualifier if this type is a void.\n  if (getUnqualifiedType()->isVoidType())\n    OtherQuals.removeUnaligned();\n\n  return getQualifiers().compatiblyIncludes(OtherQuals);\n}\n\n/// If Type is a reference type (e.g., const\n/// int&), returns the type that the reference refers to (\"const\n/// int\"). Otherwise, returns the type itself. This routine is used\n/// throughout Sema to implement C++ 5p6:\n///\n///   If an expression initially has the type \"reference to T\" (8.3.2,\n///   8.5.3), the type is adjusted to \"T\" prior to any further\n///   analysis, the expression designates the object or function\n///   denoted by the reference, and the expression is an lvalue.\ninline QualType QualType::getNonReferenceType() const {\n  if (const auto *RefType = (*this)->getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ninline bool QualType::isCForbiddenLValueType() const {\n  return ((getTypePtr()->isVoidType() && !hasQualifiers()) ||\n          getTypePtr()->isFunctionType());\n}\n\n/// Tests whether the type is categorized as a fundamental type.\n///\n/// \\returns True for types specified in C++0x [basic.fundamental].\ninline bool Type::isFundamentalType() const {\n  return isVoidType() ||\n         isNullPtrType() ||\n         // FIXME: It's really annoying that we don't have an\n         // 'isArithmeticType()' which agrees with the standard definition.\n         (isArithmeticType() && !isEnumeralType());\n}\n\n/// Tests whether the type is categorized as a compound type.\n///\n/// \\returns True for types specified in C++0x [basic.compound].\ninline bool Type::isCompoundType() const {\n  // C++0x [basic.compound]p1:\n  //   Compound types can be constructed in the following ways:\n  //    -- arrays of objects of a given type [...];\n  return isArrayType() ||\n  //    -- functions, which have parameters of given types [...];\n         isFunctionType() ||\n  //    -- pointers to void or objects or functions [...];\n         isPointerType() ||\n  //    -- references to objects or functions of a given type. [...]\n         isReferenceType() ||\n  //    -- classes containing a sequence of objects of various types, [...];\n         isRecordType() ||\n  //    -- unions, which are classes capable of containing objects of different\n  //               types at different times;\n         isUnionType() ||\n  //    -- enumerations, which comprise a set of named constant values. [...];\n         isEnumeralType() ||\n  //    -- pointers to non-static class members, [...].\n         isMemberPointerType();\n}\n\ninline bool Type::isFunctionType() const {\n  return isa<FunctionType>(CanonicalType);\n}\n\ninline bool Type::isPointerType() const {\n  return isa<PointerType>(CanonicalType);\n}\n\ninline bool Type::isAnyPointerType() const {\n  return isPointerType() || isObjCObjectPointerType();\n}\n\ninline bool Type::isBlockPointerType() const {\n  return isa<BlockPointerType>(CanonicalType);\n}\n\ninline bool Type::isReferenceType() const {\n  return isa<ReferenceType>(CanonicalType);\n}\n\ninline bool Type::isLValueReferenceType() const {\n  return isa<LValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isRValueReferenceType() const {\n  return isa<RValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isObjectPointerType() const {\n  // Note: an \"object pointer type\" is not the same thing as a pointer to an\n  // object type; rather, it is a pointer to an object type or a pointer to cv\n  // void.\n  if (const auto *T = getAs<PointerType>())\n    return !T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionPointerType() const {\n  if (const auto *T = getAs<PointerType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionReferenceType() const {\n  if (const auto *T = getAs<ReferenceType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isMemberPointerType() const {\n  return isa<MemberPointerType>(CanonicalType);\n}\n\ninline bool Type::isMemberFunctionPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberFunctionPointer();\n  else\n    return false;\n}\n\ninline bool Type::isMemberDataPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberDataPointer();\n  else\n    return false;\n}\n\ninline bool Type::isArrayType() const {\n  return isa<ArrayType>(CanonicalType);\n}\n\ninline bool Type::isConstantArrayType() const {\n  return isa<ConstantArrayType>(CanonicalType);\n}\n\ninline bool Type::isIncompleteArrayType() const {\n  return isa<IncompleteArrayType>(CanonicalType);\n}\n\ninline bool Type::isVariableArrayType() const {\n  return isa<VariableArrayType>(CanonicalType);\n}\n\ninline bool Type::isDependentSizedArrayType() const {\n  return isa<DependentSizedArrayType>(CanonicalType);\n}\n\ninline bool Type::isBuiltinType() const {\n  return isa<BuiltinType>(CanonicalType);\n}\n\ninline bool Type::isRecordType() const {\n  return isa<RecordType>(CanonicalType);\n}\n\ninline bool Type::isEnumeralType() const {\n  return isa<EnumType>(CanonicalType);\n}\n\ninline bool Type::isAnyComplexType() const {\n  return isa<ComplexType>(CanonicalType);\n}\n\ninline bool Type::isVectorType() const {\n  return isa<VectorType>(CanonicalType);\n}\n\ninline bool Type::isExtVectorType() const {\n  return isa<ExtVectorType>(CanonicalType);\n}\n\ninline bool Type::isExtVectorBoolType() const {\n  if (!isExtVectorType())\n    return false;\n  return cast<ExtVectorType>(CanonicalType)->getElementType()->isBooleanType();\n}\n\ninline bool Type::isMatrixType() const {\n  return isa<MatrixType>(CanonicalType);\n}\n\ninline bool Type::isConstantMatrixType() const {\n  return isa<ConstantMatrixType>(CanonicalType);\n}\n\ninline bool Type::isDependentAddressSpaceType() const {\n  return isa<DependentAddressSpaceType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectPointerType() const {\n  return isa<ObjCObjectPointerType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectType() const {\n  return isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectOrInterfaceType() const {\n  return isa<ObjCInterfaceType>(CanonicalType) ||\n    isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isAtomicType() const {\n  return isa<AtomicType>(CanonicalType);\n}\n\ninline bool Type::isUndeducedAutoType() const {\n  return isa<AutoType>(CanonicalType);\n}\n\ninline bool Type::isObjCQualifiedIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedIdType();\n  return false;\n}\n\ninline bool Type::isObjCQualifiedClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedClassType();\n  return false;\n}\n\ninline bool Type::isObjCIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCIdType();\n  return false;\n}\n\ninline bool Type::isObjCClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCClassType();\n  return false;\n}\n\ninline bool Type::isObjCSelType() const {\n  if (const auto *OPT = getAs<PointerType>())\n    return OPT->getPointeeType()->isSpecificBuiltinType(BuiltinType::ObjCSel);\n  return false;\n}\n\ninline bool Type::isObjCBuiltinType() const {\n  return isObjCIdType() || isObjCClassType() || isObjCSelType();\n}\n\ninline bool Type::isDecltypeType() const {\n  return isa<DecltypeType>(this);\n}\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\ninline bool Type::isSamplerT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLSampler);\n}\n\ninline bool Type::isEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLEvent);\n}\n\ninline bool Type::isClkEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLClkEvent);\n}\n\ninline bool Type::isQueueT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLQueue);\n}\n\ninline bool Type::isReserveIDT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLReserveID);\n}\n\ninline bool Type::isImageType() const {\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLImageTypes.def\"\n      false; // end boolean or operation\n}\n\ninline bool Type::isPipeType() const {\n  return isa<PipeType>(CanonicalType);\n}\n\ninline bool Type::isBitIntType() const {\n  return isa<BitIntType>(CanonicalType);\n}\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n\ninline bool Type::isOCLIntelSubgroupAVCType() const {\n#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id) \\\n  isOCLIntelSubgroupAVC##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOCLExtOpaqueType() const {\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOpenCLSpecificType() const {\n  return isSamplerT() || isEventT() || isImageType() || isClkEventT() ||\n         isQueueT() || isReserveIDT() || isPipeType() || isOCLExtOpaqueType();\n}\n\ninline bool Type::isRVVType() const {\n#define RVV_TYPE(Name, Id, SingletonId) \\\n  isSpecificBuiltinType(BuiltinType::Id) ||\n  return\n#include \"clang/Basic/RISCVVTypes.def\"\n    false; // end of boolean or operation.\n}\n\ninline bool Type::isRVVType(unsigned ElementCount) const {\n  bool Ret = false;\n#define RVV_VECTOR_TYPE(Name, Id, SingletonId, NumEls, ElBits, NF, IsSigned,   \\\n                        IsFP)                                                  \\\n  if (NumEls == ElementCount)                                                  \\\n    Ret |= isSpecificBuiltinType(BuiltinType::Id);\n#include \"clang/Basic/RISCVVTypes.def\"\n  return Ret;\n}\n\ninline bool Type::isRVVType(unsigned Bitwidth, bool IsFloat) const {\n  bool Ret = false;\n#define RVV_TYPE(Name, Id, SingletonId)\n#define RVV_VECTOR_TYPE(Name, Id, SingletonId, NumEls, ElBits, NF, IsSigned,   \\\n                        IsFP)                                                  \\\n  if (ElBits == Bitwidth && IsFloat == IsFP)                                   \\\n    Ret |= isSpecificBuiltinType(BuiltinType::Id);\n#include \"clang/Basic/RISCVVTypes.def\"\n  return Ret;\n}\n\ninline bool Type::isTemplateTypeParmType() const {\n  return isa<TemplateTypeParmType>(CanonicalType);\n}\n\ninline bool Type::isSpecificBuiltinType(unsigned K) const {\n  if (const BuiltinType *BT = getAs<BuiltinType>()) {\n    return BT->getKind() == static_cast<BuiltinType::Kind>(K);\n  }\n  return false;\n}\n\ninline bool Type::isPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isPlaceholderType();\n  return false;\n}\n\ninline const BuiltinType *Type::getAsPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    if (BT->isPlaceholderType())\n      return BT;\n  return nullptr;\n}\n\ninline bool Type::isSpecificPlaceholderType(unsigned K) const {\n  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind) K));\n  return isSpecificBuiltinType(K);\n}\n\ninline bool Type::isNonOverloadPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isNonOverloadPlaceholderType();\n  return false;\n}\n\ninline bool Type::isVoidType() const {\n  return isSpecificBuiltinType(BuiltinType::Void);\n}\n\ninline bool Type::isHalfType() const {\n  // FIXME: Should we allow complex __fp16? Probably not.\n  return isSpecificBuiltinType(BuiltinType::Half);\n}\n\ninline bool Type::isFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float16);\n}\n\ninline bool Type::isBFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::BFloat16);\n}\n\ninline bool Type::isFloat128Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float128);\n}\n\ninline bool Type::isIbm128Type() const {\n  return isSpecificBuiltinType(BuiltinType::Ibm128);\n}\n\ninline bool Type::isNullPtrType() const {\n  return isSpecificBuiltinType(BuiltinType::NullPtr);\n}\n\nbool IsEnumDeclComplete(EnumDecl *);\nbool IsEnumDeclScoped(EnumDecl *);\n\ninline bool Type::isIntegerType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType)) {\n    // Incomplete enum types are not treated as integer types.\n    // FIXME: In C++, enum types are never integer types.\n    return IsEnumDeclComplete(ET->getDecl()) &&\n      !IsEnumDeclScoped(ET->getDecl());\n  }\n  return isBitIntType();\n}\n\ninline bool Type::isFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::ShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isFixedPointOrIntegerType() const {\n  return isFixedPointType() || isIntegerType();\n}\n\ninline bool Type::isSaturatedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::SatShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isUnsaturatedFixedPointType() const {\n  return isFixedPointType() && !isSaturatedFixedPointType();\n}\n\ninline bool Type::isSignedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return ((BT->getKind() >= BuiltinType::ShortAccum &&\n             BT->getKind() <= BuiltinType::LongAccum) ||\n            (BT->getKind() >= BuiltinType::ShortFract &&\n             BT->getKind() <= BuiltinType::LongFract) ||\n            (BT->getKind() >= BuiltinType::SatShortAccum &&\n             BT->getKind() <= BuiltinType::SatLongAccum) ||\n            (BT->getKind() >= BuiltinType::SatShortFract &&\n             BT->getKind() <= BuiltinType::SatLongFract));\n  }\n  return false;\n}\n\ninline bool Type::isUnsignedFixedPointType() const {\n  return isFixedPointType() && !isSignedFixedPointType();\n}\n\ninline bool Type::isScalarType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() > BuiltinType::Void &&\n           BT->getKind() <= BuiltinType::NullPtr;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType))\n    // Enums are scalar types, but only if they are defined.  Incomplete enums\n    // are not treated as scalar types.\n    return IsEnumDeclComplete(ET->getDecl());\n  return isa<PointerType>(CanonicalType) ||\n         isa<BlockPointerType>(CanonicalType) ||\n         isa<MemberPointerType>(CanonicalType) ||\n         isa<ComplexType>(CanonicalType) ||\n         isa<ObjCObjectPointerType>(CanonicalType) ||\n         isBitIntType();\n}\n\ninline bool Type::isIntegralOrEnumerationType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n\n  // Check for a complete enum type; incomplete enum types are not properly an\n  // enumeration type in the sense required here.\n  if (const auto *ET = dyn_cast<EnumType>(CanonicalType))\n    return IsEnumDeclComplete(ET->getDecl());\n\n  return isBitIntType();\n}\n\ninline bool Type::isBooleanType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() == BuiltinType::Bool;\n  return false;\n}\n\ninline bool Type::isUndeducedType() const {\n  auto *DT = getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\n/// Determines whether this is a type for which one can define\n/// an overloaded operator.\ninline bool Type::isOverloadableType() const {\n  return isDependentType() || isRecordType() || isEnumeralType();\n}\n\n/// Determines whether this type is written as a typedef-name.\ninline bool Type::isTypedefNameType() const {\n  if (getAs<TypedefType>())\n    return true;\n  if (auto *TST = getAs<TemplateSpecializationType>())\n    return TST->isTypeAlias();\n  return false;\n}\n\n/// Determines whether this type can decay to a pointer type.\ninline bool Type::canDecayToPointerType() const {\n  return isFunctionType() || isArrayType();\n}\n\ninline bool Type::hasPointerRepresentation() const {\n  return (isPointerType() || isReferenceType() || isBlockPointerType() ||\n          isObjCObjectPointerType() || isNullPtrType());\n}\n\ninline bool Type::hasObjCPointerRepresentation() const {\n  return isObjCObjectPointerType();\n}\n\ninline const Type *Type::getBaseElementTypeUnsafe() const {\n  const Type *type = this;\n  while (const ArrayType *arrayType = type->getAsArrayTypeUnsafe())\n    type = arrayType->getElementType().getTypePtr();\n  return type;\n}\n\ninline const Type *Type::getPointeeOrArrayElementType() const {\n  const Type *type = this;\n  if (type->isAnyPointerType())\n    return type->getPointeeType().getTypePtr();\n  else if (type->isArrayType())\n    return type->getBaseElementTypeUnsafe();\n  return type;\n}\n/// Insertion operator for partial diagnostics. This allows sending adress\n/// spaces into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             LangAS AS) {\n  PD.AddTaggedVal(static_cast<std::underlying_type_t<LangAS>>(AS),\n                  DiagnosticsEngine::ArgumentKind::ak_addrspace);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics. This allows sending Qualifiers\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             Qualifiers Q) {\n  PD.AddTaggedVal(Q.getAsOpaqueValue(),\n                  DiagnosticsEngine::ArgumentKind::ak_qual);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics.  This allows sending QualType's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             QualType T) {\n  PD.AddTaggedVal(reinterpret_cast<uint64_t>(T.getAsOpaquePtr()),\n                  DiagnosticsEngine::ak_qualtype);\n  return PD;\n}\n\n// Helper class template that is used by Type::getAs to ensure that one does\n// not try to look through a qualified type to get to an array type.\ntemplate <typename T>\nusing TypeIsArrayType =\n    std::integral_constant<bool, std::is_same<T, ArrayType>::value ||\n                                     std::is_base_of<ArrayType, T>::value>;\n\n// Member-template getAs<specific type>'.\ntemplate <typename T> const T *Type::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::getAsAdjusted() const {\n  static_assert(!TypeIsArrayType<T>::value, \"ArrayType cannot be used with getAsAdjusted!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // Strip off type adjustments that do not modify the underlying nature of the\n  // type.\n  const Type *Ty = this;\n  while (Ty) {\n    if (const auto *A = dyn_cast<AttributedType>(Ty))\n      Ty = A->getModifiedType().getTypePtr();\n    else if (const auto *A = dyn_cast<BTFTagAttributedType>(Ty))\n      Ty = A->getWrappedType().getTypePtr();\n    else if (const auto *E = dyn_cast<ElaboratedType>(Ty))\n      Ty = E->desugar().getTypePtr();\n    else if (const auto *P = dyn_cast<ParenType>(Ty))\n      Ty = P->desugar().getTypePtr();\n    else if (const auto *A = dyn_cast<AdjustedType>(Ty))\n      Ty = A->desugar().getTypePtr();\n    else if (const auto *M = dyn_cast<MacroQualifiedType>(Ty))\n      Ty = M->desugar().getTypePtr();\n    else\n      break;\n  }\n\n  // Just because the canonical type is correct does not mean we can use cast<>,\n  // since we may not have stripped off all the sugar down to the base type.\n  return dyn_cast<T>(Ty);\n}\n\ninline const ArrayType *Type::getAsArrayTypeUnsafe() const {\n  // If this is directly an array type, return it.\n  if (const auto *arr = dyn_cast<ArrayType>(this))\n    return arr;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<ArrayType>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::castAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  if (const auto *ty = dyn_cast<T>(this)) return ty;\n  assert(isa<T>(CanonicalType));\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ninline const ArrayType *Type::castAsArrayTypeUnsafe() const {\n  assert(isa<ArrayType>(CanonicalType));\n  if (const auto *arr = dyn_cast<ArrayType>(this)) return arr;\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\nDecayedType::DecayedType(QualType OriginalType, QualType DecayedPtr,\n                         QualType CanonicalPtr)\n    : AdjustedType(Decayed, OriginalType, DecayedPtr, CanonicalPtr) {\n#ifndef NDEBUG\n  QualType Adjusted = getAdjustedType();\n  (void)AttributedType::stripOuterNullability(Adjusted);\n  assert(isa<PointerType>(Adjusted));\n#endif\n}\n\nQualType DecayedType::getPointeeType() const {\n  QualType Decayed = getDecayedType();\n  (void)AttributedType::stripOuterNullability(Decayed);\n  return cast<PointerType>(Decayed)->getPointeeType();\n}\n\n// Get the decimal string representation of a fixed point type, represented\n// as a scaled integer.\n// TODO: At some point, we should change the arguments to instead just accept an\n// APFixedPoint instead of APSInt and scale.\nvoid FixedPointValueToString(SmallVectorImpl<char> &Str, llvm::APSInt Val,\n                             unsigned Scale);\n\n}",
  "id": "BLOCK-CPP-14132",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Type.h",
  "source_line": 3259,
  "validation_status": "validated"
}