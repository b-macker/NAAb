{
  "code": "{\npublic:\n  /// Encapsulates the lexical context of a function call.  The lexical\n  /// context includes the arguments to the call, including the implicit object\n  /// argument.  When an attribute containing a mutex expression is attached to\n  /// a method, the expression may refer to formal parameters of the method.\n  /// Actual arguments must be substituted for formal parameters to derive\n  /// the appropriate mutex expression in the lexical context where the function\n  /// is called.  PrevCtx holds the context in which the arguments themselves\n  /// should be evaluated; multiple calling contexts can be chained together\n  /// by the lock_returned attribute.\n  struct CallingContext {\n    // The previous context; or 0 if none.\n    CallingContext  *Prev;\n\n    // The decl to which the attr is attached.\n    const NamedDecl *AttrDecl;\n\n    // Implicit object argument -- e.g. 'this'\n    llvm::PointerUnion<const Expr *, til::SExpr *> SelfArg = nullptr;\n\n    // Number of funArgs\n    unsigned NumArgs = 0;\n\n    // Function arguments\n    const Expr *const *FunArgs = nullptr;\n\n    // is Self referred to with -> or .?\n    bool SelfArrow = false;\n\n    CallingContext(CallingContext *P, const NamedDecl *D = nullptr)\n        : Prev(P), AttrDecl(D) {}\n  };\n\n  SExprBuilder(til::MemRegionRef A) : Arena(A) {\n    // FIXME: we don't always have a self-variable.\n    SelfVar = new (Arena) til::Variable(nullptr);\n    SelfVar->setKind(til::Variable::VK_SFun);\n  }\n\n  // Translate a clang expression in an attribute to a til::SExpr.\n  // Constructs the context from D, DeclExp, and SelfDecl.\n  CapabilityExpr translateAttrExpr(const Expr *AttrExp, const NamedDecl *D,\n                                   const Expr *DeclExp,\n                                   til::SExpr *Self = nullptr);\n\n  CapabilityExpr translateAttrExpr(const Expr *AttrExp, CallingContext *Ctx);\n\n  // Translate a variable reference.\n  til::LiteralPtr *createVariable(const VarDecl *VD);\n\n  // Create placeholder for this: we don't know the VarDecl on construction yet.\n  std::pair<til::LiteralPtr *, StringRef>\n  createThisPlaceholder(const Expr *Exp);\n\n  // Translate a clang statement or expression to a TIL expression.\n  // Also performs substitution of variables; Ctx provides the context.\n  // Dispatches on the type of S.\n  til::SExpr *translate(const Stmt *S, CallingContext *Ctx);\n  til::SCFG  *buildCFG(CFGWalker &Walker);\n\n  til::SExpr *lookupStmt(const Stmt *S);\n\n  til::BasicBlock *lookupBlock(const CFGBlock *B) {\n    return BlockMap[B->getBlockID()];\n  }\n\n  const til::SCFG *getCFG() const { return Scfg; }\n  til::SCFG *getCFG() { return Scfg; }\n\nprivate:\n  // We implement the CFGVisitor API\n  friend class CFGWalker;\n\n  til::SExpr *translateDeclRefExpr(const DeclRefExpr *DRE,\n                                   CallingContext *Ctx) ;\n  til::SExpr *translateCXXThisExpr(const CXXThisExpr *TE, CallingContext *Ctx);\n  til::SExpr *translateMemberExpr(const MemberExpr *ME, CallingContext *Ctx);\n  til::SExpr *translateObjCIVarRefExpr(const ObjCIvarRefExpr *IVRE,\n                                       CallingContext *Ctx);\n  til::SExpr *translateCallExpr(const CallExpr *CE, CallingContext *Ctx,\n                                const Expr *SelfE = nullptr);\n  til::SExpr *translateCXXMemberCallExpr(const CXXMemberCallExpr *ME,\n                                         CallingContext *Ctx);\n  til::SExpr *translateCXXOperatorCallExpr(const CXXOperatorCallExpr *OCE,\n                                           CallingContext *Ctx);\n  til::SExpr *translateUnaryOperator(const UnaryOperator *UO,\n                                     CallingContext *Ctx);\n  til::SExpr *translateBinOp(til::TIL_BinaryOpcode Op,\n                             const BinaryOperator *BO,\n                             CallingContext *Ctx, bool Reverse = false);\n  til::SExpr *translateBinAssign(til::TIL_BinaryOpcode Op,\n                                 const BinaryOperator *BO,\n                                 CallingContext *Ctx, bool Assign = false);\n  til::SExpr *translateBinaryOperator(const BinaryOperator *BO,\n                                      CallingContext *Ctx);\n  til::SExpr *translateCastExpr(const CastExpr *CE, CallingContext *Ctx);\n  til::SExpr *translateArraySubscriptExpr(const ArraySubscriptExpr *E,\n                                          CallingContext *Ctx);\n  til::SExpr *translateAbstractConditionalOperator(\n      const AbstractConditionalOperator *C, CallingContext *Ctx);\n\n  til::SExpr *translateDeclStmt(const DeclStmt *S, CallingContext *Ctx);\n\n  // Map from statements in the clang CFG to SExprs in the til::SCFG.\n  using StatementMap = llvm::DenseMap<const Stmt *, til::SExpr *>;\n\n  // Map from clang local variables to indices in a LVarDefinitionMap.\n  using LVarIndexMap = llvm::DenseMap<const ValueDecl *, unsigned>;\n\n  // Map from local variable indices to SSA variables (or constants).\n  using NameVarPair = std::pair<const ValueDecl *, til::SExpr *>;\n  using LVarDefinitionMap = CopyOnWriteVector<NameVarPair>;\n\n  struct BlockInfo {\n    LVarDefinitionMap ExitMap;\n    bool HasBackEdges = false;\n\n    // Successors yet to be processed\n    unsigned UnprocessedSuccessors = 0;\n\n    // Predecessors already processed\n    unsigned ProcessedPredecessors = 0;\n\n    BlockInfo() = default;\n    BlockInfo(BlockInfo &&) = default;\n    BlockInfo &operator=(BlockInfo &&) = default;\n  };\n\n  void enterCFG(CFG *Cfg, const NamedDecl *D, const CFGBlock *First);\n  void enterCFGBlock(const CFGBlock *B);\n  bool visitPredecessors() { return true; }\n  void handlePredecessor(const CFGBlock *Pred);\n  void handlePredecessorBackEdge(const CFGBlock *Pred);\n  void enterCFGBlockBody(const CFGBlock *B);\n  void handleStatement(const Stmt *S);\n  void handleDestructorCall(const VarDecl *VD, const CXXDestructorDecl *DD);\n  void exitCFGBlockBody(const CFGBlock *B);\n  bool visitSuccessors() { return true; }\n  void handleSuccessor(const CFGBlock *Succ);\n  void handleSuccessorBackEdge(const CFGBlock *Succ);\n  void exitCFGBlock(const CFGBlock *B);\n  void exitCFG(const CFGBlock *Last);\n\n  void insertStmt(const Stmt *S, til::SExpr *E) {\n    SMap.insert(std::make_pair(S, E));\n  }\n\n  til::SExpr *addStatement(til::SExpr *E, const Stmt *S,\n                           const ValueDecl *VD = nullptr);\n  til::SExpr *lookupVarDecl(const ValueDecl *VD);\n  til::SExpr *addVarDecl(const ValueDecl *VD, til::SExpr *E);\n  til::SExpr *updateVarDecl(const ValueDecl *VD, til::SExpr *E);\n\n  void makePhiNodeVar(unsigned i, unsigned NPreds, til::SExpr *E);\n  void mergeEntryMap(LVarDefinitionMap Map);\n  void mergeEntryMapBackEdge();\n  void mergePhiNodesBackEdge(const CFGBlock *Blk);\n\nprivate:\n  // Set to true when parsing capability expressions, which get translated\n  // inaccurately in order to hack around smart pointers etc.\n  static const bool CapabilityExprMode = true;\n\n  til::MemRegionRef Arena;\n\n  // Variable to use for 'this'.  May be null.\n  til::Variable *SelfVar = nullptr;\n\n  til::SCFG *Scfg = nullptr;\n\n  // Map from Stmt to TIL Variables\n  StatementMap SMap;\n\n  // Indices of clang local vars.\n  LVarIndexMap LVarIdxMap;\n\n  // Map from clang to til BBs.\n  std::vector<til::BasicBlock *> BlockMap;\n\n  // Extra information per BB. Indexed by clang BlockID.\n  std::vector<BlockInfo> BBInfo;\n\n  LVarDefinitionMap CurrentLVarMap;\n  std::vector<til::Phi *> CurrentArguments;\n  std::vector<til::SExpr *> CurrentInstructions;\n  std::vector<til::Phi *> IncompleteArgs;\n  til::BasicBlock *CurrentBB = nullptr;\n  BlockInfo *CurrentBlockInfo = nullptr;\n}",
  "id": "BLOCK-CPP-21460",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h",
  "source_line": 339,
  "validation_status": "validated"
}