{
  "code": "{\npublic:\n  enum TQ { // NOTE: These flags must be kept in sync with DeclSpec::TQ.\n    Const    = 0x1,\n    Restrict = 0x2,\n    Volatile = 0x4,\n    CVRMask = Const | Volatile | Restrict\n  };\n\n  enum GC {\n    GCNone = 0,\n    Weak,\n    Strong\n  };\n\n  enum ObjCLifetime {\n    /// There is no lifetime qualification on this type.\n    OCL_None,\n\n    /// This object can be modified without requiring retains or\n    /// releases.\n    OCL_ExplicitNone,\n\n    /// Assigning into this object requires the old value to be\n    /// released and the new value to be retained.  The timing of the\n    /// release of the old value is inexact: it may be moved to\n    /// immediately after the last known point where the value is\n    /// live.\n    OCL_Strong,\n\n    /// Reading or writing from this object requires a barrier call.\n    OCL_Weak,\n\n    /// Assigning into this object requires a lifetime extension.\n    OCL_Autoreleasing\n  };\n\n  enum {\n    /// The maximum supported address space number.\n    /// 23 bits should be enough for anyone.\n    MaxAddressSpace = 0x7fffffu,\n\n    /// The width of the \"fast\" qualifier mask.\n    FastWidth = 3,\n\n    /// The fast qualifier mask.\n    FastMask = (1 << FastWidth) - 1\n  };\n\n  /// Returns the common set of qualifiers while removing them from\n  /// the given sets.\n  static Qualifiers removeCommonQualifiers(Qualifiers &L, Qualifiers &R) {\n    // If both are only CVR-qualified, bit operations are sufficient.\n    if (!(L.Mask & ~CVRMask) && !(R.Mask & ~CVRMask)) {\n      Qualifiers Q;\n      Q.Mask = L.Mask & R.Mask;\n      L.Mask &= ~Q.Mask;\n      R.Mask &= ~Q.Mask;\n      return Q;\n    }\n\n    Qualifiers Q;\n    unsigned CommonCRV = L.getCVRQualifiers() & R.getCVRQualifiers();\n    Q.addCVRQualifiers(CommonCRV);\n    L.removeCVRQualifiers(CommonCRV);\n    R.removeCVRQualifiers(CommonCRV);\n\n    if (L.getObjCGCAttr() == R.getObjCGCAttr()) {\n      Q.setObjCGCAttr(L.getObjCGCAttr());\n      L.removeObjCGCAttr();\n      R.removeObjCGCAttr();\n    }\n\n    if (L.getObjCLifetime() == R.getObjCLifetime()) {\n      Q.setObjCLifetime(L.getObjCLifetime());\n      L.removeObjCLifetime();\n      R.removeObjCLifetime();\n    }\n\n    if (L.getAddressSpace() == R.getAddressSpace()) {\n      Q.setAddressSpace(L.getAddressSpace());\n      L.removeAddressSpace();\n      R.removeAddressSpace();\n    }\n    return Q;\n  }\n\n  static Qualifiers fromFastMask(unsigned Mask) {\n    Qualifiers Qs;\n    Qs.addFastQualifiers(Mask);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRMask(unsigned CVR) {\n    Qualifiers Qs;\n    Qs.addCVRQualifiers(CVR);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRUMask(unsigned CVRU) {\n    Qualifiers Qs;\n    Qs.addCVRUQualifiers(CVRU);\n    return Qs;\n  }\n\n  // Deserialize qualifiers from an opaque representation.\n  static Qualifiers fromOpaqueValue(unsigned opaque) {\n    Qualifiers Qs;\n    Qs.Mask = opaque;\n    return Qs;\n  }\n\n  // Serialize these qualifiers into an opaque representation.\n  unsigned getAsOpaqueValue() const {\n    return Mask;\n  }\n\n  bool hasConst() const { return Mask & Const; }\n  bool hasOnlyConst() const { return Mask == Const; }\n  void removeConst() { Mask &= ~Const; }\n  void addConst() { Mask |= Const; }\n  Qualifiers withConst() const {\n    Qualifiers Qs = *this;\n    Qs.addConst();\n    return Qs;\n  }\n\n  bool hasVolatile() const { return Mask & Volatile; }\n  bool hasOnlyVolatile() const { return Mask == Volatile; }\n  void removeVolatile() { Mask &= ~Volatile; }\n  void addVolatile() { Mask |= Volatile; }\n  Qualifiers withVolatile() const {\n    Qualifiers Qs = *this;\n    Qs.addVolatile();\n    return Qs;\n  }\n\n  bool hasRestrict() const { return Mask & Restrict; }\n  bool hasOnlyRestrict() const { return Mask == Restrict; }\n  void removeRestrict() { Mask &= ~Restrict; }\n  void addRestrict() { Mask |= Restrict; }\n  Qualifiers withRestrict() const {\n    Qualifiers Qs = *this;\n    Qs.addRestrict();\n    return Qs;\n  }\n\n  bool hasCVRQualifiers() const { return getCVRQualifiers(); }\n  unsigned getCVRQualifiers() const { return Mask & CVRMask; }\n  unsigned getCVRUQualifiers() const { return Mask & (CVRMask | UMask); }\n\n  void setCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask = (Mask & ~CVRMask) | mask;\n  }\n  void removeCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask &= ~mask;\n  }\n  void removeCVRQualifiers() {\n    removeCVRQualifiers(CVRMask);\n  }\n  void addCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask |= mask;\n  }\n  void addCVRUQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask & ~UMask) && \"bitmask contains non-CVRU bits\");\n    Mask |= mask;\n  }\n\n  bool hasUnaligned() const { return Mask & UMask; }\n  void setUnaligned(bool flag) {\n    Mask = (Mask & ~UMask) | (flag ? UMask : 0);\n  }\n  void removeUnaligned() { Mask &= ~UMask; }\n  void addUnaligned() { Mask |= UMask; }\n\n  bool hasObjCGCAttr() const { return Mask & GCAttrMask; }\n  GC getObjCGCAttr() const { return GC((Mask & GCAttrMask) >> GCAttrShift); }\n  void setObjCGCAttr(GC type) {\n    Mask = (Mask & ~GCAttrMask) | (type << GCAttrShift);\n  }\n  void removeObjCGCAttr() { setObjCGCAttr(GCNone); }\n  void addObjCGCAttr(GC type) {\n    assert(type);\n    setObjCGCAttr(type);\n  }\n  Qualifiers withoutObjCGCAttr() const {\n    Qualifiers qs = *this;\n    qs.removeObjCGCAttr();\n    return qs;\n  }\n  Qualifiers withoutObjCLifetime() const {\n    Qualifiers qs = *this;\n    qs.removeObjCLifetime();\n    return qs;\n  }\n  Qualifiers withoutAddressSpace() const {\n    Qualifiers qs = *this;\n    qs.removeAddressSpace();\n    return qs;\n  }\n\n  bool hasObjCLifetime() const { return Mask & LifetimeMask; }\n  ObjCLifetime getObjCLifetime() const {\n    return ObjCLifetime((Mask & LifetimeMask) >> LifetimeShift);\n  }\n  void setObjCLifetime(ObjCLifetime type) {\n    Mask = (Mask & ~LifetimeMask) | (type << LifetimeShift);\n  }\n  void removeObjCLifetime() { setObjCLifetime(OCL_None); }\n  void addObjCLifetime(ObjCLifetime type) {\n    assert(type);\n    assert(!hasObjCLifetime());\n    Mask |= (type << LifetimeShift);\n  }\n\n  /// True if the lifetime is neither None or ExplicitNone.\n  bool hasNonTrivialObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime > OCL_ExplicitNone);\n  }\n\n  /// True if the lifetime is either strong or weak.\n  bool hasStrongOrWeakObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime == OCL_Strong || lifetime == OCL_Weak);\n  }\n\n  bool hasAddressSpace() const { return Mask & AddressSpaceMask; }\n  LangAS getAddressSpace() const {\n    return static_cast<LangAS>(Mask >> AddressSpaceShift);\n  }\n  bool hasTargetSpecificAddressSpace() const {\n    return isTargetAddressSpace(getAddressSpace());\n  }\n  /// Get the address space attribute value to be printed by diagnostics.\n  unsigned getAddressSpaceAttributePrintValue() const {\n    auto Addr = getAddressSpace();\n    // This function is not supposed to be used with language specific\n    // address spaces. If that happens, the diagnostic message should consider\n    // printing the QualType instead of the address space value.\n    assert(Addr == LangAS::Default || hasTargetSpecificAddressSpace());\n    if (Addr != LangAS::Default)\n      return toTargetAddressSpace(Addr);\n    // TODO: The diagnostic messages where Addr may be 0 should be fixed\n    // since it cannot differentiate the situation where 0 denotes the default\n    // address space or user specified __attribute__((address_space(0))).\n    return 0;\n  }\n  void setAddressSpace(LangAS space) {\n    assert((unsigned)space <= MaxAddressSpace);\n    Mask = (Mask & ~AddressSpaceMask)\n         | (((uint32_t) space) << AddressSpaceShift);\n  }\n  void removeAddressSpace() { setAddressSpace(LangAS::Default); }\n  void addAddressSpace(LangAS space) {\n    assert(space != LangAS::Default);\n    setAddressSpace(space);\n  }\n\n  // Fast qualifiers are those that can be allocated directly\n  // on a QualType object.\n  bool hasFastQualifiers() const { return getFastQualifiers(); }\n  unsigned getFastQualifiers() const { return Mask & FastMask; }\n  void setFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask = (Mask & ~FastMask) | mask;\n  }\n  void removeFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask &= ~mask;\n  }\n  void removeFastQualifiers() {\n    removeFastQualifiers(FastMask);\n  }\n  void addFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask |= mask;\n  }\n\n  /// Return true if the set contains any qualifiers which require an ExtQuals\n  /// node to be allocated.\n  bool hasNonFastQualifiers() const { return Mask & ~FastMask; }\n  Qualifiers getNonFastQualifiers() const {\n    Qualifiers Quals = *this;\n    Quals.setFastQualifiers(0);\n    return Quals;\n  }\n\n  /// Return true if the set contains any qualifiers.\n  bool hasQualifiers() const { return Mask; }\n  bool empty() const { return !Mask; }\n\n  /// Add the qualifiers from the given set to this set.\n  void addQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-or it in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask |= Q.Mask;\n    else {\n      Mask |= (Q.Mask & CVRMask);\n      if (Q.hasAddressSpace())\n        addAddressSpace(Q.getAddressSpace());\n      if (Q.hasObjCGCAttr())\n        addObjCGCAttr(Q.getObjCGCAttr());\n      if (Q.hasObjCLifetime())\n        addObjCLifetime(Q.getObjCLifetime());\n    }\n  }\n\n  /// Remove the qualifiers from the given set from this set.\n  void removeQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-and the inverse in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask &= ~Q.Mask;\n    else {\n      Mask &= ~(Q.Mask & CVRMask);\n      if (getObjCGCAttr() == Q.getObjCGCAttr())\n        removeObjCGCAttr();\n      if (getObjCLifetime() == Q.getObjCLifetime())\n        removeObjCLifetime();\n      if (getAddressSpace() == Q.getAddressSpace())\n        removeAddressSpace();\n    }\n  }\n\n  /// Add the qualifiers from the given set to this set, given that\n  /// they don't conflict.\n  void addConsistentQualifiers(Qualifiers qs) {\n    assert(getAddressSpace() == qs.getAddressSpace() ||\n           !hasAddressSpace() || !qs.hasAddressSpace());\n    assert(getObjCGCAttr() == qs.getObjCGCAttr() ||\n           !hasObjCGCAttr() || !qs.hasObjCGCAttr());\n    assert(getObjCLifetime() == qs.getObjCLifetime() ||\n           !hasObjCLifetime() || !qs.hasObjCLifetime());\n    Mask |= qs.Mask;\n  }\n\n  /// Returns true if address space A is equal to or a superset of B.\n  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion of\n  /// overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   every address space is a superset of itself.\n  /// CL2.0 adds:\n  ///   __generic is a superset of any address space except for __constant.\n  static bool isAddressSpaceSupersetOf(LangAS A, LangAS B) {\n    // Address spaces must match exactly.\n    return A == B ||\n           // Otherwise in OpenCLC v2.0 s6.5.5: every address space except\n           // for __constant can be used as __generic.\n           (A == LangAS::opencl_generic && B != LangAS::opencl_constant) ||\n           // We also define global_device and global_host address spaces,\n           // to distinguish global pointers allocated on host from pointers\n           // allocated on device, which are a subset of __global.\n           (A == LangAS::opencl_global && (B == LangAS::opencl_global_device ||\n                                           B == LangAS::opencl_global_host)) ||\n           (A == LangAS::sycl_global && (B == LangAS::sycl_global_device ||\n                                         B == LangAS::sycl_global_host)) ||\n           // Consider pointer size address spaces to be equivalent to default.\n           ((isPtrSizeAddressSpace(A) || A == LangAS::Default) &&\n            (isPtrSizeAddressSpace(B) || B == LangAS::Default)) ||\n           // Default is a superset of SYCL address spaces.\n           (A == LangAS::Default &&\n            (B == LangAS::sycl_private || B == LangAS::sycl_local ||\n             B == LangAS::sycl_global || B == LangAS::sycl_global_device ||\n             B == LangAS::sycl_global_host)) ||\n           // In HIP device compilation, any cuda address space is allowed\n           // to implicitly cast into the default address space.\n           (A == LangAS::Default &&\n            (B == LangAS::cuda_constant || B == LangAS::cuda_device ||\n             B == LangAS::cuda_shared));\n  }\n\n  /// Returns true if the address space in these qualifiers is equal to or\n  /// a superset of the address space in the argument qualifiers.\n  bool isAddressSpaceSupersetOf(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(getAddressSpace(), other.getAddressSpace());\n  }\n\n  /// Determines if these qualifiers compatibly include another set.\n  /// Generally this answers the question of whether an object with the other\n  /// qualifiers can be safely used as an object with these qualifiers.\n  bool compatiblyIncludes(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(other) &&\n           // ObjC GC qualifiers can match, be added, or be removed, but can't\n           // be changed.\n           (getObjCGCAttr() == other.getObjCGCAttr() || !hasObjCGCAttr() ||\n            !other.hasObjCGCAttr()) &&\n           // ObjC lifetime qualifiers must match exactly.\n           getObjCLifetime() == other.getObjCLifetime() &&\n           // CVR qualifiers may subset.\n           (((Mask & CVRMask) | (other.Mask & CVRMask)) == (Mask & CVRMask)) &&\n           // U qualifier may superset.\n           (!other.hasUnaligned() || hasUnaligned());\n  }\n\n  /// Determines if these qualifiers compatibly include another set of\n  /// qualifiers from the narrow perspective of Objective-C ARC lifetime.\n  ///\n  /// One set of Objective-C lifetime qualifiers compatibly includes the other\n  /// if the lifetime qualifiers match, or if both are non-__weak and the\n  /// including set also contains the 'const' qualifier, or both are non-__weak\n  /// and one is None (which can only happen in non-ARC modes).\n  bool compatiblyIncludesObjCLifetime(Qualifiers other) const {\n    if (getObjCLifetime() == other.getObjCLifetime())\n      return true;\n\n    if (getObjCLifetime() == OCL_Weak || other.getObjCLifetime() == OCL_Weak)\n      return false;\n\n    if (getObjCLifetime() == OCL_None || other.getObjCLifetime() == OCL_None)\n      return true;\n\n    return hasConst();\n  }\n\n  /// Determine whether this set of qualifiers is a strict superset of\n  /// another set of qualifiers, not considering qualifier compatibility.\n  bool isStrictSupersetOf(Qualifiers Other) const;\n\n  bool operator==(Qualifiers Other) const { return Mask == Other.Mask; }\n  bool operator!=(Qualifiers Other) const { return Mask != Other.Mask; }\n\n  explicit operator bool() const { return hasQualifiers(); }\n\n  Qualifiers &operator+=(Qualifiers R) {\n    addQualifiers(R);\n    return *this;\n  }\n\n  // Union two qualifier sets.  If an enumerated qualifier appears\n  // in both sets, use the one from the right.\n  friend Qualifiers operator+(Qualifiers L, Qualifiers R) {\n    L += R;\n    return L;\n  }\n\n  Qualifiers &operator-=(Qualifiers R) {\n    removeQualifiers(R);\n    return *this;\n  }\n\n  /// Compute the difference between two qualifier sets.\n  friend Qualifiers operator-(Qualifiers L, Qualifiers R) {\n    L -= R;\n    return L;\n  }\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  static std::string getAddrSpaceAsString(LangAS AS);\n\n  bool isEmptyWhenPrinted(const PrintingPolicy &Policy) const;\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool appendSpaceIfNonEmpty = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger(Mask);\n  }\n\nprivate:\n  // bits:     |0 1 2|3|4 .. 5|6  ..  8|9   ...   31|\n  //           |C R V|U|GCAttr|Lifetime|AddressSpace|\n  uint32_t Mask = 0;\n\n  static const uint32_t UMask = 0x8;\n  static const uint32_t UShift = 3;\n  static const uint32_t GCAttrMask = 0x30;\n  static const uint32_t GCAttrShift = 4;\n  static const uint32_t LifetimeMask = 0x1C0;\n  static const uint32_t LifetimeShift = 6;\n  static const uint32_t AddressSpaceMask =\n      ~(CVRMask | UMask | GCAttrMask | LifetimeMask);\n  static const uint32_t AddressSpaceShift = 9;\n}",
  "id": "BLOCK-CPP-14099",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Type.h",
  "source_line": 146,
  "validation_status": "validated"
}