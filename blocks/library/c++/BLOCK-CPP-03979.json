{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace ascii_internal {\n\n// Declaration for an array of bitfields holding character information.\nABSL_DLL extern const unsigned char kPropertyBits[256];\n\n// Declaration for the array of characters to upper-case characters.\nABSL_DLL extern const char kToUpper[256];\n\n// Declaration for the array of characters to lower-case characters.\nABSL_DLL extern const char kToLower[256];\n\n}  // namespace ascii_internal\n\n// ascii_isalpha()\n//\n// Determines whether the given character is an alphabetic character.\ninline bool ascii_isalpha(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x01) != 0;\n}\n\n// ascii_isalnum()\n//\n// Determines whether the given character is an alphanumeric character.\ninline bool ascii_isalnum(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x04) != 0;\n}\n\n// ascii_isspace()\n//\n// Determines whether the given character is a whitespace character (space,\n// tab, vertical tab, formfeed, linefeed, or carriage return).\ninline bool ascii_isspace(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x08) != 0;\n}\n\n// ascii_ispunct()\n//\n// Determines whether the given character is a punctuation character.\ninline bool ascii_ispunct(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x10) != 0;\n}\n\n// ascii_isblank()\n//\n// Determines whether the given character is a blank character (tab or space).\ninline bool ascii_isblank(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x20) != 0;\n}\n\n// ascii_iscntrl()\n//\n// Determines whether the given character is a control character.\ninline bool ascii_iscntrl(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x40) != 0;\n}\n\n// ascii_isxdigit()\n//\n// Determines whether the given character can be represented as a hexadecimal\n// digit character (i.e. {0-9} or {A-F}).\ninline bool ascii_isxdigit(unsigned char c) {\n  return (ascii_internal::kPropertyBits[c] & 0x80) != 0;\n}\n\n// ascii_isdigit()\n//\n// Determines whether the given character can be represented as a decimal\n// digit character (i.e. {0-9}).\ninline bool ascii_isdigit(unsigned char c) { return c >= '0' && c <= '9'; }\n\n// ascii_isprint()\n//\n// Determines whether the given character is printable, including spaces.\ninline bool ascii_isprint(unsigned char c) { return c >= 32 && c < 127; }\n\n// ascii_isgraph()\n//\n// Determines whether the given character has a graphical representation.\ninline bool ascii_isgraph(unsigned char c) { return c > 32 && c < 127; }\n\n// ascii_isupper()\n//\n// Determines whether the given character is uppercase.\ninline bool ascii_isupper(unsigned char c) { return c >= 'A' && c <= 'Z'; }\n\n// ascii_islower()\n//\n// Determines whether the given character is lowercase.\ninline bool ascii_islower(unsigned char c) { return c >= 'a' && c <= 'z'; }\n\n// ascii_isascii()\n//\n// Determines whether the given character is ASCII.\ninline bool ascii_isascii(unsigned char c) { return c < 128; }\n\n// ascii_tolower()\n//\n// Returns an ASCII character, converting to lowercase if uppercase is\n// passed. Note that character values > 127 are simply returned.\ninline char ascii_tolower(unsigned char c) {\n  return ascii_internal::kToLower[c];\n}\n\n// Converts the characters in `s` to lowercase, changing the contents of `s`.\nvoid AsciiStrToLower(absl::Nonnull<std::string*> s);\n\n// Creates a lowercase string from a given absl::string_view.\nABSL_MUST_USE_RESULT inline std::string AsciiStrToLower(absl::string_view s) {\n  std::string result(s);\n  absl::AsciiStrToLower(&result);\n  return result;\n}\n\n// ascii_toupper()\n//\n// Returns the ASCII character, converting to upper-case if lower-case is\n// passed. Note that characters values > 127 are simply returned.\ninline char ascii_toupper(unsigned char c) {\n  return ascii_internal::kToUpper[c];\n}\n\n// Converts the characters in `s` to uppercase, changing the contents of `s`.\nvoid AsciiStrToUpper(absl::Nonnull<std::string*> s);\n\n// Creates an uppercase string from a given absl::string_view.\nABSL_MUST_USE_RESULT inline std::string AsciiStrToUpper(absl::string_view s) {\n  std::string result(s);\n  absl::AsciiStrToUpper(&result);\n  return result;\n}\n\n// Returns absl::string_view with whitespace stripped from the beginning of the\n// given string_view.\nABSL_MUST_USE_RESULT inline absl::string_view StripLeadingAsciiWhitespace(\n    absl::string_view str) {\n  auto it = std::find_if_not(str.begin(), str.end(), absl::ascii_isspace);\n  return str.substr(static_cast<size_t>(it - str.begin()));\n}\n\n// Strips in place whitespace from the beginning of the given string.\ninline void StripLeadingAsciiWhitespace(absl::Nonnull<std::string*> str) {\n  auto it = std::find_if_not(str->begin(), str->end(), absl::ascii_isspace);\n  str->erase(str->begin(), it);\n}\n\n// Returns absl::string_view with whitespace stripped from the end of the given\n// string_view.\nABSL_MUST_USE_RESULT inline absl::string_view StripTrailingAsciiWhitespace(\n    absl::string_view str) {\n  auto it = std::find_if_not(str.rbegin(), str.rend(), absl::ascii_isspace);\n  return str.substr(0, static_cast<size_t>(str.rend() - it));\n}\n\n// Strips in place whitespace from the end of the given string\ninline void StripTrailingAsciiWhitespace(absl::Nonnull<std::string*> str) {\n  auto it = std::find_if_not(str->rbegin(), str->rend(), absl::ascii_isspace);\n  str->erase(static_cast<size_t>(str->rend() - it));\n}\n\n// Returns absl::string_view with whitespace stripped from both ends of the\n// given string_view.\nABSL_MUST_USE_RESULT inline absl::string_view StripAsciiWhitespace(\n    absl::string_view str) {\n  return StripTrailingAsciiWhitespace(StripLeadingAsciiWhitespace(str));\n}\n\n// Strips in place whitespace from both ends of the given string\ninline void StripAsciiWhitespace(absl::Nonnull<std::string*> str) {\n  StripTrailingAsciiWhitespace(str);\n  StripLeadingAsciiWhitespace(str);\n}\n\n// Removes leading, trailing, and consecutive internal whitespace.\nvoid RemoveExtraAsciiWhitespace(absl::Nonnull<std::string*> str);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03979",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/ascii.h",
  "source_line": 64,
  "validation_status": "validated"
}