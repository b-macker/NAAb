{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/synchronization/internal/kernel_timeout.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06488_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n// `Waiter` is a platform specific semaphore implementation that `PerThreadSem`\n// waits on to implement blocking in `absl::Mutex`.  Implementations should\n// inherit from `WaiterCrtp` and must implement `Wait()`, `Post()`, and `Poke()`\n// as described in `WaiterBase`.  `waiter.h` selects the implementation and uses\n// static-dispatch for performance.\nclass WaiterBase {\n public:\n  WaiterBase() = default;\n\n  // Not copyable or movable\n  WaiterBase(const WaiterBase&) = delete;\n  WaiterBase& operator=(const WaiterBase&) = delete;\n\n  // Blocks the calling thread until a matching call to `Post()` or\n  // `t` has passed. Returns `true` if woken (`Post()` called),\n  // `false` on timeout.\n  //\n  // bool Wait(KernelTimeout t);\n\n  // Restart the caller of `Wait()` as with a normal semaphore.\n  //\n  // void Post();\n\n  // If anyone is waiting, wake them up temporarily and cause them to\n  // call `MaybeBecomeIdle()`. They will then return to waiting for a\n  // `Post()` or timeout.\n  //\n  // void Poke();\n\n  // Returns the name of this implementation. Used only for debugging.\n  //\n  // static constexpr char kName[];\n\n  // How many periods to remain idle before releasing resources\n#ifndef ABSL_HAVE_THREAD_SANITIZER\n  static constexpr int kIdlePeriods = 60;\n#else\n  // Memory consumption under ThreadSanitizer is a serious concern,\n  // so we release resources sooner. The value of 1 leads to 1 to 2 second\n  // delay before marking a thread as idle.\n  static constexpr int kIdlePeriods = 1;\n#endif\n\n protected:\n  static void MaybeBecomeIdle();\n};\n\ntemplate <typename T>\nclass WaiterCrtp : public WaiterBase {\n public:\n  // Returns the Waiter associated with the identity.\n  static T* GetWaiter(base_internal::ThreadIdentity* identity) {\n    static_assert(\n        sizeof(T) <= sizeof(base_internal::ThreadIdentity::WaiterState),\n        \"Insufficient space for Waiter\");\n    return reinterpret_cast<T*>(identity->waiter_state.data);\n  }\n};\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06488",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/waiter_base.h",
  "source_line": 23,
  "validation_status": "validated"
}