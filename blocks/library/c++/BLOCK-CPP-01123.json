{
  "code": "{\n private:\n  // In the future basic_format_parse_context will replace compile_parse_context\n  // here and will use is_constant_evaluated and downcasting to access the data\n  // needed for compile-time checks: https://godbolt.org/z/GvWzcTjh1.\n  using parse_context_type = compile_parse_context<Char, ErrorHandler>;\n  static constexpr int num_args = sizeof...(Args);\n\n  // Format specifier parsing function.\n  using parse_func = const Char* (*)(parse_context_type&);\n\n  parse_context_type context_;\n  parse_func parse_funcs_[num_args > 0 ? static_cast<size_t>(num_args) : 1];\n  type types_[num_args > 0 ? static_cast<size_t>(num_args) : 1];\n\n public:\n  explicit FMT_CONSTEXPR format_string_checker(\n      basic_string_view<Char> format_str, ErrorHandler eh)\n      : context_(format_str, num_args, types_, eh),\n        parse_funcs_{&parse_format_specs<Args, parse_context_type>...},\n        types_{\n            mapped_type_constant<Args,\n                                 basic_format_context<Char*, Char>>::value...} {\n  }\n\n  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}\n\n  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }\n  FMT_CONSTEXPR auto on_arg_id(int id) -> int {\n    return context_.check_arg_id(id), id;\n  }\n  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {\n#if FMT_USE_NONTYPE_TEMPLATE_ARGS\n    auto index = get_arg_index_by_name<Args...>(id);\n    if (index == invalid_arg_index) on_error(\"named argument is not found\");\n    return context_.check_arg_id(index), index;\n#else\n    (void)id;\n    on_error(\"compile-time checks for named arguments require C++20 support\");\n    return 0;\n#endif\n  }\n\n  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}\n\n  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char*)\n      -> const Char* {\n    context_.advance_to(context_.begin() + (begin - &*context_.begin()));\n    // id >= 0 check is a workaround for gcc 10 bug (#2065).\n    return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;\n  }\n\n  FMT_CONSTEXPR void on_error(const char* message) {\n    context_.on_error(message);\n  }\n}",
  "id": "BLOCK-CPP-01123",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/core.h",
  "source_line": 2934,
  "validation_status": "validated"
}