{
  "code": "{\n  DiagnosticsEngine &Diags;\n\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS;\n\n  enum DriverMode {\n    GCCMode,\n    GXXMode,\n    CPPMode,\n    CLMode,\n    FlangMode,\n    DXCMode\n  } Mode;\n\n  enum SaveTempsMode {\n    SaveTempsNone,\n    SaveTempsCwd,\n    SaveTempsObj\n  } SaveTemps;\n\n  enum BitcodeEmbedMode {\n    EmbedNone,\n    EmbedMarker,\n    EmbedBitcode\n  } BitcodeEmbed;\n\n  enum OffloadMode {\n    OffloadHostDevice,\n    OffloadHost,\n    OffloadDevice,\n  } Offload;\n\n  /// Header unit mode set by -fmodule-header={user,system}.\n  ModuleHeaderMode CXX20HeaderType;\n\n  /// Set if we should process inputs and jobs with C++20 module\n  /// interpretation.\n  bool ModulesModeCXX20;\n\n  /// LTO mode selected via -f(no-)?lto(=.*)? options.\n  LTOKind LTOMode;\n\n  /// LTO mode selected via -f(no-offload-)?lto(=.*)? options.\n  LTOKind OffloadLTOMode;\n\npublic:\n  enum OpenMPRuntimeKind {\n    /// An unknown OpenMP runtime. We can't generate effective OpenMP code\n    /// without knowing what runtime to target.\n    OMPRT_Unknown,\n\n    /// The LLVM OpenMP runtime. When completed and integrated, this will become\n    /// the default for Clang.\n    OMPRT_OMP,\n\n    /// The GNU OpenMP runtime. Clang doesn't support generating OpenMP code for\n    /// this runtime but can swallow the pragmas, and find and link against the\n    /// runtime library itself.\n    OMPRT_GOMP,\n\n    /// The legacy name for the LLVM OpenMP runtime from when it was the Intel\n    /// OpenMP runtime. We support this mode for users with existing\n    /// dependencies on this runtime library name.\n    OMPRT_IOMP5\n  };\n\n  // Diag - Forwarding function for diagnostics.\n  DiagnosticBuilder Diag(unsigned DiagID) const {\n    return Diags.Report(DiagID);\n  }\n\n  // FIXME: Privatize once interface is stable.\npublic:\n  /// The name the driver was invoked as.\n  std::string Name;\n\n  /// The path the driver executable was in, as invoked from the\n  /// command line.\n  std::string Dir;\n\n  /// The original path to the clang executable.\n  std::string ClangExecutable;\n\n  /// Target and driver mode components extracted from clang executable name.\n  ParsedClangName ClangNameParts;\n\n  /// The path to the installed clang directory, if any.\n  std::string InstalledDir;\n\n  /// The path to the compiler resource directory.\n  std::string ResourceDir;\n\n  /// System directory for config files.\n  std::string SystemConfigDir;\n\n  /// User directory for config files.\n  std::string UserConfigDir;\n\n  /// A prefix directory used to emulate a limited subset of GCC's '-Bprefix'\n  /// functionality.\n  /// FIXME: This type of customization should be removed in favor of the\n  /// universal driver when it is ready.\n  typedef SmallVector<std::string, 4> prefix_list;\n  prefix_list PrefixDirs;\n\n  /// sysroot, if present\n  std::string SysRoot;\n\n  /// Dynamic loader prefix, if present\n  std::string DyldPrefix;\n\n  /// Driver title to use with help.\n  std::string DriverTitle;\n\n  /// Information about the host which can be overridden by the user.\n  std::string HostBits, HostMachine, HostSystem, HostRelease;\n\n  /// The file to log CC_PRINT_PROC_STAT_FILE output to, if enabled.\n  std::string CCPrintStatReportFilename;\n\n  /// The file to log CC_PRINT_INTERNAL_STAT_FILE output to, if enabled.\n  std::string CCPrintInternalStatReportFilename;\n\n  /// The file to log CC_PRINT_OPTIONS output to, if enabled.\n  std::string CCPrintOptionsFilename;\n\n  /// The file to log CC_PRINT_HEADERS output to, if enabled.\n  std::string CCPrintHeadersFilename;\n\n  /// The file to log CC_LOG_DIAGNOSTICS output to, if enabled.\n  std::string CCLogDiagnosticsFilename;\n\n  /// An input type and its arguments.\n  using InputTy = std::pair<types::ID, const llvm::opt::Arg *>;\n\n  /// A list of inputs and their types for the given arguments.\n  using InputList = SmallVector<InputTy, 16>;\n\n  /// Whether the driver should follow g++ like behavior.\n  bool CCCIsCXX() const { return Mode == GXXMode; }\n\n  /// Whether the driver is just the preprocessor.\n  bool CCCIsCPP() const { return Mode == CPPMode; }\n\n  /// Whether the driver should follow gcc like behavior.\n  bool CCCIsCC() const { return Mode == GCCMode; }\n\n  /// Whether the driver should follow cl.exe like behavior.\n  bool IsCLMode() const { return Mode == CLMode; }\n\n  /// Whether the driver should invoke flang for fortran inputs.\n  /// Other modes fall back to calling gcc which in turn calls gfortran.\n  bool IsFlangMode() const { return Mode == FlangMode; }\n\n  /// Whether the driver should follow dxc.exe like behavior.\n  bool IsDXCMode() const { return Mode == DXCMode; }\n\n  /// Only print tool bindings, don't build any jobs.\n  unsigned CCCPrintBindings : 1;\n\n  /// Set CC_PRINT_OPTIONS mode, which is like -v but logs the commands to\n  /// CCPrintOptionsFilename or to stderr.\n  unsigned CCPrintOptions : 1;\n\n  /// The format of the header information that is emitted. If CC_PRINT_HEADERS\n  /// is set, the format is textual. Otherwise, the format is determined by the\n  /// enviroment variable CC_PRINT_HEADERS_FORMAT.\n  HeaderIncludeFormatKind CCPrintHeadersFormat = HIFMT_None;\n\n  /// This flag determines whether clang should filter the header information\n  /// that is emitted. If enviroment variable CC_PRINT_HEADERS_FILTERING is set\n  /// to \"only-direct-system\", only system headers that are directly included\n  /// from non-system headers are emitted.\n  HeaderIncludeFilteringKind CCPrintHeadersFiltering = HIFIL_None;\n\n  /// Set CC_LOG_DIAGNOSTICS mode, which causes the frontend to log diagnostics\n  /// to CCLogDiagnosticsFilename or to stderr, in a stable machine readable\n  /// format.\n  unsigned CCLogDiagnostics : 1;\n\n  /// Whether the driver is generating diagnostics for debugging purposes.\n  unsigned CCGenDiagnostics : 1;\n\n  /// Set CC_PRINT_PROC_STAT mode, which causes the driver to dump\n  /// performance report to CC_PRINT_PROC_STAT_FILE or to stdout.\n  unsigned CCPrintProcessStats : 1;\n\n  /// Set CC_PRINT_INTERNAL_STAT mode, which causes the driver to dump internal\n  /// performance report to CC_PRINT_INTERNAL_STAT_FILE or to stdout.\n  unsigned CCPrintInternalStats : 1;\n\n  /// Pointer to the ExecuteCC1Tool function, if available.\n  /// When the clangDriver lib is used through clang.exe, this provides a\n  /// shortcut for executing the -cc1 command-line directly, in the same\n  /// process.\n  using CC1ToolFunc =\n      llvm::function_ref<int(SmallVectorImpl<const char *> &ArgV)>;\n  CC1ToolFunc CC1Main = nullptr;\n\nprivate:\n  /// Raw target triple.\n  std::string TargetTriple;\n\n  /// Name to use when invoking gcc/g++.\n  std::string CCCGenericGCCName;\n\n  /// Paths to configuration files used.\n  std::vector<std::string> ConfigFiles;\n\n  /// Allocator for string saver.\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Object that stores strings read from configuration file.\n  llvm::StringSaver Saver;\n\n  /// Arguments originated from configuration file.\n  std::unique_ptr<llvm::opt::InputArgList> CfgOptions;\n\n  /// Arguments originated from command line.\n  std::unique_ptr<llvm::opt::InputArgList> CLOptions;\n\n  /// If this is non-null, the driver will prepend this argument before\n  /// reinvoking clang. This is useful for the llvm-driver where clang's\n  /// realpath will be to the llvm binary and not clang, so it must pass\n  /// \"clang\" as it's first argument.\n  const char *PrependArg;\n\n  /// Whether to check that input files exist when constructing compilation\n  /// jobs.\n  unsigned CheckInputsExist : 1;\n  /// Whether to probe for PCH files on disk, in order to upgrade\n  /// -include foo.h to -include-pch foo.h.pch.\n  unsigned ProbePrecompiled : 1;\n\npublic:\n  // getFinalPhase - Determine which compilation mode we are in and record\n  // which option we used to determine the final phase.\n  // TODO: Much of what getFinalPhase returns are not actually true compiler\n  //       modes. Fold this functionality into Types::getCompilationPhases and\n  //       handleArguments.\n  phases::ID getFinalPhase(const llvm::opt::DerivedArgList &DAL,\n                           llvm::opt::Arg **FinalPhaseArg = nullptr) const;\n\nprivate:\n  /// Certain options suppress the 'no input files' warning.\n  unsigned SuppressMissingInputWarning : 1;\n\n  /// Cache of all the ToolChains in use by the driver.\n  ///\n  /// This maps from the string representation of a triple to a ToolChain\n  /// created targeting that triple. The driver owns all the ToolChain objects\n  /// stored in it, and will clean them up when torn down.\n  mutable llvm::StringMap<std::unique_ptr<ToolChain>> ToolChains;\n\n  /// Cache of known offloading architectures for the ToolChain already derived.\n  /// This should only be modified when we first initialize the offloading\n  /// toolchains.\n  llvm::DenseMap<const ToolChain *, llvm::DenseSet<llvm::StringRef>> KnownArchs;\n\nprivate:\n  /// TranslateInputArgs - Create a new derived argument list from the input\n  /// arguments, after applying the standard argument translations.\n  llvm::opt::DerivedArgList *\n  TranslateInputArgs(const llvm::opt::InputArgList &Args) const;\n\n  // handleArguments - All code related to claiming and printing diagnostics\n  // related to arguments to the driver are done here.\n  void handleArguments(Compilation &C, llvm::opt::DerivedArgList &Args,\n                       const InputList &Inputs, ActionList &Actions) const;\n\n  // Before executing jobs, sets up response files for commands that need them.\n  void setUpResponseFiles(Compilation &C, Command &Cmd);\n\n  void generatePrefixedToolNames(StringRef Tool, const ToolChain &TC,\n                                 SmallVectorImpl<std::string> &Names) const;\n\n  /// Find the appropriate .crash diagonostic file for the child crash\n  /// under this driver and copy it out to a temporary destination with the\n  /// other reproducer related files (.sh, .cache, etc). If not found, suggest a\n  /// directory for the user to look at.\n  ///\n  /// \\param ReproCrashFilename The file path to copy the .crash to.\n  /// \\param CrashDiagDir       The suggested directory for the user to look at\n  ///                           in case the search or copy fails.\n  ///\n  /// \\returns If the .crash is found and successfully copied return true,\n  /// otherwise false and return the suggested directory in \\p CrashDiagDir.\n  bool getCrashDiagnosticFile(StringRef ReproCrashFilename,\n                              SmallString<128> &CrashDiagDir);\n\npublic:\n\n  /// Takes the path to a binary that's either in bin/ or lib/ and returns\n  /// the path to clang's resource directory.\n  static std::string GetResourcesPath(StringRef BinaryPath,\n                                      StringRef CustomResourceDir = \"\");\n\n  Driver(StringRef ClangExecutable, StringRef TargetTriple,\n         DiagnosticsEngine &Diags, std::string Title = \"clang LLVM compiler\",\n         IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// @name Accessors\n  /// @{\n\n  /// Name to use when invoking gcc/g++.\n  const std::string &getCCCGenericGCCName() const { return CCCGenericGCCName; }\n\n  llvm::ArrayRef<std::string> getConfigFiles() const {\n    return ConfigFiles;\n  }\n\n  const llvm::opt::OptTable &getOpts() const { return getDriverOptTable(); }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  llvm::vfs::FileSystem &getVFS() const { return *VFS; }\n\n  bool getCheckInputsExist() const { return CheckInputsExist; }\n\n  void setCheckInputsExist(bool Value) { CheckInputsExist = Value; }\n\n  bool getProbePrecompiled() const { return ProbePrecompiled; }\n  void setProbePrecompiled(bool Value) { ProbePrecompiled = Value; }\n\n  const char *getPrependArg() const { return PrependArg; }\n  void setPrependArg(const char *Value) { PrependArg = Value; }\n\n  void setTargetAndMode(const ParsedClangName &TM) { ClangNameParts = TM; }\n\n  const std::string &getTitle() { return DriverTitle; }\n  void setTitle(std::string Value) { DriverTitle = std::move(Value); }\n\n  std::string getTargetTriple() const { return TargetTriple; }\n\n  /// Get the path to the main clang executable.\n  const char *getClangProgramPath() const {\n    return ClangExecutable.c_str();\n  }\n\n  /// Get the path to where the clang executable was installed.\n  const char *getInstalledDir() const {\n    if (!InstalledDir.empty())\n      return InstalledDir.c_str();\n    return Dir.c_str();\n  }\n  void setInstalledDir(StringRef Value) { InstalledDir = std::string(Value); }\n\n  bool isSaveTempsEnabled() const { return SaveTemps != SaveTempsNone; }\n  bool isSaveTempsObj() const { return SaveTemps == SaveTempsObj; }\n\n  bool embedBitcodeEnabled() const { return BitcodeEmbed != EmbedNone; }\n  bool embedBitcodeInObject() const { return (BitcodeEmbed == EmbedBitcode); }\n  bool embedBitcodeMarkerOnly() const { return (BitcodeEmbed == EmbedMarker); }\n\n  bool offloadHostOnly() const { return Offload == OffloadHost; }\n  bool offloadDeviceOnly() const { return Offload == OffloadDevice; }\n\n  /// Compute the desired OpenMP runtime from the flags provided.\n  OpenMPRuntimeKind getOpenMPRuntime(const llvm::opt::ArgList &Args) const;\n\n  /// @}\n  /// @name Primary Functionality\n  /// @{\n\n  /// CreateOffloadingDeviceToolChains - create all the toolchains required to\n  /// support offloading devices given the programming models specified in the\n  /// current compilation. Also, update the host tool chain kind accordingly.\n  void CreateOffloadingDeviceToolChains(Compilation &C, InputList &Inputs);\n\n  /// BuildCompilation - Construct a compilation object for a command\n  /// line argument vector.\n  ///\n  /// \\return A compilation, or 0 if none was built for the given\n  /// argument vector. A null return value does not necessarily\n  /// indicate an error condition, the diagnostics should be queried\n  /// to determine if an error occurred.\n  Compilation *BuildCompilation(ArrayRef<const char *> Args);\n\n  /// ParseArgStrings - Parse the given list of strings into an\n  /// ArgList.\n  llvm::opt::InputArgList ParseArgStrings(ArrayRef<const char *> Args,\n                                          bool IsClCompatMode,\n                                          bool &ContainsError);\n\n  /// BuildInputs - Construct the list of inputs and their types from\n  /// the given arguments.\n  ///\n  /// \\param TC - The default host tool chain.\n  /// \\param Args - The input arguments.\n  /// \\param Inputs - The list to store the resulting compilation\n  /// inputs onto.\n  void BuildInputs(const ToolChain &TC, llvm::opt::DerivedArgList &Args,\n                   InputList &Inputs) const;\n\n  /// BuildActions - Construct the list of actions to perform for the\n  /// given arguments, which are only done for a single architecture.\n  ///\n  /// \\param C - The compilation that is being built.\n  /// \\param Args - The input arguments.\n  /// \\param Actions - The list to store the resulting actions onto.\n  void BuildActions(Compilation &C, llvm::opt::DerivedArgList &Args,\n                    const InputList &Inputs, ActionList &Actions) const;\n\n  /// BuildUniversalActions - Construct the list of actions to perform\n  /// for the given arguments, which may require a universal build.\n  ///\n  /// \\param C - The compilation that is being built.\n  /// \\param TC - The default host tool chain.\n  void BuildUniversalActions(Compilation &C, const ToolChain &TC,\n                             const InputList &BAInputs) const;\n\n  /// BuildOffloadingActions - Construct the list of actions to perform for the\n  /// offloading toolchain that will be embedded in the host.\n  ///\n  /// \\param C - The compilation that is being built.\n  /// \\param Args - The input arguments.\n  /// \\param Input - The input type and arguments\n  /// \\param HostAction - The host action used in the offloading toolchain.\n  Action *BuildOffloadingActions(Compilation &C,\n                                 llvm::opt::DerivedArgList &Args,\n                                 const InputTy &Input,\n                                 Action *HostAction) const;\n\n  /// Returns the set of bound architectures active for this offload kind.\n  /// If there are no bound architctures we return a set containing only the\n  /// empty string. The \\p SuppressError option is used to suppress errors.\n  llvm::DenseSet<StringRef>\n  getOffloadArchs(Compilation &C, const llvm::opt::DerivedArgList &Args,\n                  Action::OffloadKind Kind, const ToolChain *TC,\n                  bool SuppressError = false) const;\n\n  /// Check that the file referenced by Value exists. If it doesn't,\n  /// issue a diagnostic and return false.\n  /// If TypoCorrect is true and the file does not exist, see if it looks\n  /// like a likely typo for a flag and if so print a \"did you mean\" blurb.\n  bool DiagnoseInputExistence(const llvm::opt::DerivedArgList &Args,\n                              StringRef Value, types::ID Ty,\n                              bool TypoCorrect) const;\n\n  /// BuildJobs - Bind actions to concrete tools and translate\n  /// arguments to form the list of jobs to run.\n  ///\n  /// \\param C - The compilation that is being built.\n  void BuildJobs(Compilation &C) const;\n\n  /// ExecuteCompilation - Execute the compilation according to the command line\n  /// arguments and return an appropriate exit code.\n  ///\n  /// This routine handles additional processing that must be done in addition\n  /// to just running the subprocesses, for example reporting errors, setting\n  /// up response files, removing temporary files, etc.\n  int ExecuteCompilation(Compilation &C,\n     SmallVectorImpl< std::pair<int, const Command *> > &FailingCommands);\n\n  /// Contains the files in the compilation diagnostic report generated by\n  /// generateCompilationDiagnostics.\n  struct CompilationDiagnosticReport {\n    llvm::SmallVector<std::string, 4> TemporaryFiles;\n  };\n\n  /// generateCompilationDiagnostics - Generate diagnostics information\n  /// including preprocessed source file(s).\n  ///\n  void generateCompilationDiagnostics(\n      Compilation &C, const Command &FailingCommand,\n      StringRef AdditionalInformation = \"\",\n      CompilationDiagnosticReport *GeneratedReport = nullptr);\n\n  enum class CommandStatus {\n    Crash = 1,\n    Error,\n    Ok,\n  };\n\n  enum class ReproLevel {\n    Off = 0,\n    OnCrash = static_cast<int>(CommandStatus::Crash),\n    OnError = static_cast<int>(CommandStatus::Error),\n    Always = static_cast<int>(CommandStatus::Ok),\n  };\n\n  bool maybeGenerateCompilationDiagnostics(\n      CommandStatus CS, ReproLevel Level, Compilation &C,\n      const Command &FailingCommand, StringRef AdditionalInformation = \"\",\n      CompilationDiagnosticReport *GeneratedReport = nullptr) {\n    if (static_cast<int>(CS) > static_cast<int>(Level))\n      return false;\n    if (CS != CommandStatus::Crash)\n      Diags.Report(diag::err_drv_force_crash)\n          << !::getenv(\"FORCE_CLANG_DIAGNOSTICS_CRASH\");\n    // Hack to ensure that diagnostic notes get emitted.\n    Diags.setLastDiagnosticIgnored(false);\n    generateCompilationDiagnostics(C, FailingCommand, AdditionalInformation,\n                                   GeneratedReport);\n    return true;\n  }\n\n  /// @}\n  /// @name Helper Methods\n  /// @{\n\n  /// PrintActions - Print the list of actions.\n  void PrintActions(const Compilation &C) const;\n\n  /// PrintHelp - Print the help text.\n  ///\n  /// \\param ShowHidden - Show hidden options.\n  void PrintHelp(bool ShowHidden) const;\n\n  /// PrintVersion - Print the driver version.\n  void PrintVersion(const Compilation &C, raw_ostream &OS) const;\n\n  /// GetFilePath - Lookup \\p Name in the list of file search paths.\n  ///\n  /// \\param TC - The tool chain for additional information on\n  /// directories to search.\n  //\n  // FIXME: This should be in CompilationInfo.\n  std::string GetFilePath(StringRef Name, const ToolChain &TC) const;\n\n  /// GetProgramPath - Lookup \\p Name in the list of program search paths.\n  ///\n  /// \\param TC - The provided tool chain for additional information on\n  /// directories to search.\n  //\n  // FIXME: This should be in CompilationInfo.\n  std::string GetProgramPath(StringRef Name, const ToolChain &TC) const;\n\n  /// HandleAutocompletions - Handle --autocomplete by searching and printing\n  /// possible flags, descriptions, and its arguments.\n  void HandleAutocompletions(StringRef PassedFlags) const;\n\n  /// HandleImmediateArgs - Handle any arguments which should be\n  /// treated before building actions or binding tools.\n  ///\n  /// \\return Whether any compilation should be built for this\n  /// invocation.\n  bool HandleImmediateArgs(const Compilation &C);\n\n  /// ConstructAction - Construct the appropriate action to do for\n  /// \\p Phase on the \\p Input, taking in to account arguments\n  /// like -fsyntax-only or --analyze.\n  Action *ConstructPhaseAction(\n      Compilation &C, const llvm::opt::ArgList &Args, phases::ID Phase,\n      Action *Input,\n      Action::OffloadKind TargetDeviceOffloadKind = Action::OFK_None) const;\n\n  /// BuildJobsForAction - Construct the jobs to perform for the action \\p A and\n  /// return an InputInfo for the result of running \\p A.  Will only construct\n  /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.\n  InputInfoList BuildJobsForAction(\n      Compilation &C, const Action *A, const ToolChain *TC, StringRef BoundArch,\n      bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput,\n      std::map<std::pair<const Action *, std::string>, InputInfoList>\n          &CachedResults,\n      Action::OffloadKind TargetDeviceOffloadKind) const;\n\n  /// Returns the default name for linked images (e.g., \"a.out\").\n  const char *getDefaultImageName() const;\n\n  /// Creates a temp file.\n  /// 1. If \\p MultipleArch is false or \\p BoundArch is empty, the temp file is\n  ///    in the temporary directory with name $Prefix-%%%%%%.$Suffix.\n  /// 2. If \\p MultipleArch is true and \\p BoundArch is not empty,\n  ///    2a. If \\p NeedUniqueDirectory is false, the temp file is in the\n  ///        temporary directory with name $Prefix-$BoundArch-%%%%%.$Suffix.\n  ///    2b. If \\p NeedUniqueDirectory is true, the temp file is in a unique\n  ///        subdiretory with random name under the temporary directory, and\n  ///        the temp file itself has name $Prefix-$BoundArch.$Suffix.\n  const char *CreateTempFile(Compilation &C, StringRef Prefix, StringRef Suffix,\n                             bool MultipleArchs = false,\n                             StringRef BoundArch = {},\n                             bool NeedUniqueDirectory = false) const;\n\n  /// GetNamedOutputPath - Return the name to use for the output of\n  /// the action \\p JA. The result is appended to the compilation's\n  /// list of temporary or result files, as appropriate.\n  ///\n  /// \\param C - The compilation.\n  /// \\param JA - The action of interest.\n  /// \\param BaseInput - The original input file that this action was\n  /// triggered by.\n  /// \\param BoundArch - The bound architecture.\n  /// \\param AtTopLevel - Whether this is a \"top-level\" action.\n  /// \\param MultipleArchs - Whether multiple -arch options were supplied.\n  /// \\param NormalizedTriple - The normalized triple of the relevant target.\n  const char *GetNamedOutputPath(Compilation &C, const JobAction &JA,\n                                 const char *BaseInput, StringRef BoundArch,\n                                 bool AtTopLevel, bool MultipleArchs,\n                                 StringRef NormalizedTriple) const;\n\n  /// GetTemporaryPath - Return the pathname of a temporary file to use\n  /// as part of compilation; the file will have the given prefix and suffix.\n  ///\n  /// GCC goes to extra lengths here to be a bit more robust.\n  std::string GetTemporaryPath(StringRef Prefix, StringRef Suffix) const;\n\n  /// GetTemporaryDirectory - Return the pathname of a temporary directory to\n  /// use as part of compilation; the directory will have the given prefix.\n  std::string GetTemporaryDirectory(StringRef Prefix) const;\n\n  /// Return the pathname of the pch file in clang-cl mode.\n  std::string GetClPchPath(Compilation &C, StringRef BaseName) const;\n\n  /// ShouldUseClangCompiler - Should the clang compiler be used to\n  /// handle this action.\n  bool ShouldUseClangCompiler(const JobAction &JA) const;\n\n  /// ShouldUseFlangCompiler - Should the flang compiler be used to\n  /// handle this action.\n  bool ShouldUseFlangCompiler(const JobAction &JA) const;\n\n  /// ShouldEmitStaticLibrary - Should the linker emit a static library.\n  bool ShouldEmitStaticLibrary(const llvm::opt::ArgList &Args) const;\n\n  /// Returns true if the user has indicated a C++20 header unit mode.\n  bool hasHeaderMode() const { return CXX20HeaderType != HeaderMode_None; }\n\n  /// Get the mode for handling headers as set by fmodule-header{=}.\n  ModuleHeaderMode getModuleHeaderMode() const { return CXX20HeaderType; }\n\n  /// Returns true if we are performing any kind of LTO.\n  bool isUsingLTO(bool IsOffload = false) const {\n    return getLTOMode(IsOffload) != LTOK_None;\n  }\n\n  /// Get the specific kind of LTO being performed.\n  LTOKind getLTOMode(bool IsOffload = false) const {\n    return IsOffload ? OffloadLTOMode : LTOMode;\n  }\n\nprivate:\n\n  /// Tries to load options from configuration files.\n  ///\n  /// \\returns true if error occurred.\n  bool loadConfigFiles();\n\n  /// Tries to load options from default configuration files (deduced from\n  /// executable filename).\n  ///\n  /// \\returns true if error occurred.\n  bool loadDefaultConfigFiles(llvm::cl::ExpansionContext &ExpCtx);\n\n  /// Read options from the specified file.\n  ///\n  /// \\param [in] FileName File to read.\n  /// \\param [in] Search and expansion options.\n  /// \\returns true, if error occurred while reading.\n  bool readConfigFile(StringRef FileName, llvm::cl::ExpansionContext &ExpCtx);\n\n  /// Set the driver mode (cl, gcc, etc) from the value of the `--driver-mode`\n  /// option.\n  void setDriverMode(StringRef DriverModeValue);\n\n  /// Parse the \\p Args list for LTO options and record the type of LTO\n  /// compilation based on which -f(no-)?lto(=.*)? option occurs last.\n  void setLTOMode(const llvm::opt::ArgList &Args);\n\n  /// Retrieves a ToolChain for a particular \\p Target triple.\n  ///\n  /// Will cache ToolChains for the life of the driver object, and create them\n  /// on-demand.\n  const ToolChain &getToolChain(const llvm::opt::ArgList &Args,\n                                const llvm::Triple &Target) const;\n\n  /// @}\n\n  /// Retrieves a ToolChain for a particular device \\p Target triple\n  ///\n  /// \\param[in] HostTC is the host ToolChain paired with the device\n  ///\n  /// \\param[in] TargetDeviceOffloadKind (e.g. OFK_Cuda/OFK_OpenMP/OFK_SYCL) is\n  /// an Offloading action that is optionally passed to a ToolChain (used by\n  /// CUDA, to specify if it's used in conjunction with OpenMP)\n  ///\n  /// Will cache ToolChains for the life of the driver object, and create them\n  /// on-demand.\n  const ToolChain &getOffloadingDeviceToolChain(\n      const llvm::opt::ArgList &Args, const llvm::Triple &Target,\n      const ToolChain &HostTC,\n      const Action::OffloadKind &TargetDeviceOffloadKind) const;\n\n  /// Get bitmasks for which option flags to include and exclude based on\n  /// the driver mode.\n  std::pair<unsigned, unsigned> getIncludeExcludeOptionFlagMasks(bool IsClCompatMode) const;\n\n  /// Helper used in BuildJobsForAction.  Doesn't use the cache when building\n  /// jobs specifically for the given action, but will use the cache when\n  /// building jobs for the Action's inputs.\n  InputInfoList BuildJobsForActionNoCache(\n      Compilation &C, const Action *A, const ToolChain *TC, StringRef BoundArch,\n      bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput,\n      std::map<std::pair<const Action *, std::string>, InputInfoList>\n          &CachedResults,\n      Action::OffloadKind TargetDeviceOffloadKind) const;\n\n  /// Return the typical executable name for the specified driver \\p Mode.\n  static const char *getExecutableForDriverMode(DriverMode Mode);\n\npublic:\n  /// GetReleaseVersion - Parse (([0-9]+)(.([0-9]+)(.([0-9]+)?))?)? and\n  /// return the grouped values as integers. Numbers which are not\n  /// provided are set to 0.\n  ///\n  /// \\return True if the entire string was parsed (9.2), or all\n  /// groups were parsed (10.3.5extrastuff). HadExtra is true if all\n  /// groups were parsed but extra characters remain at the end.\n  static bool GetReleaseVersion(StringRef Str, unsigned &Major, unsigned &Minor,\n                                unsigned &Micro, bool &HadExtra);\n\n  /// Parse digits from a string \\p Str and fulfill \\p Digits with\n  /// the parsed numbers. This method assumes that the max number of\n  /// digits to look for is equal to Digits.size().\n  ///\n  /// \\return True if the entire string was parsed and there are\n  /// no extra characters remaining at the end.\n  static bool GetReleaseVersion(StringRef Str,\n                                MutableArrayRef<unsigned> Digits);\n  /// Compute the default -fmodule-cache-path.\n  /// \\return True if the system provides a default cache directory.\n  static bool getDefaultModuleCachePath(SmallVectorImpl<char> &Result);\n}",
  "id": "BLOCK-CPP-17763",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Driver.h",
  "source_line": 77,
  "validation_status": "validated"
}