{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// The null_state_saver does nothing.\ntemplate <typename T>\nclass null_state_saver {\n public:\n  using stream_type = T;\n  using flags_type = std::ios_base::fmtflags;\n\n  null_state_saver(T&, flags_type) {}\n  ~null_state_saver() {}\n};\n\n// ostream_state_saver is a RAII object to save and restore the common\n// basic_ostream flags used when implementing `operator <<()` on any of\n// the absl random distributions.\ntemplate <typename OStream>\nclass ostream_state_saver {\n public:\n  using ostream_type = OStream;\n  using flags_type = std::ios_base::fmtflags;\n  using fill_type = typename ostream_type::char_type;\n  using precision_type = std::streamsize;\n\n  ostream_state_saver(ostream_type& os,  // NOLINT(runtime/references)\n                      flags_type flags, fill_type fill)\n      : os_(os),\n        flags_(os.flags(flags)),\n        fill_(os.fill(fill)),\n        precision_(os.precision()) {\n    // Save state in initialized variables.\n  }\n\n  ~ostream_state_saver() {\n    // Restore saved state.\n    os_.precision(precision_);\n    os_.fill(fill_);\n    os_.flags(flags_);\n  }\n\n private:\n  ostream_type& os_;\n  const flags_type flags_;\n  const fill_type fill_;\n  const precision_type precision_;\n};\n\n#if defined(__NDK_MAJOR__) && __NDK_MAJOR__ < 16\n#define ABSL_RANDOM_INTERNAL_IOSTREAM_HEXFLOAT 1\n#else\n#define ABSL_RANDOM_INTERNAL_IOSTREAM_HEXFLOAT 0\n#endif\n\ntemplate <typename CharT, typename Traits>\nostream_state_saver<std::basic_ostream<CharT, Traits>> make_ostream_state_saver(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    std::ios_base::fmtflags flags = std::ios_base::dec | std::ios_base::left |\n#if ABSL_RANDOM_INTERNAL_IOSTREAM_HEXFLOAT\n                                    std::ios_base::fixed |\n#endif\n                                    std::ios_base::scientific) {\n  using result_type = ostream_state_saver<std::basic_ostream<CharT, Traits>>;\n  return result_type(os, flags, os.widen(' '));\n}\n\ntemplate <typename T>\ntypename absl::enable_if_t<!std::is_base_of<std::ios_base, T>::value,\n                           null_state_saver<T>>\nmake_ostream_state_saver(T& is,  // NOLINT(runtime/references)\n                         std::ios_base::fmtflags flags = std::ios_base::dec) {\n  std::cerr << \"null_state_saver\";\n  using result_type = null_state_saver<T>;\n  return result_type(is, flags);\n}\n\n// stream_precision_helper<type>::kPrecision returns the base 10 precision\n// required to stream and reconstruct a real type exact binary value through\n// a binary->decimal->binary transition.\ntemplate <typename T>\nstruct stream_precision_helper {\n  // max_digits10 may be 0 on MSVC; if so, use digits10 + 3.\n  static constexpr int kPrecision =\n      (std::numeric_limits<T>::max_digits10 > std::numeric_limits<T>::digits10)\n          ? std::numeric_limits<T>::max_digits10\n          : (std::numeric_limits<T>::digits10 + 3);\n};\n\ntemplate <>\nstruct stream_precision_helper<float> {\n  static constexpr int kPrecision = 9;\n};\ntemplate <>\nstruct stream_precision_helper<double> {\n  static constexpr int kPrecision = 17;\n};\ntemplate <>\nstruct stream_precision_helper<long double> {\n  static constexpr int kPrecision = 36;  // assuming fp128\n};\n\n// istream_state_saver is a RAII object to save and restore the common\n// std::basic_istream<> flags used when implementing `operator >>()` on any of\n// the absl random distributions.\ntemplate <typename IStream>\nclass istream_state_saver {\n public:\n  using istream_type = IStream;\n  using flags_type = std::ios_base::fmtflags;\n\n  istream_state_saver(istream_type& is,  // NOLINT(runtime/references)\n                      flags_type flags)\n      : is_(is), flags_(is.flags(flags)) {}\n\n  ~istream_state_saver() { is_.flags(flags_); }\n\n private:\n  istream_type& is_;\n  flags_type flags_;\n};\n\ntemplate <typename CharT, typename Traits>\nistream_state_saver<std::basic_istream<CharT, Traits>> make_istream_state_saver(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    std::ios_base::fmtflags flags = std::ios_base::dec |\n                                    std::ios_base::scientific |\n                                    std::ios_base::skipws) {\n  using result_type = istream_state_saver<std::basic_istream<CharT, Traits>>;\n  return result_type(is, flags);\n}\n\ntemplate <typename T>\ntypename absl::enable_if_t<!std::is_base_of<std::ios_base, T>::value,\n                           null_state_saver<T>>\nmake_istream_state_saver(T& is,  // NOLINT(runtime/references)\n                         std::ios_base::fmtflags flags = std::ios_base::dec) {\n  using result_type = null_state_saver<T>;\n  return result_type(is, flags);\n}\n\n// stream_format_type<T> is a helper struct to convert types which\n// basic_iostream cannot output as decimal numbers into types which\n// basic_iostream can output as decimal numbers. Specifically:\n// * signed/unsigned char-width types are converted to int.\n// * TODO(lar): __int128 => uint128, except there is no operator << yet.\n//\ntemplate <typename T>\nstruct stream_format_type\n    : public std::conditional<(sizeof(T) == sizeof(char)), int, T> {};\n\n// stream_u128_helper allows us to write out either absl::uint128 or\n// __uint128_t types in the same way, which enables their use as internal\n// state of PRNG engines.\ntemplate <typename T>\nstruct stream_u128_helper;\n\ntemplate <>\nstruct stream_u128_helper<absl::uint128> {\n  template <typename IStream>\n  inline absl::uint128 read(IStream& in) {\n    uint64_t h = 0;\n    uint64_t l = 0;\n    in >> h >> l;\n    return absl::MakeUint128(h, l);\n  }\n\n  template <typename OStream>\n  inline void write(absl::uint128 val, OStream& out) {\n    uint64_t h = absl::Uint128High64(val);\n    uint64_t l = absl::Uint128Low64(val);\n    out << h << out.fill() << l;\n  }\n};\n\n#ifdef ABSL_HAVE_INTRINSIC_INT128\ntemplate <>\nstruct stream_u128_helper<__uint128_t> {\n  template <typename IStream>\n  inline __uint128_t read(IStream& in) {\n    uint64_t h = 0;\n    uint64_t l = 0;\n    in >> h >> l;\n    return (static_cast<__uint128_t>(h) << 64) | l;\n  }\n\n  template <typename OStream>\n  inline void write(__uint128_t val, OStream& out) {\n    uint64_t h = static_cast<uint64_t>(val >> 64u);\n    uint64_t l = static_cast<uint64_t>(val);\n    out << h << out.fill() << l;\n  }\n};\n#endif\n\ntemplate <typename FloatType, typename IStream>\ninline FloatType read_floating_point(IStream& is) {\n  static_assert(std::is_floating_point<FloatType>::value, \"\");\n  FloatType dest;\n  is >> dest;\n  // Parsing a double value may report a subnormal value as an error\n  // despite being able to represent it.\n  // See https://stackoverflow.com/q/52410931/3286653\n  // It may also report an underflow when parsing DOUBLE_MIN as an\n  // ERANGE error, as the parsed value may be smaller than DOUBLE_MIN\n  // and rounded up.\n  // See: https://stackoverflow.com/q/42005462\n  if (is.fail() &&\n      (std::fabs(dest) == (std::numeric_limits<FloatType>::min)() ||\n       std::fpclassify(dest) == FP_SUBNORMAL)) {\n    is.clear(is.rdstate() & (~std::ios_base::failbit));\n  }\n  return dest;\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05884",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/iostream_state_saver.h",
  "source_line": 26,
  "validation_status": "validated"
}