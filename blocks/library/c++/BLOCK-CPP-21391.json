{
  "code": "{\n  virtual void anchor();\n\npublic:\n  /// Implements a set of CFGBlocks using a BitVector.\n  ///\n  /// This class contains a minimal interface, primarily dictated by the SetType\n  /// template parameter of the llvm::po_iterator template, as used with\n  /// external storage. We also use this set to keep track of which CFGBlocks we\n  /// visit during the analysis.\n  class CFGBlockSet {\n    llvm::BitVector VisitedBlockIDs;\n\n  public:\n    // po_iterator requires this iterator, but the only interface needed is the\n    // value_type type.\n    struct iterator { using value_type = const CFGBlock *; };\n\n    CFGBlockSet() = default;\n    CFGBlockSet(const CFG *G) : VisitedBlockIDs(G->getNumBlockIDs(), false) {}\n\n    /// Set the bit associated with a particular CFGBlock.\n    /// This is the important method for the SetType template parameter.\n    std::pair<std::nullopt_t, bool> insert(const CFGBlock *Block) {\n      // Note that insert() is called by po_iterator, which doesn't check to\n      // make sure that Block is non-null.  Moreover, the CFGBlock iterator will\n      // occasionally hand out null pointers for pruned edges, so we catch those\n      // here.\n      if (!Block)\n        return std::make_pair(std::nullopt,\n                              false); // if an edge is trivially false.\n      if (VisitedBlockIDs.test(Block->getBlockID()))\n        return std::make_pair(std::nullopt, false);\n      VisitedBlockIDs.set(Block->getBlockID());\n      return std::make_pair(std::nullopt, true);\n    }\n\n    /// Check if the bit for a CFGBlock has been already set.\n    /// This method is for tracking visited blocks in the main threadsafety\n    /// loop. Block must not be null.\n    bool alreadySet(const CFGBlock *Block) {\n      return VisitedBlockIDs.test(Block->getBlockID());\n    }\n  };\n\nprivate:\n  using po_iterator = llvm::po_iterator<const CFG *, CFGBlockSet, true>;\n  std::vector<const CFGBlock *> Blocks;\n\n  using BlockOrderTy = llvm::DenseMap<const CFGBlock *, unsigned>;\n  BlockOrderTy BlockOrder;\n\npublic:\n  friend struct BlockOrderCompare;\n\n  using iterator = std::vector<const CFGBlock *>::reverse_iterator;\n  using const_iterator = std::vector<const CFGBlock *>::const_reverse_iterator;\n\n  PostOrderCFGView(const CFG *cfg);\n\n  iterator begin() { return Blocks.rbegin(); }\n  iterator end() { return Blocks.rend(); }\n\n  const_iterator begin() const { return Blocks.rbegin(); }\n  const_iterator end() const { return Blocks.rend(); }\n\n  bool empty() const { return begin() == end(); }\n\n  struct BlockOrderCompare {\n    const PostOrderCFGView &POV;\n\n  public:\n    BlockOrderCompare(const PostOrderCFGView &pov) : POV(pov) {}\n\n    bool operator()(const CFGBlock *b1, const CFGBlock *b2) const;\n  };\n\n  BlockOrderCompare getComparator() const {\n    return BlockOrderCompare(*this);\n  }\n\n  // Used by AnalyisContext to construct this object.\n  static const void *getTag();\n\n  static std::unique_ptr<PostOrderCFGView>\n  create(AnalysisDeclContext &analysisContext);\n}",
  "id": "BLOCK-CPP-21391",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/PostOrderCFGView.h",
  "source_line": 27,
  "validation_status": "validated"
}