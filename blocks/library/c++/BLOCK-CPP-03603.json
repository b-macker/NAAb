{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// Forward declaration to be used inside composable flag parse/unparse\n// implementations\ntemplate <typename T>\ninline bool ParseFlag(absl::string_view input, T* dst, std::string* error);\ntemplate <typename T>\ninline std::string UnparseFlag(const T& v);\n\nnamespace flags_internal {\n\n// Overloads of `AbslParseFlag()` and `AbslUnparseFlag()` for fundamental types.\nbool AbslParseFlag(absl::string_view, bool*, std::string*);\nbool AbslParseFlag(absl::string_view, short*, std::string*);           // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned short*, std::string*);  // NOLINT\nbool AbslParseFlag(absl::string_view, int*, std::string*);             // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned int*, std::string*);    // NOLINT\nbool AbslParseFlag(absl::string_view, long*, std::string*);            // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned long*, std::string*);   // NOLINT\nbool AbslParseFlag(absl::string_view, long long*, std::string*);       // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned long long*,             // NOLINT\n                   std::string*);\nbool AbslParseFlag(absl::string_view, absl::int128*, std::string*);    // NOLINT\nbool AbslParseFlag(absl::string_view, absl::uint128*, std::string*);   // NOLINT\nbool AbslParseFlag(absl::string_view, float*, std::string*);\nbool AbslParseFlag(absl::string_view, double*, std::string*);\nbool AbslParseFlag(absl::string_view, std::string*, std::string*);\nbool AbslParseFlag(absl::string_view, std::vector<std::string>*, std::string*);\n\ntemplate <typename T>\nbool AbslParseFlag(absl::string_view text, absl::optional<T>* f,\n                   std::string* err) {\n  if (text.empty()) {\n    *f = absl::nullopt;\n    return true;\n  }\n  T value;\n  if (!absl::ParseFlag(text, &value, err)) return false;\n\n  *f = std::move(value);\n  return true;\n}\n\n#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)\ntemplate <typename T>\nbool AbslParseFlag(absl::string_view text, std::optional<T>* f,\n                   std::string* err) {\n  if (text.empty()) {\n    *f = std::nullopt;\n    return true;\n  }\n  T value;\n  if (!absl::ParseFlag(text, &value, err)) return false;\n\n  *f = std::move(value);\n  return true;\n}\n#endif\n\ntemplate <typename T>\nbool InvokeParseFlag(absl::string_view input, T* dst, std::string* err) {\n  // Comment on next line provides a good compiler error message if T\n  // does not have AbslParseFlag(absl::string_view, T*, std::string*).\n  return AbslParseFlag(input, dst, err);  // Is T missing AbslParseFlag?\n}\n\n// Strings and std:: containers do not have the same overload resolution\n// considerations as fundamental types. Naming these 'AbslUnparseFlag' means we\n// can avoid the need for additional specializations of Unparse (below).\nstd::string AbslUnparseFlag(absl::string_view v);\nstd::string AbslUnparseFlag(const std::vector<std::string>&);\n\ntemplate <typename T>\nstd::string AbslUnparseFlag(const absl::optional<T>& f) {\n  return f.has_value() ? absl::UnparseFlag(*f) : \"\";\n}\n\n#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)\ntemplate <typename T>\nstd::string AbslUnparseFlag(const std::optional<T>& f) {\n  return f.has_value() ? absl::UnparseFlag(*f) : \"\";\n}\n#endif\n\ntemplate <typename T>\nstd::string Unparse(const T& v) {\n  // Comment on next line provides a good compiler error message if T does not\n  // have UnparseFlag.\n  return AbslUnparseFlag(v);  // Is T missing AbslUnparseFlag?\n}\n\n// Overloads for builtin types.\nstd::string Unparse(bool v);\nstd::string Unparse(short v);               // NOLINT\nstd::string Unparse(unsigned short v);      // NOLINT\nstd::string Unparse(int v);                 // NOLINT\nstd::string Unparse(unsigned int v);        // NOLINT\nstd::string Unparse(long v);                // NOLINT\nstd::string Unparse(unsigned long v);       // NOLINT\nstd::string Unparse(long long v);           // NOLINT\nstd::string Unparse(unsigned long long v);  // NOLINT\nstd::string Unparse(absl::int128 v);\nstd::string Unparse(absl::uint128 v);\nstd::string Unparse(float v);\nstd::string Unparse(double v);\n\n}  // namespace flags_internal\n\n// ParseFlag()\n//\n// Parses a string value into a flag value of type `T`. Do not add overloads of\n// this function for your type directly; instead, add an `AbslParseFlag()`\n// free function as documented above.\n//\n// Some implementations of `AbslParseFlag()` for types which consist of other,\n// constituent types which already have Abseil flag support, may need to call\n// `absl::ParseFlag()` on those consituent string values. (See above.)\ntemplate <typename T>\ninline bool ParseFlag(absl::string_view input, T* dst, std::string* error) {\n  return flags_internal::InvokeParseFlag(input, dst, error);\n}\n\n// UnparseFlag()\n//\n// Unparses a flag value of type `T` into a string value. Do not add overloads\n// of this function for your type directly; instead, add an `AbslUnparseFlag()`\n// free function as documented above.\n//\n// Some implementations of `AbslUnparseFlag()` for types which consist of other,\n// constituent types which already have Abseil flag support, may want to call\n// `absl::UnparseFlag()` on those constituent types. (See above.)\ntemplate <typename T>\ninline std::string UnparseFlag(const T& v) {\n  return flags_internal::Unparse(v);\n}\n\n// Overloads for `absl::LogSeverity` can't (easily) appear alongside that type's\n// definition because it is layered below flags.  See proper documentation in\n// base/log_severity.h.\nenum class LogSeverity : int;\nbool AbslParseFlag(absl::string_view, absl::LogSeverity*, std::string*);\nstd::string AbslUnparseFlag(absl::LogSeverity);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03603",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/marshalling.h",
  "source_line": 214,
  "validation_status": "validated"
}