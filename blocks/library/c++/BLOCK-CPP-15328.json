{
  "code": "{\n\nclass AnalysisDeclContextManager;\nclass ASTContext;\nclass BlockDecl;\nclass BlockInvocationContext;\nclass CFGReverseBlockReachabilityAnalysis;\nclass CFGStmtMap;\nclass ImplicitParamDecl;\nclass LocationContext;\nclass LocationContextManager;\nclass ParentMap;\nclass StackFrameContext;\nclass Stmt;\nclass VarDecl;\n\n/// The base class of a hierarchy of objects representing analyses tied\n/// to AnalysisDeclContext.\nclass ManagedAnalysis {\nprotected:\n  ManagedAnalysis() = default;\n\npublic:\n  virtual ~ManagedAnalysis();\n\n  // Subclasses need to implement:\n  //\n  //  static const void *getTag();\n  //\n  // Which returns a fixed pointer address to distinguish classes of\n  // analysis objects.  They also need to implement:\n  //\n  //  static [Derived*] create(AnalysisDeclContext &Ctx);\n  //\n  // which creates the analysis object given an AnalysisDeclContext.\n};\n\n/// AnalysisDeclContext contains the context data for the function, method\n/// or block under analysis.\nclass AnalysisDeclContext {\n  // Backpoint to the AnalysisManager object that created this\n  // AnalysisDeclContext. This may be null.\n  AnalysisDeclContextManager *ADCMgr;\n\n  const Decl *const D;\n\n  std::unique_ptr<CFG> cfg, completeCFG;\n  std::unique_ptr<CFGStmtMap> cfgStmtMap;\n\n  CFG::BuildOptions cfgBuildOptions;\n  CFG::BuildOptions::ForcedBlkExprs *forcedBlkExprs = nullptr;\n\n  bool builtCFG = false;\n  bool builtCompleteCFG = false;\n  std::unique_ptr<ParentMap> PM;\n  std::unique_ptr<CFGReverseBlockReachabilityAnalysis> CFA;\n\n  llvm::BumpPtrAllocator A;\n\n  llvm::DenseMap<const BlockDecl *, void *> *ReferencedBlockVars = nullptr;\n\n  void *ManagedAnalyses = nullptr;\n\npublic:\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D);\n\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D,\n                      const CFG::BuildOptions &BuildOptions);\n\n  ~AnalysisDeclContext();\n\n  ASTContext &getASTContext() const { return D->getASTContext(); }\n\n  const Decl *getDecl() const { return D; }\n\n  AnalysisDeclContextManager *getManager() const { return ADCMgr; }\n\n  CFG::BuildOptions &getCFGBuildOptions() { return cfgBuildOptions; }\n\n  const CFG::BuildOptions &getCFGBuildOptions() const {\n    return cfgBuildOptions;\n  }\n\n  /// \\returns Whether we are adding exception handling edges from CallExprs.\n  /// If this is false, then try/catch statements and blocks reachable from them\n  /// can appear to be dead in the CFG, analysis passes must cope with that.\n  bool getAddEHEdges() const { return cfgBuildOptions.AddEHEdges; }\n  bool getUseUnoptimizedCFG() const {\n    return !cfgBuildOptions.PruneTriviallyFalseEdges;\n  }\n  bool getAddImplicitDtors() const { return cfgBuildOptions.AddImplicitDtors; }\n  bool getAddInitializers() const { return cfgBuildOptions.AddInitializers; }\n\n  void registerForcedBlockExpression(const Stmt *stmt);\n  const CFGBlock *getBlockForRegisteredExpression(const Stmt *stmt);\n\n  /// \\returns The body of the stored Decl \\c D.\n  Stmt *getBody() const;\n\n  /// \\copydoc AnalysisDeclContext::getBody()\n  /// \\param[out] IsAutosynthesized Specifies if the body is auto-generated\n  ///             by the BodyFarm.\n  Stmt *getBody(bool &IsAutosynthesized) const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesized() const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm\n  /// from a model file.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesizedFromModelFile() const;\n\n  CFG *getCFG();\n\n  CFGStmtMap *getCFGStmtMap();\n\n  CFGReverseBlockReachabilityAnalysis *getCFGReachablityAnalysis();\n\n  /// \\returns A version of the CFG without any edges pruned.\n  CFG *getUnoptimizedCFG();\n\n  void dumpCFG(bool ShowColors);\n\n  /// \\returns Whether we have built a CFG for this analysis context.\n  ///\n  /// \\note This doesn't correspond to whether or not a valid CFG exists, it\n  /// corresponds to whether we *attempted* to build one.\n  bool isCFGBuilt() const { return builtCFG; }\n\n  ParentMap &getParentMap();\n\n  using referenced_decls_iterator = const VarDecl *const *;\n\n  llvm::iterator_range<referenced_decls_iterator>\n  getReferencedBlockVars(const BlockDecl *BD);\n\n  /// \\returns The ImplicitParamDecl associated with \\c self if this\n  /// AnalysisDeclContext wraps an ObjCMethodDecl or nullptr otherwise.\n  const ImplicitParamDecl *getSelfDecl() const;\n\n  /// \\copydoc LocationContextManager::getStackFrame()\n  const StackFrameContext *getStackFrame(LocationContext const *ParentLC,\n                                         const Stmt *S, const CFGBlock *Blk,\n                                         unsigned BlockCount, unsigned Index);\n\n  /// \\copydoc LocationContextManager::getBlockInvocationContext()\n  const BlockInvocationContext *\n  getBlockInvocationContext(const LocationContext *ParentLC,\n                            const BlockDecl *BD, const void *Data);\n\n  /// \\returns The specified analysis object, lazily running the analysis if\n  /// necessary or nullptr if the analysis could not run.\n  template <typename T> T *getAnalysis() {\n    const void *tag = T::getTag();\n    std::unique_ptr<ManagedAnalysis> &data = getAnalysisImpl(tag);\n    if (!data)\n      data = T::create(*this);\n    return static_cast<T *>(data.get());\n  }\n\n  /// \\returns Whether the root namespace of \\p D is the \\c std C++ namespace.\n  static bool isInStdNamespace(const Decl *D);\n\n  static std::string getFunctionName(const Decl *D);\n\nprivate:\n  std::unique_ptr<ManagedAnalysis> &getAnalysisImpl(const void *tag);\n\n  LocationContextManager &getLocationContextManager();\n};\n\n/// It wraps the AnalysisDeclContext to represent both the call stack with\n/// the help of StackFrameContext and inside the function calls the\n/// BlockInvocationContext. It is needed for context sensitive analysis to\n/// model entering, leaving or inlining function calls.\nclass LocationContext : public llvm::FoldingSetNode {\npublic:\n  enum ContextKind { StackFrame, Block };\n\nprivate:\n  ContextKind Kind;\n\n  // AnalysisDeclContext can't be const since some methods may modify its\n  // member.\n  AnalysisDeclContext *Ctx;\n\n  const LocationContext *Parent;\n  int64_t ID;\n\nprotected:\n  LocationContext(ContextKind k, AnalysisDeclContext *ctx,\n                  const LocationContext *parent, int64_t ID)\n      : Kind(k), Ctx(ctx), Parent(parent), ID(ID) {\n    assert(ctx);\n  }\n\npublic:\n  virtual ~LocationContext();\n\n  ContextKind getKind() const { return Kind; }\n\n  int64_t getID() const { return ID; }\n\n  LLVM_ATTRIBUTE_RETURNS_NONNULL\n  AnalysisDeclContext *getAnalysisDeclContext() const { return Ctx; }\n\n  /// It might return null.\n  const LocationContext *getParent() const { return Parent; }\n\n  bool isParentOf(const LocationContext *LC) const;\n\n  const Decl *getDecl() const { return Ctx->getDecl(); }\n\n  CFG *getCFG() const { return Ctx->getCFG(); }\n\n  template <typename T> T *getAnalysis() const { return Ctx->getAnalysis<T>(); }\n\n  const ParentMap &getParentMap() const { return Ctx->getParentMap(); }\n\n  /// \\copydoc AnalysisDeclContext::getSelfDecl()\n  const ImplicitParamDecl *getSelfDecl() const { return Ctx->getSelfDecl(); }\n\n  const StackFrameContext *getStackFrame() const;\n\n  /// \\returns Whether the current LocationContext has no caller context.\n  virtual bool inTopFrame() const;\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) = 0;\n\n  /// Prints out the call stack.\n  ///\n  /// \\param Out The out stream.\n  LLVM_DUMP_METHOD void dumpStack(raw_ostream &Out) const;\n\n  /// Prints out the call stack in \\c json format.\n  ///\n  /// \\param Out   The out stream.\n  /// \\param NL    The newline.\n  /// \\param Space The space count for indentation.\n  /// \\param IsDot Whether the output format is \\c dot.\n  /// \\param printMoreInfoPerContext\n  /// A callback to print more information for each context, for example:\n  /// \\code\n  ///   [&](const LocationContext *LC) { LC->dump(); }\n  /// \\endcode\n  void printJson(\n      raw_ostream &Out, const char *NL = \"\\n\", unsigned int Space = 0,\n      bool IsDot = false,\n      std::function<void(const LocationContext *)> printMoreInfoPerContext =\n          [](const LocationContext *) {}) const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static void ProfileCommon(llvm::FoldingSetNodeID &ID, ContextKind ck,\n                            AnalysisDeclContext *ctx,\n                            const LocationContext *parent, const void *data);\n};\n\n/// It represents a stack frame of the call stack (based on CallEvent).\nclass StackFrameContext : public LocationContext {\n  friend class LocationContextManager;\n\n  // The call site where this stack frame is established.\n  const Stmt *CallSite;\n\n  // The parent block of the call site.\n  const CFGBlock *Block;\n\n  // The number of times the 'Block' has been visited.\n  // It allows discriminating between stack frames of the same call that is\n  // called multiple times in a loop.\n  const unsigned BlockCount;\n\n  // The index of the call site in the CFGBlock.\n  const unsigned Index;\n\n  StackFrameContext(AnalysisDeclContext *ADC, const LocationContext *ParentLC,\n                    const Stmt *S, const CFGBlock *Block, unsigned BlockCount,\n                    unsigned Index, int64_t ID)\n      : LocationContext(StackFrame, ADC, ParentLC, ID), CallSite(S),\n        Block(Block), BlockCount(BlockCount), Index(Index) {}\n\npublic:\n  ~StackFrameContext() override = default;\n\n  const Stmt *getCallSite() const { return CallSite; }\n\n  const CFGBlock *getCallSiteBlock() const { return Block; }\n\n  bool inTopFrame() const override { return getParent() == nullptr; }\n\n  unsigned getIndex() const { return Index; }\n\n  CFGElement getCallSiteCFGElement() const { return (*Block)[Index]; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) override;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, AnalysisDeclContext *ADC,\n                      const LocationContext *ParentLC, const Stmt *S,\n                      const CFGBlock *Block, unsigned BlockCount,\n                      unsigned Index) {\n    ProfileCommon(ID, StackFrame, ADC, ParentLC, S);\n    ID.AddPointer(Block);\n    ID.AddInteger(BlockCount);\n    ID.AddInteger(Index);\n  }\n\n  static bool classof(const LocationContext *LC) {\n    return LC->getKind() == StackFrame;\n  }\n};\n\n/// It represents a block invocation (based on BlockCall).\nclass BlockInvocationContext : public LocationContext {\n  friend class LocationContextManager;\n\n  const BlockDecl *BD;\n\n  // FIXME: Come up with a more type-safe way to model context-sensitivity.\n  const void *Data;\n\n  BlockInvocationContext(AnalysisDeclContext *ADC,\n                         const LocationContext *ParentLC, const BlockDecl *BD,\n                         const void *Data, int64_t ID)\n      : LocationContext(Block, ADC, ParentLC, ID), BD(BD), Data(Data) {}\n\npublic:\n  ~BlockInvocationContext() override = default;\n\n  const BlockDecl *getBlockDecl() const { return BD; }\n\n  const void *getData() const { return Data; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) override;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, AnalysisDeclContext *ADC,\n                      const LocationContext *ParentLC, const BlockDecl *BD,\n                      const void *Data) {\n    ProfileCommon(ID, Block, ADC, ParentLC, BD);\n    ID.AddPointer(Data);\n  }\n\n  static bool classof(const LocationContext *LC) {\n    return LC->getKind() == Block;\n  }\n};\n\nclass LocationContextManager {\n  llvm::FoldingSet<LocationContext> Contexts;\n\n  // ID used for generating a new location context.\n  int64_t NewID = 0;\n\npublic:\n  ~LocationContextManager();\n\n  /// Obtain a context of the call stack using its parent context.\n  ///\n  /// \\param ADC        The AnalysisDeclContext.\n  /// \\param ParentLC   The parent context of this newly created context.\n  /// \\param S          The call.\n  /// \\param Block      The basic block.\n  /// \\param BlockCount The current count of entering into \\p Blk.\n  /// \\param Index      The index of \\p Blk.\n  /// \\returns The context for \\p D with parent context \\p ParentLC.\n  const StackFrameContext *getStackFrame(AnalysisDeclContext *ADC,\n                                         const LocationContext *ParentLC,\n                                         const Stmt *S, const CFGBlock *Block,\n                                         unsigned BlockCount, unsigned Index);\n\n  /// Obtain a context of the block invocation using its parent context.\n  ///\n  /// \\param ADC      The AnalysisDeclContext.\n  /// \\param ParentLC The parent context of this newly created context.\n  /// \\param BD       The BlockDecl.\n  /// \\param Data     The raw data to store as part of the context.\n  const BlockInvocationContext *\n  getBlockInvocationContext(AnalysisDeclContext *ADC,\n                            const LocationContext *ParentLC,\n                            const BlockDecl *BD, const void *Data);\n\n  /// Discard all previously created LocationContext objects.\n  void clear();\n};\n\nclass AnalysisDeclContextManager {\n  using ContextMap =\n      llvm::DenseMap<const Decl *, std::unique_ptr<AnalysisDeclContext>>;\n\n  ContextMap Contexts;\n  LocationContextManager LocCtxMgr;\n  CFG::BuildOptions cfgBuildOptions;\n\n  // Pointer to an interface that can provide function bodies for\n  // declarations from external source.\n  std::unique_ptr<CodeInjector> Injector;\n\n  // A factory for creating and caching implementations for common\n  // methods during the analysis.\n  BodyFarm FunctionBodyFarm;\n\n  // Flag to indicate whether or not bodies should be synthesized\n  // for well-known functions.\n  bool SynthesizeBodies;\n\npublic:\n  AnalysisDeclContextManager(\n      ASTContext &ASTCtx, bool useUnoptimizedCFG = false,\n      bool addImplicitDtors = false, bool addInitializers = false,\n      bool addTemporaryDtors = false, bool addLifetime = false,\n      bool addLoopExit = false, bool addScopes = false,\n      bool synthesizeBodies = false, bool addStaticInitBranches = false,\n      bool addCXXNewAllocator = true, bool addRichCXXConstructors = true,\n      bool markElidedCXXConstructors = true, bool addVirtualBaseBranches = true,\n      CodeInjector *injector = nullptr);\n\n  AnalysisDeclContext *getContext(const Decl *D);\n\n  bool getUseUnoptimizedCFG() const {\n    return !cfgBuildOptions.PruneTriviallyFalseEdges;\n  }\n\n  CFG::BuildOptions &getCFGBuildOptions() { return cfgBuildOptions; }\n\n  /// \\returns Whether faux bodies should be synthesized for known functions.\n  bool synthesizeBodies() const { return SynthesizeBodies; }\n\n  /// Obtain the beginning context of the analysis.\n  ///\n  /// \\returns The top level stack frame for \\p D.\n  const StackFrameContext *getStackFrame(const Decl *D) {\n    return LocCtxMgr.getStackFrame(getContext(D), nullptr, nullptr, nullptr, 0,\n                                   0);\n  }\n\n  /// \\copydoc LocationContextManager::getStackFrame()\n  const StackFrameContext *getStackFrame(AnalysisDeclContext *ADC,\n                                         const LocationContext *Parent,\n                                         const Stmt *S, const CFGBlock *Block,\n                                         unsigned BlockCount, unsigned Index) {\n    return LocCtxMgr.getStackFrame(ADC, Parent, S, Block, BlockCount, Index);\n  }\n\n  BodyFarm &getBodyFarm();\n\n  /// Discard all previously created AnalysisDeclContexts.\n  void clear();\n\nprivate:\n  friend class AnalysisDeclContext;\n\n  LocationContextManager &getLocationContextManager() { return LocCtxMgr; }\n};\n\n}",
  "id": "BLOCK-CPP-15328",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/AnalysisDeclContext.h",
  "source_line": 33,
  "validation_status": "validated"
}