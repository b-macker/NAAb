{
  "code": "#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/LLVM.h\"\n\nusing namespace llvm;\nusing namespace vfs;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17598_execute() {\n    {\n  class CodeGenOptions;\n  class CoverageSourceInfo;\n  class Decl;\n  class DiagnosticsEngine;\n  class GlobalDecl;\n  class HeaderSearchOptions;\n  class LangOptions;\n  class PreprocessorOptions;\n\nnamespace CodeGen {\n  class CodeGenModule;\n  class CGDebugInfo;\n}\n\n/// The primary public interface to the Clang code generator.\n///\n/// This is not really an abstract interface.\nclass CodeGenerator : public ASTConsumer {\n  virtual void anchor();\n\npublic:\n  /// Return an opaque reference to the CodeGenModule object, which can\n  /// be used in various secondary APIs.  It is valid as long as the\n  /// CodeGenerator exists.\n  CodeGen::CodeGenModule &CGM();\n\n  /// Return the module that this code generator is building into.\n  ///\n  /// This may return null after HandleTranslationUnit is called;\n  /// this signifies that there was an error generating code.  A\n  /// diagnostic will have been generated in this case, and the module\n  /// will be deleted.\n  ///\n  /// It will also return null if the module is released.\n  llvm::Module *GetModule();\n\n  /// Release ownership of the module to the caller.\n  ///\n  /// It is illegal to call methods other than GetModule on the\n  /// CodeGenerator after releasing its module.\n  llvm::Module *ReleaseModule();\n\n  /// Return debug info code generator.\n  CodeGen::CGDebugInfo *getCGDebugInfo();\n\n  /// Given a mangled name, return a declaration which mangles that way\n  /// which has been added to this code generator via a Handle method.\n  ///\n  /// This may return null if there was no matching declaration.\n  const Decl *GetDeclForMangledName(llvm::StringRef MangledName);\n\n  /// Given a global declaration, return a mangled name for this declaration\n  /// which has been added to this code generator via a Handle method.\n  llvm::StringRef GetMangledName(GlobalDecl GD);\n\n  /// Return the LLVM address of the given global entity.\n  ///\n  /// \\param isForDefinition If true, the caller intends to define the\n  ///   entity; the object returned will be an llvm::GlobalValue of\n  ///   some sort.  If false, the caller just intends to use the entity;\n  ///   the object returned may be any sort of constant value, and the\n  ///   code generator will schedule the entity for emission if a\n  ///   definition has been registered with this code generator.\n  llvm::Constant *GetAddrOfGlobal(GlobalDecl decl, bool isForDefinition);\n\n  /// Create a new \\c llvm::Module after calling HandleTranslationUnit. This\n  /// enable codegen in interactive processing environments.\n  llvm::Module* StartModule(llvm::StringRef ModuleName, llvm::LLVMContext &C);\n};\n\n/// CreateLLVMCodeGen - Create a CodeGenerator instance.\n/// It is the responsibility of the caller to call delete on\n/// the allocated CodeGenerator instance.\nCodeGenerator *CreateLLVMCodeGen(DiagnosticsEngine &Diags,\n                                 llvm::StringRef ModuleName,\n                                 IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS,\n                                 const HeaderSearchOptions &HeaderSearchOpts,\n                                 const PreprocessorOptions &PreprocessorOpts,\n                                 const CodeGenOptions &CGO,\n                                 llvm::LLVMContext &C,\n                                 CoverageSourceInfo *CoverageInfo = nullptr);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17598",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/ModuleBuilder.h",
  "source_line": 30,
  "validation_status": "validated"
}