{
  "code": "{\n  friend class ASTStmtReader;\n\nprivate:\n  llvm::PointerUnion<Stmt *, TypeSourceInfo *> Operand;\n  SourceRange Range;\n\npublic:\n  CXXTypeidExpr(QualType Ty, TypeSourceInfo *Operand, SourceRange R)\n      : Expr(CXXTypeidExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXTypeidExpr(QualType Ty, Expr *Operand, SourceRange R)\n      : Expr(CXXTypeidExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXTypeidExpr(EmptyShell Empty, bool isExpr)\n      : Expr(CXXTypeidExprClass, Empty) {\n    if (isExpr)\n      Operand = (Expr*)nullptr;\n    else\n      Operand = (TypeSourceInfo*)nullptr;\n  }\n\n  /// Determine whether this typeid has a type operand which is potentially\n  /// evaluated, per C++11 [expr.typeid]p3.\n  bool isPotentiallyEvaluated() const;\n\n  /// Best-effort check if the expression operand refers to a most derived\n  /// object. This is not a strong guarantee.\n  bool isMostDerived(ASTContext &Context) const;\n\n  bool isTypeOperand() const { return Operand.is<TypeSourceInfo *>(); }\n\n  /// Retrieves the type operand of this typeid() expression after\n  /// various required adjustments (removing reference types, cv-qualifiers).\n  QualType getTypeOperand(ASTContext &Context) const;\n\n  /// Retrieve source information for the type operand.\n  TypeSourceInfo *getTypeOperandSourceInfo() const {\n    assert(isTypeOperand() && \"Cannot call getTypeOperand for typeid(expr)\");\n    return Operand.get<TypeSourceInfo *>();\n  }\n  Expr *getExprOperand() const {\n    assert(!isTypeOperand() && \"Cannot call getExprOperand for typeid(type)\");\n    return static_cast<Expr*>(Operand.get<Stmt *>());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  void setSourceRange(SourceRange R) { Range = R; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXTypeidExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isTypeOperand())\n      return child_range(child_iterator(), child_iterator());\n    auto **begin = reinterpret_cast<Stmt **>(&Operand);\n    return child_range(begin, begin + 1);\n  }\n\n  const_child_range children() const {\n    if (isTypeOperand())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n\n    auto **begin =\n        reinterpret_cast<Stmt **>(&const_cast<CXXTypeidExpr *>(this)->Operand);\n    return const_child_range(begin, begin + 1);\n  }\n}",
  "id": "BLOCK-CPP-10778",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 845,
  "validation_status": "validated"
}