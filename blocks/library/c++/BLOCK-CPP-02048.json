{
  "code": "{\n  // Determine total size needed.\n  size_t size = 0;\n  for (size_t i = 0; i < format.size(); i++) {\n    if (format[i] == '$') {\n      if (i + 1 >= format.size()) {\n#ifndef NDEBUG\n        ABSL_RAW_LOG(FATAL,\n                     \"Invalid absl::Substitute() format string: \\\"%s\\\".\",\n                     absl::CEscape(format).c_str());\n#endif\n        return;\n      } else if (absl::ascii_isdigit(\n                     static_cast<unsigned char>(format[i + 1]))) {\n        int index = format[i + 1] - '0';\n        if (static_cast<size_t>(index) >= num_args) {\n#ifndef NDEBUG\n          ABSL_RAW_LOG(\n              FATAL,\n              \"Invalid absl::Substitute() format string: asked for \\\"$\"\n              \"%d\\\", but only %d args were given.  Full format string was: \"\n              \"\\\"%s\\\".\",\n              index, static_cast<int>(num_args), absl::CEscape(format).c_str());\n#endif\n          return;\n        }\n        size += args_array[index].size();\n        ++i;  // Skip next char.\n      } else if (format[i + 1] == '$') {\n        ++size;\n        ++i;  // Skip next char.\n      } else {\n#ifndef NDEBUG\n        ABSL_RAW_LOG(FATAL,\n                     \"Invalid absl::Substitute() format string: \\\"%s\\\".\",\n                     absl::CEscape(format).c_str());\n#endif\n        return;\n      }\n    } else {\n      ++size;\n    }\n  }\n\n  if (size == 0) return;\n\n  // Build the string.\n  size_t original_size = output->size();\n  strings_internal::STLStringResizeUninitializedAmortized(output,\n                                                          original_size + size);\n  char* target = &(*output)[original_size];\n  for (size_t i = 0; i < format.size(); i++) {\n    if (format[i] == '$') {\n      if (absl::ascii_isdigit(static_cast<unsigned char>(format[i + 1]))) {\n        const absl::string_view src = args_array[format[i + 1] - '0'];\n        target = std::copy(src.begin(), src.end(), target);\n        ++i;  // Skip next char.\n      } else if (format[i + 1] == '$') {\n        *target++ = '$';\n        ++i;  // Skip next char.\n      }\n    } else {\n      *target++ = format[i];\n    }\n  }\n\n  assert(target == output->data() + output->size());\n}",
  "id": "BLOCK-CPP-02048",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/substitute.cc",
  "source_line": 37,
  "validation_status": "validated"
}