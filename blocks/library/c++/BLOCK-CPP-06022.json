{
  "code": "{\n  template <typename U>\n  friend class StatusOrData;\n\n public:\n  StatusOrData() = delete;\n\n  StatusOrData(const StatusOrData& other) {\n    if (other.ok()) {\n      MakeValue(other.data_);\n      MakeStatus();\n    } else {\n      MakeStatus(other.status_);\n    }\n  }\n\n  StatusOrData(StatusOrData&& other) noexcept {\n    if (other.ok()) {\n      MakeValue(std::move(other.data_));\n      MakeStatus();\n    } else {\n      MakeStatus(std::move(other.status_));\n    }\n  }\n\n  template <typename U>\n  explicit StatusOrData(const StatusOrData<U>& other) {\n    if (other.ok()) {\n      MakeValue(other.data_);\n      MakeStatus();\n    } else {\n      MakeStatus(other.status_);\n    }\n  }\n\n  template <typename U>\n  explicit StatusOrData(StatusOrData<U>&& other) {\n    if (other.ok()) {\n      MakeValue(std::move(other.data_));\n      MakeStatus();\n    } else {\n      MakeStatus(std::move(other.status_));\n    }\n  }\n\n  template <typename... Args>\n  explicit StatusOrData(absl::in_place_t, Args&&... args)\n      : data_(std::forward<Args>(args)...) {\n    MakeStatus();\n  }\n\n  explicit StatusOrData(const T& value) : data_(value) {\n    MakeStatus();\n  }\n  explicit StatusOrData(T&& value) : data_(std::move(value)) {\n    MakeStatus();\n  }\n\n  template <typename U,\n            absl::enable_if_t<std::is_constructible<absl::Status, U&&>::value,\n                              int> = 0>\n  explicit StatusOrData(U&& v) : status_(std::forward<U>(v)) {\n    EnsureNotOk();\n  }\n\n  StatusOrData& operator=(const StatusOrData& other) {\n    if (this == &other) return *this;\n    if (other.ok())\n      Assign(other.data_);\n    else\n      AssignStatus(other.status_);\n    return *this;\n  }\n\n  StatusOrData& operator=(StatusOrData&& other) {\n    if (this == &other) return *this;\n    if (other.ok())\n      Assign(std::move(other.data_));\n    else\n      AssignStatus(std::move(other.status_));\n    return *this;\n  }\n\n  ~StatusOrData() {\n    if (ok()) {\n      status_.~Status();\n      data_.~T();\n    } else {\n      status_.~Status();\n    }\n  }\n\n  template <typename U>\n  void Assign(U&& value) {\n    if (ok()) {\n      data_ = std::forward<U>(value);\n    } else {\n      MakeValue(std::forward<U>(value));\n      status_ = OkStatus();\n    }\n  }\n\n  template <typename U>\n  void AssignStatus(U&& v) {\n    Clear();\n    status_ = static_cast<absl::Status>(std::forward<U>(v));\n    EnsureNotOk();\n  }\n\n  bool ok() const { return status_.ok(); }\n\n protected:\n  // status_ will always be active after the constructor.\n  // We make it a union to be able to initialize exactly how we need without\n  // waste.\n  // Eg. in the copy constructor we use the default constructor of Status in\n  // the ok() path to avoid an extra Ref call.\n  union {\n    Status status_;\n  };\n\n  // data_ is active iff status_.ok()==true\n  struct Dummy {};\n  union {\n    // When T is const, we need some non-const object we can cast to void* for\n    // the placement new. dummy_ is that object.\n    Dummy dummy_;\n    T data_;\n  };\n\n  void Clear() {\n    if (ok()) data_.~T();\n  }\n\n  void EnsureOk() const {\n    if (ABSL_PREDICT_FALSE(!ok())) Helper::Crash(status_);\n  }\n\n  void EnsureNotOk() {\n    if (ABSL_PREDICT_FALSE(ok())) Helper::HandleInvalidStatusCtorArg(&status_);\n  }\n\n  // Construct the value (ie. data_) through placement new with the passed\n  // argument.\n  template <typename... Arg>\n  void MakeValue(Arg&&... arg) {\n    internal_statusor::PlacementNew<T>(&dummy_, std::forward<Arg>(arg)...);\n  }\n\n  // Construct the status (ie. status_) through placement new with the passed\n  // argument.\n  template <typename... Args>\n  void MakeStatus(Args&&... args) {\n    internal_statusor::PlacementNew<Status>(&status_,\n                                            std::forward<Args>(args)...);\n  }\n}",
  "id": "BLOCK-CPP-06022",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/internal/statusor_internal.h",
  "source_line": 145,
  "validation_status": "validated"
}