{
  "code": "{\n  // NameDecl is either a TemplateDecl or a UsingShadowDecl depending on the\n  // NameKind.\n  // !! There is no free low bits in 32-bit builds to discriminate more than 4\n  // pointer types in PointerUnion.\n  using StorageType =\n      llvm::PointerUnion<Decl *, UncommonTemplateNameStorage *,\n                         QualifiedTemplateName *, DependentTemplateName *>;\n\n  StorageType Storage;\n\n  explicit TemplateName(void *Ptr);\n\npublic:\n  // Kind of name that is actually stored.\n  enum NameKind {\n    /// A single template declaration.\n    Template,\n\n    /// A set of overloaded template declarations.\n    OverloadedTemplate,\n\n    /// An unqualified-id that has been assumed to name a function template\n    /// that will be found by ADL.\n    AssumedTemplate,\n\n    /// A qualified template name, where the qualification is kept\n    /// to describe the source code as written.\n    QualifiedTemplate,\n\n    /// A dependent template name that has not been resolved to a\n    /// template (or set of templates).\n    DependentTemplate,\n\n    /// A template template parameter that has been substituted\n    /// for some other template name.\n    SubstTemplateTemplateParm,\n\n    /// A template template parameter pack that has been substituted for\n    /// a template template argument pack, but has not yet been expanded into\n    /// individual arguments.\n    SubstTemplateTemplateParmPack,\n\n    /// A template name that refers to a template declaration found through a\n    /// specific using shadow declaration.\n    UsingTemplate,\n  };\n\n  TemplateName() = default;\n  explicit TemplateName(TemplateDecl *Template);\n  explicit TemplateName(OverloadedTemplateStorage *Storage);\n  explicit TemplateName(AssumedTemplateStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmPackStorage *Storage);\n  explicit TemplateName(QualifiedTemplateName *Qual);\n  explicit TemplateName(DependentTemplateName *Dep);\n  explicit TemplateName(UsingShadowDecl *Using);\n\n  /// Determine whether this template name is NULL.\n  bool isNull() const;\n\n  // Get the kind of name that is actually stored.\n  NameKind getKind() const;\n\n  /// Retrieve the underlying template declaration that\n  /// this template name refers to, if known.\n  ///\n  /// \\returns The template declaration that this template name refers\n  /// to, if any. If the template name does not refer to a specific\n  /// declaration because it is a dependent name, or if it refers to a\n  /// set of function templates, returns NULL.\n  TemplateDecl *getAsTemplateDecl() const;\n\n  /// Retrieve the underlying, overloaded function template\n  /// declarations that this template name refers to, if known.\n  ///\n  /// \\returns The set of overloaded function templates that this template\n  /// name refers to, if known. If the template name does not refer to a\n  /// specific set of function templates because it is a dependent name or\n  /// refers to a single template, returns NULL.\n  OverloadedTemplateStorage *getAsOverloadedTemplate() const;\n\n  /// Retrieve information on a name that has been assumed to be a\n  /// template-name in order to permit a call via ADL.\n  AssumedTemplateStorage *getAsAssumedTemplateName() const;\n\n  /// Retrieve the substituted template template parameter, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmStorage *getAsSubstTemplateTemplateParm() const;\n\n  /// Retrieve the substituted template template parameter pack, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter pack,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmPackStorage *\n  getAsSubstTemplateTemplateParmPack() const;\n\n  /// Retrieve the underlying qualified template name\n  /// structure, if any.\n  QualifiedTemplateName *getAsQualifiedTemplateName() const;\n\n  /// Retrieve the underlying dependent template name\n  /// structure, if any.\n  DependentTemplateName *getAsDependentTemplateName() const;\n\n  /// Retrieve the using shadow declaration through which the underlying\n  /// template declaration is introduced, if any.\n  UsingShadowDecl *getAsUsingShadowDecl() const;\n\n  TemplateName getUnderlying() const;\n\n  /// Get the template name to substitute when this template name is used as a\n  /// template template argument. This refers to the most recent declaration of\n  /// the template, including any default template arguments.\n  TemplateName getNameToSubstitute() const;\n\n  TemplateNameDependence getDependence() const;\n\n  /// Determines whether this is a dependent template name.\n  bool isDependent() const;\n\n  /// Determines whether this is a template name that somehow\n  /// depends on a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determines whether this template name contains an\n  /// unexpanded parameter pack (for C++0x variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  enum class Qualified { None, AsWritten, Fully };\n  /// Print the template name.\n  ///\n  /// \\param OS the output stream to which the template name will be\n  /// printed.\n  ///\n  /// \\param Qual print the (Qualified::None) simple name,\n  /// (Qualified::AsWritten) any written (possibly partial) qualifier, or\n  /// (Qualified::Fully) the fully qualified name.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             Qualified Qual = Qualified::AsWritten) const;\n\n  /// Debugging aid that dumps the template name.\n  void dump(raw_ostream &OS) const;\n\n  /// Debugging aid that dumps the template name to standard\n  /// error.\n  void dump() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n\n  /// Retrieve the template name as a void pointer.\n  void *getAsVoidPointer() const { return Storage.getOpaqueValue(); }\n\n  /// Build a template name from a void pointer.\n  static TemplateName getFromVoidPointer(void *Ptr) {\n    return TemplateName(Ptr);\n  }\n}",
  "id": "BLOCK-CPP-13489",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TemplateName.h",
  "source_line": 202,
  "validation_status": "validated"
}