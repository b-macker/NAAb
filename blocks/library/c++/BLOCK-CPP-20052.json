{
  "code": "{\n      OperatorRewriteInfo()\n          : OriginalOperator(OO_None), OpLoc(), AllowRewrittenCandidates(false) {}\n      OperatorRewriteInfo(OverloadedOperatorKind Op, SourceLocation OpLoc,\n                          bool AllowRewritten)\n          : OriginalOperator(Op), OpLoc(OpLoc),\n            AllowRewrittenCandidates(AllowRewritten) {}\n\n      /// The original operator as written in the source.\n      OverloadedOperatorKind OriginalOperator;\n      /// The source location of the operator.\n      SourceLocation OpLoc;\n      /// Whether we should include rewritten candidates in the overload set.\n      bool AllowRewrittenCandidates;\n\n      /// Would use of this function result in a rewrite using a different\n      /// operator?\n      bool isRewrittenOperator(const FunctionDecl *FD) {\n        return OriginalOperator &&\n               FD->getDeclName().getCXXOverloadedOperator() != OriginalOperator;\n      }\n\n      bool isAcceptableCandidate(const FunctionDecl *FD) {\n        if (!OriginalOperator)\n          return true;\n\n        // For an overloaded operator, we can have candidates with a different\n        // name in our unqualified lookup set. Make sure we only consider the\n        // ones we're supposed to.\n        OverloadedOperatorKind OO =\n            FD->getDeclName().getCXXOverloadedOperator();\n        return OO && (OO == OriginalOperator ||\n                      (AllowRewrittenCandidates &&\n                       OO == getRewrittenOverloadedOperator(OriginalOperator)));\n      }\n\n      /// Determine the kind of rewrite that should be performed for this\n      /// candidate.\n      OverloadCandidateRewriteKind\n      getRewriteKind(const FunctionDecl *FD, OverloadCandidateParamOrder PO) {\n        OverloadCandidateRewriteKind CRK = CRK_None;\n        if (isRewrittenOperator(FD))\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_DifferentOperator);\n        if (PO == OverloadCandidateParamOrder::Reversed)\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_Reversed);\n        return CRK;\n      }\n      /// Determines whether this operator could be implemented by a function\n      /// with reversed parameter order.\n      bool isReversible() {\n        return AllowRewrittenCandidates && OriginalOperator &&\n               (getRewrittenOverloadedOperator(OriginalOperator) != OO_None ||\n                allowsReversed(OriginalOperator));\n      }\n\n      /// Determine whether reversing parameter order is allowed for operator\n      /// Op.\n      bool allowsReversed(OverloadedOperatorKind Op);\n\n      /// Determine whether we should add a rewritten candidate for \\p FD with\n      /// reversed parameter order.\n      /// \\param OriginalArgs are the original non reversed arguments.\n      bool shouldAddReversed(Sema &S, ArrayRef<Expr *> OriginalArgs,\n                             FunctionDecl *FD);\n    }",
  "id": "BLOCK-CPP-20052",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Overload.h",
  "source_line": 980,
  "validation_status": "validated"
}