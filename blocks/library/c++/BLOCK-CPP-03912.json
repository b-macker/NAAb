{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::uniform_int_distribution<T>\n//\n// This distribution produces random integer values uniformly distributed in the\n// closed (inclusive) interval [a, b].\n//\n// Example:\n//\n//   absl::BitGen gen;\n//\n//   // Use the distribution to produce a value between 1 and 6, inclusive.\n//   int die_roll = absl::uniform_int_distribution<int>(1, 6)(gen);\n//\ntemplate <typename IntType = int>\nclass uniform_int_distribution {\n private:\n  using unsigned_type =\n      typename random_internal::make_unsigned_bits<IntType>::type;\n\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = uniform_int_distribution;\n\n    explicit param_type(\n        result_type lo = 0,\n        result_type hi = (std::numeric_limits<result_type>::max)())\n        : lo_(lo),\n          range_(static_cast<unsigned_type>(hi) -\n                 static_cast<unsigned_type>(lo)) {\n      // [rand.dist.uni.int] precondition 2\n      assert(lo <= hi);\n    }\n\n    result_type a() const { return lo_; }\n    result_type b() const {\n      return static_cast<result_type>(static_cast<unsigned_type>(lo_) + range_);\n    }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.lo_ == b.lo_ && a.range_ == b.range_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class uniform_int_distribution;\n    unsigned_type range() const { return range_; }\n\n    result_type lo_;\n    unsigned_type range_;\n\n    static_assert(random_internal::IsIntegral<result_type>::value,\n                  \"Class-template absl::uniform_int_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };  // param_type\n\n  uniform_int_distribution() : uniform_int_distribution(0) {}\n\n  explicit uniform_int_distribution(\n      result_type lo,\n      result_type hi = (std::numeric_limits<result_type>::max)())\n      : param_(lo, hi) {}\n\n  explicit uniform_int_distribution(const param_type& param) : param_(param) {}\n\n  // uniform_int_distribution<T>::reset()\n  //\n  // Resets the uniform int distribution. Note that this function has no effect\n  // because the distribution already produces independent values.\n  void reset() {}\n\n  template <typename URBG>\n  result_type operator()(URBG& gen) {  // NOLINT(runtime/references)\n    return (*this)(gen, param());\n  }\n\n  template <typename URBG>\n  result_type operator()(\n      URBG& gen, const param_type& param) {  // NOLINT(runtime/references)\n    return static_cast<result_type>(param.a() + Generate(gen, param.range()));\n  }\n\n  result_type a() const { return param_.a(); }\n  result_type b() const { return param_.b(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& params) { param_ = params; }\n\n  result_type(min)() const { return a(); }\n  result_type(max)() const { return b(); }\n\n  friend bool operator==(const uniform_int_distribution& a,\n                         const uniform_int_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const uniform_int_distribution& a,\n                         const uniform_int_distribution& b) {\n    return !(a == b);\n  }\n\n private:\n  // Generates a value in the *closed* interval [0, R]\n  template <typename URBG>\n  unsigned_type Generate(URBG& g,  // NOLINT(runtime/references)\n                         unsigned_type R);\n  param_type param_;\n};\n\n// -----------------------------------------------------------------------------\n// Implementation details follow\n// -----------------------------------------------------------------------------\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const uniform_int_distribution<IntType>& x) {\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os << static_cast<stream_type>(x.a()) << os.fill()\n     << static_cast<stream_type>(x.b());\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename IntType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,\n    uniform_int_distribution<IntType>& x) {\n  using param_type = typename uniform_int_distribution<IntType>::param_type;\n  using result_type = typename uniform_int_distribution<IntType>::result_type;\n  using stream_type =\n      typename random_internal::stream_format_type<IntType>::type;\n\n  stream_type a;\n  stream_type b;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  is >> a >> b;\n  if (!is.fail()) {\n    x.param(\n        param_type(static_cast<result_type>(a), static_cast<result_type>(b)));\n  }\n  return is;\n}\n\ntemplate <typename IntType>\ntemplate <typename URBG>\ntypename random_internal::make_unsigned_bits<IntType>::type\nuniform_int_distribution<IntType>::Generate(\n    URBG& g,  // NOLINT(runtime/references)\n    typename random_internal::make_unsigned_bits<IntType>::type R) {\n  random_internal::FastUniformBits<unsigned_type> fast_bits;\n  unsigned_type bits = fast_bits(g);\n  const unsigned_type Lim = R + 1;\n  if ((R & Lim) == 0) {\n    // If the interval's length is a power of two range, just take the low bits.\n    return bits & R;\n  }\n\n  // Generates a uniform variate on [0, Lim) using fixed-point multiplication.\n  // The above fast-path guarantees that Lim is representable in unsigned_type.\n  //\n  // Algorithm adapted from\n  // http://lemire.me/blog/2016/06/30/fast-random-shuffling/, with added\n  // explanation.\n  //\n  // The algorithm creates a uniform variate `bits` in the interval [0, 2^N),\n  // and treats it as the fractional part of a fixed-point real value in [0, 1),\n  // multiplied by 2^N.  For example, 0.25 would be represented as 2^(N - 2),\n  // because 2^N * 0.25 == 2^(N - 2).\n  //\n  // Next, `bits` and `Lim` are multiplied with a wide-multiply to bring the\n  // value into the range [0, Lim).  The integral part (the high word of the\n  // multiplication result) is then very nearly the desired result.  However,\n  // this is not quite accurate; viewing the multiplication result as one\n  // double-width integer, the resulting values for the sample are mapped as\n  // follows:\n  //\n  // If the result lies in this interval:       Return this value:\n  //        [0, 2^N)                                    0\n  //        [2^N, 2 * 2^N)                              1\n  //        ...                                         ...\n  //        [K * 2^N, (K + 1) * 2^N)                    K\n  //        ...                                         ...\n  //        [(Lim - 1) * 2^N, Lim * 2^N)                Lim - 1\n  //\n  // While all of these intervals have the same size, the result of `bits * Lim`\n  // must be a multiple of `Lim`, and not all of these intervals contain the\n  // same number of multiples of `Lim`.  In particular, some contain\n  // `F = floor(2^N / Lim)` and some contain `F + 1 = ceil(2^N / Lim)`.  This\n  // difference produces a small nonuniformity, which is corrected by applying\n  // rejection sampling to one of the values in the \"larger intervals\" (i.e.,\n  // the intervals containing `F + 1` multiples of `Lim`.\n  //\n  // An interval contains `F + 1` multiples of `Lim` if and only if its smallest\n  // value modulo 2^N is less than `2^N % Lim`.  The unique value satisfying\n  // this property is used as the one for rejection.  That is, a value of\n  // `bits * Lim` is rejected if `(bit * Lim) % 2^N < (2^N % Lim)`.\n\n  using helper = random_internal::wide_multiply<unsigned_type>;\n  auto product = helper::multiply(bits, Lim);\n\n  // Two optimizations here:\n  // * Rejection occurs with some probability less than 1/2, and for reasonable\n  //   ranges considerably less (in particular, less than 1/(F+1)), so\n  //   ABSL_PREDICT_FALSE is apt.\n  // * `Lim` is an overestimate of `threshold`, and doesn't require a divide.\n  if (ABSL_PREDICT_FALSE(helper::lo(product) < Lim)) {\n    // This quantity is exactly equal to `2^N % Lim`, but does not require high\n    // precision calculations: `2^N % Lim` is congruent to `(2^N - Lim) % Lim`.\n    // Ideally this could be expressed simply as `-X` rather than `2^N - X`, but\n    // for types smaller than int, this calculation is incorrect due to integer\n    // promotion rules.\n    const unsigned_type threshold =\n        ((std::numeric_limits<unsigned_type>::max)() - Lim + 1) % Lim;\n    while (helper::lo(product) < threshold) {\n      bits = fast_bits(g);\n      product = helper::multiply(bits, Lim);\n    }\n  }\n\n  return helper::hi(product);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03912",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/uniform_int_distribution.h",
  "source_line": 42,
  "validation_status": "validated"
}