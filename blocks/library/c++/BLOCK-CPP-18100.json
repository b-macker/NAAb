{
  "code": "{\n  ///        // ...                        template<typename T>\n  ///      }                               int method2(T x) {\n  ///    };                                  // ...\n  ///    class C {};                       }\n  ///    }\n  ///                                      int i, j, k;\n  ///\n  ///                                      int method3(int par) {\n  ///                                        // ...\n  ///                                      }\n  ///                                    };\n  ///\n  ///                                    class C {};\n  ///                                    }\n  /// \\endcode\n  /// \\version 14\n  SeparateDefinitionStyle SeparateDefinitionBlocks;\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  /// \\version 13\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : int8_t {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// \\version 3.8\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : int8_t {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  /// \\version 12\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// Using declaration sorting options.\n  enum SortUsingDeclarationsOptions : int8_t {\n    /// Using declarations are never sorted.\n    /// \\code\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Never,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. Sort\n    /// the lists of names lexicographically, and within those groups, names are\n    /// in case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Lexicographic,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. The\n    /// last element of each list is a non-namespace name; all others are\n    /// namespace names. Sort the lists of names lexicographically, where the\n    /// sort order of individual names is that all non-namespace names come\n    /// before all namespace names, and within those groups, names are in\n    /// case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::move;\n    ///    using std::string;\n    ///    using std::chrono::duration_cast;\n    /// \\endcode\n    SUD_LexicographicNumeric,\n  };\n\n  /// Controls if and how clang-format will sort using declarations.\n  /// \\version 5\n  SortUsingDeclarationsOptions SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  /// \\version 3.5\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  /// \\version 9\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  /// \\version 4\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : int8_t {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  /// \\version 12\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  /// \\version 3.7\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  /// \\version 12\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeInheritanceColon;\n\n  /// If ``true``, a space will be added before a JSON colon. For other\n  /// languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead.\n  /// \\code\n  ///    true:                                  false:\n  ///    {                                      {\n  ///      \"key\" : \"value\"              vs.       \"key\": \"value\"\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 17\n  bool SpaceBeforeJsonColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensStyle : int8_t {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach and If macros. This is useful in projects where ForEach/If\n    /// macros are treated as function calls instead of control statements.\n    /// ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for\n    /// backward compatibility.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptControlMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always,\n    /// Configure each individual space before parentheses in\n    /// ``SpaceBeforeParensOptions``.\n    SBPO_Custom,\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  /// \\version 3.5\n  SpaceBeforeParensStyle SpaceBeforeParens;\n\n  /// Precise control over the spacing before parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  struct SpaceBeforeParensCustom {\n    /// If ``true``, put space betwee control statement keywords\n    /// (for/if/while...) and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    if (...) {}                     vs.    if(...) {}\n    /// \\endcode\n    bool AfterControlStatements;\n    /// If ``true``, put space between foreach macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    FOREACH (...)                   vs.    FOREACH(...)\n    ///      <loop-body>                            <loop-body>\n    /// \\endcode\n    bool AfterForeachMacros;\n    /// If ``true``, put a space between function declaration name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f ();                      vs.    void f();\n    /// \\endcode\n    bool AfterFunctionDeclarationName;\n    /// If ``true``, put a space between function definition name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f () {}                    vs.    void f() {}\n    /// \\endcode\n    bool AfterFunctionDefinitionName;\n    /// If ``true``, put space between if macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    IF (...)                        vs.    IF(...)\n    ///      <conditional-body>                     <conditional-body>\n    /// \\endcode\n    bool AfterIfMacros;\n    /// If ``true``, put a space between operator overloading and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void operator++ (int a);        vs.    void operator++(int a);\n    ///    object.operator++ (10);                object.operator++(10);\n    /// \\endcode\n    bool AfterOverloadedOperator;\n    /// If ``true``, put space between requires keyword in a requires clause and\n    /// opening parentheses, if there is one.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    requires (A<T> && B<T>)                requires(A<T> && B<T>)\n    ///    ...                                    ...\n    /// \\endcode\n    bool AfterRequiresInClause;\n    /// If ``true``, put space between requires keyword in a requires expression\n    /// and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    concept C = requires (T t) {           concept C = requires(T t) {\n    ///                  ...                                    ...\n    ///                }                                      }\n    /// \\endcode\n    bool AfterRequiresInExpression;\n    /// If ``true``, put a space before opening parentheses only if the\n    /// parentheses are not empty.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f (int a);                 vs.    void f();\n    ///    f (a);                                 f();\n    /// \\endcode\n    bool BeforeNonEmptyParentheses;\n\n    SpaceBeforeParensCustom()\n        : AfterControlStatements(false), AfterForeachMacros(false),\n          AfterFunctionDeclarationName(false),\n          AfterFunctionDefinitionName(false), AfterIfMacros(false),\n          AfterOverloadedOperator(false), AfterRequiresInClause(false),\n          AfterRequiresInExpression(false), BeforeNonEmptyParentheses(false) {}\n\n    bool operator==(const SpaceBeforeParensCustom &Other) const {\n      return AfterControlStatements == Other.AfterControlStatements &&\n             AfterForeachMacros == Other.AfterForeachMacros &&\n             AfterFunctionDeclarationName ==\n                 Other.AfterFunctionDeclarationName &&\n             AfterFunctionDefinitionName == Other.AfterFunctionDefinitionName &&\n             AfterIfMacros == Other.AfterIfMacros &&\n             AfterOverloadedOperator == Other.AfterOverloadedOperator &&\n             AfterRequiresInClause == Other.AfterRequiresInClause &&\n             AfterRequiresInExpression == Other.AfterRequiresInExpression &&\n             BeforeNonEmptyParentheses == Other.BeforeNonEmptyParentheses;\n    }\n  };\n\n  /// Control of individual space before parentheses.\n  ///\n  /// If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify\n  /// how each individual space before parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  /// \\version 14\n  SpaceBeforeParensCustom SpaceBeforeParensOptions;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  /// \\version 10\n  bool SpaceBeforeSquareBrackets;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  /// \\version 10\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// This option is **deprecated**. See ``InEmptyParentheses`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as those\n  /// commonly have different usage patterns and a number of special cases.  In\n  /// the case of Verilog, it doesn't affect a comment right after the opening\n  /// parenthesis in the port or parameter list in a module header, because it\n  /// is probably for the port on the following line instead of the parenthesis\n  /// it follows.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned SpacesBeforeTrailingComments;\n\n  /// Styles for adding spacing after ``<`` and before ``>``\n  ///  in template argument lists.\n  enum SpacesInAnglesStyle : int8_t {\n    /// Remove spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast<int>(arg);\n    ///    std::function<void(int)> fct;\n    /// \\endcode\n    SIAS_Never,\n    /// Add spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast< int >(arg);\n    ///    std::function< void(int) > fct;\n    /// \\endcode\n    SIAS_Always,\n    /// Keep a single space after ``<`` and before ``>`` if any spaces were\n    /// present. Option ``Standard: Cpp03`` takes precedence.\n    SIAS_Leave\n  };\n  /// The SpacesInAnglesStyle to use for template argument lists.\n  /// \\version 3.4\n  SpacesInAnglesStyle SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// This option is **deprecated**. See ``InConditionalStatements`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 10\n  // bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.  ObjC and\n  /// Javascript array and dict literals). For JSON, use\n  /// ``SpaceBeforeJsonColon`` instead.\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// This option is **deprecated**. See ``InCStyleCasts`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment.\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code\n  ///   Minimum = 1\n  ///   Maximum = -1\n  ///   // One space is forced\n  ///\n  ///   //  but more spaces are possible\n  ///\n  ///   Minimum = 0\n  ///   Maximum = 0\n  ///   //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  ///   before:                                   after:\n  ///   Minimum: 1\n  ///   //if (b) {                                // if (b) {\n  ///   //  return true;                          //   return true;\n  ///   //}                                       // }\n  ///\n  ///   Maximum: 0\n  ///   /// List:                                 ///List:\n  ///   ///  - Foo                                /// - Foo\n  ///   ///    - Bar                              ///   - Bar\n  /// \\endcode\n  ///\n  /// This option has only effect if ``ReflowComments`` is set to ``true``.\n  /// \\version 13\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// Different ways to put a space before opening and closing parentheses.\n  enum SpacesInParensStyle : int8_t {\n    /// Never put a space in parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SIPO_Never,\n    /// Configure each individual space in parentheses in\n    /// `SpacesInParensOptions`.\n    SIPO_Custom,\n  };\n\n  /// If ``true'', spaces will be inserted after ``(`` and before ``)``.\n  /// This option is **deprecated**. The previous behavior is preserved by using\n  /// ``SpacesInParens`` with ``Custom`` and by setting all\n  /// ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and\n  /// ``InEmptyParentheses``.\n  /// \\version 3.7\n  // bool SpacesInParentheses;\n\n  /// Defines in which cases spaces will be inserted after ``(`` and before\n  /// ``)``.\n  /// \\version 17\n  SpacesInParensStyle SpacesInParens;\n\n  /// Precise control over the spacing in parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     Other: true\n  /// \\endcode\n  struct SpacesInParensCustom {\n    /// Put a space in parentheses only inside conditional statements\n    /// (``for/if/while/switch...``).\n    /// \\code\n    ///    true:                                  false:\n    ///    if ( a )  { ... }              vs.     if (a) { ... }\n    ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n    /// \\endcode\n    bool InConditionalStatements;\n    /// Put a space in C style casts.\n    /// \\code\n    ///    true:                                  false:\n    ///    x = ( int32 )y                 vs.     x = (int32)y\n    /// \\endcode\n    bool InCStyleCasts;\n    /// Put a space in parentheses only if the parentheses are empty i.e. '()'\n    /// \\code\n    ///    true:                                false:\n    ///    void f( ) {                    vs.   void f() {\n    ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n    ///      if (true) {                          if (true) {\n    ///        f( );                                f();\n    ///      }                                    }\n    ///    }                                    }\n    /// \\endcode\n    bool InEmptyParentheses;\n    /// Put a space in parentheses not covered by preceding options.\n    /// \\code\n    ///    true:                                  false:\n    ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n    /// \\endcode\n    bool Other;\n\n    SpacesInParensCustom()\n        : InConditionalStatements(false), InCStyleCasts(false),\n          InEmptyParentheses(false), Other(false) {}\n\n    SpacesInParensCustom(bool InConditionalStatements, bool InCStyleCasts,\n        bool InEmptyParentheses, bool Other)\n        : InConditionalStatements(InConditionalStatements),\n          InCStyleCasts(InCStyleCasts),\n          InEmptyParentheses(InEmptyParentheses),\n          Other(Other) {}\n\n    bool operator==(const SpacesInParensCustom &R) const {\n      return InConditionalStatements == R.InConditionalStatements &&\n             InCStyleCasts == R.InCStyleCasts &&\n             InEmptyParentheses == R.InEmptyParentheses &&\n             Other == R.Other;\n    }\n    bool operator!=(const SpacesInParensCustom &R) const {\n      return !(*this == R);\n    }\n  };\n\n  /// Control of individual spaces in parentheses.\n  ///\n  /// If ``SpacesInParens`` is set to ``Custom``, use this to specify\n  /// how each individual space in parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     InEmptyParentheses: true\n  /// \\endcode\n  /// \\version 17\n  SpacesInParensCustom SpacesInParensOptions;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInSquareBrackets;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : int8_t {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  /// \\version 3.7\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  /// \\version 12\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  /// \\version 8\n  std::vector<std::string> StatementMacros;\n\n  /// The number of columns used for tab stops.\n  /// \\version 3.7\n  unsigned TabWidth;\n\n  /// A vector of non-keyword identifiers that should be interpreted as type\n  /// names.\n  ///\n  /// A ``*``, ``&``, or ``&&`` between a type name and another non-keyword\n  /// identifier is annotated as a pointer or reference token instead of a\n  /// binary operator.\n  ///\n  /// \\version 17\n  std::vector<std::string> TypeNames;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  /// \\version 9\n  std::vector<std::string> TypenameMacros;\n\n  /// This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``.\n  /// \\version 10\n  // bool UseCRLF;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : int8_t {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// The way to use tab characters in the resulting file.\n  /// \\version 3.7\n  UseTabStyle UseTab;\n\n  /// For Verilog, put each port on its own line in module instantiations.\n  /// \\code\n  ///    true:\n  ///    ffnand ff1(.q(),\n  ///               .qbar(out1),\n  ///               .clear(in1),\n  ///               .preset(in2));\n  ///\n  ///    false:\n  ///    ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));\n  /// \\endcode\n  /// \\version 17\n  bool VerilogBreakBetweenInstancePorts;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  /// \\version 11\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignArrayOfStructures == R.AlignArrayOfStructures &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignConsecutiveShortCaseStatements ==\n               R.AlignConsecutiveShortCaseStatements &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           BracedInitializerIndentWidth == R.BracedInitializerIndentWidth &&\n           BreakAfterAttributes == R.BreakAfterAttributes &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakArrays == R.BreakArrays &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeInlineASMColon == R.BreakBeforeInlineASMColon &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           CompactNamespaces == R.CompactNamespaces &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineAfterAccessModifier == R.EmptyLineAfterAccessModifier &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentRequiresClause == R.IndentRequiresClause &&\n           IndentWidth == R.IndentWidth &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           InsertBraces == R.InsertBraces &&\n           InsertNewlineAtEOF == R.InsertNewlineAtEOF &&\n           IntegerLiteralSeparator == R.IntegerLiteralSeparator &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtEOF == R.KeepEmptyLinesAtEOF &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           Language == R.Language &&\n           LambdaBodyIndentation == R.LambdaBodyIndentation &&\n           LineEnding == R.LineEnding && MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd && Macros == R.Macros &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PackConstructorInitializers == R.PackConstructorInitializers &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakOpenParenthesis == R.PenaltyBreakOpenParenthesis &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PointerAlignment == R.PointerAlignment &&\n           QualifierAlignment == R.QualifierAlignment &&\n           QualifierOrder == R.QualifierOrder &&\n           RawStringFormats == R.RawStringFormats &&\n           ReferenceAlignment == R.ReferenceAlignment &&\n           RemoveBracesLLVM == R.RemoveBracesLLVM &&\n           RemoveParentheses == R.RemoveParentheses &&\n           RemoveSemicolon == R.RemoveSemicolon &&\n           RequiresClausePosition == R.RequiresClausePosition &&\n           RequiresExpressionIndentation == R.RequiresExpressionIndentation &&\n           SeparateDefinitionBlocks == R.SeparateDefinitionBlocks &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeJsonColon == R.SpaceBeforeJsonColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceBeforeParensOptions == R.SpaceBeforeParensOptions &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParens == R.SpacesInParens &&\n           SpacesInParensOptions == R.SpacesInParensOptions &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           TypeNames == R.TypeNames && TypenameMacros == R.TypenameMacros &&\n           UseTab == R.UseTab &&\n           VerilogBreakBetweenInstancePorts ==\n               R.VerilogBreakBetweenInstancePorts &&\n           WhitespaceSensitiveMacros == R.WhitespaceSensitiveMacros;\n  }\n\n  std::optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    std::optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n}",
  "id": "BLOCK-CPP-18100",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 3683,
  "validation_status": "validated"
}