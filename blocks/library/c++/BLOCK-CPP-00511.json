{
  "code": "{\n\nnamespace win_eventlog {\n\nnamespace internal {\n\nstruct local_alloc_t {\n    HLOCAL hlocal_;\n\n    SPDLOG_CONSTEXPR local_alloc_t() SPDLOG_NOEXCEPT : hlocal_(nullptr) {}\n\n    local_alloc_t(local_alloc_t const &) = delete;\n    local_alloc_t &operator=(local_alloc_t const &) = delete;\n\n    ~local_alloc_t() SPDLOG_NOEXCEPT {\n        if (hlocal_) {\n            LocalFree(hlocal_);\n        }\n    }\n};\n\n/** Windows error */\nstruct win32_error : public spdlog_ex {\n    /** Formats an error report line: \"user-message: error-code (system message)\" */\n    static std::string format(std::string const &user_message, DWORD error_code = GetLastError()) {\n        std::string system_message;\n\n        local_alloc_t format_message_result{};\n        auto format_message_succeeded =\n            ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n                                 FORMAT_MESSAGE_IGNORE_INSERTS,\n                             nullptr, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                             (LPSTR)&format_message_result.hlocal_, 0, nullptr);\n\n        if (format_message_succeeded && format_message_result.hlocal_) {\n            system_message = fmt_lib::format(\" ({})\", (LPSTR)format_message_result.hlocal_);\n        }\n\n        return fmt_lib::format(\"{}: {}{}\", user_message, error_code, system_message);\n    }\n\n    explicit win32_error(std::string const &func_name, DWORD error = GetLastError())\n        : spdlog_ex(format(func_name, error)) {}\n};\n\n/** Wrapper for security identifiers (SID) on Windows */\nstruct sid_t {\n    std::vector<char> buffer_;\n\npublic:\n    sid_t() {}\n\n    /** creates a wrapped SID copy */\n    static sid_t duplicate_sid(PSID psid) {\n        if (!::IsValidSid(psid)) {\n            throw_spdlog_ex(\"sid_t::sid_t(): invalid SID received\");\n        }\n\n        auto const sid_length{::GetLengthSid(psid)};\n\n        sid_t result;\n        result.buffer_.resize(sid_length);\n        if (!::CopySid(sid_length, (PSID)result.as_sid(), psid)) {\n            SPDLOG_THROW(win32_error(\"CopySid\"));\n        }\n\n        return result;\n    }\n\n    /** Retrieves pointer to the internal buffer contents as SID* */\n    SID *as_sid() const { return buffer_.empty() ? nullptr : (SID *)buffer_.data(); }\n\n    /** Get SID for the current user */\n    static sid_t get_current_user_sid() {\n        /* create and init RAII holder for process token */\n        struct process_token_t {\n            HANDLE token_handle_ = INVALID_HANDLE_VALUE;\n            explicit process_token_t(HANDLE process) {\n                if (!::OpenProcessToken(process, TOKEN_QUERY, &token_handle_)) {\n                    SPDLOG_THROW(win32_error(\"OpenProcessToken\"));\n                }\n            }\n\n            ~process_token_t() { ::CloseHandle(token_handle_); }\n\n        } current_process_token(\n            ::GetCurrentProcess());  // GetCurrentProcess returns pseudohandle, no leak here!\n\n        // Get the required size, this is expected to fail with ERROR_INSUFFICIENT_BUFFER and return\n        // the token size\n        DWORD tusize = 0;\n        if (::GetTokenInformation(current_process_token.token_handle_, TokenUser, NULL, 0,\n                                  &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation should fail\"));\n        }\n\n        // get user token\n        std::vector<unsigned char> buffer(static_cast<size_t>(tusize));\n        if (!::GetTokenInformation(current_process_token.token_handle_, TokenUser,\n                                   (LPVOID)buffer.data(), tusize, &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation\"));\n        }\n\n        // create a wrapper of the SID data as stored in the user token\n        return sid_t::duplicate_sid(((TOKEN_USER *)buffer.data())->User.Sid);\n    }\n};\n\nstruct eventlog {\n    static WORD get_event_type(details::log_msg const &msg) {\n        switch (msg.level) {\n            case level::trace:\n            case level::debug:\n                return EVENTLOG_SUCCESS;\n\n            case level::info:\n                return EVENTLOG_INFORMATION_TYPE;\n\n            case level::warn:\n                return EVENTLOG_WARNING_TYPE;\n\n            case level::err:\n            case level::critical:\n            case level::off:\n                return EVENTLOG_ERROR_TYPE;\n\n            default:\n                return EVENTLOG_INFORMATION_TYPE;\n        }\n    }\n\n    static WORD get_event_category(details::log_msg const &msg) { return (WORD)msg.level; }\n};\n\n}  // namespace internal\n\n/*\n * Windows Event Log sink\n */\ntemplate <typename Mutex>\nclass win_eventlog_sink : public base_sink<Mutex> {\nprivate:\n    HANDLE hEventLog_{NULL};\n    internal::sid_t current_user_sid_;\n    std::string source_;\n    DWORD event_id_;\n\n    HANDLE event_log_handle() {\n        if (!hEventLog_) {\n            hEventLog_ = ::RegisterEventSourceA(nullptr, source_.c_str());\n            if (!hEventLog_ || hEventLog_ == (HANDLE)ERROR_ACCESS_DENIED) {\n                SPDLOG_THROW(internal::win32_error(\"RegisterEventSource\"));\n            }\n        }\n\n        return hEventLog_;\n    }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        using namespace internal;\n\n        bool succeeded;\n        memory_buf_t formatted;\n        base_sink<Mutex>::formatter_->format(msg, formatted);\n        formatted.push_back('\\0');\n\n#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\n        wmemory_buf_t buf;\n        details::os::utf8_to_wstrbuf(string_view_t(formatted.data(), formatted.size()), buf);\n\n        LPCWSTR lp_wstr = buf.data();\n        succeeded = static_cast<bool>(::ReportEventW(\n            event_log_handle(), eventlog::get_event_type(msg), eventlog::get_event_category(msg),\n            event_id_, current_user_sid_.as_sid(), 1, 0, &lp_wstr, nullptr));\n#else\n        LPCSTR lp_str = formatted.data();\n        succeeded = static_cast<bool>(::ReportEventA(\n            event_log_handle(), eventlog::get_event_type(msg), eventlog::get_event_category(msg),\n            event_id_, current_user_sid_.as_sid(), 1, 0, &lp_str, nullptr));\n#endif\n\n        if (!succeeded) {\n            SPDLOG_THROW(win32_error(\"ReportEvent\"));\n        }\n    }\n\n    void flush_() override {}\n\npublic:\n    win_eventlog_sink(std::string const &source,\n                      DWORD event_id = 1000 /* according to mscoree.dll */)\n        : source_(source),\n          event_id_(event_id) {\n        try {\n            current_user_sid_ = internal::sid_t::get_current_user_sid();\n        } catch (...) {\n            // get_current_user_sid() is unlikely to fail and if it does, we can still proceed\n            // without current_user_sid but in the event log the record will have no user name\n        }\n    }\n\n    ~win_eventlog_sink() {\n        if (hEventLog_) DeregisterEventSource(hEventLog_);\n    }\n};\n\n}  // namespace win_eventlog\n\nusing win_eventlog_sink_mt = win_eventlog::win_eventlog_sink<std::mutex>;\nusing win_eventlog_sink_st = win_eventlog::win_eventlog_sink<details::null_mutex>;\n\n}",
  "id": "BLOCK-CPP-00511",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/win_eventlog_sink.h",
  "source_line": 47,
  "validation_status": "validated"
}