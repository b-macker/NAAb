{
  "code": "{\n public:\n  // DefaultInitType forces the use of the default initialization constructor.\n  enum DefaultInitType { kDefaultInit };\n\n  // kNullCordzInfo holds the little endian representation of intptr_t(1)\n  // This is the 'null' / initial value of 'cordz_info'. The null value\n  // is specifically big endian 1 as with 64-bit pointers, the last\n  // byte of cordz_info overlaps with the last byte holding the tag.\n  static constexpr cordz_info_t kNullCordzInfo = LittleEndianByte(1);\n\n  // kTagOffset contains the offset of the control byte / tag. This constant is\n  // intended mostly for debugging purposes: do not remove this constant as it\n  // is actively inspected and used by gdb pretty printing code.\n  static constexpr size_t kTagOffset = 0;\n\n  // Implement `~InlineData()` conditionally: we only need this destructor to\n  // unpoison poisoned instances under *SAN, and it will only compile correctly\n  // if the current compiler supports `absl::is_constant_evaluated()`.\n#ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER\n  ~InlineData() noexcept { unpoison(); }\n#endif\n\n  constexpr InlineData() noexcept { poison_this(); }\n\n  explicit InlineData(DefaultInitType) noexcept : rep_(kDefaultInit) {\n    poison_this();\n  }\n\n  explicit InlineData(CordRep* rep) noexcept : rep_(rep) {\n    ABSL_ASSERT(rep != nullptr);\n  }\n\n  // Explicit constexpr constructor to create a constexpr InlineData\n  // value. Creates an inlined SSO value if `rep` is null, otherwise\n  // creates a tree instance value.\n  constexpr InlineData(absl::string_view sv, CordRep* rep) noexcept\n      : rep_(rep ? Rep(rep) : Rep(sv)) {\n    poison();\n  }\n\n  constexpr InlineData(const InlineData& rhs) noexcept;\n  InlineData& operator=(const InlineData& rhs) noexcept;\n\n  friend bool operator==(const InlineData& lhs, const InlineData& rhs) {\n#ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER\n    const Rep l = lhs.rep_.SanitizerSafeCopy();\n    const Rep r = rhs.rep_.SanitizerSafeCopy();\n    return memcmp(&l, &r, sizeof(l)) == 0;\n#else\n    return memcmp(&lhs, &rhs, sizeof(lhs)) == 0;\n#endif\n  }\n  friend bool operator!=(const InlineData& lhs, const InlineData& rhs) {\n    return !operator==(lhs, rhs);\n  }\n\n  // Poisons the unused inlined SSO data if the current instance\n  // is inlined, else un-poisons the entire instance.\n  constexpr void poison();\n\n  // Un-poisons this instance.\n  constexpr void unpoison();\n\n  // Poisons the current instance. This is used on default initialization.\n  constexpr void poison_this();\n\n  // Returns true if the current instance is empty.\n  // The 'empty value' is an inlined data value of zero length.\n  bool is_empty() const { return rep_.tag() == 0; }\n\n  // Returns true if the current instance holds a tree value.\n  bool is_tree() const { return (rep_.tag() & 1) != 0; }\n\n  // Returns true if the current instance holds a cordz_info value.\n  // Requires the current instance to hold a tree value.\n  bool is_profiled() const {\n    assert(is_tree());\n    return rep_.cordz_info() != kNullCordzInfo;\n  }\n\n  // Returns true if either of the provided instances hold a cordz_info value.\n  // This method is more efficient than the equivalent `data1.is_profiled() ||\n  // data2.is_profiled()`. Requires both arguments to hold a tree.\n  static bool is_either_profiled(const InlineData& data1,\n                                 const InlineData& data2) {\n    assert(data1.is_tree() && data2.is_tree());\n    return (data1.rep_.cordz_info() | data2.rep_.cordz_info()) !=\n           kNullCordzInfo;\n  }\n\n  // Returns the cordz_info sampling instance for this instance, or nullptr\n  // if the current instance is not sampled and does not have CordzInfo data.\n  // Requires the current instance to hold a tree value.\n  CordzInfo* cordz_info() const {\n    assert(is_tree());\n    intptr_t info = static_cast<intptr_t>(absl::little_endian::ToHost64(\n        static_cast<uint64_t>(rep_.cordz_info())));\n    assert(info & 1);\n    return reinterpret_cast<CordzInfo*>(info - 1);\n  }\n\n  // Sets the current cordz_info sampling instance for this instance, or nullptr\n  // if the current instance is not sampled and does not have CordzInfo data.\n  // Requires the current instance to hold a tree value.\n  void set_cordz_info(CordzInfo* cordz_info) {\n    assert(is_tree());\n    uintptr_t info = reinterpret_cast<uintptr_t>(cordz_info) | 1;\n    rep_.set_cordz_info(\n        static_cast<cordz_info_t>(absl::little_endian::FromHost64(info)));\n  }\n\n  // Resets the current cordz_info to null / empty.\n  void clear_cordz_info() {\n    assert(is_tree());\n    rep_.set_cordz_info(kNullCordzInfo);\n  }\n\n  // Returns a read only pointer to the character data inside this instance.\n  // Requires the current instance to hold inline data.\n  const char* as_chars() const {\n    assert(!is_tree());\n    return rep_.as_chars();\n  }\n\n  // Returns a mutable pointer to the character data inside this instance.\n  // Should be used for 'write only' operations setting an inlined value.\n  // Applications can set the value of inlined data either before or after\n  // setting the inlined size, i.e., both of the below are valid:\n  //\n  //   // Set inlined data and inline size\n  //   memcpy(data_.as_chars(), data, size);\n  //   data_.set_inline_size(size);\n  //\n  //   // Set inlined size and inline data\n  //   data_.set_inline_size(size);\n  //   memcpy(data_.as_chars(), data, size);\n  //\n  // It's an error to read from the returned pointer without a preceding write\n  // if the current instance does not hold inline data, i.e.: is_tree() == true.\n  char* as_chars() { return rep_.as_chars(); }\n\n  // Returns the tree value of this value.\n  // Requires the current instance to hold a tree value.\n  CordRep* as_tree() const {\n    assert(is_tree());\n    return rep_.tree();\n  }\n\n  void set_inline_data(const char* data, size_t n) {\n    ABSL_ASSERT(n <= kMaxInline);\n    unpoison();\n    rep_.set_tag(static_cast<int8_t>(n << 1));\n    SmallMemmove<true>(rep_.as_chars(), data, n);\n    poison();\n  }\n\n  void copy_max_inline_to(char* dst) const {\n    assert(!is_tree());\n    memcpy(dst, rep_.SanitizerSafeCopy().as_chars(), kMaxInline);\n  }\n\n  // Initialize this instance to holding the tree value `rep`,\n  // initializing the cordz_info to null, i.e.: 'not profiled'.\n  void make_tree(CordRep* rep) {\n    unpoison();\n    rep_.make_tree(rep);\n  }\n\n  // Set the tree value of this instance to 'rep`.\n  // Requires the current instance to already hold a tree value.\n  // Does not affect the value of cordz_info.\n  void set_tree(CordRep* rep) {\n    assert(is_tree());\n    rep_.set_tree(rep);\n  }\n\n  // Returns the size of the inlined character data inside this instance.\n  // Requires the current instance to hold inline data.\n  size_t inline_size() const { return rep_.inline_size(); }\n\n  // Sets the size of the inlined character data inside this instance.\n  // Requires `size` to be <= kMaxInline.\n  // See the documentation on 'as_chars()' for more information and examples.\n  void set_inline_size(size_t size) {\n    unpoison();\n    rep_.set_inline_size(size);\n    poison();\n  }\n\n  // Compares 'this' inlined data  with rhs. The comparison is a straightforward\n  // lexicographic comparison. `Compare()` returns values as follows:\n  //\n  //   -1  'this' InlineData instance is smaller\n  //    0  the InlineData instances are equal\n  //    1  'this' InlineData instance larger\n  int Compare(const InlineData& rhs) const {\n    return Compare(rep_.SanitizerSafeCopy(), rhs.rep_.SanitizerSafeCopy());\n  }\n\n private:\n  struct Rep {\n    // See cordz_info_t for forced alignment and size of `cordz_info` details.\n    struct AsTree {\n      explicit constexpr AsTree(absl::cord_internal::CordRep* tree)\n          : rep(tree) {}\n      cordz_info_t cordz_info = kNullCordzInfo;\n      absl::cord_internal::CordRep* rep;\n    };\n\n    explicit Rep(DefaultInitType) {}\n    constexpr Rep() : data{0} {}\n    constexpr Rep(const Rep&) = default;\n    constexpr Rep& operator=(const Rep&) = default;\n\n    explicit constexpr Rep(CordRep* rep) : as_tree(rep) {}\n\n    explicit constexpr Rep(absl::string_view chars)\n        : data{static_cast<char>((chars.size() << 1)),\n               GetOrNull(chars, 0),\n               GetOrNull(chars, 1),\n               GetOrNull(chars, 2),\n               GetOrNull(chars, 3),\n               GetOrNull(chars, 4),\n               GetOrNull(chars, 5),\n               GetOrNull(chars, 6),\n               GetOrNull(chars, 7),\n               GetOrNull(chars, 8),\n               GetOrNull(chars, 9),\n               GetOrNull(chars, 10),\n               GetOrNull(chars, 11),\n               GetOrNull(chars, 12),\n               GetOrNull(chars, 13),\n               GetOrNull(chars, 14)} {}\n\n    // Disable sanitizer as we must always be able to read `tag`.\n    ABSL_CORD_INTERNAL_NO_SANITIZE\n    int8_t tag() const { return reinterpret_cast<const int8_t*>(this)[0]; }\n    void set_tag(int8_t rhs) { reinterpret_cast<int8_t*>(this)[0] = rhs; }\n\n    char* as_chars() { return data + 1; }\n    const char* as_chars() const { return data + 1; }\n\n    bool is_tree() const { return (tag() & 1) != 0; }\n\n    size_t inline_size() const {\n      ABSL_ASSERT(!is_tree());\n      return static_cast<size_t>(tag()) >> 1;\n    }\n\n    void set_inline_size(size_t size) {\n      ABSL_ASSERT(size <= kMaxInline);\n      set_tag(static_cast<int8_t>(size << 1));\n    }\n\n    CordRep* tree() const { return as_tree.rep; }\n    void set_tree(CordRep* rhs) { as_tree.rep = rhs; }\n\n    cordz_info_t cordz_info() const { return as_tree.cordz_info; }\n    void set_cordz_info(cordz_info_t rhs) { as_tree.cordz_info = rhs; }\n\n    void make_tree(CordRep* tree) {\n      as_tree.rep = tree;\n      as_tree.cordz_info = kNullCordzInfo;\n    }\n\n#ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER\n    constexpr Rep SanitizerSafeCopy() const {\n      if (!absl::is_constant_evaluated()) {\n        Rep res;\n        if (is_tree()) {\n          res = *this;\n        } else {\n          res.set_tag(tag());\n          memcpy(res.as_chars(), as_chars(), inline_size());\n        }\n        return res;\n      } else {\n        return *this;\n      }\n    }\n#else\n    constexpr const Rep& SanitizerSafeCopy() const { return *this; }\n#endif\n\n    // If the data has length <= kMaxInline, we store it in `data`, and\n    // store the size in the first char of `data` shifted left + 1.\n    // Else we store it in a tree and store a pointer to that tree in\n    // `as_tree.rep` with a tagged pointer to make `tag() & 1` non zero.\n    union {\n      char data[kMaxInline + 1];\n      AsTree as_tree;\n    };\n  };\n\n  // Private implementation of `Compare()`\n  static inline int Compare(const Rep& lhs, const Rep& rhs) {\n    uint64_t x, y;\n    memcpy(&x, lhs.as_chars(), sizeof(x));\n    memcpy(&y, rhs.as_chars(), sizeof(y));\n    if (x == y) {\n      memcpy(&x, lhs.as_chars() + 7, sizeof(x));\n      memcpy(&y, rhs.as_chars() + 7, sizeof(y));\n      if (x == y) {\n        if (lhs.inline_size() == rhs.inline_size()) return 0;\n        return lhs.inline_size() < rhs.inline_size() ? -1 : 1;\n      }\n    }\n    x = absl::big_endian::FromHost64(x);\n    y = absl::big_endian::FromHost64(y);\n    return x < y ? -1 : 1;\n  }\n\n  Rep rep_;\n}",
  "id": "BLOCK-CPP-06111",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_internal.h",
  "source_line": 480,
  "validation_status": "validated"
}