{
  "code": "#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <optional>\n#include <string>\n#include <utility>\n    /// Code completion inside the filename part of a #include directive.\n\nusing namespace clang;\nusing namespace or;\nusing namespace or;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-19458_execute() {\n    {\npublic:\n  /// The different kinds of \"chunks\" that can occur within a code\n  /// completion string.\n  enum ChunkKind {\n    /// The piece of text that the user is expected to type to\n    /// match the code-completion string, typically a keyword or the name of a\n    /// declarator or macro.\n    CK_TypedText,\n\n    /// A piece of text that should be placed in the buffer, e.g.,\n    /// parentheses or a comma in a function call.\n    CK_Text,\n\n    /// A code completion string that is entirely optional. For example,\n    /// an optional code completion string that describes the default arguments\n    /// in a function call.\n    CK_Optional,\n\n    /// A string that acts as a placeholder for, e.g., a function\n    /// call argument.\n    CK_Placeholder,\n\n    /// A piece of text that describes something about the result but\n    /// should not be inserted into the buffer.\n    CK_Informative,\n    /// A piece of text that describes the type of an entity or, for\n    /// functions and methods, the return type.\n    CK_ResultType,\n\n    /// A piece of text that describes the parameter that corresponds\n    /// to the code-completion location within a function call, message send,\n    /// macro invocation, etc.\n    CK_CurrentParameter,\n\n    /// A left parenthesis ('(').\n    CK_LeftParen,\n\n    /// A right parenthesis (')').\n    CK_RightParen,\n\n    /// A left bracket ('[').\n    CK_LeftBracket,\n\n    /// A right bracket (']').\n    CK_RightBracket,\n\n    /// A left brace ('{').\n    CK_LeftBrace,\n\n    /// A right brace ('}').\n    CK_RightBrace,\n\n    /// A left angle bracket ('<').\n    CK_LeftAngle,\n\n    /// A right angle bracket ('>').\n    CK_RightAngle,\n\n    /// A comma separator (',').\n    CK_Comma,\n\n    /// A colon (':').\n    CK_Colon,\n\n    /// A semicolon (';').\n    CK_SemiColon,\n\n    /// An '=' sign.\n    CK_Equal,\n\n    /// Horizontal whitespace (' ').\n    CK_HorizontalSpace,\n\n    /// Vertical whitespace ('\\\\n' or '\\\\r\\\\n', depending on the\n    /// platform).\n    CK_VerticalSpace\n  };\n\n  /// One piece of the code completion string.\n  struct Chunk {\n    /// The kind of data stored in this piece of the code completion\n    /// string.\n    ChunkKind Kind = CK_Text;\n\n    union {\n      /// The text string associated with a CK_Text, CK_Placeholder,\n      /// CK_Informative, or CK_Comma chunk.\n      /// The string is owned by the chunk and will be deallocated\n      /// (with delete[]) when the chunk is destroyed.\n      const char *Text;\n\n      /// The code completion string associated with a CK_Optional chunk.\n      /// The optional code completion string is owned by the chunk, and will\n      /// be deallocated (with delete) when the chunk is destroyed.\n      CodeCompletionString *Optional;\n    };\n\n    Chunk() : Text(nullptr) {}\n\n    explicit Chunk(ChunkKind Kind, const char *Text = \"\");\n\n    /// Create a new text chunk.\n    static Chunk CreateText(const char *Text);\n\n    /// Create a new optional chunk.\n    static Chunk CreateOptional(CodeCompletionString *Optional);\n\n    /// Create a new placeholder chunk.\n    static Chunk CreatePlaceholder(const char *Placeholder);\n\n    /// Create a new informative chunk.\n    static Chunk CreateInformative(const char *Informative);\n\n    /// Create a new result type chunk.\n    static Chunk CreateResultType(const char *ResultType);\n\n    /// Create a new current-parameter chunk.\n    static Chunk CreateCurrentParameter(const char *CurrentParameter);\n  };\n\nprivate:\n  friend class CodeCompletionBuilder;\n  friend class CodeCompletionResult;\n\n  /// The number of chunks stored in this string.\n  unsigned NumChunks : 16;\n\n  /// The number of annotations for this code-completion result.\n  unsigned NumAnnotations : 16;\n\n  /// The priority of this code-completion string.\n  unsigned Priority : 16;\n\n  /// The availability of this code-completion result.\n  unsigned Availability : 2;\n\n  /// The name of the parent context.\n  StringRef ParentName;\n\n  /// A brief documentation comment attached to the declaration of\n  /// entity being completed by this result.\n  const char *BriefComment;\n\n  CodeCompletionString(const Chunk *Chunks, unsigned NumChunks,\n                       unsigned Priority, CXAvailabilityKind Availability,\n                       const char **Annotations, unsigned NumAnnotations,\n                       StringRef ParentName,\n                       const char *BriefComment);\n  ~CodeCompletionString() = default;\n\npublic:\n  CodeCompletionString(const CodeCompletionString &) = delete;\n  CodeCompletionString &operator=(const CodeCompletionString &) = delete;\n\n  using iterator = const Chunk *;\n\n  iterator begin() const { return reinterpret_cast<const Chunk *>(this + 1); }\n  iterator end() const { return begin() + NumChunks; }\n  bool empty() const { return NumChunks == 0; }\n  unsigned size() const { return NumChunks; }\n\n  const Chunk &operator[](unsigned I) const {\n    assert(I < size() && \"Chunk index out-of-range\");\n    return begin()[I];\n  }\n\n  /// Returns the text in the first TypedText chunk.\n  const char *getTypedText() const;\n\n  /// Returns the combined text from all TypedText chunks.\n  std::string getAllTypedText() const;\n\n  /// Retrieve the priority of this code completion result.\n  unsigned getPriority() const { return Priority; }\n\n  /// Retrieve the availability of this code completion result.\n  unsigned getAvailability() const { return Availability; }\n\n  /// Retrieve the number of annotations for this code completion result.\n  unsigned getAnnotationCount() const;\n\n  /// Retrieve the annotation string specified by \\c AnnotationNr.\n  const char *getAnnotation(unsigned AnnotationNr) const;\n\n  /// Retrieve the name of the parent context.\n  StringRef getParentContextName() const {\n    return ParentName;\n  }\n\n  const char *getBriefComment() const {\n    return BriefComment;\n  }\n\n  /// Retrieve a string representation of the code completion string,\n  /// which is mainly useful for debugging.\n  std::string getAsString() const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-19458",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/CodeCompleteConsumer.h",
  "source_line": 444,
  "validation_status": "validated"
}