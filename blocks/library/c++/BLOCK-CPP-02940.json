{
  "code": "#include \"absl/strings/internal/escaping.h\"\n#include \"absl/base/internal/endian.h\"\n#include \"absl/base/internal/raw_logging.h\"\n\nusing namespace absl;\nusing namespace strings_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02940_execute() {\n    {\n  static const char kPad64 = '=';\n\n  if (szsrc * 4 > szdest * 3) return 0;\n\n  char* cur_dest = dest;\n  const unsigned char* cur_src = src;\n\n  char* const limit_dest = dest + szdest;\n  const unsigned char* const limit_src = src + szsrc;\n\n  // (from https://tools.ietf.org/html/rfc3548)\n  // Special processing is performed if fewer than 24 bits are available\n  // at the end of the data being encoded.  A full encoding quantum is\n  // always completed at the end of a quantity.  When fewer than 24 input\n  // bits are available in an input group, zero bits are added (on the\n  // right) to form an integral number of 6-bit groups.\n  //\n  // If do_padding is true, padding at the end of the data is performed. This\n  // output padding uses the '=' character.\n\n  // Three bytes of data encodes to four characters of cyphertext.\n  // So we can pump through three-byte chunks atomically.\n  if (szsrc >= 3) {                    // \"limit_src - 3\" is UB if szsrc < 3.\n    while (cur_src < limit_src - 3) {  // While we have >= 32 bits.\n      uint32_t in = absl::big_endian::Load32(cur_src) >> 8;\n\n      cur_dest[0] = base64[in >> 18];\n      in &= 0x3FFFF;\n      cur_dest[1] = base64[in >> 12];\n      in &= 0xFFF;\n      cur_dest[2] = base64[in >> 6];\n      in &= 0x3F;\n      cur_dest[3] = base64[in];\n\n      cur_dest += 4;\n      cur_src += 3;\n    }\n  }\n  // To save time, we didn't update szdest or szsrc in the loop.  So do it now.\n  szdest = static_cast<size_t>(limit_dest - cur_dest);\n  szsrc = static_cast<size_t>(limit_src - cur_src);\n\n  /* now deal with the tail (<=3 bytes) */\n  switch (szsrc) {\n    case 0:\n      // Nothing left; nothing more to do.\n      break;\n    case 1: {\n      // One byte left: this encodes to two characters, and (optionally)\n      // two pad characters to round out the four-character cypherblock.\n      if (szdest < 2) return 0;\n      uint32_t in = cur_src[0];\n      cur_dest[0] = base64[in >> 2];\n      in &= 0x3;\n      cur_dest[1] = base64[in << 4];\n      cur_dest += 2;\n      szdest -= 2;\n      if (do_padding) {\n        if (szdest < 2) return 0;\n        cur_dest[0] = kPad64;\n        cur_dest[1] = kPad64;\n        cur_dest += 2;\n        szdest -= 2;\n      }\n      break;\n    }\n    case 2: {\n      // Two bytes left: this encodes to three characters, and (optionally)\n      // one pad character to round out the four-character cypherblock.\n      if (szdest < 3) return 0;\n      uint32_t in = absl::big_endian::Load16(cur_src);\n      cur_dest[0] = base64[in >> 10];\n      in &= 0x3FF;\n      cur_dest[1] = base64[in >> 4];\n      in &= 0x00F;\n      cur_dest[2] = base64[in << 2];\n      cur_dest += 3;\n      szdest -= 3;\n      if (do_padding) {\n        if (szdest < 1) return 0;\n        cur_dest[0] = kPad64;\n        cur_dest += 1;\n        szdest -= 1;\n      }\n      break;\n    }\n    case 3: {\n      // Three bytes left: same as in the big loop above.  We can't do this in\n      // the loop because the loop above always reads 4 bytes, and the fourth\n      // byte is past the end of the input.\n      if (szdest < 4) return 0;\n      uint32_t in =\n          (uint32_t{cur_src[0]} << 16) + absl::big_endian::Load16(cur_src + 1);\n      cur_dest[0] = base64[in >> 18];\n      in &= 0x3FFFF;\n      cur_dest[1] = base64[in >> 12];\n      in &= 0xFFF;\n      cur_dest[2] = base64[in >> 6];\n      in &= 0x3F;\n      cur_dest[3] = base64[in];\n      cur_dest += 4;\n      szdest -= 4;\n      break;\n    }\n    default:\n      // Should not be reached: blocks of 4 bytes are handled\n      // in the while loop before this switch statement.\n      ABSL_RAW_LOG(FATAL, \"Logic problem? szsrc = %zu\", szsrc);\n      break;\n  }\n  return static_cast<size_t>(cur_dest - dest);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02940",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/escaping.cc",
  "source_line": 88,
  "validation_status": "validated"
}