{
  "code": "{\nnamespace {\n\n#if defined(__EMSCRIPTEN__)\n// Workaround __EMSCRIPTEN__ error: llvm_fma_f64 not found.\ninline double fma(double x, double y, double z) {\n  return (x * y) + z;\n}\n#endif\n\n// Use Horner's method to evaluate a polynomial.\ntemplate <typename T, unsigned N>\ninline T EvaluatePolynomial(T x, const T (&poly)[N]) {\n#if !defined(__EMSCRIPTEN__)\n  using std::fma;\n#endif\n  T p = poly[N - 1];\n  for (unsigned i = 2; i <= N; i++) {\n    p = fma(p, x, poly[N - i]);\n  }\n  return p;\n}\n\nstatic constexpr int kLargeDOF = 150;\n\n// Returns the probability of a normal z-value.\n//\n// Adapted from the POZ function in:\n//     Ibbetson D, Algorithm 209\n//     Collected Algorithms of the CACM 1963 p. 616\n//\ndouble POZ(double z) {\n  static constexpr double kP1[] = {\n      0.797884560593,  -0.531923007300, 0.319152932694,\n      -0.151968751364, 0.059054035642,  -0.019198292004,\n      0.005198775019,  -0.001075204047, 0.000124818987,\n  };\n  static constexpr double kP2[] = {\n      0.999936657524,  0.000535310849,  -0.002141268741, 0.005353579108,\n      -0.009279453341, 0.011630447319,  -0.010557625006, 0.006549791214,\n      -0.002034254874, -0.000794620820, 0.001390604284,  -0.000676904986,\n      -0.000019538132, 0.000152529290,  -0.000045255659,\n  };\n\n  const double kZMax = 6.0;  // Maximum meaningful z-value.\n  if (z == 0.0) {\n    return 0.5;\n  }\n  double x;\n  double y = 0.5 * std::fabs(z);\n  if (y >= (kZMax * 0.5)) {\n    x = 1.0;\n  } else if (y < 1.0) {\n    double w = y * y;\n    x = EvaluatePolynomial(w, kP1) * y * 2.0;\n  } else {\n    y -= 2.0;\n    x = EvaluatePolynomial(y, kP2);\n  }\n  return z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5);\n}\n\n// Approximates the survival function of the normal distribution.\n//\n// Algorithm 26.2.18, from:\n// [Abramowitz and Stegun, Handbook of Mathematical Functions,p.932]\n// http://people.math.sfu.ca/~cbm/aands/abramowitz_and_stegun.pdf\n//\ndouble normal_survival(double z) {\n  // Maybe replace with the alternate formulation.\n  // 0.5 * erfc((x - mean)/(sqrt(2) * sigma))\n  static constexpr double kR[] = {\n      1.0, 0.196854, 0.115194, 0.000344, 0.019527,\n  };\n  double r = EvaluatePolynomial(z, kR);\n  r *= r;\n  return 0.5 / (r * r);\n}\n\n}  // namespace\n\n// Calculates the critical chi-square value given degrees-of-freedom and a\n// p-value, usually using bisection. Also known by the name CRITCHI.\ndouble ChiSquareValue(int dof, double p) {\n  static constexpr double kChiEpsilon =\n      0.000001;  // Accuracy of the approximation.\n  static constexpr double kChiMax =\n      99999.0;  // Maximum chi-squared value.\n\n  const double p_value = 1.0 - p;\n  if (dof < 1 || p_value > 1.0) {\n    return 0.0;\n  }\n\n  if (dof > kLargeDOF) {\n    // For large degrees of freedom, use the normal approximation by\n    //     Wilson, E. B. and Hilferty, M. M. (1931)\n    //                     chi^2 - mean\n    //                Z = --------------\n    //                        stddev\n    const double z = InverseNormalSurvival(p_value);\n    const double mean = 1 - 2.0 / (9 * dof);\n    const double variance = 2.0 / (9 * dof);\n    // Cannot use this method if the variance is 0.\n    if (variance != 0) {\n      double term = z * std::sqrt(variance) + mean;\n      return dof * (term * term * term);\n    }\n  }\n\n  if (p_value <= 0.0) return kChiMax;\n\n  // Otherwise search for the p value by bisection\n  double min_chisq = 0.0;\n  double max_chisq = kChiMax;\n  double current = dof / std::sqrt(p_value);\n  while ((max_chisq - min_chisq) > kChiEpsilon) {\n    if (ChiSquarePValue(current, dof) < p_value) {\n      max_chisq = current;\n    } else {\n      min_chisq = current;\n    }\n    current = (max_chisq + min_chisq) * 0.5;\n  }\n  return current;\n}\n\n// Calculates the p-value (probability) of a given chi-square value\n// and degrees of freedom.\n//\n// Adapted from the POCHISQ function from:\n//     Hill, I. D. and Pike, M. C.  Algorithm 299\n//     Collected Algorithms of the CACM 1963 p. 243\n//\ndouble ChiSquarePValue(double chi_square, int dof) {\n  static constexpr double kLogSqrtPi =\n      0.5723649429247000870717135;  // Log[Sqrt[Pi]]\n  static constexpr double kInverseSqrtPi =\n      0.5641895835477562869480795;  // 1/(Sqrt[Pi])\n\n  // For large degrees of freedom, use the normal approximation by\n  //     Wilson, E. B. and Hilferty, M. M. (1931)\n  // Via Wikipedia:\n  //   By the Central Limit Theorem, because the chi-square distribution is the\n  //   sum of k independent random variables with finite mean and variance, it\n  //   converges to a normal distribution for large k.\n  if (dof > kLargeDOF) {\n    // Re-scale everything.\n    const double chi_square_scaled = std::pow(chi_square / dof, 1.0 / 3);\n    const double mean = 1 - 2.0 / (9 * dof);\n    const double variance = 2.0 / (9 * dof);\n    // If variance is 0, this method cannot be used.\n    if (variance != 0) {\n      const double z = (chi_square_scaled - mean) / std::sqrt(variance);\n      if (z > 0) {\n        return normal_survival(z);\n      } else if (z < 0) {\n        return 1.0 - normal_survival(-z);\n      } else {\n        return 0.5;\n      }\n    }\n  }\n\n  // The chi square function is >= 0 for any degrees of freedom.\n  // In other words, probability that the chi square function >= 0 is 1.\n  if (chi_square <= 0.0) return 1.0;\n\n  // If the degrees of freedom is zero, the chi square function is always 0 by\n  // definition. In other words, the probability that the chi square function\n  // is > 0 is zero (chi square values <= 0 have been filtered above).\n  if (dof < 1) return 0;\n\n  auto capped_exp = [](double x) { return x < -20 ? 0.0 : std::exp(x); };\n  static constexpr double kBigX = 20;\n\n  double a = 0.5 * chi_square;\n  const bool even = !(dof & 1);  // True if dof is an even number.\n  const double y = capped_exp(-a);\n  double s = even ? y : (2.0 * POZ(-std::sqrt(chi_square)));\n\n  if (dof <= 2) {\n    return s;\n  }\n\n  chi_square = 0.5 * (dof - 1.0);\n  double z = (even ? 1.0 : 0.5);\n  if (a > kBigX) {\n    double e = (even ? 0.0 : kLogSqrtPi);\n    double c = std::log(a);\n    while (z <= chi_square) {\n      e = std::log(z) + e;\n      s += capped_exp(c * z - a - e);\n      z += 1.0;\n    }\n    return s;\n  }\n\n  double e = (even ? 1.0 : (kInverseSqrtPi / std::sqrt(a)));\n  double c = 0.0;\n  while (z <= chi_square) {\n    e = e * (a / z);\n    c = c + e;\n    z += 1.0;\n  }\n  return c * y + s;\n}\n\n}",
  "id": "BLOCK-CPP-02774",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/chi_square.cc",
  "source_line": 23,
  "validation_status": "validated"
}