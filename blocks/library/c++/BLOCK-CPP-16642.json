{
  "code": "{\npublic:\n  VisibleModuleSet() = default;\n  VisibleModuleSet(VisibleModuleSet &&O)\n      : ImportLocs(std::move(O.ImportLocs)), Generation(O.Generation ? 1 : 0) {\n    O.ImportLocs.clear();\n    ++O.Generation;\n  }\n\n  /// Move from another visible modules set. Guaranteed to leave the source\n  /// empty and bump the generation on both.\n  VisibleModuleSet &operator=(VisibleModuleSet &&O) {\n    ImportLocs = std::move(O.ImportLocs);\n    O.ImportLocs.clear();\n    ++O.Generation;\n    ++Generation;\n    return *this;\n  }\n\n  /// Get the current visibility generation. Incremented each time the\n  /// set of visible modules changes in any way.\n  unsigned getGeneration() const { return Generation; }\n\n  /// Determine whether a module is visible.\n  bool isVisible(const Module *M) const {\n    return getImportLoc(M).isValid();\n  }\n\n  /// Get the location at which the import of a module was triggered.\n  SourceLocation getImportLoc(const Module *M) const {\n    return M->getVisibilityID() < ImportLocs.size()\n               ? ImportLocs[M->getVisibilityID()]\n               : SourceLocation();\n  }\n\n  /// A callback to call when a module is made visible (directly or\n  /// indirectly) by a call to \\ref setVisible.\n  using VisibleCallback = llvm::function_ref<void(Module *M)>;\n\n  /// A callback to call when a module conflict is found. \\p Path\n  /// consists of a sequence of modules from the conflicting module to the one\n  /// made visible, where each was exported by the next.\n  using ConflictCallback =\n      llvm::function_ref<void(ArrayRef<Module *> Path, Module *Conflict,\n                         StringRef Message)>;\n\n  /// Make a specific module visible.\n  void setVisible(Module *M, SourceLocation Loc,\n                  VisibleCallback Vis = [](Module *) {},\n                  ConflictCallback Cb = [](ArrayRef<Module *>, Module *,\n                                           StringRef) {});\n\n  /// Make transitive imports visible for [module.import]/7.\n  void makeTransitiveImportsVisible(\n      Module *M, SourceLocation Loc, VisibleCallback Vis = [](Module *) {},\n      ConflictCallback Cb = [](ArrayRef<Module *>, Module *, StringRef) {});\n\nprivate:\n  /// Import locations for each visible module. Indexed by the module's\n  /// VisibilityID.\n  std::vector<SourceLocation> ImportLocs;\n\n  /// Visibility generation, bumped every time the visibility state changes.\n  unsigned Generation = 0;\n}",
  "id": "BLOCK-CPP-16642",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Module.h",
  "source_line": 770,
  "validation_status": "validated"
}