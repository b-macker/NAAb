{
  "code": "#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"clang/Frontend/MigratorOptions.h\"\n#include \"clang/Frontend/PreprocessorOutputOptions.h\"\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <memory>\n#include <string>\n\nusing namespace llvm;\nusing namespace opt;\nusing namespace opt;\nusing namespace vfs;\nusing namespace vfs;\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18275_execute() {\n    {\n\nclass DiagnosticsEngine;\nclass HeaderSearchOptions;\nclass PreprocessorOptions;\nclass TargetOptions;\n\n// This lets us create the DiagnosticsEngine with a properly-filled-out\n// DiagnosticOptions instance.\nstd::unique_ptr<DiagnosticOptions>\nCreateAndPopulateDiagOpts(ArrayRef<const char *> Argv);\n\n/// Fill out Opts based on the options given in Args.\n///\n/// Args must have been created from the OptTable returned by\n/// createCC1OptTable().\n///\n/// When errors are encountered, return false and, if Diags is non-null,\n/// report the error(s).\nbool ParseDiagnosticArgs(DiagnosticOptions &Opts, llvm::opt::ArgList &Args,\n                         DiagnosticsEngine *Diags = nullptr,\n                         bool DefaultDiagColor = true);\n\n/// The base class of CompilerInvocation with reference semantics.\n///\n/// This class stores option objects behind reference-counted pointers. This is\n/// useful for clients that want to keep some option object around even after\n/// CompilerInvocation gets destroyed, without making a copy.\n///\n/// This is a separate class so that we can implement the copy constructor and\n/// assignment here and leave them defaulted in the rest of CompilerInvocation.\nclass CompilerInvocationRefBase {\npublic:\n  /// Options controlling the language variant.\n  std::shared_ptr<LangOptions> LangOpts;\n\n  /// Options controlling the target.\n  std::shared_ptr<TargetOptions> TargetOpts;\n\n  /// Options controlling the diagnostic engine.\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagnosticOpts;\n\n  /// Options controlling the \\#include directive.\n  std::shared_ptr<HeaderSearchOptions> HeaderSearchOpts;\n\n  /// Options controlling the preprocessor (aside from \\#include handling).\n  std::shared_ptr<PreprocessorOptions> PreprocessorOpts;\n\n  /// Options controlling the static analyzer.\n  AnalyzerOptionsRef AnalyzerOpts;\n\n  CompilerInvocationRefBase();\n  CompilerInvocationRefBase(const CompilerInvocationRefBase &X);\n  CompilerInvocationRefBase(CompilerInvocationRefBase &&X);\n  CompilerInvocationRefBase &operator=(CompilerInvocationRefBase X);\n  CompilerInvocationRefBase &operator=(CompilerInvocationRefBase &&X);\n  ~CompilerInvocationRefBase();\n\n  LangOptions *getLangOpts() { return LangOpts.get(); }\n  const LangOptions *getLangOpts() const { return LangOpts.get(); }\n\n  TargetOptions &getTargetOpts() { return *TargetOpts.get(); }\n  const TargetOptions &getTargetOpts() const { return *TargetOpts.get(); }\n\n  DiagnosticOptions &getDiagnosticOpts() const { return *DiagnosticOpts; }\n\n  HeaderSearchOptions &getHeaderSearchOpts() { return *HeaderSearchOpts; }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return *HeaderSearchOpts;\n  }\n\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return HeaderSearchOpts;\n  }\n\n  std::shared_ptr<PreprocessorOptions> getPreprocessorOptsPtr() {\n    return PreprocessorOpts;\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() { return *PreprocessorOpts; }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return *PreprocessorOpts;\n  }\n\n  AnalyzerOptionsRef getAnalyzerOpts() const { return AnalyzerOpts; }\n};\n\n/// The base class of CompilerInvocation with value semantics.\nclass CompilerInvocationValueBase {\nprotected:\n  MigratorOptions MigratorOpts;\n\n  /// Options controlling IRgen and the backend.\n  CodeGenOptions CodeGenOpts;\n\n  /// Options controlling dependency output.\n  DependencyOutputOptions DependencyOutputOpts;\n\n  /// Options controlling file system operations.\n  FileSystemOptions FileSystemOpts;\n\n  /// Options controlling the frontend itself.\n  FrontendOptions FrontendOpts;\n\n  /// Options controlling preprocessed output.\n  PreprocessorOutputOptions PreprocessorOutputOpts;\n\npublic:\n  MigratorOptions &getMigratorOpts() { return MigratorOpts; }\n  const MigratorOptions &getMigratorOpts() const { return MigratorOpts; }\n\n  CodeGenOptions &getCodeGenOpts() { return CodeGenOpts; }\n  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return DependencyOutputOpts;\n  }\n\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return DependencyOutputOpts;\n  }\n\n  FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }\n\n  const FileSystemOptions &getFileSystemOpts() const {\n    return FileSystemOpts;\n  }\n\n  FrontendOptions &getFrontendOpts() { return FrontendOpts; }\n  const FrontendOptions &getFrontendOpts() const { return FrontendOpts; }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return PreprocessorOutputOpts;\n  }\n\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return PreprocessorOutputOpts;\n  }\n};\n\n/// Helper class for holding the data necessary to invoke the compiler.\n///\n/// This class is designed to represent an abstract \"invocation\" of the\n/// compiler, including data such as the include paths, the code generation\n/// options, the warning flags, and so on.\nclass CompilerInvocation : public CompilerInvocationRefBase,\n                           public CompilerInvocationValueBase {\npublic:\n  /// Create a compiler invocation from a list of input options.\n  /// \\returns true on success.\n  ///\n  /// \\returns false if an error was encountered while parsing the arguments\n  /// and attempts to recover and continue parsing the rest of the arguments.\n  /// The recovery is best-effort and only guarantees that \\p Res will end up in\n  /// one of the vaild-to-access (albeit arbitrary) states.\n  ///\n  /// \\param [out] Res - The resulting invocation.\n  /// \\param [in] CommandLineArgs - Array of argument strings, this must not\n  /// contain \"-cc1\".\n  static bool CreateFromArgs(CompilerInvocation &Res,\n                             ArrayRef<const char *> CommandLineArgs,\n                             DiagnosticsEngine &Diags,\n                             const char *Argv0 = nullptr);\n\n  /// Get the directory where the compiler headers\n  /// reside, relative to the compiler binary (found by the passed in\n  /// arguments).\n  ///\n  /// \\param Argv0 - The program path (from argv[0]), for finding the builtin\n  /// compiler path.\n  /// \\param MainAddr - The address of main (or some other function in the main\n  /// executable), for finding the builtin compiler path.\n  static std::string GetResourcesPath(const char *Argv0, void *MainAddr);\n\n  /// Retrieve a module hash string that is suitable for uniquely\n  /// identifying the conditions under which the module was built.\n  std::string getModuleHash() const;\n\n  using StringAllocator = llvm::function_ref<const char *(const llvm::Twine &)>;\n  /// Generate cc1-compatible command line arguments from this instance.\n  ///\n  /// \\param [out] Args - The generated arguments. Note that the caller is\n  /// responsible for inserting the path to the clang executable and \"-cc1\" if\n  /// desired.\n  /// \\param SA - A function that given a Twine can allocate storage for a given\n  /// command line argument and return a pointer to the newly allocated string.\n  /// The returned pointer is what gets appended to Args.\n  void generateCC1CommandLine(llvm::SmallVectorImpl<const char *> &Args,\n                              StringAllocator SA) const;\n\n  /// Generate cc1-compatible command line arguments from this instance,\n  /// wrapping the result as a std::vector<std::string>.\n  ///\n  /// This is a (less-efficient) wrapper over generateCC1CommandLine().\n  std::vector<std::string> getCC1CommandLine() const;\n\n  /// Check that \\p Args can be parsed and re-serialized without change,\n  /// emiting diagnostics for any differences.\n  ///\n  /// This check is only suitable for command-lines that are expected to already\n  /// be canonical.\n  ///\n  /// \\return false if there are any errors.\n  static bool checkCC1RoundTrip(ArrayRef<const char *> Args,\n                                DiagnosticsEngine &Diags,\n                                const char *Argv0 = nullptr);\n\n  /// Reset all of the options that are not considered when building a\n  /// module.\n  void resetNonModularOptions();\n\n  /// Disable implicit modules and canonicalize options that are only used by\n  /// implicit modules.\n  void clearImplicitModuleBuildOptions();\n\nprivate:\n  static bool CreateFromArgsImpl(CompilerInvocation &Res,\n                                 ArrayRef<const char *> CommandLineArgs,\n                                 DiagnosticsEngine &Diags, const char *Argv0);\n\n  /// Generate command line options from DiagnosticOptions.\n  static void GenerateDiagnosticArgs(const DiagnosticOptions &Opts,\n                                     SmallVectorImpl<const char *> &Args,\n                                     StringAllocator SA, bool DefaultDiagColor);\n\n  /// Parse command line options that map to LangOptions.\n  static bool ParseLangArgs(LangOptions &Opts, llvm::opt::ArgList &Args,\n                            InputKind IK, const llvm::Triple &T,\n                            std::vector<std::string> &Includes,\n                            DiagnosticsEngine &Diags);\n\n  /// Generate command line options from LangOptions.\n  static void GenerateLangArgs(const LangOptions &Opts,\n                               SmallVectorImpl<const char *> &Args,\n                               StringAllocator SA, const llvm::Triple &T,\n                               InputKind IK);\n\n  /// Parse command line options that map to CodeGenOptions.\n  static bool ParseCodeGenArgs(CodeGenOptions &Opts, llvm::opt::ArgList &Args,\n                               InputKind IK, DiagnosticsEngine &Diags,\n                               const llvm::Triple &T,\n                               const std::string &OutputFile,\n                               const LangOptions &LangOptsRef);\n\n  // Generate command line options from CodeGenOptions.\n  static void GenerateCodeGenArgs(const CodeGenOptions &Opts,\n                                  SmallVectorImpl<const char *> &Args,\n                                  StringAllocator SA, const llvm::Triple &T,\n                                  const std::string &OutputFile,\n                                  const LangOptions *LangOpts);\n};\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\ncreateVFSFromCompilerInvocation(const CompilerInvocation &CI,\n                                DiagnosticsEngine &Diags);\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem> createVFSFromCompilerInvocation(\n    const CompilerInvocation &CI, DiagnosticsEngine &Diags,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS);\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\ncreateVFSFromOverlayFiles(ArrayRef<std::string> VFSOverlayFiles,\n                          DiagnosticsEngine &Diags,\n                          IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18275",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/CompilerInvocation.h",
  "source_line": 46,
  "validation_status": "validated"
}