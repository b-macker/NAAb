{
  "code": "{\npublic:\n  /// Empty identifier. It matches nothing.\n  constexpr ASTNodeKind() : KindId(NKI_None) {}\n\n  /// Construct an identifier for T.\n  template <class T> static constexpr ASTNodeKind getFromNodeKind() {\n    return ASTNodeKind(KindToKindId<T>::Id);\n  }\n\n  /// \\{\n  /// Construct an identifier for the dynamic type of the node\n  static ASTNodeKind getFromNode(const Decl &D);\n  static ASTNodeKind getFromNode(const Stmt &S);\n  static ASTNodeKind getFromNode(const Type &T);\n  static ASTNodeKind getFromNode(const TypeLoc &T);\n  static ASTNodeKind getFromNode(const LambdaCapture &L);\n  static ASTNodeKind getFromNode(const OMPClause &C);\n  static ASTNodeKind getFromNode(const Attr &A);\n  /// \\}\n\n  /// Returns \\c true if \\c this and \\c Other represent the same kind.\n  constexpr bool isSame(ASTNodeKind Other) const {\n    return KindId != NKI_None && KindId == Other.KindId;\n  }\n\n  /// Returns \\c true only for the default \\c ASTNodeKind()\n  constexpr bool isNone() const { return KindId == NKI_None; }\n\n  /// Returns \\c true if \\c this is a base kind of (or same as) \\c Other.\n  bool isBaseOf(ASTNodeKind Other) const;\n\n  /// Returns \\c true if \\c this is a base kind of (or same as) \\c Other.\n  /// \\param Distance If non-null, used to return the distance between \\c this\n  /// and \\c Other in the class hierarchy.\n  bool isBaseOf(ASTNodeKind Other, unsigned *Distance) const;\n\n  /// String representation of the kind.\n  StringRef asStringRef() const;\n\n  /// Strict weak ordering for ASTNodeKind.\n  constexpr bool operator<(const ASTNodeKind &Other) const {\n    return KindId < Other.KindId;\n  }\n\n  /// Return the most derived type between \\p Kind1 and \\p Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedType(ASTNodeKind Kind1, ASTNodeKind Kind2);\n\n  /// Return the most derived common ancestor between Kind1 and Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedCommonAncestor(ASTNodeKind Kind1,\n                                                  ASTNodeKind Kind2);\n\n  ASTNodeKind getCladeKind() const;\n\n  /// Hooks for using ASTNodeKind as a key in a DenseMap.\n  struct DenseMapInfo {\n    // ASTNodeKind() is a good empty key because it is represented as a 0.\n    static inline ASTNodeKind getEmptyKey() { return ASTNodeKind(); }\n    // NKI_NumberOfKinds is not a valid value, so it is good for a\n    // tombstone key.\n    static inline ASTNodeKind getTombstoneKey() {\n      return ASTNodeKind(NKI_NumberOfKinds);\n    }\n    static unsigned getHashValue(const ASTNodeKind &Val) { return Val.KindId; }\n    static bool isEqual(const ASTNodeKind &LHS, const ASTNodeKind &RHS) {\n      return LHS.KindId == RHS.KindId;\n    }\n  };\n\n  /// Check if the given ASTNodeKind identifies a type that offers pointer\n  /// identity. This is useful for the fast path in DynTypedNode.\n  constexpr bool hasPointerIdentity() const {\n    return KindId > NKI_LastKindWithoutPointerIdentity;\n  }\n\nprivate:\n  /// Kind ids.\n  ///\n  /// Includes all possible base and derived kinds.\n  enum NodeKindId {\n    NKI_None,\n    NKI_TemplateArgument,\n    NKI_TemplateArgumentLoc,\n    NKI_LambdaCapture,\n    NKI_TemplateName,\n    NKI_NestedNameSpecifierLoc,\n    NKI_QualType,\n#define TYPELOC(CLASS, PARENT) NKI_##CLASS##TypeLoc,\n#include \"clang/AST/TypeLocNodes.def\"\n    NKI_TypeLoc,\n    NKI_LastKindWithoutPointerIdentity = NKI_TypeLoc,\n    NKI_CXXBaseSpecifier,\n    NKI_CXXCtorInitializer,\n    NKI_NestedNameSpecifier,\n    NKI_Decl,\n#define DECL(DERIVED, BASE) NKI_##DERIVED##Decl,\n#include \"clang/AST/DeclNodes.inc\"\n    NKI_Stmt,\n#define STMT(DERIVED, BASE) NKI_##DERIVED,\n#include \"clang/AST/StmtNodes.inc\"\n    NKI_Type,\n#define TYPE(DERIVED, BASE) NKI_##DERIVED##Type,\n#include \"clang/AST/TypeNodes.inc\"\n    NKI_OMPClause,\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) NKI_##Class,\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    NKI_Attr,\n#define ATTR(A) NKI_##A##Attr,\n#include \"clang/Basic/AttrList.inc\"\n    NKI_ObjCProtocolLoc,\n    NKI_NumberOfKinds\n  };\n\n  /// Use getFromNodeKind<T>() to construct the kind.\n  constexpr ASTNodeKind(NodeKindId KindId) : KindId(KindId) {}\n\n  /// Returns \\c true if \\c Base is a base kind of (or same as) \\c\n  ///   Derived.\n  static bool isBaseOf(NodeKindId Base, NodeKindId Derived);\n\n  /// Returns \\c true if \\c Base is a base kind of (or same as) \\c\n  ///   Derived.\n  /// \\param Distance If non-null, used to return the distance between \\c Base\n  /// and \\c Derived in the class hierarchy.\n  static bool isBaseOf(NodeKindId Base, NodeKindId Derived, unsigned *Distance);\n\n  /// Helper meta-function to convert a kind T to its enum value.\n  ///\n  /// This struct is specialized below for all known kinds.\n  template <class T> struct KindToKindId {\n    static const NodeKindId Id = NKI_None;\n  };\n  template <class T>\n  struct KindToKindId<const T> : KindToKindId<T> {};\n\n  /// Per kind info.\n  struct KindInfo {\n    /// The id of the parent kind, or None if it has no parent.\n    NodeKindId ParentId;\n    /// Name of the kind.\n    const char *Name;\n  };\n  static const KindInfo AllKindInfo[NKI_NumberOfKinds];\n\n  NodeKindId KindId;\n}",
  "id": "BLOCK-CPP-07280",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTTypeTraits.h",
  "source_line": 51,
  "validation_status": "validated"
}