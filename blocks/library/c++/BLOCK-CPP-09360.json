{
  "code": "{\nprotected:\n  friend class FunctionDecl;\n\n  /// Data that is common to all of the declarations of a given\n  /// function template.\n  struct Common : CommonBase {\n    /// The function template specializations for this function\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> Specializations;\n\n    Common() = default;\n  };\n\n  FunctionTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                       DeclarationName Name, TemplateParameterList *Params,\n                       NamedDecl *Decl)\n      : RedeclarableTemplateDecl(FunctionTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  /// Retrieve the set of function template specializations of this\n  /// function template.\n  llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> &\n  getSpecializations() const;\n\n  /// Add a specialization of this function template.\n  ///\n  /// \\param InsertPos Insert position in the FoldingSetVector, must have been\n  ///        retrieved by an earlier call to findSpecialization().\n  void addSpecialization(FunctionTemplateSpecializationInfo* Info,\n                         void *InsertPos);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying function declaration of the template.\n  FunctionDecl *getTemplatedDecl() const {\n    return static_cast<FunctionDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  FunctionDecl *findSpecialization(ArrayRef<TemplateArgument> Args,\n                                   void *&InsertPos);\n\n  FunctionTemplateDecl *getCanonicalDecl() override {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const FunctionTemplateDecl *getCanonicalDecl() const {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  FunctionTemplateDecl *getPreviousDecl() {\n    return cast_or_null<FunctionTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const FunctionTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<FunctionTemplateDecl>(\n       static_cast<const RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n\n  FunctionTemplateDecl *getMostRecentDecl() {\n    return cast<FunctionTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)\n            ->getMostRecentDecl());\n  }\n  const FunctionTemplateDecl *getMostRecentDecl() const {\n    return const_cast<FunctionTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  FunctionTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  using spec_iterator = SpecIterator<FunctionTemplateSpecializationInfo>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  /// Return whether this function template is an abbreviated function template,\n  /// e.g. `void foo(auto x)` or `template<typename T> void foo(auto x)`\n  bool isAbbreviated() const {\n    // Since the invented template parameters generated from 'auto' parameters\n    // are either appended to the end of the explicit template parameter list or\n    // form a new template parameter list, we can simply observe the last\n    // parameter to determine if such a thing happened.\n    const TemplateParameterList *TPL = getTemplateParameters();\n    return TPL->getParam(TPL->size() - 1)->isImplicit();\n  }\n\n  /// Merge \\p Prev with our RedeclarableTemplateDecl::Common.\n  void mergePrevDecl(FunctionTemplateDecl *Prev);\n\n  /// Create a function template node.\n  static FunctionTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      DeclarationName Name,\n                                      TemplateParameterList *Params,\n                                      NamedDecl *Decl);\n\n  /// Create an empty function template node.\n  static FunctionTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FunctionTemplate; }\n}",
  "id": "BLOCK-CPP-09360",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 1007,
  "validation_status": "validated"
}