{
  "code": "#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include <cassert>\n#include <cstdint>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-12373_execute() {\n    {\n\nclass ASTContext;\nclass CXXRecordDecl;\n\n/// ASTRecordLayout -\n/// This class contains layout information for one RecordDecl,\n/// which is a struct/union/class.  The decl represented must be a definition,\n/// not a forward declaration.\n/// This class is also used to contain layout information for one\n/// ObjCInterfaceDecl. FIXME - Find appropriate name.\n/// These objects are managed by ASTContext.\nclass ASTRecordLayout {\npublic:\n  struct VBaseInfo {\n    /// The offset to this virtual base in the complete-object layout\n    /// of this class.\n    CharUnits VBaseOffset;\n\n  private:\n    /// Whether this virtual base requires a vtordisp field in the\n    /// Microsoft ABI.  These fields are required for certain operations\n    /// in constructors and destructors.\n    bool HasVtorDisp = false;\n\n  public:\n    VBaseInfo() = default;\n    VBaseInfo(CharUnits VBaseOffset, bool hasVtorDisp)\n        : VBaseOffset(VBaseOffset), HasVtorDisp(hasVtorDisp) {}\n\n    bool hasVtorDisp() const { return HasVtorDisp; }\n  };\n\n  using VBaseOffsetsMapTy = llvm::DenseMap<const CXXRecordDecl *, VBaseInfo>;\n\nprivate:\n  friend class ASTContext;\n\n  /// Size - Size of record in characters.\n  CharUnits Size;\n\n  /// DataSize - Size of record in characters without tail padding.\n  CharUnits DataSize;\n\n  // Alignment - Alignment of record in characters.\n  CharUnits Alignment;\n\n  // PreferredAlignment - Preferred alignment of record in characters. This\n  // can be different than Alignment in cases where it is beneficial for\n  // performance or backwards compatibility preserving (e.g. AIX-ABI).\n  CharUnits PreferredAlignment;\n\n  // UnadjustedAlignment - Maximum of the alignments of the record members in\n  // characters.\n  CharUnits UnadjustedAlignment;\n\n  /// RequiredAlignment - The required alignment of the object.  In the MS-ABI\n  /// the __declspec(align()) trumps #pramga pack and must always be obeyed.\n  CharUnits RequiredAlignment;\n\n  /// FieldOffsets - Array of field offsets in bits.\n  ASTVector<uint64_t> FieldOffsets;\n\n  /// CXXRecordLayoutInfo - Contains C++ specific layout information.\n  struct CXXRecordLayoutInfo {\n    /// NonVirtualSize - The non-virtual size (in chars) of an object, which is\n    /// the size of the object without virtual bases.\n    CharUnits NonVirtualSize;\n\n    /// NonVirtualAlignment - The non-virtual alignment (in chars) of an object,\n    /// which is the alignment of the object without virtual bases.\n    CharUnits NonVirtualAlignment;\n\n    /// PreferredNVAlignment - The preferred non-virtual alignment (in chars) of\n    /// an object, which is the preferred alignment of the object without\n    /// virtual bases.\n    CharUnits PreferredNVAlignment;\n\n    /// SizeOfLargestEmptySubobject - The size of the largest empty subobject\n    /// (either a base or a member). Will be zero if the class doesn't contain\n    /// any empty subobjects.\n    CharUnits SizeOfLargestEmptySubobject;\n\n    /// VBPtrOffset - Virtual base table offset (Microsoft-only).\n    CharUnits VBPtrOffset;\n\n    /// HasOwnVFPtr - Does this class provide a virtual function table\n    /// (vtable in Itanium, vftbl in Microsoft) that is independent from\n    /// its base classes?\n    bool HasOwnVFPtr : 1;\n\n    /// HasVFPtr - Does this class have a vftable that could be extended by\n    /// a derived class.  The class may have inherited this pointer from\n    /// a primary base class.\n    bool HasExtendableVFPtr : 1;\n\n    /// EndsWithZeroSizedObject - True if this class contains a zero sized\n    /// member or base or a base with a zero sized member or base.\n    /// Only used for MS-ABI.\n    bool EndsWithZeroSizedObject : 1;\n\n    /// True if this class is zero sized or first base is zero sized or\n    /// has this property.  Only used for MS-ABI.\n    bool LeadsWithZeroSizedBase : 1;\n\n    /// PrimaryBase - The primary base info for this record.\n    llvm::PointerIntPair<const CXXRecordDecl *, 1, bool> PrimaryBase;\n\n    /// BaseSharingVBPtr - The base we share vbptr with.\n    const CXXRecordDecl *BaseSharingVBPtr;\n\n    /// FIXME: This should really use a SmallPtrMap, once we have one in LLVM :)\n    using BaseOffsetsMapTy = llvm::DenseMap<const CXXRecordDecl *, CharUnits>;\n\n    /// BaseOffsets - Contains a map from base classes to their offset.\n    BaseOffsetsMapTy BaseOffsets;\n\n    /// VBaseOffsets - Contains a map from vbase classes to their offset.\n    VBaseOffsetsMapTy VBaseOffsets;\n  };\n\n  /// CXXInfo - If the record layout is for a C++ record, this will have\n  /// C++ specific information about the record.\n  CXXRecordLayoutInfo *CXXInfo = nullptr;\n\n  ASTRecordLayout(const ASTContext &Ctx, CharUnits size, CharUnits alignment,\n                  CharUnits preferredAlignment, CharUnits unadjustedAlignment,\n                  CharUnits requiredAlignment, CharUnits datasize,\n                  ArrayRef<uint64_t> fieldoffsets);\n\n  using BaseOffsetsMapTy = CXXRecordLayoutInfo::BaseOffsetsMapTy;\n\n  // Constructor for C++ records.\n  ASTRecordLayout(const ASTContext &Ctx, CharUnits size, CharUnits alignment,\n                  CharUnits preferredAlignment, CharUnits unadjustedAlignment,\n                  CharUnits requiredAlignment, bool hasOwnVFPtr,\n                  bool hasExtendableVFPtr, CharUnits vbptroffset,\n                  CharUnits datasize, ArrayRef<uint64_t> fieldoffsets,\n                  CharUnits nonvirtualsize, CharUnits nonvirtualalignment,\n                  CharUnits preferrednvalignment,\n                  CharUnits SizeOfLargestEmptySubobject,\n                  const CXXRecordDecl *PrimaryBase, bool IsPrimaryBaseVirtual,\n                  const CXXRecordDecl *BaseSharingVBPtr,\n                  bool EndsWithZeroSizedObject, bool LeadsWithZeroSizedBase,\n                  const BaseOffsetsMapTy &BaseOffsets,\n                  const VBaseOffsetsMapTy &VBaseOffsets);\n\n  ~ASTRecordLayout() = default;\n\n  void Destroy(ASTContext &Ctx);\n\npublic:\n  ASTRecordLayout(const ASTRecordLayout &) = delete;\n  ASTRecordLayout &operator=(const ASTRecordLayout &) = delete;\n\n  /// getAlignment - Get the record alignment in characters.\n  CharUnits getAlignment() const { return Alignment; }\n\n  /// getPreferredFieldAlignment - Get the record preferred alignment in\n  /// characters.\n  CharUnits getPreferredAlignment() const { return PreferredAlignment; }\n\n  /// getUnadjustedAlignment - Get the record alignment in characters, before\n  /// alignment adjustement.\n  CharUnits getUnadjustedAlignment() const { return UnadjustedAlignment; }\n\n  /// getSize - Get the record size in characters.\n  CharUnits getSize() const { return Size; }\n\n  /// getFieldCount - Get the number of fields in the layout.\n  unsigned getFieldCount() const { return FieldOffsets.size(); }\n\n  /// getFieldOffset - Get the offset of the given field index, in\n  /// bits.\n  uint64_t getFieldOffset(unsigned FieldNo) const {\n    return FieldOffsets[FieldNo];\n  }\n\n  /// getDataSize() - Get the record data size, which is the record size\n  /// without tail padding, in characters.\n  CharUnits getDataSize() const { return DataSize; }\n\n  /// getNonVirtualSize - Get the non-virtual size (in chars) of an object,\n  /// which is the size of the object without virtual bases.\n  CharUnits getNonVirtualSize() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    return CXXInfo->NonVirtualSize;\n  }\n\n  /// getNonVirtualAlignment - Get the non-virtual alignment (in chars) of an\n  /// object, which is the alignment of the object without virtual bases.\n  CharUnits getNonVirtualAlignment() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    return CXXInfo->NonVirtualAlignment;\n  }\n\n  /// getPreferredNVAlignment - Get the preferred non-virtual alignment (in\n  /// chars) of an object, which is the preferred alignment of the object\n  /// without virtual bases.\n  CharUnits getPreferredNVAlignment() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    return CXXInfo->PreferredNVAlignment;\n  }\n\n  /// getPrimaryBase - Get the primary base for this record.\n  const CXXRecordDecl *getPrimaryBase() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    return CXXInfo->PrimaryBase.getPointer();\n  }\n\n  /// isPrimaryBaseVirtual - Get whether the primary base for this record\n  /// is virtual or not.\n  bool isPrimaryBaseVirtual() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    return CXXInfo->PrimaryBase.getInt();\n  }\n\n  /// getBaseClassOffset - Get the offset, in chars, for the given base class.\n  CharUnits getBaseClassOffset(const CXXRecordDecl *Base) const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    Base = Base->getDefinition();\n    assert(CXXInfo->BaseOffsets.count(Base) && \"Did not find base!\");\n\n    return CXXInfo->BaseOffsets[Base];\n  }\n\n  /// getVBaseClassOffset - Get the offset, in chars, for the given base class.\n  CharUnits getVBaseClassOffset(const CXXRecordDecl *VBase) const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n\n    VBase = VBase->getDefinition();\n    assert(CXXInfo->VBaseOffsets.count(VBase) && \"Did not find base!\");\n\n    return CXXInfo->VBaseOffsets[VBase].VBaseOffset;\n  }\n\n  CharUnits getSizeOfLargestEmptySubobject() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->SizeOfLargestEmptySubobject;\n  }\n\n  /// hasOwnVFPtr - Does this class provide its own virtual-function\n  /// table pointer, rather than inheriting one from a primary base\n  /// class?  If so, it is at offset zero.\n  ///\n  /// This implies that the ABI has no primary base class, meaning\n  /// that it has no base classes that are suitable under the conditions\n  /// of the ABI.\n  bool hasOwnVFPtr() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->HasOwnVFPtr;\n  }\n\n  /// hasVFPtr - Does this class have a virtual function table pointer\n  /// that can be extended by a derived class?  This is synonymous with\n  /// this class having a VFPtr at offset zero.\n  bool hasExtendableVFPtr() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->HasExtendableVFPtr;\n  }\n\n  /// hasOwnVBPtr - Does this class provide its own virtual-base\n  /// table pointer, rather than inheriting one from a primary base\n  /// class?\n  ///\n  /// This implies that the ABI has no primary base class, meaning\n  /// that it has no base classes that are suitable under the conditions\n  /// of the ABI.\n  bool hasOwnVBPtr() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return hasVBPtr() && !CXXInfo->BaseSharingVBPtr;\n  }\n\n  /// hasVBPtr - Does this class have a virtual function table pointer.\n  bool hasVBPtr() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return !CXXInfo->VBPtrOffset.isNegative();\n  }\n\n  CharUnits getRequiredAlignment() const { return RequiredAlignment; }\n\n  bool endsWithZeroSizedObject() const {\n    return CXXInfo && CXXInfo->EndsWithZeroSizedObject;\n  }\n\n  bool leadsWithZeroSizedBase() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->LeadsWithZeroSizedBase;\n  }\n\n  /// getVBPtrOffset - Get the offset for virtual base table pointer.\n  /// This is only meaningful with the Microsoft ABI.\n  CharUnits getVBPtrOffset() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->VBPtrOffset;\n  }\n\n  const CXXRecordDecl *getBaseSharingVBPtr() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->BaseSharingVBPtr;\n  }\n\n  const VBaseOffsetsMapTy &getVBaseOffsetsMap() const {\n    assert(CXXInfo && \"Record layout does not have C++ specific info!\");\n    return CXXInfo->VBaseOffsets;\n  }\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-12373",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/RecordLayout.h",
  "source_line": 26,
  "validation_status": "validated"
}