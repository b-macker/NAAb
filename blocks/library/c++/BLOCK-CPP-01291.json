{
  "code": "#include <cmath>         // std::signbit\n#include <cstdint>       // uint32_t\n#include <cstring>       // std::memcpy\n#include <limits>        // std::numeric_limits\n#include <memory>        // std::uninitialized_copy\n#include <stdexcept>     // std::runtime_error\n#include <system_error>  // std::system_error\n#include \"core.h\"\n\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail_exported;\nusing namespace detail_exported;\nusing namespace dragonbox;\nusing namespace dragonbox;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01291_execute() {\n    {\n  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.\n  FMT_ASSERT(buf.capacity() > buf.size(), \"empty buffer\");\n  FMT_ASSERT(specs.format == float_format::hex, \"\");\n  static_assert(!std::is_same<T, float>::value, \"\");\n\n  // Build the format string.\n  char format[7];  // The longest format is \"%#.*Le\".\n  char* format_ptr = format;\n  *format_ptr++ = '%';\n  if (specs.showpoint) *format_ptr++ = '#';\n  if (precision >= 0) {\n    *format_ptr++ = '.';\n    *format_ptr++ = '*';\n  }\n  if (std::is_same<T, long double>()) *format_ptr++ = 'L';\n  *format_ptr++ = specs.upper ? 'A' : 'a';\n  *format_ptr = '\\0';\n\n  // Format using snprintf.\n  auto offset = buf.size();\n  for (;;) {\n    auto begin = buf.data() + offset;\n    auto capacity = buf.capacity() - offset;\n    abort_fuzzing_if(precision > 100000);\n    // Suppress the warning about a nonliteral format string.\n    // Cannot use auto because of a bug in MinGW (#1532).\n    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;\n    int result = precision >= 0\n                     ? snprintf_ptr(begin, capacity, format, precision, value)\n                     : snprintf_ptr(begin, capacity, format, value);\n    if (result < 0) {\n      // The buffer will grow exponentially.\n      buf.try_reserve(buf.capacity() + 1);\n      continue;\n    }\n    auto size = to_unsigned(result);\n    // Size equal to capacity means that the last character was truncated.\n    if (size < capacity) {\n      buf.try_resize(size + offset);\n      return 0;\n    }\n    buf.try_reserve(size + offset + 1);  // Add 1 for the terminating '\\0'.\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01291",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 1578,
  "validation_status": "validated"
}