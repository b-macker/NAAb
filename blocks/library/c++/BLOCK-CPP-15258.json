{
  "code": "{\npublic:\n  /// Defines how bindings are processed on recursive matches.\n  enum BindKind {\n    /// Stop at the first match and only bind the first match.\n    BK_First,\n\n    /// Create results for all combinations of bindings that match.\n    BK_All\n  };\n\n  /// Defines which ancestors are considered for a match.\n  enum AncestorMatchMode {\n    /// All ancestors.\n    AMM_All,\n\n    /// Direct parent only.\n    AMM_ParentOnly\n  };\n\n  virtual ~ASTMatchFinder() = default;\n\n  /// Returns true if the given C++ class is directly or indirectly derived\n  /// from a base type matching \\c base.\n  ///\n  /// A class is not considered to be derived from itself.\n  virtual bool classIsDerivedFrom(const CXXRecordDecl *Declaration,\n                                  const Matcher<NamedDecl> &Base,\n                                  BoundNodesTreeBuilder *Builder,\n                                  bool Directly) = 0;\n\n  /// Returns true if the given Objective-C class is directly or indirectly\n  /// derived from a base class matching \\c base.\n  ///\n  /// A class is not considered to be derived from itself.\n  virtual bool objcClassIsDerivedFrom(const ObjCInterfaceDecl *Declaration,\n                                      const Matcher<NamedDecl> &Base,\n                                      BoundNodesTreeBuilder *Builder,\n                                      bool Directly) = 0;\n\n  template <typename T>\n  bool matchesChildOf(const T &Node, const DynTypedMatcher &Matcher,\n                      BoundNodesTreeBuilder *Builder, BindKind Bind) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<NestedNameSpecifier, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value ||\n                      std::is_base_of<QualType, T>::value ||\n                      std::is_base_of<Attr, T>::value,\n                  \"unsupported type for recursive matching\");\n    return matchesChildOf(DynTypedNode::create(Node), getASTContext(), Matcher,\n                          Builder, Bind);\n  }\n\n  template <typename T>\n  bool matchesDescendantOf(const T &Node, const DynTypedMatcher &Matcher,\n                           BoundNodesTreeBuilder *Builder, BindKind Bind) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<NestedNameSpecifier, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value ||\n                      std::is_base_of<QualType, T>::value ||\n                      std::is_base_of<Attr, T>::value,\n                  \"unsupported type for recursive matching\");\n    return matchesDescendantOf(DynTypedNode::create(Node), getASTContext(),\n                               Matcher, Builder, Bind);\n  }\n\n  // FIXME: Implement support for BindKind.\n  template <typename T>\n  bool matchesAncestorOf(const T &Node, const DynTypedMatcher &Matcher,\n                         BoundNodesTreeBuilder *Builder,\n                         AncestorMatchMode MatchMode) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value ||\n                      std::is_base_of<Attr, T>::value,\n                  \"type not allowed for recursive matching\");\n    return matchesAncestorOf(DynTypedNode::create(Node), getASTContext(),\n                             Matcher, Builder, MatchMode);\n  }\n\n  virtual ASTContext &getASTContext() const = 0;\n\n  virtual bool IsMatchingInASTNodeNotSpelledInSource() const = 0;\n\n  virtual bool IsMatchingInASTNodeNotAsIs() const = 0;\n\n  bool isTraversalIgnoringImplicitNodes() const;\n\nprotected:\n  virtual bool matchesChildOf(const DynTypedNode &Node, ASTContext &Ctx,\n                              const DynTypedMatcher &Matcher,\n                              BoundNodesTreeBuilder *Builder,\n                              BindKind Bind) = 0;\n\n  virtual bool matchesDescendantOf(const DynTypedNode &Node, ASTContext &Ctx,\n                                   const DynTypedMatcher &Matcher,\n                                   BoundNodesTreeBuilder *Builder,\n                                   BindKind Bind) = 0;\n\n  virtual bool matchesAncestorOf(const DynTypedNode &Node, ASTContext &Ctx,\n                                 const DynTypedMatcher &Matcher,\n                                 BoundNodesTreeBuilder *Builder,\n                                 AncestorMatchMode MatchMode) = 0;\nprivate:\n  friend struct ASTChildrenNotSpelledInSourceScope;\n  virtual bool isMatchingChildrenNotSpelledInSource() const = 0;\n  virtual void setMatchingChildrenNotSpelledInSource(bool Set) = 0;\n}",
  "id": "BLOCK-CPP-15258",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchersInternal.h",
  "source_line": 701,
  "validation_status": "validated"
}