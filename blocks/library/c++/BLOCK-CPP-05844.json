{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// DistributionCaller provides an opportunity to overload the general\n// mechanism for calling a distribution, allowing for mock-RNG classes\n// to intercept such calls.\ntemplate <typename URBG>\nstruct DistributionCaller {\n  static_assert(!std::is_pointer<URBG>::value,\n                \"You must pass a reference, not a pointer.\");\n  // SFINAE to detect whether the URBG type includes a member matching\n  // bool InvokeMock(base_internal::FastTypeIdType, void*, void*).\n  //\n  // These live inside BitGenRef so that they have friend access\n  // to MockingBitGen. (see similar methods in DistributionCaller).\n  template <template <class...> class Trait, class AlwaysVoid, class... Args>\n  struct detector : std::false_type {};\n  template <template <class...> class Trait, class... Args>\n  struct detector<Trait, absl::void_t<Trait<Args...>>, Args...>\n      : std::true_type {};\n\n  template <class T>\n  using invoke_mock_t = decltype(std::declval<T*>()->InvokeMock(\n      std::declval<::absl::base_internal::FastTypeIdType>(),\n      std::declval<void*>(), std::declval<void*>()));\n\n  using HasInvokeMock = typename detector<invoke_mock_t, void, URBG>::type;\n\n  // Default implementation of distribution caller.\n  template <typename DistrT, typename... Args>\n  static typename DistrT::result_type Impl(std::false_type, URBG* urbg,\n                                           Args&&... args) {\n    DistrT dist(std::forward<Args>(args)...);\n    return dist(*urbg);\n  }\n\n  // Mock implementation of distribution caller.\n  // The underlying KeyT must match the KeyT constructed by MockOverloadSet.\n  template <typename DistrT, typename... Args>\n  static typename DistrT::result_type Impl(std::true_type, URBG* urbg,\n                                           Args&&... args) {\n    using ResultT = typename DistrT::result_type;\n    using ArgTupleT = std::tuple<absl::decay_t<Args>...>;\n    using KeyT = ResultT(DistrT, ArgTupleT);\n\n    ArgTupleT arg_tuple(std::forward<Args>(args)...);\n    ResultT result;\n    if (!urbg->InvokeMock(::absl::base_internal::FastTypeId<KeyT>(), &arg_tuple,\n                          &result)) {\n      auto dist = absl::make_from_tuple<DistrT>(arg_tuple);\n      result = dist(*urbg);\n    }\n    return result;\n  }\n\n  // Default implementation of distribution caller.\n  template <typename DistrT, typename... Args>\n  static typename DistrT::result_type Call(URBG* urbg, Args&&... args) {\n    return Impl<DistrT, Args...>(HasInvokeMock{}, urbg,\n                                 std::forward<Args>(args)...);\n  }\n};\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05844",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/distribution_caller.h",
  "source_line": 27,
  "validation_status": "validated"
}