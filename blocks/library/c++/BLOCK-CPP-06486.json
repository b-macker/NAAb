{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/synchronization/internal/kernel_timeout.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06486_execute() {\n    {\n public:\n  WaiterBase() = default;\n\n  // Not copyable or movable\n  WaiterBase(const WaiterBase&) = delete;\n  WaiterBase& operator=(const WaiterBase&) = delete;\n\n  // Blocks the calling thread until a matching call to `Post()` or\n  // `t` has passed. Returns `true` if woken (`Post()` called),\n  // `false` on timeout.\n  //\n  // bool Wait(KernelTimeout t);\n\n  // Restart the caller of `Wait()` as with a normal semaphore.\n  //\n  // void Post();\n\n  // If anyone is waiting, wake them up temporarily and cause them to\n  // call `MaybeBecomeIdle()`. They will then return to waiting for a\n  // `Post()` or timeout.\n  //\n  // void Poke();\n\n  // Returns the name of this implementation. Used only for debugging.\n  //\n  // static constexpr char kName[];\n\n  // How many periods to remain idle before releasing resources\n#ifndef ABSL_HAVE_THREAD_SANITIZER\n  static constexpr int kIdlePeriods = 60;\n#else\n  // Memory consumption under ThreadSanitizer is a serious concern,\n  // so we release resources sooner. The value of 1 leads to 1 to 2 second\n  // delay before marking a thread as idle.\n  static constexpr int kIdlePeriods = 1;\n#endif\n\n protected:\n  static void MaybeBecomeIdle();\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06486",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/waiter_base.h",
  "source_line": 32,
  "validation_status": "validated"
}