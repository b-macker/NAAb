{
  "code": "{\n public:\n  // Run the conversion for `v * 2^exp` and call `f(generator)`.\n  // This function will allocate enough stack space to perform the conversion.\n  static void RunConversion(\n      uint128 v, int exp, absl::FunctionRef<void(FractionalDigitGenerator)> f) {\n    using Limits = std::numeric_limits<MaxFloatType>;\n    assert(-exp < 0);\n    assert(-exp >= Limits::min_exponent - 128);\n    static_assert(StackArray::kMaxCapacity >=\n                      (Limits::digits + 128 - Limits::min_exponent + 31) / 32,\n                  \"\");\n    StackArray::RunWithCapacity(\n        static_cast<size_t>((Limits::digits + exp + 31) / 32),\n        [=](absl::Span<uint32_t> input) {\n          f(FractionalDigitGenerator(input, v, exp));\n        });\n  }\n\n  // Returns true if there are any more non-zero digits left.\n  bool HasMoreDigits() const { return next_digit_ != 0 || after_chunk_index_; }\n\n  // Returns true if the remainder digits are greater than 5000...\n  bool IsGreaterThanHalf() const {\n    return next_digit_ > 5 || (next_digit_ == 5 && after_chunk_index_);\n  }\n  // Returns true if the remainder digits are exactly 5000...\n  bool IsExactlyHalf() const { return next_digit_ == 5 && !after_chunk_index_; }\n\n  struct Digits {\n    char digit_before_nine;\n    size_t num_nines;\n  };\n\n  // Get the next set of digits.\n  // They are composed by a non-9 digit followed by a runs of zero or more 9s.\n  Digits GetDigits() {\n    Digits digits{next_digit_, 0};\n\n    next_digit_ = GetOneDigit();\n    while (next_digit_ == 9) {\n      ++digits.num_nines;\n      next_digit_ = GetOneDigit();\n    }\n\n    return digits;\n  }\n\n private:\n  // Return the next digit.\n  char GetOneDigit() {\n    if (!after_chunk_index_)\n      return 0;\n\n    char carry = 0;\n    for (size_t i = after_chunk_index_; i > 0; --i) {\n      carry = MultiplyBy10WithCarry(&data_[i - 1], carry);\n    }\n    // If the lowest chunk is now empty, remove it from view.\n    if (data_[after_chunk_index_ - 1] == 0)\n      --after_chunk_index_;\n    return carry;\n  }\n\n  FractionalDigitGenerator(absl::Span<uint32_t> data, uint128 v, int exp)\n      : after_chunk_index_(static_cast<size_t>(exp / 32 + 1)), data_(data) {\n    const int offset = exp % 32;\n    // Right shift `v` by `exp` bits.\n    data_[after_chunk_index_ - 1] = static_cast<uint32_t>(v << (32 - offset));\n    v >>= offset;\n    // Make sure we don't overflow the data. We already calculated that\n    // non-zero bits fit, so we might not have space for leading zero bits.\n    for (size_t pos = after_chunk_index_ - 1; v; v >>= 32)\n      data_[--pos] = static_cast<uint32_t>(v);\n\n    // Fill next_digit_, as GetDigits expects it to be populated always.\n    next_digit_ = GetOneDigit();\n  }\n\n  char next_digit_;\n  size_t after_chunk_index_;\n  absl::Span<uint32_t> data_;\n}",
  "id": "BLOCK-CPP-03102",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 246,
  "validation_status": "validated"
}