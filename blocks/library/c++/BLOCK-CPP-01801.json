{
  "code": "#include \"absl/random/discrete_distribution.h\"\n\nusing namespace absl;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01801_execute() {\n    {\n\n// Initializes the distribution table for Walker's Aliasing algorithm, described\n// in Knuth, Vol 2. as well as in https://en.wikipedia.org/wiki/Alias_method\nstd::vector<std::pair<double, size_t>> InitDiscreteDistribution(\n    std::vector<double>* probabilities) {\n  // The empty-case should already be handled by the constructor.\n  assert(probabilities);\n  assert(!probabilities->empty());\n\n  // Step 1. Normalize the input probabilities to 1.0.\n  double sum = std::accumulate(std::begin(*probabilities),\n                               std::end(*probabilities), 0.0);\n  if (std::fabs(sum - 1.0) > 1e-6) {\n    // Scale `probabilities` only when the sum is too far from 1.0.  Scaling\n    // unconditionally will alter the probabilities slightly.\n    for (double& item : *probabilities) {\n      item = item / sum;\n    }\n  }\n\n  // Step 2. At this point `probabilities` is set to the conditional\n  // probabilities of each element which sum to 1.0, to within reasonable error.\n  // These values are used to construct the proportional probability tables for\n  // the selection phases of Walker's Aliasing algorithm.\n  //\n  // To construct the table, pick an element which is under-full (i.e., an\n  // element for which `(*probabilities)[i] < 1.0/n`), and pair it with an\n  // element which is over-full (i.e., an element for which\n  // `(*probabilities)[i] > 1.0/n`). The smaller value can always be retired.\n  // The larger may still be greater than 1.0/n, or may now be less than 1.0/n,\n  // and put back onto the appropriate collection.\n  const size_t n = probabilities->size();\n  std::vector<std::pair<double, size_t>> q;\n  q.reserve(n);\n\n  std::vector<size_t> over;\n  std::vector<size_t> under;\n  size_t idx = 0;\n  for (const double item : *probabilities) {\n    assert(item >= 0);\n    const double v = item * n;\n    q.emplace_back(v, 0);\n    if (v < 1.0) {\n      under.push_back(idx++);\n    } else {\n      over.push_back(idx++);\n    }\n  }\n  while (!over.empty() && !under.empty()) {\n    auto lo = under.back();\n    under.pop_back();\n    auto hi = over.back();\n    over.pop_back();\n\n    q[lo].second = hi;\n    const double r = q[hi].first - (1.0 - q[lo].first);\n    q[hi].first = r;\n    if (r < 1.0) {\n      under.push_back(hi);\n    } else {\n      over.push_back(hi);\n    }\n  }\n\n  // Due to rounding errors, there may be un-paired elements in either\n  // collection; these should all be values near 1.0.  For these values, set `q`\n  // to 1.0 and set the alternate to the identity.\n  for (auto i : over) {\n    q[i] = {1.0, i};\n  }\n  for (auto i : under) {\n    q[i] = {1.0, i};\n  }\n  return q;\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01801",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/discrete_distribution.cc",
  "source_line": 19,
  "validation_status": "validated"
}