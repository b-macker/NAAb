{
  "code": "#include <pthread.h>\n#include <unistd.h>\n#include <atomic>\n#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/per_thread_tls.h\"\n#include \"absl/base/optimization.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04731_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\nstruct SynchLocksHeld;\nstruct SynchWaitParams;\n\nnamespace base_internal {\n\nclass SpinLock;\nstruct ThreadIdentity;\n\n// Used by the implementation of absl::Mutex and absl::CondVar.\nstruct PerThreadSynch {\n  // The internal representation of absl::Mutex and absl::CondVar rely\n  // on the alignment of PerThreadSynch. Both store the address of the\n  // PerThreadSynch in the high-order bits of their internal state,\n  // which means the low kLowZeroBits of the address of PerThreadSynch\n  // must be zero.\n  static constexpr int kLowZeroBits = 8;\n  static constexpr int kAlignment = 1 << kLowZeroBits;\n\n  // Returns the associated ThreadIdentity.\n  // This can be implemented as a cast because we guarantee\n  // PerThreadSynch is the first element of ThreadIdentity.\n  ThreadIdentity* thread_identity() {\n    return reinterpret_cast<ThreadIdentity*>(this);\n  }\n\n  PerThreadSynch* next;  // Circular waiter queue; initialized to 0.\n  PerThreadSynch* skip;  // If non-zero, all entries in Mutex queue\n                         // up to and including \"skip\" have same\n                         // condition as this, and will be woken later\n  bool may_skip;         // if false while on mutex queue, a mutex unlocker\n                         // is using this PerThreadSynch as a terminator.  Its\n                         // skip field must not be filled in because the loop\n                         // might then skip over the terminator.\n  bool wake;             // This thread is to be woken from a Mutex.\n  // If \"x\" is on a waiter list for a mutex, \"x->cond_waiter\" is true iff the\n  // waiter is waiting on the mutex as part of a CV Wait or Mutex Await.\n  //\n  // The value of \"x->cond_waiter\" is meaningless if \"x\" is not on a\n  // Mutex waiter list.\n  bool cond_waiter;\n  bool maybe_unlocking;  // Valid at head of Mutex waiter queue;\n                         // true if UnlockSlow could be searching\n                         // for a waiter to wake.  Used for an optimization\n                         // in Enqueue().  true is always a valid value.\n                         // Can be reset to false when the unlocker or any\n                         // writer releases the lock, or a reader fully\n                         // releases the lock.  It may not be set to false\n                         // by a reader that decrements the count to\n                         // non-zero. protected by mutex spinlock\n  bool suppress_fatal_errors;  // If true, try to proceed even in the face\n                               // of broken invariants.  This is used within\n                               // fatal signal handlers to improve the\n                               // chances of debug logging information being\n                               // output successfully.\n  int priority;                // Priority of thread (updated every so often).\n\n  // State values:\n  //   kAvailable: This PerThreadSynch is available.\n  //   kQueued: This PerThreadSynch is unavailable, it's currently queued on a\n  //            Mutex or CondVar waistlist.\n  //\n  // Transitions from kQueued to kAvailable require a release\n  // barrier. This is needed as a waiter may use \"state\" to\n  // independently observe that it's no longer queued.\n  //\n  // Transitions from kAvailable to kQueued require no barrier, they\n  // are externally ordered by the Mutex.\n  enum State { kAvailable, kQueued };\n  std::atomic<State> state;\n\n  // The wait parameters of the current wait.  waitp is null if the\n  // thread is not waiting. Transitions from null to non-null must\n  // occur before the enqueue commit point (state = kQueued in\n  // Enqueue() and CondVarEnqueue()). Transitions from non-null to\n  // null must occur after the wait is finished (state = kAvailable in\n  // Mutex::Block() and CondVar::WaitCommon()). This field may be\n  // changed only by the thread that describes this PerThreadSynch.  A\n  // special case is Fer(), which calls Enqueue() on another thread,\n  // but with an identical SynchWaitParams pointer, thus leaving the\n  // pointer unchanged.\n  SynchWaitParams* waitp;\n\n  intptr_t readers;  // Number of readers in mutex.\n\n  // When priority will next be read (cycles).\n  int64_t next_priority_read_cycles;\n\n  // Locks held; used during deadlock detection.\n  // Allocated in Synch_GetAllLocks() and freed in ReclaimThreadIdentity().\n  SynchLocksHeld* all_locks;\n};\n\n// The instances of this class are allocated in NewThreadIdentity() with an\n// alignment of PerThreadSynch::kAlignment.\n//\n// NOTE: The layout of fields in this structure is critical, please do not\n//       add, remove, or modify the field placements without fully auditing the\n//       layout.\nstruct ThreadIdentity {\n  // Must be the first member.  The Mutex implementation requires that\n  // the PerThreadSynch object associated with each thread is\n  // PerThreadSynch::kAlignment aligned.  We provide this alignment on\n  // ThreadIdentity itself.\n  PerThreadSynch per_thread_synch;\n\n  // Private: Reserved for absl::synchronization_internal::Waiter.\n  struct WaiterState {\n    alignas(void*) char data[256];\n  } waiter_state;\n\n  // Used by PerThreadSem::{Get,Set}ThreadBlockedCounter().\n  std::atomic<int>* blocked_count_ptr;\n\n  // The following variables are mostly read/written just by the\n  // thread itself.  The only exception is that these are read by\n  // a ticker thread as a hint.\n  std::atomic<int> ticker;      // Tick counter, incremented once per second.\n  std::atomic<int> wait_start;  // Ticker value when thread started waiting.\n  std::atomic<bool> is_idle;    // Has thread become idle yet?\n\n  ThreadIdentity* next;\n};\n\n// Returns the ThreadIdentity object representing the calling thread; guaranteed\n// to be unique for its lifetime.  The returned object will remain valid for the\n// program's lifetime; although it may be re-assigned to a subsequent thread.\n// If one does not exist, return nullptr instead.\n//\n// Does not malloc(*), and is async-signal safe.\n// [*] Technically pthread_setspecific() does malloc on first use; however this\n// is handled internally within tcmalloc's initialization already. Note that\n// darwin does *not* use tcmalloc, so this can catch you if using MallocHooks\n// on Apple platforms. Whatever function is calling your MallocHooks will need\n// to watch for recursion on Apple platforms.\n//\n// New ThreadIdentity objects can be constructed and associated with a thread\n// by calling GetOrCreateCurrentThreadIdentity() in per-thread-sem.h.\nThreadIdentity* CurrentThreadIdentityIfPresent();\n\nusing ThreadIdentityReclaimerFunction = void (*)(void*);\n\n// Sets the current thread identity to the given value.  'reclaimer' is a\n// pointer to the global function for cleaning up instances on thread\n// destruction.\nvoid SetCurrentThreadIdentity(ThreadIdentity* identity,\n                              ThreadIdentityReclaimerFunction reclaimer);\n\n// Removes the currently associated ThreadIdentity from the running thread.\n// This must be called from inside the ThreadIdentityReclaimerFunction, and only\n// from that function.\nvoid ClearCurrentThreadIdentity();\n\n// May be chosen at compile time via: -DABSL_FORCE_THREAD_IDENTITY_MODE=<mode\n// index>\n#ifdef ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\n#error ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC cannot be directly set\n#else\n#define ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC 0\n#endif\n\n#ifdef ABSL_THREAD_IDENTITY_MODE_USE_TLS\n#error ABSL_THREAD_IDENTITY_MODE_USE_TLS cannot be directly set\n#else\n#define ABSL_THREAD_IDENTITY_MODE_USE_TLS 1\n#endif\n\n#ifdef ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n#error ABSL_THREAD_IDENTITY_MODE_USE_CPP11 cannot be directly set\n#else\n#define ABSL_THREAD_IDENTITY_MODE_USE_CPP11 2\n#endif\n\n#ifdef ABSL_THREAD_IDENTITY_MODE\n#error ABSL_THREAD_IDENTITY_MODE cannot be directly set\n#elif defined(ABSL_FORCE_THREAD_IDENTITY_MODE)\n#define ABSL_THREAD_IDENTITY_MODE ABSL_FORCE_THREAD_IDENTITY_MODE\n#elif defined(_WIN32) && !defined(__MINGW32__)\n#define ABSL_THREAD_IDENTITY_MODE ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n#elif defined(__APPLE__) && defined(ABSL_HAVE_THREAD_LOCAL)\n#define ABSL_THREAD_IDENTITY_MODE ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n#elif ABSL_PER_THREAD_TLS && defined(__GOOGLE_GRTE_VERSION__) && \\\n    (__GOOGLE_GRTE_VERSION__ >= 20140228L)\n// Support for async-safe TLS was specifically added in GRTEv4.  It's not\n// present in the upstream eglibc.\n// Note:  Current default for production systems.\n#define ABSL_THREAD_IDENTITY_MODE ABSL_THREAD_IDENTITY_MODE_USE_TLS\n#else\n#define ABSL_THREAD_IDENTITY_MODE \\\n  ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\n#endif\n\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \\\n    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n\n#if ABSL_PER_THREAD_TLS\nABSL_CONST_INIT extern ABSL_PER_THREAD_TLS_KEYWORD ThreadIdentity*\n    thread_identity_ptr;\n#elif defined(ABSL_HAVE_THREAD_LOCAL)\nABSL_CONST_INIT extern thread_local ThreadIdentity* thread_identity_ptr;\n#else\n#error Thread-local storage not detected on this platform\n#endif\n\n// thread_local variables cannot be in headers exposed by DLLs or in certain\n// build configurations on Apple platforms. However, it is important for\n// performance reasons in general that `CurrentThreadIdentityIfPresent` be\n// inlined. In the other cases we opt to have the function not be inlined. Note\n// that `CurrentThreadIdentityIfPresent` is declared above so we can exclude\n// this entire inline definition.\n#if !defined(__APPLE__) && !defined(ABSL_BUILD_DLL) && \\\n    !defined(ABSL_CONSUME_DLL)\n#define ABSL_INTERNAL_INLINE_CURRENT_THREAD_IDENTITY_IF_PRESENT 1\n#endif\n\n#ifdef ABSL_INTERNAL_INLINE_CURRENT_THREAD_IDENTITY_IF_PRESENT\ninline ThreadIdentity* CurrentThreadIdentityIfPresent() {\n  return thread_identity_ptr;\n}\n#endif\n\n#elif ABSL_THREAD_IDENTITY_MODE != \\\n    ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\n#error Unknown ABSL_THREAD_IDENTITY_MODE\n#endif\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04731",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/thread_identity.h",
  "source_line": 37,
  "validation_status": "validated"
}