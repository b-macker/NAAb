{
  "code": "#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TargetCXXABI.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Frontend/OpenMP/OMPGridValues.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/TargetParser/Triple.h\"\n#include <cassert>\n#include <optional>\n#include <string>\n#include <vector>\n\nusing namespace llvm;\nusing namespace clang;\nusing namespace Builtin;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17339_execute() {\n    {\n  unsigned char PointerWidth, PointerAlign;\n  unsigned char BoolWidth, BoolAlign;\n  unsigned char IntWidth, IntAlign;\n  unsigned char HalfWidth, HalfAlign;\n  unsigned char BFloat16Width, BFloat16Align;\n  unsigned char FloatWidth, FloatAlign;\n  unsigned char DoubleWidth, DoubleAlign;\n  unsigned char LongDoubleWidth, LongDoubleAlign, Float128Align, Ibm128Align;\n  unsigned char LargeArrayMinWidth, LargeArrayAlign;\n  unsigned char LongWidth, LongAlign;\n  unsigned char LongLongWidth, LongLongAlign;\n  unsigned char Int128Align;\n\n  // Fixed point bit widths\n  unsigned char ShortAccumWidth, ShortAccumAlign;\n  unsigned char AccumWidth, AccumAlign;\n  unsigned char LongAccumWidth, LongAccumAlign;\n  unsigned char ShortFractWidth, ShortFractAlign;\n  unsigned char FractWidth, FractAlign;\n  unsigned char LongFractWidth, LongFractAlign;\n\n  // If true, unsigned fixed point types have the same number of fractional bits\n  // as their signed counterparts, forcing the unsigned types to have one extra\n  // bit of padding. Otherwise, unsigned fixed point types have\n  // one more fractional bit than its corresponding signed type. This is false\n  // by default.\n  bool PaddingOnUnsignedFixedPoint;\n\n  // Fixed point integral and fractional bit sizes\n  // Saturated types share the same integral/fractional bits as their\n  // corresponding unsaturated types.\n  // For simplicity, the fractional bits in a _Fract type will be one less the\n  // width of that _Fract type. This leaves all signed _Fract types having no\n  // padding and unsigned _Fract types will only have 1 bit of padding after the\n  // sign if PaddingOnUnsignedFixedPoint is set.\n  unsigned char ShortAccumScale;\n  unsigned char AccumScale;\n  unsigned char LongAccumScale;\n\n  unsigned char DefaultAlignForAttributeAligned;\n  unsigned char MinGlobalAlign;\n\n  unsigned short SuitableAlign;\n  unsigned short NewAlign;\n  unsigned MaxVectorAlign;\n  unsigned MaxTLSAlign;\n\n  const llvm::fltSemantics *HalfFormat, *BFloat16Format, *FloatFormat,\n      *DoubleFormat, *LongDoubleFormat, *Float128Format, *Ibm128Format;\n\n  ///===---- Target Data Type Query Methods -------------------------------===//\n  enum IntType {\n    NoInt = 0,\n    SignedChar,\n    UnsignedChar,\n    SignedShort,\n    UnsignedShort,\n    SignedInt,\n    UnsignedInt,\n    SignedLong,\n    UnsignedLong,\n    SignedLongLong,\n    UnsignedLongLong\n  };\n\nprotected:\n  IntType SizeType, IntMaxType, PtrDiffType, IntPtrType, WCharType, WIntType,\n      Char16Type, Char32Type, Int64Type, Int16Type, SigAtomicType,\n      ProcessIDType;\n\n  /// Whether Objective-C's built-in boolean type should be signed char.\n  ///\n  /// Otherwise, when this flag is not set, the normal built-in boolean type is\n  /// used.\n  unsigned UseSignedCharForObjCBool : 1;\n\n  /// Control whether the alignment of bit-field types is respected when laying\n  /// out structures. If true, then the alignment of the bit-field type will be\n  /// used to (a) impact the alignment of the containing structure, and (b)\n  /// ensure that the individual bit-field will not straddle an alignment\n  /// boundary.\n  unsigned UseBitFieldTypeAlignment : 1;\n\n  /// Whether zero length bitfields (e.g., int : 0;) force alignment of\n  /// the next bitfield.\n  ///\n  /// If the alignment of the zero length bitfield is greater than the member\n  /// that follows it, `bar', `bar' will be aligned as the type of the\n  /// zero-length bitfield.\n  unsigned UseZeroLengthBitfieldAlignment : 1;\n\n  /// Whether zero length bitfield alignment is respected if they are the\n  /// leading members.\n  unsigned UseLeadingZeroLengthBitfield : 1;\n\n  ///  Whether explicit bit field alignment attributes are honored.\n  unsigned UseExplicitBitFieldAlignment : 1;\n\n  /// If non-zero, specifies a fixed alignment value for bitfields that follow\n  /// zero length bitfield, regardless of the zero length bitfield type.\n  unsigned ZeroLengthBitfieldBoundary;\n\n  /// If non-zero, specifies a maximum alignment to truncate alignment\n  /// specified in the aligned attribute of a static variable to this value.\n  unsigned MaxAlignedAttribute;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17339",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/TargetInfo.h",
  "source_line": 84,
  "validation_status": "validated"
}