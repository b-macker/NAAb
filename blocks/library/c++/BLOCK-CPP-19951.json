{
  "code": "{\npublic:\n  enum LookupResultKind {\n    /// No entity found met the criteria.\n    NotFound = 0,\n\n    /// No entity found met the criteria within the current\n    /// instantiation,, but there were dependent base classes of the\n    /// current instantiation that could not be searched.\n    NotFoundInCurrentInstantiation,\n\n    /// Name lookup found a single declaration that met the\n    /// criteria.  getFoundDecl() will return this declaration.\n    Found,\n\n    /// Name lookup found a set of overloaded functions that\n    /// met the criteria.\n    FoundOverloaded,\n\n    /// Name lookup found an unresolvable value declaration\n    /// and cannot yet complete.  This only happens in C++ dependent\n    /// contexts with dependent using declarations.\n    FoundUnresolvedValue,\n\n    /// Name lookup results in an ambiguity; use\n    /// getAmbiguityKind to figure out what kind of ambiguity\n    /// we have.\n    Ambiguous\n  };\n\n  enum AmbiguityKind {\n    /// Name lookup results in an ambiguity because multiple\n    /// entities that meet the lookup criteria were found in\n    /// subobjects of different types. For example:\n    /// @code\n    /// struct A { void f(int); }\n    /// struct B { void f(double); }\n    /// struct C : A, B { };\n    /// void test(C c) {\n    ///   c.f(0); // error: A::f and B::f come from subobjects of different\n    ///           // types. overload resolution is not performed.\n    /// }\n    /// @endcode\n    AmbiguousBaseSubobjectTypes,\n\n    /// Name lookup results in an ambiguity because multiple\n    /// nonstatic entities that meet the lookup criteria were found\n    /// in different subobjects of the same type. For example:\n    /// @code\n    /// struct A { int x; };\n    /// struct B : A { };\n    /// struct C : A { };\n    /// struct D : B, C { };\n    /// int test(D d) {\n    ///   return d.x; // error: 'x' is found in two A subobjects (of B and C)\n    /// }\n    /// @endcode\n    AmbiguousBaseSubobjects,\n\n    /// Name lookup results in an ambiguity because multiple definitions\n    /// of entity that meet the lookup criteria were found in different\n    /// declaration contexts.\n    /// @code\n    /// namespace A {\n    ///   int i;\n    ///   namespace B { int i; }\n    ///   int test() {\n    ///     using namespace B;\n    ///     return i; // error 'i' is found in namespace A and A::B\n    ///    }\n    /// }\n    /// @endcode\n    AmbiguousReference,\n\n    /// Name lookup results in an ambiguity because an entity with a\n    /// tag name was hidden by an entity with an ordinary name from\n    /// a different context.\n    /// @code\n    /// namespace A { struct Foo {}; }\n    /// namespace B { void Foo(); }\n    /// namespace C {\n    ///   using namespace A;\n    ///   using namespace B;\n    /// }\n    /// void test() {\n    ///   C::Foo(); // error: tag 'A::Foo' is hidden by an object in a\n    ///             // different namespace\n    /// }\n    /// @endcode\n    AmbiguousTagHiding\n  };\n\n  /// A little identifier for flagging temporary lookup results.\n  enum TemporaryToken {\n    Temporary\n  };\n\n  using iterator = UnresolvedSetImpl::iterator;\n\n  LookupResult(Sema &SemaRef, const DeclarationNameInfo &NameInfo,\n               Sema::LookupNameKind LookupKind,\n               Sema::RedeclarationKind Redecl = Sema::NotForRedeclaration)\n      : SemaPtr(&SemaRef), NameInfo(NameInfo), LookupKind(LookupKind),\n        Redecl(Redecl != Sema::NotForRedeclaration),\n        ExternalRedecl(Redecl == Sema::ForExternalRedeclaration),\n        Diagnose(Redecl == Sema::NotForRedeclaration) {\n    configure();\n  }\n\n  // TODO: consider whether this constructor should be restricted to take\n  // as input a const IdentifierInfo* (instead of Name),\n  // forcing other cases towards the constructor taking a DNInfo.\n  LookupResult(Sema &SemaRef, DeclarationName Name,\n               SourceLocation NameLoc, Sema::LookupNameKind LookupKind,\n               Sema::RedeclarationKind Redecl = Sema::NotForRedeclaration)\n      : SemaPtr(&SemaRef), NameInfo(Name, NameLoc), LookupKind(LookupKind),\n        Redecl(Redecl != Sema::NotForRedeclaration),\n        ExternalRedecl(Redecl == Sema::ForExternalRedeclaration),\n        Diagnose(Redecl == Sema::NotForRedeclaration) {\n    configure();\n  }\n\n  /// Creates a temporary lookup result, initializing its core data\n  /// using the information from another result.  Diagnostics are always\n  /// disabled.\n  LookupResult(TemporaryToken _, const LookupResult &Other)\n      : SemaPtr(Other.SemaPtr), NameInfo(Other.NameInfo),\n        LookupKind(Other.LookupKind), IDNS(Other.IDNS), Redecl(Other.Redecl),\n        ExternalRedecl(Other.ExternalRedecl), HideTags(Other.HideTags),\n        AllowHidden(Other.AllowHidden),\n        TemplateNameLookup(Other.TemplateNameLookup) {}\n\n  // FIXME: Remove these deleted methods once the default build includes\n  // -Wdeprecated.\n  LookupResult(const LookupResult &) = delete;\n  LookupResult &operator=(const LookupResult &) = delete;\n\n  LookupResult(LookupResult &&Other)\n      : ResultKind(std::move(Other.ResultKind)),\n        Ambiguity(std::move(Other.Ambiguity)), Decls(std::move(Other.Decls)),\n        Paths(std::move(Other.Paths)),\n        NamingClass(std::move(Other.NamingClass)),\n        BaseObjectType(std::move(Other.BaseObjectType)),\n        SemaPtr(std::move(Other.SemaPtr)), NameInfo(std::move(Other.NameInfo)),\n        NameContextRange(std::move(Other.NameContextRange)),\n        LookupKind(std::move(Other.LookupKind)), IDNS(std::move(Other.IDNS)),\n        Redecl(std::move(Other.Redecl)),\n        ExternalRedecl(std::move(Other.ExternalRedecl)),\n        HideTags(std::move(Other.HideTags)),\n        Diagnose(std::move(Other.Diagnose)),\n        AllowHidden(std::move(Other.AllowHidden)),\n        Shadowed(std::move(Other.Shadowed)),\n        TemplateNameLookup(std::move(Other.TemplateNameLookup)) {\n    Other.Paths = nullptr;\n    Other.Diagnose = false;\n  }\n\n  LookupResult &operator=(LookupResult &&Other) {\n    ResultKind = std::move(Other.ResultKind);\n    Ambiguity = std::move(Other.Ambiguity);\n    Decls = std::move(Other.Decls);\n    Paths = std::move(Other.Paths);\n    NamingClass = std::move(Other.NamingClass);\n    BaseObjectType = std::move(Other.BaseObjectType);\n    SemaPtr = std::move(Other.SemaPtr);\n    NameInfo = std::move(Other.NameInfo);\n    NameContextRange = std::move(Other.NameContextRange);\n    LookupKind = std::move(Other.LookupKind);\n    IDNS = std::move(Other.IDNS);\n    Redecl = std::move(Other.Redecl);\n    ExternalRedecl = std::move(Other.ExternalRedecl);\n    HideTags = std::move(Other.HideTags);\n    Diagnose = std::move(Other.Diagnose);\n    AllowHidden = std::move(Other.AllowHidden);\n    Shadowed = std::move(Other.Shadowed);\n    TemplateNameLookup = std::move(Other.TemplateNameLookup);\n    Other.Paths = nullptr;\n    Other.Diagnose = false;\n    return *this;\n  }\n\n  ~LookupResult() {\n    if (Diagnose) diagnose();\n    if (Paths) deletePaths(Paths);\n  }\n\n  /// Gets the name info to look up.\n  const DeclarationNameInfo &getLookupNameInfo() const {\n    return NameInfo;\n  }\n\n  /// Sets the name info to look up.\n  void setLookupNameInfo(const DeclarationNameInfo &NameInfo) {\n    this->NameInfo = NameInfo;\n  }\n\n  /// Gets the name to look up.\n  DeclarationName getLookupName() const {\n    return NameInfo.getName();\n  }\n\n  /// Sets the name to look up.\n  void setLookupName(DeclarationName Name) {\n    NameInfo.setName(Name);\n  }\n\n  /// Gets the kind of lookup to perform.\n  Sema::LookupNameKind getLookupKind() const {\n    return LookupKind;\n  }\n\n  /// True if this lookup is just looking for an existing declaration.\n  bool isForRedeclaration() const {\n    return Redecl;\n  }\n\n  /// True if this lookup is just looking for an existing declaration to link\n  /// against a declaration with external linkage.\n  bool isForExternalRedeclaration() const {\n    return ExternalRedecl;\n  }\n\n  Sema::RedeclarationKind redeclarationKind() const {\n    return ExternalRedecl ? Sema::ForExternalRedeclaration :\n           Redecl ? Sema::ForVisibleRedeclaration : Sema::NotForRedeclaration;\n  }\n\n  /// Specify whether hidden declarations are visible, e.g.,\n  /// for recovery reasons.\n  void setAllowHidden(bool AH) {\n    AllowHidden = AH;\n  }\n\n  /// Determine whether this lookup is permitted to see hidden\n  /// declarations, such as those in modules that have not yet been imported.\n  bool isHiddenDeclarationVisible(NamedDecl *ND) const {\n    return AllowHidden ||\n           (isForExternalRedeclaration() && ND->isExternallyDeclarable());\n  }\n\n  /// Sets whether tag declarations should be hidden by non-tag\n  /// declarations during resolution.  The default is true.\n  void setHideTags(bool Hide) {\n    HideTags = Hide;\n  }\n\n  /// Sets whether this is a template-name lookup. For template-name lookups,\n  /// injected-class-names are treated as naming a template rather than a\n  /// template specialization.\n  void setTemplateNameLookup(bool TemplateName) {\n    TemplateNameLookup = TemplateName;\n  }\n\n  bool isTemplateNameLookup() const { return TemplateNameLookup; }\n\n  bool isAmbiguous() const {\n    return getResultKind() == Ambiguous;\n  }\n\n  /// Determines if this names a single result which is not an\n  /// unresolved value using decl.  If so, it is safe to call\n  /// getFoundDecl().\n  bool isSingleResult() const {\n    return getResultKind() == Found;\n  }\n\n  /// Determines if the results are overloaded.\n  bool isOverloadedResult() const {\n    return getResultKind() == FoundOverloaded;\n  }\n\n  bool isUnresolvableResult() const {\n    return getResultKind() == FoundUnresolvedValue;\n  }\n\n  LookupResultKind getResultKind() const {\n    assert(checkDebugAssumptions());\n    return ResultKind;\n  }\n\n  AmbiguityKind getAmbiguityKind() const {\n    assert(isAmbiguous());\n    return Ambiguity;\n  }\n\n  const UnresolvedSetImpl &asUnresolvedSet() const {\n    return Decls;\n  }\n\n  iterator begin() const { return iterator(Decls.begin()); }\n  iterator end() const { return iterator(Decls.end()); }\n\n  /// Return true if no decls were found\n  bool empty() const { return Decls.empty(); }\n\n  /// Return the base paths structure that's associated with\n  /// these results, or null if none is.\n  CXXBasePaths *getBasePaths() const {\n    return Paths;\n  }\n\n  /// Determine whether the given declaration is visible to the\n  /// program.\n  static bool isVisible(Sema &SemaRef, NamedDecl *D);\n\n  static bool isReachable(Sema &SemaRef, NamedDecl *D);\n\n  static bool isAcceptable(Sema &SemaRef, NamedDecl *D,\n                           Sema::AcceptableKind Kind) {\n    return Kind == Sema::AcceptableKind::Visible ? isVisible(SemaRef, D)\n                                                 : isReachable(SemaRef, D);\n  }\n\n  /// Determine whether this lookup is permitted to see the declaration.\n  /// Note that a reachable but not visible declaration inhabiting a namespace\n  /// is not allowed to be seen during name lookup.\n  ///\n  /// For example:\n  /// ```\n  /// // m.cppm\n  /// export module m;\n  /// struct reachable { int v; }\n  /// export auto func() { return reachable{43}; }\n  /// // Use.cpp\n  /// import m;\n  /// auto Use() {\n  ///   // Not valid. We couldn't see reachable here.\n  ///   // So isAvailableForLookup would return false when we look\n  ///   up 'reachable' here.\n  ///   // return reachable(43).v;\n  ///   // Valid. The field name 'v' is allowed during name lookup.\n  ///   // So isAvailableForLookup would return true when we look up 'v' here.\n  ///   return func().v;\n  /// }\n  /// ```\n  static bool isAvailableForLookup(Sema &SemaRef, NamedDecl *ND);\n\n  /// Retrieve the accepted (re)declaration of the given declaration,\n  /// if there is one.\n  NamedDecl *getAcceptableDecl(NamedDecl *D) const {\n    if (!D->isInIdentifierNamespace(IDNS))\n      return nullptr;\n\n    if (isAvailableForLookup(getSema(), D) || isHiddenDeclarationVisible(D))\n      return D;\n\n    return getAcceptableDeclSlow(D);\n  }\n\nprivate:\n  static bool isAcceptableSlow(Sema &SemaRef, NamedDecl *D,\n                               Sema::AcceptableKind Kind);\n  static bool isReachableSlow(Sema &SemaRef, NamedDecl *D);\n  NamedDecl *getAcceptableDeclSlow(NamedDecl *D) const;\n\npublic:\n  /// Returns the identifier namespace mask for this lookup.\n  unsigned getIdentifierNamespace() const {\n    return IDNS;\n  }\n\n  /// Returns whether these results arose from performing a\n  /// lookup into a class.\n  bool isClassLookup() const {\n    return NamingClass != nullptr;\n  }\n\n  /// Returns the 'naming class' for this lookup, i.e. the\n  /// class which was looked into to find these results.\n  ///\n  /// C++0x [class.access.base]p5:\n  ///   The access to a member is affected by the class in which the\n  ///   member is named. This naming class is the class in which the\n  ///   member name was looked up and found. [Note: this class can be\n  ///   explicit, e.g., when a qualified-id is used, or implicit,\n  ///   e.g., when a class member access operator (5.2.5) is used\n  ///   (including cases where an implicit \"this->\" is added). If both\n  ///   a class member access operator and a qualified-id are used to\n  ///   name the member (as in p->T::m), the class naming the member\n  ///   is the class named by the nested-name-specifier of the\n  ///   qualified-id (that is, T). -- end note ]\n  ///\n  /// This is set by the lookup routines when they find results in a class.\n  CXXRecordDecl *getNamingClass() const {\n    return NamingClass;\n  }\n\n  /// Sets the 'naming class' for this lookup.\n  void setNamingClass(CXXRecordDecl *Record) {\n    NamingClass = Record;\n  }\n\n  /// Returns the base object type associated with this lookup;\n  /// important for [class.protected].  Most lookups do not have an\n  /// associated base object.\n  QualType getBaseObjectType() const {\n    return BaseObjectType;\n  }\n\n  /// Sets the base object type for this lookup.\n  void setBaseObjectType(QualType T) {\n    BaseObjectType = T;\n  }\n\n  /// Add a declaration to these results with its natural access.\n  /// Does not test the acceptance criteria.\n  void addDecl(NamedDecl *D) {\n    addDecl(D, D->getAccess());\n  }\n\n  /// Add a declaration to these results with the given access.\n  /// Does not test the acceptance criteria.\n  void addDecl(NamedDecl *D, AccessSpecifier AS) {\n    Decls.addDecl(D, AS);\n    ResultKind = Found;\n  }\n\n  /// Add all the declarations from another set of lookup\n  /// results.\n  void addAllDecls(const LookupResult &Other) {\n    Decls.append(Other.Decls.begin(), Other.Decls.end());\n    ResultKind = Found;\n  }\n\n  /// Determine whether no result was found because we could not\n  /// search into dependent base classes of the current instantiation.\n  bool wasNotFoundInCurrentInstantiation() const {\n    return ResultKind == NotFoundInCurrentInstantiation;\n  }\n\n  /// Note that while no result was found in the current instantiation,\n  /// there were dependent base classes that could not be searched.\n  void setNotFoundInCurrentInstantiation() {\n    assert(ResultKind == NotFound && Decls.empty());\n    ResultKind = NotFoundInCurrentInstantiation;\n  }\n\n  /// Determine whether the lookup result was shadowed by some other\n  /// declaration that lookup ignored.\n  bool isShadowed() const { return Shadowed; }\n\n  /// Note that we found and ignored a declaration while performing\n  /// lookup.\n  void setShadowed() { Shadowed = true; }\n\n  /// Resolves the result kind of the lookup, possibly hiding\n  /// decls.\n  ///\n  /// This should be called in any environment where lookup might\n  /// generate multiple lookup results.\n  void resolveKind();\n\n  /// Re-resolves the result kind of the lookup after a set of\n  /// removals has been performed.\n  void resolveKindAfterFilter() {\n    if (Decls.empty()) {\n      if (ResultKind != NotFoundInCurrentInstantiation)\n        ResultKind = NotFound;\n\n      if (Paths) {\n        deletePaths(Paths);\n        Paths = nullptr;\n      }\n    } else {\n      std::optional<AmbiguityKind> SavedAK;\n      bool WasAmbiguous = false;\n      if (ResultKind == Ambiguous) {\n        SavedAK = Ambiguity;\n        WasAmbiguous = true;\n      }\n      ResultKind = Found;\n      resolveKind();\n\n      // If we didn't make the lookup unambiguous, restore the old\n      // ambiguity kind.\n      if (ResultKind == Ambiguous) {\n        (void)WasAmbiguous;\n        assert(WasAmbiguous);\n        Ambiguity = *SavedAK;\n      } else if (Paths) {\n        deletePaths(Paths);\n        Paths = nullptr;\n      }\n    }\n  }\n\n  template <class DeclClass>\n  DeclClass *getAsSingle() const {\n    if (getResultKind() != Found) return nullptr;\n    return dyn_cast<DeclClass>(getFoundDecl());\n  }\n\n  /// Fetch the unique decl found by this lookup.  Asserts\n  /// that one was found.\n  ///\n  /// This is intended for users who have examined the result kind\n  /// and are certain that there is only one result.\n  NamedDecl *getFoundDecl() const {\n    assert(getResultKind() == Found\n           && \"getFoundDecl called on non-unique result\");\n    return (*begin())->getUnderlyingDecl();\n  }\n\n  /// Fetches a representative decl.  Useful for lazy diagnostics.\n  NamedDecl *getRepresentativeDecl() const {\n    assert(!Decls.empty() && \"cannot get representative of empty set\");\n    return *begin();\n  }\n\n  /// Asks if the result is a single tag decl.\n  bool isSingleTagDecl() const {\n    return getResultKind() == Found && isa<TagDecl>(getFoundDecl());\n  }\n\n  /// Make these results show that the name was found in\n  /// base classes of different types.\n  ///\n  /// The given paths object is copied and invalidated.\n  void setAmbiguousBaseSubobjectTypes(CXXBasePaths &P);\n\n  /// Make these results show that the name was found in\n  /// distinct base classes of the same type.\n  ///\n  /// The given paths object is copied and invalidated.\n  void setAmbiguousBaseSubobjects(CXXBasePaths &P);\n\n  /// Make these results show that the name was found in\n  /// different contexts and a tag decl was hidden by an ordinary\n  /// decl in a different context.\n  void setAmbiguousQualifiedTagHiding() {\n    setAmbiguous(AmbiguousTagHiding);\n  }\n\n  /// Clears out any current state.\n  LLVM_ATTRIBUTE_REINITIALIZES void clear() {\n    ResultKind = NotFound;\n    Decls.clear();\n    if (Paths) deletePaths(Paths);\n    Paths = nullptr;\n    NamingClass = nullptr;\n    Shadowed = false;\n  }\n\n  /// Clears out any current state and re-initializes for a\n  /// different kind of lookup.\n  void clear(Sema::LookupNameKind Kind) {\n    clear();\n    LookupKind = Kind;\n    configure();\n  }\n\n  /// Change this lookup's redeclaration kind.\n  void setRedeclarationKind(Sema::RedeclarationKind RK) {\n    Redecl = (RK != Sema::NotForRedeclaration);\n    ExternalRedecl = (RK == Sema::ForExternalRedeclaration);\n    configure();\n  }\n\n  void dump();\n  void print(raw_ostream &);\n\n  /// Suppress the diagnostics that would normally fire because of this\n  /// lookup.  This happens during (e.g.) redeclaration lookups.\n  void suppressDiagnostics() {\n    Diagnose = false;\n  }\n\n  /// Determines whether this lookup is suppressing diagnostics.\n  bool isSuppressingDiagnostics() const {\n    return !Diagnose;\n  }\n\n  /// Sets a 'context' source range.\n  void setContextRange(SourceRange SR) {\n    NameContextRange = SR;\n  }\n\n  /// Gets the source range of the context of this name; for C++\n  /// qualified lookups, this is the source range of the scope\n  /// specifier.\n  SourceRange getContextRange() const {\n    return NameContextRange;\n  }\n\n  /// Gets the location of the identifier.  This isn't always defined:\n  /// sometimes we're doing lookups on synthesized names.\n  SourceLocation getNameLoc() const {\n    return NameInfo.getLoc();\n  }\n\n  /// Get the Sema object that this lookup result is searching\n  /// with.\n  Sema &getSema() const { return *SemaPtr; }\n\n  /// A class for iterating through a result set and possibly\n  /// filtering out results.  The results returned are possibly\n  /// sugared.\n  class Filter {\n    friend class LookupResult;\n\n    LookupResult &Results;\n    LookupResult::iterator I;\n    bool Changed = false;\n    bool CalledDone = false;\n\n    Filter(LookupResult &Results) : Results(Results), I(Results.begin()) {}\n\n  public:\n    Filter(Filter &&F)\n        : Results(F.Results), I(F.I), Changed(F.Changed),\n          CalledDone(F.CalledDone) {\n      F.CalledDone = true;\n    }\n\n    // The move assignment operator is defined as deleted pending\n    // further motivation.\n    Filter &operator=(Filter &&) = delete;\n\n    // The copy constrcutor and copy assignment operator is defined as deleted\n    // pending further motivation.\n    Filter(const Filter &) = delete;\n    Filter &operator=(const Filter &) = delete;\n\n    ~Filter() {\n      assert(CalledDone &&\n             \"LookupResult::Filter destroyed without done() call\");\n    }\n\n    bool hasNext() const {\n      return I != Results.end();\n    }\n\n    NamedDecl *next() {\n      assert(I != Results.end() && \"next() called on empty filter\");\n      return *I++;\n    }\n\n    /// Restart the iteration.\n    void restart() {\n      I = Results.begin();\n    }\n\n    /// Erase the last element returned from this iterator.\n    void erase() {\n      Results.Decls.erase(--I);\n      Changed = true;\n    }\n\n    /// Replaces the current entry with the given one, preserving the\n    /// access bits.\n    void replace(NamedDecl *D) {\n      Results.Decls.replace(I-1, D);\n      Changed = true;\n    }\n\n    /// Replaces the current entry with the given one.\n    void replace(NamedDecl *D, AccessSpecifier AS) {\n      Results.Decls.replace(I-1, D, AS);\n      Changed = true;\n    }\n\n    void done() {\n      assert(!CalledDone && \"done() called twice\");\n      CalledDone = true;\n\n      if (Changed)\n        Results.resolveKindAfterFilter();\n    }\n  };\n\n  /// Create a filter for this result set.\n  Filter makeFilter() {\n    return Filter(*this);\n  }\n\n  void setFindLocalExtern(bool FindLocalExtern) {\n    if (FindLocalExtern)\n      IDNS |= Decl::IDNS_LocalExtern;\n    else\n      IDNS &= ~Decl::IDNS_LocalExtern;\n  }\n\nprivate:\n  void diagnose() {\n    if (isAmbiguous())\n      getSema().DiagnoseAmbiguousLookup(*this);\n    else if (isClassLookup() && getSema().getLangOpts().AccessControl)\n      getSema().CheckLookupAccess(*this);\n  }\n\n  void setAmbiguous(AmbiguityKind AK) {\n    ResultKind = Ambiguous;\n    Ambiguity = AK;\n  }\n\n  void addDeclsFromBasePaths(const CXXBasePaths &P);\n  void configure();\n\n  bool checkDebugAssumptions() const;\n\n  bool checkUnresolved() const {\n    for (iterator I = begin(), E = end(); I != E; ++I)\n      if (isa<UnresolvedUsingValueDecl>((*I)->getUnderlyingDecl()))\n        return true;\n    return false;\n  }\n\n  static void deletePaths(CXXBasePaths *);\n\n  // Results.\n  LookupResultKind ResultKind = NotFound;\n  // ill-defined unless ambiguous. Still need to be initialized it will be\n  // copied/moved.\n  AmbiguityKind Ambiguity = {};\n  UnresolvedSet<8> Decls;\n  CXXBasePaths *Paths = nullptr;\n  CXXRecordDecl *NamingClass = nullptr;\n  QualType BaseObjectType;\n\n  // Parameters.\n  Sema *SemaPtr;\n  DeclarationNameInfo NameInfo;\n  SourceRange NameContextRange;\n  Sema::LookupNameKind LookupKind;\n  unsigned IDNS = 0; // set by configure()\n\n  bool Redecl;\n  bool ExternalRedecl;\n\n  /// True if tag declarations should be hidden if non-tags\n  ///   are present\n  bool HideTags = true;\n\n  bool Diagnose = false;\n\n  /// True if we should allow hidden declarations to be 'visible'.\n  bool AllowHidden = false;\n\n  /// True if the found declarations were shadowed by some other\n  /// declaration that we skipped. This only happens when \\c LookupKind\n  /// is \\c LookupRedeclarationWithLinkage.\n  bool Shadowed = false;\n\n  /// True if we're looking up a template-name.\n  bool TemplateNameLookup = false;\n}",
  "id": "BLOCK-CPP-19951",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Lookup.h",
  "source_line": 46,
  "validation_status": "validated"
}