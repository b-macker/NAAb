{
  "code": "#include \"clang/AST/Decl.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include <optional>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-15341_execute() {\n    {\n\n/// An instance of this class corresponds to a call.\n/// It might be a syntactically-concrete call, done as a part of evaluating an\n/// expression, or it may be an abstract callee with no associated expression.\nclass AnyCall {\npublic:\n  enum Kind {\n    /// A function, function pointer, or a C++ method call\n    Function,\n\n    /// A call to an Objective-C method\n    ObjCMethod,\n\n    /// A call to an Objective-C block\n    Block,\n\n    /// An implicit C++ destructor call (called implicitly\n    /// or by operator 'delete')\n    Destructor,\n\n    /// An implicit or explicit C++ constructor call\n    Constructor,\n\n    /// A C++ inherited constructor produced by a \"using T::T\" directive\n    InheritedConstructor,\n\n    /// A C++ allocation function call (operator `new`), via C++ new-expression\n    Allocator,\n\n    /// A C++ deallocation function call (operator `delete`), via C++\n    /// delete-expression\n    Deallocator\n  };\n\nprivate:\n  /// Either expression or declaration (but not both at the same time)\n  /// can be null.\n\n  /// Call expression, is null when is not known (then declaration is non-null),\n  /// or for implicit destructor calls (when no expression exists.)\n  const Expr *E = nullptr;\n\n  /// Corresponds to a statically known declaration of the called function,\n  /// or null if it is not known (e.g. for a function pointer).\n  const Decl *D = nullptr;\n  Kind K;\n\npublic:\n  AnyCall(const CallExpr *CE) : E(CE) {\n    D = CE->getCalleeDecl();\n    K = (CE->getCallee()->getType()->getAs<BlockPointerType>()) ? Block\n                                                                : Function;\n    if (D && ((K == Function && !isa<FunctionDecl>(D)) ||\n              (K == Block && !isa<BlockDecl>(D))))\n      D = nullptr;\n  }\n\n  AnyCall(const ObjCMessageExpr *ME)\n      : E(ME), D(ME->getMethodDecl()), K(ObjCMethod) {}\n\n  AnyCall(const CXXNewExpr *NE)\n      : E(NE), D(NE->getOperatorNew()), K(Allocator) {}\n\n  AnyCall(const CXXDeleteExpr *NE)\n      : E(NE), D(NE->getOperatorDelete()), K(Deallocator) {}\n\n  AnyCall(const CXXConstructExpr *NE)\n      : E(NE), D(NE->getConstructor()), K(Constructor) {}\n\n  AnyCall(const CXXInheritedCtorInitExpr *CIE)\n      : E(CIE), D(CIE->getConstructor()), K(InheritedConstructor) {}\n\n  AnyCall(const CXXDestructorDecl *D) : E(nullptr), D(D), K(Destructor) {}\n\n  AnyCall(const CXXConstructorDecl *D) : E(nullptr), D(D), K(Constructor) {}\n\n  AnyCall(const ObjCMethodDecl *D) : E(nullptr), D(D), K(ObjCMethod) {}\n\n  AnyCall(const FunctionDecl *D) : E(nullptr), D(D) {\n    if (isa<CXXConstructorDecl>(D)) {\n      K = Constructor;\n    } else if (isa <CXXDestructorDecl>(D)) {\n      K = Destructor;\n    } else {\n      K = Function;\n    }\n\n  }\n\n  /// If @c E is a generic call (to ObjC method /function/block/etc),\n  /// return a constructed @c AnyCall object. Return std::nullopt otherwise.\n  static std::optional<AnyCall> forExpr(const Expr *E) {\n    if (const auto *ME = dyn_cast<ObjCMessageExpr>(E)) {\n      return AnyCall(ME);\n    } else if (const auto *CE = dyn_cast<CallExpr>(E)) {\n      return AnyCall(CE);\n    } else if (const auto *CXNE = dyn_cast<CXXNewExpr>(E)) {\n      return AnyCall(CXNE);\n    } else if (const auto *CXDE = dyn_cast<CXXDeleteExpr>(E)) {\n      return AnyCall(CXDE);\n    } else if (const auto *CXCE = dyn_cast<CXXConstructExpr>(E)) {\n      return AnyCall(CXCE);\n    } else if (const auto *CXCIE = dyn_cast<CXXInheritedCtorInitExpr>(E)) {\n      return AnyCall(CXCIE);\n    } else {\n      return std::nullopt;\n    }\n  }\n\n  /// If @c D is a callable (Objective-C method or a function), return\n  /// a constructed @c AnyCall object. Return std::nullopt otherwise.\n  // FIXME: block support.\n  static std::optional<AnyCall> forDecl(const Decl *D) {\n    if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n      return AnyCall(FD);\n    } else if (const auto *MD = dyn_cast<ObjCMethodDecl>(D)) {\n      return AnyCall(MD);\n    }\n    return std::nullopt;\n  }\n\n  /// \\returns formal parameters for direct calls (including virtual calls)\n  ArrayRef<ParmVarDecl *> parameters() const {\n    if (!D)\n      return std::nullopt;\n\n    if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n      return FD->parameters();\n    } else if (const auto *MD = dyn_cast<ObjCMethodDecl>(D)) {\n      return MD->parameters();\n    } else if (const auto *BD = dyn_cast<BlockDecl>(D)) {\n      return BD->parameters();\n    } else {\n      return std::nullopt;\n    }\n  }\n\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n  bool param_empty() const { return parameters().empty(); }\n\n  QualType getReturnType(ASTContext &Ctx) const {\n    switch (K) {\n    case Function:\n      if (E)\n        return cast<CallExpr>(E)->getCallReturnType(Ctx);\n      return cast<FunctionDecl>(D)->getReturnType();\n    case ObjCMethod:\n      if (E)\n        return cast<ObjCMessageExpr>(E)->getCallReturnType(Ctx);\n      return cast<ObjCMethodDecl>(D)->getReturnType();\n    case Block:\n      // FIXME: BlockDecl does not know its return type,\n      // hence the asymmetry with the function and method cases above.\n      return cast<CallExpr>(E)->getCallReturnType(Ctx);\n    case Destructor:\n    case Constructor:\n    case InheritedConstructor:\n    case Allocator:\n    case Deallocator:\n      return cast<FunctionDecl>(D)->getReturnType();\n    }\n    llvm_unreachable(\"Unknown AnyCall::Kind\");\n  }\n\n  /// \\returns Function identifier if it is a named declaration,\n  /// @c nullptr otherwise.\n  const IdentifierInfo *getIdentifier() const {\n    if (const auto *ND = dyn_cast_or_null<NamedDecl>(D))\n      return ND->getIdentifier();\n    return nullptr;\n  }\n\n  const Decl *getDecl() const {\n    return D;\n  }\n\n  const Expr *getExpr() const {\n    return E;\n  }\n\n  Kind getKind() const {\n    return K;\n  }\n\n  void dump() const {\n    if (E)\n      E->dump();\n    if (D)\n      D->dump();\n  }\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-15341",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/AnyCall.h",
  "source_line": 21,
  "validation_status": "validated"
}