{
  "code": "{\n\nclass ASTContext;\nclass VarDecl;\nclass CXXRecordDecl;\nclass Sema;\nclass QualType;\nclass NamespaceDecl;\n\n/// An enumeration representing the different comparison categories\n/// types.\n///\n/// C++20 [cmp.categories.pre] The types partial_ordering, weak_ordering, and\n/// strong_ordering are collectively termed the comparison category types.\nenum class ComparisonCategoryType : unsigned char {\n  PartialOrdering,\n  WeakOrdering,\n  StrongOrdering,\n  First = PartialOrdering,\n  Last = StrongOrdering\n};\n\n/// Determine the common comparison type, as defined in C++2a\n/// [class.spaceship]p4.\ninline ComparisonCategoryType commonComparisonType(ComparisonCategoryType A,\n                                                   ComparisonCategoryType B) {\n  return A < B ? A : B;\n}\n\n/// Get the comparison category that should be used when comparing values of\n/// type \\c T.\nstd::optional<ComparisonCategoryType>\ngetComparisonCategoryForBuiltinCmp(QualType T);\n\n/// An enumeration representing the possible results of a three-way\n/// comparison. These values map onto instances of comparison category types\n/// defined in the standard library. e.g. 'std::strong_ordering::less'.\nenum class ComparisonCategoryResult : unsigned char {\n  Equal,\n  Equivalent,\n  Less,\n  Greater,\n  Unordered,\n  Last = Unordered\n};\n\nclass ComparisonCategoryInfo {\n  friend class ComparisonCategories;\n  friend class Sema;\n\npublic:\n  ComparisonCategoryInfo(const ASTContext &Ctx, CXXRecordDecl *RD,\n                         ComparisonCategoryType Kind)\n      : Ctx(Ctx), Record(RD), Kind(Kind) {}\n\n  struct ValueInfo {\n    ComparisonCategoryResult Kind;\n    VarDecl *VD;\n\n    ValueInfo(ComparisonCategoryResult Kind, VarDecl *VD)\n        : Kind(Kind), VD(VD) {}\n\n    /// True iff we've successfully evaluated the variable as a constant\n    /// expression and extracted its integer value.\n    bool hasValidIntValue() const;\n\n    /// Get the constant integer value used by this variable to represent\n    /// the comparison category result type.\n    llvm::APSInt getIntValue() const;\n  };\nprivate:\n  const ASTContext &Ctx;\n\n  /// A map containing the comparison category result decls from the\n  /// standard library. The key is a value of ComparisonCategoryResult.\n  mutable llvm::SmallVector<\n      ValueInfo, static_cast<unsigned>(ComparisonCategoryResult::Last) + 1>\n      Objects;\n\n  /// Lookup the ValueInfo struct for the specified ValueKind. If the\n  /// VarDecl for the value cannot be found, nullptr is returned.\n  ///\n  /// If the ValueInfo does not have a valid integer value the variable\n  /// is evaluated as a constant expression to determine that value.\n  ValueInfo *lookupValueInfo(ComparisonCategoryResult ValueKind) const;\n\npublic:\n  /// The declaration for the comparison category type from the\n  /// standard library.\n  const CXXRecordDecl *Record = nullptr;\n\n  /// The Kind of the comparison category type\n  ComparisonCategoryType Kind;\n\npublic:\n  QualType getType() const;\n\n  const ValueInfo *getValueInfo(ComparisonCategoryResult ValueKind) const {\n    ValueInfo *Info = lookupValueInfo(ValueKind);\n    assert(Info &&\n           \"comparison category does not contain the specified result kind\");\n    assert(Info->hasValidIntValue() &&\n           \"couldn't determine the integer constant for this value\");\n    return Info;\n  }\n\n  /// True iff the comparison is \"strong\". i.e. it checks equality and\n  /// not equivalence.\n  bool isStrong() const {\n    using CCK = ComparisonCategoryType;\n    return Kind == CCK::StrongOrdering;\n  }\n\n  /// True iff the comparison is not totally ordered.\n  bool isPartial() const {\n    using CCK = ComparisonCategoryType;\n    return Kind == CCK::PartialOrdering;\n  }\n\n  /// Converts the specified result kind into the correct result kind\n  /// for this category. Specifically it lowers strong equality results to\n  /// weak equivalence if needed.\n  ComparisonCategoryResult makeWeakResult(ComparisonCategoryResult Res) const {\n    using CCR = ComparisonCategoryResult;\n    if (!isStrong() && Res == CCR::Equal)\n      return CCR::Equivalent;\n    return Res;\n  }\n\n  const ValueInfo *getEqualOrEquiv() const {\n    return getValueInfo(makeWeakResult(ComparisonCategoryResult::Equal));\n  }\n  const ValueInfo *getLess() const {\n    return getValueInfo(ComparisonCategoryResult::Less);\n  }\n  const ValueInfo *getGreater() const {\n    return getValueInfo(ComparisonCategoryResult::Greater);\n  }\n  const ValueInfo *getUnordered() const {\n    assert(isPartial());\n    return getValueInfo(ComparisonCategoryResult::Unordered);\n  }\n};\n\nclass ComparisonCategories {\npublic:\n  static StringRef getCategoryString(ComparisonCategoryType Kind);\n  static StringRef getResultString(ComparisonCategoryResult Kind);\n\n  /// Return the list of results which are valid for the specified\n  /// comparison category type.\n  static std::vector<ComparisonCategoryResult>\n  getPossibleResultsForType(ComparisonCategoryType Type);\n\n  /// Return the comparison category information for the category\n  /// specified by 'Kind'.\n  const ComparisonCategoryInfo &getInfo(ComparisonCategoryType Kind) const {\n    const ComparisonCategoryInfo *Result = lookupInfo(Kind);\n    assert(Result != nullptr &&\n           \"information for specified comparison category has not been built\");\n    return *Result;\n  }\n\n  /// Return the comparison category information as specified by\n  /// `getCategoryForType(Ty)`. If the information is not already cached,\n  /// the declaration is looked up and a cache entry is created.\n  /// NOTE: Lookup is expected to succeed. Use lookupInfo if failure is\n  /// possible.\n  const ComparisonCategoryInfo &getInfoForType(QualType Ty) const;\n\npublic:\n  /// Return the cached comparison category information for the\n  /// specified 'Kind'. If no cache entry is present the comparison category\n  /// type is looked up. If lookup fails nullptr is returned. Otherwise, a\n  /// new cache entry is created and returned\n  const ComparisonCategoryInfo *lookupInfo(ComparisonCategoryType Kind) const;\n\n  ComparisonCategoryInfo *lookupInfo(ComparisonCategoryType Kind) {\n    const auto &This = *this;\n    return const_cast<ComparisonCategoryInfo *>(This.lookupInfo(Kind));\n  }\n\n  const ComparisonCategoryInfo *lookupInfoForType(QualType Ty) const;\n\nprivate:\n  friend class ASTContext;\n\n  explicit ComparisonCategories(const ASTContext &Ctx) : Ctx(Ctx) {}\n\n  const ASTContext &Ctx;\n\n  /// A map from the ComparisonCategoryType (represented as 'char') to the\n  /// cached information for the specified category.\n  mutable llvm::DenseMap<char, ComparisonCategoryInfo> Data;\n  mutable NamespaceDecl *StdNS = nullptr;\n};\n\n}",
  "id": "BLOCK-CPP-23469",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ComparisonCategories.h",
  "source_line": 30,
  "validation_status": "validated"
}