{
  "code": "#include <atomic>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/container/inlined_vector.h\"\n#include \"absl/strings/cord.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/types/optional.h\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace status_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06000_execute() {\n    {\n public:\n  StatusRep(absl::StatusCode code_arg, absl::string_view message_arg,\n            std::unique_ptr<status_internal::Payloads> payloads_arg)\n      : ref_(int32_t{1}),\n        code_(code_arg),\n        message_(message_arg),\n        payloads_(std::move(payloads_arg)) {}\n\n  absl::StatusCode code() const { return code_; }\n  const std::string& message() const { return message_; }\n\n  // Ref and unref are const to allow access through a const pointer, and are\n  // used during copying operations.\n  void Ref() const { ref_.fetch_add(1, std::memory_order_relaxed); }\n  void Unref() const;\n\n  // Payload methods correspond to the same methods in absl::Status.\n  absl::optional<absl::Cord> GetPayload(absl::string_view type_url) const;\n  void SetPayload(absl::string_view type_url, absl::Cord payload);\n  struct EraseResult {\n    bool erased;\n    uintptr_t new_rep;\n  };\n  EraseResult ErasePayload(absl::string_view type_url);\n  void ForEachPayload(\n      absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)\n      const;\n\n  std::string ToString(StatusToStringMode mode) const;\n\n  bool operator==(const StatusRep& other) const;\n  bool operator!=(const StatusRep& other) const { return !(*this == other); }\n\n  // Returns an equivalent heap allocated StatusRep with refcount 1.\n  //\n  // `this` is not safe to be used after calling as it may have been deleted.\n  absl::Nonnull<StatusRep*> CloneAndUnref() const;\n\n private:\n  mutable std::atomic<int32_t> ref_;\n  absl::StatusCode code_;\n\n  // As an internal implementation detail, we guarantee that if status.message()\n  // is non-empty, then the resulting string_view is null terminated.\n  // This is required to implement 'StatusMessageAsCStr(...)'\n  std::string message_;\n  std::unique_ptr<status_internal::Payloads> payloads_;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06000",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/internal/status_internal.h",
  "source_line": 66,
  "validation_status": "validated"
}