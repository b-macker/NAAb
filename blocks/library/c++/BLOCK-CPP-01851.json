{
  "code": "#include \"absl/strings/charconv.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <system_error>  // NOLINT(build/c++11)\n#include \"absl/base/casts.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/strings/internal/charconv_bigint.h\"\n#include \"absl/strings/internal/charconv_parse.h\"\n\nusing namespace absl;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01851_execute() {\n    {\n  CalculatedFloat result;\n\n  // Large or small enough decimal exponents will always result in overflow\n  // or underflow.\n  if (Power10Underflow(parsed_decimal.exponent)) {\n    result.exponent = kUnderflow;\n    return result;\n  } else if (Power10Overflow(parsed_decimal.exponent)) {\n    result.exponent = kOverflow;\n    return result;\n  }\n\n  // Otherwise convert our power of 10 into a power of 2 times an integer\n  // mantissa, and multiply this by our parsed decimal mantissa.\n  uint128 wide_binary_mantissa = parsed_decimal.mantissa;\n  wide_binary_mantissa *= Power10Mantissa(parsed_decimal.exponent);\n  int binary_exponent = Power10Exponent(parsed_decimal.exponent);\n\n  // Discard bits that are inaccurate due to truncation error.  The magic\n  // `mantissa_width` constants below are justified in\n  // https://abseil.io/about/design/charconv. They represent the number of bits\n  // in `wide_binary_mantissa` that are guaranteed to be unaffected by error\n  // propagation.\n  bool mantissa_exact;\n  int mantissa_width;\n  if (parsed_decimal.subrange_begin) {\n    // Truncated mantissa\n    mantissa_width = 58;\n    mantissa_exact = false;\n    binary_exponent +=\n        TruncateToBitWidth(mantissa_width, &wide_binary_mantissa);\n  } else if (!Power10Exact(parsed_decimal.exponent)) {\n    // Exact mantissa, truncated power of ten\n    mantissa_width = 63;\n    mantissa_exact = false;\n    binary_exponent +=\n        TruncateToBitWidth(mantissa_width, &wide_binary_mantissa);\n  } else {\n    // Product is exact\n    mantissa_width = BitWidth(wide_binary_mantissa);\n    mantissa_exact = true;\n  }\n\n  // Shift into an FloatType-sized mantissa, and round to nearest.\n  const int shift =\n      NormalizedShiftSize<FloatType>(mantissa_width, binary_exponent);\n  bool result_exact;\n  binary_exponent += shift;\n  uint64_t binary_mantissa = ShiftRightAndRound(wide_binary_mantissa, shift,\n                                                mantissa_exact, &result_exact);\n  if (!result_exact) {\n    // We could not determine the rounding direction using int128 math.  Use\n    // full resolution math instead.\n    if (MustRoundUp(binary_mantissa, binary_exponent, parsed_decimal)) {\n      binary_mantissa += 1;\n    }\n  }\n\n  return CalculatedFloatFromRawValues<FloatType>(binary_mantissa,\n                                                 binary_exponent);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01851",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/charconv.cc",
  "source_line": 618,
  "validation_status": "validated"
}