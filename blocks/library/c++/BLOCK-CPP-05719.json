{
  "code": "#include <stdint.h>\n#include <ostream>\n#include <sstream>\n#include <string>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/log/internal/nullguard.h\"\n#include \"absl/log/internal/nullstream.h\"\n#include \"absl/log/internal/strip.h\"\n// * We don't want this file to depend on `absl::Status` `#include`s or linkage,\n//   `Status` and the necessary `#include`s and linkage.\n\nusing namespace absl;\nusing namespace status_internal;\nusing namespace status_internal;\nusing namespace log_internal;\nusing namespace detect_specialization;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05719_execute() {\n    {\n\n// MakeCheckOpString is being specialized for every T and U pair that is being\n// passed to the CHECK_op macros. However, there is a lot of redundancy in these\n// specializations that creates unnecessary library and binary bloat.\n// The number of instantiations tends to be O(n^2) because we have two\n// independent inputs. This technique works by reducing `n`.\n//\n// Most user-defined types being passed to CHECK_op end up being printed as a\n// builtin type. For example, enums tend to be implicitly converted to its\n// underlying type when calling operator<<, and pointers are printed with the\n// `const void*` overload.\n// To reduce the number of instantiations we coerce these values before calling\n// MakeCheckOpString instead of inside it.\n//\n// To detect if this coercion is needed, we duplicate all the relevant\n// operator<< overloads as specified in the standard, just in a different\n// namespace. If the call to `stream << value` becomes ambiguous, it means that\n// one of these overloads is the one selected by overload resolution. We then\n// do overload resolution again just with our overload set to see which one gets\n// selected. That tells us which type to coerce to.\n// If the augmented call was not ambiguous, it means that none of these were\n// selected and we can't coerce the input.\n//\n// As a secondary step to reduce code duplication, we promote integral types to\n// their 64-bit variant. This does not change the printed value, but reduces the\n// number of instantiations even further. Promoting an integer is very cheap at\n// the call site.\nint64_t operator<<(std::ostream&, short value);           // NOLINT\nint64_t operator<<(std::ostream&, unsigned short value);  // NOLINT\nint64_t operator<<(std::ostream&, int value);\nint64_t operator<<(std::ostream&, unsigned int value);\nint64_t operator<<(std::ostream&, long value);                 // NOLINT\nuint64_t operator<<(std::ostream&, unsigned long value);       // NOLINT\nint64_t operator<<(std::ostream&, long long value);            // NOLINT\nuint64_t operator<<(std::ostream&, unsigned long long value);  // NOLINT\nfloat operator<<(std::ostream&, float value);\ndouble operator<<(std::ostream&, double value);\nlong double operator<<(std::ostream&, long double value);\nbool operator<<(std::ostream&, bool value);\nconst void* operator<<(std::ostream&, const void* value);\nconst void* operator<<(std::ostream&, std::nullptr_t);\n\n// These `char` overloads are specified like this in the standard, so we have to\n// write them exactly the same to ensure the call is ambiguous.\n// If we wrote it in a different way (eg taking std::ostream instead of the\n// template) then one call might have a higher rank than the other and it would\n// not be ambiguous.\ntemplate <typename Traits>\nchar operator<<(std::basic_ostream<char, Traits>&, char);\ntemplate <typename Traits>\nsigned char operator<<(std::basic_ostream<char, Traits>&, signed char);\ntemplate <typename Traits>\nunsigned char operator<<(std::basic_ostream<char, Traits>&, unsigned char);\ntemplate <typename Traits>\nconst char* operator<<(std::basic_ostream<char, Traits>&, const char*);\ntemplate <typename Traits>\nconst signed char* operator<<(std::basic_ostream<char, Traits>&,\n                              const signed char*);\ntemplate <typename Traits>\nconst unsigned char* operator<<(std::basic_ostream<char, Traits>&,\n                                const unsigned char*);\n\n// This overload triggers when the call is not ambiguous.\n// It means that T is being printed with some overload not on this list.\n// We keep the value as `const T&`.\ntemplate <typename T, typename = decltype(std::declval<std::ostream&>()\n                                          << std::declval<const T&>())>\nconst T& Detect(int);\n\n// This overload triggers when the call is ambiguous.\n// It means that T is either one from this list or printed as one from this\n// list. Eg an enum that decays to `int` for printing.\n// We ask the overload set to give us the type we want to convert it to.\ntemplate <typename T>\ndecltype(detect_specialization::operator<<(std::declval<std::ostream&>(),\n                                           std::declval<const T&>()))\nDetect(char);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05719",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/check_op.h",
  "source_line": 211,
  "validation_status": "validated"
}