{
  "code": "{\n\nclass Driver;\nclass ToolChain;\n\n/// Compilation - A set of tasks to perform for a single driver\n/// invocation.\nclass Compilation {\n  /// The driver we were created by.\n  const Driver &TheDriver;\n\n  /// The default tool chain.\n  const ToolChain &DefaultToolChain;\n\n  /// A mask of all the programming models the host has to support in the\n  /// current compilation.\n  unsigned ActiveOffloadMask = 0;\n\n  /// Array with the toolchains of offloading host and devices in the order they\n  /// were requested by the user. We are preserving that order in case the code\n  /// generation needs to derive a programming-model-specific semantic out of\n  /// it.\n  std::multimap<Action::OffloadKind, const ToolChain *>\n      OrderedOffloadingToolchains;\n\n  /// The original (untranslated) input argument list.\n  llvm::opt::InputArgList *Args;\n\n  /// The driver translated arguments. Note that toolchains may perform their\n  /// own argument translation.\n  llvm::opt::DerivedArgList *TranslatedArgs;\n\n  /// The list of actions we've created via MakeAction.  This is not accessible\n  /// to consumers; it's here just to manage ownership.\n  std::vector<std::unique_ptr<Action>> AllActions;\n\n  /// The list of actions.  This is maintained and modified by consumers, via\n  /// getActions().\n  ActionList Actions;\n\n  /// The root list of jobs.\n  JobList Jobs;\n\n  /// Cache of translated arguments for a particular tool chain, bound\n  /// architecture, and device offload kind.\n  struct TCArgsKey final {\n    const ToolChain *TC = nullptr;\n    StringRef BoundArch;\n    Action::OffloadKind DeviceOffloadKind = Action::OFK_None;\n\n    TCArgsKey(const ToolChain *TC, StringRef BoundArch,\n              Action::OffloadKind DeviceOffloadKind)\n        : TC(TC), BoundArch(BoundArch), DeviceOffloadKind(DeviceOffloadKind) {}\n\n    bool operator<(const TCArgsKey &K) const {\n      if (TC < K.TC)\n        return true;\n      else if (TC == K.TC && BoundArch < K.BoundArch)\n        return true;\n      else if (TC == K.TC && BoundArch == K.BoundArch &&\n               DeviceOffloadKind < K.DeviceOffloadKind)\n        return true;\n      return false;\n    }\n  };\n  std::map<TCArgsKey, llvm::opt::DerivedArgList *> TCArgs;\n\n  /// Temporary files which should be removed on exit.\n  llvm::opt::ArgStringList TempFiles;\n\n  /// Result files which should be removed on failure.\n  ArgStringMap ResultFiles;\n\n  /// Result files which are generated correctly on failure, and which should\n  /// only be removed if we crash.\n  ArgStringMap FailureResultFiles;\n\n  /// -ftime-trace result files.\n  ArgStringMap TimeTraceFiles;\n\n  /// Optional redirection for stdin, stdout, stderr.\n  std::vector<std::optional<StringRef>> Redirects;\n\n  /// Callback called after compilation job has been finished.\n  /// Arguments of the callback are the compilation job as an instance of\n  /// class Command and the exit status of the corresponding child process.\n  std::function<void(const Command &, int)> PostCallback;\n\n  /// Whether we're compiling for diagnostic purposes.\n  bool ForDiagnostics = false;\n\n  /// Whether an error during the parsing of the input args.\n  bool ContainsError;\n\n  /// Whether to keep temporary files regardless of -save-temps.\n  bool ForceKeepTempFiles = false;\n\npublic:\n  Compilation(const Driver &D, const ToolChain &DefaultToolChain,\n              llvm::opt::InputArgList *Args,\n              llvm::opt::DerivedArgList *TranslatedArgs, bool ContainsError);\n  ~Compilation();\n\n  const Driver &getDriver() const { return TheDriver; }\n\n  const ToolChain &getDefaultToolChain() const { return DefaultToolChain; }\n\n  unsigned isOffloadingHostKind(Action::OffloadKind Kind) const {\n    return ActiveOffloadMask & Kind;\n  }\n\n  unsigned getActiveOffloadKinds() const { return ActiveOffloadMask; }\n\n  /// Iterator that visits device toolchains of a given kind.\n  using const_offload_toolchains_iterator =\n      const std::multimap<Action::OffloadKind,\n                          const ToolChain *>::const_iterator;\n  using const_offload_toolchains_range =\n      std::pair<const_offload_toolchains_iterator,\n                const_offload_toolchains_iterator>;\n\n  template <Action::OffloadKind Kind>\n  const_offload_toolchains_range getOffloadToolChains() const {\n    return OrderedOffloadingToolchains.equal_range(Kind);\n  }\n\n  const_offload_toolchains_range\n  getOffloadToolChains(Action::OffloadKind Kind) const {\n    return OrderedOffloadingToolchains.equal_range(Kind);\n  }\n\n  /// Return true if an offloading tool chain of a given kind exists.\n  template <Action::OffloadKind Kind> bool hasOffloadToolChain() const {\n    return OrderedOffloadingToolchains.find(Kind) !=\n           OrderedOffloadingToolchains.end();\n  }\n\n  /// Return an offload toolchain of the provided kind. Only one is expected to\n  /// exist.\n  template <Action::OffloadKind Kind>\n  const ToolChain *getSingleOffloadToolChain() const {\n    auto TCs = getOffloadToolChains<Kind>();\n\n    assert(TCs.first != TCs.second &&\n           \"No tool chains of the selected kind exist!\");\n    assert(std::next(TCs.first) == TCs.second &&\n           \"More than one tool chain of the this kind exist.\");\n    return TCs.first->second;\n  }\n\n  void addOffloadDeviceToolChain(const ToolChain *DeviceToolChain,\n                                 Action::OffloadKind OffloadKind) {\n    assert(OffloadKind != Action::OFK_Host && OffloadKind != Action::OFK_None &&\n           \"This is not a device tool chain!\");\n\n    // Update the host offload kind to also contain this kind.\n    ActiveOffloadMask |= OffloadKind;\n    OrderedOffloadingToolchains.insert(\n        std::make_pair(OffloadKind, DeviceToolChain));\n  }\n\n  const llvm::opt::InputArgList &getInputArgs() const { return *Args; }\n\n  const llvm::opt::DerivedArgList &getArgs() const { return *TranslatedArgs; }\n\n  llvm::opt::DerivedArgList &getArgs() { return *TranslatedArgs; }\n\n  ActionList &getActions() { return Actions; }\n  const ActionList &getActions() const { return Actions; }\n\n  /// Creates a new Action owned by this Compilation.\n  ///\n  /// The new Action is *not* added to the list returned by getActions().\n  template <typename T, typename... Args> T *MakeAction(Args &&... Arg) {\n    T *RawPtr = new T(std::forward<Args>(Arg)...);\n    AllActions.push_back(std::unique_ptr<Action>(RawPtr));\n    return RawPtr;\n  }\n\n  JobList &getJobs() { return Jobs; }\n  const JobList &getJobs() const { return Jobs; }\n\n  void addCommand(std::unique_ptr<Command> C) { Jobs.addJob(std::move(C)); }\n\n  llvm::opt::ArgStringList &getTempFiles() { return TempFiles; }\n  const llvm::opt::ArgStringList &getTempFiles() const { return TempFiles; }\n\n  const ArgStringMap &getResultFiles() const { return ResultFiles; }\n\n  const ArgStringMap &getFailureResultFiles() const {\n    return FailureResultFiles;\n  }\n\n  /// Installs a handler that is executed when a compilation job is finished.\n  /// The arguments of the callback specify the compilation job as an instance\n  /// of class Command and the exit status of the child process executed that\n  /// job.\n  void setPostCallback(const std::function<void(const Command &, int)> &CB) {\n    PostCallback = CB;\n  }\n\n  /// Returns the sysroot path.\n  StringRef getSysRoot() const;\n\n  /// getArgsForToolChain - Return the derived argument list for the\n  /// tool chain \\p TC (or the default tool chain, if TC is not specified).\n  /// If a device offloading kind is specified, a translation specific for that\n  /// kind is performed, if any.\n  ///\n  /// \\param BoundArch - The bound architecture name, or 0.\n  /// \\param DeviceOffloadKind - The offload device kind that should be used in\n  /// the translation, if any.\n  const llvm::opt::DerivedArgList &\n  getArgsForToolChain(const ToolChain *TC, StringRef BoundArch,\n                      Action::OffloadKind DeviceOffloadKind);\n\n  /// addTempFile - Add a file to remove on exit, and returns its\n  /// argument.\n  const char *addTempFile(const char *Name) {\n    TempFiles.push_back(Name);\n    return Name;\n  }\n\n  /// addResultFile - Add a file to remove on failure, and returns its\n  /// argument.\n  const char *addResultFile(const char *Name, const JobAction *JA) {\n    ResultFiles[JA] = Name;\n    return Name;\n  }\n\n  /// addFailureResultFile - Add a file to remove if we crash, and returns its\n  /// argument.\n  const char *addFailureResultFile(const char *Name, const JobAction *JA) {\n    FailureResultFiles[JA] = Name;\n    return Name;\n  }\n\n  const char *getTimeTraceFile(const JobAction *JA) const {\n    return TimeTraceFiles.lookup(JA);\n  }\n  void addTimeTraceFile(const char *Name, const JobAction *JA) {\n    assert(!TimeTraceFiles.contains(JA));\n    TimeTraceFiles[JA] = Name;\n  }\n\n  /// CleanupFile - Delete a given file.\n  ///\n  /// \\param IssueErrors - Report failures as errors.\n  /// \\return Whether the file was removed successfully.\n  bool CleanupFile(const char *File, bool IssueErrors = false) const;\n\n  /// CleanupFileList - Remove the files in the given list.\n  ///\n  /// \\param IssueErrors - Report failures as errors.\n  /// \\return Whether all files were removed successfully.\n  bool CleanupFileList(const llvm::opt::ArgStringList &Files,\n                       bool IssueErrors = false) const;\n\n  /// CleanupFileMap - Remove the files in the given map.\n  ///\n  /// \\param JA - If specified, only delete the files associated with this\n  /// JobAction.  Otherwise, delete all files in the map.\n  /// \\param IssueErrors - Report failures as errors.\n  /// \\return Whether all files were removed successfully.\n  bool CleanupFileMap(const ArgStringMap &Files,\n                      const JobAction *JA,\n                      bool IssueErrors = false) const;\n\n  /// ExecuteCommand - Execute an actual command.\n  ///\n  /// \\param FailingCommand - For non-zero results, this will be set to the\n  /// Command which failed, if any.\n  /// \\param LogOnly - When true, only tries to log the command, not actually\n  /// execute it.\n  /// \\return The result code of the subprocess.\n  int ExecuteCommand(const Command &C, const Command *&FailingCommand,\n                     bool LogOnly = false) const;\n\n  /// ExecuteJob - Execute a single job.\n  ///\n  /// \\param FailingCommands - For non-zero results, this will be a vector of\n  /// failing commands and their associated result code.\n  /// \\param LogOnly - When true, only tries to log the command, not actually\n  /// execute it.\n  void\n  ExecuteJobs(const JobList &Jobs,\n              SmallVectorImpl<std::pair<int, const Command *>> &FailingCommands,\n              bool LogOnly = false) const;\n\n  /// initCompilationForDiagnostics - Remove stale state and suppress output\n  /// so compilation can be reexecuted to generate additional diagnostic\n  /// information (e.g., preprocessed source(s)).\n  void initCompilationForDiagnostics();\n\n  /// Return true if we're compiling for diagnostics.\n  bool isForDiagnostics() const { return ForDiagnostics; }\n\n  /// Return whether an error during the parsing of the input args.\n  bool containsError() const { return ContainsError; }\n\n  /// Force driver to fail before toolchain is created. This is necessary when\n  /// error happens in action builder.\n  void setContainsError() { ContainsError = true; }\n\n  /// Redirect - Redirect output of this compilation. Can only be done once.\n  ///\n  /// \\param Redirects - array of optional paths. The array should have a size\n  /// of three. The inferior process's stdin(0), stdout(1), and stderr(2) will\n  /// be redirected to the corresponding paths, if provided (not std::nullopt).\n  void Redirect(ArrayRef<std::optional<StringRef>> Redirects);\n};\n\n}",
  "id": "BLOCK-CPP-17722",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Compilation.h",
  "source_line": 38,
  "validation_status": "validated"
}