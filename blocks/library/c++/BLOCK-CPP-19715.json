{
  "code": "{\n\nprivate:\n  const DeclSpec &DS;\n  CXXScopeSpec SS;\n  UnqualifiedId Name;\n  SourceRange Range;\n\n  /// Where we are parsing this declarator.\n  DeclaratorContext Context;\n\n  /// The C++17 structured binding, if any. This is an alternative to a Name.\n  DecompositionDeclarator BindingGroup;\n\n  /// DeclTypeInfo - This holds each type that the declarator includes as it is\n  /// parsed.  This is pushed from the identifier out, which means that element\n  /// #0 will be the most closely bound to the identifier, and\n  /// DeclTypeInfo.back() will be the least closely bound.\n  SmallVector<DeclaratorChunk, 8> DeclTypeInfo;\n\n  /// InvalidType - Set by Sema::GetTypeForDeclarator().\n  unsigned InvalidType : 1;\n\n  /// GroupingParens - Set by Parser::ParseParenDeclarator().\n  unsigned GroupingParens : 1;\n\n  /// FunctionDefinition - Is this Declarator for a function or member\n  /// definition and, if so, what kind?\n  ///\n  /// Actually a FunctionDefinitionKind.\n  unsigned FunctionDefinition : 2;\n\n  /// Is this Declarator a redeclaration?\n  unsigned Redeclaration : 1;\n\n  /// true if the declaration is preceded by \\c __extension__.\n  unsigned Extension : 1;\n\n  /// Indicates whether this is an Objective-C instance variable.\n  unsigned ObjCIvar : 1;\n\n  /// Indicates whether this is an Objective-C 'weak' property.\n  unsigned ObjCWeakProperty : 1;\n\n  /// Indicates whether the InlineParams / InlineBindings storage has been used.\n  unsigned InlineStorageUsed : 1;\n\n  /// Indicates whether this declarator has an initializer.\n  unsigned HasInitializer : 1;\n\n  /// Attributes attached to the declarator.\n  ParsedAttributes Attrs;\n\n  /// Attributes attached to the declaration. See also documentation for the\n  /// corresponding constructor parameter.\n  const ParsedAttributesView &DeclarationAttrs;\n\n  /// The asm label, if specified.\n  Expr *AsmLabel;\n\n  /// \\brief The constraint-expression specified by the trailing\n  /// requires-clause, or null if no such clause was specified.\n  Expr *TrailingRequiresClause;\n\n  /// If this declarator declares a template, its template parameter lists.\n  ArrayRef<TemplateParameterList *> TemplateParameterLists;\n\n  /// If the declarator declares an abbreviated function template, the innermost\n  /// template parameter list containing the invented and explicit template\n  /// parameters (if any).\n  TemplateParameterList *InventedTemplateParameterList;\n\n#ifndef _MSC_VER\n  union {\n#endif\n    /// InlineParams - This is a local array used for the first function decl\n    /// chunk to avoid going to the heap for the common case when we have one\n    /// function chunk in the declarator.\n    DeclaratorChunk::ParamInfo InlineParams[16];\n    DecompositionDeclarator::Binding InlineBindings[16];\n#ifndef _MSC_VER\n  };\n#endif\n\n  /// If this is the second or subsequent declarator in this declaration,\n  /// the location of the comma before this declarator.\n  SourceLocation CommaLoc;\n\n  /// If provided, the source location of the ellipsis used to describe\n  /// this declarator as a parameter pack.\n  SourceLocation EllipsisLoc;\n\n  friend struct DeclaratorChunk;\n\npublic:\n  /// `DS` and `DeclarationAttrs` must outlive the `Declarator`. In particular,\n  /// take care not to pass temporary objects for these parameters.\n  ///\n  /// `DeclarationAttrs` contains [[]] attributes from the\n  /// attribute-specifier-seq at the beginning of a declaration, which appertain\n  /// to the declared entity itself. Attributes with other syntax (e.g. GNU)\n  /// should not be placed in this attribute list; if they occur at the\n  /// beginning of a declaration, they apply to the `DeclSpec` and should be\n  /// attached to that instead.\n  ///\n  /// Here is an example of an attribute associated with a declaration:\n  ///\n  ///  [[deprecated]] int x, y;\n  ///\n  /// This attribute appertains to all of the entities declared in the\n  /// declaration, i.e. `x` and `y` in this case.\n  Declarator(const DeclSpec &DS, const ParsedAttributesView &DeclarationAttrs,\n             DeclaratorContext C)\n      : DS(DS), Range(DS.getSourceRange()), Context(C),\n        InvalidType(DS.getTypeSpecType() == DeclSpec::TST_error),\n        GroupingParens(false), FunctionDefinition(static_cast<unsigned>(\n                                   FunctionDefinitionKind::Declaration)),\n        Redeclaration(false), Extension(false), ObjCIvar(false),\n        ObjCWeakProperty(false), InlineStorageUsed(false),\n        HasInitializer(false), Attrs(DS.getAttributePool().getFactory()),\n        DeclarationAttrs(DeclarationAttrs), AsmLabel(nullptr),\n        TrailingRequiresClause(nullptr),\n        InventedTemplateParameterList(nullptr) {\n    assert(llvm::all_of(DeclarationAttrs,\n                        [](const ParsedAttr &AL) {\n                          return (AL.isStandardAttributeSyntax() ||\n                                  AL.isRegularKeywordAttribute());\n                        }) &&\n           \"DeclarationAttrs may only contain [[]] and keyword attributes\");\n  }\n\n  ~Declarator() {\n    clear();\n  }\n  /// getDeclSpec - Return the declaration-specifier that this declarator was\n  /// declared with.\n  const DeclSpec &getDeclSpec() const { return DS; }\n\n  /// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This\n  /// should be used with extreme care: declspecs can often be shared between\n  /// multiple declarators, so mutating the DeclSpec affects all of the\n  /// Declarators.  This should only be done when the declspec is known to not\n  /// be shared or when in error recovery etc.\n  DeclSpec &getMutableDeclSpec() { return const_cast<DeclSpec &>(DS); }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// getCXXScopeSpec - Return the C++ scope specifier (global scope or\n  /// nested-name-specifier) that is part of the declarator-id.\n  const CXXScopeSpec &getCXXScopeSpec() const { return SS; }\n  CXXScopeSpec &getCXXScopeSpec() { return SS; }\n\n  /// Retrieve the name specified by this declarator.\n  UnqualifiedId &getName() { return Name; }\n\n  const DecompositionDeclarator &getDecompositionDeclarator() const {\n    return BindingGroup;\n  }\n\n  DeclaratorContext getContext() const { return Context; }\n\n  bool isPrototypeContext() const {\n    return (Context == DeclaratorContext::Prototype ||\n            Context == DeclaratorContext::ObjCParameter ||\n            Context == DeclaratorContext::ObjCResult ||\n            Context == DeclaratorContext::LambdaExprParameter);\n  }\n\n  /// Get the source range that spans this declarator.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  void SetSourceRange(SourceRange R) { Range = R; }\n  /// SetRangeBegin - Set the start of the source range to Loc, unless it's\n  /// invalid.\n  void SetRangeBegin(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setBegin(Loc);\n  }\n  /// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.\n  void SetRangeEnd(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setEnd(Loc);\n  }\n  /// ExtendWithDeclSpec - Extend the declarator source range to include the\n  /// given declspec, unless its location is invalid. Adopts the range start if\n  /// the current range start is invalid.\n  void ExtendWithDeclSpec(const DeclSpec &DS) {\n    SourceRange SR = DS.getSourceRange();\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(SR.getBegin());\n    if (!SR.getEnd().isInvalid())\n      Range.setEnd(SR.getEnd());\n  }\n\n  /// Reset the contents of this Declarator.\n  void clear() {\n    SS.clear();\n    Name.clear();\n    Range = DS.getSourceRange();\n    BindingGroup.clear();\n\n    for (unsigned i = 0, e = DeclTypeInfo.size(); i != e; ++i)\n      DeclTypeInfo[i].destroy();\n    DeclTypeInfo.clear();\n    Attrs.clear();\n    AsmLabel = nullptr;\n    InlineStorageUsed = false;\n    HasInitializer = false;\n    ObjCIvar = false;\n    ObjCWeakProperty = false;\n    CommaLoc = SourceLocation();\n    EllipsisLoc = SourceLocation();\n  }\n\n  /// mayOmitIdentifier - Return true if the identifier is either optional or\n  /// not allowed.  This is true for typenames, prototypes, and template\n  /// parameter lists.\n  bool mayOmitIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return false;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n    case DeclaratorContext::Association:\n      return true;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayHaveIdentifier - Return true if the identifier is either optional or\n  /// required.  This is true for normal declarators and prototypes, but not\n  /// typenames.\n  bool mayHaveIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::Association:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if the context permits a C++17 decomposition declarator.\n  bool mayHaveDecompositionDeclarator() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n      // FIXME: It's not clear that the proposal meant to allow file-scope\n      // structured bindings, but it does.\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return true;\n\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::RequiresExpr:\n      // Maybe one day...\n      return false;\n\n    // These contexts don't allow any kind of non-abstract declarator.\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::Association:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayBeFollowedByCXXDirectInit - Return true if the declarator can be\n  /// followed by a C++ direct initializer, e.g. \"int x(1);\".\n  bool mayBeFollowedByCXXDirectInit() const {\n    if (hasGroupingParens()) return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_extern &&\n        Context != DeclaratorContext::File)\n      return false;\n\n    // Special names can't have direct initializers.\n    if (Name.getKind() != UnqualifiedIdKind::IK_Identifier)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::TrailingReturnVar:\n      return true;\n\n    case DeclaratorContext::Condition:\n      // This may not be followed by a direct initializer, but it can't be a\n      // function declaration either, and we'd prefer to perform a tentative\n      // parse in order to produce the right diagnostic.\n      return true;\n\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast: // FIXME\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::RequiresExpr:\n    case DeclaratorContext::Association:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// isPastIdentifier - Return true if we have parsed beyond the point where\n  /// the name would appear. (This may happen even if we haven't actually parsed\n  /// a name, perhaps because this context doesn't require one.)\n  bool isPastIdentifier() const { return Name.isValid(); }\n\n  /// hasName - Whether this declarator has a name, which might be an\n  /// identifier (accessible via getIdentifier()) or some kind of\n  /// special C++ name (constructor, destructor, etc.), or a structured\n  /// binding (which is not exactly a name, but occupies the same position).\n  bool hasName() const {\n    return Name.getKind() != UnqualifiedIdKind::IK_Identifier ||\n           Name.Identifier || isDecompositionDeclarator();\n  }\n\n  /// Return whether this declarator is a decomposition declarator.\n  bool isDecompositionDeclarator() const {\n    return BindingGroup.isSet();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    if (Name.getKind() == UnqualifiedIdKind::IK_Identifier)\n      return Name.Identifier;\n\n    return nullptr;\n  }\n  SourceLocation getIdentifierLoc() const { return Name.StartLocation; }\n\n  /// Set the name of this declarator to be the given identifier.\n  void SetIdentifier(IdentifierInfo *Id, SourceLocation IdLoc) {\n    Name.setIdentifier(Id, IdLoc);\n  }\n\n  /// Set the decomposition bindings for this declarator.\n  void\n  setDecompositionBindings(SourceLocation LSquareLoc,\n                           ArrayRef<DecompositionDeclarator::Binding> Bindings,\n                           SourceLocation RSquareLoc);\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  /// This function takes attrs by R-Value reference because it takes ownership\n  /// of those attributes from the parameter.\n  void AddTypeInfo(const DeclaratorChunk &TI, ParsedAttributes &&attrs,\n                   SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n    DeclTypeInfo.back().getAttrs().addAll(attrs.begin(), attrs.end());\n    getAttributePool().takeAllFrom(attrs.getPool());\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  void AddTypeInfo(const DeclaratorChunk &TI, SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// Add a new innermost chunk to this declarator.\n  void AddInnermostTypeInfo(const DeclaratorChunk &TI) {\n    DeclTypeInfo.insert(DeclTypeInfo.begin(), TI);\n  }\n\n  /// Return the number of types applied to this declarator.\n  unsigned getNumTypeObjects() const { return DeclTypeInfo.size(); }\n\n  /// Return the specified TypeInfo from this declarator.  TypeInfo #0 is\n  /// closest to the identifier.\n  const DeclaratorChunk &getTypeObject(unsigned i) const {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n  DeclaratorChunk &getTypeObject(unsigned i) {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n\n  typedef SmallVectorImpl<DeclaratorChunk>::const_iterator type_object_iterator;\n  typedef llvm::iterator_range<type_object_iterator> type_object_range;\n\n  /// Returns the range of type objects, from the identifier outwards.\n  type_object_range type_objects() const {\n    return type_object_range(DeclTypeInfo.begin(), DeclTypeInfo.end());\n  }\n\n  void DropFirstTypeObject() {\n    assert(!DeclTypeInfo.empty() && \"No type chunks to drop.\");\n    DeclTypeInfo.front().destroy();\n    DeclTypeInfo.erase(DeclTypeInfo.begin());\n  }\n\n  /// Return the innermost (closest to the declarator) chunk of this\n  /// declarator that is not a parens chunk, or null if there are no\n  /// non-parens chunks.\n  const DeclaratorChunk *getInnermostNonParenChunk() const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      if (!DeclTypeInfo[i].isParen())\n        return &DeclTypeInfo[i];\n    }\n    return nullptr;\n  }\n\n  /// Return the outermost (furthest from the declarator) chunk of\n  /// this declarator that is not a parens chunk, or null if there are\n  /// no non-parens chunks.\n  const DeclaratorChunk *getOutermostNonParenChunk() const {\n    for (unsigned i = DeclTypeInfo.size(), i_end = 0; i != i_end; --i) {\n      if (!DeclTypeInfo[i-1].isParen())\n        return &DeclTypeInfo[i-1];\n    }\n    return nullptr;\n  }\n\n  /// isArrayOfUnknownBound - This method returns true if the declarator\n  /// is a declarator for an array of unknown bound (looking through\n  /// parentheses).\n  bool isArrayOfUnknownBound() const {\n    const DeclaratorChunk *chunk = getInnermostNonParenChunk();\n    return (chunk && chunk->Kind == DeclaratorChunk::Array &&\n            !chunk->Arr.NumElts);\n  }\n\n  /// isFunctionDeclarator - This method returns true if the declarator\n  /// is a function declarator (looking through parentheses).\n  /// If true is returned, then the reference type parameter idx is\n  /// assigned with the index of the declaration chunk.\n  bool isFunctionDeclarator(unsigned& idx) const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      switch (DeclTypeInfo[i].Kind) {\n      case DeclaratorChunk::Function:\n        idx = i;\n        return true;\n      case DeclaratorChunk::Paren:\n        continue;\n      case DeclaratorChunk::Pointer:\n      case DeclaratorChunk::Reference:\n      case DeclaratorChunk::Array:\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::MemberPointer:\n      case DeclaratorChunk::Pipe:\n        return false;\n      }\n      llvm_unreachable(\"Invalid type chunk\");\n    }\n    return false;\n  }\n\n  /// isFunctionDeclarator - Once this declarator is fully parsed and formed,\n  /// this method returns true if the identifier is a function declarator\n  /// (looking through parentheses).\n  bool isFunctionDeclarator() const {\n    unsigned index;\n    return isFunctionDeclarator(index);\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() {\n    assert(isFunctionDeclarator() && \"Not a function declarator!\");\n    unsigned index = 0;\n    isFunctionDeclarator(index);\n    return DeclTypeInfo[index].Fun;\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  const DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() const {\n    return const_cast<Declarator*>(this)->getFunctionTypeInfo();\n  }\n\n  /// Determine whether the declaration that will be produced from\n  /// this declaration will be a function.\n  ///\n  /// A declaration can declare a function even if the declarator itself\n  /// isn't a function declarator, if the type specifier refers to a function\n  /// type. This routine checks for both cases.\n  bool isDeclarationOfFunction() const;\n\n  /// Return true if this declaration appears in a context where a\n  /// function declarator would be a function declaration.\n  bool isFunctionDeclarationContext() const {\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n      return true;\n\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n    case DeclaratorContext::Association:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Determine whether this declaration appears in a context where an\n  /// expression could appear.\n  bool isExpressionContext() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n\n    // FIXME: sizeof(...) permits an expression.\n    case DeclaratorContext::TypeName:\n\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::RequiresExpr:\n    case DeclaratorContext::Association:\n      return false;\n\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::TemplateArg:\n      return true;\n    }\n\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if a function declarator at this position would be a\n  /// function declaration.\n  bool isFunctionDeclaratorAFunctionDeclaration() const {\n    if (!isFunctionDeclarationContext())\n      return false;\n\n    for (unsigned I = 0, N = getNumTypeObjects(); I != N; ++I)\n      if (getTypeObject(I).Kind != DeclaratorChunk::Paren)\n        return false;\n\n    return true;\n  }\n\n  /// Determine whether a trailing return type was written (at any\n  /// level) within this declarator.\n  bool hasTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return true;\n    return false;\n  }\n  /// Get the trailing return type appearing (at any level) within this\n  /// declarator.\n  ParsedType getTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return Chunk.Fun.getTrailingReturnType();\n    return ParsedType();\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  void setTrailingRequiresClause(Expr *TRC) {\n    TrailingRequiresClause = TRC;\n\n    SetRangeEnd(TRC->getEndLoc());\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  Expr *getTrailingRequiresClause() {\n    return TrailingRequiresClause;\n  }\n\n  /// \\brief Determine whether a trailing requires clause was written in this\n  /// declarator.\n  bool hasTrailingRequiresClause() const {\n    return TrailingRequiresClause != nullptr;\n  }\n\n  /// Sets the template parameter lists that preceded the declarator.\n  void setTemplateParameterLists(ArrayRef<TemplateParameterList *> TPLs) {\n    TemplateParameterLists = TPLs;\n  }\n\n  /// The template parameter lists that preceded the declarator.\n  ArrayRef<TemplateParameterList *> getTemplateParameterLists() const {\n    return TemplateParameterLists;\n  }\n\n  /// Sets the template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters.\n  void setInventedTemplateParameterList(TemplateParameterList *Invented) {\n    InventedTemplateParameterList = Invented;\n  }\n\n  /// The template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters, if there were any such parameters.\n  TemplateParameterList * getInventedTemplateParameterList() const {\n    return InventedTemplateParameterList;\n  }\n\n  /// takeAttributes - Takes attributes from the given parsed-attributes\n  /// set and add them to this declarator.\n  ///\n  /// These examples both add 3 attributes to \"var\":\n  ///  short int var __attribute__((aligned(16),common,deprecated));\n  ///  short int x, __attribute__((aligned(16)) var\n  ///                                 __attribute__((common,deprecated));\n  ///\n  /// Also extends the range of the declarator.\n  void takeAttributes(ParsedAttributes &attrs) {\n    Attrs.takeAllFrom(attrs);\n\n    if (attrs.Range.getEnd().isValid())\n      SetRangeEnd(attrs.Range.getEnd());\n  }\n\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n  ParsedAttributes &getAttributes() { return Attrs; }\n\n  const ParsedAttributesView &getDeclarationAttributes() const {\n    return DeclarationAttrs;\n  }\n\n  /// hasAttributes - do we contain any attributes?\n  bool hasAttributes() const {\n    if (!getAttributes().empty() || !getDeclarationAttributes().empty() ||\n        getDeclSpec().hasAttributes())\n      return true;\n    for (unsigned i = 0, e = getNumTypeObjects(); i != e; ++i)\n      if (!getTypeObject(i).getAttrs().empty())\n        return true;\n    return false;\n  }\n\n  void setAsmLabel(Expr *E) { AsmLabel = E; }\n  Expr *getAsmLabel() const { return AsmLabel; }\n\n  void setExtension(bool Val = true) { Extension = Val; }\n  bool getExtension() const { return Extension; }\n\n  void setObjCIvar(bool Val = true) { ObjCIvar = Val; }\n  bool isObjCIvar() const { return ObjCIvar; }\n\n  void setObjCWeakProperty(bool Val = true) { ObjCWeakProperty = Val; }\n  bool isObjCWeakProperty() const { return ObjCWeakProperty; }\n\n  void setInvalidType(bool Val = true) { InvalidType = Val; }\n  bool isInvalidType() const {\n    return InvalidType || DS.getTypeSpecType() == DeclSpec::TST_error;\n  }\n\n  void setGroupingParens(bool flag) { GroupingParens = flag; }\n  bool hasGroupingParens() const { return GroupingParens; }\n\n  bool isFirstDeclarator() const { return !CommaLoc.isValid(); }\n  SourceLocation getCommaLoc() const { return CommaLoc; }\n  void setCommaLoc(SourceLocation CL) { CommaLoc = CL; }\n\n  bool hasEllipsis() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  void setEllipsisLoc(SourceLocation EL) { EllipsisLoc = EL; }\n\n  void setFunctionDefinitionKind(FunctionDefinitionKind Val) {\n    FunctionDefinition = static_cast<unsigned>(Val);\n  }\n\n  bool isFunctionDefinition() const {\n    return getFunctionDefinitionKind() != FunctionDefinitionKind::Declaration;\n  }\n\n  FunctionDefinitionKind getFunctionDefinitionKind() const {\n    return (FunctionDefinitionKind)FunctionDefinition;\n  }\n\n  void setHasInitializer(bool Val = true) { HasInitializer = Val; }\n  bool hasInitializer() const { return HasInitializer; }\n\n  /// Returns true if this declares a real member and not a friend.\n  bool isFirstDeclarationOfMember() {\n    return getContext() == DeclaratorContext::Member &&\n           !getDeclSpec().isFriendSpecified();\n  }\n\n  /// Returns true if this declares a static member.  This cannot be called on a\n  /// declarator outside of a MemberContext because we won't know until\n  /// redeclaration time if the decl is static.\n  bool isStaticMember();\n\n  /// Returns true if this declares a constructor or a destructor.\n  bool isCtorOrDtor();\n\n  void setRedeclaration(bool Val) { Redeclaration = Val; }\n  bool isRedeclaration() const { return Redeclaration; }\n}",
  "id": "BLOCK-CPP-19715",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DeclSpec.h",
  "source_line": 1850,
  "validation_status": "validated"
}