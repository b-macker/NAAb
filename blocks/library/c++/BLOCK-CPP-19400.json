{
  "code": "{\n    Parser& P;\n    tok::TokenKind Kind, Close, FinalToken;\n    SourceLocation (Parser::*Consumer)();\n    SourceLocation LOpen, LClose;\n\n    unsigned short &getDepth() {\n      switch (Kind) {\n        case tok::l_brace: return P.BraceCount;\n        case tok::l_square: return P.BracketCount;\n        case tok::l_paren: return P.ParenCount;\n        default: llvm_unreachable(\"Wrong token kind\");\n      }\n    }\n\n    bool diagnoseOverflow();\n    bool diagnoseMissingClose();\n\n  public:\n    BalancedDelimiterTracker(Parser& p, tok::TokenKind k,\n                             tok::TokenKind FinalToken = tok::semi)\n      : GreaterThanIsOperatorScope(p.GreaterThanIsOperator, true),\n        P(p), Kind(k), FinalToken(FinalToken)\n    {\n      switch (Kind) {\n        default: llvm_unreachable(\"Unexpected balanced token\");\n        case tok::l_brace:\n          Close = tok::r_brace;\n          Consumer = &Parser::ConsumeBrace;\n          break;\n        case tok::l_paren:\n          Close = tok::r_paren;\n          Consumer = &Parser::ConsumeParen;\n          break;\n\n        case tok::l_square:\n          Close = tok::r_square;\n          Consumer = &Parser::ConsumeBracket;\n          break;\n      }\n    }\n\n    SourceLocation getOpenLocation() const { return LOpen; }\n    SourceLocation getCloseLocation() const { return LClose; }\n    SourceRange getRange() const { return SourceRange(LOpen, LClose); }\n\n    bool consumeOpen() {\n      if (!P.Tok.is(Kind))\n        return true;\n\n      if (getDepth() < P.getLangOpts().BracketDepth) {\n        LOpen = (P.*Consumer)();\n        return false;\n      }\n\n      return diagnoseOverflow();\n    }\n\n    bool expectAndConsume(unsigned DiagID = diag::err_expected,\n                          const char *Msg = \"\",\n                          tok::TokenKind SkipToTok = tok::unknown);\n    bool consumeClose() {\n      if (P.Tok.is(Close)) {\n        LClose = (P.*Consumer)();\n        return false;\n      } else if (P.Tok.is(tok::semi) && P.NextToken().is(Close)) {\n        SourceLocation SemiLoc = P.ConsumeToken();\n        P.Diag(SemiLoc, diag::err_unexpected_semi)\n            << Close << FixItHint::CreateRemoval(SourceRange(SemiLoc, SemiLoc));\n        LClose = (P.*Consumer)();\n        return false;\n      }\n\n      return diagnoseMissingClose();\n    }\n    void skipToEnd();\n  }",
  "id": "BLOCK-CPP-19400",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Parse/RAIIObjectsForParser.h",
  "source_line": 401,
  "validation_status": "validated"
}