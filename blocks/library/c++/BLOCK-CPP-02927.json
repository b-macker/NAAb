{
  "code": "{\n public:\n  // Creates an analyzer instance binding to `statistics`.\n  explicit CordRepAnalyzer(CordzStatistics& statistics)\n      : statistics_(statistics) {}\n\n  // Analyzes the memory statistics and node counts for the provided `rep`, and\n  // adds the results to `statistics`. Note that node counts and memory sizes\n  // are not initialized, computed values are added to any existing values.\n  void AnalyzeCordRep(const CordRep* rep) {\n    ABSL_ASSERT(rep != nullptr);\n\n    // Process all linear nodes.\n    // As per the class comments, use refcout - 1 on the top level node, as the\n    // top level node is assumed to be referenced only for analysis purposes.\n    size_t refcount = rep->refcount.Get();\n    RepRef repref{rep, (refcount > 1) ? refcount - 1 : 1};\n\n    // Process the top level CRC node, if present.\n    if (repref.tag() == CRC) {\n      statistics_.node_count++;\n      statistics_.node_counts.crc++;\n      memory_usage_.Add(sizeof(CordRepCrc), repref.refcount);\n      repref = repref.Child(repref.rep->crc()->child);\n    }\n\n    // Process all top level linear nodes (substrings and flats).\n    repref = CountLinearReps(repref, memory_usage_);\n\n    switch (repref.tag()) {\n      case CordRepKind::BTREE:\n        AnalyzeBtree(repref);\n        break;\n      default:\n        // We should have a btree node if not null.\n        ABSL_ASSERT(repref.tag() == CordRepKind::UNUSED_0);\n        break;\n    }\n\n    // Adds values to output\n    statistics_.estimated_memory_usage += memory_usage_.total;\n    statistics_.estimated_fair_share_memory_usage +=\n        static_cast<size_t>(memory_usage_.fair_share);\n  }\n\n private:\n  // RepRef identifies a CordRep* inside the Cord tree with its cumulative\n  // refcount including itself. For example, a tree consisting of a substring\n  // with a refcount of 3 and a child flat with a refcount of 4 will have RepRef\n  // refcounts of 3 and 12 respectively.\n  struct RepRef {\n    const CordRep* rep;\n    size_t refcount;\n\n    // Returns a 'child' RepRef which contains the cumulative reference count\n    // of this instance multiplied by the child's reference count. Returns a\n    // nullptr RepRef value with a refcount of 0 if `child` is nullptr.\n    RepRef Child(const CordRep* child) const {\n      if (child == nullptr) return RepRef{nullptr, 0};\n      return RepRef{child, refcount * child->refcount.Get()};\n    }\n\n    // Returns the tag of this rep, or UNUSED_0 if this instance is null\n    constexpr CordRepKind tag() const {\n      ABSL_ASSERT(rep == nullptr || rep->tag != CordRepKind::UNUSED_0);\n      return rep ? static_cast<CordRepKind>(rep->tag) : CordRepKind::UNUSED_0;\n    }\n  };\n\n  // Memory usage values\n  struct MemoryUsage {\n    size_t total = 0;\n    double fair_share = 0.0;\n\n    // Adds 'size` memory usage to this class, with a cumulative (recursive)\n    // reference count of `refcount`\n    void Add(size_t size, size_t refcount) {\n      total += size;\n      fair_share += static_cast<double>(size) / refcount;\n    }\n  };\n\n  // Counts a flat of the provide allocated size\n  void CountFlat(size_t size) {\n    statistics_.node_count++;\n    statistics_.node_counts.flat++;\n    if (size <= 64) {\n      statistics_.node_counts.flat_64++;\n    } else if (size <= 128) {\n      statistics_.node_counts.flat_128++;\n    } else if (size <= 256) {\n      statistics_.node_counts.flat_256++;\n    } else if (size <= 512) {\n      statistics_.node_counts.flat_512++;\n    } else if (size <= 1024) {\n      statistics_.node_counts.flat_1k++;\n    }\n  }\n\n  // Processes 'linear' reps (substring, flat, external) not requiring iteration\n  // or recursion. Returns RefRep{null} if all reps were processed, else returns\n  // the top-most non-linear concat or ring cordrep.\n  // Node counts are updated into `statistics_`, memory usage is update into\n  // `memory_usage`, which typically references `memory_usage_` except for ring\n  // buffers where we count children unrounded.\n  RepRef CountLinearReps(RepRef rep, MemoryUsage& memory_usage) {\n    // Consume all substrings\n    while (rep.tag() == SUBSTRING) {\n      statistics_.node_count++;\n      statistics_.node_counts.substring++;\n      memory_usage.Add(sizeof(CordRepSubstring), rep.refcount);\n      rep = rep.Child(rep.rep->substring()->child);\n    }\n\n    // Consume possible FLAT\n    if (rep.tag() >= FLAT) {\n      size_t size = rep.rep->flat()->AllocatedSize();\n      CountFlat(size);\n      memory_usage.Add(size, rep.refcount);\n      return RepRef{nullptr, 0};\n    }\n\n    // Consume possible external\n    if (rep.tag() == EXTERNAL) {\n      statistics_.node_count++;\n      statistics_.node_counts.external++;\n      size_t size = rep.rep->length + sizeof(CordRepExternalImpl<intptr_t>);\n      memory_usage.Add(size, rep.refcount);\n      return RepRef{nullptr, 0};\n    }\n\n    return rep;\n  }\n\n  // Analyzes the provided btree.\n  void AnalyzeBtree(RepRef rep) {\n    statistics_.node_count++;\n    statistics_.node_counts.btree++;\n    memory_usage_.Add(sizeof(CordRepBtree), rep.refcount);\n    const CordRepBtree* tree = rep.rep->btree();\n    if (tree->height() > 0) {\n      for (CordRep* edge : tree->Edges()) {\n        AnalyzeBtree(rep.Child(edge));\n      }\n    } else {\n      for (CordRep* edge : tree->Edges()) {\n        CountLinearReps(rep.Child(edge), memory_usage_);\n      }\n    }\n  }\n\n  CordzStatistics& statistics_;\n  MemoryUsage memory_usage_;\n}",
  "id": "BLOCK-CPP-02927",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_info.cc",
  "source_line": 69,
  "validation_status": "validated"
}