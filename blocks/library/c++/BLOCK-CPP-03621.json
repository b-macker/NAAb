{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::AnyInvocable\n//\n// `absl::AnyInvocable` is a functional wrapper type, like `std::function`, that\n// assumes ownership of an invocable object. Unlike `std::function`, an\n// `absl::AnyInvocable` is more type-safe and provides the following additional\n// benefits:\n//\n// * Properly adheres to const correctness of the underlying type\n// * Is move-only so avoids concurrency problems with copied invocables and\n//   unnecessary copies in general.\n// * Supports reference qualifiers allowing it to perform unique actions (noted\n//   below).\n//\n// `absl::AnyInvocable` is a template, and an `absl::AnyInvocable` instantiation\n// may wrap any invocable object with a compatible function signature, e.g.\n// having arguments and return types convertible to types matching the\n// `absl::AnyInvocable` signature, and also matching any stated reference\n// qualifiers, as long as that type is moveable. It therefore provides broad\n// type erasure for functional objects.\n//\n// An `absl::AnyInvocable` is typically used as a type-erased function parameter\n// for accepting various functional objects:\n//\n// // Define a function taking an AnyInvocable parameter.\n// void my_func(absl::AnyInvocable<int()> f) {\n//   ...\n// };\n//\n// // That function can accept any invocable type:\n//\n// // Accept a function reference. We don't need to move a reference.\n// int func1() { return 0; };\n// my_func(func1);\n//\n// // Accept a lambda. We use std::move here because otherwise my_func would\n// // copy the lambda.\n// auto lambda = []() { return 0; };\n// my_func(std::move(lambda));\n//\n// // Accept a function pointer. We don't need to move a function pointer.\n// func2 = &func1;\n// my_func(func2);\n//\n// // Accept an std::function by moving it. Note that the lambda is copyable\n// // (satisfying std::function requirements) and moveable (satisfying\n// // absl::AnyInvocable requirements).\n// std::function<int()> func6 = []() { return 0; };\n// my_func(std::move(func6));\n//\n// `AnyInvocable` also properly respects `const` qualifiers, reference\n// qualifiers, and the `noexcept` specification (only in C++ 17 and beyond) as\n// part of the user-specified function type (e.g.\n// `AnyInvocable<void()&& const noexcept>`). These qualifiers will be applied to\n// the `AnyInvocable` object's `operator()`, and the underlying invocable must\n// be compatible with those qualifiers.\n//\n// Comparison of const and non-const function types:\n//\n//   // Store a closure inside of `func` with the function type `int()`.\n//   // Note that we have made `func` itself `const`.\n//   const AnyInvocable<int()> func = [](){ return 0; };\n//\n//   func();  // Compile-error: the passed type `int()` isn't `const`.\n//\n//   // Store a closure inside of `const_func` with the function type\n//   // `int() const`.\n//   // Note that we have also made `const_func` itself `const`.\n//   const AnyInvocable<int() const> const_func = [](){ return 0; };\n//\n//   const_func();  // Fine: `int() const` is `const`.\n//\n// In the above example, the call `func()` would have compiled if\n// `std::function` were used even though the types are not const compatible.\n// This is a bug, and using `absl::AnyInvocable` properly detects that bug.\n//\n// In addition to affecting the signature of `operator()`, the `const` and\n// reference qualifiers of the function type also appropriately constrain which\n// kinds of invocable objects you are allowed to place into the `AnyInvocable`\n// instance. If you specify a function type that is const-qualified, then\n// anything that you attempt to put into the `AnyInvocable` must be callable on\n// a `const` instance of that type.\n//\n// Constraint example:\n//\n//   // Fine because the lambda is callable when `const`.\n//   AnyInvocable<int() const> func = [=](){ return 0; };\n//\n//   // This is a compile-error because the lambda isn't callable when `const`.\n//   AnyInvocable<int() const> error = [=]() mutable { return 0; };\n//\n// An `&&` qualifier can be used to express that an `absl::AnyInvocable`\n// instance should be invoked at most once:\n//\n//   // Invokes `continuation` with the logical result of an operation when\n//   // that operation completes (common in asynchronous code).\n//   void CallOnCompletion(AnyInvocable<void(int)&&> continuation) {\n//     int result_of_foo = foo();\n//\n//     // `std::move` is required because the `operator()` of `continuation` is\n//     // rvalue-reference qualified.\n//     std::move(continuation)(result_of_foo);\n//   }\n//\n// Attempting to call `absl::AnyInvocable` multiple times in such a case\n// results in undefined behavior.\ntemplate <class Sig>\nclass AnyInvocable : private internal_any_invocable::Impl<Sig> {\n private:\n  static_assert(\n      std::is_function<Sig>::value,\n      \"The template argument of AnyInvocable must be a function type.\");\n\n  using Impl = internal_any_invocable::Impl<Sig>;\n\n public:\n  // The return type of Sig\n  using result_type = typename Impl::result_type;\n\n  // Constructors\n\n  // Constructs the `AnyInvocable` in an empty state.\n  AnyInvocable() noexcept = default;\n  AnyInvocable(std::nullptr_t) noexcept {}  // NOLINT\n\n  // Constructs the `AnyInvocable` from an existing `AnyInvocable` by a move.\n  // Note that `f` is not guaranteed to be empty after move-construction,\n  // although it may be.\n  AnyInvocable(AnyInvocable&& /*f*/) noexcept = default;\n\n  // Constructs an `AnyInvocable` from an invocable object.\n  //\n  // Upon construction, `*this` is only empty if `f` is a function pointer or\n  // member pointer type and is null, or if `f` is an `AnyInvocable` that is\n  // empty.\n  template <class F, typename = absl::enable_if_t<\n                         internal_any_invocable::CanConvert<Sig, F>::value>>\n  AnyInvocable(F&& f)  // NOLINT\n      : Impl(internal_any_invocable::ConversionConstruct(),\n             std::forward<F>(f)) {}\n\n  // Constructs an `AnyInvocable` that holds an invocable object of type `T`,\n  // which is constructed in-place from the given arguments.\n  //\n  // Example:\n  //\n  //   AnyInvocable<int(int)> func(\n  //       absl::in_place_type<PossiblyImmovableType>, arg1, arg2);\n  //\n  template <class T, class... Args,\n            typename = absl::enable_if_t<\n                internal_any_invocable::CanEmplace<Sig, T, Args...>::value>>\n  explicit AnyInvocable(absl::in_place_type_t<T>, Args&&... args)\n      : Impl(absl::in_place_type<absl::decay_t<T>>,\n             std::forward<Args>(args)...) {\n    static_assert(std::is_same<T, absl::decay_t<T>>::value,\n                  \"The explicit template argument of in_place_type is required \"\n                  \"to be an unqualified object type.\");\n  }\n\n  // Overload of the above constructor to support list-initialization.\n  template <class T, class U, class... Args,\n            typename = absl::enable_if_t<internal_any_invocable::CanEmplace<\n                Sig, T, std::initializer_list<U>&, Args...>::value>>\n  explicit AnyInvocable(absl::in_place_type_t<T>,\n                        std::initializer_list<U> ilist, Args&&... args)\n      : Impl(absl::in_place_type<absl::decay_t<T>>, ilist,\n             std::forward<Args>(args)...) {\n    static_assert(std::is_same<T, absl::decay_t<T>>::value,\n                  \"The explicit template argument of in_place_type is required \"\n                  \"to be an unqualified object type.\");\n  }\n\n  // Assignment Operators\n\n  // Assigns an `AnyInvocable` through move-assignment.\n  // Note that `f` is not guaranteed to be empty after move-assignment\n  // although it may be.\n  AnyInvocable& operator=(AnyInvocable&& /*f*/) noexcept = default;\n\n  // Assigns an `AnyInvocable` from a nullptr, clearing the `AnyInvocable`. If\n  // not empty, destroys the target, putting `*this` into an empty state.\n  AnyInvocable& operator=(std::nullptr_t) noexcept {\n    this->Clear();\n    return *this;\n  }\n\n  // Assigns an `AnyInvocable` from an existing `AnyInvocable` instance.\n  //\n  // Upon assignment, `*this` is only empty if `f` is a function pointer or\n  // member pointer type and is null, or if `f` is an `AnyInvocable` that is\n  // empty.\n  template <class F, typename = absl::enable_if_t<\n                         internal_any_invocable::CanAssign<Sig, F>::value>>\n  AnyInvocable& operator=(F&& f) {\n    *this = AnyInvocable(std::forward<F>(f));\n    return *this;\n  }\n\n  // Assigns an `AnyInvocable` from a reference to an invocable object.\n  // Upon assignment, stores a reference to the invocable object in the\n  // `AnyInvocable` instance.\n  template <\n      class F,\n      typename = absl::enable_if_t<\n          internal_any_invocable::CanAssignReferenceWrapper<Sig, F>::value>>\n  AnyInvocable& operator=(std::reference_wrapper<F> f) noexcept {\n    *this = AnyInvocable(f);\n    return *this;\n  }\n\n  // Destructor\n\n  // If not empty, destroys the target.\n  ~AnyInvocable() = default;\n\n  // absl::AnyInvocable::swap()\n  //\n  // Exchanges the targets of `*this` and `other`.\n  void swap(AnyInvocable& other) noexcept { std::swap(*this, other); }\n\n  // absl::AnyInvocable::operator bool()\n  //\n  // Returns `true` if `*this` is not empty.\n  //\n  // WARNING: An `AnyInvocable` that wraps an empty `std::function` is not\n  // itself empty. This behavior is consistent with the standard equivalent\n  // `std::move_only_function`.\n  //\n  // In other words:\n  //   std::function<void()> f;  // empty\n  //   absl::AnyInvocable<void()> a = std::move(f);  // not empty\n  explicit operator bool() const noexcept { return this->HasValue(); }\n\n  // Invokes the target object of `*this`. `*this` must not be empty.\n  //\n  // Note: The signature of this function call operator is the same as the\n  //       template parameter `Sig`.\n  using Impl::operator();\n\n  // Equality operators\n\n  // Returns `true` if `*this` is empty.\n  friend bool operator==(const AnyInvocable& f, std::nullptr_t) noexcept {\n    return !f.HasValue();\n  }\n\n  // Returns `true` if `*this` is empty.\n  friend bool operator==(std::nullptr_t, const AnyInvocable& f) noexcept {\n    return !f.HasValue();\n  }\n\n  // Returns `false` if `*this` is empty.\n  friend bool operator!=(const AnyInvocable& f, std::nullptr_t) noexcept {\n    return f.HasValue();\n  }\n\n  // Returns `false` if `*this` is empty.\n  friend bool operator!=(std::nullptr_t, const AnyInvocable& f) noexcept {\n    return f.HasValue();\n  }\n\n  // swap()\n  //\n  // Exchanges the targets of `f1` and `f2`.\n  friend void swap(AnyInvocable& f1, AnyInvocable& f2) noexcept { f1.swap(f2); }\n\n private:\n  // Friending other instantiations is necessary for conversions.\n  template <bool /*SigIsNoexcept*/, class /*ReturnType*/, class... /*P*/>\n  friend class internal_any_invocable::CoreImpl;\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03621",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/functional/any_invocable.h",
  "source_line": 46,
  "validation_status": "validated"
}