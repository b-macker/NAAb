{
  "code": "{\n  if (detail::is_utf8() && loc != get_classic_locale()) {\n    // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and\n    // gcc-4.\n#if FMT_MSC_VERSION != 0 || \\\n    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))\n    // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5\n    // and newer.\n    using code_unit = wchar_t;\n#else\n    using code_unit = char32_t;\n#endif\n\n    using unit_t = codecvt_result<code_unit>;\n    unit_t unit;\n    write_codecvt(unit, in, loc);\n    // In UTF-8 is used one to four one-byte code units.\n    auto&& buf = basic_memory_buffer<char, unit_t::max_size * 4>();\n    for (code_unit* p = unit.buf; p != unit.end; ++p) {\n      uint32_t c = static_cast<uint32_t>(*p);\n      if (sizeof(code_unit) == 2 && c >= 0xd800 && c <= 0xdfff) {\n        // surrogate pair\n        ++p;\n        if (p == unit.end || (c & 0xfc00) != 0xd800 ||\n            (*p & 0xfc00) != 0xdc00) {\n          FMT_THROW(format_error(\"failed to format time\"));\n        }\n        c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;\n      }\n      if (c < 0x80) {\n        buf.push_back(static_cast<char>(c));\n      } else if (c < 0x800) {\n        buf.push_back(static_cast<char>(0xc0 | (c >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else if ((c >= 0x800 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xffff)) {\n        buf.push_back(static_cast<char>(0xe0 | (c >> 12)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else if (c >= 0x10000 && c <= 0x10ffff) {\n        buf.push_back(static_cast<char>(0xf0 | (c >> 18)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0x3ffff) >> 12)));\n        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));\n        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));\n      } else {\n        FMT_THROW(format_error(\"failed to format time\"));\n      }\n    }\n    return copy_str<char>(buf.data(), buf.data() + buf.size(), out);\n  }\n  return copy_str<char>(in.data(), in.data() + in.size(), out);\n}",
  "id": "BLOCK-CPP-00545",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/chrono.h",
  "source_line": 342,
  "validation_status": "validated"
}