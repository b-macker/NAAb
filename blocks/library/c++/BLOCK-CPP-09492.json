{
  "code": "{\nstruct ExprDependenceScope {\n  enum ExprDependence : uint8_t {\n    UnexpandedPack = 1,\n    // This expr depends in any way on\n    //   - a template parameter, it implies that the resolution of this expr may\n    //     cause instantiation to fail\n    //   - or an error (often in a non-template context)\n    //\n    // Note that C++ standard doesn't define the instantiation-dependent term,\n    // we follow the formal definition coming from the Itanium C++ ABI, and\n    // extend it to errors.\n    Instantiation = 2,\n    // The type of this expr depends on a template parameter, or an error.\n    Type = 4,\n    // The value of this expr depends on a template parameter, or an error.\n    Value = 8,\n\n    // clang extension: this expr contains or references an error, and is\n    // considered dependent on how that error is resolved.\n    Error = 16,\n\n    None = 0,\n    All = 31,\n\n    TypeValue = Type | Value,\n    TypeInstantiation = Type | Instantiation,\n    ValueInstantiation = Value | Instantiation,\n    TypeValueInstantiation = Type | Value | Instantiation,\n    ErrorDependent = Error | ValueInstantiation,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)\n  };\n};\nusing ExprDependence = ExprDependenceScope::ExprDependence;\n\nstruct TypeDependenceScope {\n  enum TypeDependence : uint8_t {\n    /// Whether this type contains an unexpanded parameter pack\n    /// (for C++11 variadic templates)\n    UnexpandedPack = 1,\n    /// Whether this type somehow involves\n    ///   - a template parameter, even if the resolution of the type does not\n    ///     depend on a template parameter.\n    ///   - or an error.\n    Instantiation = 2,\n    /// Whether this type\n    ///   - is a dependent type (C++ [temp.dep.type])\n    ///   - or it somehow involves an error, e.g. decltype(recovery-expr)\n    Dependent = 4,\n    /// Whether this type is a variably-modified type (C99 6.7.5).\n    VariablyModified = 8,\n\n    /// Whether this type references an error, e.g. decltype(err-expression)\n    /// yields an error type.\n    Error = 16,\n\n    None = 0,\n    All = 31,\n\n    DependentInstantiation = Dependent | Instantiation,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)\n  };\n};\nusing TypeDependence = TypeDependenceScope::TypeDependence;\n\n#define LLVM_COMMON_DEPENDENCE(NAME)                                           \\\n  struct NAME##Scope {                                                         \\\n    enum NAME : uint8_t {                                                      \\\n      UnexpandedPack = 1,                                                      \\\n      Instantiation = 2,                                                       \\\n      Dependent = 4,                                                           \\\n      Error = 8,                                                               \\\n                                                                               \\\n      None = 0,                                                                \\\n      DependentInstantiation = Dependent | Instantiation,                      \\\n      All = 15,                                                                \\\n                                                                               \\\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/Error)                        \\\n    };                                                                         \\\n  };                                                                           \\\n  using NAME = NAME##Scope::NAME;\n\nLLVM_COMMON_DEPENDENCE(NestedNameSpecifierDependence)\nLLVM_COMMON_DEPENDENCE(TemplateNameDependence)\nLLVM_COMMON_DEPENDENCE(TemplateArgumentDependence)\n#undef LLVM_COMMON_DEPENDENCE\n\n// A combined space of all dependence concepts for all node types.\n// Used when aggregating dependence of nodes of different types.\nclass Dependence {\npublic:\n  enum Bits : uint8_t {\n    None = 0,\n\n    // Contains a template parameter pack that wasn't expanded.\n    UnexpandedPack = 1,\n    // Depends on a template parameter or an error in some way.\n    // Validity depends on how the template is instantiated or the error is\n    // resolved.\n    Instantiation = 2,\n    // Expression type depends on template context, or an error.\n    // Value and Instantiation should also be set.\n    Type = 4,\n    // Expression value depends on template context, or an error.\n    // Instantiation should also be set.\n    Value = 8,\n    // Depends on template context, or an error.\n    // The type/value distinction is only meaningful for expressions.\n    Dependent = Type | Value,\n    // Includes an error, and depends on how it is resolved.\n    Error = 16,\n    // Type depends on a runtime value (variable-length array).\n    VariablyModified = 32,\n\n    // Dependence that is propagated syntactically, regardless of semantics.\n    Syntactic = UnexpandedPack | Instantiation | Error,\n    // Dependence that is propagated semantically, even in cases where the\n    // type doesn't syntactically appear. This currently excludes only\n    // UnexpandedPack. Even though Instantiation dependence is also notionally\n    // syntactic, we also want to propagate it semantically because anything\n    // that semantically depends on an instantiation-dependent entity should\n    // always be instantiated when that instantiation-dependent entity is.\n    Semantic =\n        Instantiation | Type | Value | Dependent | Error | VariablyModified,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/VariablyModified)\n  };\n\n  Dependence() : V(None) {}\n\n  Dependence(TypeDependence D)\n      : V(translate(D, TypeDependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TypeDependence::Instantiation, Instantiation) |\n          translate(D, TypeDependence::Dependent, Dependent) |\n          translate(D, TypeDependence::Error, Error) |\n          translate(D, TypeDependence::VariablyModified, VariablyModified)) {}\n\n  Dependence(ExprDependence D)\n      : V(translate(D, ExprDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, ExprDependence::Instantiation, Instantiation) |\n             translate(D, ExprDependence::Type, Type) |\n             translate(D, ExprDependence::Value, Value) |\n             translate(D, ExprDependence::Error, Error)) {}\n\n  Dependence(NestedNameSpecifierDependence D) :\n    V ( translate(D, NNSDependence::UnexpandedPack, UnexpandedPack) |\n            translate(D, NNSDependence::Instantiation, Instantiation) |\n            translate(D, NNSDependence::Dependent, Dependent) |\n            translate(D, NNSDependence::Error, Error)) {}\n\n  Dependence(TemplateArgumentDependence D)\n      : V(translate(D, TADependence::UnexpandedPack, UnexpandedPack) |\n          translate(D, TADependence::Instantiation, Instantiation) |\n          translate(D, TADependence::Dependent, Dependent) |\n          translate(D, TADependence::Error, Error)) {}\n\n  Dependence(TemplateNameDependence D)\n      : V(translate(D, TNDependence::UnexpandedPack, UnexpandedPack) |\n             translate(D, TNDependence::Instantiation, Instantiation) |\n             translate(D, TNDependence::Dependent, Dependent) |\n             translate(D, TNDependence::Error, Error)) {}\n\n  /// Extract only the syntactic portions of this type's dependence.\n  Dependence syntactic() {\n    Dependence Result = *this;\n    Result.V &= Syntactic;\n    return Result;\n  }\n\n  /// Extract the semantic portions of this type's dependence that apply even\n  /// to uses where the type does not appear syntactically.\n  Dependence semantic() {\n    Dependence Result = *this;\n    Result.V &= Semantic;\n    return Result;\n  }\n\n  TypeDependence type() const {\n    return translate(V, UnexpandedPack, TypeDependence::UnexpandedPack) |\n           translate(V, Instantiation, TypeDependence::Instantiation) |\n           translate(V, Dependent, TypeDependence::Dependent) |\n           translate(V, Error, TypeDependence::Error) |\n           translate(V, VariablyModified, TypeDependence::VariablyModified);\n  }\n\n  ExprDependence expr() const {\n    return translate(V, UnexpandedPack, ExprDependence::UnexpandedPack) |\n           translate(V, Instantiation, ExprDependence::Instantiation) |\n           translate(V, Type, ExprDependence::Type) |\n           translate(V, Value, ExprDependence::Value) |\n           translate(V, Error, ExprDependence::Error);\n  }\n\n  NestedNameSpecifierDependence nestedNameSpecifier() const {\n    return translate(V, UnexpandedPack, NNSDependence::UnexpandedPack) |\n           translate(V, Instantiation, NNSDependence::Instantiation) |\n           translate(V, Dependent, NNSDependence::Dependent) |\n           translate(V, Error, NNSDependence::Error);\n  }\n\n  TemplateArgumentDependence templateArgument() const {\n    return translate(V, UnexpandedPack, TADependence::UnexpandedPack) |\n           translate(V, Instantiation, TADependence::Instantiation) |\n           translate(V, Dependent, TADependence::Dependent) |\n           translate(V, Error, TADependence::Error);\n  }\n\n  TemplateNameDependence templateName() const {\n    return translate(V, UnexpandedPack, TNDependence::UnexpandedPack) |\n           translate(V, Instantiation, TNDependence::Instantiation) |\n           translate(V, Dependent, TNDependence::Dependent) |\n           translate(V, Error, TNDependence::Error);\n  }\n\nprivate:\n  Bits V;\n\n  template <typename T, typename U>\n  static U translate(T Bits, T FromBit, U ToBit) {\n    return (Bits & FromBit) ? ToBit : static_cast<U>(0);\n  }\n\n  // Abbreviations to make conversions more readable.\n  using NNSDependence = NestedNameSpecifierDependence;\n  using TADependence = TemplateArgumentDependence;\n  using TNDependence = TemplateNameDependence;\n};\n\n/// Computes dependencies of a reference with the name having template arguments\n/// with \\p TA dependencies.\ninline ExprDependence toExprDependence(TemplateArgumentDependence TA) {\n  return Dependence(TA).expr();\n}\ninline ExprDependence toExprDependenceForImpliedType(TypeDependence D) {\n  return Dependence(D).semantic().expr();\n}\ninline ExprDependence toExprDependenceAsWritten(TypeDependence D) {\n  return Dependence(D).expr();\n}\n// Note: it's often necessary to strip `Dependent` from qualifiers.\n// If V<T>:: refers to the current instantiation, NNS is considered dependent\n// but the containing V<T>::foo likely isn't.\ninline ExprDependence toExprDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).expr();\n}\ninline ExprDependence turnTypeToValueDependence(ExprDependence D) {\n  // Type-dependent expressions are always be value-dependent, so we simply drop\n  // type dependency.\n  return D & ~ExprDependence::Type;\n}\ninline ExprDependence turnValueToTypeDependence(ExprDependence D) {\n  // Type-dependent expressions are always be value-dependent.\n  if (D & ExprDependence::Value)\n    D |= ExprDependence::Type;\n  return D;\n}\n\n// Returned type-dependence will never have VariablyModified set.\ninline TypeDependence toTypeDependence(ExprDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(TemplateNameDependence D) {\n  return Dependence(D).type();\n}\ninline TypeDependence toTypeDependence(TemplateArgumentDependence D) {\n  return Dependence(D).type();\n}\n\ninline TypeDependence toSyntacticDependence(TypeDependence D) {\n  return Dependence(D).syntactic().type();\n}\ninline TypeDependence toSemanticDependence(TypeDependence D) {\n  return Dependence(D).semantic().type();\n}\n\ninline NestedNameSpecifierDependence\ntoNestedNameSpecifierDependendence(TypeDependence D) {\n  return Dependence(D).nestedNameSpecifier();\n}\n\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(TypeDependence D) {\n  return Dependence(D).templateArgument();\n}\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(TemplateNameDependence D) {\n  return Dependence(D).templateArgument();\n}\ninline TemplateArgumentDependence\ntoTemplateArgumentDependence(ExprDependence D) {\n  return Dependence(D).templateArgument();\n}\n\ninline TemplateNameDependence\ntoTemplateNameDependence(NestedNameSpecifierDependence D) {\n  return Dependence(D).templateName();\n}\n\nLLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE();\n\n}",
  "id": "BLOCK-CPP-09492",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DependenceFlags.h",
  "source_line": 15,
  "validation_status": "validated"
}