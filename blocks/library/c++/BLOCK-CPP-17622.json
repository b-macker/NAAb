{
  "code": "{\npublic:\n  CrossTranslationUnitContext(CompilerInstance &CI);\n  ~CrossTranslationUnitContext();\n\n  /// This function loads a function or variable definition from an\n  ///        external AST file and merges it into the original AST.\n  ///\n  /// This method should only be used on functions that have no definitions or\n  /// variables that have no initializer in\n  /// the current translation unit. A function definition with the same\n  /// declaration will be looked up in the index file which should be in the\n  /// \\p CrossTUDir directory, called \\p IndexName. In case the declaration is\n  /// found in the index the corresponding AST will be loaded and the\n  /// definition will be merged into the original AST using the AST Importer.\n  ///\n  /// \\return The declaration with the definition will be returned.\n  /// If no suitable definition is found in the index file or multiple\n  /// definitions found error will be returned.\n  ///\n  /// Note that the AST files should also be in the \\p CrossTUDir.\n  llvm::Expected<const FunctionDecl *>\n  getCrossTUDefinition(const FunctionDecl *FD, StringRef CrossTUDir,\n                       StringRef IndexName, bool DisplayCTUProgress = false);\n  llvm::Expected<const VarDecl *>\n  getCrossTUDefinition(const VarDecl *VD, StringRef CrossTUDir,\n                       StringRef IndexName, bool DisplayCTUProgress = false);\n\n  /// This function loads a definition from an external AST file.\n  ///\n  /// A definition with the same declaration will be looked up in the\n  /// index file which should be in the \\p CrossTUDir directory, called\n  /// \\p IndexName. In case the declaration is found in the index the\n  /// corresponding AST will be loaded. If the number of TUs imported\n  /// reaches \\p CTULoadTreshold, no loading is performed.\n  ///\n  /// \\return Returns a pointer to the ASTUnit that contains the definition of\n  /// the looked up name or an Error.\n  /// The returned pointer is never a nullptr.\n  ///\n  /// Note that the AST files should also be in the \\p CrossTUDir.\n  llvm::Expected<ASTUnit *> loadExternalAST(StringRef LookupName,\n                                            StringRef CrossTUDir,\n                                            StringRef IndexName,\n                                            bool DisplayCTUProgress = false);\n\n  /// This function merges a definition from a separate AST Unit into\n  ///        the current one which was created by the compiler instance that\n  ///        was passed to the constructor.\n  ///\n  /// \\return Returns the resulting definition or an error.\n  llvm::Expected<const FunctionDecl *> importDefinition(const FunctionDecl *FD,\n                                                        ASTUnit *Unit);\n  llvm::Expected<const VarDecl *> importDefinition(const VarDecl *VD,\n                                                   ASTUnit *Unit);\n\n  /// Get a name to identify a named decl.\n  static std::optional<std::string> getLookupName(const NamedDecl *ND);\n\n  /// Emit diagnostics for the user for potential configuration errors.\n  void emitCrossTUDiagnostics(const IndexError &IE);\n\n  /// Returns the MacroExpansionContext for the imported TU to which the given\n  /// source-location corresponds.\n  /// \\p ToLoc Source location in the imported-to AST.\n  /// \\note If any error happens such as \\p ToLoc is a non-imported\n  ///       source-location, empty is returned.\n  /// \\note Macro expansion tracking for imported TUs is not implemented yet.\n  ///       It returns empty unconditionally.\n  std::optional<clang::MacroExpansionContext>\n  getMacroExpansionContextForSourceLocation(\n      const clang::SourceLocation &ToLoc) const;\n\n  /// Returns true if the given Decl is newly created during the import.\n  bool isImportedAsNew(const Decl *ToDecl) const;\n\n  /// Returns true if the given Decl is mapped (or created) during an import\n  /// but there was an unrecoverable error (the AST node cannot be erased, it\n  /// is marked with an Error object in this case).\n  bool hasError(const Decl *ToDecl) const;\n\nprivate:\n  void lazyInitImporterSharedSt(TranslationUnitDecl *ToTU);\n  ASTImporter &getOrCreateASTImporter(ASTUnit *Unit);\n  template <typename T>\n  llvm::Expected<const T *> getCrossTUDefinitionImpl(const T *D,\n                                                     StringRef CrossTUDir,\n                                                     StringRef IndexName,\n                                                     bool DisplayCTUProgress);\n  template <typename T>\n  const T *findDefInDeclContext(const DeclContext *DC,\n                                StringRef LookupName);\n  template <typename T>\n  llvm::Expected<const T *> importDefinitionImpl(const T *D, ASTUnit *Unit);\n\n  using ImporterMapTy =\n      llvm::DenseMap<TranslationUnitDecl *, std::unique_ptr<ASTImporter>>;\n\n  ImporterMapTy ASTUnitImporterMap;\n\n  ASTContext &Context;\n  std::shared_ptr<ASTImporterSharedState> ImporterSharedSt;\n\n  using LoadResultTy = llvm::Expected<std::unique_ptr<ASTUnit>>;\n\n  /// Loads ASTUnits from AST-dumps or source-files.\n  class ASTLoader {\n  public:\n    ASTLoader(CompilerInstance &CI, StringRef CTUDir,\n              StringRef InvocationListFilePath);\n\n    /// Load the ASTUnit by its identifier found in the index file. If the\n    /// identifier is suffixed with '.ast' it is considered a dump. Otherwise\n    /// it is treated as source-file, and on-demand parsed. Relative paths are\n    /// prefixed with CTUDir.\n    LoadResultTy load(StringRef Identifier);\n\n    /// Lazily initialize the invocation list information, which is needed for\n    /// on-demand parsing.\n    llvm::Error lazyInitInvocationList();\n\n  private:\n    /// The style used for storage and lookup of filesystem paths.\n    /// Defaults to posix.\n    const llvm::sys::path::Style PathStyle = llvm::sys::path::Style::posix;\n\n    /// Loads an AST from a pch-dump.\n    LoadResultTy loadFromDump(StringRef Identifier);\n    /// Loads an AST from a source-file.\n    LoadResultTy loadFromSource(StringRef Identifier);\n\n    CompilerInstance &CI;\n    StringRef CTUDir;\n    /// The path to the file containing the invocation list, which is in YAML\n    /// format, and contains a mapping from source files to compiler invocations\n    /// that produce the AST used for analysis.\n    StringRef InvocationListFilePath;\n    /// In case of on-demand parsing, the invocations for parsing the source\n    /// files is stored.\n    std::optional<InvocationListTy> InvocationList;\n    index_error_code PreviousParsingResult = index_error_code::success;\n  };\n\n  /// Maintain number of AST loads and check for reaching the load limit.\n  class ASTLoadGuard {\n  public:\n    ASTLoadGuard(unsigned Limit) : Limit(Limit) {}\n\n    /// Indicates, whether a new load operation is permitted, it is within the\n    /// threshold.\n    operator bool() const { return Count < Limit; }\n\n    /// Tell that a new AST was loaded successfully.\n    void indicateLoadSuccess() { ++Count; }\n\n  private:\n    /// The number of ASTs actually imported.\n    unsigned Count{0u};\n    /// The limit (threshold) value for number of loaded ASTs.\n    const unsigned Limit;\n  };\n\n  /// Storage and load of ASTUnits, cached access, and providing searchability\n  /// are the concerns of ASTUnitStorage class.\n  class ASTUnitStorage {\n  public:\n    ASTUnitStorage(CompilerInstance &CI);\n    /// Loads an ASTUnit for a function.\n    ///\n    /// \\param FunctionName USR name of the function.\n    /// \\param CrossTUDir Path to the directory used to store CTU related files.\n    /// \\param IndexName Name of the file inside \\p CrossTUDir which maps\n    /// function USR names to file paths. These files contain the corresponding\n    /// AST-dumps.\n    /// \\param DisplayCTUProgress Display a message about loading new ASTs.\n    ///\n    /// \\return An Expected instance which contains the ASTUnit pointer or the\n    /// error occurred during the load.\n    llvm::Expected<ASTUnit *> getASTUnitForFunction(StringRef FunctionName,\n                                                    StringRef CrossTUDir,\n                                                    StringRef IndexName,\n                                                    bool DisplayCTUProgress);\n    /// Identifies the path of the file which can be used to load the ASTUnit\n    /// for a given function.\n    ///\n    /// \\param FunctionName USR name of the function.\n    /// \\param CrossTUDir Path to the directory used to store CTU related files.\n    /// \\param IndexName Name of the file inside \\p CrossTUDir which maps\n    /// function USR names to file paths. These files contain the corresponding\n    /// AST-dumps.\n    ///\n    /// \\return An Expected instance containing the filepath.\n    llvm::Expected<std::string> getFileForFunction(StringRef FunctionName,\n                                                   StringRef CrossTUDir,\n                                                   StringRef IndexName);\n\n  private:\n    llvm::Error ensureCTUIndexLoaded(StringRef CrossTUDir, StringRef IndexName);\n    llvm::Expected<ASTUnit *> getASTUnitForFile(StringRef FileName,\n                                                bool DisplayCTUProgress);\n\n    template <typename... T> using BaseMapTy = llvm::StringMap<T...>;\n    using OwningMapTy = BaseMapTy<std::unique_ptr<clang::ASTUnit>>;\n    using NonOwningMapTy = BaseMapTy<clang::ASTUnit *>;\n\n    OwningMapTy FileASTUnitMap;\n    NonOwningMapTy NameASTUnitMap;\n\n    using IndexMapTy = BaseMapTy<std::string>;\n    IndexMapTy NameFileMap;\n\n    /// Loads the AST based on the identifier found in the index.\n    ASTLoader Loader;\n\n    /// Limit the number of loaded ASTs. It is used to limit the  memory usage\n    /// of the CrossTranslationUnitContext. The ASTUnitStorage has the\n    /// information whether the AST to load is actually loaded or returned from\n    /// cache. This information is needed to maintain the counter.\n    ASTLoadGuard LoadGuard;\n  };\n\n  ASTUnitStorage ASTStorage;\n}",
  "id": "BLOCK-CPP-17622",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CrossTU/CrossTranslationUnit.h",
  "source_line": 127,
  "validation_status": "validated"
}