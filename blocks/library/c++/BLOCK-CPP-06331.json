{
  "code": "#include <algorithm>\n#include \"absl/base/attributes.h\"\n#include \"absl/strings/internal/str_format/arg.h\"\n#include \"absl/strings/internal/str_format/constexpr_parser.h\"\n#include \"absl/strings/internal/str_format/extension.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06331_execute() {\n    {\n  int next_arg = 0;\n  const char* p = format.data();\n  const char* const end = p + format.size();\n  constexpr FormatConversionCharSet\n      kAllowedConvs[(std::max)(sizeof...(C), size_t{1})] = {C...};\n  bool used[(std::max)(sizeof...(C), size_t{1})]{};\n  constexpr int kNumArgs = sizeof...(C);\n  while (p != end) {\n    while (p != end && *p != '%') ++p;\n    if (p == end) {\n      break;\n    }\n    if (p + 1 >= end) return false;\n    if (p[1] == '%') {\n      // %%\n      p += 2;\n      continue;\n    }\n\n    UnboundConversion conv(absl::kConstInit);\n    p = ConsumeUnboundConversion(p + 1, end, &conv, &next_arg);\n    if (p == nullptr) return false;\n    if (conv.arg_position <= 0 || conv.arg_position > kNumArgs) {\n      return false;\n    }\n    if (!Contains(kAllowedConvs[conv.arg_position - 1], conv.conv)) {\n      return false;\n    }\n    used[conv.arg_position - 1] = true;\n    for (auto extra : {conv.width, conv.precision}) {\n      if (extra.is_from_arg()) {\n        int pos = extra.get_from_arg();\n        if (pos <= 0 || pos > kNumArgs) return false;\n        used[pos - 1] = true;\n        if (!Contains(kAllowedConvs[pos - 1], '*')) {\n          return false;\n        }\n      }\n    }\n  }\n  if (sizeof...(C) != 0) {\n    for (bool b : used) {\n      if (!b) return false;\n    }\n  }\n  return true;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06331",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/checker.h",
  "source_line": 44,
  "validation_status": "validated"
}