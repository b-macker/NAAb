{
  "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <istream>\n#include <limits>\n#include <ostream>\n#include <type_traits>\n#include \"absl/numeric/bits.h\"\n#include \"absl/random/internal/fastmath.h\"\n#include \"absl/random/internal/generate_real.h\"\n#include \"absl/random/internal/iostream_state_saver.h\"\n#include \"absl/random/internal/traits.h\"\n#include \"absl/random/uniform_int_distribution.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03873_execute() {\n    {\n   public:\n    using distribution_type = log_uniform_int_distribution;\n\n    explicit param_type(\n        result_type min = 0,\n        result_type max = (std::numeric_limits<result_type>::max)(),\n        result_type base = 2)\n        : min_(min),\n          max_(max),\n          base_(base),\n          range_(static_cast<unsigned_type>(max_) -\n                 static_cast<unsigned_type>(min_)),\n          log_range_(0) {\n      assert(max_ >= min_);\n      assert(base_ > 1);\n\n      if (base_ == 2) {\n        // Determine where the first set bit is on range(), giving a log2(range)\n        // value which can be used to construct bounds.\n        log_range_ = (std::min)(random_internal::BitWidth(range()),\n                                std::numeric_limits<unsigned_type>::digits);\n      } else {\n        // NOTE: Computing the logN(x) introduces error from 2 sources:\n        // 1. Conversion of int to double loses precision for values >=\n        // 2^53, which may cause some log() computations to operate on\n        // different values.\n        // 2. The error introduced by the division will cause the result\n        // to differ from the expected value.\n        //\n        // Thus a result which should equal K may equal K +/- epsilon,\n        // which can eliminate some values depending on where the bounds fall.\n        const double inv_log_base = 1.0 / std::log(static_cast<double>(base_));\n        const double log_range = std::log(static_cast<double>(range()) + 0.5);\n        log_range_ = static_cast<int>(std::ceil(inv_log_base * log_range));\n      }\n    }\n\n    result_type(min)() const { return min_; }\n    result_type(max)() const { return max_; }\n    result_type base() const { return base_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.min_ == b.min_ && a.max_ == b.max_ && a.base_ == b.base_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class log_uniform_int_distribution;\n\n    int log_range() const { return log_range_; }\n    unsigned_type range() const { return range_; }\n\n    result_type min_;\n    result_type max_;\n    result_type base_;\n    unsigned_type range_;  // max - min\n    int log_range_;        // ceil(logN(range_))\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::log_uniform_int_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03873",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/log_uniform_int_distribution.h",
  "source_line": 52,
  "validation_status": "validated"
}