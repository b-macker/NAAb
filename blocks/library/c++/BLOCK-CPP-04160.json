{
  "code": "{\n//   // To add formatting support to `Point`, we simply need to add a free\n//   // (non-member) function `AbslStringify()`. This method prints in the\n//   // request format using the underlying `%v` specifier. You can add such a\n//   // free function using a friend declaration within the body of the class.\n//   // The sink parameter is a templated type to avoid requiring dependencies.\n//   template <typename Sink>\n//   friend void AbslStringify(Sink& sink, const Point& p) {\n//     absl::Format(&sink, \"(%v, %v)\", p.x, p.y);\n//   }\n//\n//   int x;\n//   int y;\n// };\n//\n// AbslFormatConvert()\n//\n// The StrFormat library provides a customization API for formatting\n// user-defined types using absl::StrFormat(). The API relies on detecting an\n// overload in the user-defined type's namespace of a free (non-member)\n// `AbslFormatConvert()` function, usually as a friend definition with the\n// following signature:\n//\n// absl::FormatConvertResult<...> AbslFormatConvert(\n//     const X& value,\n//     const absl::FormatConversionSpec& spec,\n//     absl::FormatSink *sink);\n//\n// An `AbslFormatConvert()` overload for a type should only be declared in the\n// same file and namespace as said type.\n//\n// The abstractions within this definition include:\n//\n// * An `absl::FormatConversionSpec` to specify the fields to pull from a\n//   user-defined type's format string\n// * An `absl::FormatSink` to hold the converted string data during the\n//   conversion process.\n// * An `absl::FormatConvertResult` to hold the status of the returned\n//   formatting operation\n//\n// The return type encodes all the conversion characters that your\n// AbslFormatConvert() routine accepts.  The return value should be {true}.\n// A return value of {false} will result in `StrFormat()` returning\n// an empty string.  This result will be propagated to the result of\n// `FormatUntyped`.\n//\n// Example:\n//\n// struct Point {\n//   // To add formatting support to `Point`, we simply need to add a free\n//   // (non-member) function `AbslFormatConvert()`.  This method interprets\n//   // `spec` to print in the request format. The allowed conversion characters\n//   // can be restricted via the type of the result, in this example\n//   // string and integral formatting are allowed (but not, for instance\n//   // floating point characters like \"%f\").  You can add such a free function\n//   // using a friend declaration within the body of the class:\n//   friend absl::FormatConvertResult<absl::FormatConversionCharSet::kString |\n//                                    absl::FormatConversionCharSet::kIntegral>\n//   AbslFormatConvert(const Point& p, const absl::FormatConversionSpec& spec,\n//                     absl::FormatSink* s) {\n//     if (spec.conversion_char() == absl::FormatConversionChar::s) {\n//       absl::Format(s, \"x=%vy=%v\", p.x, p.y);\n//     } else {\n//       absl::Format(s, \"%v,%v\", p.x, p.y);\n//     }\n//     return {true};\n//   }\n//\n//   int x;\n//   int y;\n// };\n\n// clang-format off\n\n// FormatConversionChar\n//\n// Specifies the formatting character provided in the format string\n// passed to `StrFormat()`.\nenum class FormatConversionChar : uint8_t {\n  c, s,                    // text\n  d, i, o, u, x, X,        // int\n  f, F, e, E, g, G, a, A,  // float\n  n, p, v                  // misc\n};\n// clang-format on\n\n// FormatConversionSpec\n//\n// Specifies modifications to the conversion of the format string, through use\n// of one or more format flags in the source format string.\nclass FormatConversionSpec {\n public:\n  // FormatConversionSpec::is_basic()\n  //\n  // Indicates that width and precision are not specified, and no additional\n  // flags are set for this conversion character in the format string.\n  bool is_basic() const { return impl_.is_basic(); }\n\n  // FormatConversionSpec::has_left_flag()\n  //\n  // Indicates whether the result should be left justified for this conversion\n  // character in the format string. This flag is set through use of a '-'\n  // character in the format string. E.g. \"%-s\"\n  bool has_left_flag() const { return impl_.has_left_flag(); }\n\n  // FormatConversionSpec::has_show_pos_flag()\n  //\n  // Indicates whether a sign column is prepended to the result for this\n  // conversion character in the format string, even if the result is positive.\n  // This flag is set through use of a '+' character in the format string.\n  // E.g. \"%+d\"\n  bool has_show_pos_flag() const { return impl_.has_show_pos_flag(); }\n\n  // FormatConversionSpec::has_sign_col_flag()\n  //\n  // Indicates whether a mandatory sign column is added to the result for this\n  // conversion character. This flag is set through use of a space character\n  // (' ') in the format string. E.g. \"% i\"\n  bool has_sign_col_flag() const { return impl_.has_sign_col_flag(); }\n\n  // FormatConversionSpec::has_alt_flag()\n  //\n  // Indicates whether an \"alternate\" format is applied to the result for this\n  // conversion character. Alternative forms depend on the type of conversion\n  // character, and unallowed alternatives are undefined. This flag is set\n  // through use of a '#' character in the format string. E.g. \"%#h\"\n  bool has_alt_flag() const { return impl_.has_alt_flag(); }\n\n  // FormatConversionSpec::has_zero_flag()\n  //\n  // Indicates whether zeroes should be prepended to the result for this\n  // conversion character instead of spaces. This flag is set through use of the\n  // '0' character in the format string. E.g. \"%0f\"\n  bool has_zero_flag() const { return impl_.has_zero_flag(); }\n\n  // FormatConversionSpec::conversion_char()\n  //\n  // Returns the underlying conversion character.\n  FormatConversionChar conversion_char() const {\n    return impl_.conversion_char();\n  }\n\n  // FormatConversionSpec::width()\n  //\n  // Returns the specified width (indicated through use of a non-zero integer\n  // value or '*' character) of the conversion character. If width is\n  // unspecified, it returns a negative value.\n  int width() const { return impl_.width(); }\n\n  // FormatConversionSpec::precision()\n  //\n  // Returns the specified precision (through use of the '.' character followed\n  // by a non-zero integer value or '*' character) of the conversion character.\n  // If precision is unspecified, it returns a negative value.\n  int precision() const { return impl_.precision(); }\n\n private:\n  explicit FormatConversionSpec(\n      str_format_internal::FormatConversionSpecImpl impl)\n      : impl_(impl) {}\n\n  friend str_format_internal::FormatConversionSpecImpl;\n\n  absl::str_format_internal::FormatConversionSpecImpl impl_;\n};\n\n// Type safe OR operator for FormatConversionCharSet to allow accepting multiple\n// conversion chars in custom format converters.\nconstexpr FormatConversionCharSet operator|(FormatConversionCharSet a,\n                                            FormatConversionCharSet b) {\n  return static_cast<FormatConversionCharSet>(static_cast<uint64_t>(a) |\n                                              static_cast<uint64_t>(b));\n}\n\n// FormatConversionCharSet\n//\n// Specifies the _accepted_ conversion types as a template parameter to\n// FormatConvertResult for custom implementations of `AbslFormatConvert`.\n// Note the helper predefined alias definitions (kIntegral, etc.) below.\nenum class FormatConversionCharSet : uint64_t {\n  // text\n  c = str_format_internal::FormatConversionCharToConvInt('c'),\n  s = str_format_internal::FormatConversionCharToConvInt('s'),\n  // integer\n  d = str_format_internal::FormatConversionCharToConvInt('d'),\n  i = str_format_internal::FormatConversionCharToConvInt('i'),\n  o = str_format_internal::FormatConversionCharToConvInt('o'),\n  u = str_format_internal::FormatConversionCharToConvInt('u'),\n  x = str_format_internal::FormatConversionCharToConvInt('x'),\n  X = str_format_internal::FormatConversionCharToConvInt('X'),\n  // Float\n  f = str_format_internal::FormatConversionCharToConvInt('f'),\n  F = str_format_internal::FormatConversionCharToConvInt('F'),\n  e = str_format_internal::FormatConversionCharToConvInt('e'),\n  E = str_format_internal::FormatConversionCharToConvInt('E'),\n  g = str_format_internal::FormatConversionCharToConvInt('g'),\n  G = str_format_internal::FormatConversionCharToConvInt('G'),\n  a = str_format_internal::FormatConversionCharToConvInt('a'),\n  A = str_format_internal::FormatConversionCharToConvInt('A'),\n  // misc\n  n = str_format_internal::FormatConversionCharToConvInt('n'),\n  p = str_format_internal::FormatConversionCharToConvInt('p'),\n  v = str_format_internal::FormatConversionCharToConvInt('v'),\n\n  // Used for width/precision '*' specification.\n  kStar = static_cast<uint64_t>(\n      absl::str_format_internal::FormatConversionCharSetInternal::kStar),\n  // Some predefined values:\n  kIntegral = d | i | u | o | x | X,\n  kFloating = a | e | f | g | A | E | F | G,\n  kNumeric = kIntegral | kFloating,\n  kString = s,\n  kPointer = p,\n};\n\n// FormatSink\n//\n// A format sink is a generic abstraction to which conversions may write their\n// formatted string data. `absl::FormatConvert()` uses this sink to write its\n// formatted string.\n//\nclass FormatSink {\n public:\n  // FormatSink::Append()\n  //\n  // Appends `count` copies of `ch` to the format sink.\n  void Append(size_t count, char ch) { sink_->Append(count, ch); }\n\n  // Overload of FormatSink::Append() for appending the characters of a string\n  // view to a format sink.\n  void Append(string_view v) { sink_->Append(v); }\n\n  // FormatSink::PutPaddedString()\n  //\n  // Appends `precision` number of bytes of `v` to the format sink. If this is\n  // less than `width`, spaces will be appended first (if `left` is false), or\n  // after (if `left` is true) to ensure the total amount appended is\n  // at least `width`.\n  bool PutPaddedString(string_view v, int width, int precision, bool left) {\n    return sink_->PutPaddedString(v, width, precision, left);\n  }\n\n  // Support `absl::Format(&sink, format, args...)`.\n  friend void AbslFormatFlush(absl::Nonnull<FormatSink*> sink,\n                              absl::string_view v) {\n    sink->Append(v);\n  }\n\n private:\n  friend str_format_internal::FormatSinkImpl;\n  explicit FormatSink(absl::Nonnull<str_format_internal::FormatSinkImpl*> s)\n      : sink_(s) {}\n  absl::Nonnull<str_format_internal::FormatSinkImpl*> sink_;\n};\n\n// FormatConvertResult\n//\n// Indicates whether a call to AbslFormatConvert() was successful.\n// This return type informs the StrFormat extension framework (through\n// ADL but using the return type) of what conversion characters are supported.\n// It is strongly discouraged to return {false}, as this will result in an\n// empty string in StrFormat.\ntemplate <FormatConversionCharSet C>\nstruct FormatConvertResult {\n  bool value;\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04160",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_format.h",
  "source_line": 617,
  "validation_status": "validated"
}