{
  "code": "{\n\nclass ASTReader;\nclass CompilerInstance;\nclass CompilerInvocation;\nclass DiagnosticsEngine;\nclass ExternalSemaSource;\nclass FrontendOptions;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nclass PreprocessorOutputOptions;\n\n/// InitializePreprocessor - Initialize the preprocessor getting it and the\n/// environment ready to process a single file.\nvoid InitializePreprocessor(Preprocessor &PP, const PreprocessorOptions &PPOpts,\n                            const PCHContainerReader &PCHContainerRdr,\n                            const FrontendOptions &FEOpts);\n\n/// DoPrintPreprocessedInput - Implement -E mode.\nvoid DoPrintPreprocessedInput(Preprocessor &PP, raw_ostream *OS,\n                              const PreprocessorOutputOptions &Opts);\n\n/// An interface for collecting the dependencies of a compilation. Users should\n/// use \\c attachToPreprocessor and \\c attachToASTReader to get all of the\n/// dependencies.\n/// FIXME: Migrate DependencyGraphGen to use this interface.\nclass DependencyCollector {\npublic:\n  virtual ~DependencyCollector();\n\n  virtual void attachToPreprocessor(Preprocessor &PP);\n  virtual void attachToASTReader(ASTReader &R);\n  ArrayRef<std::string> getDependencies() const { return Dependencies; }\n\n  /// Called when a new file is seen. Return true if \\p Filename should be added\n  /// to the list of dependencies.\n  ///\n  /// The default implementation ignores <built-in> and system files.\n  virtual bool sawDependency(StringRef Filename, bool FromModule,\n                             bool IsSystem, bool IsModuleFile, bool IsMissing);\n\n  /// Called when the end of the main file is reached.\n  virtual void finishedMainFile(DiagnosticsEngine &Diags) {}\n\n  /// Return true if system files should be passed to sawDependency().\n  virtual bool needSystemDependencies() { return false; }\n\n  /// Add a dependency \\p Filename if it has not been seen before and\n  /// sawDependency() returns true.\n  virtual void maybeAddDependency(StringRef Filename, bool FromModule,\n                                  bool IsSystem, bool IsModuleFile,\n                                  bool IsMissing);\n\nprotected:\n  /// Return true if the filename was added to the list of dependencies, false\n  /// otherwise.\n  bool addDependency(StringRef Filename);\n\nprivate:\n  llvm::StringSet<> Seen;\n  std::vector<std::string> Dependencies;\n};\n\n/// Builds a dependency file when attached to a Preprocessor (for includes) and\n/// ASTReader (for module imports), and writes it out at the end of processing\n/// a source file.  Users should attach to the ast reader whenever a module is\n/// loaded.\nclass DependencyFileGenerator : public DependencyCollector {\npublic:\n  DependencyFileGenerator(const DependencyOutputOptions &Opts);\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n\n  void finishedMainFile(DiagnosticsEngine &Diags) override;\n\n  bool needSystemDependencies() final { return IncludeSystemHeaders; }\n\n  bool sawDependency(StringRef Filename, bool FromModule, bool IsSystem,\n                     bool IsModuleFile, bool IsMissing) final;\n\nprotected:\n  void outputDependencyFile(llvm::raw_ostream &OS);\n\nprivate:\n  void outputDependencyFile(DiagnosticsEngine &Diags);\n\n  std::string OutputFile;\n  std::vector<std::string> Targets;\n  bool IncludeSystemHeaders;\n  bool PhonyTarget;\n  bool AddMissingHeaderDeps;\n  bool SeenMissingHeader;\n  bool IncludeModuleFiles;\n  DependencyOutputFormat OutputFormat;\n  unsigned InputFileIndex;\n};\n\n/// Collects the dependencies for imported modules into a directory.  Users\n/// should attach to the AST reader whenever a module is loaded.\nclass ModuleDependencyCollector : public DependencyCollector {\n  std::string DestDir;\n  bool HasErrors = false;\n  llvm::StringSet<> Seen;\n  llvm::vfs::YAMLVFSWriter VFSWriter;\n  llvm::FileCollector::PathCanonicalizer Canonicalizer;\n\n  std::error_code copyToRoot(StringRef Src, StringRef Dst = {});\n\npublic:\n  ModuleDependencyCollector(std::string DestDir)\n      : DestDir(std::move(DestDir)) {}\n  ~ModuleDependencyCollector() override { writeFileMap(); }\n\n  StringRef getDest() { return DestDir; }\n  virtual bool insertSeen(StringRef Filename) { return Seen.insert(Filename).second; }\n  virtual void addFile(StringRef Filename, StringRef FileDst = {});\n\n  virtual void addFileMapping(StringRef VPath, StringRef RPath) {\n    VFSWriter.addFileMapping(VPath, RPath);\n  }\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n  void attachToASTReader(ASTReader &R) override;\n\n  virtual void writeFileMap();\n  virtual bool hasErrors() { return HasErrors; }\n};\n\n/// AttachDependencyGraphGen - Create a dependency graph generator, and attach\n/// it to the given preprocessor.\nvoid AttachDependencyGraphGen(Preprocessor &PP, StringRef OutputFile,\n                              StringRef SysRoot);\n\n/// AttachHeaderIncludeGen - Create a header include list generator, and attach\n/// it to the given preprocessor.\n///\n/// \\param DepOpts - Options controlling the output.\n/// \\param ShowAllHeaders - If true, show all header information instead of just\n/// headers following the predefines buffer. This is useful for making sure\n/// includes mentioned on the command line are also reported, but differs from\n/// the default behavior used by -H.\n/// \\param OutputPath - If non-empty, a path to write the header include\n/// information to, instead of writing to stderr.\n/// \\param ShowDepth - Whether to indent to show the nesting of the includes.\n/// \\param MSStyle - Whether to print in cl.exe /showIncludes style.\nvoid AttachHeaderIncludeGen(Preprocessor &PP,\n                            const DependencyOutputOptions &DepOpts,\n                            bool ShowAllHeaders = false,\n                            StringRef OutputPath = {},\n                            bool ShowDepth = true, bool MSStyle = false);\n\n/// The ChainedIncludesSource class converts headers to chained PCHs in\n/// memory, mainly for testing.\nIntrusiveRefCntPtr<ExternalSemaSource>\ncreateChainedIncludesSource(CompilerInstance &CI,\n                            IntrusiveRefCntPtr<ExternalSemaSource> &Reader);\n\n/// Optional inputs to createInvocation.\nstruct CreateInvocationOptions {\n  /// Receives diagnostics encountered while parsing command-line flags.\n  /// If not provided, these are printed to stderr.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags = nullptr;\n  /// Used e.g. to probe for system headers locations.\n  /// If not provided, the real filesystem is used.\n  /// FIXME: the driver does perform some non-virtualized IO.\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr;\n  /// Whether to attempt to produce a non-null (possibly incorrect) invocation\n  /// if any errors were encountered.\n  /// By default, always return null on errors.\n  bool RecoverOnError = false;\n  /// Allow the driver to probe the filesystem for PCH files.\n  /// This is used to replace -include with -include-pch in the cc1 args.\n  /// FIXME: ProbePrecompiled=true is a poor, historical default.\n  /// It misbehaves if the PCH file is from GCC, has the wrong version, etc.\n  bool ProbePrecompiled = false;\n  /// If set, the target is populated with the cc1 args produced by the driver.\n  /// This may be populated even if createInvocation returns nullptr.\n  std::vector<std::string> *CC1Args = nullptr;\n};\n\n/// Interpret clang arguments in preparation to parse a file.\n///\n/// This simulates a number of steps Clang takes when its driver is invoked:\n/// - choosing actions (e.g compile + link) to run\n/// - probing the system for settings like standard library locations\n/// - spawning a cc1 subprocess to compile code, with more explicit arguments\n/// - in the cc1 process, assembling those arguments into a CompilerInvocation\n///   which is used to configure the parser\n///\n/// This simulation is lossy, e.g. in some situations one driver run would\n/// result in multiple parses. (Multi-arch, CUDA, ...).\n/// This function tries to select a reasonable invocation that tools should use.\n///\n/// Args[0] should be the driver name, such as \"clang\" or \"/usr/bin/g++\".\n/// Absolute path is preferred - this affects searching for system headers.\n///\n/// May return nullptr if an invocation could not be determined.\n/// See CreateInvocationOptions::ShouldRecoverOnErrors to try harder!\nstd::unique_ptr<CompilerInvocation>\ncreateInvocation(ArrayRef<const char *> Args,\n                 CreateInvocationOptions Opts = {});\n\n}",
  "id": "BLOCK-CPP-18446",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/Utils.h",
  "source_line": 34,
  "validation_status": "validated"
}