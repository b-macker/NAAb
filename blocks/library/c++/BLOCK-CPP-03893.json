{
  "code": "#include <random>\n#include \"absl/random/distributions.h\"  // IWYU pragma: export\n#include \"absl/random/internal/nonsecure_base.h\"  // IWYU pragma: export\n#include \"absl/random/internal/pcg_engine.h\"  // IWYU pragma: export\n#include \"absl/random/internal/pool_urbg.h\"\n#include \"absl/random/internal/randen_engine.h\"\n#include \"absl/random/seed_sequences.h\"  // IWYU pragma: export\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03893_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// absl::BitGen\n// -----------------------------------------------------------------------------\n//\n// `absl::BitGen` is a general-purpose random bit generator for generating\n// random values for use within the Abseil random library. Typically, you use a\n// bit generator in combination with a distribution to provide random values.\n//\n// Example:\n//\n//   // Create an absl::BitGen. There is no need to seed this bit generator.\n//   absl::BitGen gen;\n//\n//   // Generate an integer value in the closed interval [1,6]\n//   int die_roll = absl::uniform_int_distribution<int>(1, 6)(gen);\n//\n// `absl::BitGen` is seeded by default with non-deterministic data to produce\n// different sequences of random values across different instances, including\n// different binary invocations. This behavior is different than the standard\n// library bit generators, which use golden values as their seeds. Default\n// construction intentionally provides no stability guarantees, to avoid\n// accidental dependence on such a property.\n//\n// `absl::BitGen` may be constructed with an optional seed sequence type,\n// conforming to [rand.req.seed_seq], which will be mixed with additional\n// non-deterministic data as detailed below.\n//\n// Example:\n//\n//  // Create an absl::BitGen using an std::seed_seq seed sequence\n//  std::seed_seq seq{1,2,3};\n//  absl::BitGen gen_with_seed(seq);\n//\n//  // Generate an integer value in the closed interval [1,6]\n//  int die_roll2 = absl::uniform_int_distribution<int>(1, 6)(gen_with_seed);\n//\n// Constructing two `absl::BitGen`s with the same seed sequence in the same\n// process will produce the same sequence of variates, but need not do so across\n// multiple processes even if they're executing the same binary.\n//\n// `absl::BitGen` meets the requirements of the Uniform Random Bit Generator\n// (URBG) concept as per the C++17 standard [rand.req.urng] though differs\n// slightly with [rand.req.eng]. Like its standard library equivalents (e.g.\n// `std::mersenne_twister_engine`) `absl::BitGen` is not cryptographically\n// secure.\n//\n// This type has been optimized to perform better than Mersenne Twister\n// (https://en.wikipedia.org/wiki/Mersenne_Twister) and many other complex URBG\n// types on modern x86, ARM, and PPC architectures.\n//\n// This type is thread-compatible, but not thread-safe.\n\n// ---------------------------------------------------------------------------\n// absl::BitGen member functions\n// ---------------------------------------------------------------------------\n\n// absl::BitGen::operator()()\n//\n// Calls the BitGen, returning a generated value.\n\n// absl::BitGen::min()\n//\n// Returns the smallest possible value from this bit generator.\n\n// absl::BitGen::max()\n//\n// Returns the largest possible value from this bit generator.\n\n// absl::BitGen::discard(num)\n//\n// Advances the internal state of this bit generator by `num` times, and\n// discards the intermediate results.\n// ---------------------------------------------------------------------------\n\nusing BitGen = random_internal::NonsecureURBGBase<\n    random_internal::randen_engine<uint64_t>>;\n\n// -----------------------------------------------------------------------------\n// absl::InsecureBitGen\n// -----------------------------------------------------------------------------\n//\n// `absl::InsecureBitGen` is an efficient random bit generator for generating\n// random values, recommended only for performance-sensitive use cases where\n// `absl::BitGen` is not satisfactory when compute-bounded by bit generation\n// costs.\n//\n// Example:\n//\n//   // Create an absl::InsecureBitGen\n//   absl::InsecureBitGen gen;\n//   for (size_t i = 0; i < 1000000; i++) {\n//\n//     // Generate a bunch of random values from some complex distribution\n//     auto my_rnd = some_distribution(gen, 1, 1000);\n//   }\n//\n// Like `absl::BitGen`, `absl::InsecureBitGen` is seeded by default with\n// non-deterministic data to produce different sequences of random values across\n// different instances, including different binary invocations. (This behavior\n// is different than the standard library bit generators, which use golden\n// values as their seeds.)\n//\n// `absl::InsecureBitGen` may be constructed with an optional seed sequence\n// type, conforming to [rand.req.seed_seq], which will be mixed with additional\n// non-deterministic data, as detailed in the `absl::BitGen` comment.\n//\n// `absl::InsecureBitGen` meets the requirements of the Uniform Random Bit\n// Generator (URBG) concept as per the C++17 standard [rand.req.urng] though\n// its implementation differs slightly with [rand.req.eng]. Like its standard\n// library equivalents (e.g. `std::mersenne_twister_engine`)\n// `absl::InsecureBitGen` is not cryptographically secure.\n//\n// Prefer `absl::BitGen` over `absl::InsecureBitGen` as the general type is\n// often fast enough for the vast majority of applications.\n\nusing InsecureBitGen =\n    random_internal::NonsecureURBGBase<random_internal::pcg64_2018_engine>;\n\n// ---------------------------------------------------------------------------\n// absl::InsecureBitGen member functions\n// ---------------------------------------------------------------------------\n\n// absl::InsecureBitGen::operator()()\n//\n// Calls the InsecureBitGen, returning a generated value.\n\n// absl::InsecureBitGen::min()\n//\n// Returns the smallest possible value from this bit generator.\n\n// absl::InsecureBitGen::max()\n//\n// Returns the largest possible value from this bit generator.\n\n// absl::InsecureBitGen::discard(num)\n//\n// Advances the internal state of this bit generator by `num` times, and\n// discards the intermediate results.\n// ---------------------------------------------------------------------------\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03893",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/random.h",
  "source_line": 43,
  "validation_status": "validated"
}