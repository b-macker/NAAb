{
  "code": "{\n  /// IdDeclInfo - Keeps track of information about decls associated\n  /// to a particular declaration name. IdDeclInfos are lazily\n  /// constructed and assigned to a declaration name the first time a\n  /// decl with that declaration name is shadowed in some scope.\n  class IdDeclInfo {\n  public:\n    using DeclsTy = SmallVector<NamedDecl *, 2>;\n\n    DeclsTy::iterator decls_begin() { return Decls.begin(); }\n    DeclsTy::iterator decls_end() { return Decls.end(); }\n\n    void AddDecl(NamedDecl *D) { Decls.push_back(D); }\n\n    /// RemoveDecl - Remove the decl from the scope chain.\n    /// The decl must already be part of the decl chain.\n    void RemoveDecl(NamedDecl *D);\n\n    /// Insert the given declaration at the given position in the list.\n    void InsertDecl(DeclsTy::iterator Pos, NamedDecl *D) {\n      Decls.insert(Pos, D);\n    }\n\n  private:\n    DeclsTy Decls;\n  };\n\npublic:\n  /// iterator - Iterate over the decls of a specified declaration name.\n  /// It will walk or not the parent declaration contexts depending on how\n  /// it was instantiated.\n  class iterator {\n  public:\n    friend class IdentifierResolver;\n\n    using value_type = NamedDecl *;\n    using reference = NamedDecl *;\n    using pointer = NamedDecl *;\n    using iterator_category = std::input_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    /// Ptr - There are 2 forms that 'Ptr' represents:\n    /// 1) A single NamedDecl. (Ptr & 0x1 == 0)\n    /// 2) A IdDeclInfo::DeclsTy::iterator that traverses only the decls of the\n    ///    same declaration context. (Ptr & 0x1 == 0x1)\n    uintptr_t Ptr = 0;\n    using BaseIter = IdDeclInfo::DeclsTy::iterator;\n\n    /// A single NamedDecl. (Ptr & 0x1 == 0)\n    iterator(NamedDecl *D) {\n      Ptr = reinterpret_cast<uintptr_t>(D);\n      assert((Ptr & 0x1) == 0 && \"Invalid Ptr!\");\n    }\n\n    /// A IdDeclInfo::DeclsTy::iterator that walks or not the parent declaration\n    /// contexts depending on 'LookInParentCtx'.\n    iterator(BaseIter I) {\n      Ptr = reinterpret_cast<uintptr_t>(I) | 0x1;\n    }\n\n    bool isIterator() const { return (Ptr & 0x1); }\n\n    BaseIter getIterator() const {\n      assert(isIterator() && \"Ptr not an iterator!\");\n      return reinterpret_cast<BaseIter>(Ptr & ~0x1);\n    }\n\n    void incrementSlowCase();\n\n  public:\n    iterator() = default;\n\n    NamedDecl *operator*() const {\n      if (isIterator())\n        return *getIterator();\n      else\n        return reinterpret_cast<NamedDecl*>(Ptr);\n    }\n\n    bool operator==(const iterator &RHS) const {\n      return Ptr == RHS.Ptr;\n    }\n    bool operator!=(const iterator &RHS) const {\n      return Ptr != RHS.Ptr;\n    }\n\n    // Preincrement.\n    iterator& operator++() {\n      if (!isIterator()) // common case.\n        Ptr = 0;\n      else\n        incrementSlowCase();\n      return *this;\n    }\n  };\n\n  explicit IdentifierResolver(Preprocessor &PP);\n  ~IdentifierResolver();\n\n  /// Returns a range of decls with the name 'Name'.\n  llvm::iterator_range<iterator> decls(DeclarationName Name);\n\n  /// Returns an iterator over decls with the name 'Name'.\n  iterator begin(DeclarationName Name);\n\n  /// Returns the end iterator.\n  iterator end() { return iterator(); }\n\n  /// isDeclInScope - If 'Ctx' is a function/method, isDeclInScope returns true\n  /// if 'D' is in Scope 'S', otherwise 'S' is ignored and isDeclInScope returns\n  /// true if 'D' belongs to the given declaration context.\n  ///\n  /// \\param AllowInlineNamespace If \\c true, we are checking whether a prior\n  ///        declaration is in scope in a declaration that requires a prior\n  ///        declaration (because it is either explicitly qualified or is a\n  ///        template instantiation or specialization). In this case, a\n  ///        declaration is in scope if it's in the inline namespace set of the\n  ///        context.\n  bool isDeclInScope(Decl *D, DeclContext *Ctx, Scope *S = nullptr,\n                     bool AllowInlineNamespace = false) const;\n\n  /// AddDecl - Link the decl to its shadowed decl chain.\n  void AddDecl(NamedDecl *D);\n\n  /// RemoveDecl - Unlink the decl from its shadowed decl chain.\n  /// The decl must already be part of the decl chain.\n  void RemoveDecl(NamedDecl *D);\n\n  /// Insert the given declaration after the given iterator\n  /// position.\n  void InsertDeclAfter(iterator Pos, NamedDecl *D);\n\n  /// Try to add the given declaration to the top level scope, if it\n  /// (or a redeclaration of it) hasn't already been added.\n  ///\n  /// \\param D The externally-produced declaration to add.\n  ///\n  /// \\param Name The name of the externally-produced declaration.\n  ///\n  /// \\returns true if the declaration was added, false otherwise.\n  bool tryAddTopLevelDecl(NamedDecl *D, DeclarationName Name);\n\nprivate:\n  const LangOptions &LangOpt;\n  Preprocessor &PP;\n\n  class IdDeclInfoMap;\n  IdDeclInfoMap *IdDeclInfos;\n\n  void updatingIdentifier(IdentifierInfo &II);\n  void readingIdentifier(IdentifierInfo &II);\n\n  /// FETokenInfo contains a Decl pointer if lower bit == 0.\n  static inline bool isDeclPtr(void *Ptr) {\n    return (reinterpret_cast<uintptr_t>(Ptr) & 0x1) == 0;\n  }\n\n  /// FETokenInfo contains a IdDeclInfo pointer if lower bit == 1.\n  static inline IdDeclInfo *toIdDeclInfo(void *Ptr) {\n    assert((reinterpret_cast<uintptr_t>(Ptr) & 0x1) == 1\n          && \"Ptr not a IdDeclInfo* !\");\n    return reinterpret_cast<IdDeclInfo*>(\n                    reinterpret_cast<uintptr_t>(Ptr) & ~0x1);\n  }\n}",
  "id": "BLOCK-CPP-19795",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/IdentifierResolver.h",
  "source_line": 38,
  "validation_status": "validated"
}