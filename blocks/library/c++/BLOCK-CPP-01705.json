{
  "code": "#include \"absl/flags/parse.h\"\n#include <stdlib.h>\n#include <algorithm>\n#include <cstdint>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n#include <windows.h>\n#include \"absl/algorithm/container.h\"\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/const_init.h\"\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/flags/commandlineflag.h\"\n#include \"absl/flags/config.h\"\n#include \"absl/flags/flag.h\"\n#include \"absl/flags/internal/commandlineflag.h\"\n#include \"absl/flags/internal/flag.h\"\n#include \"absl/flags/internal/parse.h\"\n#include \"absl/flags/internal/private_handle_accessor.h\"\n#include \"absl/flags/internal/program_name.h\"\n#include \"absl/flags/internal/usage.h\"\n#include \"absl/flags/reflection.h\"\n#include \"absl/flags/usage.h\"\n#include \"absl/flags/usage_config.h\"\n#include \"absl/strings/ascii.h\"\n#include \"absl/strings/internal/damerau_levenshtein_distance.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_join.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/strings/strip.h\"\n#include \"absl/synchronization/mutex.h\"\n\nusing namespace absl;\nusing namespace flags_internal;\nusing namespace flags_internal;\nusing namespace absl;\nusing namespace absl;\nusing namespace flags_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01705_execute() {\n    {\n  bool success = true;\n\n  absl::MutexLock l(&flags_internal::processing_checks_guard);\n\n  // flagfile could have been set either on a command line or\n  // programmatically before invoking ParseCommandLine. Note that we do not\n  // actually process arguments specified in the flagfile, but instead\n  // create a secondary arguments list to be processed along with the rest\n  // of the command line arguments. Since we always the process most recently\n  // created list of arguments first, this will result in flagfile argument\n  // being processed before any other argument in the command line. If\n  // FLAGS_flagfile contains more than one file name we create multiple new\n  // levels of arguments in a reverse order of file names. Thus we always\n  // process arguments from first file before arguments containing in a\n  // second file, etc. If flagfile contains another\n  // --flagfile inside of it, it will produce new level of arguments and\n  // processed before the rest of the flagfile. We are also collecting all\n  // flagfiles set on original command line. Unlike the rest of the flags,\n  // this flag can be set multiple times and is expected to be handled\n  // multiple times. We are collecting them all into a single list and set\n  // the value of FLAGS_flagfile to that value at the end of the parsing.\n  if (flags_internal::flagfile_needs_processing) {\n    auto flagfiles = absl::GetFlag(FLAGS_flagfile);\n\n    if (input_args.size() == 1) {\n      flagfile_value.insert(flagfile_value.end(), flagfiles.begin(),\n                            flagfiles.end());\n    }\n\n    success &= ReadFlagfiles(flagfiles, input_args);\n\n    flags_internal::flagfile_needs_processing = false;\n  }\n\n  // Similar to flagfile fromenv/tryfromemv can be set both\n  // programmatically and at runtime on a command line. Unlike flagfile these\n  // can't be recursive.\n  if (flags_internal::fromenv_needs_processing) {\n    auto flags_list = absl::GetFlag(FLAGS_fromenv);\n\n    success &= ReadFlagsFromEnv(flags_list, input_args, true);\n\n    flags_internal::fromenv_needs_processing = false;\n  }\n\n  if (flags_internal::tryfromenv_needs_processing) {\n    auto flags_list = absl::GetFlag(FLAGS_tryfromenv);\n\n    success &= ReadFlagsFromEnv(flags_list, input_args, false);\n\n    flags_internal::tryfromenv_needs_processing = false;\n  }\n\n  return success;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01705",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/parse.cc",
  "source_line": 414,
  "validation_status": "validated"
}