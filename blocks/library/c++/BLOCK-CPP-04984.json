{
  "code": "{\n\ntemplate <size_t Alignment>\nstruct alignas(Alignment) AlignedType {};\n\n// Allocates at least n bytes aligned to the specified alignment.\n// Alignment must be a power of 2. It must be positive.\n//\n// Note that many allocators don't honor alignment requirements above certain\n// threshold (usually either alignof(std::max_align_t) or alignof(void*)).\n// Allocate() doesn't apply alignment corrections. If the underlying allocator\n// returns insufficiently alignment pointer, that's what you are going to get.\ntemplate <size_t Alignment, class Alloc>\nvoid* Allocate(Alloc* alloc, size_t n) {\n  static_assert(Alignment > 0, \"\");\n  assert(n && \"n must be positive\");\n  using M = AlignedType<Alignment>;\n  using A = typename absl::allocator_traits<Alloc>::template rebind_alloc<M>;\n  using AT = typename absl::allocator_traits<Alloc>::template rebind_traits<M>;\n  // On macOS, \"mem_alloc\" is a #define with one argument defined in\n  // rpc/types.h, so we can't name the variable \"mem_alloc\" and initialize it\n  // with the \"foo(bar)\" syntax.\n  A my_mem_alloc(*alloc);\n  void* p = AT::allocate(my_mem_alloc, (n + sizeof(M) - 1) / sizeof(M));\n  assert(reinterpret_cast<uintptr_t>(p) % Alignment == 0 &&\n         \"allocator does not respect alignment\");\n  return p;\n}\n\n// The pointer must have been previously obtained by calling\n// Allocate<Alignment>(alloc, n).\ntemplate <size_t Alignment, class Alloc>\nvoid Deallocate(Alloc* alloc, void* p, size_t n) {\n  static_assert(Alignment > 0, \"\");\n  assert(n && \"n must be positive\");\n  using M = AlignedType<Alignment>;\n  using A = typename absl::allocator_traits<Alloc>::template rebind_alloc<M>;\n  using AT = typename absl::allocator_traits<Alloc>::template rebind_traits<M>;\n  // On macOS, \"mem_alloc\" is a #define with one argument defined in\n  // rpc/types.h, so we can't name the variable \"mem_alloc\" and initialize it\n  // with the \"foo(bar)\" syntax.\n  A my_mem_alloc(*alloc);\n  AT::deallocate(my_mem_alloc, static_cast<M*>(p),\n                 (n + sizeof(M) - 1) / sizeof(M));\n}\n\nnamespace memory_internal {\n\n// Constructs T into uninitialized storage pointed by `ptr` using the args\n// specified in the tuple.\ntemplate <class Alloc, class T, class Tuple, size_t... I>\nvoid ConstructFromTupleImpl(Alloc* alloc, T* ptr, Tuple&& t,\n                            absl::index_sequence<I...>) {\n  absl::allocator_traits<Alloc>::construct(\n      *alloc, ptr, std::get<I>(std::forward<Tuple>(t))...);\n}\n\ntemplate <class T, class F>\nstruct WithConstructedImplF {\n  template <class... Args>\n  decltype(std::declval<F>()(std::declval<T>())) operator()(\n      Args&&... args) const {\n    return std::forward<F>(f)(T(std::forward<Args>(args)...));\n  }\n  F&& f;\n};\n\ntemplate <class T, class Tuple, size_t... Is, class F>\ndecltype(std::declval<F>()(std::declval<T>())) WithConstructedImpl(\n    Tuple&& t, absl::index_sequence<Is...>, F&& f) {\n  return WithConstructedImplF<T, F>{std::forward<F>(f)}(\n      std::get<Is>(std::forward<Tuple>(t))...);\n}\n\ntemplate <class T, size_t... Is>\nauto TupleRefImpl(T&& t, absl::index_sequence<Is...>)\n    -> decltype(std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...)) {\n  return std::forward_as_tuple(std::get<Is>(std::forward<T>(t))...);\n}\n\n// Returns a tuple of references to the elements of the input tuple. T must be a\n// tuple.\ntemplate <class T>\nauto TupleRef(T&& t) -> decltype(TupleRefImpl(\n    std::forward<T>(t),\n    absl::make_index_sequence<\n        std::tuple_size<typename std::decay<T>::type>::value>())) {\n  return TupleRefImpl(\n      std::forward<T>(t),\n      absl::make_index_sequence<\n          std::tuple_size<typename std::decay<T>::type>::value>());\n}\n\ntemplate <class F, class K, class V>\ndecltype(std::declval<F>()(std::declval<const K&>(), std::piecewise_construct,\n                           std::declval<std::tuple<K>>(), std::declval<V>()))\nDecomposePairImpl(F&& f, std::pair<std::tuple<K>, V> p) {\n  const auto& key = std::get<0>(p.first);\n  return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),\n                            std::move(p.second));\n}\n\n}  // namespace memory_internal\n\n// Constructs T into uninitialized storage pointed by `ptr` using the args\n// specified in the tuple.\ntemplate <class Alloc, class T, class Tuple>\nvoid ConstructFromTuple(Alloc* alloc, T* ptr, Tuple&& t) {\n  memory_internal::ConstructFromTupleImpl(\n      alloc, ptr, std::forward<Tuple>(t),\n      absl::make_index_sequence<\n          std::tuple_size<typename std::decay<Tuple>::type>::value>());\n}\n\n// Constructs T using the args specified in the tuple and calls F with the\n// constructed value.\ntemplate <class T, class Tuple, class F>\ndecltype(std::declval<F>()(std::declval<T>())) WithConstructed(Tuple&& t,\n                                                               F&& f) {\n  return memory_internal::WithConstructedImpl<T>(\n      std::forward<Tuple>(t),\n      absl::make_index_sequence<\n          std::tuple_size<typename std::decay<Tuple>::type>::value>(),\n      std::forward<F>(f));\n}\n\n// Given arguments of an std::pair's constructor, PairArgs() returns a pair of\n// tuples with references to the passed arguments. The tuples contain\n// constructor arguments for the first and the second elements of the pair.\n//\n// The following two snippets are equivalent.\n//\n// 1. std::pair<F, S> p(args...);\n//\n// 2. auto a = PairArgs(args...);\n//    std::pair<F, S> p(std::piecewise_construct,\n//                      std::move(a.first), std::move(a.second));\ninline std::pair<std::tuple<>, std::tuple<>> PairArgs() { return {}; }\ntemplate <class F, class S>\nstd::pair<std::tuple<F&&>, std::tuple<S&&>> PairArgs(F&& f, S&& s) {\n  return {std::piecewise_construct, std::forward_as_tuple(std::forward<F>(f)),\n          std::forward_as_tuple(std::forward<S>(s))};\n}\ntemplate <class F, class S>\nstd::pair<std::tuple<const F&>, std::tuple<const S&>> PairArgs(\n    const std::pair<F, S>& p) {\n  return PairArgs(p.first, p.second);\n}\ntemplate <class F, class S>\nstd::pair<std::tuple<F&&>, std::tuple<S&&>> PairArgs(std::pair<F, S>&& p) {\n  return PairArgs(std::forward<F>(p.first), std::forward<S>(p.second));\n}\ntemplate <class F, class S>\nauto PairArgs(std::piecewise_construct_t, F&& f, S&& s)\n    -> decltype(std::make_pair(memory_internal::TupleRef(std::forward<F>(f)),\n                               memory_internal::TupleRef(std::forward<S>(s)))) {\n  return std::make_pair(memory_internal::TupleRef(std::forward<F>(f)),\n                        memory_internal::TupleRef(std::forward<S>(s)));\n}\n\n// A helper function for implementing apply() in map policies.\ntemplate <class F, class... Args>\nauto DecomposePair(F&& f, Args&&... args)\n    -> decltype(memory_internal::DecomposePairImpl(\n        std::forward<F>(f), PairArgs(std::forward<Args>(args)...))) {\n  return memory_internal::DecomposePairImpl(\n      std::forward<F>(f), PairArgs(std::forward<Args>(args)...));\n}\n\n// A helper function for implementing apply() in set policies.\ntemplate <class F, class Arg>\ndecltype(std::declval<F>()(std::declval<const Arg&>(), std::declval<Arg>()))\nDecomposeValue(F&& f, Arg&& arg) {\n  const auto& key = arg;\n  return std::forward<F>(f)(key, std::forward<Arg>(arg));\n}\n\n// Helper functions for asan and msan.\ninline void SanitizerPoisonMemoryRegion(const void* m, size_t s) {\n#ifdef ABSL_HAVE_ADDRESS_SANITIZER\n  ASAN_POISON_MEMORY_REGION(m, s);\n#endif\n#ifdef ABSL_HAVE_MEMORY_SANITIZER\n  __msan_poison(m, s);\n#endif\n  (void)m;\n  (void)s;\n}\n\ninline void SanitizerUnpoisonMemoryRegion(const void* m, size_t s) {\n#ifdef ABSL_HAVE_ADDRESS_SANITIZER\n  ASAN_UNPOISON_MEMORY_REGION(m, s);\n#endif\n#ifdef ABSL_HAVE_MEMORY_SANITIZER\n  __msan_unpoison(m, s);\n#endif\n  (void)m;\n  (void)s;\n}\n\ntemplate <typename T>\ninline void SanitizerPoisonObject(const T* object) {\n  SanitizerPoisonMemoryRegion(object, sizeof(T));\n}\n\ntemplate <typename T>\ninline void SanitizerUnpoisonObject(const T* object) {\n  SanitizerUnpoisonMemoryRegion(object, sizeof(T));\n}\n\nnamespace memory_internal {\n\n// If Pair is a standard-layout type, OffsetOf<Pair>::kFirst and\n// OffsetOf<Pair>::kSecond are equivalent to offsetof(Pair, first) and\n// offsetof(Pair, second) respectively. Otherwise they are -1.\n//\n// The purpose of OffsetOf is to avoid calling offsetof() on non-standard-layout\n// type, which is non-portable.\ntemplate <class Pair, class = std::true_type>\nstruct OffsetOf {\n  static constexpr size_t kFirst = static_cast<size_t>(-1);\n  static constexpr size_t kSecond = static_cast<size_t>(-1);\n};\n\ntemplate <class Pair>\nstruct OffsetOf<Pair, typename std::is_standard_layout<Pair>::type> {\n  static constexpr size_t kFirst = offsetof(Pair, first);\n  static constexpr size_t kSecond = offsetof(Pair, second);\n};\n\ntemplate <class K, class V>\nstruct IsLayoutCompatible {\n private:\n  struct Pair {\n    K first;\n    V second;\n  };\n\n  // Is P layout-compatible with Pair?\n  template <class P>\n  static constexpr bool LayoutCompatible() {\n    return std::is_standard_layout<P>() && sizeof(P) == sizeof(Pair) &&\n           alignof(P) == alignof(Pair) &&\n           memory_internal::OffsetOf<P>::kFirst ==\n               memory_internal::OffsetOf<Pair>::kFirst &&\n           memory_internal::OffsetOf<P>::kSecond ==\n               memory_internal::OffsetOf<Pair>::kSecond;\n  }\n\n public:\n  // Whether pair<const K, V> and pair<K, V> are layout-compatible. If they are,\n  // then it is safe to store them in a union and read from either.\n  static constexpr bool value = std::is_standard_layout<K>() &&\n                                std::is_standard_layout<Pair>() &&\n                                memory_internal::OffsetOf<Pair>::kFirst == 0 &&\n                                LayoutCompatible<std::pair<K, V>>() &&\n                                LayoutCompatible<std::pair<const K, V>>();\n};\n\n}  // namespace memory_internal\n\n// The internal storage type for key-value containers like flat_hash_map.\n//\n// It is convenient for the value_type of a flat_hash_map<K, V> to be\n// pair<const K, V>; the \"const K\" prevents accidental modification of the key\n// when dealing with the reference returned from find() and similar methods.\n// However, this creates other problems; we want to be able to emplace(K, V)\n// efficiently with move operations, and similarly be able to move a\n// pair<K, V> in insert().\n//\n// The solution is this union, which aliases the const and non-const versions\n// of the pair. This also allows flat_hash_map<const K, V> to work, even though\n// that has the same efficiency issues with move in emplace() and insert() -\n// but people do it anyway.\n//\n// If kMutableKeys is false, only the value member can be accessed.\n//\n// If kMutableKeys is true, key can be accessed through all slots while value\n// and mutable_value must be accessed only via INITIALIZED slots. Slots are\n// created and destroyed via mutable_value so that the key can be moved later.\n//\n// Accessing one of the union fields while the other is active is safe as\n// long as they are layout-compatible, which is guaranteed by the definition of\n// kMutableKeys. For C++11, the relevant section of the standard is\n// https://timsong-cpp.github.io/cppwp/n3337/class.mem#19 (9.2.19)\ntemplate <class K, class V>\nunion map_slot_type {\n  map_slot_type() {}\n  ~map_slot_type() = delete;\n  using value_type = std::pair<const K, V>;\n  using mutable_value_type =\n      std::pair<absl::remove_const_t<K>, absl::remove_const_t<V>>;\n\n  value_type value;\n  mutable_value_type mutable_value;\n  absl::remove_const_t<K> key;\n};\n\ntemplate <class K, class V>\nstruct map_slot_policy {\n  using slot_type = map_slot_type<K, V>;\n  using value_type = std::pair<const K, V>;\n  using mutable_value_type =\n      std::pair<absl::remove_const_t<K>, absl::remove_const_t<V>>;\n\n private:\n  static void emplace(slot_type* slot) {\n    // The construction of union doesn't do anything at runtime but it allows us\n    // to access its members without violating aliasing rules.\n    new (slot) slot_type;\n  }\n  // If pair<const K, V> and pair<K, V> are layout-compatible, we can accept one\n  // or the other via slot_type. We are also free to access the key via\n  // slot_type::key in this case.\n  using kMutableKeys = memory_internal::IsLayoutCompatible<K, V>;\n\n public:\n  static value_type& element(slot_type* slot) { return slot->value; }\n  static const value_type& element(const slot_type* slot) {\n    return slot->value;\n  }\n\n  // When C++17 is available, we can use std::launder to provide mutable\n  // access to the key for use in node handle.\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n  static K& mutable_key(slot_type* slot) {\n    // Still check for kMutableKeys so that we can avoid calling std::launder\n    // unless necessary because it can interfere with optimizations.\n    return kMutableKeys::value ? slot->key\n                               : *std::launder(const_cast<K*>(\n                                     std::addressof(slot->value.first)));\n  }\n#else  // !(defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606)\n  static const K& mutable_key(slot_type* slot) { return key(slot); }\n#endif\n\n  static const K& key(const slot_type* slot) {\n    return kMutableKeys::value ? slot->key : slot->value.first;\n  }\n\n  template <class Allocator, class... Args>\n  static void construct(Allocator* alloc, slot_type* slot, Args&&... args) {\n    emplace(slot);\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->mutable_value,\n                                                   std::forward<Args>(args)...);\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                   std::forward<Args>(args)...);\n    }\n  }\n\n  // Construct this slot by moving from another slot.\n  template <class Allocator>\n  static void construct(Allocator* alloc, slot_type* slot, slot_type* other) {\n    emplace(slot);\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(\n          *alloc, &slot->mutable_value, std::move(other->mutable_value));\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                   std::move(other->value));\n    }\n  }\n\n  // Construct this slot by copying from another slot.\n  template <class Allocator>\n  static void construct(Allocator* alloc, slot_type* slot,\n                        const slot_type* other) {\n    emplace(slot);\n    absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                 other->value);\n  }\n\n  template <class Allocator>\n  static void destroy(Allocator* alloc, slot_type* slot) {\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::destroy(*alloc, &slot->mutable_value);\n    } else {\n      absl::allocator_traits<Allocator>::destroy(*alloc, &slot->value);\n    }\n  }\n\n  template <class Allocator>\n  static auto transfer(Allocator* alloc, slot_type* new_slot,\n                       slot_type* old_slot) {\n    auto is_relocatable =\n        typename absl::is_trivially_relocatable<value_type>::type();\n\n    emplace(new_slot);\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n    if (is_relocatable) {\n      // TODO(b/247130232,b/251814870): remove casts after fixing warnings.\n      std::memcpy(static_cast<void*>(std::launder(&new_slot->value)),\n                  static_cast<const void*>(&old_slot->value),\n                  sizeof(value_type));\n      return is_relocatable;\n    }\n#endif\n\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(\n          *alloc, &new_slot->mutable_value, std::move(old_slot->mutable_value));\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &new_slot->value,\n                                                   std::move(old_slot->value));\n    }\n    destroy(alloc, old_slot);\n    return is_relocatable;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-04984",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/container_memory.h",
  "source_line": 42,
  "validation_status": "validated"
}