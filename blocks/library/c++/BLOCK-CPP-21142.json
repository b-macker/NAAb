{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace tooling;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21142_execute() {\n    {\npublic:\n  virtual ~CompilationDatabase();\n\n  /// Loads a compilation database from a build directory.\n  ///\n  /// Looks at the specified 'BuildDirectory' and creates a compilation database\n  /// that allows to query compile commands for source files in the\n  /// corresponding source tree.\n  ///\n  /// Returns NULL and sets ErrorMessage if we were not able to build up a\n  /// compilation database for the build directory.\n  ///\n  /// FIXME: Currently only supports JSON compilation databases, which\n  /// are named 'compile_commands.json' in the given directory. Extend this\n  /// for other build types (like ninja build files).\n  static std::unique_ptr<CompilationDatabase>\n  loadFromDirectory(StringRef BuildDirectory, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in all parent paths of file 'SourceFile'\n  /// by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromSource(StringRef SourceFile, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in directory 'SourceDir' and all\n  /// its parent paths by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromDirectory(StringRef SourceDir, std::string &ErrorMessage);\n\n  /// Returns all compile commands in which the specified file was\n  /// compiled.\n  ///\n  /// This includes compile commands that span multiple source files.\n  /// For example, consider a project with the following compilations:\n  /// $ clang++ -o test a.cc b.cc t.cc\n  /// $ clang++ -o production a.cc b.cc -DPRODUCTION\n  /// A compilation database representing the project would return both command\n  /// lines for a.cc and b.cc and only the first command line for t.cc.\n  virtual std::vector<CompileCommand> getCompileCommands(\n      StringRef FilePath) const = 0;\n\n  /// Returns the list of all files available in the compilation database.\n  ///\n  /// By default, returns nothing. Implementations should override this if they\n  /// can enumerate their source files.\n  virtual std::vector<std::string> getAllFiles() const { return {}; }\n\n  /// Returns all compile commands for all the files in the compilation\n  /// database.\n  ///\n  /// FIXME: Add a layer in Tooling that provides an interface to run a tool\n  /// over all files in a compilation database. Not all build systems have the\n  /// ability to provide a feasible implementation for \\c getAllCompileCommands.\n  ///\n  /// By default, this is implemented in terms of getAllFiles() and\n  /// getCompileCommands(). Subclasses may override this for efficiency.\n  virtual std::vector<CompileCommand> getAllCompileCommands() const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21142",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/CompilationDatabase.h",
  "source_line": 87,
  "validation_status": "validated"
}