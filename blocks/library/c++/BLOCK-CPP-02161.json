{
  "code": "#include \"absl/time/clock.h\"\n#include \"absl/base/attributes.h\"\n#include \"absl/base/optimization.h\"\n#include <windows.h>\n#include <algorithm>\n#include <atomic>\n#include <cerrno>\n#include <cstdint>\n#include <ctime>\n#include <limits>\n#include \"absl/base/internal/spinlock.h\"\n#include \"absl/base/internal/unscaledcycleclock.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/base/port.h\"\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/time/internal/get_current_time_chrono.inc\"\n#include \"absl/time/internal/get_current_time_posix.inc\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\nusing namespace time_internal;\nusing namespace time_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02161_execute() {\n    {\n    // Enough time has passed to compute the cycle time.\n    if (sample->nsscaled_per_cycle != 0) {  // Have a cycle time estimate.\n      // Compute time from counter reading, but avoiding overflow\n      // delta_cycles may be larger than on the fast path.\n      uint64_t estimated_scaled_ns;\n      int s = -1;\n      do {\n        s++;\n        estimated_scaled_ns = (delta_cycles >> s) * sample->nsscaled_per_cycle;\n      } while (estimated_scaled_ns / sample->nsscaled_per_cycle !=\n               (delta_cycles >> s));\n      estimated_base_ns = sample->base_ns +\n                          (estimated_scaled_ns >> (kScale - s));\n    }\n\n    // Compute the assumed cycle time kMinNSBetweenSamples ns into the future\n    // assuming the cycle counter rate stays the same as the last interval.\n    uint64_t ns = now_ns - sample->raw_ns;\n    uint64_t measured_nsscaled_per_cycle = SafeDivideAndScale(ns, delta_cycles);\n\n    uint64_t assumed_next_sample_delta_cycles =\n        SafeDivideAndScale(kMinNSBetweenSamples, measured_nsscaled_per_cycle);\n\n    // Estimate low by this much.\n    int64_t diff_ns = static_cast<int64_t>(now_ns - estimated_base_ns);\n\n    // We want to set nsscaled_per_cycle so that our estimate of the ns time\n    // at the assumed cycle time is the assumed ns time.\n    // That is, we want to set nsscaled_per_cycle so:\n    //  kMinNSBetweenSamples + diff_ns  ==\n    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale\n    // But we wish to damp oscillations, so instead correct only most\n    // of our current error, by solving:\n    //  kMinNSBetweenSamples + diff_ns - (diff_ns / 16) ==\n    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale\n    ns = static_cast<uint64_t>(static_cast<int64_t>(kMinNSBetweenSamples) +\n                               diff_ns - (diff_ns / 16));\n    uint64_t new_nsscaled_per_cycle =\n        SafeDivideAndScale(ns, assumed_next_sample_delta_cycles);\n    if (new_nsscaled_per_cycle != 0 &&\n        diff_ns < 100 * 1000 * 1000 && -diff_ns < 100 * 1000 * 1000) {\n      // record the cycle time measurement\n      time_state.last_sample.nsscaled_per_cycle.store(\n          new_nsscaled_per_cycle, std::memory_order_relaxed);\n      uint64_t new_min_cycles_per_sample =\n          SafeDivideAndScale(kMinNSBetweenSamples, new_nsscaled_per_cycle);\n      time_state.last_sample.min_cycles_per_sample.store(\n          new_min_cycles_per_sample, std::memory_order_relaxed);\n      time_state.stats_calibrations++;\n    } else {  // something went wrong; forget the slope\n      time_state.last_sample.nsscaled_per_cycle.store(\n          0, std::memory_order_relaxed);\n      time_state.last_sample.min_cycles_per_sample.store(\n          0, std::memory_order_relaxed);\n      estimated_base_ns = now_ns;\n      time_state.stats_reinitializations++;\n    }\n    time_state.last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);\n    time_state.last_sample.base_ns.store(estimated_base_ns,\n                                         std::memory_order_relaxed);\n    time_state.last_sample.base_cycles.store(now_cycles,\n                                             std::memory_order_relaxed);\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02161",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/clock.cc",
  "source_line": 470,
  "validation_status": "validated"
}