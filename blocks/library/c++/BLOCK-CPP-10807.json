{
  "code": "{\n///     S() { }  // User defined constructor makes S non-POD.\n///     ~S() { } // User defined destructor makes it non-trivial.\n///   };\n///   void test() {\n///     const S &s_ref = S(); // Requires a CXXBindTemporaryExpr.\n///   }\n/// \\endcode\nclass CXXBindTemporaryExpr : public Expr {\n  CXXTemporary *Temp = nullptr;\n  Stmt *SubExpr = nullptr;\n\n  CXXBindTemporaryExpr(CXXTemporary *temp, Expr *SubExpr)\n      : Expr(CXXBindTemporaryExprClass, SubExpr->getType(), VK_PRValue,\n             OK_Ordinary),\n        Temp(temp), SubExpr(SubExpr) {\n    setDependence(computeDependence(this));\n  }\n\npublic:\n  CXXBindTemporaryExpr(EmptyShell Empty)\n      : Expr(CXXBindTemporaryExprClass, Empty) {}\n\n  static CXXBindTemporaryExpr *Create(const ASTContext &C, CXXTemporary *Temp,\n                                      Expr* SubExpr);\n\n  CXXTemporary *getTemporary() { return Temp; }\n  const CXXTemporary *getTemporary() const { return Temp; }\n  void setTemporary(CXXTemporary *T) { Temp = T; }\n\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXBindTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n/// Represents a call to a C++ constructor.\nclass CXXConstructExpr : public Expr {\n  friend class ASTStmtReader;\n\npublic:\n  enum ConstructionKind {\n    CK_Complete,\n    CK_NonVirtualBase,\n    CK_VirtualBase,\n    CK_Delegating\n  };\n\nprivate:\n  /// A pointer to the constructor which will be ultimately called.\n  CXXConstructorDecl *Constructor;\n\n  SourceRange ParenOrBraceRange;\n\n  /// The number of arguments.\n  unsigned NumArgs;\n\n  // We would like to stash the arguments of the constructor call after\n  // CXXConstructExpr. However CXXConstructExpr is used as a base class of\n  // CXXTemporaryObjectExpr which makes the use of llvm::TrailingObjects\n  // impossible.\n  //\n  // Instead we manually stash the trailing object after the full object\n  // containing CXXConstructExpr (that is either CXXConstructExpr or\n  // CXXTemporaryObjectExpr).\n  //\n  // The trailing objects are:\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the arguments of the\n  //   constructor call.\n\n  /// Return a pointer to the start of the trailing arguments.\n  /// Defined just after CXXTemporaryObjectExpr.\n  inline Stmt **getTrailingArgs();\n  const Stmt *const *getTrailingArgs() const {\n    return const_cast<CXXConstructExpr *>(this)->getTrailingArgs();\n  }\n\nprotected:\n  /// Build a C++ construction expression.\n  CXXConstructExpr(StmtClass SC, QualType Ty, SourceLocation Loc,\n                   CXXConstructorDecl *Ctor, bool Elidable,\n                   ArrayRef<Expr *> Args, bool HadMultipleCandidates,\n                   bool ListInitialization, bool StdInitListInitialization,\n                   bool ZeroInitialization, ConstructionKind ConstructKind,\n                   SourceRange ParenOrBraceRange);\n\n  /// Build an empty C++ construction expression.\n  CXXConstructExpr(StmtClass SC, EmptyShell Empty, unsigned NumArgs);\n\n  /// Return the size in bytes of the trailing objects. Used by\n  /// CXXTemporaryObjectExpr to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumArgs) {\n    return NumArgs * sizeof(Stmt *);\n  }\n\npublic:\n  /// Create a C++ construction expression.\n  static CXXConstructExpr *\n  Create(const ASTContext &Ctx, QualType Ty, SourceLocation Loc,\n         CXXConstructorDecl *Ctor, bool Elidable, ArrayRef<Expr *> Args,\n         bool HadMultipleCandidates, bool ListInitialization,\n         bool StdInitListInitialization, bool ZeroInitialization,\n         ConstructionKind ConstructKind, SourceRange ParenOrBraceRange);\n\n  /// Create an empty C++ construction expression.\n  static CXXConstructExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs);\n\n  /// Get the constructor that this expression will (ultimately) call.\n  CXXConstructorDecl *getConstructor() const { return Constructor; }\n\n  SourceLocation getLocation() const { return CXXConstructExprBits.Loc; }\n  void setLocation(SourceLocation Loc) { CXXConstructExprBits.Loc = Loc; }\n\n  /// Whether this construction is elidable.\n  bool isElidable() const { return CXXConstructExprBits.Elidable; }\n  void setElidable(bool E) { CXXConstructExprBits.Elidable = E; }\n\n  /// Whether the referred constructor was resolved from\n  /// an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return CXXConstructExprBits.HadMultipleCandidates;\n  }\n  void setHadMultipleCandidates(bool V) {\n    CXXConstructExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization.\n  bool isListInitialization() const {\n    return CXXConstructExprBits.ListInitialization;\n  }\n  void setListInitialization(bool V) {\n    CXXConstructExprBits.ListInitialization = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization,\n  /// but was interpreted as forming a std::initializer_list<T> from the list\n  /// and passing that as a single constructor argument.\n  /// See C++11 [over.match.list]p1 bullet 1.\n  bool isStdInitListInitialization() const {\n    return CXXConstructExprBits.StdInitListInitialization;\n  }\n  void setStdInitListInitialization(bool V) {\n    CXXConstructExprBits.StdInitListInitialization = V;\n  }\n\n  /// Whether this construction first requires\n  /// zero-initialization before the initializer is called.\n  bool requiresZeroInitialization() const {\n    return CXXConstructExprBits.ZeroInitialization;\n  }\n  void setRequiresZeroInitialization(bool ZeroInit) {\n    CXXConstructExprBits.ZeroInitialization = ZeroInit;\n  }\n\n  /// Determine whether this constructor is actually constructing\n  /// a base class (rather than a complete object).\n  ConstructionKind getConstructionKind() const {\n    return static_cast<ConstructionKind>(CXXConstructExprBits.ConstructionKind);\n  }\n  void setConstructionKind(ConstructionKind CK) {\n    CXXConstructExprBits.ConstructionKind = CK;\n  }\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() { return getTrailingArgs(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  const_arg_iterator arg_begin() const { return getTrailingArgs(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  Expr **getArgs() { return reinterpret_cast<Expr **>(getTrailingArgs()); }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(getTrailingArgs());\n  }\n\n  /// Return the number of arguments to the constructor call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  bool isImmediateEscalating() const {\n    return CXXConstructExprBits.IsImmediateEscalating;\n  }\n\n  void setIsImmediateEscalating(bool Set) {\n    CXXConstructExprBits.IsImmediateEscalating = Set;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getParenOrBraceRange() const { return ParenOrBraceRange; }\n  void setParenOrBraceRange(SourceRange Range) { ParenOrBraceRange = Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXConstructExprClass ||\n           T->getStmtClass() == CXXTemporaryObjectExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingArgs(), getTrailingArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<CXXConstructExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n};\n\n/// Represents a call to an inherited base class constructor from an\n/// inheriting constructor. This call implicitly forwards the arguments from\n/// the enclosing context (an inheriting constructor) to the specified inherited\n/// base class constructor.\nclass CXXInheritedCtorInitExpr : public Expr {\nprivate:\n  CXXConstructorDecl *Constructor = nullptr;\n\n  /// The location of the using declaration.\n  SourceLocation Loc;\n\n  /// Whether this is the construction of a virtual base.\n  unsigned ConstructsVirtualBase : 1;\n\n  /// Whether the constructor is inherited from a virtual base class of the\n  /// class that we construct.\n  unsigned InheritedFromVirtualBase : 1;\n\npublic:\n  friend class ASTStmtReader;\n\n  /// Construct a C++ inheriting construction expression.\n  CXXInheritedCtorInitExpr(SourceLocation Loc, QualType T,\n                           CXXConstructorDecl *Ctor, bool ConstructsVirtualBase,\n                           bool InheritedFromVirtualBase)\n      : Expr(CXXInheritedCtorInitExprClass, T, VK_PRValue, OK_Ordinary),\n        Constructor(Ctor), Loc(Loc),\n        ConstructsVirtualBase(ConstructsVirtualBase),\n        InheritedFromVirtualBase(InheritedFromVirtualBase) {\n    assert(!T->isDependentType());\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty C++ inheriting construction expression.\n  explicit CXXInheritedCtorInitExpr(EmptyShell Empty)\n      : Expr(CXXInheritedCtorInitExprClass, Empty),\n        ConstructsVirtualBase(false), InheritedFromVirtualBase(false) {}\n\n  /// Get the constructor that this expression will call.\n  CXXConstructorDecl *getConstructor() const { return Constructor; }\n\n  /// Determine whether this constructor is actually constructing\n  /// a base class (rather than a complete object).\n  bool constructsVBase() const { return ConstructsVirtualBase; }\n  CXXConstructExpr::ConstructionKind getConstructionKind() const {\n    return ConstructsVirtualBase ? CXXConstructExpr::CK_VirtualBase\n                                 : CXXConstructExpr::CK_NonVirtualBase;\n  }\n\n  /// Determine whether the inherited constructor is inherited from a\n  /// virtual base of the object we construct. If so, we are not responsible\n  /// for calling the inherited constructor (the complete object constructor\n  /// does that), and so we don't need to pass any arguments.\n  bool inheritedFromVBase() const { return InheritedFromVirtualBase; }\n\n  SourceLocation getLocation() const LLVM_READONLY { return Loc; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXInheritedCtorInitExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents an explicit C++ type conversion that uses \"functional\"\n/// notation (C++ [expr.type.conv]).\n///\n/// Example:\n/// \\code\n///   x = int(0.5);\n/// \\endcode\nclass CXXFunctionalCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CXXFunctionalCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  CXXFunctionalCastExpr(QualType ty, ExprValueKind VK,\n                        TypeSourceInfo *writtenTy, CastKind kind,\n                        Expr *castExpr, unsigned pathSize,\n                        FPOptionsOverride FPO, SourceLocation lParenLoc,\n                        SourceLocation rParenLoc)\n      : ExplicitCastExpr(CXXFunctionalCastExprClass, ty, VK, kind, castExpr,\n                         pathSize, FPO.requiresTrailingStorage(), writtenTy),\n        LParenLoc(lParenLoc), RParenLoc(rParenLoc) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  explicit CXXFunctionalCastExpr(EmptyShell Shell, unsigned PathSize,\n                                 bool HasFPFeatures)\n      : ExplicitCastExpr(CXXFunctionalCastExprClass, Shell, PathSize,\n                         HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXFunctionalCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK,\n         TypeSourceInfo *Written, CastKind Kind, Expr *Op,\n         const CXXCastPath *Path, FPOptionsOverride FPO, SourceLocation LPLoc,\n         SourceLocation RPLoc);\n  static CXXFunctionalCastExpr *\n  CreateEmpty(const ASTContext &Context, unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  /// Determine whether this expression models list-initialization.\n  bool isListInitialization() const { return LParenLoc.isInvalid(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFunctionalCastExprClass;\n  }\n};\n\n/// Represents a C++ functional cast expression that builds a\n/// temporary object.\n///\n/// This expression type represents a C++ \"functional\" cast\n/// (C++[expr.type.conv]) with N != 1 arguments that invokes a\n/// constructor to build a temporary object. With N == 1 arguments the\n/// functional cast expression will be represented by CXXFunctionalCastExpr.\n/// Example:\n/// \\code\n/// struct X { X(int, float); }\n///\n/// X create_X() {\n///   return X(1, 3.14f); // creates a CXXTemporaryObjectExpr\n/// };\n/// \\endcode\nclass CXXTemporaryObjectExpr final : public CXXConstructExpr {\n  friend class ASTStmtReader;\n\n  // CXXTemporaryObjectExpr has some trailing objects belonging\n  // to CXXConstructExpr. See the comment inside CXXConstructExpr\n  // for more details.\n\n  TypeSourceInfo *TSI;\n\n  CXXTemporaryObjectExpr(CXXConstructorDecl *Cons, QualType Ty,\n                         TypeSourceInfo *TSI, ArrayRef<Expr *> Args,\n                         SourceRange ParenOrBraceRange,\n                         bool HadMultipleCandidates, bool ListInitialization,\n                         bool StdInitListInitialization,\n                         bool ZeroInitialization);\n\n  CXXTemporaryObjectExpr(EmptyShell Empty, unsigned NumArgs);\n\npublic:\n  static CXXTemporaryObjectExpr *\n  Create(const ASTContext &Ctx, CXXConstructorDecl *Cons, QualType Ty,\n         TypeSourceInfo *TSI, ArrayRef<Expr *> Args,\n         SourceRange ParenOrBraceRange, bool HadMultipleCandidates,\n         bool ListInitialization, bool StdInitListInitialization,\n         bool ZeroInitialization);\n\n  static CXXTemporaryObjectExpr *CreateEmpty(const ASTContext &Ctx,\n                                             unsigned NumArgs);\n\n  TypeSourceInfo *getTypeSourceInfo() const { return TSI; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXTemporaryObjectExprClass;\n  }\n};\n\nStmt **CXXConstructExpr::getTrailingArgs() {\n  if (auto *E = dyn_cast<CXXTemporaryObjectExpr>(this))\n    return reinterpret_cast<Stmt **>(E + 1);\n  assert((getStmtClass() == CXXConstructExprClass) &&\n         \"Unexpected class deriving from CXXConstructExpr!\");\n  return reinterpret_cast<Stmt **>(this + 1);\n}\n\n/// A C++ lambda expression, which produces a function object\n/// (of unspecified type) that can be invoked later.\n///\n/// Example:\n/// \\code\n/// void low_pass_filter(std::vector<double> &values, double cutoff) {\n///   values.erase(std::remove_if(values.begin(), values.end(),\n///                               [=](double value) { return value > cutoff; });\n/// }\n/// \\endcode\n///\n/// C++11 lambda expressions can capture local variables, either by copying\n/// the values of those local variables at the time the function\n/// object is constructed (not when it is called!) or by holding a\n/// reference to the local variable. These captures can occur either\n/// implicitly or can be written explicitly between the square\n/// brackets ([...]) that start the lambda expression.\n///\n/// C++1y introduces a new form of \"capture\" called an init-capture that\n/// includes an initializing expression (rather than capturing a variable),\n/// and which can never occur implicitly.\nclass LambdaExpr final : public Expr,\n                         private llvm::TrailingObjects<LambdaExpr, Stmt *> {\n  // LambdaExpr has some data stored in LambdaExprBits.\n\n  /// The source range that covers the lambda introducer ([...]).\n  SourceRange IntroducerRange;\n\n  /// The source location of this lambda's capture-default ('=' or '&').\n  SourceLocation CaptureDefaultLoc;\n\n  /// The location of the closing brace ('}') that completes\n  /// the lambda.\n  ///\n  /// The location of the brace is also available by looking up the\n  /// function call operator in the lambda class. However, it is\n  /// stored here to improve the performance of getSourceRange(), and\n  /// to avoid having to deserialize the function call operator from a\n  /// module file just to determine the source range.\n  SourceLocation ClosingBrace;\n\n  /// Construct a lambda expression.\n  LambdaExpr(QualType T, SourceRange IntroducerRange,\n             LambdaCaptureDefault CaptureDefault,\n             SourceLocation CaptureDefaultLoc, bool ExplicitParams,\n             bool ExplicitResultType, ArrayRef<Expr *> CaptureInits,\n             SourceLocation ClosingBrace, bool ContainsUnexpandedParameterPack);\n\n  /// Construct an empty lambda expression.\n  LambdaExpr(EmptyShell Empty, unsigned NumCaptures);\n\n  Stmt **getStoredStmts() { return getTrailingObjects<Stmt *>(); }\n  Stmt *const *getStoredStmts() const { return getTrailingObjects<Stmt *>(); }\n\n  void initBodyIfNeeded() const;\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Construct a new lambda expression.\n  static LambdaExpr *\n  Create(const ASTContext &C, CXXRecordDecl *Class, SourceRange IntroducerRange,\n         LambdaCaptureDefault CaptureDefault, SourceLocation CaptureDefaultLoc,\n         bool ExplicitParams, bool ExplicitResultType,\n         ArrayRef<Expr *> CaptureInits, SourceLocation ClosingBrace,\n         bool ContainsUnexpandedParameterPack);\n\n  /// Construct a new lambda expression that will be deserialized from\n  /// an external source.\n  static LambdaExpr *CreateDeserialized(const ASTContext &C,\n                                        unsigned NumCaptures);\n\n  /// Determine the default capture kind for this lambda.\n  LambdaCaptureDefault getCaptureDefault() const {\n    return static_cast<LambdaCaptureDefault>(LambdaExprBits.CaptureDefault);\n  }\n\n  /// Retrieve the location of this lambda's capture-default, if any.\n  SourceLocation getCaptureDefaultLoc() const { return CaptureDefaultLoc; }\n\n  /// Determine whether one of this lambda's captures is an init-capture.\n  bool isInitCapture(const LambdaCapture *Capture) const;\n\n  /// An iterator that walks over the captures of the lambda,\n  /// both implicit and explicit.\n  using capture_iterator = const LambdaCapture *;\n\n  /// An iterator over a range of lambda captures.\n  using capture_range = llvm::iterator_range<capture_iterator>;\n\n  /// Retrieve this lambda's captures.\n  capture_range captures() const;\n\n  /// Retrieve an iterator pointing to the first lambda capture.\n  capture_iterator capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the\n  /// sequence of lambda captures.\n  capture_iterator capture_end() const;\n\n  /// Determine the number of captures in this lambda.\n  unsigned capture_size() const { return LambdaExprBits.NumCaptures; }\n\n  /// Retrieve this lambda's explicit captures.\n  capture_range explicit_captures() const;\n\n  /// Retrieve an iterator pointing to the first explicit\n  /// lambda capture.\n  capture_iterator explicit_capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// explicit lambda captures.\n  capture_iterator explicit_capture_end() const;\n\n  /// Retrieve this lambda's implicit captures.\n  capture_range implicit_captures() const;\n\n  /// Retrieve an iterator pointing to the first implicit\n  /// lambda capture.\n  capture_iterator implicit_capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// implicit lambda captures.\n  capture_iterator implicit_capture_end() const;\n\n  /// Iterator that walks over the capture initialization\n  /// arguments.\n  using capture_init_iterator = Expr **;\n\n  /// Const iterator that walks over the capture initialization\n  /// arguments.\n  /// FIXME: This interface is prone to being used incorrectly.\n  using const_capture_init_iterator = Expr *const *;\n\n  /// Retrieve the initialization expressions for this lambda's captures.\n  llvm::iterator_range<capture_init_iterator> capture_inits() {\n    return llvm::make_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the initialization expressions for this lambda's captures.\n  llvm::iterator_range<const_capture_init_iterator> capture_inits() const {\n    return llvm::make_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the first initialization argument for this\n  /// lambda expression (which initializes the first capture field).\n  capture_init_iterator capture_init_begin() {\n    return reinterpret_cast<Expr **>(getStoredStmts());\n  }\n\n  /// Retrieve the first initialization argument for this\n  /// lambda expression (which initializes the first capture field).\n  const_capture_init_iterator capture_init_begin() const {\n    return reinterpret_cast<Expr *const *>(getStoredStmts());\n  }\n\n  /// Retrieve the iterator pointing one past the last\n  /// initialization argument for this lambda expression.\n  capture_init_iterator capture_init_end() {\n    return capture_init_begin() + capture_size();\n  }\n\n  /// Retrieve the iterator pointing one past the last\n  /// initialization argument for this lambda expression.\n  const_capture_init_iterator capture_init_end() const {\n    return capture_init_begin() + capture_size();\n  }\n\n  /// Retrieve the source range covering the lambda introducer,\n  /// which contains the explicit capture list surrounded by square\n  /// brackets ([...]).\n  SourceRange getIntroducerRange() const { return IntroducerRange; }\n\n  /// Retrieve the class that corresponds to the lambda.\n  ///\n  /// This is the \"closure type\" (C++1y [expr.prim.lambda]), and stores the\n  /// captures in its fields and provides the various operations permitted\n  /// on a lambda (copying, calling).\n  CXXRecordDecl *getLambdaClass() const;\n\n  /// Retrieve the function call operator associated with this\n  /// lambda expression.\n  CXXMethodDecl *getCallOperator() const;\n\n  /// Retrieve the function template call operator associated with this\n  /// lambda expression.\n  FunctionTemplateDecl *getDependentCallOperator() const;\n\n  /// If this is a generic lambda expression, retrieve the template\n  /// parameter list associated with it, or else return null.\n  TemplateParameterList *getTemplateParameterList() const;\n\n  /// Get the template parameters were explicitly specified (as opposed to being\n  /// invented by use of an auto parameter).\n  ArrayRef<NamedDecl *> getExplicitTemplateParameters() const;\n\n  /// Get the trailing requires clause, if any.\n  Expr *getTrailingRequiresClause() const;\n\n  /// Whether this is a generic lambda.\n  bool isGenericLambda() const { return getTemplateParameterList(); }\n\n  /// Retrieve the body of the lambda. This will be most of the time\n  /// a \\p CompoundStmt, but can also be \\p CoroutineBodyStmt wrapping\n  /// a \\p CompoundStmt. Note that unlike functions, lambda-expressions\n  /// cannot have a function-try-block.\n  Stmt *getBody() const;\n\n  /// Retrieve the \\p CompoundStmt representing the body of the lambda.\n  /// This is a convenience function for callers who do not need\n  /// to handle node(s) which may wrap a \\p CompoundStmt.\n  const CompoundStmt *getCompoundStmtBody() const;\n  CompoundStmt *getCompoundStmtBody() {\n    const auto *ConstThis = this;\n    return const_cast<CompoundStmt *>(ConstThis->getCompoundStmtBody());\n  }\n\n  /// Determine whether the lambda is mutable, meaning that any\n  /// captures values can be modified.\n  bool isMutable() const;\n\n  /// Determine whether this lambda has an explicit parameter\n  /// list vs. an implicit (empty) parameter list.\n  bool hasExplicitParameters() const { return LambdaExprBits.ExplicitParams; }\n\n  /// Whether this lambda had its result type explicitly specified.\n  bool hasExplicitResultType() const {\n    return LambdaExprBits.ExplicitResultType;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == LambdaExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return IntroducerRange.getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return ClosingBrace; }\n\n  /// Includes the captures and the body of the lambda.\n  child_range children();\n  const_child_range children() const;\n};\n\n/// An expression \"T()\" which creates a value-initialized rvalue of type\n/// T, which is a non-class type.  See (C++98 [5.2.3p2]).\nclass CXXScalarValueInitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  TypeSourceInfo *TypeInfo;\n\npublic:\n  /// Create an explicitly-written scalar-value initialization\n  /// expression.\n  CXXScalarValueInitExpr(QualType Type, TypeSourceInfo *TypeInfo,\n                         SourceLocation RParenLoc)\n      : Expr(CXXScalarValueInitExprClass, Type, VK_PRValue, OK_Ordinary),\n        TypeInfo(TypeInfo) {\n    CXXScalarValueInitExprBits.RParenLoc = RParenLoc;\n    setDependence(computeDependence(this));\n  }\n\n  explicit CXXScalarValueInitExpr(EmptyShell Shell)\n      : Expr(CXXScalarValueInitExprClass, Shell) {}\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TypeInfo;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return CXXScalarValueInitExprBits.RParenLoc;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXScalarValueInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a new-expression for memory allocation and constructor\n/// calls, e.g: \"new CXXNewExpr(foo)\".\nclass CXXNewExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXNewExpr, Stmt *, SourceRange> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Points to the allocation function used.\n  FunctionDecl *OperatorNew;\n\n  /// Points to the deallocation function used in case of error. May be null.\n  FunctionDecl *OperatorDelete;\n\n  /// The allocated type-source information, as written in the source.\n  TypeSourceInfo *AllocatedTypeInfo;\n\n  /// Range of the entire new expression.\n  SourceRange Range;\n\n  /// Source-range of a paren-delimited initializer.\n  SourceRange DirectInitRange;\n\n  // CXXNewExpr is followed by several optional trailing objects.\n  // They are in order:\n  //\n  // * An optional \"Stmt *\" for the array size expression.\n  //    Present if and ony if isArray().\n  //\n  // * An optional \"Stmt *\" for the init expression.\n  //    Present if and only if hasInitializer().\n  //\n  // * An array of getNumPlacementArgs() \"Stmt *\" for the placement new\n  //   arguments, if any.\n  //\n  // * An optional SourceRange for the range covering the parenthesized type-id\n  //    if the allocated type was expressed as a parenthesized type-id.\n  //    Present if and only if isParenTypeId().\n  unsigned arraySizeOffset() const { return 0; }\n  unsigned initExprOffset() const { return arraySizeOffset() + isArray(); }\n  unsigned placementNewArgsOffset() const {\n    return initExprOffset() + hasInitializer();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return isArray() + hasInitializer() + getNumPlacementArgs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceRange>) const {\n    return isParenTypeId();\n  }\n\npublic:\n  enum InitializationStyle {\n    /// New-expression has no initializer as written.\n    NoInit,\n\n    /// New-expression has a C++98 paren-delimited initializer.\n    CallInit,\n\n    /// New-expression has a C++11 list-initializer.\n    ListInit\n  };\n\nprivate:\n  /// Build a c++ new expression.\n  CXXNewExpr(bool IsGlobalNew, FunctionDecl *OperatorNew,\n             FunctionDecl *OperatorDelete, bool ShouldPassAlignment,\n             bool UsualArrayDeleteWantsSize, ArrayRef<Expr *> PlacementArgs,\n             SourceRange TypeIdParens, std::optional<Expr *> ArraySize,\n             InitializationStyle InitializationStyle, Expr *Initializer,\n             QualType Ty, TypeSourceInfo *AllocatedTypeInfo, SourceRange Range,\n             SourceRange DirectInitRange);\n\n  /// Build an empty c++ new expression.\n  CXXNewExpr(EmptyShell Empty, bool IsArray, unsigned NumPlacementArgs,\n             bool IsParenTypeId);\n\npublic:\n  /// Create a c++ new expression.\n  static CXXNewExpr *\n  Create(const ASTContext &Ctx, bool IsGlobalNew, FunctionDecl *OperatorNew,\n         FunctionDecl *OperatorDelete, bool ShouldPassAlignment,\n         bool UsualArrayDeleteWantsSize, ArrayRef<Expr *> PlacementArgs,\n         SourceRange TypeIdParens, std::optional<Expr *> ArraySize,\n         InitializationStyle InitializationStyle, Expr *Initializer,\n         QualType Ty, TypeSourceInfo *AllocatedTypeInfo, SourceRange Range,\n         SourceRange DirectInitRange);\n\n  /// Create an empty c++ new expression.\n  static CXXNewExpr *CreateEmpty(const ASTContext &Ctx, bool IsArray,\n                                 bool HasInit, unsigned NumPlacementArgs,\n                                 bool IsParenTypeId);\n\n  QualType getAllocatedType() const {\n    return getType()->castAs<PointerType>()->getPointeeType();\n  }\n\n  TypeSourceInfo *getAllocatedTypeSourceInfo() const {\n    return AllocatedTypeInfo;\n  }\n\n  /// True if the allocation result needs to be null-checked.\n  ///\n  /// C++11 [expr.new]p13:\n  ///   If the allocation function returns null, initialization shall\n  ///   not be done, the deallocation function shall not be called,\n  ///   and the value of the new-expression shall be null.\n  ///\n  /// C++ DR1748:\n  ///   If the allocation function is a reserved placement allocation\n  ///   function that returns null, the behavior is undefined.\n  ///\n  /// An allocation function is not allowed to return null unless it\n  /// has a non-throwing exception-specification.  The '03 rule is\n  /// identical except that the definition of a non-throwing\n  /// exception specification is just \"is it throw()?\".\n  bool shouldNullCheckAllocation() const;\n\n  FunctionDecl *getOperatorNew() const { return OperatorNew; }\n  void setOperatorNew(FunctionDecl *D) { OperatorNew = D; }\n  FunctionDecl *getOperatorDelete() const { return OperatorDelete; }\n  void setOperatorDelete(FunctionDecl *D) { OperatorDelete = D; }\n\n  bool isArray() const { return CXXNewExprBits.IsArray; }\n\n  /// This might return std::nullopt even if isArray() returns true,\n  /// since there might not be an array size expression.\n  /// If the result is not std::nullopt, it will never wrap a nullptr.\n  std::optional<Expr *> getArraySize() {\n    if (!isArray())\n      return std::nullopt;\n\n    if (auto *Result =\n            cast_or_null<Expr>(getTrailingObjects<Stmt *>()[arraySizeOffset()]))\n      return Result;\n\n    return std::nullopt;\n  }\n\n  /// This might return std::nullopt even if isArray() returns true,\n  /// since there might not be an array size expression.\n  /// If the result is not std::nullopt, it will never wrap a nullptr.\n  std::optional<const Expr *> getArraySize() const {\n    if (!isArray())\n      return std::nullopt;\n\n    if (auto *Result =\n            cast_or_null<Expr>(getTrailingObjects<Stmt *>()[arraySizeOffset()]))\n      return Result;\n\n    return std::nullopt;\n  }\n\n  unsigned getNumPlacementArgs() const {\n    return CXXNewExprBits.NumPlacementArgs;\n  }\n\n  Expr **getPlacementArgs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>() +\n                                     placementNewArgsOffset());\n  }\n\n  Expr *getPlacementArg(unsigned I) {\n    assert((I < getNumPlacementArgs()) && \"Index out of range!\");\n    return getPlacementArgs()[I];\n  }\n  const Expr *getPlacementArg(unsigned I) const {\n    return const_cast<CXXNewExpr *>(this)->getPlacementArg(I);\n  }\n\n  bool isParenTypeId() const { return CXXNewExprBits.IsParenTypeId; }\n  SourceRange getTypeIdParens() const {\n    return isParenTypeId() ? getTrailingObjects<SourceRange>()[0]\n                           : SourceRange();\n  }\n\n  bool isGlobalNew() const { return CXXNewExprBits.IsGlobalNew; }\n\n  /// Whether this new-expression has any initializer at all.\n  bool hasInitializer() const {\n    return CXXNewExprBits.StoredInitializationStyle > 0;\n  }\n\n  /// The kind of initializer this new-expression has.\n  InitializationStyle getInitializationStyle() const {\n    if (CXXNewExprBits.StoredInitializationStyle == 0)\n      return NoInit;\n    return static_cast<InitializationStyle>(\n        CXXNewExprBits.StoredInitializationStyle - 1);\n  }\n\n  /// The initializer of this new-expression.\n  Expr *getInitializer() {\n    return hasInitializer()\n               ? cast<Expr>(getTrailingObjects<Stmt *>()[initExprOffset()])\n               : nullptr;\n  }\n  const Expr *getInitializer() const {\n    return hasInitializer()\n               ? cast<Expr>(getTrailingObjects<Stmt *>()[initExprOffset()])\n               : nullptr;\n  }\n\n  /// Returns the CXXConstructExpr from this new-expression, or null.\n  const CXXConstructExpr *getConstructExpr() const {\n    return dyn_cast_or_null<CXXConstructExpr>(getInitializer());\n  }\n\n  /// Indicates whether the required alignment should be implicitly passed to\n  /// the allocation function.\n  bool passAlignment() const { return CXXNewExprBits.ShouldPassAlignment; }\n\n  /// Answers whether the usual array deallocation function for the\n  /// allocated type expects the size of the allocation as a\n  /// parameter.\n  bool doesUsualArrayDeleteWantSize() const {\n    return CXXNewExprBits.UsualArrayDeleteWantsSize;\n  }\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n\n  llvm::iterator_range<arg_iterator> placement_arguments() {\n    return llvm::make_range(placement_arg_begin(), placement_arg_end());\n  }\n\n  llvm::iterator_range<const_arg_iterator> placement_arguments() const {\n    return llvm::make_range(placement_arg_begin(), placement_arg_end());\n  }\n\n  arg_iterator placement_arg_begin() {\n    return getTrailingObjects<Stmt *>() + placementNewArgsOffset();\n  }\n  arg_iterator placement_arg_end() {\n    return placement_arg_begin() + getNumPlacementArgs();\n  }\n  const_arg_iterator placement_arg_begin() const {\n    return getTrailingObjects<Stmt *>() + placementNewArgsOffset();\n  }\n  const_arg_iterator placement_arg_end() const {\n    return placement_arg_begin() + getNumPlacementArgs();\n  }\n\n  using raw_arg_iterator = Stmt **;\n\n  raw_arg_iterator raw_arg_begin() { return getTrailingObjects<Stmt *>(); }\n  raw_arg_iterator raw_arg_end() {\n    return raw_arg_begin() + numTrailingObjects(OverloadToken<Stmt *>());\n  }\n  const_arg_iterator raw_arg_begin() const {\n    return getTrailingObjects<Stmt *>();\n  }\n  const_arg_iterator raw_arg_end() const {\n    return raw_arg_begin() + numTrailingObjects(OverloadToken<Stmt *>());\n  }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n\n  SourceRange getDirectInitRange() const { return DirectInitRange; }\n  SourceRange getSourceRange() const { return Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNewExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(raw_arg_begin(), raw_arg_end()); }\n\n  const_child_range children() const {\n    return const_child_range(const_cast<CXXNewExpr *>(this)->children());\n  }\n};\n\n/// Represents a \\c delete expression for memory deallocation and\n/// destructor calls, e.g. \"delete[] pArray\".\nclass CXXDeleteExpr : public Expr {\n  friend class ASTStmtReader;\n\n  /// Points to the operator delete overload that is used. Could be a member.\n  FunctionDecl *OperatorDelete = nullptr;\n\n  /// The pointer expression to be deleted.\n  Stmt *Argument = nullptr;\n\npublic:\n  CXXDeleteExpr(QualType Ty, bool GlobalDelete, bool ArrayForm,\n                bool ArrayFormAsWritten, bool UsualArrayDeleteWantsSize,\n                FunctionDecl *OperatorDelete, Expr *Arg, SourceLocation Loc)\n      : Expr(CXXDeleteExprClass, Ty, VK_PRValue, OK_Ordinary),\n        OperatorDelete(OperatorDelete), Argument(Arg) {\n    CXXDeleteExprBits.GlobalDelete = GlobalDelete;\n    CXXDeleteExprBits.ArrayForm = ArrayForm;\n    CXXDeleteExprBits.ArrayFormAsWritten = ArrayFormAsWritten;\n    CXXDeleteExprBits.UsualArrayDeleteWantsSize = UsualArrayDeleteWantsSize;\n    CXXDeleteExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  explicit CXXDeleteExpr(EmptyShell Shell) : Expr(CXXDeleteExprClass, Shell) {}\n\n  bool isGlobalDelete() const { return CXXDeleteExprBits.GlobalDelete; }\n  bool isArrayForm() const { return CXXDeleteExprBits.ArrayForm; }\n  bool isArrayFormAsWritten() const {\n    return CXXDeleteExprBits.ArrayFormAsWritten;\n  }\n\n  /// Answers whether the usual array deallocation function for the\n  /// allocated type expects the size of the allocation as a\n  /// parameter.  This can be true even if the actual deallocation\n  /// function that we're using doesn't want a size.\n  bool doesUsualArrayDeleteWantSize() const {\n    return CXXDeleteExprBits.UsualArrayDeleteWantsSize;\n  }\n\n  FunctionDecl *getOperatorDelete() const { return OperatorDelete; }\n\n  Expr *getArgument() { return cast<Expr>(Argument); }\n  const Expr *getArgument() const { return cast<Expr>(Argument); }\n\n  /// Retrieve the type being destroyed.\n  ///\n  /// If the type being destroyed is a dependent type which may or may not\n  /// be a pointer, return an invalid type.\n  QualType getDestroyedType() const;\n\n  SourceLocation getBeginLoc() const { return CXXDeleteExprBits.Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Argument->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDeleteExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Argument, &Argument + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Argument, &Argument + 1);\n  }\n};\n\n/// Stores the type being destroyed by a pseudo-destructor expression.\nclass PseudoDestructorTypeStorage {\n  /// Either the type source information or the name of the type, if\n  /// it couldn't be resolved due to type-dependence.\n  llvm::PointerUnion<TypeSourceInfo *, IdentifierInfo *> Type;\n\n  /// The starting source location of the pseudo-destructor type.\n  SourceLocation Location;\n\npublic:\n  PseudoDestructorTypeStorage() = default;\n\n  PseudoDestructorTypeStorage(IdentifierInfo *II, SourceLocation Loc)\n      : Type(II), Location(Loc) {}\n\n  PseudoDestructorTypeStorage(TypeSourceInfo *Info);\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Type.dyn_cast<TypeSourceInfo *>();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    return Type.dyn_cast<IdentifierInfo *>();\n  }\n\n  SourceLocation getLocation() const { return Location; }\n};\n\n/// Represents a C++ pseudo-destructor (C++ [expr.pseudo]).\n///\n/// A pseudo-destructor is an expression that looks like a member access to a\n/// destructor of a scalar type, except that scalar types don't have\n/// destructors. For example:\n///\n/// \\code\n/// typedef int T;\n/// void f(int *p) {\n///   p->T::~T();\n/// }\n/// \\endcode\n///\n/// Pseudo-destructors typically occur when instantiating templates such as:\n///\n/// \\code\n/// template<typename T>\n/// void destroy(T* ptr) {\n///   ptr->T::~T();\n/// }\n/// \\endcode\n///\n/// for scalar types. A pseudo-destructor expression has no run-time semantics\n/// beyond evaluating the base expression.\nclass CXXPseudoDestructorExpr : public Expr {\n  friend class ASTStmtReader;\n\n  /// The base expression (that is being destroyed).\n  Stmt *Base = nullptr;\n\n  /// Whether the operator was an arrow ('->'); otherwise, it was a\n  /// period ('.').\n  bool IsArrow : 1;\n\n  /// The location of the '.' or '->' operator.\n  SourceLocation OperatorLoc;\n\n  /// The nested-name-specifier that follows the operator, if present.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The type that precedes the '::' in a qualified pseudo-destructor\n  /// expression.\n  TypeSourceInfo *ScopeType = nullptr;\n\n  /// The location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation ColonColonLoc;\n\n  /// The location of the '~'.\n  SourceLocation TildeLoc;\n\n  /// The type being destroyed, or its name if we were unable to\n  /// resolve the name.\n  PseudoDestructorTypeStorage DestroyedType;\n\npublic:\n  CXXPseudoDestructorExpr(const ASTContext &Context,\n                          Expr *Base, bool isArrow, SourceLocation OperatorLoc,\n                          NestedNameSpecifierLoc QualifierLoc,\n                          TypeSourceInfo *ScopeType,\n                          SourceLocation ColonColonLoc,\n                          SourceLocation TildeLoc,\n                          PseudoDestructorTypeStorage DestroyedType);\n\n  explicit CXXPseudoDestructorExpr(EmptyShell Shell)\n      : Expr(CXXPseudoDestructorExprClass, Shell), IsArrow(false) {}\n\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return QualifierLoc.hasQualifier(); }\n\n  /// Retrieves the nested-name-specifier that qualifies the type name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// null.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Determine whether this pseudo-destructor expression was written\n  /// using an '->' (otherwise, it used a '.').\n  bool isArrow() const { return IsArrow; }\n\n  /// Retrieve the location of the '.' or '->' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the scope type in a qualified pseudo-destructor\n  /// expression.\n  ///\n  /// Pseudo-destructor expressions can have extra qualification within them\n  /// that is not part of the nested-name-specifier, e.g., \\c p->T::~T().\n  /// Here, if the object type of the expression is (or may be) a scalar type,\n  /// \\p T may also be a scalar type and, therefore, cannot be part of a\n  /// nested-name-specifier. It is stored as the \"scope type\" of the pseudo-\n  /// destructor expression.\n  TypeSourceInfo *getScopeTypeInfo() const { return ScopeType; }\n\n  /// Retrieve the location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation getColonColonLoc() const { return ColonColonLoc; }\n\n  /// Retrieve the location of the '~'.\n  SourceLocation getTildeLoc() const { return TildeLoc; }\n\n  /// Retrieve the source location information for the type\n  /// being destroyed.\n  ///\n  /// This type-source information is available for non-dependent\n  /// pseudo-destructor expressions and some dependent pseudo-destructor\n  /// expressions. Returns null if we only have the identifier for a\n  /// dependent pseudo-destructor expression.\n  TypeSourceInfo *getDestroyedTypeInfo() const {\n    return DestroyedType.getTypeSourceInfo();\n  }\n\n  /// In a dependent pseudo-destructor expression for which we do not\n  /// have full type information on the destroyed type, provides the name\n  /// of the destroyed type.\n  IdentifierInfo *getDestroyedTypeIdentifier() const {\n    return DestroyedType.getIdentifier();\n  }\n\n  /// Retrieve the type being destroyed.\n  QualType getDestroyedType() const;\n\n  /// Retrieve the starting location of the type being destroyed.\n  SourceLocation getDestroyedTypeLoc() const {\n    return DestroyedType.getLocation();\n  }\n\n  /// Set the name of destroyed type for a dependent pseudo-destructor\n  /// expression.\n  void setDestroyedType(IdentifierInfo *II, SourceLocation Loc) {\n    DestroyedType = PseudoDestructorTypeStorage(II, Loc);\n  }\n\n  /// Set the destroyed type.\n  void setDestroyedType(TypeSourceInfo *Info) {\n    DestroyedType = PseudoDestructorTypeStorage(Info);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Base->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXPseudoDestructorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// A type trait used in the implementation of various C++11 and\n/// Library TR1 trait templates.\n///\n/// \\code\n///   __is_pod(int) == true\n///   __is_enum(std::string) == false\n///   __is_trivially_constructible(vector<int>, int*, int*)\n/// \\endcode\nclass TypeTraitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<TypeTraitExpr, TypeSourceInfo *> {\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  ///  The location of the closing parenthesis.\n  SourceLocation RParenLoc;\n\n  // Note: The TypeSourceInfos for the arguments are allocated after the\n  // TypeTraitExpr.\n\n  TypeTraitExpr(QualType T, SourceLocation Loc, TypeTrait Kind,\n                ArrayRef<TypeSourceInfo *> Args,\n                SourceLocation RParenLoc,\n                bool Value);\n\n  TypeTraitExpr(EmptyShell Empty) : Expr(TypeTraitExprClass, Empty) {}\n\n  size_t numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumArgs();\n  }\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Create a new type trait expression.\n  static TypeTraitExpr *Create(const ASTContext &C, QualType T,\n                               SourceLocation Loc, TypeTrait Kind,\n                               ArrayRef<TypeSourceInfo *> Args,\n                               SourceLocation RParenLoc,\n                               bool Value);\n\n  static TypeTraitExpr *CreateDeserialized(const ASTContext &C,\n                                           unsigned NumArgs);\n\n  /// Determine which type trait this expression uses.\n  TypeTrait getTrait() const {\n    return static_cast<TypeTrait>(TypeTraitExprBits.Kind);\n  }\n\n  bool getValue() const {\n    assert(!isValueDependent());\n    return TypeTraitExprBits.Value;\n  }\n\n  /// Determine the number of arguments to this type trait.\n  unsigned getNumArgs() const { return TypeTraitExprBits.NumArgs; }\n\n  /// Retrieve the Ith argument.\n  TypeSourceInfo *getArg(unsigned I) const {\n    assert(I < getNumArgs() && \"Argument out-of-range\");\n    return getArgs()[I];\n  }\n\n  /// Retrieve the argument types.\n  ArrayRef<TypeSourceInfo *> getArgs() const {\n    return llvm::ArrayRef(getTrailingObjects<TypeSourceInfo *>(), getNumArgs());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// An Embarcadero array type trait, as used in the implementation of\n/// __array_rank and __array_extent.\n///\n/// Example:\n/// \\code\n///   __array_rank(int[10][20]) == 2\n///   __array_extent(int, 1)    == 20\n/// \\endcode\nclass ArrayTypeTraitExpr : public Expr {\n  /// The trait. An ArrayTypeTrait enum in MSVC compat unsigned.\n  unsigned ATT : 2;\n\n  /// The value of the type trait. Unspecified if dependent.\n  uint64_t Value = 0;\n\n  /// The array dimension being queried, or -1 if not used.\n  Expr *Dimension;\n\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  /// The location of the closing paren.\n  SourceLocation RParen;\n\n  /// The type being queried.\n  TypeSourceInfo *QueriedType = nullptr;\n\npublic:\n  friend class ASTStmtReader;\n\n  ArrayTypeTraitExpr(SourceLocation loc, ArrayTypeTrait att,\n                     TypeSourceInfo *queried, uint64_t value, Expr *dimension,\n                     SourceLocation rparen, QualType ty)\n      : Expr(ArrayTypeTraitExprClass, ty, VK_PRValue, OK_Ordinary), ATT(att),\n        Value(value), Dimension(dimension), Loc(loc), RParen(rparen),\n        QueriedType(queried) {\n    assert(att <= ATT_Last && \"invalid enum value!\");\n    assert(static_cast<unsigned>(att) == ATT && \"ATT overflow!\");\n    setDependence(computeDependence(this));\n  }\n\n  explicit ArrayTypeTraitExpr(EmptyShell Empty)\n      : Expr(ArrayTypeTraitExprClass, Empty), ATT(0) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParen; }\n\n  ArrayTypeTrait getTrait() const { return static_cast<ArrayTypeTrait>(ATT); }\n\n  QualType getQueriedType() const { return QueriedType->getType(); }\n\n  TypeSourceInfo *getQueriedTypeSourceInfo() const { return QueriedType; }\n\n  uint64_t getValue() const { assert(!isTypeDependent()); return Value; }\n\n  Expr *getDimensionExpression() const { return Dimension; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArrayTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// An expression trait intrinsic.\n///\n/// Example:\n/// \\code\n///   __is_lvalue_expr(std::cout) == true\n///   __is_lvalue_expr(1) == false\n/// \\endcode\nclass ExpressionTraitExpr : public Expr {\n  /// The trait. A ExpressionTrait enum in MSVC compatible unsigned.\n  unsigned ET : 31;\n\n  /// The value of the type trait. Unspecified if dependent.\n  unsigned Value : 1;\n\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  /// The location of the closing paren.\n  SourceLocation RParen;\n\n  /// The expression being queried.\n  Expr* QueriedExpression = nullptr;\n\npublic:\n  friend class ASTStmtReader;\n\n  ExpressionTraitExpr(SourceLocation loc, ExpressionTrait et, Expr *queried,\n                      bool value, SourceLocation rparen, QualType resultType)\n      : Expr(ExpressionTraitExprClass, resultType, VK_PRValue, OK_Ordinary),\n        ET(et), Value(value), Loc(loc), RParen(rparen),\n        QueriedExpression(queried) {\n    assert(et <= ET_Last && \"invalid enum value!\");\n    assert(static_cast<unsigned>(et) == ET && \"ET overflow!\");\n    setDependence(computeDependence(this));\n  }\n\n  explicit ExpressionTraitExpr(EmptyShell Empty)\n      : Expr(ExpressionTraitExprClass, Empty), ET(0), Value(false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParen; }\n\n  ExpressionTrait getTrait() const { return static_cast<ExpressionTrait>(ET); }\n\n  Expr *getQueriedExpression() const { return QueriedExpression; }\n\n  bool getValue() const { return Value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExpressionTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// A reference to an overloaded function set, either an\n/// \\c UnresolvedLookupExpr or an \\c UnresolvedMemberExpr.\nclass OverloadExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// The common name of these declarations.\n  DeclarationNameInfo NameInfo;\n\n  /// The nested-name-specifier that qualifies the name, if any.\n  NestedNameSpecifierLoc QualifierLoc;\n\nprotected:\n  OverloadExpr(StmtClass SC, const ASTContext &Context,\n               NestedNameSpecifierLoc QualifierLoc,\n               SourceLocation TemplateKWLoc,\n               const DeclarationNameInfo &NameInfo,\n               const TemplateArgumentListInfo *TemplateArgs,\n               UnresolvedSetIterator Begin, UnresolvedSetIterator End,\n               bool KnownDependent, bool KnownInstantiationDependent,\n               bool KnownContainsUnexpandedParameterPack);\n\n  OverloadExpr(StmtClass SC, EmptyShell Empty, unsigned NumResults,\n               bool HasTemplateKWAndArgsInfo);\n\n  /// Return the results. Defined after UnresolvedMemberExpr.\n  inline DeclAccessPair *getTrailingResults();\n  const DeclAccessPair *getTrailingResults() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingResults();\n  }\n\n  /// Return the optional template keyword and arguments info.\n  /// Defined after UnresolvedMemberExpr.\n  inline ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo();\n  const ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo() const {\n    return const_cast<OverloadExpr *>(this)\n        ->getTrailingASTTemplateKWAndArgsInfo();\n  }\n\n  /// Return the optional template arguments. Defined after\n  /// UnresolvedMemberExpr.\n  inline TemplateArgumentLoc *getTrailingTemplateArgumentLoc();\n  const TemplateArgumentLoc *getTrailingTemplateArgumentLoc() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return OverloadExprBits.HasTemplateKWAndArgsInfo;\n  }\n\npublic:\n  struct FindResult {\n    OverloadExpr *Expression;\n    bool IsAddressOfOperand;\n    bool HasFormOfMemberPointer;\n  };\n\n  /// Finds the overloaded expression in the given expression \\p E of\n  /// OverloadTy.\n  ///\n  /// \\return the expression (which must be there) and true if it has\n  /// the particular form of a member pointer expression\n  static FindResult find(Expr *E) {\n    assert(E->getType()->isSpecificBuiltinType(BuiltinType::Overload));\n\n    FindResult Result;\n\n    E = E->IgnoreParens();\n    if (isa<UnaryOperator>(E)) {\n      assert(cast<UnaryOperator>(E)->getOpcode() == UO_AddrOf);\n      E = cast<UnaryOperator>(E)->getSubExpr();\n      auto *Ovl = cast<OverloadExpr>(E->IgnoreParens());\n\n      Result.HasFormOfMemberPointer = (E == Ovl && Ovl->getQualifier());\n      Result.IsAddressOfOperand = true;\n      Result.Expression = Ovl;\n    } else {\n      Result.HasFormOfMemberPointer = false;\n      Result.IsAddressOfOperand = false;\n      Result.Expression = cast<OverloadExpr>(E);\n    }\n\n    return Result;\n  }\n\n  /// Gets the naming class of this lookup, if any.\n  /// Defined after UnresolvedMemberExpr.\n  inline CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<OverloadExpr *>(this)->getNamingClass();\n  }\n\n  using decls_iterator = UnresolvedSetImpl::iterator;\n\n  decls_iterator decls_begin() const {\n    return UnresolvedSetIterator(getTrailingResults());\n  }\n  decls_iterator decls_end() const {\n    return UnresolvedSetIterator(getTrailingResults() + getNumDecls());\n  }\n  llvm::iterator_range<decls_iterator> decls() const {\n    return llvm::make_range(decls_begin(), decls_end());\n  }\n\n  /// Gets the number of declarations in the unresolved set.\n  unsigned getNumDecls() const { return OverloadExprBits.NumResults; }\n\n  /// Gets the full name info.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the name looked up.\n  DeclarationName getName() const { return NameInfo.getName(); }\n\n  /// Gets the location of the name.\n  SourceLocation getNameLoc() const { return NameInfo.getLoc(); }\n\n  /// Fetches the nested-name qualifier, if one was given.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Fetches the nested-name qualifier with source-location\n  /// information, if one was given.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->RAngleLoc;\n  }\n\n  /// Determines whether the name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this expression had explicit template arguments.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  TemplateArgumentLoc const *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingASTTemplateKWAndArgsInfo()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Copies the template arguments into the given structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingASTTemplateKWAndArgsInfo()->copyInto(getTemplateArgs(), List);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedLookupExprClass ||\n           T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n};\n\n/// A reference to a name which we were able to look up during\n/// parsing but could not resolve to a specific declaration.\n///\n/// This arises in several ways:\n///   * we might be waiting for argument-dependent lookup;\n///   * the name might resolve to an overloaded function;\n/// and eventually:\n///   * the lookup might have included a function template.\n///\n/// These never include UnresolvedUsingValueDecls, which are always class\n/// members and therefore appear only in UnresolvedMemberLookupExprs.\nclass UnresolvedLookupExpr final\n    : public OverloadExpr,\n      private llvm::TrailingObjects<UnresolvedLookupExpr, DeclAccessPair,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class OverloadExpr;\n  friend TrailingObjects;\n\n  /// The naming class (C++ [class.access.base]p5) of the lookup, if\n  /// any.  This can generally be recalculated from the context chain,\n  /// but that can be fairly expensive for unqualified lookups.\n  CXXRecordDecl *NamingClass;\n\n  // UnresolvedLookupExpr is followed by several trailing objects.\n  // They are in order:\n  //\n  // * An array of getNumResults() DeclAccessPair for the results. These are\n  //   undesugared, which is to say, they may include UsingShadowDecls.\n  //   Access is relative to the naming class.\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing\n  //   location information for the explicitly specified template arguments.\n\n  UnresolvedLookupExpr(const ASTContext &Context, CXXRecordDecl *NamingClass,\n                       NestedNameSpecifierLoc QualifierLoc,\n                       SourceLocation TemplateKWLoc,\n                       const DeclarationNameInfo &NameInfo, bool RequiresADL,\n                       bool Overloaded,\n                       const TemplateArgumentListInfo *TemplateArgs,\n                       UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  UnresolvedLookupExpr(EmptyShell Empty, unsigned NumResults,\n                       bool HasTemplateKWAndArgsInfo);\n\n  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {\n    return getNumDecls();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\npublic:\n  static UnresolvedLookupExpr *\n  Create(const ASTContext &Context, CXXRecordDecl *NamingClass,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, bool RequiresADL, bool Overloaded,\n         UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  static UnresolvedLookupExpr *\n  Create(const ASTContext &Context, CXXRecordDecl *NamingClass,\n         NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,\n         const DeclarationNameInfo &NameInfo, bool RequiresADL,\n         const TemplateArgumentListInfo *Args, UnresolvedSetIterator Begin,\n         UnresolvedSetIterator End);\n\n  static UnresolvedLookupExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumResults,\n                                           bool HasTemplateKWAndArgsInfo,\n                                           unsigned NumTemplateArgs);\n\n  /// True if this declaration should be extended by\n  /// argument-dependent lookup.\n  bool requiresADL() const { return UnresolvedLookupExprBits.RequiresADL; }\n\n  /// True if this lookup is overloaded.\n  bool isOverloaded() const { return UnresolvedLookupExprBits.Overloaded; }\n\n  /// Gets the 'naming class' (in the sense of C++0x\n  /// [class.access.base]p5) of the lookup.  This is the scope\n  /// that was looked in to find these results.\n  CXXRecordDecl *getNamingClass() { return NamingClass; }\n  const CXXRecordDecl *getNamingClass() const { return NamingClass; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (NestedNameSpecifierLoc l = getQualifierLoc())\n      return l.getBeginLoc();\n    return getNameInfo().getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getNameInfo().getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedLookupExprClass;\n  }\n};\n\n/// A qualified reference to a name whose declaration cannot\n/// yet be resolved.\n///\n/// DependentScopeDeclRefExpr is similar to DeclRefExpr in that\n/// it expresses a reference to a declaration such as\n/// X<T>::value. The difference, however, is that an\n/// DependentScopeDeclRefExpr node is used only within C++ templates when\n/// the qualification (e.g., X<T>::) refers to a dependent type. In\n/// this case, X<T>::value cannot resolve to a declaration because the\n/// declaration will differ from one instantiation of X<T> to the\n/// next. Therefore, DependentScopeDeclRefExpr keeps track of the\n/// qualifier (X<T>::) and the name of the entity being referenced\n/// (\"value\"). Such expressions will instantiate to a DeclRefExpr once the\n/// declaration can be found.\nclass DependentScopeDeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DependentScopeDeclRefExpr,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The nested-name-specifier that qualifies this unresolved\n  /// declaration name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The name of the entity we will be referencing.\n  DeclarationNameInfo NameInfo;\n\n  DependentScopeDeclRefExpr(QualType Ty, NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc,\n                            const DeclarationNameInfo &NameInfo,\n                            const TemplateArgumentListInfo *Args);\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DependentScopeDeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\npublic:\n  static DependentScopeDeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, const DeclarationNameInfo &NameInfo,\n         const TemplateArgumentListInfo *TemplateArgs);\n\n  static DependentScopeDeclRefExpr *CreateEmpty(const ASTContext &Context,\n                                                bool HasTemplateKWAndArgsInfo,\n                                                unsigned NumTemplateArgs);\n\n  /// Retrieve the name that this expression refers to.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Retrieve the name that this expression refers to.\n  DeclarationName getDeclName() const { return NameInfo.getName(); }\n\n  /// Retrieve the location of the name within the expression.\n  ///\n  /// For example, in \"X<T>::value\" this is the location of \"value\".\n  SourceLocation getLocation() const { return NameInfo.getLoc(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name, with source location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies this\n  /// declaration.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this lookup had explicit template arguments.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  TemplateArgumentLoc const *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Note: getBeginLoc() is the start of the whole DependentScopeDeclRefExpr,\n  /// and differs from getLocation().getStart().\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return QualifierLoc.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getLocation();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentScopeDeclRefExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents an expression -- generally a full-expression -- that\n/// introduces cleanups to be run at the end of the sub-expression's\n/// evaluation.  The most common source of expression-introduced\n/// cleanups is temporary objects in C++, but several other kinds of\n/// expressions can create cleanups, including basically every\n/// call in ARC that returns an Objective-C pointer.\n///\n/// This expression also tracks whether the sub-expression contains a\n/// potentially-evaluated block literal.  The lifetime of a block\n/// literal is the extent of the enclosing scope.\nclass ExprWithCleanups final\n    : public FullExpr,\n      private llvm::TrailingObjects<\n          ExprWithCleanups,\n          llvm::PointerUnion<BlockDecl *, CompoundLiteralExpr *>> {\npublic:\n  /// The type of objects that are kept in the cleanup.\n  /// It's useful to remember the set of blocks and block-scoped compound\n  /// literals; we could also remember the set of temporaries, but there's\n  /// currently no need.\n  using CleanupObject = llvm::PointerUnion<BlockDecl *, CompoundLiteralExpr *>;\n\nprivate:\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  ExprWithCleanups(EmptyShell, unsigned NumObjects);\n  ExprWithCleanups(Expr *SubExpr, bool CleanupsHaveSideEffects,\n                   ArrayRef<CleanupObject> Objects);\n\npublic:\n  static ExprWithCleanups *Create(const ASTContext &C, EmptyShell empty,\n                                  unsigned numObjects);\n\n  static ExprWithCleanups *Create(const ASTContext &C, Expr *subexpr,\n                                  bool CleanupsHaveSideEffects,\n                                  ArrayRef<CleanupObject> objects);\n\n  ArrayRef<CleanupObject> getObjects() const {\n    return llvm::ArrayRef(getTrailingObjects<CleanupObject>(), getNumObjects());\n  }\n\n  unsigned getNumObjects() const { return ExprWithCleanupsBits.NumObjects; }\n\n  CleanupObject getObject(unsigned i) const {\n    assert(i < getNumObjects() && \"Index out of range\");\n    return getObjects()[i];\n  }\n\n  bool cleanupsHaveSideEffects() const {\n    return ExprWithCleanupsBits.CleanupsHaveSideEffects;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExprWithCleanupsClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n/// Describes an explicit type conversion that uses functional\n/// notion but could not be resolved because one or more arguments are\n/// type-dependent.\n///\n/// The explicit type conversions expressed by\n/// CXXUnresolvedConstructExpr have the form <tt>T(a1, a2, ..., aN)</tt>,\n/// where \\c T is some type and \\c a1, \\c a2, ..., \\c aN are values, and\n/// either \\c T is a dependent type or one or more of the <tt>a</tt>'s is\n/// type-dependent. For example, this would occur in a template such\n/// as:\n///\n/// \\code\n///   template<typename T, typename A1>\n///   inline T make_a(const A1& a1) {\n///     return T(a1);\n///   }\n/// \\endcode\n///\n/// When the returned expression is instantiated, it may resolve to a\n/// constructor call, conversion function call, or some kind of type\n/// conversion.\nclass CXXUnresolvedConstructExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXUnresolvedConstructExpr, Expr *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The type being constructed, and whether the construct expression models\n  /// list initialization or not.\n  llvm::PointerIntPair<TypeSourceInfo *, 1> TypeAndInitForm;\n\n  /// The location of the left parentheses ('(').\n  SourceLocation LParenLoc;\n\n  /// The location of the right parentheses (')').\n  SourceLocation RParenLoc;\n\n  CXXUnresolvedConstructExpr(QualType T, TypeSourceInfo *TSI,\n                             SourceLocation LParenLoc, ArrayRef<Expr *> Args,\n                             SourceLocation RParenLoc, bool IsListInit);\n\n  CXXUnresolvedConstructExpr(EmptyShell Empty, unsigned NumArgs)\n      : Expr(CXXUnresolvedConstructExprClass, Empty) {\n    CXXUnresolvedConstructExprBits.NumArgs = NumArgs;\n  }\n\npublic:\n  static CXXUnresolvedConstructExpr *\n  Create(const ASTContext &Context, QualType T, TypeSourceInfo *TSI,\n         SourceLocation LParenLoc, ArrayRef<Expr *> Args,\n         SourceLocation RParenLoc, bool IsListInit);\n\n  static CXXUnresolvedConstructExpr *CreateEmpty(const ASTContext &Context,\n                                                 unsigned NumArgs);\n\n  /// Retrieve the type that is being constructed, as specified\n  /// in the source code.\n  QualType getTypeAsWritten() const { return getTypeSourceInfo()->getType(); }\n\n  /// Retrieve the type source information for the type being\n  /// constructed.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TypeAndInitForm.getPointer();\n  }\n\n  /// Retrieve the location of the left parentheses ('(') that\n  /// precedes the argument list.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  /// Retrieve the location of the right parentheses (')') that\n  /// follows the argument list.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  /// Determine whether this expression models list-initialization.\n  /// If so, there will be exactly one subexpression, which will be\n  /// an InitListExpr.\n  bool isListInitialization() const { return TypeAndInitForm.getInt(); }\n\n  /// Retrieve the number of arguments.\n  unsigned getNumArgs() const { return CXXUnresolvedConstructExprBits.NumArgs; }\n\n  using arg_iterator = Expr **;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n\n  arg_iterator arg_begin() { return getTrailingObjects<Expr *>(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n\n  using const_arg_iterator = const Expr* const *;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  const_arg_iterator arg_begin() const { return getTrailingObjects<Expr *>(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  Expr *getArg(unsigned I) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  const Expr *getArg(unsigned I) const {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  void setArg(unsigned I, Expr *E) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    arg_begin()[I] = E;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (!RParenLoc.isValid() && getNumArgs() > 0)\n      return getArg(getNumArgs() - 1)->getEndLoc();\n    return RParenLoc;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXUnresolvedConstructExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    auto **begin = reinterpret_cast<Stmt **>(arg_begin());\n    return child_range(begin, begin + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto **begin = reinterpret_cast<Stmt **>(\n        const_cast<CXXUnresolvedConstructExpr *>(this)->arg_begin());\n    return const_child_range(begin, begin + getNumArgs());\n  }\n};\n\n/// Represents a C++ member access expression where the actual\n/// member referenced could not be resolved because the base\n/// expression or the member name was dependent.\n///\n/// Like UnresolvedMemberExprs, these can be either implicit or\n/// explicit accesses.  It is only possible to get one of these with\n/// an implicit access if a qualifier is provided.\nclass CXXDependentScopeMemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXDependentScopeMemberExpr,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc, NamedDecl *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.  Can be null in implicit accesses.\n  Stmt *Base;\n\n  /// The type of the base expression.  Never null, even for\n  /// implicit accesses.\n  QualType BaseType;\n\n  /// The nested-name-specifier that precedes the member name, if any.\n  /// FIXME: This could be in principle store as a trailing object.\n  /// However the performance impact of doing so should be investigated first.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The member to which this member expression refers, which\n  /// can be name, overloaded operator, or destructor.\n  ///\n  /// FIXME: could also be a template-id\n  DeclarationNameInfo MemberNameInfo;\n\n  // CXXDependentScopeMemberExpr is followed by several trailing objects,\n  // some of which optional. They are in order:\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing location\n  //   information for the explicitly specified template arguments.\n  //\n  // * An optional NamedDecl *. In a qualified member access expression such\n  //   as t->Base::f, this member stores the resolves of name lookup in the\n  //   context of the member access expression, to be used at instantiation\n  //   time. Present if and only if hasFirstQualifierFoundInScope().\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  bool hasFirstQualifierFoundInScope() const {\n    return CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return getNumTemplateArgs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFirstQualifierFoundInScope();\n  }\n\n  CXXDependentScopeMemberExpr(const ASTContext &Ctx, Expr *Base,\n                              QualType BaseType, bool IsArrow,\n                              SourceLocation OperatorLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TemplateKWLoc,\n                              NamedDecl *FirstQualifierFoundInScope,\n                              DeclarationNameInfo MemberNameInfo,\n                              const TemplateArgumentListInfo *TemplateArgs);\n\n  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasTemplateKWAndArgsInfo,\n                              bool HasFirstQualifierFoundInScope);\n\npublic:\n  static CXXDependentScopeMemberExpr *\n  Create(const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,\n         SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,\n         DeclarationNameInfo MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs);\n\n  static CXXDependentScopeMemberExpr *\n  CreateEmpty(const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,\n              unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope);\n\n  /// True if this is an implicit access, i.e. one in which the\n  /// member being accessed was not written in the source.  The source\n  /// location of the operator is invalid in this case.\n  bool isImplicitAccess() const {\n    if (!Base)\n      return true;\n    return cast<Expr>(Base)->isImplicitCXXThis();\n  }\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return CXXDependentScopeMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const {\n    return CXXDependentScopeMemberExprBits.OperatorLoc;\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member\n  /// name, with source location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the first part of the nested-name-specifier that was\n  /// found in the scope of the member access expression when the member access\n  /// was initially parsed.\n  ///\n  /// This function only returns a useful result when member access expression\n  /// uses a qualified member name, e.g., \"x.Base::f\". Here, the declaration\n  /// returned by this function describes what was found by unqualified name\n  /// lookup for the identifier \"Base\" within the scope of the member access\n  /// expression itself. At template instantiation time, this information is\n  /// combined with the results of name lookup into the type of the object\n  /// expression itself (the class type of x).\n  NamedDecl *getFirstQualifierFoundInScope() const {\n    if (!hasFirstQualifierFoundInScope())\n      return nullptr;\n    return *getTrailingObjects<NamedDecl *>();\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const {\n    return MemberNameInfo;\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMember() const { return MemberNameInfo.getName(); }\n\n  // Retrieve the location of the name of the member that this\n  // expression refers to.\n  SourceLocation getMemberLoc() const { return MemberNameInfo.getLoc(); }\n\n  /// Retrieve the location of the template keyword preceding the\n  /// member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this member expression actually had a C++\n  /// template argument list explicitly specified, e.g., x.f<int>.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (getQualifier())\n      return getQualifierLoc().getBeginLoc();\n    return MemberNameInfo.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return MemberNameInfo.getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDependentScopeMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// Represents a C++ member access expression for which lookup\n/// produced a set of overloaded functions.\n///\n/// The member access may be explicit or implicit:\n/// \\code\n///    struct A {\n///      int a, b;\n///      int explicitAccess() { return this->a + this->A::b; }\n///      int implicitAccess() { return a + A::b; }\n///    };\n/// \\endcode\n///\n/// In the final AST, an explicit access always becomes a MemberExpr.\n/// An implicit access may become either a MemberExpr or a\n/// DeclRefExpr, depending on whether the member is static.\nclass UnresolvedMemberExpr final\n    : public OverloadExpr,\n      private llvm::TrailingObjects<UnresolvedMemberExpr, DeclAccessPair,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class OverloadExpr;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.\n  ///\n  /// This can be null if this is an 'unbased' member expression.\n  Stmt *Base;\n\n  /// The type of the base expression; never null.\n  QualType BaseType;\n\n  /// The location of the '->' or '.' operator.\n  SourceLocation OperatorLoc;\n\n  // UnresolvedMemberExpr is followed by several trailing objects.\n  // They are in order:\n  //\n  // * An array of getNumResults() DeclAccessPair for the results. These are\n  //   undesugared, which is to say, they may include UsingShadowDecls.\n  //   Access is relative to the naming class.\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing\n  //   location information for the explicitly specified template arguments.\n\n  UnresolvedMemberExpr(const ASTContext &Context, bool HasUnresolvedUsing,\n                       Expr *Base, QualType BaseType, bool IsArrow,\n                       SourceLocation OperatorLoc,\n                       NestedNameSpecifierLoc QualifierLoc,\n                       SourceLocation TemplateKWLoc,\n                       const DeclarationNameInfo &MemberNameInfo,\n                       const TemplateArgumentListInfo *TemplateArgs,\n                       UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  UnresolvedMemberExpr(EmptyShell Empty, unsigned NumResults,\n                       bool HasTemplateKWAndArgsInfo);\n\n  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {\n    return getNumDecls();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\npublic:\n  static UnresolvedMemberExpr *\n  Create(const ASTContext &Context, bool HasUnresolvedUsing, Expr *Base,\n         QualType BaseType, bool IsArrow, SourceLocation OperatorLoc,\n         NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,\n         const DeclarationNameInfo &MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs,\n         UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  static UnresolvedMemberExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumResults,\n                                           bool HasTemplateKWAndArgsInfo,\n                                           unsigned NumTemplateArgs);\n\n  /// True if this is an implicit access, i.e., one in which the\n  /// member being accessed was not written in the source.\n  ///\n  /// The source location of the operator is invalid in this case.\n  bool isImplicitAccess() const;\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n  const Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether the lookup results contain an unresolved using\n  /// declaration.\n  bool hasUnresolvedUsing() const {\n    return UnresolvedMemberExprBits.HasUnresolvedUsing;\n  }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return UnresolvedMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the naming class of this lookup.\n  CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<UnresolvedMemberExpr *>(this)->getNamingClass();\n  }\n\n  /// Retrieve the full name info for the member that this expression\n  /// refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const { return getNameInfo(); }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMemberName() const { return getName(); }\n\n  /// Retrieve the location of the name of the member that this\n  /// expression refers to.\n  SourceLocation getMemberLoc() const { return getNameLoc(); }\n\n  /// Return the preferred location (the member name) for the arrow when\n  /// diagnosing a problem with this expression.\n  SourceLocation getExprLoc() const LLVM_READONLY { return getMemberLoc(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (NestedNameSpecifierLoc l = getQualifierLoc())\n      return l.getBeginLoc();\n    return getMemberNameInfo().getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getMemberNameInfo().getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\nDeclAccessPair *OverloadExpr::getTrailingResults() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<DeclAccessPair>();\n  return cast<UnresolvedMemberExpr>(this)->getTrailingObjects<DeclAccessPair>();\n}\n\nASTTemplateKWAndArgsInfo *OverloadExpr::getTrailingASTTemplateKWAndArgsInfo() {\n  if (!hasTemplateKWAndArgsInfo())\n    return nullptr;\n\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n}\n\nTemplateArgumentLoc *OverloadExpr::getTrailingTemplateArgumentLoc() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<TemplateArgumentLoc>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<TemplateArgumentLoc>();\n}\n\nCXXRecordDecl *OverloadExpr::getNamingClass() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getNamingClass();\n  return cast<UnresolvedMemberExpr>(this)->getNamingClass();\n}\n\n/// Represents a C++11 noexcept expression (C++ [expr.unary.noexcept]).\n///\n/// The noexcept expression tests whether a given expression might throw. Its\n/// result is a boolean constant.\nclass CXXNoexceptExpr : public Expr {\n  friend class ASTStmtReader;\n\n  Stmt *Operand;\n  SourceRange Range;\n\npublic:\n  CXXNoexceptExpr(QualType Ty, Expr *Operand, CanThrowResult Val,\n                  SourceLocation Keyword, SourceLocation RParen)\n      : Expr(CXXNoexceptExprClass, Ty, VK_PRValue, OK_Ordinary),\n        Operand(Operand), Range(Keyword, RParen) {\n    CXXNoexceptExprBits.Value = Val == CT_Cannot;\n    setDependence(computeDependence(this, Val));\n  }\n\n  CXXNoexceptExpr(EmptyShell Empty) : Expr(CXXNoexceptExprClass, Empty) {}\n\n  Expr *getOperand() const { return static_cast<Expr *>(Operand); }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n  SourceRange getSourceRange() const { return Range; }\n\n  bool getValue() const { return CXXNoexceptExprBits.Value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNoexceptExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Operand, &Operand + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, &Operand + 1);\n  }\n};\n\n/// Represents a C++11 pack expansion that produces a sequence of\n/// expressions.\n///\n/// A pack expansion expression contains a pattern (which itself is an\n/// expression) followed by an ellipsis. For example:\n///\n/// \\code\n/// template<typename F, typename ...Types>\n/// void forward(F f, Types &&...args) {\n///   f(static_cast<Types&&>(args)...);\n/// }\n/// \\endcode\n///\n/// Here, the argument to the function object \\c f is a pack expansion whose\n/// pattern is \\c static_cast<Types&&>(args). When the \\c forward function\n/// template is instantiated, the pack expansion will instantiate to zero or\n/// or more function arguments to the function object \\c f.\nclass PackExpansionExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  SourceLocation EllipsisLoc;\n\n  /// The number of expansions that will be produced by this pack\n  /// expansion expression, if known.\n  ///\n  /// When zero, the number of expansions is not known. Otherwise, this value\n  /// is the number of expansions + 1.\n  unsigned NumExpansions;\n\n  Stmt *Pattern;\n\npublic:\n  PackExpansionExpr(QualType T, Expr *Pattern, SourceLocation EllipsisLoc,\n                    std::optional<unsigned> NumExpansions)\n      : Expr(PackExpansionExprClass, T, Pattern->getValueKind(),\n             Pattern->getObjectKind()),\n        EllipsisLoc(EllipsisLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0),\n        Pattern(Pattern) {\n    setDependence(computeDependence(this));\n  }\n\n  PackExpansionExpr(EmptyShell Empty) : Expr(PackExpansionExprClass, Empty) {}\n\n  /// Retrieve the pattern of the pack expansion.\n  Expr *getPattern() { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the pattern of the pack expansion.\n  const Expr *getPattern() const { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the location of the ellipsis that describes this pack\n  /// expansion.\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// Determine the number of expansions that will be produced when\n  /// this pack expansion is instantiated, if already known.\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Pattern->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return EllipsisLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PackExpansionExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&Pattern, &Pattern + 1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Pattern, &Pattern + 1);\n  }\n};\n\n/// Represents an expression that computes the length of a parameter\n/// pack.\n///\n/// \\code\n/// template<typename ...Types>\n/// struct count {\n///   static const unsigned value = sizeof...(Types);\n/// };\n/// \\endcode\nclass SizeOfPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<SizeOfPackExpr, TemplateArgument> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The location of the \\c sizeof keyword.\n  SourceLocation OperatorLoc;\n\n  /// The location of the name of the parameter pack.\n  SourceLocation PackLoc;\n\n  /// The location of the closing parenthesis.\n  SourceLocation RParenLoc;\n\n  /// The length of the parameter pack, if known.\n  ///\n  /// When this expression is not value-dependent, this is the length of\n  /// the pack. When the expression was parsed rather than instantiated\n  /// (and thus is value-dependent), this is zero.\n  ///\n  /// After partial substitution into a sizeof...(X) expression (for instance,\n  /// within an alias template or during function template argument deduction),\n  /// we store a trailing array of partially-substituted TemplateArguments,\n  /// and this is the length of that array.\n  unsigned Length;\n\n  /// The parameter pack.\n  NamedDecl *Pack = nullptr;\n\n  /// Create an expression that computes the length of\n  /// the given parameter pack.\n  SizeOfPackExpr(QualType SizeType, SourceLocation OperatorLoc, NamedDecl *Pack,\n                 SourceLocation PackLoc, SourceLocation RParenLoc,\n                 std::optional<unsigned> Length,\n                 ArrayRef<TemplateArgument> PartialArgs)\n      : Expr(SizeOfPackExprClass, SizeType, VK_PRValue, OK_Ordinary),\n        OperatorLoc(OperatorLoc), PackLoc(PackLoc), RParenLoc(RParenLoc),\n        Length(Length ? *Length : PartialArgs.size()), Pack(Pack) {\n    assert((!Length || PartialArgs.empty()) &&\n           \"have partial args for non-dependent sizeof... expression\");\n    auto *Args = getTrailingObjects<TemplateArgument>();\n    std::uninitialized_copy(PartialArgs.begin(), PartialArgs.end(), Args);\n    setDependence(Length ? ExprDependence::None\n                         : ExprDependence::ValueInstantiation);\n  }\n\n  /// Create an empty expression.\n  SizeOfPackExpr(EmptyShell Empty, unsigned NumPartialArgs)\n      : Expr(SizeOfPackExprClass, Empty), Length(NumPartialArgs) {}\n\npublic:\n  static SizeOfPackExpr *\n  Create(ASTContext &Context, SourceLocation OperatorLoc, NamedDecl *Pack,\n         SourceLocation PackLoc, SourceLocation RParenLoc,\n         std::optional<unsigned> Length = std::nullopt,\n         ArrayRef<TemplateArgument> PartialArgs = std::nullopt);\n  static SizeOfPackExpr *CreateDeserialized(ASTContext &Context,\n                                            unsigned NumPartialArgs);\n\n  /// Determine the location of the 'sizeof' keyword.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Determine the location of the parameter pack.\n  SourceLocation getPackLoc() const { return PackLoc; }\n\n  /// Determine the location of the right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Retrieve the parameter pack.\n  NamedDecl *getPack() const { return Pack; }\n\n  /// Retrieve the length of the parameter pack.\n  ///\n  /// This routine may only be invoked when the expression is not\n  /// value-dependent.\n  unsigned getPackLength() const {\n    assert(!isValueDependent() &&\n           \"Cannot get the length of a value-dependent pack size expression\");\n    return Length;\n  }\n\n  /// Determine whether this represents a partially-substituted sizeof...\n  /// expression, such as is produced for:\n  ///\n  ///   template<typename ...Ts> using X = int[sizeof...(Ts)];\n  ///   template<typename ...Us> void f(X<Us..., 1, 2, 3, Us...>);\n  bool isPartiallySubstituted() const {\n    return isValueDependent() && Length;\n  }\n\n  /// Get\n  ArrayRef<TemplateArgument> getPartialArguments() const {\n    assert(isPartiallySubstituted());\n    const auto *Args = getTrailingObjects<TemplateArgument>();\n    return llvm::ArrayRef(Args, Args + Length);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SizeOfPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a non-type template parameter\n/// that has been substituted with a template argument.\nclass SubstNonTypeTemplateParmExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The replacement expression.\n  Stmt *Replacement;\n\n  /// The associated declaration and a flag indicating if it was a reference\n  /// parameter. For class NTTPs, we can't determine that based on the value\n  /// category alone.\n  llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndRef;\n\n  unsigned Index : 15;\n  unsigned PackIndex : 16;\n\n  explicit SubstNonTypeTemplateParmExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmExpr(QualType Ty, ExprValueKind ValueKind,\n                               SourceLocation Loc, Expr *Replacement,\n                               Decl *AssociatedDecl, unsigned Index,\n                               std::optional<unsigned> PackIndex, bool RefParam)\n      : Expr(SubstNonTypeTemplateParmExprClass, Ty, ValueKind, OK_Ordinary),\n        Replacement(Replacement),\n        AssociatedDeclAndRef(AssociatedDecl, RefParam), Index(Index),\n        PackIndex(PackIndex ? *PackIndex + 1 : 0) {\n    assert(AssociatedDecl != nullptr);\n    SubstNonTypeTemplateParmExprBits.NameLoc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  SourceLocation getNameLoc() const {\n    return SubstNonTypeTemplateParmExprBits.NameLoc;\n  }\n  SourceLocation getBeginLoc() const { return getNameLoc(); }\n  SourceLocation getEndLoc() const { return getNameLoc(); }\n\n  Expr *getReplacement() const { return cast<Expr>(Replacement); }\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDeclAndRef.getPointer(); }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameter()->getIndex()`.\n  unsigned getIndex() const { return Index; }\n\n  std::optional<unsigned> getPackIndex() const {\n    if (PackIndex == 0)\n      return std::nullopt;\n    return PackIndex - 1;\n  }\n\n  NonTypeTemplateParmDecl *getParameter() const;\n\n  bool isReferenceParameter() const { return AssociatedDeclAndRef.getInt(); }\n\n  /// Determine the substituted type of the template parameter.\n  QualType getParameterType(const ASTContext &Ctx) const;\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == SubstNonTypeTemplateParmExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Replacement, &Replacement + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Replacement, &Replacement + 1);\n  }\n};\n\n/// Represents a reference to a non-type template parameter pack that\n/// has been substituted with a non-template argument pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this node is used to represent a non-type template\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the appropriate underlying\n/// expression at the current pack substitution index.\nclass SubstNonTypeTemplateParmPackExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The non-type template parameter pack itself.\n  Decl *AssociatedDecl;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in \\c Arguments.\n  unsigned NumArguments : 16;\n\n  unsigned Index : 16;\n\n  /// The location of the non-type template parameter pack reference.\n  SourceLocation NameLoc;\n\n  explicit SubstNonTypeTemplateParmPackExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmPackExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmPackExpr(QualType T, ExprValueKind ValueKind,\n                                   SourceLocation NameLoc,\n                                   const TemplateArgument &ArgPack,\n                                   Decl *AssociatedDecl, unsigned Index);\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDecl; }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameterPack()->getIndex()`.\n  unsigned getIndex() const { return Index; }\n\n  /// Retrieve the non-type template parameter pack being substituted.\n  NonTypeTemplateParmDecl *getParameterPack() const;\n\n  /// Retrieve the location of the parameter pack name.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Retrieve the template argument pack containing the substituted\n  /// template arguments.\n  TemplateArgument getArgumentPack() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SubstNonTypeTemplateParmPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a function parameter pack or init-capture pack\n/// that has been substituted but not yet expanded.\n///\n/// When a pack expansion contains multiple parameter packs at different levels,\n/// this node is used to represent a function parameter pack at an outer level\n/// which we have already substituted to refer to expanded parameters, but where\n/// the containing pack expansion cannot yet be expanded.\n///\n/// \\code\n/// template<typename...Ts> struct S {\n///   template<typename...Us> auto f(Ts ...ts) -> decltype(g(Us(ts)...));\n/// };\n/// template struct S<int, int>;\n/// \\endcode\nclass FunctionParmPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<FunctionParmPackExpr, VarDecl *> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The function parameter pack which was referenced.\n  VarDecl *ParamPack;\n\n  /// The location of the function parameter pack reference.\n  SourceLocation NameLoc;\n\n  /// The number of expansions of this pack.\n  unsigned NumParameters;\n\n  FunctionParmPackExpr(QualType T, VarDecl *ParamPack,\n                       SourceLocation NameLoc, unsigned NumParams,\n                       VarDecl *const *Params);\n\npublic:\n  static FunctionParmPackExpr *Create(const ASTContext &Context, QualType T,\n                                      VarDecl *ParamPack,\n                                      SourceLocation NameLoc,\n                                      ArrayRef<VarDecl *> Params);\n  static FunctionParmPackExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumParams);\n\n  /// Get the parameter pack which this expression refers to.\n  VarDecl *getParameterPack() const { return ParamPack; }\n\n  /// Get the location of the parameter pack.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Iterators over the parameters which the parameter pack expanded\n  /// into.\n  using iterator = VarDecl * const *;\n  iterator begin() const { return getTrailingObjects<VarDecl *>(); }\n  iterator end() const { return begin() + NumParameters; }\n\n  /// Get the number of parameters in this parameter pack.\n  unsigned getNumExpansions() const { return NumParameters; }\n\n  /// Get an expansion of the parameter pack by index.\n  VarDecl *getExpansion(unsigned I) const { return begin()[I]; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FunctionParmPackExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a prvalue temporary that is written into memory so that\n/// a reference can bind to it.\n///\n/// Prvalue expressions are materialized when they need to have an address\n/// in memory for a reference to bind to. This happens when binding a\n/// reference to the result of a conversion, e.g.,\n///\n/// \\code\n/// const int &r = 1.0;\n/// \\endcode\n///\n/// Here, 1.0 is implicitly converted to an \\c int. That resulting \\c int is\n/// then materialized via a \\c MaterializeTemporaryExpr, and the reference\n/// binds to the temporary. \\c MaterializeTemporaryExprs are always glvalues\n/// (either an lvalue or an xvalue, depending on the kind of reference binding\n/// to it), maintaining the invariant that references always bind to glvalues.\n///\n/// Reference binding and copy-elision can both extend the lifetime of a\n/// temporary. When either happens, the expression will also track the\n/// declaration which is responsible for the lifetime extension.\nclass MaterializeTemporaryExpr : public Expr {\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  llvm::PointerUnion<Stmt *, LifetimeExtendedTemporaryDecl *> State;\n\npublic:\n  MaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                           bool BoundToLvalueReference,\n                           LifetimeExtendedTemporaryDecl *MTD = nullptr);\n\n  MaterializeTemporaryExpr(EmptyShell Empty)\n      : Expr(MaterializeTemporaryExprClass, Empty) {}\n\n  /// Retrieve the temporary-generating subexpression whose value will\n  /// be materialized into a glvalue.\n  Expr *getSubExpr() const {\n    return cast<Expr>(\n        State.is<Stmt *>()\n            ? State.get<Stmt *>()\n            : State.get<LifetimeExtendedTemporaryDecl *>()->getTemporaryExpr());\n  }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const {\n    return State.is<Stmt *>() ? SD_FullExpression\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getStorageDuration();\n  }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const {\n    assert(State.is<LifetimeExtendedTemporaryDecl *>() &&\n           \"the temporary has not been lifetime extended\");\n    return State.get<LifetimeExtendedTemporaryDecl *>()->getOrCreateValue(\n        MayCreate);\n  }\n\n  LifetimeExtendedTemporaryDecl *getLifetimeExtendedTemporaryDecl() {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n  const LifetimeExtendedTemporaryDecl *\n  getLifetimeExtendedTemporaryDecl() const {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n\n  /// Get the declaration which triggered the lifetime-extension of this\n  /// temporary, if any.\n  ValueDecl *getExtendingDecl() {\n    return State.is<Stmt *>() ? nullptr\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getExtendingDecl();\n  }\n  const ValueDecl *getExtendingDecl() const {\n    return const_cast<MaterializeTemporaryExpr *>(this)->getExtendingDecl();\n  }\n\n  void setExtendingDecl(ValueDecl *ExtendedBy, unsigned ManglingNumber);\n\n  unsigned getManglingNumber() const {\n    return State.is<Stmt *>() ? 0\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getManglingNumber();\n  }\n\n  /// Determine whether this materialized temporary is bound to an\n  /// lvalue reference; otherwise, it's bound to an rvalue reference.\n  bool isBoundToLvalueReference() const { return isLValue(); }\n\n  /// Determine whether this temporary object is usable in constant\n  /// expressions, as specified in C++20 [expr.const]p4.\n  bool isUsableInConstantExpressions(const ASTContext &Context) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MaterializeTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return State.is<Stmt *>()\n               ? child_range(State.getAddrOfPtr1(), State.getAddrOfPtr1() + 1)\n               : State.get<LifetimeExtendedTemporaryDecl *>()->childrenExpr();\n  }\n\n  const_child_range children() const {\n    return State.is<Stmt *>()\n               ? const_child_range(State.getAddrOfPtr1(),\n                                   State.getAddrOfPtr1() + 1)\n               : const_cast<const LifetimeExtendedTemporaryDecl *>(\n                     State.get<LifetimeExtendedTemporaryDecl *>())\n                     ->childrenExpr();\n  }\n};\n\n/// Represents a folding of a pack over an operator.\n///\n/// This expression is always dependent and represents a pack expansion of the\n/// forms:\n///\n///    ( expr op ... )\n///    ( ... op expr )\n///    ( expr op ... op expr )\nclass CXXFoldExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  enum SubExpr { Callee, LHS, RHS, Count };\n\n  SourceLocation LParenLoc;\n  SourceLocation EllipsisLoc;\n  SourceLocation RParenLoc;\n  // When 0, the number of expansions is not known. Otherwise, this is one more\n  // than the number of expansions.\n  unsigned NumExpansions;\n  Stmt *SubExprs[SubExpr::Count];\n  BinaryOperatorKind Opcode;\n\npublic:\n  CXXFoldExpr(QualType T, UnresolvedLookupExpr *Callee,\n              SourceLocation LParenLoc, Expr *LHS, BinaryOperatorKind Opcode,\n              SourceLocation EllipsisLoc, Expr *RHS, SourceLocation RParenLoc,\n              std::optional<unsigned> NumExpansions)\n      : Expr(CXXFoldExprClass, T, VK_PRValue, OK_Ordinary),\n        LParenLoc(LParenLoc), EllipsisLoc(EllipsisLoc), RParenLoc(RParenLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0), Opcode(Opcode) {\n    SubExprs[SubExpr::Callee] = Callee;\n    SubExprs[SubExpr::LHS] = LHS;\n    SubExprs[SubExpr::RHS] = RHS;\n    setDependence(computeDependence(this));\n  }\n\n  CXXFoldExpr(EmptyShell Empty) : Expr(CXXFoldExprClass, Empty) {}\n\n  UnresolvedLookupExpr *getCallee() const {\n    return static_cast<UnresolvedLookupExpr *>(SubExprs[SubExpr::Callee]);\n  }\n  Expr *getLHS() const { return static_cast<Expr*>(SubExprs[SubExpr::LHS]); }\n  Expr *getRHS() const { return static_cast<Expr*>(SubExprs[SubExpr::RHS]); }\n\n  /// Does this produce a right-associated sequence of operators?\n  bool isRightFold() const {\n    return getLHS() && getLHS()->containsUnexpandedParameterPack();\n  }\n\n  /// Does this produce a left-associated sequence of operators?\n  bool isLeftFold() const { return !isRightFold(); }\n\n  /// Get the pattern, that is, the operand that contains an unexpanded pack.\n  Expr *getPattern() const { return isLeftFold() ? getRHS() : getLHS(); }\n\n  /// Get the operand that doesn't contain a pack, for a binary fold.\n  Expr *getInit() const { return isLeftFold() ? getLHS() : getRHS(); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  BinaryOperatorKind getOperator() const { return Opcode; }\n\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (LParenLoc.isValid())\n      return LParenLoc;\n    if (isLeftFold())\n      return getEllipsisLoc();\n    return getLHS()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (RParenLoc.isValid())\n      return RParenLoc;\n    if (isRightFold())\n      return getEllipsisLoc();\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFoldExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n};\n\n/// Represents a list-initialization with parenthesis.\n///\n/// As per P0960R3, this is a C++20 feature that allows aggregate to\n/// be initialized with a parenthesized list of values:\n/// ```\n/// struct A {\n///   int a;\n///   double b;\n/// };\n///\n/// void foo() {\n///   A a1(0);        // Well-formed in C++20\n///   A a2(1.5, 1.0); // Well-formed in C++20\n/// }\n/// ```\n/// It has some sort of similiarity to braced\n/// list-initialization, with some differences such as\n/// it allows narrowing conversion whilst braced\n/// list-initialization doesn't.\n/// ```\n/// struct A {\n///   char a;\n/// };\n/// void foo() {\n///   A a(1.5); // Well-formed in C++20\n///   A b{1.5}; // Ill-formed !\n/// }\n/// ```\nclass CXXParenListInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXParenListInitExpr, Expr *> {\n  friend class TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  unsigned NumExprs;\n  unsigned NumUserSpecifiedExprs;\n  SourceLocation InitLoc, LParenLoc, RParenLoc;\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\n  CXXParenListInitExpr(ArrayRef<Expr *> Args, QualType T,\n                       unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n                       SourceLocation LParenLoc, SourceLocation RParenLoc)\n      : Expr(CXXParenListInitExprClass, T, getValueKindForType(T), OK_Ordinary),\n        NumExprs(Args.size()), NumUserSpecifiedExprs(NumUserSpecifiedExprs),\n        InitLoc(InitLoc), LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    std::copy(Args.begin(), Args.end(), getTrailingObjects<Expr *>());\n    assert(NumExprs >= NumUserSpecifiedExprs &&\n           \"number of user specified inits is greater than the number of \"\n           \"passed inits\");\n    setDependence(computeDependence(this));\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const { return NumExprs; }\n\npublic:\n  static CXXParenListInitExpr *\n  Create(ASTContext &C, ArrayRef<Expr *> Args, QualType T,\n         unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n         SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  static CXXParenListInitExpr *CreateEmpty(ASTContext &C, unsigned numExprs,\n                                           EmptyShell Empty);\n\n  explicit CXXParenListInitExpr(EmptyShell Empty, unsigned NumExprs)\n      : Expr(CXXParenListInitExprClass, Empty), NumExprs(NumExprs),\n        NumUserSpecifiedExprs(0) {}\n\n  void updateDependence() { setDependence(computeDependence(this)); }\n\n  ArrayRef<Expr *> getInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  const ArrayRef<Expr *> getInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  ArrayRef<Expr *> getUserSpecifiedInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  const ArrayRef<Expr *> getUserSpecifiedInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getInitLoc() const LLVM_READONLY { return InitLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  void setArrayFiller(Expr *E) { ArrayFillerOrUnionFieldInit = E; }\n\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  const Expr *getArrayFiller() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumExprs);\n  }\n\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumExprs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXParenListInitExprClass;\n  }\n};\n\n/// Represents an expression that might suspend coroutine execution;\n/// either a co_await or co_yield expression.\n///\n/// Evaluation of this expression first evaluates its 'ready' expression. If\n/// that returns 'false':\n///  -- execution of the coroutine is suspended\n///  -- the 'suspend' expression is evaluated\n///     -- if the 'suspend' expression returns 'false', the coroutine is\n///        resumed\n///     -- otherwise, control passes back to the resumer.\n/// If the coroutine is not suspended, or when it is resumed, the 'resume'\n/// expression is evaluated, and its result is the result of the overall\n/// expression.\nclass CoroutineSuspendExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n\n  enum SubExpr { Operand, Common, Ready, Suspend, Resume, Count };\n\n  Stmt *SubExprs[SubExpr::Count];\n  OpaqueValueExpr *OpaqueValue = nullptr;\n\npublic:\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, Expr *Operand,\n                       Expr *Common, Expr *Ready, Expr *Suspend, Expr *Resume,\n                       OpaqueValueExpr *OpaqueValue)\n      : Expr(SC, Resume->getType(), Resume->getValueKind(),\n             Resume->getObjectKind()),\n        KeywordLoc(KeywordLoc), OpaqueValue(OpaqueValue) {\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = Ready;\n    SubExprs[SubExpr::Suspend] = Suspend;\n    SubExprs[SubExpr::Resume] = Resume;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, QualType Ty,\n                       Expr *Operand, Expr *Common)\n      : Expr(SC, Ty, VK_PRValue, OK_Ordinary), KeywordLoc(KeywordLoc) {\n    assert(Common->isTypeDependent() && Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    SubExprs[SubExpr::Operand] = nullptr;\n    SubExprs[SubExpr::Common] = nullptr;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n  }\n\n  Expr *getCommonExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Common]);\n  }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  Expr *getReadyExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Ready]);\n  }\n\n  Expr *getSuspendExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Suspend]);\n  }\n\n  Expr *getResumeExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Resume]);\n  }\n\n  // The syntactic operand written in the code\n  Expr *getOperand() const {\n    return static_cast<Expr *>(SubExprs[SubExpr::Operand]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass ||\n           T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression.\nclass CoawaitExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoawaitExpr(SourceLocation CoawaitLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(SourceLocation CoawaitLoc, QualType Ty, Expr *Operand,\n              Expr *Common, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Ty, Operand,\n                             Common) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoawaitExprClass, Empty) {}\n\n  bool isImplicit() const { return CoawaitBits.IsImplicit; }\n  void setIsImplicit(bool value = true) { CoawaitBits.IsImplicit = value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression while the type of the promise\n/// is dependent.\nclass DependentCoawaitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n  Stmt *SubExprs[2];\n\npublic:\n  DependentCoawaitExpr(SourceLocation KeywordLoc, QualType Ty, Expr *Op,\n                       UnresolvedLookupExpr *OpCoawait)\n      : Expr(DependentCoawaitExprClass, Ty, VK_PRValue, OK_Ordinary),\n        KeywordLoc(KeywordLoc) {\n    // NOTE: A co_await expression is dependent on the coroutines promise\n    // type and may be dependent even when the `Op` expression is not.\n    assert(Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[0] = Op;\n    SubExprs[1] = OpCoawait;\n    setDependence(computeDependence(this));\n  }\n\n  DependentCoawaitExpr(EmptyShell Empty)\n      : Expr(DependentCoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const { return cast<Expr>(SubExprs[0]); }\n\n  UnresolvedLookupExpr *getOperatorCoawaitLookup() const {\n    return cast<UnresolvedLookupExpr>(SubExprs[1]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() { return child_range(SubExprs, SubExprs + 2); }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentCoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_yield' expression.\nclass CoyieldExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoyieldExpr(SourceLocation CoyieldLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {}\n  CoyieldExpr(SourceLocation CoyieldLoc, QualType Ty, Expr *Operand,\n              Expr *Common)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Ty, Operand,\n                             Common) {}\n  CoyieldExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoyieldExprClass, Empty) {}\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a C++2a __builtin_bit_cast(T, v) expression. Used to implement\n/// std::bit_cast. These can sometimes be evaluated as part of a constant\n/// expression, but otherwise CodeGen to a simple memcpy in general.\nclass BuiltinBitCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<BuiltinBitCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation KWLoc;\n  SourceLocation RParenLoc;\n\npublic:\n  BuiltinBitCastExpr(QualType T, ExprValueKind VK, CastKind CK, Expr *SrcExpr,\n                     TypeSourceInfo *DstType, SourceLocation KWLoc,\n                     SourceLocation RParenLoc)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, T, VK, CK, SrcExpr, 0, false,\n                         DstType),\n        KWLoc(KWLoc), RParenLoc(RParenLoc) {}\n  BuiltinBitCastExpr(EmptyShell Empty)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, Empty, 0, false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KWLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BuiltinBitCastExprClass;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-10807",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 1462,
  "validation_status": "validated"
}