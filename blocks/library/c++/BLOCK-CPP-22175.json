{
  "code": "{\n\nclass LangOptions;\nclass SourceManager;\n\nclass FixItOptions {\npublic:\n  FixItOptions() = default;\n  virtual ~FixItOptions();\n\n  /// This file is about to be rewritten. Return the name of the file\n  /// that is okay to write to.\n  ///\n  /// \\param fd out parameter for file descriptor. After the call it may be set\n  /// to an open file descriptor for the returned filename, or it will be -1\n  /// otherwise.\n  virtual std::string RewriteFilename(const std::string &Filename, int &fd) = 0;\n\n  /// True if files should be updated in place. RewriteFilename is only called\n  /// if this is false.\n  bool InPlace = false;\n\n  /// Whether to abort fixing a file when not all errors could be fixed.\n  bool FixWhatYouCan = false;\n\n  /// Whether to only fix warnings and not errors.\n  bool FixOnlyWarnings = false;\n\n  /// If true, only pass the diagnostic to the actual diagnostic consumer\n  /// if it is an error or a fixit was applied as part of the diagnostic.\n  /// It basically silences warnings without accompanying fixits.\n  bool Silent = false;\n};\n\nclass FixItRewriter : public DiagnosticConsumer {\n  /// The diagnostics machinery.\n  DiagnosticsEngine &Diags;\n\n  edit::EditedSource Editor;\n\n  /// The rewriter used to perform the various code\n  /// modifications.\n  Rewriter Rewrite;\n\n  /// The diagnostic client that performs the actual formatting\n  /// of error messages.\n  DiagnosticConsumer *Client;\n  std::unique_ptr<DiagnosticConsumer> Owner;\n\n  /// Turn an input path into an output path. NULL implies overwriting\n  /// the original.\n  FixItOptions *FixItOpts;\n\n  /// The number of rewriter failures.\n  unsigned NumFailures = 0;\n\n  /// Whether the previous diagnostic was not passed to the consumer.\n  bool PrevDiagSilenced = false;\n\npublic:\n  /// Initialize a new fix-it rewriter.\n  FixItRewriter(DiagnosticsEngine &Diags, SourceManager &SourceMgr,\n                const LangOptions &LangOpts, FixItOptions *FixItOpts);\n\n  /// Destroy the fix-it rewriter.\n  ~FixItRewriter() override;\n\n  /// Check whether there are modifications for a given file.\n  bool IsModified(FileID ID) const {\n    return Rewrite.getRewriteBufferFor(ID) != nullptr;\n  }\n\n  using iterator = Rewriter::buffer_iterator;\n\n  // Iteration over files with changes.\n  iterator buffer_begin() { return Rewrite.buffer_begin(); }\n  iterator buffer_end() { return Rewrite.buffer_end(); }\n\n  /// Write a single modified source file.\n  ///\n  /// \\returns true if there was an error, false otherwise.\n  bool WriteFixedFile(FileID ID, raw_ostream &OS);\n\n  /// Write the modified source files.\n  ///\n  /// \\returns true if there was an error, false otherwise.\n  bool WriteFixedFiles(\n    std::vector<std::pair<std::string, std::string>> *RewrittenFiles = nullptr);\n\n  /// IncludeInDiagnosticCounts - This method (whose default implementation\n  /// returns true) indicates whether the diagnostics handled by this\n  /// DiagnosticConsumer should be included in the number of diagnostics\n  /// reported by DiagnosticsEngine.\n  bool IncludeInDiagnosticCounts() const override;\n\n  /// HandleDiagnostic - Handle this diagnostic, reporting it to the user or\n  /// capturing it to a log as needed.\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override;\n\n  /// Emit a diagnostic via the adapted diagnostic client.\n  void Diag(SourceLocation Loc, unsigned DiagID);\n};\n\n}",
  "id": "BLOCK-CPP-22175",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Rewrite/Frontend/FixItRewriter.h",
  "source_line": 28,
  "validation_status": "validated"
}