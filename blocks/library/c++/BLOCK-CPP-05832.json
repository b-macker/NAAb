{
  "code": "#include <atomic>\n#include <cstddef>\n#include <functional>\n#include \"absl/base/config.h\"\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"absl/time/time.h\"\n\nusing namespace absl;\nusing namespace profiling_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05832_execute() {\n    {\n public:\n  SampleRecorder();\n  ~SampleRecorder();\n\n  // Registers for sampling.  Returns an opaque registration info.\n  template <typename... Targs>\n  T* Register(Targs&&... args);\n\n  // Unregisters the sample.\n  void Unregister(T* sample);\n\n  // The dispose callback will be called on all samples the moment they are\n  // being unregistered. Only affects samples that are unregistered after the\n  // callback has been set.\n  // Returns the previous callback.\n  using DisposeCallback = void (*)(const T&);\n  DisposeCallback SetDisposeCallback(DisposeCallback f);\n\n  // Iterates over all the registered `StackInfo`s.  Returning the number of\n  // samples that have been dropped.\n  int64_t Iterate(const std::function<void(const T& stack)>& f);\n\n  size_t GetMaxSamples() const;\n  void SetMaxSamples(size_t max);\n\n private:\n  void PushNew(T* sample);\n  void PushDead(T* sample);\n  template <typename... Targs>\n  T* PopDead(Targs... args);\n\n  std::atomic<size_t> dropped_samples_;\n  std::atomic<size_t> size_estimate_;\n  std::atomic<size_t> max_samples_{1 << 20};\n\n  // Intrusive lock free linked lists for tracking samples.\n  //\n  // `all_` records all samples (they are never removed from this list) and is\n  // terminated with a `nullptr`.\n  //\n  // `graveyard_.dead` is a circular linked list.  When it is empty,\n  // `graveyard_.dead == &graveyard`.  The list is circular so that\n  // every item on it (even the last) has a non-null dead pointer.  This allows\n  // `Iterate` to determine if a given sample is live or dead using only\n  // information on the sample itself.\n  //\n  // For example, nodes [A, B, C, D, E] with [A, C, E] alive and [B, D] dead\n  // looks like this (G is the Graveyard):\n  //\n  //           +---+    +---+    +---+    +---+    +---+\n  //    all -->| A |--->| B |--->| C |--->| D |--->| E |\n  //           |   |    |   |    |   |    |   |    |   |\n  //   +---+   |   | +->|   |-+  |   | +->|   |-+  |   |\n  //   | G |   +---+ |  +---+ |  +---+ |  +---+ |  +---+\n  //   |   |         |        |        |        |\n  //   |   | --------+        +--------+        |\n  //   +---+                                    |\n  //     ^                                      |\n  //     +--------------------------------------+\n  //\n  std::atomic<T*> all_;\n  T graveyard_;\n\n  std::atomic<DisposeCallback> dispose_;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05832",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/profiling/internal/sample_recorder.h",
  "source_line": 56,
  "validation_status": "validated"
}