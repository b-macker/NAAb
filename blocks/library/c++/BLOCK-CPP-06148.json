{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\n// CordRepBtreeReader implements logic to iterate over cord btrees.\n// References to the underlying data are returned as absl::string_view values.\n// The most typical use case is a forward only iteration over tree data.\n// The class also provides `Skip()`, `Seek()` and `Read()` methods similar to\n// CordRepBtreeNavigator that allow more advanced navigation.\n//\n// Example: iterate over all data inside a cord btree:\n//\n//   CordRepBtreeReader reader;\n//   for (string_view sv = reader.Init(tree); !sv.Empty(); sv = sv.Next()) {\n//     DoSomethingWithDataIn(sv);\n//   }\n//\n// All navigation methods always return the next 'chunk' of data. The class\n// assumes that all data is directly 'consumed' by the caller. For example:\n// invoking `Skip()` will skip the desired number of bytes, and directly\n// read and return the next chunk of data directly after the skipped bytes.\n//\n// Example: iterate over all data inside a btree skipping the first 100 bytes:\n//\n//   CordRepBtreeReader reader;\n//   absl::string_view sv = reader.Init(tree);\n//   if (sv.length() > 100) {\n//     sv.RemovePrefix(100);\n//   } else {\n//     sv = reader.Skip(100 - sv.length());\n//   }\n//   while (!sv.empty()) {\n//     DoSomethingWithDataIn(sv);\n//     absl::string_view sv = reader.Next();\n//   }\n//\n// It is important to notice that `remaining` is based on the end position of\n// the last data edge returned to the caller, not the cumulative data returned\n// to the caller which can be less in cases of skipping or seeking over data.\n//\n// For example, consider a cord btree with five data edges: \"abc\", \"def\", \"ghi\",\n// \"jkl\" and \"mno\":\n//\n//   absl::string_view sv;\n//   CordRepBtreeReader reader;\n//\n//   sv = reader.Init(tree); // sv = \"abc\", remaining = 12\n//   sv = reader.Skip(4);    // sv = \"hi\",  remaining = 6\n//   sv = reader.Skip(2);    // sv = \"l\",   remaining = 3\n//   sv = reader.Next();     // sv = \"mno\", remaining = 0\n//   sv = reader.Seek(1);    // sv = \"bc\", remaining = 12\n//\nclass CordRepBtreeReader {\n public:\n  using ReadResult = CordRepBtreeNavigator::ReadResult;\n  using Position = CordRepBtreeNavigator::Position;\n\n  // Returns true if this instance is not empty.\n  explicit operator bool() const { return navigator_.btree() != nullptr; }\n\n  // Returns the tree referenced by this instance or nullptr if empty.\n  CordRepBtree* btree() const { return navigator_.btree(); }\n\n  // Returns the current data edge inside the referenced btree.\n  // Requires that the current instance is not empty.\n  CordRep* node() const { return navigator_.Current(); }\n\n  // Returns the length of the referenced tree.\n  // Requires that the current instance is not empty.\n  size_t length() const;\n\n  // Returns the number of remaining bytes available for iteration, which is the\n  // number of bytes directly following the end of the last chunk returned.\n  // This value will be zero if we iterated over the last edge in the bound\n  // tree, in which case any call to Next() or Skip() will return an empty\n  // string_view reflecting the EOF state.\n  // Note that a call to `Seek()` resets `remaining` to a value based on the\n  // end position of the chunk returned by that call.\n  size_t remaining() const { return remaining_; }\n\n  // Resets this instance to an empty value.\n  void Reset() { navigator_.Reset(); }\n\n  // Initializes this instance with `tree`. `tree` must not be null.\n  // Returns a reference to the first data edge of the provided tree.\n  absl::string_view Init(CordRepBtree* tree);\n\n  // Navigates to and returns the next data edge of the referenced tree.\n  // Returns an empty string_view if an attempt is made to read beyond the end\n  // of the tree, i.e.: if `remaining()` is zero indicating an EOF condition.\n  // Requires that the current instance is not empty.\n  absl::string_view Next();\n\n  // Skips the provided amount of bytes and returns a reference to the data\n  // directly following the skipped bytes.\n  absl::string_view Skip(size_t skip);\n\n  // Reads `n` bytes into `tree`.\n  // If `chunk_size` is zero, starts reading at the next data edge. If\n  // `chunk_size` is non zero, the read starts at the last `chunk_size` bytes of\n  // the last returned data edge. Effectively, this means that the read starts\n  // at offset `consumed() - chunk_size`.\n  // Requires that `chunk_size` is less than or equal to the length of the\n  // last returned data edge. The purpose of `chunk_size` is to simplify code\n  // partially consuming a returned chunk and wanting to include the remaining\n  // bytes in the Read call. For example, the below code will read 1000 bytes of\n  // data into a cord tree if the first chunk starts with \"big:\":\n  //\n  //   CordRepBtreeReader reader;\n  //   absl::string_view sv = reader.Init(tree);\n  //   if (absl::StartsWith(sv, \"big:\")) {\n  //     CordRepBtree tree;\n  //     sv = reader.Read(1000, sv.size() - 4 /* \"big:\" */, &tree);\n  //   }\n  //\n  // This method will return an empty string view if all remaining data was\n  // read. If `n` exceeded the amount of remaining data this function will\n  // return an empty string view and `tree` will be set to nullptr.\n  // In both cases, `consumed` will be set to `length`.\n  absl::string_view Read(size_t n, size_t chunk_size, CordRep*& tree);\n\n  // Navigates to the chunk at offset `offset`.\n  // Returns a reference into the navigated to chunk, adjusted for the relative\n  // position of `offset` into that chunk. For example, calling `Seek(13)` on a\n  // cord tree containing 2 chunks of 10 and 20 bytes respectively will return\n  // a string view into the second chunk starting at offset 3 with a size of 17.\n  // Returns an empty string view if `offset` is equal to or greater than the\n  // length of the referenced tree.\n  absl::string_view Seek(size_t offset);\n\n private:\n  size_t remaining_ = 0;\n  CordRepBtreeNavigator navigator_;\n};\n\ninline size_t CordRepBtreeReader::length() const {\n  assert(btree() != nullptr);\n  return btree()->length;\n}\n\ninline absl::string_view CordRepBtreeReader::Init(CordRepBtree* tree) {\n  assert(tree != nullptr);\n  const CordRep* edge = navigator_.InitFirst(tree);\n  remaining_ = tree->length - edge->length;\n  return EdgeData(edge);\n}\n\ninline absl::string_view CordRepBtreeReader::Next() {\n  if (remaining_ == 0) return {};\n  const CordRep* edge = navigator_.Next();\n  assert(edge != nullptr);\n  remaining_ -= edge->length;\n  return EdgeData(edge);\n}\n\ninline absl::string_view CordRepBtreeReader::Skip(size_t skip) {\n  // As we are always positioned on the last 'consumed' edge, we\n  // need to skip the current edge as well as `skip`.\n  const size_t edge_length = navigator_.Current()->length;\n  CordRepBtreeNavigator::Position pos = navigator_.Skip(skip + edge_length);\n  if (ABSL_PREDICT_FALSE(pos.edge == nullptr)) {\n    remaining_ = 0;\n    return {};\n  }\n  // The combined length of all edges skipped before `pos.edge` is `skip -\n  // pos.offset`, all of which are 'consumed', as well as the current edge.\n  remaining_ -= skip - pos.offset + pos.edge->length;\n  return EdgeData(pos.edge).substr(pos.offset);\n}\n\ninline absl::string_view CordRepBtreeReader::Seek(size_t offset) {\n  const CordRepBtreeNavigator::Position pos = navigator_.Seek(offset);\n  if (ABSL_PREDICT_FALSE(pos.edge == nullptr)) {\n    remaining_ = 0;\n    return {};\n  }\n  absl::string_view chunk = EdgeData(pos.edge).substr(pos.offset);\n  remaining_ = length() - offset - chunk.length();\n  return chunk;\n}\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06148",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree_reader.h",
  "source_line": 27,
  "validation_status": "validated"
}