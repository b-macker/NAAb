{
  "code": "{\n  friend class clang::SarifDocumentWriter;\n\n  // NOTE:\n  // This type cannot fit all possible indexes representable by JSON, but is\n  // chosen because it is the largest unsigned type that can be safely\n  // converted to an \\c int64_t.\n  uint32_t RuleIdx;\n  std::string RuleId;\n  std::string DiagnosticMessage;\n  llvm::SmallVector<CharSourceRange, 8> Locations;\n  llvm::SmallVector<ThreadFlow, 8> ThreadFlows;\n  std::optional<SarifResultLevel> LevelOverride;\n\n  SarifResult() = delete;\n  explicit SarifResult(uint32_t RuleIdx) : RuleIdx(RuleIdx) {}\n\npublic:\n  static SarifResult create(uint32_t RuleIdx) { return SarifResult{RuleIdx}; }\n\n  SarifResult setIndex(uint32_t Idx) {\n    RuleIdx = Idx;\n    return *this;\n  }\n\n  SarifResult setRuleId(llvm::StringRef Id) {\n    RuleId = Id.str();\n    return *this;\n  }\n\n  SarifResult setDiagnosticMessage(llvm::StringRef Message) {\n    DiagnosticMessage = Message.str();\n    return *this;\n  }\n\n  SarifResult setLocations(llvm::ArrayRef<CharSourceRange> DiagLocs) {\n#ifndef NDEBUG\n    for (const auto &Loc : DiagLocs) {\n      assert(Loc.isCharRange() &&\n             \"SARIF Results require character granular source ranges!\");\n    }\n#endif\n    Locations.assign(DiagLocs.begin(), DiagLocs.end());\n    return *this;\n  }\n  SarifResult setThreadFlows(llvm::ArrayRef<ThreadFlow> ThreadFlowResults) {\n    ThreadFlows.assign(ThreadFlowResults.begin(), ThreadFlowResults.end());\n    return *this;\n  }\n\n  SarifResult setDiagnosticLevel(const SarifResultLevel &TheLevel) {\n    LevelOverride = TheLevel;\n    return *this;\n  }\n}",
  "id": "BLOCK-CPP-16808",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Sarif.h",
  "source_line": 315,
  "validation_status": "validated"
}