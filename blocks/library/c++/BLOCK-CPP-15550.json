{
  "code": "{\npublic:\n  /// Returns true when call expression \\p CE needs to be represented\n  /// by CFGCXXRecordTypedCall, as opposed to a regular CFGStmt.\n  static bool isCXXRecordTypedCall(const Expr *E) {\n    assert(isa<CallExpr>(E) || isa<ObjCMessageExpr>(E));\n    // There is no such thing as reference-type expression. If the function\n    // returns a reference, it'll return the respective lvalue or xvalue\n    // instead, and we're only interested in objects.\n    return !E->isGLValue() &&\n           E->getType().getCanonicalType()->getAsCXXRecordDecl();\n  }\n\n  explicit CFGCXXRecordTypedCall(const Expr *E, const ConstructionContext *C)\n      : CFGStmt(E, CXXRecordTypedCall) {\n    assert(isCXXRecordTypedCall(E));\n    assert(C && (isa<TemporaryObjectConstructionContext>(C) ||\n                 // These are possible in C++17 due to mandatory copy elision.\n                 isa<ReturnedValueConstructionContext>(C) ||\n                 isa<VariableConstructionContext>(C) ||\n                 isa<ConstructorInitializerConstructionContext>(C) ||\n                 isa<ArgumentConstructionContext>(C) ||\n                 isa<LambdaCaptureConstructionContext>(C)));\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGCXXRecordTypedCall() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == CXXRecordTypedCall;\n  }\n}",
  "id": "BLOCK-CPP-15550",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CFG.h",
  "source_line": 183,
  "validation_status": "validated"
}