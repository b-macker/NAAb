{
  "code": "{\nprivate:\n  static constexpr const uint64_t NullabilityKindMask = 0x3;\n  static constexpr const unsigned NullabilityKindSize = 2;\n\n  static constexpr const unsigned ReturnInfoIndex = 0;\n\npublic:\n  // If yes, we consider all types to be non-nullable unless otherwise noted.\n  // If this flag is not set, the pointer types are considered to have\n  // unknown nullability.\n\n  /// Whether the signature has been audited with respect to nullability.\n  unsigned NullabilityAudited : 1;\n\n  /// Number of types whose nullability is encoded with the NullabilityPayload.\n  unsigned NumAdjustedNullable : 8;\n\n  /// A biased RetainCountConventionKind, where 0 means \"unspecified\".\n  unsigned RawRetainCountConvention : 3;\n\n  // NullabilityKindSize bits are used to encode the nullability. The info\n  // about the return type is stored at position 0, followed by the nullability\n  // of the parameters.\n\n  /// Stores the nullability of the return type and the parameters.\n  uint64_t NullabilityPayload = 0;\n\n  /// The result type of this function, as a C type.\n  std::string ResultType;\n\n  /// The function parameters.\n  std::vector<ParamInfo> Params;\n\n  FunctionInfo()\n      : NullabilityAudited(false), NumAdjustedNullable(0),\n        RawRetainCountConvention() {}\n\n  static unsigned getMaxNullabilityIndex() {\n    return ((sizeof(NullabilityPayload) * CHAR_BIT) / NullabilityKindSize);\n  }\n\n  void addTypeInfo(unsigned index, NullabilityKind kind) {\n    assert(index <= getMaxNullabilityIndex());\n    assert(static_cast<unsigned>(kind) < NullabilityKindMask);\n\n    NullabilityAudited = true;\n    if (NumAdjustedNullable < index + 1)\n      NumAdjustedNullable = index + 1;\n\n    // Mask the bits.\n    NullabilityPayload &=\n        ~(NullabilityKindMask << (index * NullabilityKindSize));\n\n    // Set the value.\n    unsigned kindValue = (static_cast<unsigned>(kind))\n                         << (index * NullabilityKindSize);\n    NullabilityPayload |= kindValue;\n  }\n\n  /// Adds the return type info.\n  void addReturnTypeInfo(NullabilityKind kind) {\n    addTypeInfo(ReturnInfoIndex, kind);\n  }\n\n  /// Adds the parameter type info.\n  void addParamTypeInfo(unsigned index, NullabilityKind kind) {\n    addTypeInfo(index + 1, kind);\n  }\n\n  NullabilityKind getParamTypeInfo(unsigned index) const {\n    return getTypeInfo(index + 1);\n  }\n\n  NullabilityKind getReturnTypeInfo() const { return getTypeInfo(0); }\n\n  std::optional<RetainCountConventionKind> getRetainCountConvention() const {\n    if (!RawRetainCountConvention)\n      return std::nullopt;\n    return static_cast<RetainCountConventionKind>(RawRetainCountConvention - 1);\n  }\n  void\n  setRetainCountConvention(std::optional<RetainCountConventionKind> Value) {\n    RawRetainCountConvention = Value ? static_cast<unsigned>(*Value) + 1 : 0;\n    assert(getRetainCountConvention() == Value && \"bitfield too small\");\n  }\n\n  friend bool operator==(const FunctionInfo &, const FunctionInfo &);\n\nprivate:\n  NullabilityKind getTypeInfo(unsigned index) const {\n    assert(NullabilityAudited &&\n           \"Checking the type adjustment on non-audited method.\");\n\n    // If we don't have info about this parameter, return the default.\n    if (index > NumAdjustedNullable)\n      return NullabilityKind::NonNull;\n    auto nullability = NullabilityPayload >> (index * NullabilityKindSize);\n    return static_cast<NullabilityKind>(nullability & NullabilityKindMask);\n  }\n\npublic:\n  LLVM_DUMP_METHOD void dump(llvm::raw_ostream &OS) const;\n}",
  "id": "BLOCK-CPP-06804",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/APINotes/Types.h",
  "source_line": 483,
  "validation_status": "validated"
}