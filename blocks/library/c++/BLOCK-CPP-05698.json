{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace hash_internal {\n\n// SpyHashState is an implementation of the HashState API that simply\n// accumulates all input bytes in an internal buffer. This makes it useful\n// for testing AbslHashValue overloads (so long as they are templated on the\n// HashState parameter), since it can report the exact hash representation\n// that the AbslHashValue overload produces.\n//\n// Sample usage:\n// EXPECT_EQ(SpyHashState::combine(SpyHashState(), foo),\n//           SpyHashState::combine(SpyHashState(), bar));\ntemplate <typename T>\nclass SpyHashStateImpl : public HashStateBase<SpyHashStateImpl<T>> {\n public:\n  SpyHashStateImpl() : error_(std::make_shared<absl::optional<std::string>>()) {\n    static_assert(std::is_void<T>::value, \"\");\n  }\n\n  // Move-only\n  SpyHashStateImpl(const SpyHashStateImpl&) = delete;\n  SpyHashStateImpl& operator=(const SpyHashStateImpl&) = delete;\n\n  SpyHashStateImpl(SpyHashStateImpl&& other) noexcept {\n    *this = std::move(other);\n  }\n\n  SpyHashStateImpl& operator=(SpyHashStateImpl&& other) noexcept {\n    hash_representation_ = std::move(other.hash_representation_);\n    error_ = other.error_;\n    moved_from_ = other.moved_from_;\n    other.moved_from_ = true;\n    return *this;\n  }\n\n  template <typename U>\n  SpyHashStateImpl(SpyHashStateImpl<U>&& other) {  // NOLINT\n    hash_representation_ = std::move(other.hash_representation_);\n    error_ = other.error_;\n    moved_from_ = other.moved_from_;\n    other.moved_from_ = true;\n  }\n\n  template <typename A, typename... Args>\n  static SpyHashStateImpl combine(SpyHashStateImpl s, const A& a,\n                                  const Args&... args) {\n    // Pass an instance of SpyHashStateImpl<A> when trying to combine `A`. This\n    // allows us to test that the user only uses this instance for combine calls\n    // and does not call AbslHashValue directly.\n    // See AbslHashValue implementation at the bottom.\n    s = SpyHashStateImpl<A>::HashStateBase::combine(std::move(s), a);\n    return SpyHashStateImpl::combine(std::move(s), args...);\n  }\n  static SpyHashStateImpl combine(SpyHashStateImpl s) {\n    if (direct_absl_hash_value_error_) {\n      *s.error_ = \"AbslHashValue should not be invoked directly.\";\n    } else if (s.moved_from_) {\n      *s.error_ = \"Used moved-from instance of the hash state object.\";\n    }\n    return s;\n  }\n\n  static void SetDirectAbslHashValueError() {\n    direct_absl_hash_value_error_ = true;\n  }\n\n  // Two SpyHashStateImpl objects are equal if they hold equal hash\n  // representations.\n  friend bool operator==(const SpyHashStateImpl& lhs,\n                         const SpyHashStateImpl& rhs) {\n    return lhs.hash_representation_ == rhs.hash_representation_;\n  }\n\n  friend bool operator!=(const SpyHashStateImpl& lhs,\n                         const SpyHashStateImpl& rhs) {\n    return !(lhs == rhs);\n  }\n\n  enum class CompareResult {\n    kEqual,\n    kASuffixB,\n    kBSuffixA,\n    kUnequal,\n  };\n\n  static CompareResult Compare(const SpyHashStateImpl& a,\n                               const SpyHashStateImpl& b) {\n    const std::string a_flat = absl::StrJoin(a.hash_representation_, \"\");\n    const std::string b_flat = absl::StrJoin(b.hash_representation_, \"\");\n    if (a_flat == b_flat) return CompareResult::kEqual;\n    if (absl::EndsWith(a_flat, b_flat)) return CompareResult::kBSuffixA;\n    if (absl::EndsWith(b_flat, a_flat)) return CompareResult::kASuffixB;\n    return CompareResult::kUnequal;\n  }\n\n  // operator<< prints the hash representation as a hex and ASCII dump, to\n  // facilitate debugging.\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const SpyHashStateImpl& hash_state) {\n    out << \"[\\n\";\n    for (auto& s : hash_state.hash_representation_) {\n      size_t offset = 0;\n      for (char c : s) {\n        if (offset % 16 == 0) {\n          out << absl::StreamFormat(\"\\n0x%04x: \", offset);\n        }\n        if (offset % 2 == 0) {\n          out << \" \";\n        }\n        out << absl::StreamFormat(\"%02x\", c);\n        ++offset;\n      }\n      out << \"\\n\";\n    }\n    return out << \"]\";\n  }\n\n  // The base case of the combine recursion, which writes raw bytes into the\n  // internal buffer.\n  static SpyHashStateImpl combine_contiguous(SpyHashStateImpl hash_state,\n                                             const unsigned char* begin,\n                                             size_t size) {\n    const size_t large_chunk_stride = PiecewiseChunkSize();\n    if (size > large_chunk_stride) {\n      // Combining a large contiguous buffer must have the same effect as\n      // doing it piecewise by the stride length, followed by the (possibly\n      // empty) remainder.\n      while (size >= large_chunk_stride) {\n        hash_state = SpyHashStateImpl::combine_contiguous(\n            std::move(hash_state), begin, large_chunk_stride);\n        begin += large_chunk_stride;\n        size -= large_chunk_stride;\n      }\n    }\n\n    hash_state.hash_representation_.emplace_back(\n        reinterpret_cast<const char*>(begin), size);\n    return hash_state;\n  }\n\n  using SpyHashStateImpl::HashStateBase::combine_contiguous;\n\n  template <typename CombinerT>\n  static SpyHashStateImpl RunCombineUnordered(SpyHashStateImpl state,\n                                              CombinerT combiner) {\n    UnorderedCombinerCallback cb;\n\n    combiner(SpyHashStateImpl<void>{}, std::ref(cb));\n\n    std::sort(cb.element_hash_representations.begin(),\n              cb.element_hash_representations.end());\n    state.hash_representation_.insert(state.hash_representation_.end(),\n                                      cb.element_hash_representations.begin(),\n                                      cb.element_hash_representations.end());\n    if (cb.error && cb.error->has_value()) {\n      state.error_ = std::move(cb.error);\n    }\n    return state;\n  }\n\n  absl::optional<std::string> error() const {\n    if (moved_from_) {\n      return \"Returned a moved-from instance of the hash state object.\";\n    }\n    return *error_;\n  }\n\n private:\n  template <typename U>\n  friend class SpyHashStateImpl;\n\n  struct UnorderedCombinerCallback {\n    std::vector<std::string> element_hash_representations;\n    std::shared_ptr<absl::optional<std::string>> error;\n\n    // The inner spy can have a different type.\n    template <typename U>\n    void operator()(SpyHashStateImpl<U>& inner) {\n      element_hash_representations.push_back(\n          absl::StrJoin(inner.hash_representation_, \"\"));\n      if (inner.error_->has_value()) {\n        error = std::move(inner.error_);\n      }\n      inner = SpyHashStateImpl<void>{};\n    }\n  };\n\n  // This is true if SpyHashStateImpl<T> has been passed to a call of\n  // AbslHashValue with the wrong type. This detects that the user called\n  // AbslHashValue directly (because the hash state type does not match).\n  static bool direct_absl_hash_value_error_;\n\n  std::vector<std::string> hash_representation_;\n  // This is a shared_ptr because we want all instances of the particular\n  // SpyHashState run to share the field. This way we can set the error for\n  // use-after-move and all the copies will see it.\n  std::shared_ptr<absl::optional<std::string>> error_;\n  bool moved_from_ = false;\n};\n\ntemplate <typename T>\nbool SpyHashStateImpl<T>::direct_absl_hash_value_error_;\n\ntemplate <bool& B>\nstruct OdrUse {\n  constexpr OdrUse() {}\n  bool& b = B;\n};\n\ntemplate <void (*)()>\nstruct RunOnStartup {\n  static bool run;\n  static constexpr OdrUse<run> kOdrUse{};\n};\n\ntemplate <void (*f)()>\nbool RunOnStartup<f>::run = (f(), true);\n\ntemplate <\n    typename T, typename U,\n    // Only trigger for when (T != U),\n    typename = absl::enable_if_t<!std::is_same<T, U>::value>,\n    // This statement works in two ways:\n    //  - First, it instantiates RunOnStartup and forces the initialization of\n    //    `run`, which set the global variable.\n    //  - Second, it triggers a SFINAE error disabling the overload to prevent\n    //    compile time errors. If we didn't disable the overload we would get\n    //    ambiguous overload errors, which we don't want.\n    int = RunOnStartup<SpyHashStateImpl<T>::SetDirectAbslHashValueError>::run>\nvoid AbslHashValue(SpyHashStateImpl<T>, const U&);\n\nusing SpyHashState = SpyHashStateImpl<void>;\n\n}  // namespace hash_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05698",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/internal/spy_hash_state.h",
  "source_line": 28,
  "validation_status": "validated"
}