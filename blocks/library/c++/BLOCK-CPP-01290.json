{
  "code": "#include <cmath>         // std::signbit\n#include <cstdint>       // uint32_t\n#include <cstring>       // std::memcpy\n#include <limits>        // std::numeric_limits\n#include <memory>        // std::uninitialized_copy\n#include <stdexcept>     // std::runtime_error\n#include <system_error>  // std::system_error\n#include \"core.h\"\n\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail_exported;\nusing namespace detail_exported;\nusing namespace dragonbox;\nusing namespace dragonbox;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01290_execute() {\n    {\n  const int shift = 32;\n  // log10(2) = 0x0.4d104d427de7fbcc...\n  const int64_t significand = 0x4d104d427de7fbcc;\n  int index = static_cast<int>(\n      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +\n       ((int64_t(1) << shift) - 1))  // ceil\n      >> 32                          // arithmetic shift\n  );\n  // Decimal exponent of the first (smallest) cached power of 10.\n  const int first_dec_exp = -348;\n  // Difference between 2 consecutive decimal exponents in cached powers of 10.\n  const int dec_exp_step = 8;\n  index = (index - first_dec_exp - 1) / dec_exp_step + 1;\n  pow10_exponent = first_dec_exp + index * dec_exp_step;\n  // Using *(x + index) instead of x[index] avoids an issue with some compilers\n  // using the EDG frontend (e.g. nvhpc/22.3 in C++17 mode).\n  return {*(data::pow10_significands + index),\n          *(data::pow10_exponents + index)};\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01290",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 1548,
  "validation_status": "validated"
}