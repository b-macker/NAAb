{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace functional_internal {\n\n// Like a void* that can handle function pointers as well. The standard does not\n// allow function pointers to round-trip through void*, but void(*)() is fine.\n//\n// Note: It's important that this class remains trivial and is the same size as\n// a pointer, since this allows the compiler to perform tail-call optimizations\n// when the underlying function is a callable object with a matching signature.\nunion VoidPtr {\n  const void* obj;\n  void (*fun)();\n};\n\n// Chooses the best type for passing T as an argument.\n// Attempt to be close to SystemV AMD64 ABI. Objects with trivial copy ctor are\n// passed by value.\ntemplate <typename T,\n          bool IsLValueReference = std::is_lvalue_reference<T>::value>\nstruct PassByValue : std::false_type {};\n\ntemplate <typename T>\nstruct PassByValue<T, /*IsLValueReference=*/false>\n    : std::integral_constant<bool,\n                             absl::is_trivially_copy_constructible<T>::value &&\n                                 absl::is_trivially_copy_assignable<\n                                     typename std::remove_cv<T>::type>::value &&\n                                 std::is_trivially_destructible<T>::value &&\n                                 sizeof(T) <= 2 * sizeof(void*)> {};\n\ntemplate <typename T>\nstruct ForwardT : std::conditional<PassByValue<T>::value, T, T&&> {};\n\n// An Invoker takes a pointer to the type-erased invokable object, followed by\n// the arguments that the invokable object expects.\n//\n// Note: The order of arguments here is an optimization, since member functions\n// have an implicit \"this\" pointer as their first argument, putting VoidPtr\n// first allows the compiler to perform tail-call optimization in many cases.\ntemplate <typename R, typename... Args>\nusing Invoker = R (*)(VoidPtr, typename ForwardT<Args>::type...);\n\n//\n// InvokeObject and InvokeFunction provide static \"Invoke\" functions that can be\n// used as Invokers for objects or functions respectively.\n//\n// static_cast<R> handles the case the return type is void.\ntemplate <typename Obj, typename R, typename... Args>\nR InvokeObject(VoidPtr ptr, typename ForwardT<Args>::type... args) {\n  auto o = static_cast<const Obj*>(ptr.obj);\n  return static_cast<R>(\n      absl::base_internal::invoke(*o, std::forward<Args>(args)...));\n}\n\ntemplate <typename Fun, typename R, typename... Args>\nR InvokeFunction(VoidPtr ptr, typename ForwardT<Args>::type... args) {\n  auto f = reinterpret_cast<Fun>(ptr.fun);\n  return static_cast<R>(\n      absl::base_internal::invoke(f, std::forward<Args>(args)...));\n}\n\ntemplate <typename Sig>\nvoid AssertNonNull(const std::function<Sig>& f) {\n  assert(f != nullptr);\n  (void)f;\n}\n\ntemplate <typename Sig>\nvoid AssertNonNull(const AnyInvocable<Sig>& f) {\n  assert(f != nullptr);\n  (void)f;\n}\n\ntemplate <typename F>\nvoid AssertNonNull(const F&) {}\n\ntemplate <typename F, typename C>\nvoid AssertNonNull(F C::*f) {\n  assert(f != nullptr);\n  (void)f;\n}\n\ntemplate <bool C>\nusing EnableIf = typename ::std::enable_if<C, int>::type;\n\n}  // namespace functional_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05610",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/functional/internal/function_ref.h",
  "source_line": 26,
  "validation_status": "validated"
}