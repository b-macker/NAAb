{
  "code": "{\n    public:\n      typedef int64_t QuantityType;\n\n    private:\n      QuantityType Quantity = 0;\n\n      explicit CharUnits(QuantityType C) : Quantity(C) {}\n\n    public:\n\n      /// CharUnits - A default constructor.\n      CharUnits() = default;\n\n      /// Zero - Construct a CharUnits quantity of zero.\n      static CharUnits Zero() {\n        return CharUnits(0);\n      }\n\n      /// One - Construct a CharUnits quantity of one.\n      static CharUnits One() {\n        return CharUnits(1);\n      }\n\n      /// fromQuantity - Construct a CharUnits quantity from a raw integer type.\n      static CharUnits fromQuantity(QuantityType Quantity) {\n        return CharUnits(Quantity);\n      }\n\n      /// fromQuantity - Construct a CharUnits quantity from an llvm::Align\n      /// quantity.\n      static CharUnits fromQuantity(llvm::Align Quantity) {\n        return CharUnits(Quantity.value());\n      }\n\n      // Compound assignment.\n      CharUnits& operator+= (const CharUnits &Other) {\n        Quantity += Other.Quantity;\n        return *this;\n      }\n      CharUnits& operator++ () {\n        ++Quantity;\n        return *this;\n      }\n      CharUnits operator++ (int) {\n        return CharUnits(Quantity++);\n      }\n      CharUnits& operator-= (const CharUnits &Other) {\n        Quantity -= Other.Quantity;\n        return *this;\n      }\n      CharUnits& operator-- () {\n        --Quantity;\n        return *this;\n      }\n      CharUnits operator-- (int) {\n        return CharUnits(Quantity--);\n      }\n\n      // Comparison operators.\n      bool operator== (const CharUnits &Other) const {\n        return Quantity == Other.Quantity;\n      }\n      bool operator!= (const CharUnits &Other) const {\n        return Quantity != Other.Quantity;\n      }\n\n      // Relational operators.\n      bool operator<  (const CharUnits &Other) const {\n        return Quantity <  Other.Quantity;\n      }\n      bool operator<= (const CharUnits &Other) const {\n        return Quantity <= Other.Quantity;\n      }\n      bool operator>  (const CharUnits &Other) const {\n        return Quantity >  Other.Quantity;\n      }\n      bool operator>= (const CharUnits &Other) const {\n        return Quantity >= Other.Quantity;\n      }\n\n      // Other predicates.\n\n      /// isZero - Test whether the quantity equals zero.\n      bool isZero() const     { return Quantity == 0; }\n\n      /// isOne - Test whether the quantity equals one.\n      bool isOne() const      { return Quantity == 1; }\n\n      /// isPositive - Test whether the quantity is greater than zero.\n      bool isPositive() const { return Quantity  > 0; }\n\n      /// isNegative - Test whether the quantity is less than zero.\n      bool isNegative() const { return Quantity  < 0; }\n\n      /// isPowerOfTwo - Test whether the quantity is a power of two.\n      /// Zero is not a power of two.\n      bool isPowerOfTwo() const {\n        return (Quantity & -Quantity) == Quantity;\n      }\n\n      /// Test whether this is a multiple of the other value.\n      ///\n      /// Among other things, this promises that\n      /// self.alignTo(N) will just return self.\n      bool isMultipleOf(CharUnits N) const {\n        return (*this % N) == 0;\n      }\n\n      // Arithmetic operators.\n      CharUnits operator* (QuantityType N) const {\n        return CharUnits(Quantity * N);\n      }\n      CharUnits &operator*= (QuantityType N) {\n        Quantity *= N;\n        return *this;\n      }\n      CharUnits operator/ (QuantityType N) const {\n        return CharUnits(Quantity / N);\n      }\n      CharUnits &operator/= (QuantityType N) {\n        Quantity /= N;\n        return *this;\n      }\n      QuantityType operator/ (const CharUnits &Other) const {\n        return Quantity / Other.Quantity;\n      }\n      CharUnits operator% (QuantityType N) const {\n        return CharUnits(Quantity % N);\n      }\n      QuantityType operator% (const CharUnits &Other) const {\n        return Quantity % Other.Quantity;\n      }\n      CharUnits operator+ (const CharUnits &Other) const {\n        return CharUnits(Quantity + Other.Quantity);\n      }\n      CharUnits operator- (const CharUnits &Other) const {\n        return CharUnits(Quantity - Other.Quantity);\n      }\n      CharUnits operator- () const {\n        return CharUnits(-Quantity);\n      }\n\n\n      // Conversions.\n\n      /// getQuantity - Get the raw integer representation of this quantity.\n      QuantityType getQuantity() const { return Quantity; }\n\n      /// getAsAlign - Returns Quantity as a valid llvm::Align,\n      /// Beware llvm::Align assumes power of two 8-bit bytes.\n      llvm::Align getAsAlign() const { return llvm::Align(Quantity); }\n\n      /// getAsMaybeAlign - Returns Quantity as a valid llvm::Align or\n      /// std::nullopt, Beware llvm::MaybeAlign assumes power of two 8-bit\n      /// bytes.\n      llvm::MaybeAlign getAsMaybeAlign() const {\n        return llvm::MaybeAlign(Quantity);\n      }\n\n      /// alignTo - Returns the next integer (mod 2**64) that is\n      /// greater than or equal to this quantity and is a multiple of \\p Align.\n      /// Align must be non-zero.\n      CharUnits alignTo(const CharUnits &Align) const {\n        return CharUnits(llvm::alignTo(Quantity, Align.Quantity));\n      }\n\n      /// Given that this is a non-zero alignment value, what is the\n      /// alignment at the given offset?\n      CharUnits alignmentAtOffset(CharUnits offset) const {\n        assert(Quantity != 0 && \"offsetting from unknown alignment?\");\n        return CharUnits(llvm::MinAlign(Quantity, offset.Quantity));\n      }\n\n      /// Given that this is the alignment of the first element of an\n      /// array, return the minimum alignment of any element in the array.\n      CharUnits alignmentOfArrayElement(CharUnits elementSize) const {\n        // Since we don't track offsetted alignments, the alignment of\n        // the second element (or any odd element) will be minimally\n        // aligned.\n        return alignmentAtOffset(elementSize);\n      }\n\n\n  }",
  "id": "BLOCK-CPP-23289",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CharUnits.h",
  "source_line": 38,
  "validation_status": "validated"
}