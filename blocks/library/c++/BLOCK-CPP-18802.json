{
  "code": "{\n  SourceManager &SourceMgr;\n  DiagnosticsEngine &Diags;\n  const LangOptions &LangOpts;\n  const TargetInfo *Target;\n  HeaderSearch &HeaderInfo;\n\n  llvm::SmallVector<std::unique_ptr<ModuleMapCallbacks>, 1> Callbacks;\n\n  /// The directory used for Clang-supplied, builtin include headers,\n  /// such as \"stdint.h\".\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr BuiltinIncludeDir;\n\n  /// Language options used to parse the module map itself.\n  ///\n  /// These are always simple C language options.\n  LangOptions MMapLangOpts;\n\n  /// The module that the main source file is associated with (the module\n  /// named LangOpts::CurrentModule, if we've loaded it).\n  Module *SourceModule = nullptr;\n\n  /// Submodules of the current module that have not yet been attached to it.\n  /// (Ownership is transferred if/when we create an enclosing module.)\n  llvm::SmallVector<std::unique_ptr<Module>, 8> PendingSubmodules;\n\n  /// The top-level modules that are known.\n  llvm::StringMap<Module *> Modules;\n\n  /// Module loading cache that includes submodules, indexed by IdentifierInfo.\n  /// nullptr is stored for modules that are known to fail to load.\n  llvm::DenseMap<const IdentifierInfo *, Module *> CachedModuleLoads;\n\n  /// Shadow modules created while building this module map.\n  llvm::SmallVector<Module*, 2> ShadowModules;\n\n  /// The number of modules we have created in total.\n  unsigned NumCreatedModules = 0;\n\n  /// In case a module has a export_as entry, it might have a pending link\n  /// name to be determined if that module is imported.\n  llvm::StringMap<llvm::StringSet<>> PendingLinkAsModule;\n\npublic:\n  /// Use PendingLinkAsModule information to mark top level link names that\n  /// are going to be replaced by export_as aliases.\n  void resolveLinkAsDependencies(Module *Mod);\n\n  /// Make module to use export_as as the link dependency name if enough\n  /// information is available or add it to a pending list otherwise.\n  void addLinkAsDependency(Module *Mod);\n\n  /// Flags describing the role of a module header.\n  enum ModuleHeaderRole {\n    /// This header is normally included in the module.\n    NormalHeader  = 0x0,\n\n    /// This header is included but private.\n    PrivateHeader = 0x1,\n\n    /// This header is part of the module (for layering purposes) but\n    /// should be textually included.\n    TextualHeader = 0x2,\n\n    /// This header is explicitly excluded from the module.\n    ExcludedHeader = 0x4,\n\n    // Caution: Adding an enumerator needs other changes.\n    // Adjust the number of bits for KnownHeader::Storage.\n    // Adjust the HeaderFileInfoTrait::ReadData streaming.\n    // Adjust the HeaderFileInfoTrait::EmitData streaming.\n    // Adjust ModuleMap::addHeader.\n  };\n\n  /// Convert a header kind to a role. Requires Kind to not be HK_Excluded.\n  static ModuleHeaderRole headerKindToRole(Module::HeaderKind Kind);\n\n  /// Convert a header role to a kind.\n  static Module::HeaderKind headerRoleToKind(ModuleHeaderRole Role);\n\n  /// Check if the header with the given role is a modular one.\n  static bool isModular(ModuleHeaderRole Role);\n\n  /// A header that is known to reside within a given module,\n  /// whether it was included or excluded.\n  class KnownHeader {\n    llvm::PointerIntPair<Module *, 3, ModuleHeaderRole> Storage;\n\n  public:\n    KnownHeader() : Storage(nullptr, NormalHeader) {}\n    KnownHeader(Module *M, ModuleHeaderRole Role) : Storage(M, Role) {}\n\n    friend bool operator==(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage == B.Storage;\n    }\n    friend bool operator!=(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage != B.Storage;\n    }\n\n    /// Retrieve the module the header is stored in.\n    Module *getModule() const { return Storage.getPointer(); }\n\n    /// The role of this header within the module.\n    ModuleHeaderRole getRole() const { return Storage.getInt(); }\n\n    /// Whether this header is available in the module.\n    bool isAvailable() const {\n      return getRole() != ExcludedHeader && getModule()->isAvailable();\n    }\n\n    /// Whether this header is accessible from the specified module.\n    bool isAccessibleFrom(Module *M) const {\n      return !(getRole() & PrivateHeader) ||\n             (M && M->getTopLevelModule() == getModule()->getTopLevelModule());\n    }\n\n    // Whether this known header is valid (i.e., it has an\n    // associated module).\n    explicit operator bool() const {\n      return Storage.getPointer() != nullptr;\n    }\n  };\n\n  using AdditionalModMapsSet = llvm::SmallPtrSet<const FileEntry *, 1>;\n\nprivate:\n  friend class ModuleMapParser;\n\n  using HeadersMap =\n      llvm::DenseMap<const FileEntry *, SmallVector<KnownHeader, 1>>;\n\n  /// Mapping from each header to the module that owns the contents of\n  /// that header.\n  HeadersMap Headers;\n\n  /// Map from file sizes to modules with lazy header directives of that size.\n  mutable llvm::DenseMap<off_t, llvm::TinyPtrVector<Module*>> LazyHeadersBySize;\n\n  /// Map from mtimes to modules with lazy header directives with those mtimes.\n  mutable llvm::DenseMap<time_t, llvm::TinyPtrVector<Module*>>\n              LazyHeadersByModTime;\n\n  /// Mapping from directories with umbrella headers to the module\n  /// that is generated from the umbrella header.\n  ///\n  /// This mapping is used to map headers that haven't explicitly been named\n  /// in the module map over to the module that includes them via its umbrella\n  /// header.\n  llvm::DenseMap<const DirectoryEntry *, Module *> UmbrellaDirs;\n\n  /// A generation counter that is used to test whether modules of the\n  /// same name may shadow or are illegal redefinitions.\n  ///\n  /// Modules from earlier scopes may shadow modules from later ones.\n  /// Modules from the same scope may not have the same name.\n  unsigned CurrentModuleScopeID = 0;\n\n  llvm::DenseMap<Module *, unsigned> ModuleScopeIDs;\n\n  /// The set of attributes that can be attached to a module.\n  struct Attributes {\n    /// Whether this is a system module.\n    unsigned IsSystem : 1;\n\n    /// Whether this is an extern \"C\" module.\n    unsigned IsExternC : 1;\n\n    /// Whether this is an exhaustive set of configuration macros.\n    unsigned IsExhaustive : 1;\n\n    /// Whether files in this module can only include non-modular headers\n    /// and headers from used modules.\n    unsigned NoUndeclaredIncludes : 1;\n\n    Attributes()\n        : IsSystem(false), IsExternC(false), IsExhaustive(false),\n          NoUndeclaredIncludes(false) {}\n  };\n\n  /// A directory for which framework modules can be inferred.\n  struct InferredDirectory {\n    /// Whether to infer modules from this directory.\n    unsigned InferModules : 1;\n\n    /// The attributes to use for inferred modules.\n    Attributes Attrs;\n\n    /// If \\c InferModules is non-zero, the module map file that allowed\n    /// inferred modules.  Otherwise, nullptr.\n    const FileEntry *ModuleMapFile;\n\n    /// The names of modules that cannot be inferred within this\n    /// directory.\n    SmallVector<std::string, 2> ExcludedModules;\n\n    InferredDirectory() : InferModules(false) {}\n  };\n\n  /// A mapping from directories to information about inferring\n  /// framework modules from within those directories.\n  llvm::DenseMap<const DirectoryEntry *, InferredDirectory> InferredDirectories;\n\n  /// A mapping from an inferred module to the module map that allowed the\n  /// inference.\n  llvm::DenseMap<const Module *, const FileEntry *> InferredModuleAllowedBy;\n\n  llvm::DenseMap<const Module *, AdditionalModMapsSet> AdditionalModMaps;\n\n  /// Describes whether we haved parsed a particular file as a module\n  /// map.\n  llvm::DenseMap<const FileEntry *, bool> ParsedModuleMap;\n\n  /// Resolve the given export declaration into an actual export\n  /// declaration.\n  ///\n  /// \\param Mod The module in which we're resolving the export declaration.\n  ///\n  /// \\param Unresolved The export declaration to resolve.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// exports.\n  ///\n  /// \\returns The resolved export declaration, which will have a NULL pointer\n  /// if the export could not be resolved.\n  Module::ExportDecl\n  resolveExport(Module *Mod, const Module::UnresolvedExportDecl &Unresolved,\n                bool Complain) const;\n\n  /// Resolve the given module id to an actual module.\n  ///\n  /// \\param Id The module-id to resolve.\n  ///\n  /// \\param Mod The module in which we're resolving the module-id.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// module-ids.\n  ///\n  /// \\returns The resolved module, or null if the module-id could not be\n  /// resolved.\n  Module *resolveModuleId(const ModuleId &Id, Module *Mod, bool Complain) const;\n\n  /// Add an unresolved header to a module.\n  ///\n  /// \\param Mod The module in which we're adding the unresolved header\n  ///        directive.\n  /// \\param Header The unresolved header directive.\n  /// \\param NeedsFramework If Mod is not a framework but a missing header would\n  ///        be found in case Mod was, set it to true. False otherwise.\n  void addUnresolvedHeader(Module *Mod,\n                           Module::UnresolvedHeaderDirective Header,\n                           bool &NeedsFramework);\n\n  /// Look up the given header directive to find an actual header file.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param RelativePathName Filled in with the relative path name from the\n  ///        module to the resolved header.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  /// \\return The resolved file, if any.\n  OptionalFileEntryRef\n  findHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n             SmallVectorImpl<char> &RelativePathName, bool &NeedsFramework);\n\n  /// Resolve the given header directive.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  void resolveHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n                     bool &NeedsFramework);\n\n  /// Attempt to resolve the specified header directive as naming a builtin\n  /// header.\n  /// \\return \\c true if a corresponding builtin header was found.\n  bool resolveAsBuiltinHeader(Module *M,\n                              const Module::UnresolvedHeaderDirective &Header);\n\n  /// Looks up the modules that \\p File corresponds to.\n  ///\n  /// If \\p File represents a builtin header within Clang's builtin include\n  /// directory, this also loads all of the module maps to see if it will get\n  /// associated with a specific module (e.g. in /usr/include).\n  HeadersMap::iterator findKnownHeader(const FileEntry *File);\n\n  /// Searches for a module whose umbrella directory contains \\p File.\n  ///\n  /// \\param File The header to search for.\n  ///\n  /// \\param IntermediateDirs On success, contains the set of directories\n  /// searched before finding \\p File.\n  KnownHeader findHeaderInUmbrellaDirs(\n      FileEntryRef File, SmallVectorImpl<DirectoryEntryRef> &IntermediateDirs);\n\n  /// Given that \\p File is not in the Headers map, look it up within\n  /// umbrella directories and find or create a module for it.\n  KnownHeader findOrCreateModuleForHeaderInUmbrellaDir(FileEntryRef File);\n\n  /// A convenience method to determine if \\p File is (possibly nested)\n  /// in an umbrella directory.\n  bool isHeaderInUmbrellaDirs(FileEntryRef File) {\n    SmallVector<DirectoryEntryRef, 2> IntermediateDirs;\n    return static_cast<bool>(findHeaderInUmbrellaDirs(File, IntermediateDirs));\n  }\n\n  Module *inferFrameworkModule(DirectoryEntryRef FrameworkDir, Attributes Attrs,\n                               Module *Parent);\n\npublic:\n  /// Construct a new module map.\n  ///\n  /// \\param SourceMgr The source manager used to find module files and headers.\n  /// This source manager should be shared with the header-search mechanism,\n  /// since they will refer to the same headers.\n  ///\n  /// \\param Diags A diagnostic engine used for diagnostics.\n  ///\n  /// \\param LangOpts Language options for this translation unit.\n  ///\n  /// \\param Target The target for this translation unit.\n  ModuleMap(SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n            const LangOptions &LangOpts, const TargetInfo *Target,\n            HeaderSearch &HeaderInfo);\n\n  /// Destroy the module map.\n  ~ModuleMap();\n\n  /// Set the target information.\n  void setTarget(const TargetInfo &Target);\n\n  /// Set the directory that contains Clang-supplied include\n  /// files, such as our stdarg.h or tgmath.h.\n  void setBuiltinIncludeDir(DirectoryEntryRef Dir) {\n    BuiltinIncludeDir = Dir;\n  }\n\n  /// Get the directory that contains Clang-supplied include files.\n  const DirectoryEntry *getBuiltinDir() const {\n    return BuiltinIncludeDir;\n  }\n\n  /// Is this a compiler builtin header?\n  static bool isBuiltinHeader(StringRef FileName);\n  bool isBuiltinHeader(const FileEntry *File);\n\n  /// Add a module map callback.\n  void addModuleMapCallbacks(std::unique_ptr<ModuleMapCallbacks> Callback) {\n    Callbacks.push_back(std::move(Callback));\n  }\n\n  /// Retrieve the module that owns the given header file, if any. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// \\param File The header file that is likely to be included.\n  ///\n  /// \\param AllowTextual If \\c true and \\p File is a textual header, return\n  /// its owning module. Otherwise, no KnownHeader will be returned if the\n  /// file is only known as a textual header.\n  ///\n  /// \\returns The module KnownHeader, which provides the module that owns the\n  /// given header file.  The KnownHeader is default constructed to indicate\n  /// that no module owns this header file.\n  KnownHeader findModuleForHeader(FileEntryRef File, bool AllowTextual = false,\n                                  bool AllowExcluded = false);\n\n  /// Retrieve all the modules that contain the given header file. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// Typically, \\ref findModuleForHeader should be used instead, as it picks\n  /// the preferred module for the header.\n  ArrayRef<KnownHeader> findAllModulesForHeader(FileEntryRef File);\n\n  /// Like \\ref findAllModulesForHeader, but do not attempt to infer module\n  /// ownership from umbrella headers if we've not already done so.\n  ArrayRef<KnownHeader>\n  findResolvedModulesForHeader(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified file.\n  ///\n  /// This ensures that the HeaderFileInfo on HeaderSearch is up to date. This\n  /// is effectively internal, but is exposed so HeaderSearch can call it.\n  void resolveHeaderDirectives(const FileEntry *File) const;\n\n  /// Resolve lazy header directives for the specified module. If File is\n  /// provided, only headers with same size and modtime are resolved. If File\n  /// is not set, all headers are resolved.\n  void resolveHeaderDirectives(Module *Mod,\n                               std::optional<const FileEntry *> File) const;\n\n  /// Reports errors if a module must not include a specific file.\n  ///\n  /// \\param RequestingModule The module including a file.\n  ///\n  /// \\param RequestingModuleIsModuleInterface \\c true if the inclusion is in\n  ///        the interface of RequestingModule, \\c false if it's in the\n  ///        implementation of RequestingModule. Value is ignored and\n  ///        meaningless if RequestingModule is nullptr.\n  ///\n  /// \\param FilenameLoc The location of the inclusion's filename.\n  ///\n  /// \\param Filename The included filename as written.\n  ///\n  /// \\param File The included file.\n  void diagnoseHeaderInclusion(Module *RequestingModule,\n                               bool RequestingModuleIsModuleInterface,\n                               SourceLocation FilenameLoc, StringRef Filename,\n                               FileEntryRef File);\n\n  /// Determine whether the given header is part of a module\n  /// marked 'unavailable'.\n  bool isHeaderInUnavailableModule(FileEntryRef Header) const;\n\n  /// Determine whether the given header is unavailable as part\n  /// of the specified module.\n  bool isHeaderUnavailableInModule(FileEntryRef Header,\n                                   const Module *RequestingModule) const;\n\n  /// Retrieve a module with the given name.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *findModule(StringRef Name) const;\n\n  /// Retrieve a module with the given name using lexical name lookup,\n  /// starting at the given context.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module context, from which we will perform lexical\n  /// name lookup.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *lookupModuleUnqualified(StringRef Name, Module *Context) const;\n\n  /// Retrieve a module with the given name within the given context,\n  /// using direct (qualified) name lookup.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module for which we will look for a submodule. If\n  /// null, we will look for a top-level module.\n  ///\n  /// \\returns The named submodule, if known; otherwose, returns null.\n  Module *lookupModuleQualified(StringRef Name, Module *Context) const;\n\n  /// Find a new module or submodule, or create it if it does not already\n  /// exist.\n  ///\n  /// \\param Name The name of the module to find or create.\n  ///\n  /// \\param Parent The module that will act as the parent of this submodule,\n  /// or nullptr to indicate that this is a top-level module.\n  ///\n  /// \\param IsFramework Whether this is a framework module.\n  ///\n  /// \\param IsExplicit Whether this is an explicit submodule.\n  ///\n  /// \\returns The found or newly-created module, along with a boolean value\n  /// that will be true if the module is newly-created.\n  std::pair<Module *, bool> findOrCreateModule(StringRef Name, Module *Parent,\n                                               bool IsFramework,\n                                               bool IsExplicit);\n\n  /// Create a global module fragment for a C++ module unit.\n  ///\n  /// We model the global module fragment as a submodule of the module\n  /// interface unit. Unfortunately, we can't create the module interface\n  /// unit's Module until later, because we don't know what it will be called\n  /// usually. See C++20 [module.unit]/7.2 for the case we could know its\n  /// parent.\n  Module *createGlobalModuleFragmentForModuleUnit(SourceLocation Loc,\n                                                  Module *Parent = nullptr);\n  Module *createImplicitGlobalModuleFragmentForModuleUnit(\n      SourceLocation Loc, bool IsExported, Module *Parent = nullptr);\n\n  /// Create a global module fragment for a C++ module interface unit.\n  Module *createPrivateModuleFragmentForInterfaceUnit(Module *Parent,\n                                                      SourceLocation Loc);\n\n  /// Create a new C++ module with the specified kind, and reparent any pending\n  /// global module fragment(s) to it.\n  Module *createModuleUnitWithKind(SourceLocation Loc, StringRef Name,\n                                   Module::ModuleKind Kind);\n\n  /// Create a new module for a C++ module interface unit.\n  /// The module must not already exist, and will be configured for the current\n  /// compilation.\n  ///\n  /// Note that this also sets the current module to the newly-created module.\n  ///\n  /// \\returns The newly-created module.\n  Module *createModuleForInterfaceUnit(SourceLocation Loc, StringRef Name);\n\n  /// Create a new module for a C++ module implementation unit.\n  /// The interface module for this implementation (implicitly imported) must\n  /// exist and be loaded and present in the modules map.\n  ///\n  /// \\returns The newly-created module.\n  Module *createModuleForImplementationUnit(SourceLocation Loc, StringRef Name);\n\n  /// Create a C++20 header unit.\n  Module *createHeaderUnit(SourceLocation Loc, StringRef Name,\n                           Module::Header H);\n\n  /// Infer the contents of a framework module map from the given\n  /// framework directory.\n  Module *inferFrameworkModule(DirectoryEntryRef FrameworkDir, bool IsSystem,\n                               Module *Parent);\n\n  /// Create a new top-level module that is shadowed by\n  /// \\p ShadowingModule.\n  Module *createShadowedModule(StringRef Name, bool IsFramework,\n                               Module *ShadowingModule);\n\n  /// Creates a new declaration scope for module names, allowing\n  /// previously defined modules to shadow definitions from the new scope.\n  ///\n  /// \\note Module names from earlier scopes will shadow names from the new\n  /// scope, which is the opposite of how shadowing works for variables.\n  void finishModuleDeclarationScope() { CurrentModuleScopeID += 1; }\n\n  bool mayShadowNewModule(Module *ExistingModule) {\n    assert(!ExistingModule->Parent && \"expected top-level module\");\n    assert(ModuleScopeIDs.count(ExistingModule) && \"unknown module\");\n    return ModuleScopeIDs[ExistingModule] < CurrentModuleScopeID;\n  }\n\n  /// Check whether a framework module can be inferred in the given directory.\n  bool canInferFrameworkModule(const DirectoryEntry *Dir) const {\n    auto It = InferredDirectories.find(Dir);\n    return It != InferredDirectories.end() && It->getSecond().InferModules;\n  }\n\n  /// Retrieve the module map file containing the definition of the given\n  /// module.\n  ///\n  /// \\param Module The module whose module map file will be returned, if known.\n  ///\n  /// \\returns The file entry for the module map file containing the given\n  /// module, or nullptr if the module definition was inferred.\n  OptionalFileEntryRef getContainingModuleMapFile(const Module *Module) const;\n\n  /// Get the module map file that (along with the module name) uniquely\n  /// identifies this module.\n  ///\n  /// The particular module that \\c Name refers to may depend on how the module\n  /// was found in header search. However, the combination of \\c Name and\n  /// this module map will be globally unique for top-level modules. In the case\n  /// of inferred modules, returns the module map that allowed the inference\n  /// (e.g. contained 'module *'). Otherwise, returns\n  /// getContainingModuleMapFile().\n  OptionalFileEntryRef getModuleMapFileForUniquing(const Module *M) const;\n\n  void setInferredModuleAllowedBy(Module *M, const FileEntry *ModMap);\n\n  /// Canonicalize \\p Path in a manner suitable for a module map file. In\n  /// particular, this canonicalizes the parent directory separately from the\n  /// filename so that it does not affect header resolution relative to the\n  /// modulemap.\n  ///\n  /// \\returns an error code if any filesystem operations failed. In this case\n  /// \\p Path is not modified.\n  std::error_code canonicalizeModuleMapPath(SmallVectorImpl<char> &Path);\n\n  /// Get any module map files other than getModuleMapFileForUniquing(M)\n  /// that define submodules of a top-level module \\p M. This is cheaper than\n  /// getting the module map file for each submodule individually, since the\n  /// expected number of results is very small.\n  AdditionalModMapsSet *getAdditionalModuleMapFiles(const Module *M) {\n    auto I = AdditionalModMaps.find(M);\n    if (I == AdditionalModMaps.end())\n      return nullptr;\n    return &I->second;\n  }\n\n  void addAdditionalModuleMapFile(const Module *M, const FileEntry *ModuleMap);\n\n  /// Resolve all of the unresolved exports in the given module.\n  ///\n  /// \\param Mod The module whose exports should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving exports,\n  /// false otherwise.\n  bool resolveExports(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved uses in the given module.\n  ///\n  /// \\param Mod The module whose uses should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving uses,\n  /// false otherwise.\n  bool resolveUses(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved conflicts in the given module.\n  ///\n  /// \\param Mod The module whose conflicts should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving conflicts,\n  /// false otherwise.\n  bool resolveConflicts(Module *Mod, bool Complain);\n\n  /// Sets the umbrella header of the given module to the given header.\n  void\n  setUmbrellaHeaderAsWritten(Module *Mod, FileEntryRef UmbrellaHeader,\n                             const Twine &NameAsWritten,\n                             const Twine &PathRelativeToRootModuleDirectory);\n\n  /// Sets the umbrella directory of the given module to the given directory.\n  void setUmbrellaDirAsWritten(Module *Mod, DirectoryEntryRef UmbrellaDir,\n                               const Twine &NameAsWritten,\n                               const Twine &PathRelativeToRootModuleDirectory);\n\n  /// Adds this header to the given module.\n  /// \\param Role The role of the header wrt the module.\n  void addHeader(Module *Mod, Module::Header Header,\n                 ModuleHeaderRole Role, bool Imported = false);\n\n  /// Parse the given module map file, and record any modules we\n  /// encounter.\n  ///\n  /// \\param File The file to be parsed.\n  ///\n  /// \\param IsSystem Whether this module map file is in a system header\n  /// directory, and therefore should be considered a system module.\n  ///\n  /// \\param HomeDir The directory in which relative paths within this module\n  ///        map file will be resolved.\n  ///\n  /// \\param ID The FileID of the file to process, if we've already entered it.\n  ///\n  /// \\param Offset [inout] On input the offset at which to start parsing. On\n  ///        output, the offset at which the module map terminated.\n  ///\n  /// \\param ExternModuleLoc The location of the \"extern module\" declaration\n  ///        that caused us to load this module map file, if any.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool parseModuleMapFile(const FileEntry *File, bool IsSystem,\n                          DirectoryEntryRef HomeDir, FileID ID = FileID(),\n                          unsigned *Offset = nullptr,\n                          SourceLocation ExternModuleLoc = SourceLocation());\n\n  /// Dump the contents of the module map, for debugging purposes.\n  void dump();\n\n  using module_iterator = llvm::StringMap<Module *>::const_iterator;\n\n  module_iterator module_begin() const { return Modules.begin(); }\n  module_iterator module_end()   const { return Modules.end(); }\n  llvm::iterator_range<module_iterator> modules() const {\n    return {module_begin(), module_end()};\n  }\n\n  /// Cache a module load.  M might be nullptr.\n  void cacheModuleLoad(const IdentifierInfo &II, Module *M) {\n    CachedModuleLoads[&II] = M;\n  }\n\n  /// Return a cached module load.\n  std::optional<Module *> getCachedModuleLoad(const IdentifierInfo &II) {\n    auto I = CachedModuleLoads.find(&II);\n    if (I == CachedModuleLoads.end())\n      return std::nullopt;\n    return I->second;\n  }\n}",
  "id": "BLOCK-CPP-18802",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/ModuleMap.h",
  "source_line": 74,
  "validation_status": "validated"
}