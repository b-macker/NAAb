{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// Historical note: Abseil once provided implementations of these\n// abstractions for platforms that had not yet provided them. Those\n// platforms are no longer supported. New code should simply use the\n// the ones from std directly.\nusing std::index_sequence;\nusing std::index_sequence_for;\nusing std::integer_sequence;\nusing std::make_index_sequence;\nusing std::make_integer_sequence;\n\nnamespace utility_internal {\n\ntemplate <typename T>\nstruct InPlaceTypeTag {\n  explicit InPlaceTypeTag() = delete;\n  InPlaceTypeTag(const InPlaceTypeTag&) = delete;\n  InPlaceTypeTag& operator=(const InPlaceTypeTag&) = delete;\n};\n\ntemplate <size_t I>\nstruct InPlaceIndexTag {\n  explicit InPlaceIndexTag() = delete;\n  InPlaceIndexTag(const InPlaceIndexTag&) = delete;\n  InPlaceIndexTag& operator=(const InPlaceIndexTag&) = delete;\n};\n\n}  // namespace utility_internal\n\n// Tag types\n\n#ifdef ABSL_USES_STD_OPTIONAL\n\nusing std::in_place_t;\nusing std::in_place;\n\n#else  // ABSL_USES_STD_OPTIONAL\n\n// in_place_t\n//\n// Tag type used to specify in-place construction, such as with\n// `absl::optional`, designed to be a drop-in replacement for C++17's\n// `std::in_place_t`.\nstruct in_place_t {};\n\nABSL_INTERNAL_INLINE_CONSTEXPR(in_place_t, in_place, {});\n\n#endif  // ABSL_USES_STD_OPTIONAL\n\n#if defined(ABSL_USES_STD_ANY) || defined(ABSL_USES_STD_VARIANT)\nusing std::in_place_type;\nusing std::in_place_type_t;\n#else\n\n// in_place_type_t\n//\n// Tag type used for in-place construction when the type to construct needs to\n// be specified, such as with `absl::any`, designed to be a drop-in replacement\n// for C++17's `std::in_place_type_t`.\ntemplate <typename T>\nusing in_place_type_t = void (*)(utility_internal::InPlaceTypeTag<T>);\n\ntemplate <typename T>\nvoid in_place_type(utility_internal::InPlaceTypeTag<T>) {}\n#endif  // ABSL_USES_STD_ANY || ABSL_USES_STD_VARIANT\n\n#ifdef ABSL_USES_STD_VARIANT\nusing std::in_place_index;\nusing std::in_place_index_t;\n#else\n\n// in_place_index_t\n//\n// Tag type used for in-place construction when the type to construct needs to\n// be specified, such as with `absl::any`, designed to be a drop-in replacement\n// for C++17's `std::in_place_index_t`.\ntemplate <size_t I>\nusing in_place_index_t = void (*)(utility_internal::InPlaceIndexTag<I>);\n\ntemplate <size_t I>\nvoid in_place_index(utility_internal::InPlaceIndexTag<I>) {}\n#endif  // ABSL_USES_STD_VARIANT\n\n// Constexpr move and forward\n\n// move()\n//\n// A constexpr version of `std::move()`, designed to be a drop-in replacement\n// for C++14's `std::move()`.\ntemplate <typename T>\nconstexpr absl::remove_reference_t<T>&& move(T&& t) noexcept {\n  return static_cast<absl::remove_reference_t<T>&&>(t);\n}\n\n// forward()\n//\n// A constexpr version of `std::forward()`, designed to be a drop-in replacement\n// for C++14's `std::forward()`.\ntemplate <typename T>\nconstexpr T&& forward(\n    absl::remove_reference_t<T>& t) noexcept {  // NOLINT(runtime/references)\n  return static_cast<T&&>(t);\n}\n\nnamespace utility_internal {\n// Helper method for expanding tuple into a called method.\ntemplate <typename Functor, typename Tuple, std::size_t... Indexes>\nauto apply_helper(Functor&& functor, Tuple&& t, index_sequence<Indexes...>)\n    -> decltype(absl::base_internal::invoke(\n        absl::forward<Functor>(functor),\n        std::get<Indexes>(absl::forward<Tuple>(t))...)) {\n  return absl::base_internal::invoke(\n      absl::forward<Functor>(functor),\n      std::get<Indexes>(absl::forward<Tuple>(t))...);\n}\n\n}  // namespace utility_internal\n\n// apply\n//\n// Invokes a Callable using elements of a tuple as its arguments.\n// Each element of the tuple corresponds to an argument of the call (in order).\n// Both the Callable argument and the tuple argument are perfect-forwarded.\n// For member-function Callables, the first tuple element acts as the `this`\n// pointer. `absl::apply` is designed to be a drop-in replacement for C++17's\n// `std::apply`. Unlike C++17's `std::apply`, this is not currently `constexpr`.\n//\n// Example:\n//\n//   class Foo {\n//    public:\n//     void Bar(int);\n//   };\n//   void user_function1(int, std::string);\n//   void user_function2(std::unique_ptr<Foo>);\n//   auto user_lambda = [](int, int) {};\n//\n//   int main()\n//   {\n//       std::tuple<int, std::string> tuple1(42, \"bar\");\n//       // Invokes the first user function on int, std::string.\n//       absl::apply(&user_function1, tuple1);\n//\n//       std::tuple<std::unique_ptr<Foo>> tuple2(absl::make_unique<Foo>());\n//       // Invokes the user function that takes ownership of the unique\n//       // pointer.\n//       absl::apply(&user_function2, std::move(tuple2));\n//\n//       auto foo = absl::make_unique<Foo>();\n//       std::tuple<Foo*, int> tuple3(foo.get(), 42);\n//       // Invokes the method Bar on foo with one argument, 42.\n//       absl::apply(&Foo::Bar, tuple3);\n//\n//       std::tuple<int, int> tuple4(8, 9);\n//       // Invokes a lambda.\n//       absl::apply(user_lambda, tuple4);\n//   }\ntemplate <typename Functor, typename Tuple>\nauto apply(Functor&& functor, Tuple&& t)\n    -> decltype(utility_internal::apply_helper(\n        absl::forward<Functor>(functor), absl::forward<Tuple>(t),\n        absl::make_index_sequence<std::tuple_size<\n            typename std::remove_reference<Tuple>::type>::value>{})) {\n  return utility_internal::apply_helper(\n      absl::forward<Functor>(functor), absl::forward<Tuple>(t),\n      absl::make_index_sequence<std::tuple_size<\n          typename std::remove_reference<Tuple>::type>::value>{});\n}\n\n// exchange\n//\n// Replaces the value of `obj` with `new_value` and returns the old value of\n// `obj`.  `absl::exchange` is designed to be a drop-in replacement for C++14's\n// `std::exchange`.\n//\n// Example:\n//\n//   Foo& operator=(Foo&& other) {\n//     ptr1_ = absl::exchange(other.ptr1_, nullptr);\n//     int1_ = absl::exchange(other.int1_, -1);\n//     return *this;\n//   }\ntemplate <typename T, typename U = T>\nT exchange(T& obj, U&& new_value) {\n  T old_value = absl::move(obj);\n  obj = absl::forward<U>(new_value);\n  return old_value;\n}\n\nnamespace utility_internal {\ntemplate <typename T, typename Tuple, size_t... I>\nT make_from_tuple_impl(Tuple&& tup, absl::index_sequence<I...>) {\n  return T(std::get<I>(std::forward<Tuple>(tup))...);\n}\n}  // namespace utility_internal\n\n// make_from_tuple\n//\n// Given the template parameter type `T` and a tuple of arguments\n// `std::tuple(arg0, arg1, ..., argN)` constructs an object of type `T` as if by\n// calling `T(arg0, arg1, ..., argN)`.\n//\n// Example:\n//\n//   std::tuple<const char*, size_t> args(\"hello world\", 5);\n//   auto s = absl::make_from_tuple<std::string>(args);\n//   assert(s == \"hello\");\n//\ntemplate <typename T, typename Tuple>\nconstexpr T make_from_tuple(Tuple&& tup) {\n  return utility_internal::make_from_tuple_impl<T>(\n      std::forward<Tuple>(tup),\n      absl::make_index_sequence<\n          std::tuple_size<absl::decay_t<Tuple>>::value>{});\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04552",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/utility/utility.h",
  "source_line": 47,
  "validation_status": "validated"
}