{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\nclass ABSL_LOCKABLE SpinLock {\n public:\n  SpinLock() : lockword_(kSpinLockCooperative) {\n    ABSL_TSAN_MUTEX_CREATE(this, __tsan_mutex_not_static);\n  }\n\n  // Constructors that allow non-cooperative spinlocks to be created for use\n  // inside thread schedulers.  Normal clients should not use these.\n  explicit SpinLock(base_internal::SchedulingMode mode);\n\n  // Constructor for global SpinLock instances.  See absl/base/const_init.h.\n  constexpr SpinLock(absl::ConstInitType, base_internal::SchedulingMode mode)\n      : lockword_(IsCooperative(mode) ? kSpinLockCooperative : 0) {}\n\n  // For global SpinLock instances prefer trivial destructor when possible.\n  // Default but non-trivial destructor in some build configurations causes an\n  // extra static initializer.\n#ifdef ABSL_INTERNAL_HAVE_TSAN_INTERFACE\n  ~SpinLock() { ABSL_TSAN_MUTEX_DESTROY(this, __tsan_mutex_not_static); }\n#else\n  ~SpinLock() = default;\n#endif\n\n  // Acquire this SpinLock.\n  inline void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    ABSL_TSAN_MUTEX_PRE_LOCK(this, 0);\n    if (!TryLockImpl()) {\n      SlowLock();\n    }\n    ABSL_TSAN_MUTEX_POST_LOCK(this, 0, 0);\n  }\n\n  // Try to acquire this SpinLock without blocking and return true if the\n  // acquisition was successful.  If the lock was not acquired, false is\n  // returned.  If this SpinLock is free at the time of the call, TryLock\n  // will return true with high probability.\n  inline bool TryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true) {\n    ABSL_TSAN_MUTEX_PRE_LOCK(this, __tsan_mutex_try_lock);\n    bool res = TryLockImpl();\n    ABSL_TSAN_MUTEX_POST_LOCK(\n        this, __tsan_mutex_try_lock | (res ? 0 : __tsan_mutex_try_lock_failed),\n        0);\n    return res;\n  }\n\n  // Release this SpinLock, which must be held by the calling thread.\n  inline void Unlock() ABSL_UNLOCK_FUNCTION() {\n    ABSL_TSAN_MUTEX_PRE_UNLOCK(this, 0);\n    uint32_t lock_value = lockword_.load(std::memory_order_relaxed);\n    lock_value = lockword_.exchange(lock_value & kSpinLockCooperative,\n                                    std::memory_order_release);\n\n    if ((lock_value & kSpinLockDisabledScheduling) != 0) {\n      base_internal::SchedulingGuard::EnableRescheduling(true);\n    }\n    if ((lock_value & kWaitTimeMask) != 0) {\n      // Collect contentionz profile info, and speed the wakeup of any waiter.\n      // The wait_cycles value indicates how long this thread spent waiting\n      // for the lock.\n      SlowUnlock(lock_value);\n    }\n    ABSL_TSAN_MUTEX_POST_UNLOCK(this, 0);\n  }\n\n  // Determine if the lock is held.  When the lock is held by the invoking\n  // thread, true will always be returned. Intended to be used as\n  // CHECK(lock.IsHeld()).\n  inline bool IsHeld() const {\n    return (lockword_.load(std::memory_order_relaxed) & kSpinLockHeld) != 0;\n  }\n\n  // Return immediately if this thread holds the SpinLock exclusively.\n  // Otherwise, report an error by crashing with a diagnostic.\n  inline void AssertHeld() const ABSL_ASSERT_EXCLUSIVE_LOCK() {\n    if (!IsHeld()) {\n      ABSL_RAW_LOG(FATAL, \"thread should hold the lock on SpinLock\");\n    }\n  }\n\n protected:\n  // These should not be exported except for testing.\n\n  // Store number of cycles between wait_start_time and wait_end_time in a\n  // lock value.\n  static uint32_t EncodeWaitCycles(int64_t wait_start_time,\n                                   int64_t wait_end_time);\n\n  // Extract number of wait cycles in a lock value.\n  static int64_t DecodeWaitCycles(uint32_t lock_value);\n\n  // Provide access to protected method above.  Use for testing only.\n  friend struct SpinLockTest;\n  friend class tcmalloc::tcmalloc_internal::AllocationGuardSpinLockHolder;\n\n private:\n  // lockword_ is used to store the following:\n  //\n  // bit[0] encodes whether a lock is being held.\n  // bit[1] encodes whether a lock uses cooperative scheduling.\n  // bit[2] encodes whether the current lock holder disabled scheduling when\n  //        acquiring the lock. Only set when kSpinLockHeld is also set.\n  // bit[3:31] encodes time a lock spent on waiting as a 29-bit unsigned int.\n  //        This is set by the lock holder to indicate how long it waited on\n  //        the lock before eventually acquiring it. The number of cycles is\n  //        encoded as a 29-bit unsigned int, or in the case that the current\n  //        holder did not wait but another waiter is queued, the LSB\n  //        (kSpinLockSleeper) is set. The implementation does not explicitly\n  //        track the number of queued waiters beyond this. It must always be\n  //        assumed that waiters may exist if the current holder was required to\n  //        queue.\n  //\n  // Invariant: if the lock is not held, the value is either 0 or\n  // kSpinLockCooperative.\n  static constexpr uint32_t kSpinLockHeld = 1;\n  static constexpr uint32_t kSpinLockCooperative = 2;\n  static constexpr uint32_t kSpinLockDisabledScheduling = 4;\n  static constexpr uint32_t kSpinLockSleeper = 8;\n  // Includes kSpinLockSleeper.\n  static constexpr uint32_t kWaitTimeMask =\n      ~(kSpinLockHeld | kSpinLockCooperative | kSpinLockDisabledScheduling);\n\n  // Returns true if the provided scheduling mode is cooperative.\n  static constexpr bool IsCooperative(\n      base_internal::SchedulingMode scheduling_mode) {\n    return scheduling_mode == base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL;\n  }\n\n  bool IsCooperative() const {\n    return lockword_.load(std::memory_order_relaxed) & kSpinLockCooperative;\n  }\n\n  uint32_t TryLockInternal(uint32_t lock_value, uint32_t wait_cycles);\n  void SlowLock() ABSL_ATTRIBUTE_COLD;\n  void SlowUnlock(uint32_t lock_value) ABSL_ATTRIBUTE_COLD;\n  uint32_t SpinLoop();\n\n  inline bool TryLockImpl() {\n    uint32_t lock_value = lockword_.load(std::memory_order_relaxed);\n    return (TryLockInternal(lock_value, 0) & kSpinLockHeld) == 0;\n  }\n\n  std::atomic<uint32_t> lockword_;\n\n  SpinLock(const SpinLock&) = delete;\n  SpinLock& operator=(const SpinLock&) = delete;\n};\n\n// Corresponding locker object that arranges to acquire a spinlock for\n// the duration of a C++ scope.\nclass ABSL_SCOPED_LOCKABLE SpinLockHolder {\n public:\n  inline explicit SpinLockHolder(SpinLock* l) ABSL_EXCLUSIVE_LOCK_FUNCTION(l)\n      : lock_(l) {\n    l->Lock();\n  }\n  inline ~SpinLockHolder() ABSL_UNLOCK_FUNCTION() { lock_->Unlock(); }\n\n  SpinLockHolder(const SpinLockHolder&) = delete;\n  SpinLockHolder& operator=(const SpinLockHolder&) = delete;\n\n private:\n  SpinLock* lock_;\n};\n\n// Register a hook for profiling support.\n//\n// The function pointer registered here will be called whenever a spinlock is\n// contended.  The callback is given an opaque handle to the contended spinlock\n// and the number of wait cycles.  This is thread-safe, but only a single\n// profiler can be registered.  It is an error to call this function multiple\n// times with different arguments.\nvoid RegisterSpinLockProfiler(void (*fn)(const void* lock,\n                                         int64_t wait_cycles));\n\n//------------------------------------------------------------------------------\n// Public interface ends here.\n//------------------------------------------------------------------------------\n\n// If (result & kSpinLockHeld) == 0, then *this was successfully locked.\n// Otherwise, returns last observed value for lockword_.\ninline uint32_t SpinLock::TryLockInternal(uint32_t lock_value,\n                                          uint32_t wait_cycles) {\n  if ((lock_value & kSpinLockHeld) != 0) {\n    return lock_value;\n  }\n\n  uint32_t sched_disabled_bit = 0;\n  if ((lock_value & kSpinLockCooperative) == 0) {\n    // For non-cooperative locks we must make sure we mark ourselves as\n    // non-reschedulable before we attempt to CompareAndSwap.\n    if (base_internal::SchedulingGuard::DisableRescheduling()) {\n      sched_disabled_bit = kSpinLockDisabledScheduling;\n    }\n  }\n\n  if (!lockword_.compare_exchange_strong(\n          lock_value,\n          kSpinLockHeld | lock_value | wait_cycles | sched_disabled_bit,\n          std::memory_order_acquire, std::memory_order_relaxed)) {\n    base_internal::SchedulingGuard::EnableRescheduling(sched_disabled_bit != 0);\n  }\n\n  return lock_value;\n}\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04719",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/spinlock.h",
  "source_line": 52,
  "validation_status": "validated"
}