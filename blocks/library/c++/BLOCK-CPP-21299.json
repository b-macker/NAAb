{
  "code": "#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/ASTMatchers/ASTMatchersInternal.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include <memory>\n#include <optional>\n#include <vector>\n\nusing namespace clang;\nusing namespace ast_matchers;\nusing namespace dynamic;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21299_execute() {\n    {\n  /// Methods that depend on T from hasTypedMatcher/getTypedMatcher.\n  class MatcherOps {\n  public:\n    MatcherOps(ASTNodeKind NodeKind) : NodeKind(NodeKind) {}\n\n    bool canConstructFrom(const DynTypedMatcher &Matcher,\n                          bool &IsExactMatch) const;\n\n    /// Convert \\p Matcher the destination type and return it as a new\n    /// DynTypedMatcher.\n    DynTypedMatcher convertMatcher(const DynTypedMatcher &Matcher) const;\n\n    /// Constructs a variadic typed matcher from \\p InnerMatchers.\n    /// Will try to convert each inner matcher to the destination type and\n    /// return std::nullopt if it fails to do so.\n    std::optional<DynTypedMatcher>\n    constructVariadicOperator(DynTypedMatcher::VariadicOperator Op,\n                              ArrayRef<VariantMatcher> InnerMatchers) const;\n\n  private:\n    ASTNodeKind NodeKind;\n  };\n\n  /// Payload interface to be specialized by each matcher type.\n  ///\n  /// It follows a similar interface as VariantMatcher itself.\n  class Payload {\n  public:\n    virtual ~Payload();\n    virtual std::optional<DynTypedMatcher> getSingleMatcher() const = 0;\n    virtual std::string getTypeAsString() const = 0;\n    virtual std::optional<DynTypedMatcher>\n    getTypedMatcher(const MatcherOps &Ops) const = 0;\n    virtual bool isConvertibleTo(ASTNodeKind Kind,\n                                 unsigned *Specificity) const = 0;\n  };\n\npublic:\n  /// A null matcher.\n  VariantMatcher();\n\n  /// Clones the provided matcher.\n  static VariantMatcher SingleMatcher(const DynTypedMatcher &Matcher);\n\n  /// Clones the provided matchers.\n  ///\n  /// They should be the result of a polymorphic matcher.\n  static VariantMatcher\n  PolymorphicMatcher(std::vector<DynTypedMatcher> Matchers);\n\n  /// Creates a 'variadic' operator matcher.\n  ///\n  /// It will bind to the appropriate type on getTypedMatcher<T>().\n  static VariantMatcher\n  VariadicOperatorMatcher(DynTypedMatcher::VariadicOperator Op,\n                          std::vector<VariantMatcher> Args);\n\n  /// Makes the matcher the \"null\" matcher.\n  void reset();\n\n  /// Whether the matcher is null.\n  bool isNull() const { return !Value; }\n\n  /// Return a single matcher, if there is no ambiguity.\n  ///\n  /// \\returns the matcher, if there is only one matcher. An empty Optional, if\n  /// the underlying matcher is a polymorphic matcher with more than one\n  /// representation.\n  std::optional<DynTypedMatcher> getSingleMatcher() const;\n\n  /// Determines if the contained matcher can be converted to\n  ///   \\c Matcher<T>.\n  ///\n  /// For the Single case, it returns true if it can be converted to\n  /// \\c Matcher<T>.\n  /// For the Polymorphic case, it returns true if one, and only one, of the\n  /// overloads can be converted to \\c Matcher<T>. If there are more than one\n  /// that can, the result would be ambiguous and false is returned.\n  template <class T>\n  bool hasTypedMatcher() const {\n    return hasTypedMatcher(ASTNodeKind::getFromNodeKind<T>());\n  }\n\n  bool hasTypedMatcher(ASTNodeKind NK) const {\n    if (!Value) return false;\n    return Value->getTypedMatcher(MatcherOps(NK)).has_value();\n  }\n\n  /// Determines if the contained matcher can be converted to \\p Kind.\n  ///\n  /// \\param Kind the requested destination type.\n  ///\n  /// \\param Specificity value corresponding to the \"specificity\" of the\n  ///   conversion.\n  bool isConvertibleTo(ASTNodeKind Kind, unsigned *Specificity) const {\n    if (Value)\n      return Value->isConvertibleTo(Kind, Specificity);\n    return false;\n  }\n\n  /// Return this matcher as a \\c Matcher<T>.\n  ///\n  /// Handles the different types (Single, Polymorphic) accordingly.\n  /// Asserts that \\c hasTypedMatcher<T>() is true.\n  template <class T>\n  ast_matchers::internal::Matcher<T> getTypedMatcher() const {\n    assert(hasTypedMatcher<T>() && \"hasTypedMatcher<T>() == false\");\n    return Value->getTypedMatcher(MatcherOps(ASTNodeKind::getFromNodeKind<T>()))\n        ->template convertTo<T>();\n  }\n\n  DynTypedMatcher getTypedMatcher(ASTNodeKind NK) const {\n    assert(hasTypedMatcher(NK) && \"hasTypedMatcher(NK) == false\");\n    return *Value->getTypedMatcher(MatcherOps(NK));\n  }\n\n  /// String representation of the type of the value.\n  ///\n  /// If the underlying matcher is a polymorphic one, the string will show all\n  /// the types.\n  std::string getTypeAsString() const;\n\nprivate:\n  explicit VariantMatcher(std::shared_ptr<Payload> Value)\n      : Value(std::move(Value)) {}\n\n\n  class SinglePayload;\n  class PolymorphicPayload;\n  class VariadicOpPayload;\n\n  std::shared_ptr<const Payload> Value;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21299",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/Dynamic/VariantValue.h",
  "source_line": 105,
  "validation_status": "validated"
}