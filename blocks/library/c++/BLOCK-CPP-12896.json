{
  "code": "{\npublic:\n  /// The different capture forms: by 'this', by reference, capture for\n  /// variable-length array type etc.\n  enum VariableCaptureKind {\n    VCK_This,\n    VCK_ByRef,\n    VCK_ByCopy,\n    VCK_VLAType,\n  };\n\n  /// Describes the capture of either a variable, or 'this', or\n  /// variable-length array type.\n  class Capture {\n    llvm::PointerIntPair<VarDecl *, 2, VariableCaptureKind> VarAndKind;\n    SourceLocation Loc;\n\n    Capture() = default;\n\n  public:\n    friend class ASTStmtReader;\n    friend class CapturedStmt;\n\n    /// Create a new capture.\n    ///\n    /// \\param Loc The source location associated with this capture.\n    ///\n    /// \\param Kind The kind of capture (this, ByRef, ...).\n    ///\n    /// \\param Var The variable being captured, or null if capturing this.\n    Capture(SourceLocation Loc, VariableCaptureKind Kind,\n            VarDecl *Var = nullptr);\n\n    /// Determine the kind of capture.\n    VariableCaptureKind getCaptureKind() const;\n\n    /// Retrieve the source location at which the variable or 'this' was\n    /// first used.\n    SourceLocation getLocation() const { return Loc; }\n\n    /// Determine whether this capture handles the C++ 'this' pointer.\n    bool capturesThis() const { return getCaptureKind() == VCK_This; }\n\n    /// Determine whether this capture handles a variable (by reference).\n    bool capturesVariable() const { return getCaptureKind() == VCK_ByRef; }\n\n    /// Determine whether this capture handles a variable by copy.\n    bool capturesVariableByCopy() const {\n      return getCaptureKind() == VCK_ByCopy;\n    }\n\n    /// Determine whether this capture handles a variable-length array\n    /// type.\n    bool capturesVariableArrayType() const {\n      return getCaptureKind() == VCK_VLAType;\n    }\n\n    /// Retrieve the declaration of the variable being captured.\n    ///\n    /// This operation is only valid if this capture captures a variable.\n    VarDecl *getCapturedVar() const;\n  };\n\nprivate:\n  /// The number of variable captured, including 'this'.\n  unsigned NumCaptures;\n\n  /// The pointer part is the implicit the outlined function and the\n  /// int part is the captured region kind, 'CR_Default' etc.\n  llvm::PointerIntPair<CapturedDecl *, 2, CapturedRegionKind> CapDeclAndKind;\n\n  /// The record for captured variables, a RecordDecl or CXXRecordDecl.\n  RecordDecl *TheRecordDecl = nullptr;\n\n  /// Construct a captured statement.\n  CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,\n               ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);\n\n  /// Construct an empty captured statement.\n  CapturedStmt(EmptyShell Empty, unsigned NumCaptures);\n\n  Stmt **getStoredStmts() { return reinterpret_cast<Stmt **>(this + 1); }\n\n  Stmt *const *getStoredStmts() const {\n    return reinterpret_cast<Stmt *const *>(this + 1);\n  }\n\n  Capture *getStoredCaptures() const;\n\n  void setCapturedStmt(Stmt *S) { getStoredStmts()[NumCaptures] = S; }\n\npublic:\n  friend class ASTStmtReader;\n\n  static CapturedStmt *Create(const ASTContext &Context, Stmt *S,\n                              CapturedRegionKind Kind,\n                              ArrayRef<Capture> Captures,\n                              ArrayRef<Expr *> CaptureInits,\n                              CapturedDecl *CD, RecordDecl *RD);\n\n  static CapturedStmt *CreateDeserialized(const ASTContext &Context,\n                                          unsigned NumCaptures);\n\n  /// Retrieve the statement being captured.\n  Stmt *getCapturedStmt() { return getStoredStmts()[NumCaptures]; }\n  const Stmt *getCapturedStmt() const { return getStoredStmts()[NumCaptures]; }\n\n  /// Retrieve the outlined function declaration.\n  CapturedDecl *getCapturedDecl();\n  const CapturedDecl *getCapturedDecl() const;\n\n  /// Set the outlined function declaration.\n  void setCapturedDecl(CapturedDecl *D);\n\n  /// Retrieve the captured region kind.\n  CapturedRegionKind getCapturedRegionKind() const;\n\n  /// Set the captured region kind.\n  void setCapturedRegionKind(CapturedRegionKind Kind);\n\n  /// Retrieve the record declaration for captured variables.\n  const RecordDecl *getCapturedRecordDecl() const { return TheRecordDecl; }\n\n  /// Set the record declaration for captured variables.\n  void setCapturedRecordDecl(RecordDecl *D) {\n    assert(D && \"null RecordDecl\");\n    TheRecordDecl = D;\n  }\n\n  /// True if this variable has been captured.\n  bool capturesVariable(const VarDecl *Var) const;\n\n  /// An iterator that walks over the captures.\n  using capture_iterator = Capture *;\n  using const_capture_iterator = const Capture *;\n  using capture_range = llvm::iterator_range<capture_iterator>;\n  using capture_const_range = llvm::iterator_range<const_capture_iterator>;\n\n  capture_range captures() {\n    return capture_range(capture_begin(), capture_end());\n  }\n  capture_const_range captures() const {\n    return capture_const_range(capture_begin(), capture_end());\n  }\n\n  /// Retrieve an iterator pointing to the first capture.\n  capture_iterator capture_begin() { return getStoredCaptures(); }\n  const_capture_iterator capture_begin() const { return getStoredCaptures(); }\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// captures.\n  capture_iterator capture_end() const {\n    return getStoredCaptures() + NumCaptures;\n  }\n\n  /// Retrieve the number of captures, including 'this'.\n  unsigned capture_size() const { return NumCaptures; }\n\n  /// Iterator that walks over the capture initialization arguments.\n  using capture_init_iterator = Expr **;\n  using capture_init_range = llvm::iterator_range<capture_init_iterator>;\n\n  /// Const iterator that walks over the capture initialization\n  /// arguments.\n  using const_capture_init_iterator = Expr *const *;\n  using const_capture_init_range =\n      llvm::iterator_range<const_capture_init_iterator>;\n\n  capture_init_range capture_inits() {\n    return capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  const_capture_init_range capture_inits() const {\n    return const_capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the first initialization argument.\n  capture_init_iterator capture_init_begin() {\n    return reinterpret_cast<Expr **>(getStoredStmts());\n  }\n\n  const_capture_init_iterator capture_init_begin() const {\n    return reinterpret_cast<Expr *const *>(getStoredStmts());\n  }\n\n  /// Retrieve the iterator pointing one past the last initialization\n  /// argument.\n  capture_init_iterator capture_init_end() {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  const_capture_init_iterator capture_init_end() const {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return getCapturedStmt()->getSourceRange();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CapturedStmtClass;\n  }\n\n  child_range children();\n\n  const_child_range children() const;\n}",
  "id": "BLOCK-CPP-12896",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Stmt.h",
  "source_line": 3578,
  "validation_status": "validated"
}