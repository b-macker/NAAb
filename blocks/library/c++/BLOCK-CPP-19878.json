{
  "code": "{\npublic:\n  /// Describes the kind of initialization sequence computed.\n  enum SequenceKind {\n    /// A failed initialization sequence. The failure kind tells what\n    /// happened.\n    FailedSequence = 0,\n\n    /// A dependent initialization, which could not be\n    /// type-checked due to the presence of dependent types or\n    /// dependently-typed expressions.\n    DependentSequence,\n\n    /// A normal sequence.\n    NormalSequence\n  };\n\n  /// Describes the kind of a particular step in an initialization\n  /// sequence.\n  enum StepKind {\n    /// Resolve the address of an overloaded function to a specific\n    /// function declaration.\n    SK_ResolveAddressOfOverloadedFunction,\n\n    /// Perform a derived-to-base cast, producing an rvalue.\n    SK_CastDerivedToBasePRValue,\n\n    /// Perform a derived-to-base cast, producing an xvalue.\n    SK_CastDerivedToBaseXValue,\n\n    /// Perform a derived-to-base cast, producing an lvalue.\n    SK_CastDerivedToBaseLValue,\n\n    /// Reference binding to an lvalue.\n    SK_BindReference,\n\n    /// Reference binding to a temporary.\n    SK_BindReferenceToTemporary,\n\n    /// An optional copy of a temporary object to another\n    /// temporary object, which is permitted (but not required) by\n    /// C++98/03 but not C++0x.\n    SK_ExtraneousCopyToTemporary,\n\n    /// Direct-initialization from a reference-related object in the\n    /// final stage of class copy-initialization.\n    SK_FinalCopy,\n\n    /// Perform a user-defined conversion, either via a conversion\n    /// function or via a constructor.\n    SK_UserConversion,\n\n    /// Perform a qualification conversion, producing a prvalue.\n    SK_QualificationConversionPRValue,\n\n    /// Perform a qualification conversion, producing an xvalue.\n    SK_QualificationConversionXValue,\n\n    /// Perform a qualification conversion, producing an lvalue.\n    SK_QualificationConversionLValue,\n\n    /// Perform a function reference conversion, see [dcl.init.ref]p4.\n    SK_FunctionReferenceConversion,\n\n    /// Perform a conversion adding _Atomic to a type.\n    SK_AtomicConversion,\n\n    /// Perform an implicit conversion sequence.\n    SK_ConversionSequence,\n\n    /// Perform an implicit conversion sequence without narrowing.\n    SK_ConversionSequenceNoNarrowing,\n\n    /// Perform list-initialization without a constructor.\n    SK_ListInitialization,\n\n    /// Unwrap the single-element initializer list for a reference.\n    SK_UnwrapInitList,\n\n    /// Rewrap the single-element initializer list for a reference.\n    SK_RewrapInitList,\n\n    /// Perform initialization via a constructor.\n    SK_ConstructorInitialization,\n\n    /// Perform initialization via a constructor, taking arguments from\n    /// a single InitListExpr.\n    SK_ConstructorInitializationFromList,\n\n    /// Zero-initialize the object\n    SK_ZeroInitialization,\n\n    /// C assignment\n    SK_CAssignment,\n\n    /// Initialization by string\n    SK_StringInit,\n\n    /// An initialization that \"converts\" an Objective-C object\n    /// (not a point to an object) to another Objective-C object type.\n    SK_ObjCObjectConversion,\n\n    /// Array indexing for initialization by elementwise copy.\n    SK_ArrayLoopIndex,\n\n    /// Array initialization by elementwise copy.\n    SK_ArrayLoopInit,\n\n    /// Array initialization (from an array rvalue).\n    SK_ArrayInit,\n\n    /// Array initialization (from an array rvalue) as a GNU extension.\n    SK_GNUArrayInit,\n\n    /// Array initialization from a parenthesized initializer list.\n    /// This is a GNU C++ extension.\n    SK_ParenthesizedArrayInit,\n\n    /// Pass an object by indirect copy-and-restore.\n    SK_PassByIndirectCopyRestore,\n\n    /// Pass an object by indirect restore.\n    SK_PassByIndirectRestore,\n\n    /// Produce an Objective-C object pointer.\n    SK_ProduceObjCObject,\n\n    /// Construct a std::initializer_list from an initializer list.\n    SK_StdInitializerList,\n\n    /// Perform initialization via a constructor taking a single\n    /// std::initializer_list argument.\n    SK_StdInitializerListConstructorCall,\n\n    /// Initialize an OpenCL sampler from an integer.\n    SK_OCLSamplerInit,\n\n    /// Initialize an opaque OpenCL type (event_t, queue_t, etc.) with zero\n    SK_OCLZeroOpaqueType,\n\n    /// Initialize an aggreagate with parenthesized list of values.\n    /// This is a C++20 feature.\n    SK_ParenthesizedListInit\n  };\n\n  /// A single step in the initialization sequence.\n  class Step {\n  public:\n    /// The kind of conversion or initialization step we are taking.\n    StepKind Kind;\n\n    // The type that results from this initialization.\n    QualType Type;\n\n    struct F {\n      bool HadMultipleCandidates;\n      FunctionDecl *Function;\n      DeclAccessPair FoundDecl;\n    };\n\n    union {\n      /// When Kind == SK_ResolvedOverloadedFunction or Kind ==\n      /// SK_UserConversion, the function that the expression should be\n      /// resolved to or the conversion function to call, respectively.\n      /// When Kind == SK_ConstructorInitialization or SK_ListConstruction,\n      /// the constructor to be called.\n      ///\n      /// Always a FunctionDecl, plus a Boolean flag telling if it was\n      /// selected from an overloaded set having size greater than 1.\n      /// For conversion decls, the naming class is the source type.\n      /// For construct decls, the naming class is the target type.\n      struct F Function;\n\n      /// When Kind = SK_ConversionSequence, the implicit conversion\n      /// sequence.\n      ImplicitConversionSequence *ICS;\n\n      /// When Kind = SK_RewrapInitList, the syntactic form of the\n      /// wrapping list.\n      InitListExpr *WrappingSyntacticList;\n    };\n\n    void Destroy();\n  };\n\nprivate:\n  /// The kind of initialization sequence computed.\n  enum SequenceKind SequenceKind;\n\n  /// Steps taken by this initialization.\n  SmallVector<Step, 4> Steps;\n\npublic:\n  /// Describes why initialization failed.\n  enum FailureKind {\n    /// Too many initializers provided for a reference.\n    FK_TooManyInitsForReference,\n\n    /// Reference initialized from a parenthesized initializer list.\n    FK_ParenthesizedListInitForReference,\n\n    /// Array must be initialized with an initializer list.\n    FK_ArrayNeedsInitList,\n\n    /// Array must be initialized with an initializer list or a\n    /// string literal.\n    FK_ArrayNeedsInitListOrStringLiteral,\n\n    /// Array must be initialized with an initializer list or a\n    /// wide string literal.\n    FK_ArrayNeedsInitListOrWideStringLiteral,\n\n    /// Initializing a wide char array with narrow string literal.\n    FK_NarrowStringIntoWideCharArray,\n\n    /// Initializing char array with wide string literal.\n    FK_WideStringIntoCharArray,\n\n    /// Initializing wide char array with incompatible wide string\n    /// literal.\n    FK_IncompatWideStringIntoWideChar,\n\n    /// Initializing char8_t array with plain string literal.\n    FK_PlainStringIntoUTF8Char,\n\n    /// Initializing char array with UTF-8 string literal.\n    FK_UTF8StringIntoPlainChar,\n\n    /// Array type mismatch.\n    FK_ArrayTypeMismatch,\n\n    /// Non-constant array initializer\n    FK_NonConstantArrayInit,\n\n    /// Cannot resolve the address of an overloaded function.\n    FK_AddressOfOverloadFailed,\n\n    /// Overloading due to reference initialization failed.\n    FK_ReferenceInitOverloadFailed,\n\n    /// Non-const lvalue reference binding to a temporary.\n    FK_NonConstLValueReferenceBindingToTemporary,\n\n    /// Non-const lvalue reference binding to a bit-field.\n    FK_NonConstLValueReferenceBindingToBitfield,\n\n    /// Non-const lvalue reference binding to a vector element.\n    FK_NonConstLValueReferenceBindingToVectorElement,\n\n    /// Non-const lvalue reference binding to a matrix element.\n    FK_NonConstLValueReferenceBindingToMatrixElement,\n\n    /// Non-const lvalue reference binding to an lvalue of unrelated\n    /// type.\n    FK_NonConstLValueReferenceBindingToUnrelated,\n\n    /// Rvalue reference binding to an lvalue.\n    FK_RValueReferenceBindingToLValue,\n\n    /// Reference binding drops qualifiers.\n    FK_ReferenceInitDropsQualifiers,\n\n    /// Reference with mismatching address space binding to temporary.\n    FK_ReferenceAddrspaceMismatchTemporary,\n\n    /// Reference binding failed.\n    FK_ReferenceInitFailed,\n\n    /// Implicit conversion failed.\n    FK_ConversionFailed,\n\n    /// Implicit conversion failed.\n    FK_ConversionFromPropertyFailed,\n\n    /// Too many initializers for scalar\n    FK_TooManyInitsForScalar,\n\n    /// Scalar initialized from a parenthesized initializer list.\n    FK_ParenthesizedListInitForScalar,\n\n    /// Reference initialization from an initializer list\n    FK_ReferenceBindingToInitList,\n\n    /// Initialization of some unused destination type with an\n    /// initializer list.\n    FK_InitListBadDestinationType,\n\n    /// Overloading for a user-defined conversion failed.\n    FK_UserConversionOverloadFailed,\n\n    /// Overloading for initialization by constructor failed.\n    FK_ConstructorOverloadFailed,\n\n    /// Overloading for list-initialization by constructor failed.\n    FK_ListConstructorOverloadFailed,\n\n    /// Default-initialization of a 'const' object.\n    FK_DefaultInitOfConst,\n\n    /// Initialization of an incomplete type.\n    FK_Incomplete,\n\n    /// Variable-length array must not have an initializer.\n    FK_VariableLengthArrayHasInitializer,\n\n    /// List initialization failed at some point.\n    FK_ListInitializationFailed,\n\n    /// Initializer has a placeholder type which cannot be\n    /// resolved by initialization.\n    FK_PlaceholderType,\n\n    /// Trying to take the address of a function that doesn't support\n    /// having its address taken.\n    FK_AddressOfUnaddressableFunction,\n\n    /// List-copy-initialization chose an explicit constructor.\n    FK_ExplicitConstructor,\n\n    /// Parenthesized list initialization failed at some point.\n    /// This is a C++20 feature.\n    FK_ParenthesizedListInitFailed,\n\n    // A designated initializer was provided for a non-aggregate type.\n    FK_DesignatedInitForNonAggregate,\n  };\n\nprivate:\n  /// The reason why initialization failed.\n  FailureKind Failure;\n\n  /// The failed result of overload resolution.\n  OverloadingResult FailedOverloadResult;\n\n  /// The candidate set created when initialization failed.\n  OverloadCandidateSet FailedCandidateSet;\n\n  /// The incomplete type that caused a failure.\n  QualType FailedIncompleteType;\n\n  /// The fixit that needs to be applied to make this initialization\n  /// succeed.\n  std::string ZeroInitializationFixit;\n  SourceLocation ZeroInitializationFixitLoc;\n\npublic:\n  /// Call for initializations are invalid but that would be valid\n  /// zero initialzations if Fixit was applied.\n  void SetZeroInitializationFixit(const std::string& Fixit, SourceLocation L) {\n    ZeroInitializationFixit = Fixit;\n    ZeroInitializationFixitLoc = L;\n  }\n\nprivate:\n  /// Prints a follow-up note that highlights the location of\n  /// the initialized entity, if it's remote.\n  void PrintInitLocationNote(Sema &S, const InitializedEntity &Entity);\n\npublic:\n  /// Try to perform initialization of the given entity, creating a\n  /// record of the steps required to perform the initialization.\n  ///\n  /// The generated initialization sequence will either contain enough\n  /// information to diagnose\n  ///\n  /// \\param S the semantic analysis object.\n  ///\n  /// \\param Entity the entity being initialized.\n  ///\n  /// \\param Kind the kind of initialization being performed.\n  ///\n  /// \\param Args the argument(s) provided for initialization.\n  ///\n  /// \\param TopLevelOfInitList true if we are initializing from an expression\n  ///        at the top level inside an initializer list. This disallows\n  ///        narrowing conversions in C++11 onwards.\n  /// \\param TreatUnavailableAsInvalid true if we want to treat unavailable\n  ///        as invalid.\n  InitializationSequence(Sema &S,\n                         const InitializedEntity &Entity,\n                         const InitializationKind &Kind,\n                         MultiExprArg Args,\n                         bool TopLevelOfInitList = false,\n                         bool TreatUnavailableAsInvalid = true);\n  void InitializeFrom(Sema &S, const InitializedEntity &Entity,\n                      const InitializationKind &Kind, MultiExprArg Args,\n                      bool TopLevelOfInitList, bool TreatUnavailableAsInvalid);\n\n  ~InitializationSequence();\n\n  /// Perform the actual initialization of the given entity based on\n  /// the computed initialization sequence.\n  ///\n  /// \\param S the semantic analysis object.\n  ///\n  /// \\param Entity the entity being initialized.\n  ///\n  /// \\param Kind the kind of initialization being performed.\n  ///\n  /// \\param Args the argument(s) provided for initialization, ownership of\n  /// which is transferred into the routine.\n  ///\n  /// \\param ResultType if non-NULL, will be set to the type of the\n  /// initialized object, which is the type of the declaration in most\n  /// cases. However, when the initialized object is a variable of\n  /// incomplete array type and the initializer is an initializer\n  /// list, this type will be set to the completed array type.\n  ///\n  /// \\returns an expression that performs the actual object initialization, if\n  /// the initialization is well-formed. Otherwise, emits diagnostics\n  /// and returns an invalid expression.\n  ExprResult Perform(Sema &S,\n                     const InitializedEntity &Entity,\n                     const InitializationKind &Kind,\n                     MultiExprArg Args,\n                     QualType *ResultType = nullptr);\n\n  /// Diagnose an potentially-invalid initialization sequence.\n  ///\n  /// \\returns true if the initialization sequence was ill-formed,\n  /// false otherwise.\n  bool Diagnose(Sema &S,\n                const InitializedEntity &Entity,\n                const InitializationKind &Kind,\n                ArrayRef<Expr *> Args);\n\n  /// Determine the kind of initialization sequence computed.\n  enum SequenceKind getKind() const { return SequenceKind; }\n\n  /// Set the kind of sequence computed.\n  void setSequenceKind(enum SequenceKind SK) { SequenceKind = SK; }\n\n  /// Determine whether the initialization sequence is valid.\n  explicit operator bool() const { return !Failed(); }\n\n  /// Determine whether the initialization sequence is invalid.\n  bool Failed() const { return SequenceKind == FailedSequence; }\n\n  using step_iterator = SmallVectorImpl<Step>::const_iterator;\n\n  step_iterator step_begin() const { return Steps.begin(); }\n  step_iterator step_end()   const { return Steps.end(); }\n\n  using step_range = llvm::iterator_range<step_iterator>;\n\n  step_range steps() const { return {step_begin(), step_end()}; }\n\n  /// Determine whether this initialization is a direct reference\n  /// binding (C++ [dcl.init.ref]).\n  bool isDirectReferenceBinding() const;\n\n  /// Determine whether this initialization failed due to an ambiguity.\n  bool isAmbiguous() const;\n\n  /// Determine whether this initialization is direct call to a\n  /// constructor.\n  bool isConstructorInitialization() const;\n\n  /// Add a new step in the initialization that resolves the address\n  /// of an overloaded function to a specific function declaration.\n  ///\n  /// \\param Function the function to which the overloaded function reference\n  /// resolves.\n  void AddAddressOverloadResolutionStep(FunctionDecl *Function,\n                                        DeclAccessPair Found,\n                                        bool HadMultipleCandidates);\n\n  /// Add a new step in the initialization that performs a derived-to-\n  /// base cast.\n  ///\n  /// \\param BaseType the base type to which we will be casting.\n  ///\n  /// \\param Category Indicates whether the result will be treated as an\n  /// rvalue, an xvalue, or an lvalue.\n  void AddDerivedToBaseCastStep(QualType BaseType,\n                                ExprValueKind Category);\n\n  /// Add a new step binding a reference to an object.\n  ///\n  /// \\param BindingTemporary True if we are binding a reference to a temporary\n  /// object (thereby extending its lifetime); false if we are binding to an\n  /// lvalue or an lvalue treated as an rvalue.\n  void AddReferenceBindingStep(QualType T, bool BindingTemporary);\n\n  /// Add a new step that makes an extraneous copy of the input\n  /// to a temporary of the same class type.\n  ///\n  /// This extraneous copy only occurs during reference binding in\n  /// C++98/03, where we are permitted (but not required) to introduce\n  /// an extra copy. At a bare minimum, we must check that we could\n  /// call the copy constructor, and produce a diagnostic if the copy\n  /// constructor is inaccessible or no copy constructor matches.\n  //\n  /// \\param T The type of the temporary being created.\n  void AddExtraneousCopyToTemporary(QualType T);\n\n  /// Add a new step that makes a copy of the input to an object of\n  /// the given type, as the final step in class copy-initialization.\n  void AddFinalCopy(QualType T);\n\n  /// Add a new step invoking a conversion function, which is either\n  /// a constructor or a conversion function.\n  void AddUserConversionStep(FunctionDecl *Function,\n                             DeclAccessPair FoundDecl,\n                             QualType T,\n                             bool HadMultipleCandidates);\n\n  /// Add a new step that performs a qualification conversion to the\n  /// given type.\n  void AddQualificationConversionStep(QualType Ty,\n                                     ExprValueKind Category);\n\n  /// Add a new step that performs a function reference conversion to the\n  /// given type.\n  void AddFunctionReferenceConversionStep(QualType Ty);\n\n  /// Add a new step that performs conversion from non-atomic to atomic\n  /// type.\n  void AddAtomicConversionStep(QualType Ty);\n\n  /// Add a new step that applies an implicit conversion sequence.\n  void AddConversionSequenceStep(const ImplicitConversionSequence &ICS,\n                                 QualType T, bool TopLevelOfInitList = false);\n\n  /// Add a list-initialization step.\n  void AddListInitializationStep(QualType T);\n\n  /// Add a constructor-initialization step.\n  ///\n  /// \\param FromInitList The constructor call is syntactically an initializer\n  /// list.\n  /// \\param AsInitList The constructor is called as an init list constructor.\n  void AddConstructorInitializationStep(DeclAccessPair FoundDecl,\n                                        CXXConstructorDecl *Constructor,\n                                        QualType T,\n                                        bool HadMultipleCandidates,\n                                        bool FromInitList, bool AsInitList);\n\n  /// Add a zero-initialization step.\n  void AddZeroInitializationStep(QualType T);\n\n  /// Add a C assignment step.\n  //\n  // FIXME: It isn't clear whether this should ever be needed;\n  // ideally, we would handle everything needed in C in the common\n  // path. However, that isn't the case yet.\n  void AddCAssignmentStep(QualType T);\n\n  /// Add a string init step.\n  void AddStringInitStep(QualType T);\n\n  /// Add an Objective-C object conversion step, which is\n  /// always a no-op.\n  void AddObjCObjectConversionStep(QualType T);\n\n  /// Add an array initialization loop step.\n  void AddArrayInitLoopStep(QualType T, QualType EltTy);\n\n  /// Add an array initialization step.\n  void AddArrayInitStep(QualType T, bool IsGNUExtension);\n\n  /// Add a parenthesized array initialization step.\n  void AddParenthesizedArrayInitStep(QualType T);\n\n  /// Add a step to pass an object by indirect copy-restore.\n  void AddPassByIndirectCopyRestoreStep(QualType T, bool shouldCopy);\n\n  /// Add a step to \"produce\" an Objective-C object (by\n  /// retaining it).\n  void AddProduceObjCObjectStep(QualType T);\n\n  /// Add a step to construct a std::initializer_list object from an\n  /// initializer list.\n  void AddStdInitializerListConstructionStep(QualType T);\n\n  /// Add a step to initialize an OpenCL sampler from an integer\n  /// constant.\n  void AddOCLSamplerInitStep(QualType T);\n\n  /// Add a step to initialzie an OpenCL opaque type (event_t, queue_t, etc.)\n  /// from a zero constant.\n  void AddOCLZeroOpaqueTypeStep(QualType T);\n\n  void AddParenthesizedListInitStep(QualType T);\n\n  /// Add steps to unwrap a initializer list for a reference around a\n  /// single element and rewrap it at the end.\n  void RewrapReferenceInitList(QualType T, InitListExpr *Syntactic);\n\n  /// Note that this initialization sequence failed.\n  void SetFailed(FailureKind Failure) {\n    SequenceKind = FailedSequence;\n    this->Failure = Failure;\n    assert((Failure != FK_Incomplete || !FailedIncompleteType.isNull()) &&\n           \"Incomplete type failure requires a type!\");\n  }\n\n  /// Note that this initialization sequence failed due to failed\n  /// overload resolution.\n  void SetOverloadFailure(FailureKind Failure, OverloadingResult Result);\n\n  /// Retrieve a reference to the candidate set when overload\n  /// resolution fails.\n  OverloadCandidateSet &getFailedCandidateSet() {\n    return FailedCandidateSet;\n  }\n\n  /// Get the overloading result, for when the initialization\n  /// sequence failed due to a bad overload.\n  OverloadingResult getFailedOverloadResult() const {\n    return FailedOverloadResult;\n  }\n\n  /// Note that this initialization sequence failed due to an\n  /// incomplete type.\n  void setIncompleteTypeFailure(QualType IncompleteType) {\n    FailedIncompleteType = IncompleteType;\n    SetFailed(FK_Incomplete);\n  }\n\n  /// Determine why initialization failed.\n  FailureKind getFailureKind() const {\n    assert(Failed() && \"Not an initialization failure!\");\n    return Failure;\n  }\n\n  /// Dump a representation of this initialization sequence to\n  /// the given stream, for debugging purposes.\n  void dump(raw_ostream &OS) const;\n\n  /// Dump a representation of this initialization sequence to\n  /// standard error, for debugging purposes.\n  void dump() const;\n}",
  "id": "BLOCK-CPP-19878",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Initialization.h",
  "source_line": 802,
  "validation_status": "validated"
}