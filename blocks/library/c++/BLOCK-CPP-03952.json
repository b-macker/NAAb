{
  "code": "{\n//    LOG(ERROR) << \"Unexpected null pointer\";\n//  } else {\n//    (*result)->DoSomethingCool();\n//  }\n//\n// Example factory implementation returning StatusOr<T>:\n//\n//  StatusOr<Foo> FooFactory::MakeFoo(int arg) {\n//    if (arg <= 0) {\n//      return absl::Status(absl::StatusCode::kInvalidArgument,\n//                          \"Arg must be positive\");\n//    }\n//    return Foo(arg);\n//  }\ntemplate <typename T>\nclass StatusOr : private internal_statusor::StatusOrData<T>,\n                 private internal_statusor::CopyCtorBase<T>,\n                 private internal_statusor::MoveCtorBase<T>,\n                 private internal_statusor::CopyAssignBase<T>,\n                 private internal_statusor::MoveAssignBase<T> {\n  template <typename U>\n  friend class StatusOr;\n\n  typedef internal_statusor::StatusOrData<T> Base;\n\n public:\n  // StatusOr<T>::value_type\n  //\n  // This instance data provides a generic `value_type` member for use within\n  // generic programming. This usage is analogous to that of\n  // `optional::value_type` in the case of `std::optional`.\n  typedef T value_type;\n\n  // Constructors\n\n  // Constructs a new `absl::StatusOr` with an `absl::StatusCode::kUnknown`\n  // status. This constructor is marked 'explicit' to prevent usages in return\n  // values such as 'return {};', under the misconception that\n  // `absl::StatusOr<std::vector<int>>` will be initialized with an empty\n  // vector, instead of an `absl::StatusCode::kUnknown` error code.\n  explicit StatusOr();\n\n  // `StatusOr<T>` is copy constructible if `T` is copy constructible.\n  StatusOr(const StatusOr&) = default;\n  // `StatusOr<T>` is copy assignable if `T` is copy constructible and copy\n  // assignable.\n  StatusOr& operator=(const StatusOr&) = default;\n\n  // `StatusOr<T>` is move constructible if `T` is move constructible.\n  StatusOr(StatusOr&&) = default;\n  // `StatusOr<T>` is moveAssignable if `T` is move constructible and move\n  // assignable.\n  StatusOr& operator=(StatusOr&&) = default;\n\n  // Converting Constructors\n\n  // Constructs a new `absl::StatusOr<T>` from an `absl::StatusOr<U>`, when `T`\n  // is constructible from `U`. To avoid ambiguity, these constructors are\n  // disabled if `T` is also constructible from `StatusOr<U>.`. This constructor\n  // is explicit if and only if the corresponding construction of `T` from `U`\n  // is explicit. (This constructor inherits its explicitness from the\n  // underlying constructor.)\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>,\n              std::is_constructible<T, const U&>,\n              std::is_convertible<const U&, T>,\n              absl::negation<\n                  internal_statusor::IsConstructibleOrConvertibleFromStatusOr<\n                      T, U>>>::value,\n          int> = 0>\n  StatusOr(const StatusOr<U>& other)  // NOLINT\n      : Base(static_cast<const typename StatusOr<U>::Base&>(other)) {}\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>,\n              std::is_constructible<T, const U&>,\n              absl::negation<std::is_convertible<const U&, T>>,\n              absl::negation<\n                  internal_statusor::IsConstructibleOrConvertibleFromStatusOr<\n                      T, U>>>::value,\n          int> = 0>\n  explicit StatusOr(const StatusOr<U>& other)\n      : Base(static_cast<const typename StatusOr<U>::Base&>(other)) {}\n\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>, std::is_constructible<T, U&&>,\n              std::is_convertible<U&&, T>,\n              absl::negation<\n                  internal_statusor::IsConstructibleOrConvertibleFromStatusOr<\n                      T, U>>>::value,\n          int> = 0>\n  StatusOr(StatusOr<U>&& other)  // NOLINT\n      : Base(static_cast<typename StatusOr<U>::Base&&>(other)) {}\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>, std::is_constructible<T, U&&>,\n              absl::negation<std::is_convertible<U&&, T>>,\n              absl::negation<\n                  internal_statusor::IsConstructibleOrConvertibleFromStatusOr<\n                      T, U>>>::value,\n          int> = 0>\n  explicit StatusOr(StatusOr<U>&& other)\n      : Base(static_cast<typename StatusOr<U>::Base&&>(other)) {}\n\n  // Converting Assignment Operators\n\n  // Creates an `absl::StatusOr<T>` through assignment from an\n  // `absl::StatusOr<U>` when:\n  //\n  //   * Both `absl::StatusOr<T>` and `absl::StatusOr<U>` are OK by assigning\n  //     `U` to `T` directly.\n  //   * `absl::StatusOr<T>` is OK and `absl::StatusOr<U>` contains an error\n  //      code by destroying `absl::StatusOr<T>`'s value and assigning from\n  //      `absl::StatusOr<U>'\n  //   * `absl::StatusOr<T>` contains an error code and `absl::StatusOr<U>` is\n  //      OK by directly initializing `T` from `U`.\n  //   * Both `absl::StatusOr<T>` and `absl::StatusOr<U>` contain an error\n  //     code by assigning the `Status` in `absl::StatusOr<U>` to\n  //     `absl::StatusOr<T>`\n  //\n  // These overloads only apply if `absl::StatusOr<T>` is constructible and\n  // assignable from `absl::StatusOr<U>` and `StatusOr<T>` cannot be directly\n  // assigned from `StatusOr<U>`.\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>,\n              std::is_constructible<T, const U&>,\n              std::is_assignable<T, const U&>,\n              absl::negation<\n                  internal_statusor::\n                      IsConstructibleOrConvertibleOrAssignableFromStatusOr<\n                          T, U>>>::value,\n          int> = 0>\n  StatusOr& operator=(const StatusOr<U>& other) {\n    this->Assign(other);\n    return *this;\n  }\n  template <\n      typename U,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_same<T, U>>, std::is_constructible<T, U&&>,\n              std::is_assignable<T, U&&>,\n              absl::negation<\n                  internal_statusor::\n                      IsConstructibleOrConvertibleOrAssignableFromStatusOr<\n                          T, U>>>::value,\n          int> = 0>\n  StatusOr& operator=(StatusOr<U>&& other) {\n    this->Assign(std::move(other));\n    return *this;\n  }\n\n  // Constructs a new `absl::StatusOr<T>` with a non-ok status. After calling\n  // this constructor, `this->ok()` will be `false` and calls to `value()` will\n  // crash, or produce an exception if exceptions are enabled.\n  //\n  // The constructor also takes any type `U` that is convertible to\n  // `absl::Status`. This constructor is explicit if an only if `U` is not of\n  // type `absl::Status` and the conversion from `U` to `Status` is explicit.\n  //\n  // REQUIRES: !Status(std::forward<U>(v)).ok(). This requirement is DCHECKed.\n  // In optimized builds, passing absl::OkStatus() here will have the effect\n  // of passing absl::StatusCode::kInternal as a fallback.\n  template <\n      typename U = absl::Status,\n      absl::enable_if_t<\n          absl::conjunction<\n              std::is_convertible<U&&, absl::Status>,\n              std::is_constructible<absl::Status, U&&>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::StatusOr<T>>>,\n              absl::negation<std::is_same<absl::decay_t<U>, T>>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::in_place_t>>,\n              absl::negation<internal_statusor::HasConversionOperatorToStatusOr<\n                  T, U&&>>>::value,\n          int> = 0>\n  StatusOr(U&& v) : Base(std::forward<U>(v)) {}\n\n  template <\n      typename U = absl::Status,\n      absl::enable_if_t<\n          absl::conjunction<\n              absl::negation<std::is_convertible<U&&, absl::Status>>,\n              std::is_constructible<absl::Status, U&&>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::StatusOr<T>>>,\n              absl::negation<std::is_same<absl::decay_t<U>, T>>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::in_place_t>>,\n              absl::negation<internal_statusor::HasConversionOperatorToStatusOr<\n                  T, U&&>>>::value,\n          int> = 0>\n  explicit StatusOr(U&& v) : Base(std::forward<U>(v)) {}\n\n  template <\n      typename U = absl::Status,\n      absl::enable_if_t<\n          absl::conjunction<\n              std::is_convertible<U&&, absl::Status>,\n              std::is_constructible<absl::Status, U&&>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::StatusOr<T>>>,\n              absl::negation<std::is_same<absl::decay_t<U>, T>>,\n              absl::negation<std::is_same<absl::decay_t<U>, absl::in_place_t>>,\n              absl::negation<internal_statusor::HasConversionOperatorToStatusOr<\n                  T, U&&>>>::value,\n          int> = 0>\n  StatusOr& operator=(U&& v) {\n    this->AssignStatus(std::forward<U>(v));\n    return *this;\n  }\n\n  // Perfect-forwarding value assignment operator.\n\n  // If `*this` contains a `T` value before the call, the contained value is\n  // assigned from `std::forward<U>(v)`; Otherwise, it is directly-initialized\n  // from `std::forward<U>(v)`.\n  // This function does not participate in overload unless:\n  // 1. `std::is_constructible_v<T, U>` is true,\n  // 2. `std::is_assignable_v<T&, U>` is true.\n  // 3. `std::is_same_v<StatusOr<T>, std::remove_cvref_t<U>>` is false.\n  // 4. Assigning `U` to `T` is not ambiguous:\n  //  If `U` is `StatusOr<V>` and `T` is constructible and assignable from\n  //  both `StatusOr<V>` and `V`, the assignment is considered bug-prone and\n  //  ambiguous thus will fail to compile. For example:\n  //    StatusOr<bool> s1 = true;  // s1.ok() && *s1 == true\n  //    StatusOr<bool> s2 = false;  // s2.ok() && *s2 == false\n  //    s1 = s2;  // ambiguous, `s1 = *s2` or `s1 = bool(s2)`?\n  template <\n      typename U = T,\n      typename = typename std::enable_if<absl::conjunction<\n          std::is_constructible<T, U&&>, std::is_assignable<T&, U&&>,\n          absl::disjunction<\n              std::is_same<absl::remove_cvref_t<U>, T>,\n              absl::conjunction<\n                  absl::negation<std::is_convertible<U&&, absl::Status>>,\n                  absl::negation<internal_statusor::\n                                     HasConversionOperatorToStatusOr<T, U&&>>>>,\n          internal_statusor::IsForwardingAssignmentValid<T, U&&>>::value>::type>\n  StatusOr& operator=(U&& v) {\n    this->Assign(std::forward<U>(v));\n    return *this;\n  }\n\n  // Constructs the inner value `T` in-place using the provided args, using the\n  // `T(args...)` constructor.\n  template <typename... Args>\n  explicit StatusOr(absl::in_place_t, Args&&... args);\n  template <typename U, typename... Args>\n  explicit StatusOr(absl::in_place_t, std::initializer_list<U> ilist,\n                    Args&&... args);\n\n  // Constructs the inner value `T` in-place using the provided args, using the\n  // `T(U)` (direct-initialization) constructor. This constructor is only valid\n  // if `T` can be constructed from a `U`. Can accept move or copy constructors.\n  //\n  // This constructor is explicit if `U` is not convertible to `T`. To avoid\n  // ambiguity, this constructor is disabled if `U` is a `StatusOr<J>`, where\n  // `J` is convertible to `T`.\n  template <\n      typename U = T,\n      absl::enable_if_t<\n          absl::conjunction<\n              internal_statusor::IsDirectInitializationValid<T, U&&>,\n              std::is_constructible<T, U&&>, std::is_convertible<U&&, T>,\n              absl::disjunction<\n                  std::is_same<absl::remove_cvref_t<U>, T>,\n                  absl::conjunction<\n                      absl::negation<std::is_convertible<U&&, absl::Status>>,\n                      absl::negation<\n                          internal_statusor::HasConversionOperatorToStatusOr<\n                              T, U&&>>>>>::value,\n          int> = 0>\n  StatusOr(U&& u)  // NOLINT\n      : StatusOr(absl::in_place, std::forward<U>(u)) {}\n\n  template <\n      typename U = T,\n      absl::enable_if_t<\n          absl::conjunction<\n              internal_statusor::IsDirectInitializationValid<T, U&&>,\n              absl::disjunction<\n                  std::is_same<absl::remove_cvref_t<U>, T>,\n                  absl::conjunction<\n                      absl::negation<std::is_constructible<absl::Status, U&&>>,\n                      absl::negation<\n                          internal_statusor::HasConversionOperatorToStatusOr<\n                              T, U&&>>>>,\n              std::is_constructible<T, U&&>,\n              absl::negation<std::is_convertible<U&&, T>>>::value,\n          int> = 0>\n  explicit StatusOr(U&& u)  // NOLINT\n      : StatusOr(absl::in_place, std::forward<U>(u)) {}\n\n  // StatusOr<T>::ok()\n  //\n  // Returns whether or not this `absl::StatusOr<T>` holds a `T` value. This\n  // member function is analogous to `absl::Status::ok()` and should be used\n  // similarly to check the status of return values.\n  //\n  // Example:\n  //\n  // StatusOr<Foo> result = DoBigCalculationThatCouldFail();\n  // if (result.ok()) {\n  //    // Handle result\n  // else {\n  //    // Handle error\n  // }\n  ABSL_MUST_USE_RESULT bool ok() const { return this->status_.ok(); }\n\n  // StatusOr<T>::status()\n  //\n  // Returns a reference to the current `absl::Status` contained within the\n  // `absl::StatusOr<T>`. If `absl::StatusOr<T>` contains a `T`, then this\n  // function returns `absl::OkStatus()`.\n  const Status& status() const&;\n  Status status() &&;\n\n  // StatusOr<T>::value()\n  //\n  // Returns a reference to the held value if `this->ok()`. Otherwise, throws\n  // `absl::BadStatusOrAccess` if exceptions are enabled, or is guaranteed to\n  // terminate the process if exceptions are disabled.\n  //\n  // If you have already checked the status using `this->ok()`, you probably\n  // want to use `operator*()` or `operator->()` to access the value instead of\n  // `value`.\n  //\n  // Note: for value types that are cheap to copy, prefer simple code:\n  //\n  //   T value = statusor.value();\n  //\n  // Otherwise, if the value type is expensive to copy, but can be left\n  // in the StatusOr, simply assign to a reference:\n  //\n  //   T& value = statusor.value();  // or `const T&`\n  //\n  // Otherwise, if the value type supports an efficient move, it can be\n  // used as follows:\n  //\n  //   T value = std::move(statusor).value();\n  //\n  // The `std::move` on statusor instead of on the whole expression enables\n  // warnings about possible uses of the statusor object after the move.\n  const T& value() const& ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  T& value() & ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  const T&& value() const&& ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  T&& value() && ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // StatusOr<T>:: operator*()\n  //\n  // Returns a reference to the current value.\n  //\n  // REQUIRES: `this->ok() == true`, otherwise the behavior is undefined.\n  //\n  // Use `this->ok()` to verify that there is a current value within the\n  // `absl::StatusOr<T>`. Alternatively, see the `value()` member function for a\n  // similar API that guarantees crashing or throwing an exception if there is\n  // no current value.\n  const T& operator*() const& ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  T& operator*() & ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  const T&& operator*() const&& ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  T&& operator*() && ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // StatusOr<T>::operator->()\n  //\n  // Returns a pointer to the current value.\n  //\n  // REQUIRES: `this->ok() == true`, otherwise the behavior is undefined.\n  //\n  // Use `this->ok()` to verify that there is a current value.\n  const T* operator->() const ABSL_ATTRIBUTE_LIFETIME_BOUND;\n  T* operator->() ABSL_ATTRIBUTE_LIFETIME_BOUND;\n\n  // StatusOr<T>::value_or()\n  //\n  // Returns the current value if `this->ok() == true`. Otherwise constructs a\n  // value using the provided `default_value`.\n  //\n  // Unlike `value`, this function returns by value, copying the current value\n  // if necessary. If the value type supports an efficient move, it can be used\n  // as follows:\n  //\n  //   T value = std::move(statusor).value_or(def);\n  //\n  // Unlike with `value`, calling `std::move()` on the result of `value_or` will\n  // still trigger a copy.\n  template <typename U>\n  T value_or(U&& default_value) const&;\n  template <typename U>\n  T value_or(U&& default_value) &&;\n\n  // StatusOr<T>::IgnoreError()\n  //\n  // Ignores any errors. This method does nothing except potentially suppress\n  // complaints from any tools that are checking that errors are not dropped on\n  // the floor.\n  void IgnoreError() const;\n\n  // StatusOr<T>::emplace()\n  //\n  // Reconstructs the inner value T in-place using the provided args, using the\n  // T(args...) constructor. Returns reference to the reconstructed `T`.\n  template <typename... Args>\n  T& emplace(Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ok()) {\n      this->Clear();\n      this->MakeValue(std::forward<Args>(args)...);\n    } else {\n      this->MakeValue(std::forward<Args>(args)...);\n      this->status_ = absl::OkStatus();\n    }\n    return this->data_;\n  }\n\n  template <\n      typename U, typename... Args,\n      absl::enable_if_t<\n          std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,\n          int> = 0>\n  T& emplace(std::initializer_list<U> ilist,\n             Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ok()) {\n      this->Clear();\n      this->MakeValue(ilist, std::forward<Args>(args)...);\n    } else {\n      this->MakeValue(ilist, std::forward<Args>(args)...);\n      this->status_ = absl::OkStatus();\n    }\n    return this->data_;\n  }\n\n  // StatusOr<T>::AssignStatus()\n  //\n  // Sets the status of `absl::StatusOr<T>` to the given non-ok status value.\n  //\n  // NOTE: We recommend using the constructor and `operator=` where possible.\n  // This method is intended for use in generic programming, to enable setting\n  // the status of a `StatusOr<T>` when `T` may be `Status`. In that case, the\n  // constructor and `operator=` would assign into the inner value of type\n  // `Status`, rather than status of the `StatusOr` (b/280392796).\n  //\n  // REQUIRES: !Status(std::forward<U>(v)).ok(). This requirement is DCHECKed.\n  // In optimized builds, passing absl::OkStatus() here will have the effect\n  // of passing absl::StatusCode::kInternal as a fallback.\n  using internal_statusor::StatusOrData<T>::AssignStatus;\n\n private:\n  using internal_statusor::StatusOrData<T>::Assign;\n  template <typename U>\n  void Assign(const absl::StatusOr<U>& other);\n  template <typename U>\n  void Assign(absl::StatusOr<U>&& other);\n};\n\n// operator==()\n//\n// This operator checks the equality of two `absl::StatusOr<T>` objects.\ntemplate <typename T>\nbool operator==(const StatusOr<T>& lhs, const StatusOr<T>& rhs) {\n  if (lhs.ok() && rhs.ok()) return *lhs == *rhs;\n  return lhs.status() == rhs.status();\n}\n\n// operator!=()\n//\n// This operator checks the inequality of two `absl::StatusOr<T>` objects.\ntemplate <typename T>\nbool operator!=(const StatusOr<T>& lhs, const StatusOr<T>& rhs) {\n  return !(lhs == rhs);\n}\n\n// Prints the `value` or the status in brackets to `os`.\n//\n// Requires `T` supports `operator<<`.  Do not rely on the output format which\n// may change without notice.\ntemplate <typename T, typename std::enable_if<\n                          absl::HasOstreamOperator<T>::value, int>::type = 0>\nstd::ostream& operator<<(std::ostream& os, const StatusOr<T>& status_or) {\n  if (status_or.ok()) {\n    os << status_or.value();\n  } else {\n    os << internal_statusor::StringifyRandom::OpenBrackets()\n       << status_or.status()\n       << internal_statusor::StringifyRandom::CloseBrackets();\n  }\n  return os;\n}\n\n// As above, but supports `StrCat`, `StrFormat`, etc.\n//\n// Requires `T` has `AbslStringify`.  Do not rely on the output format which\n// may change without notice.\ntemplate <\n    typename Sink, typename T,\n    typename std::enable_if<absl::HasAbslStringify<T>::value, int>::type = 0>\nvoid AbslStringify(Sink& sink, const StatusOr<T>& status_or) {\n  if (status_or.ok()) {\n    absl::Format(&sink, \"%v\", status_or.value());\n  } else {\n    absl::Format(&sink, \"%s%v%s\",\n                 internal_statusor::StringifyRandom::OpenBrackets(),\n                 status_or.status(),\n                 internal_statusor::StringifyRandom::CloseBrackets());\n  }\n}\n\n//------------------------------------------------------------------------------\n// Implementation details for StatusOr<T>\n//------------------------------------------------------------------------------\n\n// TODO(sbenza): avoid the string here completely.\ntemplate <typename T>\nStatusOr<T>::StatusOr() : Base(Status(absl::StatusCode::kUnknown, \"\")) {}\n\ntemplate <typename T>\ntemplate <typename U>\ninline void StatusOr<T>::Assign(const StatusOr<U>& other) {\n  if (other.ok()) {\n    this->Assign(*other);\n  } else {\n    this->AssignStatus(other.status());\n  }\n}\n\ntemplate <typename T>\ntemplate <typename U>\ninline void StatusOr<T>::Assign(StatusOr<U>&& other) {\n  if (other.ok()) {\n    this->Assign(*std::move(other));\n  } else {\n    this->AssignStatus(std::move(other).status());\n  }\n}\ntemplate <typename T>\ntemplate <typename... Args>\nStatusOr<T>::StatusOr(absl::in_place_t, Args&&... args)\n    : Base(absl::in_place, std::forward<Args>(args)...) {}\n\ntemplate <typename T>\ntemplate <typename U, typename... Args>\nStatusOr<T>::StatusOr(absl::in_place_t, std::initializer_list<U> ilist,\n                      Args&&... args)\n    : Base(absl::in_place, ilist, std::forward<Args>(args)...) {}\n\ntemplate <typename T>\nconst Status& StatusOr<T>::status() const& {\n  return this->status_;\n}\ntemplate <typename T>\nStatus StatusOr<T>::status() && {\n  return ok() ? OkStatus() : std::move(this->status_);\n}\n\ntemplate <typename T>\nconst T& StatusOr<T>::value() const& {\n  if (!this->ok()) internal_statusor::ThrowBadStatusOrAccess(this->status_);\n  return this->data_;\n}\n\ntemplate <typename T>\nT& StatusOr<T>::value() & {\n  if (!this->ok()) internal_statusor::ThrowBadStatusOrAccess(this->status_);\n  return this->data_;\n}\n\ntemplate <typename T>\nconst T&& StatusOr<T>::value() const&& {\n  if (!this->ok()) {\n    internal_statusor::ThrowBadStatusOrAccess(std::move(this->status_));\n  }\n  return std::move(this->data_);\n}\n\ntemplate <typename T>\nT&& StatusOr<T>::value() && {\n  if (!this->ok()) {\n    internal_statusor::ThrowBadStatusOrAccess(std::move(this->status_));\n  }\n  return std::move(this->data_);\n}\n\ntemplate <typename T>\nconst T& StatusOr<T>::operator*() const& {\n  this->EnsureOk();\n  return this->data_;\n}\n\ntemplate <typename T>\nT& StatusOr<T>::operator*() & {\n  this->EnsureOk();\n  return this->data_;\n}\n\ntemplate <typename T>\nconst T&& StatusOr<T>::operator*() const&& {\n  this->EnsureOk();\n  return std::move(this->data_);\n}\n\ntemplate <typename T>\nT&& StatusOr<T>::operator*() && {\n  this->EnsureOk();\n  return std::move(this->data_);\n}\n\ntemplate <typename T>\nabsl::Nonnull<const T*> StatusOr<T>::operator->() const {\n  this->EnsureOk();\n  return &this->data_;\n}\n\ntemplate <typename T>\nabsl::Nonnull<T*> StatusOr<T>::operator->() {\n  this->EnsureOk();\n  return &this->data_;\n}\n\ntemplate <typename T>\ntemplate <typename U>\nT StatusOr<T>::value_or(U&& default_value) const& {\n  if (ok()) {\n    return this->data_;\n  }\n  return std::forward<U>(default_value);\n}\n\ntemplate <typename T>\ntemplate <typename U>\nT StatusOr<T>::value_or(U&& default_value) && {\n  if (ok()) {\n    return std::move(this->data_);\n  }\n  return std::forward<U>(default_value);\n}\n\ntemplate <typename T>\nvoid StatusOr<T>::IgnoreError() const {\n  // no-op\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03952",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/statusor.h",
  "source_line": 176,
  "validation_status": "validated"
}