{
  "code": "{\n public:\n  // A `CondVar` allocated on the heap or on the stack can use the this\n  // constructor.\n  CondVar();\n\n  // CondVar::Wait()\n  //\n  // Atomically releases a `Mutex` and blocks on this condition variable.\n  // Waits until awakened by a call to `Signal()` or `SignalAll()` (or a\n  // spurious wakeup), then reacquires the `Mutex` and returns.\n  //\n  // Requires and ensures that the current thread holds the `Mutex`.\n  void Wait(Mutex* mu) {\n    WaitCommon(mu, synchronization_internal::KernelTimeout::Never());\n  }\n\n  // CondVar::WaitWithTimeout()\n  //\n  // Atomically releases a `Mutex` and blocks on this condition variable.\n  // Waits until awakened by a call to `Signal()` or `SignalAll()` (or a\n  // spurious wakeup), or until the timeout has expired, then reacquires\n  // the `Mutex` and returns.\n  //\n  // Returns true if the timeout has expired without this `CondVar`\n  // being signalled in any manner. If both the timeout has expired\n  // and this `CondVar` has been signalled, the implementation is free\n  // to return `true` or `false`.\n  //\n  // Requires and ensures that the current thread holds the `Mutex`.\n  bool WaitWithTimeout(Mutex* mu, absl::Duration timeout) {\n    return WaitCommon(mu, synchronization_internal::KernelTimeout(timeout));\n  }\n\n  // CondVar::WaitWithDeadline()\n  //\n  // Atomically releases a `Mutex` and blocks on this condition variable.\n  // Waits until awakened by a call to `Signal()` or `SignalAll()` (or a\n  // spurious wakeup), or until the deadline has passed, then reacquires\n  // the `Mutex` and returns.\n  //\n  // Deadlines in the past are equivalent to an immediate deadline.\n  //\n  // Returns true if the deadline has passed without this `CondVar`\n  // being signalled in any manner. If both the deadline has passed\n  // and this `CondVar` has been signalled, the implementation is free\n  // to return `true` or `false`.\n  //\n  // Requires and ensures that the current thread holds the `Mutex`.\n  bool WaitWithDeadline(Mutex* mu, absl::Time deadline) {\n    return WaitCommon(mu, synchronization_internal::KernelTimeout(deadline));\n  }\n\n  // CondVar::Signal()\n  //\n  // Signal this `CondVar`; wake at least one waiter if one exists.\n  void Signal();\n\n  // CondVar::SignalAll()\n  //\n  // Signal this `CondVar`; wake all waiters.\n  void SignalAll();\n\n  // CondVar::EnableDebugLog()\n  //\n  // Causes all subsequent uses of this `CondVar` to be logged via\n  // `ABSL_RAW_LOG(INFO)`. Log entries are tagged with `name` if `name != 0`.\n  // Note: this method substantially reduces `CondVar` performance.\n  void EnableDebugLog(const char* name);\n\n private:\n  bool WaitCommon(Mutex* mutex, synchronization_internal::KernelTimeout t);\n  void Remove(base_internal::PerThreadSynch* s);\n  std::atomic<intptr_t> cv_;  // Condition variable state.\n  CondVar(const CondVar&) = delete;\n  CondVar& operator=(const CondVar&) = delete;\n}",
  "id": "BLOCK-CPP-04326",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/mutex.h",
  "source_line": 911,
  "validation_status": "validated"
}