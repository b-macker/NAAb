{
  "code": "{\n  // Building a module if true.\n  bool BuildingModule;\n\npublic:\n  explicit ModuleLoader(bool BuildingModule = false)\n      : BuildingModule(BuildingModule) {}\n\n  virtual ~ModuleLoader();\n\n  /// Returns true if this instance is building a module.\n  bool buildingModule() const {\n    return BuildingModule;\n  }\n\n  /// Flag indicating whether this instance is building a module.\n  void setBuildingModule(bool BuildingModuleFlag) {\n    BuildingModule = BuildingModuleFlag;\n  }\n\n  /// Attempt to load the given module.\n  ///\n  /// This routine attempts to load the module described by the given\n  /// parameters.  If there is a module cache, this may implicitly compile the\n  /// module before loading it.\n  ///\n  /// \\param ImportLoc The location of the 'import' keyword.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Visibility The visibility provided for the names in the loaded\n  /// module.\n  ///\n  /// \\param IsInclusionDirective Indicates that this module is being loaded\n  /// implicitly, due to the presence of an inclusion directive. Otherwise,\n  /// it is being loaded due to an import declaration.\n  ///\n  /// \\returns If successful, returns the loaded module. Otherwise, returns\n  /// NULL to indicate that the module could not be loaded.\n  virtual ModuleLoadResult loadModule(SourceLocation ImportLoc,\n                                      ModuleIdPath Path,\n                                      Module::NameVisibilityKind Visibility,\n                                      bool IsInclusionDirective) = 0;\n\n  /// Attempt to create the given module from the specified source buffer.\n  /// Does not load the module or make any submodule visible; for that, use\n  /// loadModule and makeModuleVisible.\n  ///\n  /// \\param Loc The location at which to create the module.\n  /// \\param ModuleName The name of the module to create.\n  /// \\param Source The source of the module: a (preprocessed) module map.\n  virtual void createModuleFromSource(SourceLocation Loc, StringRef ModuleName,\n                                      StringRef Source) = 0;\n\n  /// Make the given module visible.\n  virtual void makeModuleVisible(Module *Mod,\n                                 Module::NameVisibilityKind Visibility,\n                                 SourceLocation ImportLoc) = 0;\n\n  /// Load, create, or return global module.\n  /// This function returns an existing global module index, if one\n  /// had already been loaded or created, or loads one if it\n  /// exists, or creates one if it doesn't exist.\n  /// Also, importantly, if the index doesn't cover all the modules\n  /// in the module map, it will be update to do so here, because\n  /// of its use in searching for needed module imports and\n  /// associated fixit messages.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns null if load failed.\n  virtual GlobalModuleIndex *loadGlobalModuleIndex(\n                                                SourceLocation TriggerLoc) = 0;\n\n  /// Check global module index for missing imports.\n  /// \\param Name The symbol name to look for.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns true if any modules with that symbol found.\n  virtual bool lookupMissingImports(StringRef Name,\n                                    SourceLocation TriggerLoc) = 0;\n\n  bool HadFatalFailure = false;\n}",
  "id": "BLOCK-CPP-18777",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/ModuleLoader.h",
  "source_line": 82,
  "validation_status": "validated"
}