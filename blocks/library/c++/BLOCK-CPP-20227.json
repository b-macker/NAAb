{
  "code": "{\npublic:\n  /// ScopeFlags - These are bitfields that are or'd together when creating a\n  /// scope, which defines the sorts of things the scope contains.\n  enum ScopeFlags {\n    /// This indicates that the scope corresponds to a function, which\n    /// means that labels are set here.\n    FnScope = 0x01,\n\n    /// This is a while, do, switch, for, etc that can have break\n    /// statements embedded into it.\n    BreakScope = 0x02,\n\n    /// This is a while, do, for, which can have continue statements\n    /// embedded into it.\n    ContinueScope = 0x04,\n\n    /// This is a scope that can contain a declaration.  Some scopes\n    /// just contain loop constructs but don't contain decls.\n    DeclScope = 0x08,\n\n    /// The controlling scope in a if/switch/while/for statement.\n    ControlScope = 0x10,\n\n    /// The scope of a struct/union/class definition.\n    ClassScope = 0x20,\n\n    /// This is a scope that corresponds to a block/closure object.\n    /// Blocks serve as top-level scopes for some objects like labels, they\n    /// also prevent things like break and continue.  BlockScopes always have\n    /// the FnScope and DeclScope flags set as well.\n    BlockScope = 0x40,\n\n    /// This is a scope that corresponds to the\n    /// template parameters of a C++ template. Template parameter\n    /// scope starts at the 'template' keyword and ends when the\n    /// template declaration ends.\n    TemplateParamScope = 0x80,\n\n    /// This is a scope that corresponds to the\n    /// parameters within a function prototype.\n    FunctionPrototypeScope = 0x100,\n\n    /// This is a scope that corresponds to the parameters within\n    /// a function prototype for a function declaration (as opposed to any\n    /// other kind of function declarator). Always has FunctionPrototypeScope\n    /// set as well.\n    FunctionDeclarationScope = 0x200,\n\n    /// This is a scope that corresponds to the Objective-C\n    /// \\@catch statement.\n    AtCatchScope = 0x400,\n\n    /// This scope corresponds to an Objective-C method body.\n    /// It always has FnScope and DeclScope set as well.\n    ObjCMethodScope = 0x800,\n\n    /// This is a scope that corresponds to a switch statement.\n    SwitchScope = 0x1000,\n\n    /// This is the scope of a C++ try statement.\n    TryScope = 0x2000,\n\n    /// This is the scope for a function-level C++ try or catch scope.\n    FnTryCatchScope = 0x4000,\n\n    /// This is the scope of OpenMP executable directive.\n    OpenMPDirectiveScope = 0x8000,\n\n    /// This is the scope of some OpenMP loop directive.\n    OpenMPLoopDirectiveScope = 0x10000,\n\n    /// This is the scope of some OpenMP simd directive.\n    /// For example, it is used for 'omp simd', 'omp for simd'.\n    /// This flag is propagated to children scopes.\n    OpenMPSimdDirectiveScope = 0x20000,\n\n    /// This scope corresponds to an enum.\n    EnumScope = 0x40000,\n\n    /// This scope corresponds to an SEH try.\n    SEHTryScope = 0x80000,\n\n    /// This scope corresponds to an SEH except.\n    SEHExceptScope = 0x100000,\n\n    /// We are currently in the filter expression of an SEH except block.\n    SEHFilterScope = 0x200000,\n\n    /// This is a compound statement scope.\n    CompoundStmtScope = 0x400000,\n\n    /// We are between inheritance colon and the real class/struct definition\n    /// scope.\n    ClassInheritanceScope = 0x800000,\n\n    /// This is the scope of a C++ catch statement.\n    CatchScope = 0x1000000,\n\n    /// This is a scope in which a condition variable is currently being\n    /// parsed. If such a scope is a ContinueScope, it's invalid to jump to the\n    /// continue block from here.\n    ConditionVarScope = 0x2000000,\n\n    /// This is a scope of some OpenMP directive with\n    /// order clause which specifies concurrent\n    OpenMPOrderClauseScope = 0x4000000,\n    /// This is the scope for a lambda, after the lambda introducer.\n    /// Lambdas need two FunctionPrototypeScope scopes (because there is a\n    /// template scope in between), the outer scope does not increase the\n    /// depth of recursion.\n    LambdaScope = 0x8000000,\n  };\n\nprivate:\n  /// The parent scope for this scope.  This is null for the translation-unit\n  /// scope.\n  Scope *AnyParent;\n\n  /// Flags - This contains a set of ScopeFlags, which indicates how the scope\n  /// interrelates with other control flow statements.\n  unsigned Flags;\n\n  /// Depth - This is the depth of this scope.  The translation-unit scope has\n  /// depth 0.\n  unsigned short Depth;\n\n  /// Declarations with static linkage are mangled with the number of\n  /// scopes seen as a component.\n  unsigned short MSLastManglingNumber;\n\n  unsigned short MSCurManglingNumber;\n\n  /// PrototypeDepth - This is the number of function prototype scopes\n  /// enclosing this scope, including this scope.\n  unsigned short PrototypeDepth;\n\n  /// PrototypeIndex - This is the number of parameters currently\n  /// declared in this scope.\n  unsigned short PrototypeIndex;\n\n  /// FnParent - If this scope has a parent scope that is a function body, this\n  /// pointer is non-null and points to it.  This is used for label processing.\n  Scope *FnParent;\n  Scope *MSLastManglingParent;\n\n  /// BreakParent/ContinueParent - This is a direct link to the innermost\n  /// BreakScope/ContinueScope which contains the contents of this scope\n  /// for control flow purposes (and might be this scope itself), or null\n  /// if there is no such scope.\n  Scope *BreakParent, *ContinueParent;\n\n  /// BlockParent - This is a direct link to the immediately containing\n  /// BlockScope if this scope is not one, or null if there is none.\n  Scope *BlockParent;\n\n  /// TemplateParamParent - This is a direct link to the\n  /// immediately containing template parameter scope. In the\n  /// case of nested templates, template parameter scopes can have\n  /// other template parameter scopes as parents.\n  Scope *TemplateParamParent;\n\n  /// DeclsInScope - This keeps track of all declarations in this scope.  When\n  /// the declaration is added to the scope, it is set as the current\n  /// declaration for the identifier in the IdentifierTable.  When the scope is\n  /// popped, these declarations are removed from the IdentifierTable's notion\n  /// of current declaration.  It is up to the current Action implementation to\n  /// implement these semantics.\n  using DeclSetTy = llvm::SmallPtrSet<Decl *, 32>;\n  DeclSetTy DeclsInScope;\n\n  /// The DeclContext with which this scope is associated. For\n  /// example, the entity of a class scope is the class itself, the\n  /// entity of a function scope is a function, etc.\n  DeclContext *Entity;\n\n  using UsingDirectivesTy = SmallVector<UsingDirectiveDecl *, 2>;\n  UsingDirectivesTy UsingDirectives;\n\n  /// Used to determine if errors occurred in this scope.\n  DiagnosticErrorTrap ErrorTrap;\n\n  /// A single NRVO candidate variable in this scope.\n  /// There are three possible values:\n  ///  1) pointer to VarDecl that denotes NRVO candidate itself.\n  ///  2) nullptr value means that NRVO is not allowed in this scope\n  ///     (e.g. return a function parameter).\n  ///  3) std::nullopt value means that there is no NRVO candidate in this scope\n  ///     (i.e. there are no return statements in this scope).\n  std::optional<VarDecl *> NRVO;\n\n  /// Represents return slots for NRVO candidates in the current scope.\n  /// If a variable is present in this set, it means that a return slot is\n  /// available for this variable in the current scope.\n  llvm::SmallPtrSet<VarDecl *, 8> ReturnSlots;\n\n  void setFlags(Scope *Parent, unsigned F);\n\npublic:\n  Scope(Scope *Parent, unsigned ScopeFlags, DiagnosticsEngine &Diag)\n      : ErrorTrap(Diag) {\n    Init(Parent, ScopeFlags);\n  }\n\n  /// getFlags - Return the flags for this scope.\n  unsigned getFlags() const { return Flags; }\n\n  void setFlags(unsigned F) { setFlags(getParent(), F); }\n\n  /// isBlockScope - Return true if this scope correspond to a closure.\n  bool isBlockScope() const { return Flags & BlockScope; }\n\n  /// getParent - Return the scope that this is nested in.\n  const Scope *getParent() const { return AnyParent; }\n  Scope *getParent() { return AnyParent; }\n\n  /// getFnParent - Return the closest scope that is a function body.\n  const Scope *getFnParent() const { return FnParent; }\n  Scope *getFnParent() { return FnParent; }\n\n  const Scope *getMSLastManglingParent() const {\n    return MSLastManglingParent;\n  }\n  Scope *getMSLastManglingParent() { return MSLastManglingParent; }\n\n  /// getContinueParent - Return the closest scope that a continue statement\n  /// would be affected by.\n  Scope *getContinueParent() {\n    return ContinueParent;\n  }\n\n  const Scope *getContinueParent() const {\n    return const_cast<Scope*>(this)->getContinueParent();\n  }\n\n  // Set whether we're in the scope of a condition variable, where 'continue'\n  // is disallowed despite being a continue scope.\n  void setIsConditionVarScope(bool InConditionVarScope) {\n    Flags = (Flags & ~ConditionVarScope) |\n            (InConditionVarScope ? ConditionVarScope : 0);\n  }\n\n  bool isConditionVarScope() const {\n    return Flags & ConditionVarScope;\n  }\n\n  /// getBreakParent - Return the closest scope that a break statement\n  /// would be affected by.\n  Scope *getBreakParent() {\n    return BreakParent;\n  }\n  const Scope *getBreakParent() const {\n    return const_cast<Scope*>(this)->getBreakParent();\n  }\n\n  Scope *getBlockParent() { return BlockParent; }\n  const Scope *getBlockParent() const { return BlockParent; }\n\n  Scope *getTemplateParamParent() { return TemplateParamParent; }\n  const Scope *getTemplateParamParent() const { return TemplateParamParent; }\n\n  /// Returns the depth of this scope. The translation-unit has scope depth 0.\n  unsigned getDepth() const { return Depth; }\n\n  /// Returns the number of function prototype scopes in this scope\n  /// chain.\n  unsigned getFunctionPrototypeDepth() const {\n    return PrototypeDepth;\n  }\n\n  /// Return the number of parameters declared in this function\n  /// prototype, increasing it by one for the next call.\n  unsigned getNextFunctionPrototypeIndex() {\n    assert(isFunctionPrototypeScope());\n    return PrototypeIndex++;\n  }\n\n  using decl_range = llvm::iterator_range<DeclSetTy::iterator>;\n\n  decl_range decls() const {\n    return decl_range(DeclsInScope.begin(), DeclsInScope.end());\n  }\n\n  bool decl_empty() const { return DeclsInScope.empty(); }\n\n  void AddDecl(Decl *D) {\n    if (auto *VD = dyn_cast<VarDecl>(D))\n      if (!isa<ParmVarDecl>(VD))\n        ReturnSlots.insert(VD);\n\n    DeclsInScope.insert(D);\n  }\n\n  void RemoveDecl(Decl *D) { DeclsInScope.erase(D); }\n\n  void incrementMSManglingNumber() {\n    if (Scope *MSLMP = getMSLastManglingParent()) {\n      MSLMP->MSLastManglingNumber += 1;\n      MSCurManglingNumber += 1;\n    }\n  }\n\n  void decrementMSManglingNumber() {\n    if (Scope *MSLMP = getMSLastManglingParent()) {\n      MSLMP->MSLastManglingNumber -= 1;\n      MSCurManglingNumber -= 1;\n    }\n  }\n\n  unsigned getMSLastManglingNumber() const {\n    if (const Scope *MSLMP = getMSLastManglingParent())\n      return MSLMP->MSLastManglingNumber;\n    return 1;\n  }\n\n  unsigned getMSCurManglingNumber() const {\n    return MSCurManglingNumber;\n  }\n\n  /// isDeclScope - Return true if this is the scope that the specified decl is\n  /// declared in.\n  bool isDeclScope(const Decl *D) const { return DeclsInScope.contains(D); }\n\n  /// Get the entity corresponding to this scope.\n  DeclContext *getEntity() const {\n    return isTemplateParamScope() ? nullptr : Entity;\n  }\n\n  /// Get the DeclContext in which to continue unqualified lookup after a\n  /// lookup in this scope.\n  DeclContext *getLookupEntity() const { return Entity; }\n\n  void setEntity(DeclContext *E) {\n    assert(!isTemplateParamScope() &&\n           \"entity associated with template param scope\");\n    Entity = E;\n  }\n  void setLookupEntity(DeclContext *E) { Entity = E; }\n\n  /// Determine whether any unrecoverable errors have occurred within this\n  /// scope. Note that this may return false even if the scope contains invalid\n  /// declarations or statements, if the errors for those invalid constructs\n  /// were suppressed because some prior invalid construct was referenced.\n  bool hasUnrecoverableErrorOccurred() const {\n    return ErrorTrap.hasUnrecoverableErrorOccurred();\n  }\n\n  /// isFunctionScope() - Return true if this scope is a function scope.\n  bool isFunctionScope() const { return getFlags() & Scope::FnScope; }\n\n  /// isClassScope - Return true if this scope is a class/struct/union scope.\n  bool isClassScope() const { return getFlags() & Scope::ClassScope; }\n\n  /// Determines whether this scope is between inheritance colon and the real\n  /// class/struct definition.\n  bool isClassInheritanceScope() const {\n    return getFlags() & Scope::ClassInheritanceScope;\n  }\n\n  /// isInCXXInlineMethodScope - Return true if this scope is a C++ inline\n  /// method scope or is inside one.\n  bool isInCXXInlineMethodScope() const {\n    if (const Scope *FnS = getFnParent()) {\n      assert(FnS->getParent() && \"TUScope not created?\");\n      return FnS->getParent()->isClassScope();\n    }\n    return false;\n  }\n\n  /// isInObjcMethodScope - Return true if this scope is, or is contained in, an\n  /// Objective-C method body.  Note that this method is not constant time.\n  bool isInObjcMethodScope() const {\n    for (const Scope *S = this; S; S = S->getParent()) {\n      // If this scope is an objc method scope, then we succeed.\n      if (S->getFlags() & ObjCMethodScope)\n        return true;\n    }\n    return false;\n  }\n\n  /// isInObjcMethodOuterScope - Return true if this scope is an\n  /// Objective-C method outer most body.\n  bool isInObjcMethodOuterScope() const {\n    if (const Scope *S = this) {\n      // If this scope is an objc method scope, then we succeed.\n      if (S->getFlags() & ObjCMethodScope)\n        return true;\n    }\n    return false;\n  }\n\n  /// isTemplateParamScope - Return true if this scope is a C++\n  /// template parameter scope.\n  bool isTemplateParamScope() const {\n    return getFlags() & Scope::TemplateParamScope;\n  }\n\n  /// isFunctionPrototypeScope - Return true if this scope is a\n  /// function prototype scope.\n  bool isFunctionPrototypeScope() const {\n    return getFlags() & Scope::FunctionPrototypeScope;\n  }\n\n  /// isFunctionDeclarationScope - Return true if this scope is a\n  /// function prototype scope.\n  bool isFunctionDeclarationScope() const {\n    return getFlags() & Scope::FunctionDeclarationScope;\n  }\n\n  /// isAtCatchScope - Return true if this scope is \\@catch.\n  bool isAtCatchScope() const {\n    return getFlags() & Scope::AtCatchScope;\n  }\n\n  /// isCatchScope - Return true if this scope is a C++ catch statement.\n  bool isCatchScope() const { return getFlags() & Scope::CatchScope; }\n\n  /// isSwitchScope - Return true if this scope is a switch scope.\n  bool isSwitchScope() const {\n    for (const Scope *S = this; S; S = S->getParent()) {\n      if (S->getFlags() & Scope::SwitchScope)\n        return true;\n      else if (S->getFlags() & (Scope::FnScope | Scope::ClassScope |\n                                Scope::BlockScope | Scope::TemplateParamScope |\n                                Scope::FunctionPrototypeScope |\n                                Scope::AtCatchScope | Scope::ObjCMethodScope))\n        return false;\n    }\n    return false;\n  }\n\n  /// Determines whether this scope is the OpenMP directive scope\n  bool isOpenMPDirectiveScope() const {\n    return (getFlags() & Scope::OpenMPDirectiveScope);\n  }\n\n  /// Determine whether this scope is some OpenMP loop directive scope\n  /// (for example, 'omp for', 'omp simd').\n  bool isOpenMPLoopDirectiveScope() const {\n    if (getFlags() & Scope::OpenMPLoopDirectiveScope) {\n      assert(isOpenMPDirectiveScope() &&\n             \"OpenMP loop directive scope is not a directive scope\");\n      return true;\n    }\n    return false;\n  }\n\n  /// Determine whether this scope is (or is nested into) some OpenMP\n  /// loop simd directive scope (for example, 'omp simd', 'omp for simd').\n  bool isOpenMPSimdDirectiveScope() const {\n    return getFlags() & Scope::OpenMPSimdDirectiveScope;\n  }\n\n  /// Determine whether this scope is a loop having OpenMP loop\n  /// directive attached.\n  bool isOpenMPLoopScope() const {\n    const Scope *P = getParent();\n    return P && P->isOpenMPLoopDirectiveScope();\n  }\n\n  /// Determine whether this scope is some OpenMP directive with\n  /// order clause which specifies concurrent scope.\n  bool isOpenMPOrderClauseScope() const {\n    return getFlags() & Scope::OpenMPOrderClauseScope;\n  }\n\n  /// Determine whether this scope is a while/do/for statement, which can have\n  /// continue statements embedded into it.\n  bool isContinueScope() const {\n    return getFlags() & ScopeFlags::ContinueScope;\n  }\n\n  /// Determine whether this scope is a C++ 'try' block.\n  bool isTryScope() const { return getFlags() & Scope::TryScope; }\n\n  /// Determine whether this scope is a function-level C++ try or catch scope.\n  bool isFnTryCatchScope() const {\n    return getFlags() & ScopeFlags::FnTryCatchScope;\n  }\n\n  /// Determine whether this scope is a SEH '__try' block.\n  bool isSEHTryScope() const { return getFlags() & Scope::SEHTryScope; }\n\n  /// Determine whether this scope is a SEH '__except' block.\n  bool isSEHExceptScope() const { return getFlags() & Scope::SEHExceptScope; }\n\n  /// Determine whether this scope is a compound statement scope.\n  bool isCompoundStmtScope() const {\n    return getFlags() & Scope::CompoundStmtScope;\n  }\n\n  /// Determine whether this scope is a controlling scope in a\n  /// if/switch/while/for statement.\n  bool isControlScope() const { return getFlags() & Scope::ControlScope; }\n\n  /// Returns if rhs has a higher scope depth than this.\n  ///\n  /// The caller is responsible for calling this only if one of the two scopes\n  /// is an ancestor of the other.\n  bool Contains(const Scope& rhs) const { return Depth < rhs.Depth; }\n\n  /// containedInPrototypeScope - Return true if this or a parent scope\n  /// is a FunctionPrototypeScope.\n  bool containedInPrototypeScope() const;\n\n  void PushUsingDirective(UsingDirectiveDecl *UDir) {\n    UsingDirectives.push_back(UDir);\n  }\n\n  using using_directives_range =\n      llvm::iterator_range<UsingDirectivesTy::iterator>;\n\n  using_directives_range using_directives() {\n    return using_directives_range(UsingDirectives.begin(),\n                                  UsingDirectives.end());\n  }\n\n  void updateNRVOCandidate(VarDecl *VD);\n\n  void applyNRVO();\n\n  /// Init - This is used by the parser to implement scope caching.\n  void Init(Scope *parent, unsigned flags);\n\n  /// Sets up the specified scope flags and adjusts the scope state\n  /// variables accordingly.\n  void AddFlags(unsigned Flags);\n\n  void dumpImpl(raw_ostream &OS) const;\n  void dump() const;\n}",
  "id": "BLOCK-CPP-20227",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Scope.h",
  "source_line": 41,
  "validation_status": "validated"
}