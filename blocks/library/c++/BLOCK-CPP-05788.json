{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\n\n// absl::Span<char> represents a view into the available space in a mutable\n// buffer during encoding.  Encoding functions shrink the span as they go so\n// that the same view can be passed to a series of Encode functions.  If the\n// data do not fit, nothing is encoded, the view is set to size zero (so that\n// all subsequent encode calls fail), and false is returned.  Otherwise true is\n// returned.\n\n// In particular, attempting to encode a series of data into an insufficient\n// buffer has consistent and efficient behavior without any caller-side error\n// checking.  Individual values will be encoded in their entirety or not at all\n// (unless one of the `Truncate` functions is used).  Once a value is omitted\n// because it does not fit, no subsequent values will be encoded to preserve\n// ordering; the decoded sequence will be a prefix of the original sequence.\n\n// There are two ways to encode a message-typed field:\n//\n// * Construct its contents in a separate buffer and use `EncodeBytes` to copy\n//   it into the primary buffer with type, tag, and length.\n// * Use `EncodeMessageStart` to write type and tag fields and reserve space for\n//   the length field, then encode the contents directly into the buffer, then\n//   use `EncodeMessageLength` to write the actual length into the reserved\n//   bytes.  This works fine if the actual length takes fewer bytes to encode\n//   than were reserved, although you don't get your extra bytes back.\n//   This approach will always produce a valid encoding, but your protocol may\n//   require that the whole message field by omitted if the buffer is too small\n//   to contain all desired subfields.  In this case, operate on a copy of the\n//   buffer view and assign back only if everything fit, i.e. if the last\n//   `Encode` call returned true.\n\n// Encodes the specified integer as a varint field and returns true if it fits.\n// Used for int32_t, int64_t, uint32_t, uint64_t, bool, and enum field types.\n// Consumes up to kMaxVarintSize * 2 bytes (20).\nbool EncodeVarint(uint64_t tag, uint64_t value, absl::Span<char> *buf);\ninline bool EncodeVarint(uint64_t tag, int64_t value, absl::Span<char> *buf) {\n  return EncodeVarint(tag, static_cast<uint64_t>(value), buf);\n}\ninline bool EncodeVarint(uint64_t tag, uint32_t value, absl::Span<char> *buf) {\n  return EncodeVarint(tag, static_cast<uint64_t>(value), buf);\n}\ninline bool EncodeVarint(uint64_t tag, int32_t value, absl::Span<char> *buf) {\n  return EncodeVarint(tag, static_cast<uint64_t>(value), buf);\n}\n\n// Encodes the specified integer as a varint field using ZigZag encoding and\n// returns true if it fits.\n// Used for sint32 and sint64 field types.\n// Consumes up to kMaxVarintSize * 2 bytes (20).\ninline bool EncodeVarintZigZag(uint64_t tag, int64_t value,\n                               absl::Span<char> *buf) {\n  if (value < 0)\n    return EncodeVarint(tag, 2 * static_cast<uint64_t>(-(value + 1)) + 1, buf);\n  return EncodeVarint(tag, 2 * static_cast<uint64_t>(value), buf);\n}\n\n// Encodes the specified integer as a 64-bit field and returns true if it fits.\n// Used for fixed64 and sfixed64 field types.\n// Consumes up to kMaxVarintSize + 8 bytes (18).\nbool Encode64Bit(uint64_t tag, uint64_t value, absl::Span<char> *buf);\ninline bool Encode64Bit(uint64_t tag, int64_t value, absl::Span<char> *buf) {\n  return Encode64Bit(tag, static_cast<uint64_t>(value), buf);\n}\ninline bool Encode64Bit(uint64_t tag, uint32_t value, absl::Span<char> *buf) {\n  return Encode64Bit(tag, static_cast<uint64_t>(value), buf);\n}\ninline bool Encode64Bit(uint64_t tag, int32_t value, absl::Span<char> *buf) {\n  return Encode64Bit(tag, static_cast<uint64_t>(value), buf);\n}\n\n// Encodes the specified double as a 64-bit field and returns true if it fits.\n// Used for double field type.\n// Consumes up to kMaxVarintSize + 8 bytes (18).\ninline bool EncodeDouble(uint64_t tag, double value, absl::Span<char> *buf) {\n  return Encode64Bit(tag, absl::bit_cast<uint64_t>(value), buf);\n}\n\n// Encodes the specified integer as a 32-bit field and returns true if it fits.\n// Used for fixed32 and sfixed32 field types.\n// Consumes up to kMaxVarintSize + 4 bytes (14).\nbool Encode32Bit(uint64_t tag, uint32_t value, absl::Span<char> *buf);\ninline bool Encode32Bit(uint64_t tag, int32_t value, absl::Span<char> *buf) {\n  return Encode32Bit(tag, static_cast<uint32_t>(value), buf);\n}\n\n// Encodes the specified float as a 32-bit field and returns true if it fits.\n// Used for float field type.\n// Consumes up to kMaxVarintSize + 4 bytes (14).\ninline bool EncodeFloat(uint64_t tag, float value, absl::Span<char> *buf) {\n  return Encode32Bit(tag, absl::bit_cast<uint32_t>(value), buf);\n}\n\n// Encodes the specified bytes as a length-delimited field and returns true if\n// they fit.\n// Used for string, bytes, message, and packed-repeated field type.\n// Consumes up to kMaxVarintSize * 2 + value.size() bytes (20 + value.size()).\nbool EncodeBytes(uint64_t tag, absl::Span<const char> value,\n                 absl::Span<char> *buf);\n\n// Encodes as many of the specified bytes as will fit as a length-delimited\n// field and returns true as long as the field header (`tag_type` and `length`)\n// fits.\n// Used for string, bytes, message, and packed-repeated field type.\n// Consumes up to kMaxVarintSize * 2 + value.size() bytes (20 + value.size()).\nbool EncodeBytesTruncate(uint64_t tag, absl::Span<const char> value,\n                         absl::Span<char> *buf);\n\n// Encodes the specified string as a length-delimited field and returns true if\n// it fits.\n// Used for string, bytes, message, and packed-repeated field type.\n// Consumes up to kMaxVarintSize * 2 + value.size() bytes (20 + value.size()).\ninline bool EncodeString(uint64_t tag, absl::string_view value,\n                         absl::Span<char> *buf) {\n  return EncodeBytes(tag, value, buf);\n}\n\n// Encodes as much of the specified string as will fit as a length-delimited\n// field and returns true as long as the field header (`tag_type` and `length`)\n// fits.\n// Used for string, bytes, message, and packed-repeated field type.\n// Consumes up to kMaxVarintSize * 2 + value.size() bytes (20 + value.size()).\ninline bool EncodeStringTruncate(uint64_t tag, absl::string_view value,\n                                 absl::Span<char> *buf) {\n  return EncodeBytesTruncate(tag, value, buf);\n}\n\n// Encodes the header for a length-delimited field containing up to `max_size`\n// bytes or the number remaining in the buffer, whichever is less.  If the\n// header fits, a non-nullptr `Span` is returned; this must be passed to\n// `EncodeMessageLength` after all contents are encoded to finalize the length\n// field.  If the header does not fit, a nullptr `Span` is returned which is\n// safe to pass to `EncodeMessageLength` but need not be.\n// Used for string, bytes, message, and packed-repeated field type.\n// Consumes up to kMaxVarintSize * 2 bytes (20).\nABSL_MUST_USE_RESULT absl::Span<char> EncodeMessageStart(uint64_t tag,\n                                                         uint64_t max_size,\n                                                         absl::Span<char> *buf);\n\n// Finalizes the length field in `msg` so that it encompasses all data encoded\n// since the call to `EncodeMessageStart` which returned `msg`.  Does nothing if\n// `msg` is a `nullptr` `Span`.\nvoid EncodeMessageLength(absl::Span<char> msg, const absl::Span<char> *buf);\n\nenum class WireType : uint64_t {\n  kVarint = 0,\n  k64Bit = 1,\n  kLengthDelimited = 2,\n  k32Bit = 5,\n};\n\nconstexpr size_t VarintSize(uint64_t value) {\n  return value < 128 ? 1 : 1 + VarintSize(value >> 7);\n}\nconstexpr size_t MinVarintSize() {\n  return VarintSize((std::numeric_limits<uint64_t>::min)());\n}\nconstexpr size_t MaxVarintSize() {\n  return VarintSize((std::numeric_limits<uint64_t>::max)());\n}\n\nconstexpr uint64_t MaxVarintForSize(size_t size) {\n  return size >= 10 ? (std::numeric_limits<uint64_t>::max)()\n                    : (static_cast<uint64_t>(1) << size * 7) - 1;\n}\n\n// `BufferSizeFor` returns a number of bytes guaranteed to be sufficient to\n// store encoded fields of the specified WireTypes regardless of tag numbers and\n// data values.  This only makes sense for `WireType::kLengthDelimited` if you\n// add in the length of the contents yourself, e.g. for string and bytes fields\n// by adding the lengths of any encoded strings to the return value or for\n// submessage fields by enumerating the fields you may encode into their\n// contents.\nconstexpr size_t BufferSizeFor() { return 0; }\ntemplate <typename... T>\nconstexpr size_t BufferSizeFor(WireType type, T... tail) {\n  // tag_type + data + ...\n  return MaxVarintSize() +\n         (type == WireType::kVarint ? MaxVarintSize() :              //\n              type == WireType::k64Bit ? 8 :                         //\n                  type == WireType::k32Bit ? 4 : MaxVarintSize()) +  //\n         BufferSizeFor(tail...);\n}\n\n// absl::Span<const char> represents a view into the un-processed space in a\n// buffer during decoding.  Decoding functions shrink the span as they go so\n// that the same view can be decoded iteratively until all data are processed.\n// In general, if the buffer is exhausted but additional bytes are expected by\n// the decoder, it will return values as if the additional bytes were zeros.\n// Length-delimited fields are an exception - if the encoded length field\n// indicates more data bytes than are available in the buffer, the `bytes_value`\n// and `string_value` accessors will return truncated views.\n\nclass ProtoField final {\n public:\n  // Consumes bytes from `data` and returns true if there were any bytes to\n  // decode.\n  bool DecodeFrom(absl::Span<const char> *data);\n  uint64_t tag() const { return tag_; }\n  WireType type() const { return type_; }\n\n  // These value accessors will return nonsense if the data were not encoded in\n  // the corresponding wiretype from the corresponding C++ (or other language)\n  // type.\n\n  double double_value() const { return absl::bit_cast<double>(value_); }\n  float float_value() const {\n    return absl::bit_cast<float>(static_cast<uint32_t>(value_));\n  }\n  int32_t int32_value() const { return static_cast<int32_t>(value_); }\n  int64_t int64_value() const { return static_cast<int64_t>(value_); }\n  int32_t sint32_value() const {\n    if (value_ % 2) return static_cast<int32_t>(0 - ((value_ - 1) / 2) - 1);\n    return static_cast<int32_t>(value_ / 2);\n  }\n  int64_t sint64_value() const {\n    if (value_ % 2) return 0 - ((value_ - 1) / 2) - 1;\n    return value_ / 2;\n  }\n  uint32_t uint32_value() const { return static_cast<uint32_t>(value_); }\n  uint64_t uint64_value() const { return value_; }\n  bool bool_value() const { return value_ != 0; }\n  // To decode an enum, call int32_value() and cast to the appropriate type.\n  // Note that the official C++ proto compiler treats enum fields with values\n  // that do not correspond to a defined enumerator as unknown fields.\n\n  // To decode fields within a submessage field, call\n  // `DecodeNextField(field.BytesValue())`.\n  absl::Span<const char> bytes_value() const { return data_; }\n  absl::string_view string_value() const {\n    const auto data = bytes_value();\n    return absl::string_view(data.data(), data.size());\n  }\n  // Returns the encoded length of a length-delimited field.  This equals\n  // `bytes_value().size()` except when the latter has been truncated due to\n  // buffer underrun.\n  uint64_t encoded_length() const { return value_; }\n\n private:\n  uint64_t tag_;\n  WireType type_;\n  // For `kTypeVarint`, `kType64Bit`, and `kType32Bit`, holds the decoded value.\n  // For `kTypeLengthDelimited`, holds the decoded length.\n  uint64_t value_;\n  absl::Span<const char> data_;\n};\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05788",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/proto.h",
  "source_line": 36,
  "validation_status": "validated"
}