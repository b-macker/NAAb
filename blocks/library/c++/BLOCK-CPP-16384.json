{
  "code": "{\n\nclass FileEntryRef;\n\nnamespace optional_detail {\n\n/// Forward declare a template specialization for OptionalStorage.\ntemplate <> class OptionalStorage<clang::FileEntryRef>;\n\n} // namespace optional_detail\n\nclass FileEntry;\n\n/// A reference to a \\c FileEntry that includes the name of the file as it was\n/// accessed by the FileManager's client.\nclass FileEntryRef {\npublic:\n  /// The name of this FileEntry. If a VFS uses 'use-external-name', this is\n  /// the redirected name. See getRequestedName().\n  StringRef getName() const { return getBaseMapEntry().first(); }\n\n  /// The name of this FileEntry, as originally requested without applying any\n  /// remappings for VFS 'use-external-name'.\n  ///\n  /// FIXME: this should be the semantics of getName(). See comment in\n  /// FileManager::getFileRef().\n  StringRef getNameAsRequested() const { return ME->first(); }\n\n  const FileEntry &getFileEntry() const {\n    return *getBaseMapEntry().second->V.get<FileEntry *>();\n  }\n  DirectoryEntryRef getDir() const { return ME->second->Dir; }\n\n  inline off_t getSize() const;\n  inline unsigned getUID() const;\n  inline const llvm::sys::fs::UniqueID &getUniqueID() const;\n  inline time_t getModificationTime() const;\n  inline bool isNamedPipe() const;\n  inline void closeFile() const;\n\n  /// Check if the underlying FileEntry is the same, intentially ignoring\n  /// whether the file was referenced with the same spelling of the filename.\n  friend bool operator==(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return &LHS.getFileEntry() == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return LHS == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return &LHS.getFileEntry() == RHS;\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Hash code is based on the FileEntry, not the specific named reference,\n  /// just like operator==.\n  friend llvm::hash_code hash_value(FileEntryRef Ref) {\n    return llvm::hash_value(&Ref.getFileEntry());\n  }\n\n  struct MapValue;\n\n  /// Type used in the StringMap.\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<MapValue>>;\n\n  /// Type stored in the StringMap.\n  struct MapValue {\n    /// The pointer at another MapEntry is used when the FileManager should\n    /// silently forward from one name to another, which occurs in Redirecting\n    /// VFSs that use external names. In that case, the \\c FileEntryRef\n    /// returned by the \\c FileManager will have the external name, and not the\n    /// name that was used to lookup the file.\n    llvm::PointerUnion<FileEntry *, const MapEntry *> V;\n\n    /// Directory the file was found in.\n    DirectoryEntryRef Dir;\n\n    MapValue() = delete;\n    MapValue(FileEntry &FE, DirectoryEntryRef Dir) : V(&FE), Dir(Dir) {}\n    MapValue(MapEntry &ME, DirectoryEntryRef Dir) : V(&ME), Dir(Dir) {}\n  };\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(const FileEntryRef &RHS) const { return ME == RHS.ME; }\n\n  /// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate\n  /// incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getFileEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this implicit conversion.\n  operator const FileEntry *() const { return &getFileEntry(); }\n\n  FileEntryRef() = delete;\n  explicit FileEntryRef(const MapEntry &ME) : ME(&ME) {\n    assert(ME.second && \"Expected payload\");\n    assert(ME.second->V && \"Expected non-null\");\n  }\n\n  /// Expose the underlying MapEntry to simplify packing in a PointerIntPair or\n  /// PointerUnion and allow construction in Optional.\n  const clang::FileEntryRef::MapEntry &getMapEntry() const { return *ME; }\n\n  /// Retrieve the base MapEntry after redirects.\n  const MapEntry &getBaseMapEntry() const {\n    const MapEntry *Base = ME;\n    while (const auto *Next = Base->second->V.dyn_cast<const MapEntry *>())\n      Base = Next;\n    return *Base;\n  }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<FileEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  FileEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<FileEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  FileEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  FileEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(FileEntryRef(dense_map_empty_tag())) ||\n           isSameRef(FileEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nstatic_assert(sizeof(FileEntryRef) == sizeof(const FileEntry *),\n              \"FileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<FileEntryRef>::value,\n              \"FileEntryRef must be trivially copyable\");\n\nusing OptionalFileEntryRef = CustomizableOptional<FileEntryRef>;\n\nnamespace optional_detail {\n\n/// Customize OptionalStorage<FileEntryRef> to use FileEntryRef and its\n/// optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(std::in_place_t, ArgTypes &&...Args)\n      : StorageImpl(std::in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::FileEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(OptionalFileEntryRef) == sizeof(FileEntryRef),\n              \"OptionalFileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<OptionalFileEntryRef>::value,\n              \"OptionalFileEntryRef should be trivially copyable\");\n\n} // end namespace optional_detail\n}",
  "id": "BLOCK-CPP-16384",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/FileEntry.h",
  "source_line": 42,
  "validation_status": "validated"
}