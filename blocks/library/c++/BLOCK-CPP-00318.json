{
  "code": "{\n    int socket_ = -1;\n\npublic:\n    bool is_connected() const { return socket_ != -1; }\n\n    void close() {\n        if (is_connected()) {\n            ::close(socket_);\n            socket_ = -1;\n        }\n    }\n\n    int fd() const { return socket_; }\n\n    ~tcp_client() { close(); }\n\n    // try to connect or throw on failure\n    void connect(const std::string &host, int port) {\n        close();\n        struct addrinfo hints {};\n        memset(&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = AF_UNSPEC;      // To work with IPv4, IPv6, and so on\n        hints.ai_socktype = SOCK_STREAM;  // TCP\n        hints.ai_flags = AI_NUMERICSERV;  // port passed as as numeric value\n        hints.ai_protocol = 0;\n\n        auto port_str = std::to_string(port);\n        struct addrinfo *addrinfo_result;\n        auto rv = ::getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrinfo_result);\n        if (rv != 0) {\n            throw_spdlog_ex(fmt_lib::format(\"::getaddrinfo failed: {}\", gai_strerror(rv)));\n        }\n\n        // Try each address until we successfully connect(2).\n        int last_errno = 0;\n        for (auto *rp = addrinfo_result; rp != nullptr; rp = rp->ai_next) {\n#if defined(SOCK_CLOEXEC)\n            const int flags = SOCK_CLOEXEC;\n#else\n            const int flags = 0;\n#endif\n            socket_ = ::socket(rp->ai_family, rp->ai_socktype | flags, rp->ai_protocol);\n            if (socket_ == -1) {\n                last_errno = errno;\n                continue;\n            }\n            rv = ::connect(socket_, rp->ai_addr, rp->ai_addrlen);\n            if (rv == 0) {\n                break;\n            }\n            last_errno = errno;\n            ::close(socket_);\n            socket_ = -1;\n        }\n        ::freeaddrinfo(addrinfo_result);\n        if (socket_ == -1) {\n            throw_spdlog_ex(\"::connect failed\", last_errno);\n        }\n\n        // set TCP_NODELAY\n        int enable_flag = 1;\n        ::setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&enable_flag),\n                     sizeof(enable_flag));\n\n        // prevent sigpipe on systems where MSG_NOSIGNAL is not available\n#if defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)\n        ::setsockopt(socket_, SOL_SOCKET, SO_NOSIGPIPE, reinterpret_cast<char *>(&enable_flag),\n                     sizeof(enable_flag));\n#endif\n\n#if !defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)\n    #error \"tcp_sink would raise SIGPIPE since neither SO_NOSIGPIPE nor MSG_NOSIGNAL are available\"\n#endif\n    }\n\n    // Send exactly n_bytes of the given data.\n    // On error close the connection and throw.\n    void send(const char *data, size_t n_bytes) {\n        size_t bytes_sent = 0;\n        while (bytes_sent < n_bytes) {\n#if defined(MSG_NOSIGNAL)\n            const int send_flags = MSG_NOSIGNAL;\n#else\n            const int send_flags = 0;\n#endif\n            auto write_result =\n                ::send(socket_, data + bytes_sent, n_bytes - bytes_sent, send_flags);\n            if (write_result < 0) {\n                close();\n                throw_spdlog_ex(\"write(2) failed\", errno);\n            }\n\n            if (write_result == 0)  // (probably should not happen but in any case..)\n            {\n                break;\n            }\n            bytes_sent += static_cast<size_t>(write_result);\n        }\n    }\n}",
  "id": "BLOCK-CPP-00318",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/tcp_client.h",
  "source_line": 25,
  "validation_status": "validated"
}