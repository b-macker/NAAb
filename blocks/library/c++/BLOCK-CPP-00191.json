{
  "code": "{\n\n// inplace convert to lowercase\ninline std::string &to_lower_(std::string &str) {\n    std::transform(str.begin(), str.end(), str.begin(), [](char ch) {\n        return static_cast<char>((ch >= 'A' && ch <= 'Z') ? ch + ('a' - 'A') : ch);\n    });\n    return str;\n}\n\n// inplace trim spaces\ninline std::string &trim_(std::string &str) {\n    const char *spaces = \" \\n\\r\\t\";\n    str.erase(str.find_last_not_of(spaces) + 1);\n    str.erase(0, str.find_first_not_of(spaces));\n    return str;\n}\n\n// return (name,value) trimmed pair from given \"name=value\" string.\n// return empty string on missing parts\n// \"key=val\" => (\"key\", \"val\")\n// \" key  =  val \" => (\"key\", \"val\")\n// \"key=\" => (\"key\", \"\")\n// \"val\" => (\"\", \"val\")\n\ninline std::pair<std::string, std::string> extract_kv_(char sep, const std::string &str) {\n    auto n = str.find(sep);\n    std::string k, v;\n    if (n == std::string::npos) {\n        v = str;\n    } else {\n        k = str.substr(0, n);\n        v = str.substr(n + 1);\n    }\n    return std::make_pair(trim_(k), trim_(v));\n}\n\n// return vector of key/value pairs from sequence of \"K1=V1,K2=V2,..\"\n// \"a=AAA,b=BBB,c=CCC,..\" => {(\"a\",\"AAA\"),(\"b\",\"BBB\"),(\"c\", \"CCC\"),...}\ninline std::unordered_map<std::string, std::string> extract_key_vals_(const std::string &str) {\n    std::string token;\n    std::istringstream token_stream(str);\n    std::unordered_map<std::string, std::string> rv{};\n    while (std::getline(token_stream, token, ',')) {\n        if (token.empty()) {\n            continue;\n        }\n        auto kv = extract_kv_('=', token);\n        rv[kv.first] = kv.second;\n    }\n    return rv;\n}\n\nSPDLOG_INLINE void load_levels(const std::string &input) {\n    if (input.empty() || input.size() > 512) {\n        return;\n    }\n\n    auto key_vals = extract_key_vals_(input);\n    std::unordered_map<std::string, level::level_enum> levels;\n    level::level_enum global_level = level::info;\n    bool global_level_found = false;\n\n    for (auto &name_level : key_vals) {\n        auto &logger_name = name_level.first;\n        auto level_name = to_lower_(name_level.second);\n        auto level = level::from_str(level_name);\n        // ignore unrecognized level names\n        if (level == level::off && level_name != \"off\") {\n            continue;\n        }\n        if (logger_name.empty())  // no logger name indicate global level\n        {\n            global_level_found = true;\n            global_level = level;\n        } else {\n            levels[logger_name] = level;\n        }\n    }\n\n    details::registry::instance().set_levels(std::move(levels),\n                                             global_level_found ? &global_level : nullptr);\n}\n\n}",
  "id": "BLOCK-CPP-00191",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/cfg/helpers-inl.h",
  "source_line": 21,
  "validation_status": "validated"
}