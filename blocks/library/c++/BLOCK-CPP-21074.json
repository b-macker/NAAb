{
  "code": "{\n  using UIntTy = SourceLocation::UIntTy;\n  using EncodedTy = uint64_t;\n  constexpr static auto UIntBits = SourceLocationEncoding::UIntBits;\n  static_assert(sizeof(EncodedTy) > sizeof(UIntTy), \"Need one extra bit!\");\n\n  // Prev stores the rotated last nonzero location.\n  UIntTy &Prev;\n\n  // Zig-zag encoding turns small signed integers into small unsigned integers.\n  // 0 => 0, -1 => 1, 1 => 2, -2 => 3, ...\n  static UIntTy zigZag(UIntTy V) {\n    UIntTy Sign = (V & (1 << (UIntBits - 1))) ? UIntTy(-1) : UIntTy(0);\n    return Sign ^ (V << 1);\n  }\n  static UIntTy zagZig(UIntTy V) { return (V >> 1) ^ -(V & 1); }\n\n  SourceLocationSequence(UIntTy &Prev) : Prev(Prev) {}\n\n  EncodedTy encodeRaw(UIntTy Raw) {\n    if (Raw == 0)\n      return 0;\n    UIntTy Rotated = SourceLocationEncoding::encodeRaw(Raw);\n    if (Prev == 0)\n      return Prev = Rotated;\n    UIntTy Delta = Rotated - Prev;\n    Prev = Rotated;\n    // Exactly one 33 bit value is possible! (1 << 32).\n    // This is because we have two representations of zero: trivial & relative.\n    return 1 + EncodedTy{zigZag(Delta)};\n  }\n  UIntTy decodeRaw(EncodedTy Encoded) {\n    if (Encoded == 0)\n      return 0;\n    if (Prev == 0)\n      return SourceLocationEncoding::decodeRaw(Prev = Encoded);\n    return SourceLocationEncoding::decodeRaw(Prev += zagZig(Encoded - 1));\n  }\n\npublic:\n  SourceLocation decode(EncodedTy Encoded) {\n    return SourceLocation::getFromRawEncoding(decodeRaw(Encoded));\n  }\n  EncodedTy encode(SourceLocation Loc) {\n    return encodeRaw(Loc.getRawEncoding());\n  }\n\n  class State;\n}",
  "id": "BLOCK-CPP-21074",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/SourceLocationEncoding.h",
  "source_line": 87,
  "validation_status": "validated"
}