{
  "code": "{\nclass SourceLocationSequence;\n\n/// Serialized encoding of SourceLocations without context.\n/// Optimized to have small unsigned values (=> small after VBR encoding).\n///\n// Macro locations have the top bit set, we rotate by one so it is the low bit.\nclass SourceLocationEncoding {\n  using UIntTy = SourceLocation::UIntTy;\n  constexpr static unsigned UIntBits = CHAR_BIT * sizeof(UIntTy);\n\n  static UIntTy encodeRaw(UIntTy Raw) {\n    return (Raw << 1) | (Raw >> (UIntBits - 1));\n  }\n  static UIntTy decodeRaw(UIntTy Raw) {\n    return (Raw >> 1) | (Raw << (UIntBits - 1));\n  }\n  friend SourceLocationSequence;\n\npublic:\n  static uint64_t encode(SourceLocation Loc,\n                         SourceLocationSequence * = nullptr);\n  static SourceLocation decode(uint64_t, SourceLocationSequence * = nullptr);\n};\n\n/// Serialized encoding of a sequence of SourceLocations.\n///\n/// Optimized to produce small values when locations with the sequence are\n/// similar. Each element can be delta-encoded against the last nonzero element.\n///\n/// Sequences should be started by creating a SourceLocationSequence::State,\n/// and then passed around as SourceLocationSequence*. Example:\n///\n///   // establishes a sequence\n///   void EmitTopLevelThing() {\n///     SourceLocationSequence::State Seq;\n///     EmitContainedThing(Seq);\n///     EmitRecursiveThing(Seq);\n///   }\n///\n///   // optionally part of a sequence\n///   void EmitContainedThing(SourceLocationSequence *Seq = nullptr) {\n///     Record.push_back(SourceLocationEncoding::encode(SomeLoc, Seq));\n///   }\n///\n///   // establishes a sequence if there isn't one already\n///   void EmitRecursiveThing(SourceLocationSequence *ParentSeq = nullptr) {\n///     SourceLocationSequence::State Seq(ParentSeq);\n///     Record.push_back(SourceLocationEncoding::encode(SomeLoc, Seq));\n///     EmitRecursiveThing(Seq);\n///   }\n///\nclass SourceLocationSequence {\n  using UIntTy = SourceLocation::UIntTy;\n  using EncodedTy = uint64_t;\n  constexpr static auto UIntBits = SourceLocationEncoding::UIntBits;\n  static_assert(sizeof(EncodedTy) > sizeof(UIntTy), \"Need one extra bit!\");\n\n  // Prev stores the rotated last nonzero location.\n  UIntTy &Prev;\n\n  // Zig-zag encoding turns small signed integers into small unsigned integers.\n  // 0 => 0, -1 => 1, 1 => 2, -2 => 3, ...\n  static UIntTy zigZag(UIntTy V) {\n    UIntTy Sign = (V & (1 << (UIntBits - 1))) ? UIntTy(-1) : UIntTy(0);\n    return Sign ^ (V << 1);\n  }\n  static UIntTy zagZig(UIntTy V) { return (V >> 1) ^ -(V & 1); }\n\n  SourceLocationSequence(UIntTy &Prev) : Prev(Prev) {}\n\n  EncodedTy encodeRaw(UIntTy Raw) {\n    if (Raw == 0)\n      return 0;\n    UIntTy Rotated = SourceLocationEncoding::encodeRaw(Raw);\n    if (Prev == 0)\n      return Prev = Rotated;\n    UIntTy Delta = Rotated - Prev;\n    Prev = Rotated;\n    // Exactly one 33 bit value is possible! (1 << 32).\n    // This is because we have two representations of zero: trivial & relative.\n    return 1 + EncodedTy{zigZag(Delta)};\n  }\n  UIntTy decodeRaw(EncodedTy Encoded) {\n    if (Encoded == 0)\n      return 0;\n    if (Prev == 0)\n      return SourceLocationEncoding::decodeRaw(Prev = Encoded);\n    return SourceLocationEncoding::decodeRaw(Prev += zagZig(Encoded - 1));\n  }\n\npublic:\n  SourceLocation decode(EncodedTy Encoded) {\n    return SourceLocation::getFromRawEncoding(decodeRaw(Encoded));\n  }\n  EncodedTy encode(SourceLocation Loc) {\n    return encodeRaw(Loc.getRawEncoding());\n  }\n\n  class State;\n};\n\n/// This object establishes a SourceLocationSequence.\nclass SourceLocationSequence::State {\n  UIntTy Prev = 0;\n  SourceLocationSequence Seq;\n\npublic:\n  // If Parent is provided and non-null, then this root becomes part of that\n  // enclosing sequence instead of establishing a new one.\n  State(SourceLocationSequence *Parent = nullptr)\n      : Seq(Parent ? Parent->Prev : Prev) {}\n\n  // Implicit conversion for uniform use of roots vs propagated sequences.\n  operator SourceLocationSequence *() { return &Seq; }\n};\n\ninline uint64_t SourceLocationEncoding::encode(SourceLocation Loc,\n                                               SourceLocationSequence *Seq) {\n  return Seq ? Seq->encode(Loc) : encodeRaw(Loc.getRawEncoding());\n}\ninline SourceLocation\nSourceLocationEncoding::decode(uint64_t Encoded, SourceLocationSequence *Seq) {\n  return Seq ? Seq->decode(Encoded)\n             : SourceLocation::getFromRawEncoding(decodeRaw(Encoded));\n}\n\n}",
  "id": "BLOCK-CPP-21075",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/SourceLocationEncoding.h",
  "source_line": 35,
  "validation_status": "validated"
}