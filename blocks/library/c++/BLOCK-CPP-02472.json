{
  "code": "#include \"absl/crc/internal/crc_cord_state.h\"\n#include <cassert>\n#include \"absl/base/config.h\"\n#include \"absl/numeric/bits.h\"\n\nusing namespace absl;\nusing namespace crc_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02472_execute() {\n    {\n\nCrcCordState::RefcountedRep* CrcCordState::RefSharedEmptyRep() {\n  static CrcCordState::RefcountedRep* empty = new CrcCordState::RefcountedRep;\n\n  assert(empty->count.load(std::memory_order_relaxed) >= 1);\n  assert(empty->rep.removed_prefix.length == 0);\n  assert(empty->rep.prefix_crc.empty());\n\n  Ref(empty);\n  return empty;\n}\n\nCrcCordState::CrcCordState() : refcounted_rep_(new RefcountedRep) {}\n\nCrcCordState::CrcCordState(const CrcCordState& other)\n    : refcounted_rep_(other.refcounted_rep_) {\n  Ref(refcounted_rep_);\n}\n\nCrcCordState::CrcCordState(CrcCordState&& other)\n    : refcounted_rep_(other.refcounted_rep_) {\n  // Make `other` valid for use after move.\n  other.refcounted_rep_ = RefSharedEmptyRep();\n}\n\nCrcCordState& CrcCordState::operator=(const CrcCordState& other) {\n  if (this != &other) {\n    Unref(refcounted_rep_);\n    refcounted_rep_ = other.refcounted_rep_;\n    Ref(refcounted_rep_);\n  }\n  return *this;\n}\n\nCrcCordState& CrcCordState::operator=(CrcCordState&& other) {\n  if (this != &other) {\n    Unref(refcounted_rep_);\n    refcounted_rep_ = other.refcounted_rep_;\n    // Make `other` valid for use after move.\n    other.refcounted_rep_ = RefSharedEmptyRep();\n  }\n  return *this;\n}\n\nCrcCordState::~CrcCordState() {\n  Unref(refcounted_rep_);\n}\n\ncrc32c_t CrcCordState::Checksum() const {\n  if (rep().prefix_crc.empty()) {\n    return absl::crc32c_t{0};\n  }\n  if (IsNormalized()) {\n    return rep().prefix_crc.back().crc;\n  }\n  return absl::RemoveCrc32cPrefix(\n      rep().removed_prefix.crc, rep().prefix_crc.back().crc,\n      rep().prefix_crc.back().length - rep().removed_prefix.length);\n}\n\nCrcCordState::PrefixCrc CrcCordState::NormalizedPrefixCrcAtNthChunk(\n    size_t n) const {\n  assert(n < NumChunks());\n  if (IsNormalized()) {\n    return rep().prefix_crc[n];\n  }\n  size_t length = rep().prefix_crc[n].length - rep().removed_prefix.length;\n  return PrefixCrc(length,\n                   absl::RemoveCrc32cPrefix(rep().removed_prefix.crc,\n                                            rep().prefix_crc[n].crc, length));\n}\n\nvoid CrcCordState::Normalize() {\n  if (IsNormalized() || rep().prefix_crc.empty()) {\n    return;\n  }\n\n  Rep* r = mutable_rep();\n  for (auto& prefix_crc : r->prefix_crc) {\n    size_t remaining = prefix_crc.length - r->removed_prefix.length;\n    prefix_crc.crc = absl::RemoveCrc32cPrefix(r->removed_prefix.crc,\n                                              prefix_crc.crc, remaining);\n    prefix_crc.length = remaining;\n  }\n  r->removed_prefix = PrefixCrc();\n}\n\nvoid CrcCordState::Poison() {\n  Rep* rep = mutable_rep();\n  if (NumChunks() > 0) {\n    for (auto& prefix_crc : rep->prefix_crc) {\n      // This is basically CRC32::Scramble().\n      uint32_t crc = static_cast<uint32_t>(prefix_crc.crc);\n      crc += 0x2e76e41b;\n      crc = absl::rotr(crc, 17);\n      prefix_crc.crc = crc32c_t{crc};\n    }\n  } else {\n    // Add a fake corrupt chunk.\n    rep->prefix_crc.emplace_back(0, crc32c_t{1});\n  }\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02472",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc_cord_state.cc",
  "source_line": 24,
  "validation_status": "validated"
}