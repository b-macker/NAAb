{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace {\n\ntypedef int (*Unwinder)(void**, int*, int, int, const void*, int*);\nstd::atomic<Unwinder> custom;\n\ntemplate <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>\nABSL_ATTRIBUTE_ALWAYS_INLINE inline int Unwind(void** result, int* sizes,\n                                               int max_depth, int skip_count,\n                                               const void* uc,\n                                               int* min_dropped_frames) {\n  Unwinder f = &UnwindImpl<IS_STACK_FRAMES, IS_WITH_CONTEXT>;\n  Unwinder g = custom.load(std::memory_order_acquire);\n  if (g != nullptr) f = g;\n\n  // Add 1 to skip count for the unwinder function itself\n  int size = (*f)(result, sizes, max_depth, skip_count + 1, uc,\n                  min_dropped_frames);\n  // To disable tail call to (*f)(...)\n  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();\n  return size;\n}\n\n}  // anonymous namespace\n\nABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int GetStackFrames(\n    void** result, int* sizes, int max_depth, int skip_count) {\n  return Unwind<true, false>(result, sizes, max_depth, skip_count, nullptr,\n                             nullptr);\n}\n\nABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int\nGetStackFramesWithContext(void** result, int* sizes, int max_depth,\n                          int skip_count, const void* uc,\n                          int* min_dropped_frames) {\n  return Unwind<true, true>(result, sizes, max_depth, skip_count, uc,\n                            min_dropped_frames);\n}\n\nABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int GetStackTrace(\n    void** result, int max_depth, int skip_count) {\n  return Unwind<false, false>(result, nullptr, max_depth, skip_count, nullptr,\n                              nullptr);\n}\n\nABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int\nGetStackTraceWithContext(void** result, int max_depth, int skip_count,\n                         const void* uc, int* min_dropped_frames) {\n  return Unwind<false, true>(result, nullptr, max_depth, skip_count, uc,\n                             min_dropped_frames);\n}\n\nvoid SetStackUnwinder(Unwinder w) {\n  custom.store(w, std::memory_order_release);\n}\n\nint DefaultStackUnwinder(void** pcs, int* sizes, int depth, int skip,\n                         const void* uc, int* min_dropped_frames) {\n  skip++;  // For this function\n  Unwinder f = nullptr;\n  if (sizes == nullptr) {\n    if (uc == nullptr) {\n      f = &UnwindImpl<false, false>;\n    } else {\n      f = &UnwindImpl<false, true>;\n    }\n  } else {\n    if (uc == nullptr) {\n      f = &UnwindImpl<true, false>;\n    } else {\n      f = &UnwindImpl<true, true>;\n    }\n  }\n  volatile int x = 0;\n  int n = (*f)(pcs, sizes, depth, skip, uc, min_dropped_frames);\n  x = 1; (void) x;  // To disable tail call to (*f)(...)\n  return n;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01655",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/stacktrace.cc",
  "source_line": 61,
  "validation_status": "validated"
}