{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::NoDestructor<T>\n//\n// NoDestructor<T> is a wrapper around an object of type T that behaves as an\n// object of type T but never calls T's destructor. NoDestructor<T> makes it\n// safer and/or more efficient to use such objects in static storage contexts:\n// as global or function scope static variables.\n//\n// An instance of absl::NoDestructor<T> has similar type semantics to an\n// instance of T:\n//\n// * Constructs in the same manner as an object of type T through perfect\n//   forwarding.\n// * Provides pointer/reference semantic access to the object of type T via\n//   `->`, `*`, and `get()`.\n//   (Note that `const NoDestructor<T>` works like a pointer to const `T`.)\n//\n// An object of type NoDestructor<T> should be defined in static storage:\n// as either a global static object, or as a function scope static variable.\n//\n// Additionally, NoDestructor<T> provides the following benefits:\n//\n// * Never calls T's destructor for the object\n// * If the object is a function-local static variable, the type can be\n//   lazily constructed.\n//\n// An object of type NoDestructor<T> is \"trivially destructible\" in the notion\n// that its destructor is never run. Provided that an object of this type can be\n// safely initialized and does not need to be cleaned up on program shutdown,\n// NoDestructor<T> allows you to define global static variables, since Google's\n// C++ style guide ban on such objects doesn't apply to objects that are\n// trivially destructible.\n//\n// Usage as Global Static Variables\n//\n// NoDestructor<T> allows declaration of a global object with a non-trivial\n// constructor in static storage without needing to add a destructor.\n// However, such objects still need to worry about initialization order, so\n// such objects should be const initialized:\n//\n//    // Global or namespace scope.\n//    ABSL_CONST_INIT absl::NoDestructor<MyRegistry> reg{\"foo\", \"bar\", 8008};\n//\n// Note that if your object already has a trivial destructor, you don't need to\n// use NoDestructor<T>.\n//\n// Usage as Function Scope Static Variables\n//\n// Function static objects will be lazily initialized within static storage:\n//\n//    // Function scope.\n//    const std::string& MyString() {\n//      static const absl::NoDestructor<std::string> x(\"foo\");\n//      return *x;\n//    }\n//\n// For function static variables, NoDestructor avoids heap allocation and can be\n// inlined in static storage, resulting in exactly-once, thread-safe\n// construction of an object, and very fast access thereafter (the cost is a few\n// extra cycles).\n//\n// Using NoDestructor<T> in this manner is generally better than other patterns\n// which require pointer chasing:\n//\n//   // Prefer using absl::NoDestructor<T> instead for the static variable.\n//   const std::string& MyString() {\n//     static const std::string* x = new std::string(\"foo\");\n//     return *x;\n//   }\n//\ntemplate <typename T>\nclass NoDestructor {\n public:\n  // Forwards arguments to the T's constructor: calls T(args...).\n  template <typename... Ts,\n            // Disable this overload when it might collide with copy/move.\n            typename std::enable_if<!std::is_same<void(std::decay_t<Ts>&...),\n                                                  void(NoDestructor&)>::value,\n                                    int>::type = 0>\n  explicit constexpr NoDestructor(Ts&&... args)\n      : impl_(std::forward<Ts>(args)...) {}\n\n  // Forwards copy and move construction for T. Enables usage like this:\n  //   static NoDestructor<std::array<string, 3>> x{{{\"1\", \"2\", \"3\"}}};\n  //   static NoDestructor<std::vector<int>> x{{1, 2, 3}};\n  explicit constexpr NoDestructor(const T& x) : impl_(x) {}\n  explicit constexpr NoDestructor(T&& x)\n      : impl_(std::move(x)) {}\n\n  // No copying.\n  NoDestructor(const NoDestructor&) = delete;\n  NoDestructor& operator=(const NoDestructor&) = delete;\n\n  // Pretend to be a smart pointer to T with deep constness.\n  // Never returns a null pointer.\n  T& operator*() { return *get(); }\n  T* operator->() { return get(); }\n  T* get() { return impl_.get(); }\n  const T& operator*() const { return *get(); }\n  const T* operator->() const { return get(); }\n  const T* get() const { return impl_.get(); }\n\n private:\n  class DirectImpl {\n   public:\n    template <typename... Args>\n    explicit constexpr DirectImpl(Args&&... args)\n        : value_(std::forward<Args>(args)...) {}\n    const T* get() const { return &value_; }\n    T* get() { return &value_; }\n\n   private:\n    T value_;\n  };\n\n  class PlacementImpl {\n   public:\n    template <typename... Args>\n    explicit PlacementImpl(Args&&... args) {\n      new (&space_) T(std::forward<Args>(args)...);\n    }\n    const T* get() const {\n      return Launder(reinterpret_cast<const T*>(&space_));\n    }\n    T* get() { return Launder(reinterpret_cast<T*>(&space_)); }\n\n   private:\n    template <typename P>\n    static P* Launder(P* p) {\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606L\n      return std::launder(p);\n#elif ABSL_HAVE_BUILTIN(__builtin_launder)\n      return __builtin_launder(p);\n#else\n      // When `std::launder` or equivalent are not available, we rely on\n      // undefined behavior, which works as intended on Abseil's officially\n      // supported platforms as of Q3 2023.\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#endif\n      return p;\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n#endif\n    }\n\n    alignas(T) unsigned char space_[sizeof(T)];\n  };\n\n  // If the object is trivially destructible we use a member directly to avoid\n  // potential once-init runtime initialization. It somewhat defeats the\n  // purpose of NoDestructor in this case, but this makes the class more\n  // friendly to generic code.\n  std::conditional_t<std::is_trivially_destructible<T>::value, DirectImpl,\n                     PlacementImpl>\n      impl_;\n};\n\n#ifdef ABSL_HAVE_CLASS_TEMPLATE_ARGUMENT_DEDUCTION\n// Provide 'Class Template Argument Deduction': the type of NoDestructor's T\n// will be the same type as the argument passed to NoDestructor's constructor.\ntemplate <typename T>\nNoDestructor(T) -> NoDestructor<T>;\n#endif  // ABSL_HAVE_CLASS_TEMPLATE_ARGUMENT_DEDUCTION\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03440",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/no_destructor.h",
  "source_line": 45,
  "validation_status": "validated"
}