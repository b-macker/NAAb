{
  "code": "{\n  ///   // Not valid. We couldn't see reachable here.\n  ///   // So isAvailableForLookup would return false when we look\n  ///   up 'reachable' here.\n  ///   // return reachable(43).v;\n  ///   // Valid. The field name 'v' is allowed during name lookup.\n  ///   // So isAvailableForLookup would return true when we look up 'v' here.\n  ///   return func().v;\n  /// }\n  /// ```\n  static bool isAvailableForLookup(Sema &SemaRef, NamedDecl *ND);\n\n  /// Retrieve the accepted (re)declaration of the given declaration,\n  /// if there is one.\n  NamedDecl *getAcceptableDecl(NamedDecl *D) const {\n    if (!D->isInIdentifierNamespace(IDNS))\n      return nullptr;\n\n    if (isAvailableForLookup(getSema(), D) || isHiddenDeclarationVisible(D))\n      return D;\n\n    return getAcceptableDeclSlow(D);\n  }\n\nprivate:\n  static bool isAcceptableSlow(Sema &SemaRef, NamedDecl *D,\n                               Sema::AcceptableKind Kind);\n  static bool isReachableSlow(Sema &SemaRef, NamedDecl *D);\n  NamedDecl *getAcceptableDeclSlow(NamedDecl *D) const;\n\npublic:\n  /// Returns the identifier namespace mask for this lookup.\n  unsigned getIdentifierNamespace() const {\n    return IDNS;\n  }\n\n  /// Returns whether these results arose from performing a\n  /// lookup into a class.\n  bool isClassLookup() const {\n    return NamingClass != nullptr;\n  }\n\n  /// Returns the 'naming class' for this lookup, i.e. the\n  /// class which was looked into to find these results.\n  ///\n  /// C++0x [class.access.base]p5:\n  ///   The access to a member is affected by the class in which the\n  ///   member is named. This naming class is the class in which the\n  ///   member name was looked up and found. [Note: this class can be\n  ///   explicit, e.g., when a qualified-id is used, or implicit,\n  ///   e.g., when a class member access operator (5.2.5) is used\n  ///   (including cases where an implicit \"this->\" is added). If both\n  ///   a class member access operator and a qualified-id are used to\n  ///   name the member (as in p->T::m), the class naming the member\n  ///   is the class named by the nested-name-specifier of the\n  ///   qualified-id (that is, T). -- end note ]\n  ///\n  /// This is set by the lookup routines when they find results in a class.\n  CXXRecordDecl *getNamingClass() const {\n    return NamingClass;\n  }\n\n  /// Sets the 'naming class' for this lookup.\n  void setNamingClass(CXXRecordDecl *Record) {\n    NamingClass = Record;\n  }\n\n  /// Returns the base object type associated with this lookup;\n  /// important for [class.protected].  Most lookups do not have an\n  /// associated base object.\n  QualType getBaseObjectType() const {\n    return BaseObjectType;\n  }\n\n  /// Sets the base object type for this lookup.\n  void setBaseObjectType(QualType T) {\n    BaseObjectType = T;\n  }\n\n  /// Add a declaration to these results with its natural access.\n  /// Does not test the acceptance criteria.\n  void addDecl(NamedDecl *D) {\n    addDecl(D, D->getAccess());\n  }\n\n  /// Add a declaration to these results with the given access.\n  /// Does not test the acceptance criteria.\n  void addDecl(NamedDecl *D, AccessSpecifier AS) {\n    Decls.addDecl(D, AS);\n    ResultKind = Found;\n  }\n\n  /// Add all the declarations from another set of lookup\n  /// results.\n  void addAllDecls(const LookupResult &Other) {\n    Decls.append(Other.Decls.begin(), Other.Decls.end());\n    ResultKind = Found;\n  }\n\n  /// Determine whether no result was found because we could not\n  /// search into dependent base classes of the current instantiation.\n  bool wasNotFoundInCurrentInstantiation() const {\n    return ResultKind == NotFoundInCurrentInstantiation;\n  }\n\n  /// Note that while no result was found in the current instantiation,\n  /// there were dependent base classes that could not be searched.\n  void setNotFoundInCurrentInstantiation() {\n    assert(ResultKind == NotFound && Decls.empty());\n    ResultKind = NotFoundInCurrentInstantiation;\n  }\n\n  /// Determine whether the lookup result was shadowed by some other\n  /// declaration that lookup ignored.\n  bool isShadowed() const { return Shadowed; }\n\n  /// Note that we found and ignored a declaration while performing\n  /// lookup.\n  void setShadowed() { Shadowed = true; }\n\n  /// Resolves the result kind of the lookup, possibly hiding\n  /// decls.\n  ///\n  /// This should be called in any environment where lookup might\n  /// generate multiple lookup results.\n  void resolveKind();\n\n  /// Re-resolves the result kind of the lookup after a set of\n  /// removals has been performed.\n  void resolveKindAfterFilter() {\n    if (Decls.empty()) {\n      if (ResultKind != NotFoundInCurrentInstantiation)\n        ResultKind = NotFound;\n\n      if (Paths) {\n        deletePaths(Paths);\n        Paths = nullptr;\n      }\n    } else {\n      std::optional<AmbiguityKind> SavedAK;\n      bool WasAmbiguous = false;\n      if (ResultKind == Ambiguous) {\n        SavedAK = Ambiguity;\n        WasAmbiguous = true;\n      }\n      ResultKind = Found;\n      resolveKind();\n\n      // If we didn't make the lookup unambiguous, restore the old\n      // ambiguity kind.\n      if (ResultKind == Ambiguous) {\n        (void)WasAmbiguous;\n        assert(WasAmbiguous);\n        Ambiguity = *SavedAK;\n      } else if (Paths) {\n        deletePaths(Paths);\n        Paths = nullptr;\n      }\n    }\n  }\n\n  template <class DeclClass>\n  DeclClass *getAsSingle() const {\n    if (getResultKind() != Found) return nullptr;\n    return dyn_cast<DeclClass>(getFoundDecl());\n  }\n\n  /// Fetch the unique decl found by this lookup.  Asserts\n  /// that one was found.\n  ///\n  /// This is intended for users who have examined the result kind\n  /// and are certain that there is only one result.\n  NamedDecl *getFoundDecl() const {\n    assert(getResultKind() == Found\n           && \"getFoundDecl called on non-unique result\");\n    return (*begin())->getUnderlyingDecl();\n  }\n\n  /// Fetches a representative decl.  Useful for lazy diagnostics.\n  NamedDecl *getRepresentativeDecl() const {\n    assert(!Decls.empty() && \"cannot get representative of empty set\");\n    return *begin();\n  }\n\n  /// Asks if the result is a single tag decl.\n  bool isSingleTagDecl() const {\n    return getResultKind() == Found && isa<TagDecl>(getFoundDecl());\n  }\n\n  /// Make these results show that the name was found in\n  /// base classes of different types.\n  ///\n  /// The given paths object is copied and invalidated.\n  void setAmbiguousBaseSubobjectTypes(CXXBasePaths &P);\n\n  /// Make these results show that the name was found in\n  /// distinct base classes of the same type.\n  ///\n  /// The given paths object is copied and invalidated.\n  void setAmbiguousBaseSubobjects(CXXBasePaths &P);\n\n  /// Make these results show that the name was found in\n  /// different contexts and a tag decl was hidden by an ordinary\n  /// decl in a different context.\n  void setAmbiguousQualifiedTagHiding() {\n    setAmbiguous(AmbiguousTagHiding);\n  }\n\n  /// Clears out any current state.\n  LLVM_ATTRIBUTE_REINITIALIZES void clear() {\n    ResultKind = NotFound;\n    Decls.clear();\n    if (Paths) deletePaths(Paths);\n    Paths = nullptr;\n    NamingClass = nullptr;\n    Shadowed = false;\n  }\n\n  /// Clears out any current state and re-initializes for a\n  /// different kind of lookup.\n  void clear(Sema::LookupNameKind Kind) {\n    clear();\n    LookupKind = Kind;\n    configure();\n  }\n\n  /// Change this lookup's redeclaration kind.\n  void setRedeclarationKind(Sema::RedeclarationKind RK) {\n    Redecl = (RK != Sema::NotForRedeclaration);\n    ExternalRedecl = (RK == Sema::ForExternalRedeclaration);\n    configure();\n  }\n\n  void dump();\n  void print(raw_ostream &);\n\n  /// Suppress the diagnostics that would normally fire because of this\n  /// lookup.  This happens during (e.g.) redeclaration lookups.\n  void suppressDiagnostics() {\n    Diagnose = false;\n  }\n\n  /// Determines whether this lookup is suppressing diagnostics.\n  bool isSuppressingDiagnostics() const {\n    return !Diagnose;\n  }\n\n  /// Sets a 'context' source range.\n  void setContextRange(SourceRange SR) {\n    NameContextRange = SR;\n  }\n\n  /// Gets the source range of the context of this name; for C++\n  /// qualified lookups, this is the source range of the scope\n  /// specifier.\n  SourceRange getContextRange() const {\n    return NameContextRange;\n  }\n\n  /// Gets the location of the identifier.  This isn't always defined:\n  /// sometimes we're doing lookups on synthesized names.\n  SourceLocation getNameLoc() const {\n    return NameInfo.getLoc();\n  }\n\n  /// Get the Sema object that this lookup result is searching\n  /// with.\n  Sema &getSema() const { return *SemaPtr; }\n\n  /// A class for iterating through a result set and possibly\n  /// filtering out results.  The results returned are possibly\n  /// sugared.\n  class Filter {\n    friend class LookupResult;\n\n    LookupResult &Results;\n    LookupResult::iterator I;\n    bool Changed = false;\n    bool CalledDone = false;\n\n    Filter(LookupResult &Results) : Results(Results), I(Results.begin()) {}\n\n  public:\n    Filter(Filter &&F)\n        : Results(F.Results), I(F.I), Changed(F.Changed),\n          CalledDone(F.CalledDone) {\n      F.CalledDone = true;\n    }\n\n    // The move assignment operator is defined as deleted pending\n    // further motivation.\n    Filter &operator=(Filter &&) = delete;\n\n    // The copy constrcutor and copy assignment operator is defined as deleted\n    // pending further motivation.\n    Filter(const Filter &) = delete;\n    Filter &operator=(const Filter &) = delete;\n\n    ~Filter() {\n      assert(CalledDone &&\n             \"LookupResult::Filter destroyed without done() call\");\n    }\n\n    bool hasNext() const {\n      return I != Results.end();\n    }\n\n    NamedDecl *next() {\n      assert(I != Results.end() && \"next() called on empty filter\");\n      return *I++;\n    }\n\n    /// Restart the iteration.\n    void restart() {\n      I = Results.begin();\n    }\n\n    /// Erase the last element returned from this iterator.\n    void erase() {\n      Results.Decls.erase(--I);\n      Changed = true;\n    }\n\n    /// Replaces the current entry with the given one, preserving the\n    /// access bits.\n    void replace(NamedDecl *D) {\n      Results.Decls.replace(I-1, D);\n      Changed = true;\n    }\n\n    /// Replaces the current entry with the given one.\n    void replace(NamedDecl *D, AccessSpecifier AS) {\n      Results.Decls.replace(I-1, D, AS);\n      Changed = true;\n    }\n\n    void done() {\n      assert(!CalledDone && \"done() called twice\");\n      CalledDone = true;\n\n      if (Changed)\n        Results.resolveKindAfterFilter();\n    }\n  };\n\n  /// Create a filter for this result set.\n  Filter makeFilter() {\n    return Filter(*this);\n  }\n\n  void setFindLocalExtern(bool FindLocalExtern) {\n    if (FindLocalExtern)\n      IDNS |= Decl::IDNS_LocalExtern;\n    else\n      IDNS &= ~Decl::IDNS_LocalExtern;\n  }\n\nprivate:\n  void diagnose() {\n    if (isAmbiguous())\n      getSema().DiagnoseAmbiguousLookup(*this);\n    else if (isClassLookup() && getSema().getLangOpts().AccessControl)\n      getSema().CheckLookupAccess(*this);\n  }\n\n  void setAmbiguous(AmbiguityKind AK) {\n    ResultKind = Ambiguous;\n    Ambiguity = AK;\n  }\n\n  void addDeclsFromBasePaths(const CXXBasePaths &P);\n  void configure();\n\n  bool checkDebugAssumptions() const;\n\n  bool checkUnresolved() const {\n    for (iterator I = begin(), E = end(); I != E; ++I)\n      if (isa<UnresolvedUsingValueDecl>((*I)->getUnderlyingDecl()))\n        return true;\n    return false;\n  }\n\n  static void deletePaths(CXXBasePaths *);\n\n  // Results.\n  LookupResultKind ResultKind = NotFound;\n  // ill-defined unless ambiguous. Still need to be initialized it will be\n  // copied/moved.\n  AmbiguityKind Ambiguity = {};\n  UnresolvedSet<8> Decls;\n  CXXBasePaths *Paths = nullptr;\n  CXXRecordDecl *NamingClass = nullptr;\n  QualType BaseObjectType;\n\n  // Parameters.\n  Sema *SemaPtr;\n  DeclarationNameInfo NameInfo;\n  SourceRange NameContextRange;\n  Sema::LookupNameKind LookupKind;\n  unsigned IDNS = 0; // set by configure()\n\n  bool Redecl;\n  bool ExternalRedecl;\n\n  /// True if tag declarations should be hidden if non-tags\n  ///   are present\n  bool HideTags = true;\n\n  bool Diagnose = false;\n\n  /// True if we should allow hidden declarations to be 'visible'.\n  bool AllowHidden = false;\n\n  /// True if the found declarations were shadowed by some other\n  /// declaration that we skipped. This only happens when \\c LookupKind\n  /// is \\c LookupRedeclarationWithLinkage.\n  bool Shadowed = false;\n\n  /// True if we're looking up a template-name.\n  bool TemplateNameLookup = false;\n}",
  "id": "BLOCK-CPP-19911",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Lookup.h",
  "source_line": 371,
  "validation_status": "validated"
}