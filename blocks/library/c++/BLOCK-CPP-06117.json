{
  "code": "{\n    // See cordz_info_t for forced alignment and size of `cordz_info` details.\n    struct AsTree {\n      explicit constexpr AsTree(absl::cord_internal::CordRep* tree)\n          : rep(tree) {}\n      cordz_info_t cordz_info = kNullCordzInfo;\n      absl::cord_internal::CordRep* rep;\n    };\n\n    explicit Rep(DefaultInitType) {}\n    constexpr Rep() : data{0} {}\n    constexpr Rep(const Rep&) = default;\n    constexpr Rep& operator=(const Rep&) = default;\n\n    explicit constexpr Rep(CordRep* rep) : as_tree(rep) {}\n\n    explicit constexpr Rep(absl::string_view chars)\n        : data{static_cast<char>((chars.size() << 1)),\n               GetOrNull(chars, 0),\n               GetOrNull(chars, 1),\n               GetOrNull(chars, 2),\n               GetOrNull(chars, 3),\n               GetOrNull(chars, 4),\n               GetOrNull(chars, 5),\n               GetOrNull(chars, 6),\n               GetOrNull(chars, 7),\n               GetOrNull(chars, 8),\n               GetOrNull(chars, 9),\n               GetOrNull(chars, 10),\n               GetOrNull(chars, 11),\n               GetOrNull(chars, 12),\n               GetOrNull(chars, 13),\n               GetOrNull(chars, 14)} {}\n\n    // Disable sanitizer as we must always be able to read `tag`.\n    ABSL_CORD_INTERNAL_NO_SANITIZE\n    int8_t tag() const { return reinterpret_cast<const int8_t*>(this)[0]; }\n    void set_tag(int8_t rhs) { reinterpret_cast<int8_t*>(this)[0] = rhs; }\n\n    char* as_chars() { return data + 1; }\n    const char* as_chars() const { return data + 1; }\n\n    bool is_tree() const { return (tag() & 1) != 0; }\n\n    size_t inline_size() const {\n      ABSL_ASSERT(!is_tree());\n      return static_cast<size_t>(tag()) >> 1;\n    }\n\n    void set_inline_size(size_t size) {\n      ABSL_ASSERT(size <= kMaxInline);\n      set_tag(static_cast<int8_t>(size << 1));\n    }\n\n    CordRep* tree() const { return as_tree.rep; }\n    void set_tree(CordRep* rhs) { as_tree.rep = rhs; }\n\n    cordz_info_t cordz_info() const { return as_tree.cordz_info; }\n    void set_cordz_info(cordz_info_t rhs) { as_tree.cordz_info = rhs; }\n\n    void make_tree(CordRep* tree) {\n      as_tree.rep = tree;\n      as_tree.cordz_info = kNullCordzInfo;\n    }\n\n#ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER\n    constexpr Rep SanitizerSafeCopy() const {\n      if (!absl::is_constant_evaluated()) {\n        Rep res;\n        if (is_tree()) {\n          res = *this;\n        } else {\n          res.set_tag(tag());\n          memcpy(res.as_chars(), as_chars(), inline_size());\n        }\n        return res;\n      } else {\n        return *this;\n      }\n    }\n#else\n    constexpr const Rep& SanitizerSafeCopy() const { return *this; }\n#endif\n\n    // If the data has length <= kMaxInline, we store it in `data`, and\n    // store the size in the first char of `data` shifted left + 1.\n    // Else we store it in a tree and store a pointer to that tree in\n    // `as_tree.rep` with a tagged pointer to make `tag() & 1` non zero.\n    union {\n      char data[kMaxInline + 1];\n      AsTree as_tree;\n    };\n  }",
  "id": "BLOCK-CPP-06117",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_internal.h",
  "source_line": 681,
  "validation_status": "validated"
}