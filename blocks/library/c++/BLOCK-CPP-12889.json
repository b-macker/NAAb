{
  "code": "{\n  friend class ASTStmtReader;\n\n  SourceLocation RParenLoc;\n  StringLiteral *AsmStr;\n\n  // FIXME: If we wanted to, we could allocate all of these in one big array.\n  StringLiteral **Constraints = nullptr;\n  StringLiteral **Clobbers = nullptr;\n  IdentifierInfo **Names = nullptr;\n  unsigned NumLabels = 0;\n\npublic:\n  GCCAsmStmt(const ASTContext &C, SourceLocation asmloc, bool issimple,\n             bool isvolatile, unsigned numoutputs, unsigned numinputs,\n             IdentifierInfo **names, StringLiteral **constraints, Expr **exprs,\n             StringLiteral *asmstr, unsigned numclobbers,\n             StringLiteral **clobbers, unsigned numlabels,\n             SourceLocation rparenloc);\n\n  /// Build an empty inline-assembly statement.\n  explicit GCCAsmStmt(EmptyShell Empty) : AsmStmt(GCCAsmStmtClass, Empty) {}\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  //===--- Asm String Analysis ---===//\n\n  const StringLiteral *getAsmString() const { return AsmStr; }\n  StringLiteral *getAsmString() { return AsmStr; }\n  void setAsmString(StringLiteral *E) { AsmStr = E; }\n\n  /// AsmStringPiece - this is part of a decomposed asm string specification\n  /// (for use with the AnalyzeAsmString function below).  An asm string is\n  /// considered to be a concatenation of these parts.\n  class AsmStringPiece {\n  public:\n    enum Kind {\n      String,  // String in .ll asm string form, \"$\" -> \"$$\" and \"%%\" -> \"%\".\n      Operand  // Operand reference, with optional modifier %c4.\n    };\n\n  private:\n    Kind MyKind;\n    std::string Str;\n    unsigned OperandNo;\n\n    // Source range for operand references.\n    CharSourceRange Range;\n\n  public:\n    AsmStringPiece(const std::string &S) : MyKind(String), Str(S) {}\n    AsmStringPiece(unsigned OpNo, const std::string &S, SourceLocation Begin,\n                   SourceLocation End)\n        : MyKind(Operand), Str(S), OperandNo(OpNo),\n          Range(CharSourceRange::getCharRange(Begin, End)) {}\n\n    bool isString() const { return MyKind == String; }\n    bool isOperand() const { return MyKind == Operand; }\n\n    const std::string &getString() const { return Str; }\n\n    unsigned getOperandNo() const {\n      assert(isOperand());\n      return OperandNo;\n    }\n\n    CharSourceRange getRange() const {\n      assert(isOperand() && \"Range is currently used only for Operands.\");\n      return Range;\n    }\n\n    /// getModifier - Get the modifier for this operand, if present.  This\n    /// returns '\\0' if there was no modifier.\n    char getModifier() const;\n  };\n\n  /// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing\n  /// it into pieces.  If the asm string is erroneous, emit errors and return\n  /// true, otherwise return false.  This handles canonicalization and\n  /// translation of strings from GCC syntax to LLVM IR syntax, and handles\n  //// flattening of named references like %[foo] to Operand AsmStringPiece's.\n  unsigned AnalyzeAsmString(SmallVectorImpl<AsmStringPiece> &Pieces,\n                            const ASTContext &C, unsigned &DiagOffs) const;\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  IdentifierInfo *getOutputIdentifier(unsigned i) const { return Names[i]; }\n\n  StringRef getOutputName(unsigned i) const {\n    if (IdentifierInfo *II = getOutputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getOutputConstraint(unsigned i) const;\n\n  const StringLiteral *getOutputConstraintLiteral(unsigned i) const {\n    return Constraints[i];\n  }\n  StringLiteral *getOutputConstraintLiteral(unsigned i) {\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  IdentifierInfo *getInputIdentifier(unsigned i) const {\n    return Names[i + NumOutputs];\n  }\n\n  StringRef getInputName(unsigned i) const {\n    if (IdentifierInfo *II = getInputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getInputConstraint(unsigned i) const;\n\n  const StringLiteral *getInputConstraintLiteral(unsigned i) const {\n    return Constraints[i + NumOutputs];\n  }\n  StringLiteral *getInputConstraintLiteral(unsigned i) {\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Labels ---===//\n\n  bool isAsmGoto() const {\n    return NumLabels > 0;\n  }\n\n  unsigned getNumLabels() const {\n    return NumLabels;\n  }\n\n  IdentifierInfo *getLabelIdentifier(unsigned i) const {\n    return Names[i + NumOutputs + NumInputs];\n  }\n\n  AddrLabelExpr *getLabelExpr(unsigned i) const;\n  StringRef getLabelName(unsigned i) const;\n  using labels_iterator = CastIterator<AddrLabelExpr>;\n  using const_labels_iterator = ConstCastIterator<AddrLabelExpr>;\n  using labels_range = llvm::iterator_range<labels_iterator>;\n  using labels_const_range = llvm::iterator_range<const_labels_iterator>;\n\n  labels_iterator begin_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  labels_iterator end_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_range labels() {\n    return labels_range(begin_labels(), end_labels());\n  }\n\n  const_labels_iterator begin_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  const_labels_iterator end_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_const_range labels() const {\n    return labels_const_range(begin_labels(), end_labels());\n  }\n\nprivate:\n  void setOutputsAndInputsAndClobbers(const ASTContext &C,\n                                      IdentifierInfo **Names,\n                                      StringLiteral **Constraints,\n                                      Stmt **Exprs,\n                                      unsigned NumOutputs,\n                                      unsigned NumInputs,\n                                      unsigned NumLabels,\n                                      StringLiteral **Clobbers,\n                                      unsigned NumClobbers);\n\npublic:\n  //===--- Other ---===//\n\n  /// getNamedOperand - Given a symbolic operand reference like %[foo],\n  /// translate this into a numeric value needed to reference the same operand.\n  /// This returns -1 if the operand name is invalid.\n  int getNamedOperand(StringRef SymbolicName) const;\n\n  StringRef getClobber(unsigned i) const;\n\n  StringLiteral *getClobberStringLiteral(unsigned i) { return Clobbers[i]; }\n  const StringLiteral *getClobberStringLiteral(unsigned i) const {\n    return Clobbers[i];\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GCCAsmStmtClass;\n  }\n}",
  "id": "BLOCK-CPP-12889",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Stmt.h",
  "source_line": 3080,
  "validation_status": "validated"
}