{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// StrReplaceAll()\n//\n// Replaces character sequences within a given string with replacements provided\n// within an initializer list of key/value pairs. Candidate replacements are\n// considered in order as they occur within the string, with earlier matches\n// taking precedence, and longer matches taking precedence for candidates\n// starting at the same position in the string. Once a substitution is made, the\n// replaced text is not considered for any further substitutions.\n//\n// Example:\n//\n//   std::string s = absl::StrReplaceAll(\n//       \"$who bought $count #Noun. Thanks $who!\",\n//       {{\"$count\", absl::StrCat(5)},\n//        {\"$who\", \"Bob\"},\n//        {\"#Noun\", \"Apples\"}});\n//   EXPECT_EQ(\"Bob bought 5 Apples. Thanks Bob!\", s);\nABSL_MUST_USE_RESULT std::string StrReplaceAll(\n    absl::string_view s,\n    std::initializer_list<std::pair<absl::string_view, absl::string_view>>\n        replacements);\n\n// Overload of `StrReplaceAll()` to accept a container of key/value replacement\n// pairs (typically either an associative map or a `std::vector` of `std::pair`\n// elements). A vector of pairs is generally more efficient.\n//\n// Examples:\n//\n//   std::map<const absl::string_view, const absl::string_view> replacements;\n//   replacements[\"$who\"] = \"Bob\";\n//   replacements[\"$count\"] = \"5\";\n//   replacements[\"#Noun\"] = \"Apples\";\n//   std::string s = absl::StrReplaceAll(\n//       \"$who bought $count #Noun. Thanks $who!\",\n//       replacements);\n//   EXPECT_EQ(\"Bob bought 5 Apples. Thanks Bob!\", s);\n//\n//   // A std::vector of std::pair elements can be more efficient.\n//   std::vector<std::pair<const absl::string_view, std::string>> replacements;\n//   replacements.push_back({\"&\", \"&amp;\"});\n//   replacements.push_back({\"<\", \"&lt;\"});\n//   replacements.push_back({\">\", \"&gt;\"});\n//   std::string s = absl::StrReplaceAll(\"if (ptr < &foo)\",\n//                                  replacements);\n//   EXPECT_EQ(\"if (ptr &lt; &amp;foo)\", s);\ntemplate <typename StrToStrMapping>\nstd::string StrReplaceAll(absl::string_view s,\n                          const StrToStrMapping& replacements);\n\n// Overload of `StrReplaceAll()` to replace character sequences within a given\n// output string *in place* with replacements provided within an initializer\n// list of key/value pairs, returning the number of substitutions that occurred.\n//\n// Example:\n//\n//   std::string s = std::string(\"$who bought $count #Noun. Thanks $who!\");\n//   int count;\n//   count = absl::StrReplaceAll({{\"$count\", absl::StrCat(5)},\n//                               {\"$who\", \"Bob\"},\n//                               {\"#Noun\", \"Apples\"}}, &s);\n//  EXPECT_EQ(count, 4);\n//  EXPECT_EQ(\"Bob bought 5 Apples. Thanks Bob!\", s);\nint StrReplaceAll(\n    std::initializer_list<std::pair<absl::string_view, absl::string_view>>\n        replacements,\n    absl::Nonnull<std::string*> target);\n\n// Overload of `StrReplaceAll()` to replace patterns within a given output\n// string *in place* with replacements provided within a container of key/value\n// pairs.\n//\n// Example:\n//\n//   std::string s = std::string(\"if (ptr < &foo)\");\n//   int count = absl::StrReplaceAll({{\"&\", \"&amp;\"},\n//                                    {\"<\", \"&lt;\"},\n//                                    {\">\", \"&gt;\"}}, &s);\n//  EXPECT_EQ(count, 2);\n//  EXPECT_EQ(\"if (ptr &lt; &amp;foo)\", s);\ntemplate <typename StrToStrMapping>\nint StrReplaceAll(const StrToStrMapping& replacements,\n                  absl::Nonnull<std::string*> target);\n\n// Implementation details only, past this point.\nnamespace strings_internal {\n\nstruct ViableSubstitution {\n  absl::string_view old;\n  absl::string_view replacement;\n  size_t offset;\n\n  ViableSubstitution(absl::string_view old_str,\n                     absl::string_view replacement_str, size_t offset_val)\n      : old(old_str), replacement(replacement_str), offset(offset_val) {}\n\n  // One substitution occurs \"before\" another (takes priority) if either\n  // it has the lowest offset, or it has the same offset but a larger size.\n  bool OccursBefore(const ViableSubstitution& y) const {\n    if (offset != y.offset) return offset < y.offset;\n    return old.size() > y.old.size();\n  }\n};\n\n// Build a vector of ViableSubstitutions based on the given list of\n// replacements. subs can be implemented as a priority_queue. However, it turns\n// out that most callers have small enough a list of substitutions that the\n// overhead of such a queue isn't worth it.\ntemplate <typename StrToStrMapping>\nstd::vector<ViableSubstitution> FindSubstitutions(\n    absl::string_view s, const StrToStrMapping& replacements) {\n  std::vector<ViableSubstitution> subs;\n  subs.reserve(replacements.size());\n\n  for (const auto& rep : replacements) {\n    using std::get;\n    absl::string_view old(get<0>(rep));\n\n    size_t pos = s.find(old);\n    if (pos == s.npos) continue;\n\n    // Ignore attempts to replace \"\". This condition is almost never true,\n    // but above condition is frequently true. That's why we test for this\n    // now and not before.\n    if (old.empty()) continue;\n\n    subs.emplace_back(old, get<1>(rep), pos);\n\n    // Insertion sort to ensure the last ViableSubstitution comes before\n    // all the others.\n    size_t index = subs.size();\n    while (--index && subs[index - 1].OccursBefore(subs[index])) {\n      std::swap(subs[index], subs[index - 1]);\n    }\n  }\n  return subs;\n}\n\nint ApplySubstitutions(absl::string_view s,\n                       absl::Nonnull<std::vector<ViableSubstitution>*> subs_ptr,\n                       absl::Nonnull<std::string*> result_ptr);\n\n}  // namespace strings_internal\n\ntemplate <typename StrToStrMapping>\nstd::string StrReplaceAll(absl::string_view s,\n                          const StrToStrMapping& replacements) {\n  auto subs = strings_internal::FindSubstitutions(s, replacements);\n  std::string result;\n  result.reserve(s.size());\n  strings_internal::ApplySubstitutions(s, &subs, &result);\n  return result;\n}\n\ntemplate <typename StrToStrMapping>\nint StrReplaceAll(const StrToStrMapping& replacements,\n                  absl::Nonnull<std::string*> target) {\n  auto subs = strings_internal::FindSubstitutions(*target, replacements);\n  if (subs.empty()) return 0;\n\n  std::string result;\n  result.reserve(target->size());\n  int substitutions =\n      strings_internal::ApplySubstitutions(*target, &subs, &result);\n  target->swap(result);\n  return substitutions;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04183",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_replace.h",
  "source_line": 49,
  "validation_status": "validated"
}