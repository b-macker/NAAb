{
  "code": "{\n  friend class ASTStmtReader;\n\nprotected:\n  /// Number of collapsed loops as specified by 'collapse' clause.\n  unsigned NumAssociatedLoops = 0;\n\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param NumAssociatedLoops Number of loops associated with the construct.\n  ///\n  OMPLoopBasedDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                        SourceLocation StartLoc, SourceLocation EndLoc,\n                        unsigned NumAssociatedLoops)\n      : OMPExecutableDirective(SC, Kind, StartLoc, EndLoc),\n        NumAssociatedLoops(NumAssociatedLoops) {}\n\npublic:\n  /// The expressions built to support OpenMP loops in combined/composite\n  /// pragmas (e.g. pragma omp distribute parallel for)\n  struct DistCombinedHelperExprs {\n    /// DistributeLowerBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *LB;\n    /// DistributeUpperBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *UB;\n    /// DistributeEnsureUpperBound - used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct, EUB depends on DistUB\n    Expr *EUB;\n    /// Distribute loop iteration variable init used when composing 'omp\n    /// distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Init;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Cond;\n    /// Update of LowerBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NUB;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct when schedule is chunked.\n    Expr *DistCond;\n    /// 'omp parallel for' loop condition used when composed with\n    /// 'omp distribute' in the same construct and when schedule is\n    /// chunked and the chunk size is 1.\n    Expr *ParForInDistCond;\n  };\n\n  /// The expressions built for the OpenMP loop CodeGen for the\n  /// whole collapsed loop nest.\n  struct HelperExprs {\n    /// Loop iteration variable.\n    Expr *IterationVarRef;\n    /// Loop last iteration number.\n    Expr *LastIteration;\n    /// Loop number of iterations.\n    Expr *NumIterations;\n    /// Calculation of last iteration.\n    Expr *CalcLastIteration;\n    /// Loop pre-condition.\n    Expr *PreCond;\n    /// Loop condition.\n    Expr *Cond;\n    /// Loop iteration variable init.\n    Expr *Init;\n    /// Loop increment.\n    Expr *Inc;\n    /// IsLastIteration - local flag variable passed to runtime.\n    Expr *IL;\n    /// LowerBound - local variable passed to runtime.\n    Expr *LB;\n    /// UpperBound - local variable passed to runtime.\n    Expr *UB;\n    /// Stride - local variable passed to runtime.\n    Expr *ST;\n    /// EnsureUpperBound -- expression UB = min(UB, NumIterations).\n    Expr *EUB;\n    /// Update of LowerBound for statically scheduled 'omp for' loops.\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled 'omp for' loops.\n    Expr *NUB;\n    /// PreviousLowerBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevLB;\n    /// PreviousUpperBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevUB;\n    /// DistInc - increment expression for distribute loop when found\n    /// combined with a further loop level (e.g. in 'distribute parallel for')\n    /// expression IV = IV + ST\n    Expr *DistInc;\n    /// PrevEUB - expression similar to EUB but to be used when loop\n    /// scheduling uses PrevLB and PrevUB (e.g.  in 'distribute parallel for'\n    /// when ensuring that the UB is either the calculated UB by the runtime or\n    /// the end of the assigned distribute chunk)\n    /// expression UB = min (UB, PrevUB)\n    Expr *PrevEUB;\n    /// Counters Loop counters.\n    SmallVector<Expr *, 4> Counters;\n    /// PrivateCounters Loop counters.\n    SmallVector<Expr *, 4> PrivateCounters;\n    /// Expressions for loop counters inits for CodeGen.\n    SmallVector<Expr *, 4> Inits;\n    /// Expressions for loop counters update for CodeGen.\n    SmallVector<Expr *, 4> Updates;\n    /// Final loop counter values for GodeGen.\n    SmallVector<Expr *, 4> Finals;\n    /// List of counters required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentCounters;\n    /// List of initializers required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentInits;\n    /// List of final conditions required for the generation of the\n    /// non-rectangular loops.\n    SmallVector<Expr *, 4> FinalsConditions;\n    /// Init statement for all captured expressions.\n    Stmt *PreInits;\n\n    /// Expressions used when combining OpenMP loop pragmas\n    DistCombinedHelperExprs DistCombinedFields;\n\n    /// Check if all the expressions are built (does not check the\n    /// worksharing ones).\n    bool builtAll() {\n      return IterationVarRef != nullptr && LastIteration != nullptr &&\n             NumIterations != nullptr && PreCond != nullptr &&\n             Cond != nullptr && Init != nullptr && Inc != nullptr;\n    }\n\n    /// Initialize all the fields to null.\n    /// \\param Size Number of elements in the\n    /// counters/finals/updates/dependent_counters/dependent_inits/finals_conditions\n    /// arrays.\n    void clear(unsigned Size) {\n      IterationVarRef = nullptr;\n      LastIteration = nullptr;\n      CalcLastIteration = nullptr;\n      PreCond = nullptr;\n      Cond = nullptr;\n      Init = nullptr;\n      Inc = nullptr;\n      IL = nullptr;\n      LB = nullptr;\n      UB = nullptr;\n      ST = nullptr;\n      EUB = nullptr;\n      NLB = nullptr;\n      NUB = nullptr;\n      NumIterations = nullptr;\n      PrevLB = nullptr;\n      PrevUB = nullptr;\n      DistInc = nullptr;\n      PrevEUB = nullptr;\n      Counters.resize(Size);\n      PrivateCounters.resize(Size);\n      Inits.resize(Size);\n      Updates.resize(Size);\n      Finals.resize(Size);\n      DependentCounters.resize(Size);\n      DependentInits.resize(Size);\n      FinalsConditions.resize(Size);\n      for (unsigned I = 0; I < Size; ++I) {\n        Counters[I] = nullptr;\n        PrivateCounters[I] = nullptr;\n        Inits[I] = nullptr;\n        Updates[I] = nullptr;\n        Finals[I] = nullptr;\n        DependentCounters[I] = nullptr;\n        DependentInits[I] = nullptr;\n        FinalsConditions[I] = nullptr;\n      }\n      PreInits = nullptr;\n      DistCombinedFields.LB = nullptr;\n      DistCombinedFields.UB = nullptr;\n      DistCombinedFields.EUB = nullptr;\n      DistCombinedFields.Init = nullptr;\n      DistCombinedFields.Cond = nullptr;\n      DistCombinedFields.NLB = nullptr;\n      DistCombinedFields.NUB = nullptr;\n      DistCombinedFields.DistCond = nullptr;\n      DistCombinedFields.ParForInDistCond = nullptr;\n    }\n  };\n\n  /// Get number of collapsed loops.\n  unsigned getLoopsNumber() const { return NumAssociatedLoops; }\n\n  /// Try to find the next loop sub-statement in the specified statement \\p\n  /// CurStmt.\n  /// \\param TryImperfectlyNestedLoops true, if we need to try to look for the\n  /// imperfectly nested loop.\n  static Stmt *tryToFindNextInnerLoop(Stmt *CurStmt,\n                                      bool TryImperfectlyNestedLoops);\n  static const Stmt *tryToFindNextInnerLoop(const Stmt *CurStmt,\n                                            bool TryImperfectlyNestedLoops) {\n    return tryToFindNextInnerLoop(const_cast<Stmt *>(CurStmt),\n                                  TryImperfectlyNestedLoops);\n  }\n\n  /// Calls the specified callback function for all the loops in \\p CurStmt,\n  /// from the outermost to the innermost.\n  static bool\n  doForAllLoops(Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, Stmt *)> Callback,\n                llvm::function_ref<void(OMPLoopTransformationDirective *)>\n                    OnTransformationCallback);\n  static bool\n  doForAllLoops(const Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, const Stmt *)> Callback,\n                llvm::function_ref<void(const OMPLoopTransformationDirective *)>\n                    OnTransformationCallback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *CurStmt) {\n      return Callback(Cnt, CurStmt);\n    };\n    auto &&NewTransformCb =\n        [OnTransformationCallback](OMPLoopTransformationDirective *A) {\n          OnTransformationCallback(A);\n        };\n    return doForAllLoops(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                         NumLoops, NewCallback, NewTransformCb);\n  }\n\n  /// Calls the specified callback function for all the loops in \\p CurStmt,\n  /// from the outermost to the innermost.\n  static bool\n  doForAllLoops(Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, Stmt *)> Callback) {\n    auto &&TransformCb = [](OMPLoopTransformationDirective *) {};\n    return doForAllLoops(CurStmt, TryImperfectlyNestedLoops, NumLoops, Callback,\n                         TransformCb);\n  }\n  static bool\n  doForAllLoops(const Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, const Stmt *CurStmt) {\n      return Callback(Cnt, CurStmt);\n    };\n    return doForAllLoops(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                         NumLoops, NewCallback);\n  }\n\n  /// Calls the specified callback function for all the loop bodies in \\p\n  /// CurStmt, from the outermost loop to the innermost.\n  static void doForAllLoopsBodies(\n      Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, Stmt *, Stmt *)> Callback);\n  static void doForAllLoopsBodies(\n      const Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, const Stmt *, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *Loop, Stmt *Body) {\n      Callback(Cnt, Loop, Body);\n    };\n    doForAllLoopsBodies(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                        NumLoops, NewCallback);\n  }\n\n  static bool classof(const Stmt *T) {\n    if (auto *D = dyn_cast<OMPExecutableDirective>(T))\n      return isOpenMPLoopDirective(D->getDirectiveKind());\n    return false;\n  }\n}",
  "id": "BLOCK-CPP-13361",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 683,
  "validation_status": "validated"
}