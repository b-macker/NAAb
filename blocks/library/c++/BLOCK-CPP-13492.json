{
  "code": "{\n  friend class ASTContext;\n\n  /// The nested name specifier that qualifies the template\n  /// name.\n  ///\n  /// The bit stored in this qualifier describes whether the \\c Name field\n  /// is interpreted as an IdentifierInfo pointer (when clear) or as an\n  /// overloaded operator kind (when set).\n  llvm::PointerIntPair<NestedNameSpecifier *, 1, bool> Qualifier;\n\n  /// The dependent template name.\n  union {\n    /// The identifier template name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is clear.\n    const IdentifierInfo *Identifier;\n\n    /// The overloaded operator name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is set.\n    OverloadedOperatorKind Operator;\n  };\n\n  /// The canonical template name to which this dependent\n  /// template name refers.\n  ///\n  /// The canonical template name for a dependent template name is\n  /// another dependent template name whose nested name specifier is\n  /// canonical.\n  TemplateName CanonicalTemplateName;\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier,\n                        TemplateName Canon)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(Canon) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator)\n      : Qualifier(Qualifier, true), Operator(Operator),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator,\n                        TemplateName Canon)\n       : Qualifier(Qualifier, true), Operator(Operator),\n         CanonicalTemplateName(Canon) {}\n\npublic:\n  /// Return the nested name specifier that qualifies this name.\n  NestedNameSpecifier *getQualifier() const { return Qualifier.getPointer(); }\n\n  /// Determine whether this template name refers to an identifier.\n  bool isIdentifier() const { return !Qualifier.getInt(); }\n\n  /// Returns the identifier to which this template name refers.\n  const IdentifierInfo *getIdentifier() const {\n    assert(isIdentifier() && \"Template name isn't an identifier?\");\n    return Identifier;\n  }\n\n  /// Determine whether this template name refers to an overloaded\n  /// operator.\n  bool isOverloadedOperator() const { return Qualifier.getInt(); }\n\n  /// Return the overloaded operator to which this template name refers.\n  OverloadedOperatorKind getOperator() const {\n    assert(isOverloadedOperator() &&\n           \"Template name isn't an overloaded operator?\");\n    return Operator;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    if (isIdentifier())\n      Profile(ID, getQualifier(), getIdentifier());\n    else\n      Profile(ID, getQualifier(), getOperator());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      const IdentifierInfo *Identifier) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(false);\n    ID.AddPointer(Identifier);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      OverloadedOperatorKind Operator) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(true);\n    ID.AddInteger(Operator);\n  }\n}",
  "id": "BLOCK-CPP-13492",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TemplateName.h",
  "source_line": 488,
  "validation_status": "validated"
}