{
  "code": "{\npublic:\n  enum Kind { UnknownTy, InvalidTy, SpecificTy, ObjCPointerTy, CPointerTy,\n              AnyCharTy, CStrTy, WCStrTy, WIntTy };\n\n  /// How well a given conversion specifier matches its argument.\n  enum MatchKind {\n    /// The conversion specifier and the argument types are incompatible. For\n    /// instance, \"%d\" and float.\n    NoMatch = 0,\n    /// The conversion specifier and the argument type are compatible. For\n    /// instance, \"%d\" and int.\n    Match = 1,\n    /// The conversion specifier and the argument type are compatible because of\n    /// default argument promotions. For instance, \"%hhd\" and int.\n    MatchPromotion,\n    /// The conversion specifier and the argument type are compatible but still\n    /// seems likely to be an error. For instanace, \"%hhd\" and short.\n    NoMatchPromotionTypeConfusion,\n    /// The conversion specifier and the argument type are disallowed by the C\n    /// standard, but are in practice harmless. For instance, \"%p\" and int*.\n    NoMatchPedantic,\n    /// The conversion specifier and the argument type are compatible, but still\n    /// seems likely to be an error. For instance, \"%hd\" and _Bool.\n    NoMatchTypeConfusion,\n  };\n\nprivate:\n  const Kind K;\n  QualType T;\n  const char *Name = nullptr;\n  bool Ptr = false;\n\n  /// The TypeKind identifies certain well-known types like size_t and\n  /// ptrdiff_t.\n  enum class TypeKind { DontCare, SizeT, PtrdiffT };\n  TypeKind TK = TypeKind::DontCare;\n\npublic:\n  ArgType(Kind K = UnknownTy, const char *N = nullptr) : K(K), Name(N) {}\n  ArgType(QualType T, const char *N = nullptr) : K(SpecificTy), T(T), Name(N) {}\n  ArgType(CanQualType T) : K(SpecificTy), T(T) {}\n\n  static ArgType Invalid() { return ArgType(InvalidTy); }\n  bool isValid() const { return K != InvalidTy; }\n\n  bool isSizeT() const { return TK == TypeKind::SizeT; }\n\n  bool isPtrdiffT() const { return TK == TypeKind::PtrdiffT; }\n\n  /// Create an ArgType which corresponds to the type pointer to A.\n  static ArgType PtrTo(const ArgType& A) {\n    assert(A.K >= InvalidTy && \"ArgType cannot be pointer to invalid/unknown\");\n    ArgType Res = A;\n    Res.Ptr = true;\n    return Res;\n  }\n\n  /// Create an ArgType which corresponds to the size_t/ssize_t type.\n  static ArgType makeSizeT(const ArgType &A) {\n    ArgType Res = A;\n    Res.TK = TypeKind::SizeT;\n    return Res;\n  }\n\n  /// Create an ArgType which corresponds to the ptrdiff_t/unsigned ptrdiff_t\n  /// type.\n  static ArgType makePtrdiffT(const ArgType &A) {\n    ArgType Res = A;\n    Res.TK = TypeKind::PtrdiffT;\n    return Res;\n  }\n\n  MatchKind matchesType(ASTContext &C, QualType argTy) const;\n\n  QualType getRepresentativeType(ASTContext &C) const;\n\n  ArgType makeVectorType(ASTContext &C, unsigned NumElts) const;\n\n  std::string getRepresentativeTypeName(ASTContext &C) const;\n}",
  "id": "BLOCK-CPP-11201",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/FormatString.h",
  "source_line": 254,
  "validation_status": "validated"
}