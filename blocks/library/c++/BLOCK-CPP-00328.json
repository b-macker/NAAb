{
  "code": "#include <spdlog/details/log_msg_buffer.h>\n#include <spdlog/details/mpmc_blocking_q.h>\n#include <spdlog/details/os.h>\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <thread>\n#include <vector>\n\nusing namespace spdlog;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00328_execute() {\n    {\nclass async_logger;\n\nnamespace details {\n\nusing async_logger_ptr = std::shared_ptr<spdlog::async_logger>;\n\nenum class async_msg_type { log, flush, terminate };\n\n// Async msg to move to/from the queue\n// Movable only. should never be copied\nstruct async_msg : log_msg_buffer {\n    async_msg_type msg_type{async_msg_type::log};\n    async_logger_ptr worker_ptr;\n\n    async_msg() = default;\n    ~async_msg() = default;\n\n    // should only be moved in or out of the queue..\n    async_msg(const async_msg &) = delete;\n\n// support for vs2013 move\n#if defined(_MSC_VER) && _MSC_VER <= 1800\n    async_msg(async_msg &&other)\n        : log_msg_buffer(std::move(other)),\n          msg_type(other.msg_type),\n          worker_ptr(std::move(other.worker_ptr)) {}\n\n    async_msg &operator=(async_msg &&other) {\n        *static_cast<log_msg_buffer *>(this) = std::move(other);\n        msg_type = other.msg_type;\n        worker_ptr = std::move(other.worker_ptr);\n        return *this;\n    }\n#else  // (_MSC_VER) && _MSC_VER <= 1800\n    async_msg(async_msg &&) = default;\n    async_msg &operator=(async_msg &&) = default;\n#endif\n\n    // construct from log_msg with given type\n    async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)\n        : log_msg_buffer{m},\n          msg_type{the_type},\n          worker_ptr{std::move(worker)} {}\n\n    async_msg(async_logger_ptr &&worker, async_msg_type the_type)\n        : log_msg_buffer{},\n          msg_type{the_type},\n          worker_ptr{std::move(worker)} {}\n\n    explicit async_msg(async_msg_type the_type)\n        : async_msg{nullptr, the_type} {}\n};\n\nclass SPDLOG_API thread_pool {\npublic:\n    using item_type = async_msg;\n    using q_type = details::mpmc_blocking_queue<item_type>;\n\n    thread_pool(size_t q_max_items,\n                size_t threads_n,\n                std::function<void()> on_thread_start,\n                std::function<void()> on_thread_stop);\n    thread_pool(size_t q_max_items, size_t threads_n, std::function<void()> on_thread_start);\n    thread_pool(size_t q_max_items, size_t threads_n);\n\n    // message all threads to terminate gracefully and join them\n    ~thread_pool();\n\n    thread_pool(const thread_pool &) = delete;\n    thread_pool &operator=(thread_pool &&) = delete;\n\n    void post_log(async_logger_ptr &&worker_ptr,\n                  const details::log_msg &msg,\n                  async_overflow_policy overflow_policy);\n    void post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy);\n    size_t overrun_counter();\n    void reset_overrun_counter();\n    size_t discard_counter();\n    void reset_discard_counter();\n    size_t queue_size();\n\nprivate:\n    q_type q_;\n\n    std::vector<std::thread> threads_;\n\n    void post_async_msg_(async_msg &&new_msg, async_overflow_policy overflow_policy);\n    void worker_loop_();\n\n    // process next message in the queue\n    // return true if this thread should still be active (while no terminate msg\n    // was received)\n    bool process_next_msg_();\n};\n\n}  // namespace details\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00328",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/thread_pool.h",
  "source_line": 16,
  "validation_status": "validated"
}