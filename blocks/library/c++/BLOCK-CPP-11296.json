{
  "code": "{\n  class ASTContext;\n  class BlockDecl;\n  class CXXConstructorDecl;\n  class CXXDestructorDecl;\n  class CXXMethodDecl;\n  class FunctionDecl;\n  struct MethodVFTableLocation;\n  class NamedDecl;\n  class ObjCMethodDecl;\n  class StringLiteral;\n  struct ThisAdjustment;\n  struct ThunkInfo;\n  class VarDecl;\n\n/// MangleContext - Context for tracking state which persists across multiple\n/// calls to the C++ name mangler.\nclass MangleContext {\npublic:\n  enum ManglerKind {\n    MK_Itanium,\n    MK_Microsoft\n  };\n\nprivate:\n  virtual void anchor();\n\n  ASTContext &Context;\n  DiagnosticsEngine &Diags;\n  const ManglerKind Kind;\n  /// For aux target. If true, uses mangling number for aux target from\n  /// ASTContext.\n  bool IsAux = false;\n\n  llvm::DenseMap<const BlockDecl*, unsigned> GlobalBlockIds;\n  llvm::DenseMap<const BlockDecl*, unsigned> LocalBlockIds;\n  llvm::DenseMap<const NamedDecl*, uint64_t> AnonStructIds;\n  llvm::DenseMap<const FunctionDecl*, unsigned> FuncAnonStructSize;\n\npublic:\n  ManglerKind getKind() const { return Kind; }\n\n  bool isAux() const { return IsAux; }\n\n  explicit MangleContext(ASTContext &Context, DiagnosticsEngine &Diags,\n                         ManglerKind Kind, bool IsAux = false)\n      : Context(Context), Diags(Diags), Kind(Kind), IsAux(IsAux) {}\n\n  virtual ~MangleContext() { }\n\n  ASTContext &getASTContext() const { return Context; }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  virtual void startNewFunction() { LocalBlockIds.clear(); }\n\n  unsigned getBlockId(const BlockDecl *BD, bool Local) {\n    llvm::DenseMap<const BlockDecl *, unsigned> &BlockIds\n      = Local? LocalBlockIds : GlobalBlockIds;\n    std::pair<llvm::DenseMap<const BlockDecl *, unsigned>::iterator, bool>\n      Result = BlockIds.insert(std::make_pair(BD, BlockIds.size()));\n    return Result.first->second;\n  }\n\n  uint64_t getAnonymousStructId(const NamedDecl *D,\n                                const FunctionDecl *FD = nullptr) {\n    auto FindResult = AnonStructIds.find(D);\n    if (FindResult != AnonStructIds.end())\n      return FindResult->second;\n\n    // If FunctionDecl is passed in, the anonymous structID will be per-function\n    // based.\n    unsigned Id = FD ? FuncAnonStructSize[FD]++ : AnonStructIds.size();\n    std::pair<llvm::DenseMap<const NamedDecl *, uint64_t>::iterator, bool>\n        Result = AnonStructIds.insert(std::make_pair(D, Id));\n    return Result.first->second;\n  }\n\n  uint64_t getAnonymousStructIdForDebugInfo(const NamedDecl *D) {\n    llvm::DenseMap<const NamedDecl *, uint64_t>::iterator Result =\n        AnonStructIds.find(D);\n    // The decl should already be inserted, but return 0 in case it is not.\n    if (Result == AnonStructIds.end())\n      return 0;\n    return Result->second;\n  }\n\n  virtual std::string getLambdaString(const CXXRecordDecl *Lambda) = 0;\n\n  /// @name Mangler Entry Points\n  /// @{\n\n  bool shouldMangleDeclName(const NamedDecl *D);\n  virtual bool shouldMangleCXXName(const NamedDecl *D) = 0;\n  virtual bool shouldMangleStringLiteral(const StringLiteral *SL) = 0;\n\n  virtual bool isUniqueInternalLinkageDecl(const NamedDecl *ND) {\n    return false;\n  }\n\n  virtual void needsUniqueInternalLinkageNames() { }\n\n  // FIXME: consider replacing raw_ostream & with something like SmallString &.\n  void mangleName(GlobalDecl GD, raw_ostream &);\n  virtual void mangleCXXName(GlobalDecl GD, raw_ostream &) = 0;\n  virtual void mangleThunk(const CXXMethodDecl *MD,\n                          const ThunkInfo &Thunk,\n                          raw_ostream &) = 0;\n  virtual void mangleCXXDtorThunk(const CXXDestructorDecl *DD, CXXDtorType Type,\n                                  const ThisAdjustment &ThisAdjustment,\n                                  raw_ostream &) = 0;\n  virtual void mangleReferenceTemporary(const VarDecl *D,\n                                        unsigned ManglingNumber,\n                                        raw_ostream &) = 0;\n  virtual void mangleCXXRTTI(QualType T, raw_ostream &) = 0;\n  virtual void mangleCXXRTTIName(QualType T, raw_ostream &,\n                                 bool NormalizeIntegers = false) = 0;\n  virtual void mangleStringLiteral(const StringLiteral *SL, raw_ostream &) = 0;\n  virtual void mangleMSGuidDecl(const MSGuidDecl *GD, raw_ostream&);\n\n  void mangleGlobalBlock(const BlockDecl *BD,\n                         const NamedDecl *ID,\n                         raw_ostream &Out);\n  void mangleCtorBlock(const CXXConstructorDecl *CD, CXXCtorType CT,\n                       const BlockDecl *BD, raw_ostream &Out);\n  void mangleDtorBlock(const CXXDestructorDecl *CD, CXXDtorType DT,\n                       const BlockDecl *BD, raw_ostream &Out);\n  void mangleBlock(const DeclContext *DC, const BlockDecl *BD,\n                   raw_ostream &Out);\n\n  void mangleObjCMethodName(const ObjCMethodDecl *MD, raw_ostream &OS,\n                            bool includePrefixByte = true,\n                            bool includeCategoryNamespace = true);\n  void mangleObjCMethodNameAsSourceName(const ObjCMethodDecl *MD,\n                                        raw_ostream &);\n\n  virtual void mangleStaticGuardVariable(const VarDecl *D, raw_ostream &) = 0;\n\n  virtual void mangleDynamicInitializer(const VarDecl *D, raw_ostream &) = 0;\n\n  virtual void mangleDynamicAtExitDestructor(const VarDecl *D,\n                                             raw_ostream &) = 0;\n\n  virtual void mangleSEHFilterExpression(GlobalDecl EnclosingDecl,\n                                         raw_ostream &Out) = 0;\n\n  virtual void mangleSEHFinallyBlock(GlobalDecl EnclosingDecl,\n                                     raw_ostream &Out) = 0;\n\n  /// Generates a unique string for an externally visible type for use with TBAA\n  /// or type uniquing.\n  /// TODO: Extend this to internal types by generating names that are unique\n  /// across translation units so it can be used with LTO.\n  virtual void mangleTypeName(QualType T, raw_ostream &,\n                              bool NormalizeIntegers = false) = 0;\n\n  /// @}\n};\n\nclass ItaniumMangleContext : public MangleContext {\npublic:\n  using DiscriminatorOverrideTy =\n      std::optional<unsigned> (*)(ASTContext &, const NamedDecl *);\n  explicit ItaniumMangleContext(ASTContext &C, DiagnosticsEngine &D,\n                                bool IsAux = false)\n      : MangleContext(C, D, MK_Itanium, IsAux) {}\n\n  virtual void mangleCXXVTable(const CXXRecordDecl *RD, raw_ostream &) = 0;\n  virtual void mangleCXXVTT(const CXXRecordDecl *RD, raw_ostream &) = 0;\n  virtual void mangleCXXCtorVTable(const CXXRecordDecl *RD, int64_t Offset,\n                                   const CXXRecordDecl *Type,\n                                   raw_ostream &) = 0;\n  virtual void mangleItaniumThreadLocalInit(const VarDecl *D,\n                                            raw_ostream &) = 0;\n  virtual void mangleItaniumThreadLocalWrapper(const VarDecl *D,\n                                               raw_ostream &) = 0;\n\n  virtual void mangleCXXCtorComdat(const CXXConstructorDecl *D,\n                                   raw_ostream &) = 0;\n  virtual void mangleCXXDtorComdat(const CXXDestructorDecl *D,\n                                   raw_ostream &) = 0;\n\n  virtual void mangleLambdaSig(const CXXRecordDecl *Lambda, raw_ostream &) = 0;\n\n  virtual void mangleDynamicStermFinalizer(const VarDecl *D, raw_ostream &) = 0;\n\n  virtual void mangleModuleInitializer(const Module *Module, raw_ostream &) = 0;\n\n  // This has to live here, otherwise the CXXNameMangler won't have access to\n  // it.\n  virtual DiscriminatorOverrideTy getDiscriminatorOverride() const = 0;\n  static bool classof(const MangleContext *C) {\n    return C->getKind() == MK_Itanium;\n  }\n\n  static ItaniumMangleContext *\n  create(ASTContext &Context, DiagnosticsEngine &Diags, bool IsAux = false);\n  static ItaniumMangleContext *create(ASTContext &Context,\n                                      DiagnosticsEngine &Diags,\n                                      DiscriminatorOverrideTy Discriminator,\n                                      bool IsAux = false);\n};\n\nclass MicrosoftMangleContext : public MangleContext {\npublic:\n  explicit MicrosoftMangleContext(ASTContext &C, DiagnosticsEngine &D,\n                                  bool IsAux = false)\n      : MangleContext(C, D, MK_Microsoft, IsAux) {}\n\n  /// Mangle vftable symbols.  Only a subset of the bases along the path\n  /// to the vftable are included in the name.  It's up to the caller to pick\n  /// them correctly.\n  virtual void mangleCXXVFTable(const CXXRecordDecl *Derived,\n                                ArrayRef<const CXXRecordDecl *> BasePath,\n                                raw_ostream &Out) = 0;\n\n  /// Mangle vbtable symbols.  Only a subset of the bases along the path\n  /// to the vbtable are included in the name.  It's up to the caller to pick\n  /// them correctly.\n  virtual void mangleCXXVBTable(const CXXRecordDecl *Derived,\n                                ArrayRef<const CXXRecordDecl *> BasePath,\n                                raw_ostream &Out) = 0;\n\n  virtual void mangleThreadSafeStaticGuardVariable(const VarDecl *VD,\n                                                   unsigned GuardNum,\n                                                   raw_ostream &Out) = 0;\n\n  virtual void mangleVirtualMemPtrThunk(const CXXMethodDecl *MD,\n                                        const MethodVFTableLocation &ML,\n                                        raw_ostream &Out) = 0;\n\n  virtual void mangleCXXVirtualDisplacementMap(const CXXRecordDecl *SrcRD,\n                                               const CXXRecordDecl *DstRD,\n                                               raw_ostream &Out) = 0;\n\n  virtual void mangleCXXThrowInfo(QualType T, bool IsConst, bool IsVolatile,\n                                  bool IsUnaligned, uint32_t NumEntries,\n                                  raw_ostream &Out) = 0;\n\n  virtual void mangleCXXCatchableTypeArray(QualType T, uint32_t NumEntries,\n                                           raw_ostream &Out) = 0;\n\n  virtual void mangleCXXCatchableType(QualType T, const CXXConstructorDecl *CD,\n                                      CXXCtorType CT, uint32_t Size,\n                                      uint32_t NVOffset, int32_t VBPtrOffset,\n                                      uint32_t VBIndex, raw_ostream &Out) = 0;\n\n  virtual void mangleCXXRTTIBaseClassDescriptor(\n      const CXXRecordDecl *Derived, uint32_t NVOffset, int32_t VBPtrOffset,\n      uint32_t VBTableOffset, uint32_t Flags, raw_ostream &Out) = 0;\n\n  virtual void mangleCXXRTTIBaseClassArray(const CXXRecordDecl *Derived,\n                                           raw_ostream &Out) = 0;\n  virtual void\n  mangleCXXRTTIClassHierarchyDescriptor(const CXXRecordDecl *Derived,\n                                        raw_ostream &Out) = 0;\n\n  virtual void\n  mangleCXXRTTICompleteObjectLocator(const CXXRecordDecl *Derived,\n                                     ArrayRef<const CXXRecordDecl *> BasePath,\n                                     raw_ostream &Out) = 0;\n\n  static bool classof(const MangleContext *C) {\n    return C->getKind() == MK_Microsoft;\n  }\n\n  static MicrosoftMangleContext *\n  create(ASTContext &Context, DiagnosticsEngine &Diags, bool IsAux = false);\n};\n\nclass ASTNameGenerator {\npublic:\n  explicit ASTNameGenerator(ASTContext &Ctx);\n  ~ASTNameGenerator();\n\n  /// Writes name for \\p D to \\p OS.\n  /// \\returns true on failure, false on success.\n  bool writeName(const Decl *D, raw_ostream &OS);\n\n  /// \\returns name for \\p D\n  std::string getName(const Decl *D);\n\n  /// \\returns all applicable mangled names.\n  /// For example C++ constructors/destructors can have multiple.\n  std::vector<std::string> getAllManglings(const Decl *D);\n\nprivate:\n  class Implementation;\n  std::unique_ptr<Implementation> Impl;\n};\n}",
  "id": "BLOCK-CPP-11296",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Mangle.h",
  "source_line": 28,
  "validation_status": "validated"
}