{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace time_internal {\n// This is a friend wrapper around UnscaledCycleClock::Now()\n// (needed to access UnscaledCycleClock).\nclass UnscaledCycleClockWrapperForGetCurrentTime {\n public:\n  static int64_t Now() { return base_internal::UnscaledCycleClock::Now(); }\n};\n}  // namespace time_internal\n\n// uint64_t is used in this module to provide an extra bit in multiplications\n\n// ---------------------------------------------------------------------\n// An implementation of reader-write locks that use no atomic ops in the read\n// case.  This is a generalization of Lamport's method for reading a multiword\n// clock.  Increment a word on each write acquisition, using the low-order bit\n// as a spinlock; the word is the high word of the \"clock\".  Readers read the\n// high word, then all other data, then the high word again, and repeat the\n// read if the reads of the high words yields different answers, or an odd\n// value (either case suggests possible interference from a writer).\n// Here we use a spinlock to ensure only one writer at a time, rather than\n// spinning on the bottom bit of the word to benefit from SpinLock\n// spin-delay tuning.\n\n// Acquire seqlock (*seq) and return the value to be written to unlock.\nstatic inline uint64_t SeqAcquire(std::atomic<uint64_t> *seq) {\n  uint64_t x = seq->fetch_add(1, std::memory_order_relaxed);\n\n  // We put a release fence between update to *seq and writes to shared data.\n  // Thus all stores to shared data are effectively release operations and\n  // update to *seq above cannot be re-ordered past any of them.  Note that\n  // this barrier is not for the fetch_add above.  A release barrier for the\n  // fetch_add would be before it, not after.\n  std::atomic_thread_fence(std::memory_order_release);\n\n  return x + 2;   // original word plus 2\n}\n\n// Release seqlock (*seq) by writing x to it---a value previously returned by\n// SeqAcquire.\nstatic inline void SeqRelease(std::atomic<uint64_t> *seq, uint64_t x) {\n  // The unlock store to *seq must have release ordering so that all\n  // updates to shared data must finish before this store.\n  seq->store(x, std::memory_order_release);  // release lock for readers\n}\n\n// ---------------------------------------------------------------------\n\n// \"nsscaled\" is unit of time equal to a (2**kScale)th of a nanosecond.\nenum { kScale = 30 };\n\n// The minimum interval between samples of the time base.\n// We pick enough time to amortize the cost of the sample,\n// to get a reasonably accurate cycle counter rate reading,\n// and not so much that calculations will overflow 64-bits.\nstatic const uint64_t kMinNSBetweenSamples = 2000 << 20;\n\n// We require that kMinNSBetweenSamples shifted by kScale\n// have at least a bit left over for 64-bit calculations.\nstatic_assert(((kMinNSBetweenSamples << (kScale + 1)) >> (kScale + 1)) ==\n               kMinNSBetweenSamples,\n               \"cannot represent kMaxBetweenSamplesNSScaled\");\n\n// data from a sample of the kernel's time value\nstruct TimeSampleAtomic {\n  std::atomic<uint64_t> raw_ns{0};              // raw kernel time\n  std::atomic<uint64_t> base_ns{0};             // our estimate of time\n  std::atomic<uint64_t> base_cycles{0};         // cycle counter reading\n  std::atomic<uint64_t> nsscaled_per_cycle{0};  // cycle period\n  // cycles before we'll sample again (a scaled reciprocal of the period,\n  // to avoid a division on the fast path).\n  std::atomic<uint64_t> min_cycles_per_sample{0};\n};\n// Same again, but with non-atomic types\nstruct TimeSample {\n  uint64_t raw_ns = 0;                 // raw kernel time\n  uint64_t base_ns = 0;                // our estimate of time\n  uint64_t base_cycles = 0;            // cycle counter reading\n  uint64_t nsscaled_per_cycle = 0;     // cycle period\n  uint64_t min_cycles_per_sample = 0;  // approx cycles before next sample\n};\n\nstruct ABSL_CACHELINE_ALIGNED TimeState {\n  std::atomic<uint64_t> seq{0};\n  TimeSampleAtomic last_sample;  // the last sample; under seq\n\n  // The following counters are used only by the test code.\n  int64_t stats_initializations{0};\n  int64_t stats_reinitializations{0};\n  int64_t stats_calibrations{0};\n  int64_t stats_slow_paths{0};\n  int64_t stats_fast_slow_paths{0};\n\n  uint64_t last_now_cycles ABSL_GUARDED_BY(lock){0};\n\n  // Used by GetCurrentTimeNanosFromKernel().\n  // We try to read clock values at about the same time as the kernel clock.\n  // This value gets adjusted up or down as estimate of how long that should\n  // take, so we can reject attempts that take unusually long.\n  std::atomic<uint64_t> approx_syscall_time_in_cycles{10 * 1000};\n  // Number of times in a row we've seen a kernel time call take substantially\n  // less than approx_syscall_time_in_cycles.\n  std::atomic<uint32_t> kernel_time_seen_smaller{0};\n\n  // A reader-writer lock protecting the static locations below.\n  // See SeqAcquire() and SeqRelease() above.\n  absl::base_internal::SpinLock lock{absl::kConstInit,\n                                     base_internal::SCHEDULE_KERNEL_ONLY};\n};\nABSL_CONST_INIT static TimeState time_state;\n\n// Return the time in ns as told by the kernel interface.  Place in *cycleclock\n// the value of the cycleclock at about the time of the syscall.\n// This call represents the time base that this module synchronizes to.\n// Ensures that *cycleclock does not step back by up to (1 << 16) from\n// last_cycleclock, to discard small backward counter steps.  (Larger steps are\n// assumed to be complete resyncs, which shouldn't happen.  If they do, a full\n// reinitialization of the outer algorithm should occur.)\nstatic int64_t GetCurrentTimeNanosFromKernel(uint64_t last_cycleclock,\n                                             uint64_t *cycleclock)\n    ABSL_EXCLUSIVE_LOCKS_REQUIRED(time_state.lock) {\n  uint64_t local_approx_syscall_time_in_cycles =  // local copy\n      time_state.approx_syscall_time_in_cycles.load(std::memory_order_relaxed);\n\n  int64_t current_time_nanos_from_system;\n  uint64_t before_cycles;\n  uint64_t after_cycles;\n  uint64_t elapsed_cycles;\n  int loops = 0;\n  do {\n    before_cycles =\n        static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());\n    current_time_nanos_from_system = GET_CURRENT_TIME_NANOS_FROM_SYSTEM();\n    after_cycles =\n        static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());\n    // elapsed_cycles is unsigned, so is large on overflow\n    elapsed_cycles = after_cycles - before_cycles;\n    if (elapsed_cycles >= local_approx_syscall_time_in_cycles &&\n        ++loops == 20) {  // clock changed frequencies?  Back off.\n      loops = 0;\n      if (local_approx_syscall_time_in_cycles < 1000 * 1000) {\n        local_approx_syscall_time_in_cycles =\n            (local_approx_syscall_time_in_cycles + 1) << 1;\n      }\n      time_state.approx_syscall_time_in_cycles.store(\n          local_approx_syscall_time_in_cycles, std::memory_order_relaxed);\n    }\n  } while (elapsed_cycles >= local_approx_syscall_time_in_cycles ||\n           last_cycleclock - after_cycles < (static_cast<uint64_t>(1) << 16));\n\n  // Adjust approx_syscall_time_in_cycles to be within a factor of 2\n  // of the typical time to execute one iteration of the loop above.\n  if ((local_approx_syscall_time_in_cycles >> 1) < elapsed_cycles) {\n    // measured time is no smaller than half current approximation\n    time_state.kernel_time_seen_smaller.store(0, std::memory_order_relaxed);\n  } else if (time_state.kernel_time_seen_smaller.fetch_add(\n                 1, std::memory_order_relaxed) >= 3) {\n    // smaller delays several times in a row; reduce approximation by 12.5%\n    const uint64_t new_approximation =\n        local_approx_syscall_time_in_cycles -\n        (local_approx_syscall_time_in_cycles >> 3);\n    time_state.approx_syscall_time_in_cycles.store(new_approximation,\n                                                   std::memory_order_relaxed);\n    time_state.kernel_time_seen_smaller.store(0, std::memory_order_relaxed);\n  }\n\n  *cycleclock = after_cycles;\n  return current_time_nanos_from_system;\n}\n\nstatic int64_t GetCurrentTimeNanosSlowPath() ABSL_ATTRIBUTE_COLD;\n\n// Read the contents of *atomic into *sample.\n// Each field is read atomically, but to maintain atomicity between fields,\n// the access must be done under a lock.\nstatic void ReadTimeSampleAtomic(const struct TimeSampleAtomic *atomic,\n                                 struct TimeSample *sample) {\n  sample->base_ns = atomic->base_ns.load(std::memory_order_relaxed);\n  sample->base_cycles = atomic->base_cycles.load(std::memory_order_relaxed);\n  sample->nsscaled_per_cycle =\n      atomic->nsscaled_per_cycle.load(std::memory_order_relaxed);\n  sample->min_cycles_per_sample =\n      atomic->min_cycles_per_sample.load(std::memory_order_relaxed);\n  sample->raw_ns = atomic->raw_ns.load(std::memory_order_relaxed);\n}\n\n// Public routine.\n// Algorithm:  We wish to compute real time from a cycle counter.  In normal\n// operation, we construct a piecewise linear approximation to the kernel time\n// source, using the cycle counter value.  The start of each line segment is at\n// the same point as the end of the last, but may have a different slope (that\n// is, a different idea of the cycle counter frequency).  Every couple of\n// seconds, the kernel time source is sampled and compared with the current\n// approximation.  A new slope is chosen that, if followed for another couple\n// of seconds, will correct the error at the current position.  The information\n// for a sample is in the \"last_sample\" struct.  The linear approximation is\n//   estimated_time = last_sample.base_ns +\n//     last_sample.ns_per_cycle * (counter_reading - last_sample.base_cycles)\n// (ns_per_cycle is actually stored in different units and scaled, to avoid\n// overflow).  The base_ns of the next linear approximation is the\n// estimated_time using the last approximation; the base_cycles is the cycle\n// counter value at that time; the ns_per_cycle is the number of ns per cycle\n// measured since the last sample, but adjusted so that most of the difference\n// between the estimated_time and the kernel time will be corrected by the\n// estimated time to the next sample.  In normal operation, this algorithm\n// relies on:\n// - the cycle counter and kernel time rates not changing a lot in a few\n//   seconds.\n// - the client calling into the code often compared to a couple of seconds, so\n//   the time to the next correction can be estimated.\n// Any time ns_per_cycle is not known, a major error is detected, or the\n// assumption about frequent calls is violated, the implementation returns the\n// kernel time.  It records sufficient data that a linear approximation can\n// resume a little later.\n\nint64_t GetCurrentTimeNanos() {\n  // read the data from the \"last_sample\" struct (but don't need raw_ns yet)\n  // The reads of \"seq\" and test of the values emulate a reader lock.\n  uint64_t base_ns;\n  uint64_t base_cycles;\n  uint64_t nsscaled_per_cycle;\n  uint64_t min_cycles_per_sample;\n  uint64_t seq_read0;\n  uint64_t seq_read1;\n\n  // If we have enough information to interpolate, the value returned will be\n  // derived from this cycleclock-derived time estimate.  On some platforms\n  // (POWER) the function to retrieve this value has enough complexity to\n  // contribute to register pressure - reading it early before initializing\n  // the other pieces of the calculation minimizes spill/restore instructions,\n  // minimizing icache cost.\n  uint64_t now_cycles =\n      static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());\n\n  // Acquire pairs with the barrier in SeqRelease - if this load sees that\n  // store, the shared-data reads necessarily see that SeqRelease's updates\n  // to the same shared data.\n  seq_read0 = time_state.seq.load(std::memory_order_acquire);\n\n  base_ns = time_state.last_sample.base_ns.load(std::memory_order_relaxed);\n  base_cycles =\n      time_state.last_sample.base_cycles.load(std::memory_order_relaxed);\n  nsscaled_per_cycle =\n      time_state.last_sample.nsscaled_per_cycle.load(std::memory_order_relaxed);\n  min_cycles_per_sample = time_state.last_sample.min_cycles_per_sample.load(\n      std::memory_order_relaxed);\n\n  // This acquire fence pairs with the release fence in SeqAcquire.  Since it\n  // is sequenced between reads of shared data and seq_read1, the reads of\n  // shared data are effectively acquiring.\n  std::atomic_thread_fence(std::memory_order_acquire);\n\n  // The shared-data reads are effectively acquire ordered, and the\n  // shared-data writes are effectively release ordered. Therefore if our\n  // shared-data reads see any of a particular update's shared-data writes,\n  // seq_read1 is guaranteed to see that update's SeqAcquire.\n  seq_read1 = time_state.seq.load(std::memory_order_relaxed);\n\n  // Fast path.  Return if min_cycles_per_sample has not yet elapsed since the\n  // last sample, and we read a consistent sample.  The fast path activates\n  // only when min_cycles_per_sample is non-zero, which happens when we get an\n  // estimate for the cycle time.  The predicate will fail if now_cycles <\n  // base_cycles, or if some other thread is in the slow path.\n  //\n  // Since we now read now_cycles before base_ns, it is possible for now_cycles\n  // to be less than base_cycles (if we were interrupted between those loads and\n  // last_sample was updated). This is harmless, because delta_cycles will wrap\n  // and report a time much much bigger than min_cycles_per_sample. In that case\n  // we will take the slow path.\n  uint64_t delta_cycles;\n  if (seq_read0 == seq_read1 && (seq_read0 & 1) == 0 &&\n      (delta_cycles = now_cycles - base_cycles) < min_cycles_per_sample) {\n    return static_cast<int64_t>(\n        base_ns + ((delta_cycles * nsscaled_per_cycle) >> kScale));\n  }\n  return GetCurrentTimeNanosSlowPath();\n}\n\n// Return (a << kScale)/b.\n// Zero is returned if b==0.   Scaling is performed internally to\n// preserve precision without overflow.\nstatic uint64_t SafeDivideAndScale(uint64_t a, uint64_t b) {\n  // Find maximum safe_shift so that\n  //  0 <= safe_shift <= kScale  and  (a << safe_shift) does not overflow.\n  int safe_shift = kScale;\n  while (((a << safe_shift) >> safe_shift) != a) {\n    safe_shift--;\n  }\n  uint64_t scaled_b = b >> (kScale - safe_shift);\n  uint64_t quotient = 0;\n  if (scaled_b != 0) {\n    quotient = (a << safe_shift) / scaled_b;\n  }\n  return quotient;\n}\n\nstatic uint64_t UpdateLastSample(\n    uint64_t now_cycles, uint64_t now_ns, uint64_t delta_cycles,\n    const struct TimeSample *sample) ABSL_ATTRIBUTE_COLD;\n\n// The slow path of GetCurrentTimeNanos().  This is taken while gathering\n// initial samples, when enough time has elapsed since the last sample, and if\n// any other thread is writing to last_sample.\n//\n// Manually mark this 'noinline' to minimize stack frame size of the fast\n// path.  Without this, sometimes a compiler may inline this big block of code\n// into the fast path.  That causes lots of register spills and reloads that\n// are unnecessary unless the slow path is taken.\n//\n// TODO(absl-team): Remove this attribute when our compiler is smart enough\n// to do the right thing.\nABSL_ATTRIBUTE_NOINLINE\nstatic int64_t GetCurrentTimeNanosSlowPath()\n    ABSL_LOCKS_EXCLUDED(time_state.lock) {\n  // Serialize access to slow-path.  Fast-path readers are not blocked yet, and\n  // code below must not modify last_sample until the seqlock is acquired.\n  time_state.lock.Lock();\n\n  // Sample the kernel time base.  This is the definition of\n  // \"now\" if we take the slow path.\n  uint64_t now_cycles;\n  uint64_t now_ns = static_cast<uint64_t>(\n      GetCurrentTimeNanosFromKernel(time_state.last_now_cycles, &now_cycles));\n  time_state.last_now_cycles = now_cycles;\n\n  uint64_t estimated_base_ns;\n\n  // ----------\n  // Read the \"last_sample\" values again; this time holding the write lock.\n  struct TimeSample sample;\n  ReadTimeSampleAtomic(&time_state.last_sample, &sample);\n\n  // ----------\n  // Try running the fast path again; another thread may have updated the\n  // sample between our run of the fast path and the sample we just read.\n  uint64_t delta_cycles = now_cycles - sample.base_cycles;\n  if (delta_cycles < sample.min_cycles_per_sample) {\n    // Another thread updated the sample.  This path does not take the seqlock\n    // so that blocked readers can make progress without blocking new readers.\n    estimated_base_ns = sample.base_ns +\n        ((delta_cycles * sample.nsscaled_per_cycle) >> kScale);\n    time_state.stats_fast_slow_paths++;\n  } else {\n    estimated_base_ns =\n        UpdateLastSample(now_cycles, now_ns, delta_cycles, &sample);\n  }\n\n  time_state.lock.Unlock();\n\n  return static_cast<int64_t>(estimated_base_ns);\n}\n\n// Main part of the algorithm.  Locks out readers, updates the approximation\n// using the new sample from the kernel, and stores the result in last_sample\n// for readers.  Returns the new estimated time.\nstatic uint64_t UpdateLastSample(uint64_t now_cycles, uint64_t now_ns,\n                                 uint64_t delta_cycles,\n                                 const struct TimeSample *sample)\n    ABSL_EXCLUSIVE_LOCKS_REQUIRED(time_state.lock) {\n  uint64_t estimated_base_ns = now_ns;\n  uint64_t lock_value =\n      SeqAcquire(&time_state.seq);  // acquire seqlock to block readers\n\n  // The 5s in the next if-statement limits the time for which we will trust\n  // the cycle counter and our last sample to give a reasonable result.\n  // Errors in the rate of the source clock can be multiplied by the ratio\n  // between this limit and kMinNSBetweenSamples.\n  if (sample->raw_ns == 0 ||  // no recent sample, or clock went backwards\n      sample->raw_ns + static_cast<uint64_t>(5) * 1000 * 1000 * 1000 < now_ns ||\n      now_ns < sample->raw_ns || now_cycles < sample->base_cycles) {\n    // record this sample, and forget any previously known slope.\n    time_state.last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);\n    time_state.last_sample.base_ns.store(estimated_base_ns,\n                                         std::memory_order_relaxed);\n    time_state.last_sample.base_cycles.store(now_cycles,\n                                             std::memory_order_relaxed);\n    time_state.last_sample.nsscaled_per_cycle.store(0,\n                                                    std::memory_order_relaxed);\n    time_state.last_sample.min_cycles_per_sample.store(\n        0, std::memory_order_relaxed);\n    time_state.stats_initializations++;\n  } else if (sample->raw_ns + 500 * 1000 * 1000 < now_ns &&\n             sample->base_cycles + 50 < now_cycles) {\n    // Enough time has passed to compute the cycle time.\n    if (sample->nsscaled_per_cycle != 0) {  // Have a cycle time estimate.\n      // Compute time from counter reading, but avoiding overflow\n      // delta_cycles may be larger than on the fast path.\n      uint64_t estimated_scaled_ns;\n      int s = -1;\n      do {\n        s++;\n        estimated_scaled_ns = (delta_cycles >> s) * sample->nsscaled_per_cycle;\n      } while (estimated_scaled_ns / sample->nsscaled_per_cycle !=\n               (delta_cycles >> s));\n      estimated_base_ns = sample->base_ns +\n                          (estimated_scaled_ns >> (kScale - s));\n    }\n\n    // Compute the assumed cycle time kMinNSBetweenSamples ns into the future\n    // assuming the cycle counter rate stays the same as the last interval.\n    uint64_t ns = now_ns - sample->raw_ns;\n    uint64_t measured_nsscaled_per_cycle = SafeDivideAndScale(ns, delta_cycles);\n\n    uint64_t assumed_next_sample_delta_cycles =\n        SafeDivideAndScale(kMinNSBetweenSamples, measured_nsscaled_per_cycle);\n\n    // Estimate low by this much.\n    int64_t diff_ns = static_cast<int64_t>(now_ns - estimated_base_ns);\n\n    // We want to set nsscaled_per_cycle so that our estimate of the ns time\n    // at the assumed cycle time is the assumed ns time.\n    // That is, we want to set nsscaled_per_cycle so:\n    //  kMinNSBetweenSamples + diff_ns  ==\n    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale\n    // But we wish to damp oscillations, so instead correct only most\n    // of our current error, by solving:\n    //  kMinNSBetweenSamples + diff_ns - (diff_ns / 16) ==\n    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale\n    ns = static_cast<uint64_t>(static_cast<int64_t>(kMinNSBetweenSamples) +\n                               diff_ns - (diff_ns / 16));\n    uint64_t new_nsscaled_per_cycle =\n        SafeDivideAndScale(ns, assumed_next_sample_delta_cycles);\n    if (new_nsscaled_per_cycle != 0 &&\n        diff_ns < 100 * 1000 * 1000 && -diff_ns < 100 * 1000 * 1000) {\n      // record the cycle time measurement\n      time_state.last_sample.nsscaled_per_cycle.store(\n          new_nsscaled_per_cycle, std::memory_order_relaxed);\n      uint64_t new_min_cycles_per_sample =\n          SafeDivideAndScale(kMinNSBetweenSamples, new_nsscaled_per_cycle);\n      time_state.last_sample.min_cycles_per_sample.store(\n          new_min_cycles_per_sample, std::memory_order_relaxed);\n      time_state.stats_calibrations++;\n    } else {  // something went wrong; forget the slope\n      time_state.last_sample.nsscaled_per_cycle.store(\n          0, std::memory_order_relaxed);\n      time_state.last_sample.min_cycles_per_sample.store(\n          0, std::memory_order_relaxed);\n      estimated_base_ns = now_ns;\n      time_state.stats_reinitializations++;\n    }\n    time_state.last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);\n    time_state.last_sample.base_ns.store(estimated_base_ns,\n                                         std::memory_order_relaxed);\n    time_state.last_sample.base_cycles.store(now_cycles,\n                                             std::memory_order_relaxed);\n  } else {\n    // have a sample, but no slope; waiting for enough time for a calibration\n    time_state.stats_slow_paths++;\n  }\n\n  SeqRelease(&time_state.seq, lock_value);  // release the readers\n\n  return estimated_base_ns;\n}\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02169",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/clock.cc",
  "source_line": 88,
  "validation_status": "validated"
}