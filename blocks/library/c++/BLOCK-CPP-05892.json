{
  "code": "#include <type_traits>\n#include \"gmock/gmock.h\"\n#include \"absl/random/internal/mock_helpers.h\"\n#include \"absl/random/mocking_bit_gen.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05892_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\ntemplate <typename DistrT, typename Fn>\nstruct MockSingleOverload;\n\n// MockSingleOverload\n//\n// MockSingleOverload hooks in to gMock's `ON_CALL` and `EXPECT_CALL` macros.\n// EXPECT_CALL(mock_single_overload, Call(...))` will expand to a call to\n// `mock_single_overload.gmock_Call(...)`. Because expectations are stored on\n// the MockingBitGen (an argument passed inside `Call(...)`), this forwards to\n// arguments to MockingBitGen::Register.\n//\n// The underlying KeyT must match the KeyT constructed by DistributionCaller.\ntemplate <typename DistrT, typename Ret, typename... Args>\nstruct MockSingleOverload<DistrT, Ret(MockingBitGen&, Args...)> {\n  static_assert(std::is_same<typename DistrT::result_type, Ret>::value,\n                \"Overload signature must have return type matching the \"\n                \"distribution result_type.\");\n  using KeyT = Ret(DistrT, std::tuple<Args...>);\n\n  template <typename MockURBG>\n  auto gmock_Call(MockURBG& gen, const ::testing::Matcher<Args>&... matchers)\n      -> decltype(MockHelpers::MockFor<KeyT>(gen).gmock_Call(matchers...)) {\n    static_assert(std::is_base_of<MockingBitGen, MockURBG>::value,\n                  \"Mocking requires an absl::MockingBitGen\");\n    return MockHelpers::MockFor<KeyT>(gen).gmock_Call(matchers...);\n  }\n};\n\ntemplate <typename DistrT, typename Ret, typename Arg, typename... Args>\nstruct MockSingleOverload<DistrT, Ret(Arg, MockingBitGen&, Args...)> {\n  static_assert(std::is_same<typename DistrT::result_type, Ret>::value,\n                \"Overload signature must have return type matching the \"\n                \"distribution result_type.\");\n  using KeyT = Ret(DistrT, std::tuple<Arg, Args...>);\n\n  template <typename MockURBG>\n  auto gmock_Call(const ::testing::Matcher<Arg>& matcher, MockURBG& gen,\n                  const ::testing::Matcher<Args>&... matchers)\n      -> decltype(MockHelpers::MockFor<KeyT>(gen).gmock_Call(matcher,\n                                                             matchers...)) {\n    static_assert(std::is_base_of<MockingBitGen, MockURBG>::value,\n                  \"Mocking requires an absl::MockingBitGen\");\n    return MockHelpers::MockFor<KeyT>(gen).gmock_Call(matcher, matchers...);\n  }\n};\n\n// MockOverloadSet\n//\n// MockOverloadSet takes a distribution and a collection of signatures and\n// performs overload resolution amongst all the overloads. This makes\n// `EXPECT_CALL(mock_overload_set, Call(...))` expand and do overload resolution\n// correctly.\ntemplate <typename DistrT, typename... Signatures>\nstruct MockOverloadSet;\n\ntemplate <typename DistrT, typename Sig>\nstruct MockOverloadSet<DistrT, Sig> : public MockSingleOverload<DistrT, Sig> {\n  using MockSingleOverload<DistrT, Sig>::gmock_Call;\n};\n\ntemplate <typename DistrT, typename FirstSig, typename... Rest>\nstruct MockOverloadSet<DistrT, FirstSig, Rest...>\n    : public MockSingleOverload<DistrT, FirstSig>,\n      public MockOverloadSet<DistrT, Rest...> {\n  using MockSingleOverload<DistrT, FirstSig>::gmock_Call;\n  using MockOverloadSet<DistrT, Rest...>::gmock_Call;\n};\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05892",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/mock_overload_set.h",
  "source_line": 25,
  "validation_status": "validated"
}