{
  "code": "{\n  std::string result;\n  result.reserve(format.size());  // A reasonable guess for the result size.\n  const time_zone::absolute_lookup al = tz.lookup(tp);\n  const std::tm tm = ToTM(al);\n\n  // Scratch buffer for internal conversions.\n  char buf[3 + kDigits10_64];  // enough for longest conversion\n  char* const ep = buf + sizeof(buf);\n  char* bp;  // works back from ep\n\n  // Maintain three, disjoint subsequences that span format.\n  //   [format.begin() ... pending) : already formatted into result\n  //   [pending ... cur) : formatting pending, but no special cases\n  //   [cur ... format.end()) : unexamined\n  // Initially, everything is in the unexamined part.\n  const char* pending = format.c_str();  // NUL terminated\n  const char* cur = pending;\n  const char* end = pending + format.length();\n\n  while (cur != end) {  // while something is unexamined\n    // Moves cur to the next percent sign.\n    const char* start = cur;\n    while (cur != end && *cur != '%') ++cur;\n\n    // If the new pending text is all ordinary, copy it out.\n    if (cur != start && pending == start) {\n      result.append(pending, static_cast<std::size_t>(cur - pending));\n      pending = start = cur;\n    }\n\n    // Span the sequential percent signs.\n    const char* percent = cur;\n    while (cur != end && *cur == '%') ++cur;\n\n    // If the new pending text is all percents, copy out one\n    // percent for every matched pair, then skip those pairs.\n    if (cur != start && pending == start) {\n      std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;\n      result.append(pending, escaped);\n      pending += escaped * 2;\n      // Also copy out a single trailing percent.\n      if (pending != cur && cur == end) {\n        result.push_back(*pending++);\n      }\n    }\n\n    // Loop unless we have an unescaped percent.\n    if (cur == end || (cur - percent) % 2 == 0) continue;\n\n    // Simple specifiers that we handle ourselves.\n    if (strchr(\"YmdeUuWwHMSzZs%\", *cur)) {\n      if (cur - 1 != pending) {\n        FormatTM(&result, std::string(pending, cur - 1), tm);\n      }\n      switch (*cur) {\n        case 'Y':\n          // This avoids the tm.tm_year overflow problem for %Y, however\n          // tm.tm_year will still be used by other specifiers like %D.\n          bp = Format64(ep, 0, al.cs.year());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'm':\n          bp = Format02d(ep, al.cs.month());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'd':\n        case 'e':\n          bp = Format02d(ep, al.cs.day());\n          if (*cur == 'e' && *bp == '0') *bp = ' ';  // for Windows\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'U':\n          bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'u':\n          bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'W':\n          bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'w':\n          bp = Format64(ep, 0, tm.tm_wday);\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'H':\n          bp = Format02d(ep, al.cs.hour());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'M':\n          bp = Format02d(ep, al.cs.minute());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'S':\n          bp = Format02d(ep, al.cs.second());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'z':\n          bp = FormatOffset(ep, al.offset, \"\");\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case 'Z':\n          result.append(al.abbr);\n          break;\n        case 's':\n          bp = Format64(ep, 0, ToUnixSeconds(tp));\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          break;\n        case '%':\n          result.push_back('%');\n          break;\n      }\n      pending = ++cur;\n      continue;\n    }\n\n    // More complex specifiers that we handle ourselves.\n    if (*cur == ':' && cur + 1 != end) {\n      if (*(cur + 1) == 'z') {\n        // Formats %:z.\n        if (cur - 1 != pending) {\n          FormatTM(&result, std::string(pending, cur - 1), tm);\n        }\n        bp = FormatOffset(ep, al.offset, \":\");\n        result.append(bp, static_cast<std::size_t>(ep - bp));\n        pending = cur += 2;\n        continue;\n      }\n      if (*(cur + 1) == ':' && cur + 2 != end) {\n        if (*(cur + 2) == 'z') {\n          // Formats %::z.\n          if (cur - 1 != pending) {\n            FormatTM(&result, std::string(pending, cur - 1), tm);\n          }\n          bp = FormatOffset(ep, al.offset, \":*\");\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          pending = cur += 3;\n          continue;\n        }\n        if (*(cur + 2) == ':' && cur + 3 != end) {\n          if (*(cur + 3) == 'z') {\n            // Formats %:::z.\n            if (cur - 1 != pending) {\n              FormatTM(&result, std::string(pending, cur - 1), tm);\n            }\n            bp = FormatOffset(ep, al.offset, \":*:\");\n            result.append(bp, static_cast<std::size_t>(ep - bp));\n            pending = cur += 4;\n            continue;\n          }\n        }\n      }\n    }\n\n    // Loop if there is no E modifier.\n    if (*cur != 'E' || ++cur == end) continue;\n\n    // Format our extensions.\n    if (*cur == 'T') {\n      // Formats %ET.\n      if (cur - 2 != pending) {\n        FormatTM(&result, std::string(pending, cur - 2), tm);\n      }\n      result.append(\"T\");\n      pending = ++cur;\n    } else if (*cur == 'z') {\n      // Formats %Ez.\n      if (cur - 2 != pending) {\n        FormatTM(&result, std::string(pending, cur - 2), tm);\n      }\n      bp = FormatOffset(ep, al.offset, \":\");\n      result.append(bp, static_cast<std::size_t>(ep - bp));\n      pending = ++cur;\n    } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {\n      // Formats %E*z.\n      if (cur - 2 != pending) {\n        FormatTM(&result, std::string(pending, cur - 2), tm);\n      }\n      bp = FormatOffset(ep, al.offset, \":*\");\n      result.append(bp, static_cast<std::size_t>(ep - bp));\n      pending = cur += 2;\n    } else if (*cur == '*' && cur + 1 != end &&\n               (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {\n      // Formats %E*S or %E*F.\n      if (cur - 2 != pending) {\n        FormatTM(&result, std::string(pending, cur - 2), tm);\n      }\n      char* cp = ep;\n      bp = Format64(cp, 15, fs.count());\n      while (cp != bp && cp[-1] == '0') --cp;\n      switch (*(cur + 1)) {\n        case 'S':\n          if (cp != bp) *--bp = '.';\n          bp = Format02d(bp, al.cs.second());\n          break;\n        case 'f':\n          if (cp == bp) *--bp = '0';\n          break;\n      }\n      result.append(bp, static_cast<std::size_t>(cp - bp));\n      pending = cur += 2;\n    } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {\n      // Formats %E4Y.\n      if (cur - 2 != pending) {\n        FormatTM(&result, std::string(pending, cur - 2), tm);\n      }\n      bp = Format64(ep, 4, al.cs.year());\n      result.append(bp, static_cast<std::size_t>(ep - bp));\n      pending = cur += 2;\n    } else if (std::isdigit(*cur)) {\n      // Possibly found %E#S or %E#f.\n      int n = 0;\n      if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {\n        if (*np == 'S' || *np == 'f') {\n          // Formats %E#S or %E#f.\n          if (cur - 2 != pending) {\n            FormatTM(&result, std::string(pending, cur - 2), tm);\n          }\n          bp = ep;\n          if (n > 0) {\n            if (n > kDigits10_64) n = kDigits10_64;\n            bp = Format64(bp, n,\n                          (n > 15) ? fs.count() * kExp10[n - 15]\n                                   : fs.count() / kExp10[15 - n]);\n            if (*np == 'S') *--bp = '.';\n          }\n          if (*np == 'S') bp = Format02d(bp, al.cs.second());\n          result.append(bp, static_cast<std::size_t>(ep - bp));\n          pending = cur = ++np;\n        }\n      }\n    }\n  }\n\n  // Formats any remaining data.\n  if (end != pending) {\n    FormatTM(&result, std::string(pending, end), tm);\n  }\n\n  return result;\n}",
  "id": "BLOCK-CPP-03214",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_format.cc",
  "source_line": 333,
  "validation_status": "validated"
}