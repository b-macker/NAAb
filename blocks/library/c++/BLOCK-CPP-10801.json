{
  "code": "{\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  enum SubExpr { Callee, LHS, RHS, Count };\n\n  SourceLocation LParenLoc;\n  SourceLocation EllipsisLoc;\n  SourceLocation RParenLoc;\n  // When 0, the number of expansions is not known. Otherwise, this is one more\n  // than the number of expansions.\n  unsigned NumExpansions;\n  Stmt *SubExprs[SubExpr::Count];\n  BinaryOperatorKind Opcode;\n\npublic:\n  CXXFoldExpr(QualType T, UnresolvedLookupExpr *Callee,\n              SourceLocation LParenLoc, Expr *LHS, BinaryOperatorKind Opcode,\n              SourceLocation EllipsisLoc, Expr *RHS, SourceLocation RParenLoc,\n              std::optional<unsigned> NumExpansions)\n      : Expr(CXXFoldExprClass, T, VK_PRValue, OK_Ordinary),\n        LParenLoc(LParenLoc), EllipsisLoc(EllipsisLoc), RParenLoc(RParenLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0), Opcode(Opcode) {\n    SubExprs[SubExpr::Callee] = Callee;\n    SubExprs[SubExpr::LHS] = LHS;\n    SubExprs[SubExpr::RHS] = RHS;\n    setDependence(computeDependence(this));\n  }\n\n  CXXFoldExpr(EmptyShell Empty) : Expr(CXXFoldExprClass, Empty) {}\n\n  UnresolvedLookupExpr *getCallee() const {\n    return static_cast<UnresolvedLookupExpr *>(SubExprs[SubExpr::Callee]);\n  }\n  Expr *getLHS() const { return static_cast<Expr*>(SubExprs[SubExpr::LHS]); }\n  Expr *getRHS() const { return static_cast<Expr*>(SubExprs[SubExpr::RHS]); }\n\n  /// Does this produce a right-associated sequence of operators?\n  bool isRightFold() const {\n    return getLHS() && getLHS()->containsUnexpandedParameterPack();\n  }\n\n  /// Does this produce a left-associated sequence of operators?\n  bool isLeftFold() const { return !isRightFold(); }\n\n  /// Get the pattern, that is, the operand that contains an unexpanded pack.\n  Expr *getPattern() const { return isLeftFold() ? getRHS() : getLHS(); }\n\n  /// Get the operand that doesn't contain a pack, for a binary fold.\n  Expr *getInit() const { return isLeftFold() ? getLHS() : getRHS(); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  BinaryOperatorKind getOperator() const { return Opcode; }\n\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (LParenLoc.isValid())\n      return LParenLoc;\n    if (isLeftFold())\n      return getEllipsisLoc();\n    return getLHS()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (RParenLoc.isValid())\n      return RParenLoc;\n    if (isRightFold())\n      return getEllipsisLoc();\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFoldExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n}",
  "id": "BLOCK-CPP-10801",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 4684,
  "validation_status": "validated"
}