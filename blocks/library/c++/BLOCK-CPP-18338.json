{
  "code": "#include \"clang/Frontend/FrontendAction.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18338_execute() {\n    {\n\n//===----------------------------------------------------------------------===//\n// Custom Consumer Actions\n//===----------------------------------------------------------------------===//\n\nclass InitOnlyAction : public FrontendAction {\n  void ExecuteAction() override;\n\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  // Don't claim to only use the preprocessor, we want to follow the AST path,\n  // but do nothing.\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\n/// Preprocessor-based frontend action that also loads PCH files.\nclass ReadPCHAndPreprocessAction : public FrontendAction {\n  void ExecuteAction() override;\n\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\nclass DumpCompilerOptionsAction : public FrontendAction {\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override {\n    return nullptr;\n  }\n\n  void ExecuteAction() override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n//===----------------------------------------------------------------------===//\n// AST Consumer Actions\n//===----------------------------------------------------------------------===//\n\nclass ASTPrintAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n};\n\nclass ASTDumpAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n};\n\nclass ASTDeclListAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n};\n\nclass ASTViewAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n};\n\nclass GeneratePCHAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  TranslationUnitKind getTranslationUnitKind() override {\n    return TU_Prefix;\n  }\n\n  bool hasASTFileSupport() const override { return false; }\n\n  bool shouldEraseOutputFiles() override;\n\npublic:\n  /// Compute the AST consumer arguments that will be used to\n  /// create the PCHGenerator instance returned by CreateASTConsumer.\n  ///\n  /// \\returns false if an error occurred, true otherwise.\n  static bool ComputeASTConsumerArguments(CompilerInstance &CI,\n                                          std::string &Sysroot);\n\n  /// Creates file to write the PCH into and returns a stream to write it\n  /// into. On error, returns null.\n  static std::unique_ptr<llvm::raw_pwrite_stream>\n  CreateOutputFile(CompilerInstance &CI, StringRef InFile,\n                   std::string &OutputFile);\n\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n};\n\nclass GenerateModuleAction : public ASTFrontendAction {\n  virtual std::unique_ptr<raw_pwrite_stream>\n  CreateOutputFile(CompilerInstance &CI, StringRef InFile) = 0;\n\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  TranslationUnitKind getTranslationUnitKind() override {\n    return TU_Module;\n  }\n\n  bool hasASTFileSupport() const override { return false; }\n\n  bool shouldEraseOutputFiles() override;\n};\n\nclass GenerateInterfaceStubsAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  TranslationUnitKind getTranslationUnitKind() override { return TU_Module; }\n  bool hasASTFileSupport() const override { return false; }\n};\n\nclass GenerateModuleFromModuleMapAction : public GenerateModuleAction {\nprivate:\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n\n  std::unique_ptr<raw_pwrite_stream>\n  CreateOutputFile(CompilerInstance &CI, StringRef InFile) override;\n};\n\nclass GenerateModuleInterfaceAction : public GenerateModuleAction {\nprivate:\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n\n  std::unique_ptr<raw_pwrite_stream>\n  CreateOutputFile(CompilerInstance &CI, StringRef InFile) override;\n};\n\nclass GenerateHeaderUnitAction : public GenerateModuleAction {\n\nprivate:\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n\n  std::unique_ptr<raw_pwrite_stream>\n  CreateOutputFile(CompilerInstance &CI, StringRef InFile) override;\n};\n\nclass SyntaxOnlyAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  ~SyntaxOnlyAction() override;\n  bool hasCodeCompletionSupport() const override { return true; }\n};\n\n/// Dump information about the given module file, to be used for\n/// basic debugging and discovery.\nclass DumpModuleInfoAction : public ASTFrontendAction {\n  // Allow other tools (ex lldb) to direct output for their use.\n  std::shared_ptr<llvm::raw_ostream> OutputStream;\n\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n  bool BeginInvocation(CompilerInstance &CI) override;\n  void ExecuteAction() override;\n\npublic:\n  DumpModuleInfoAction() = default;\n  explicit DumpModuleInfoAction(std::shared_ptr<llvm::raw_ostream> Out)\n      : OutputStream(Out) {}\n  bool hasPCHSupport() const override { return false; }\n  bool hasASTFileSupport() const override { return true; }\n  bool hasIRSupport() const override { return false; }\n  bool hasCodeCompletionSupport() const override { return false; }\n};\n\nclass VerifyPCHAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  void ExecuteAction() override;\n\npublic:\n  bool hasCodeCompletionSupport() const override { return false; }\n};\n\nclass TemplightDumpAction : public ASTFrontendAction {\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  void ExecuteAction() override;\n};\n\n/**\n * Frontend action adaptor that merges ASTs together.\n *\n * This action takes an existing AST file and \"merges\" it into the AST\n * context, producing a merged context. This action is an action\n * adaptor, which forwards most of its calls to another action that\n * will consume the merged context.\n */\nclass ASTMergeAction : public FrontendAction {\n  /// The action that the merge action adapts.\n  std::unique_ptr<FrontendAction> AdaptedAction;\n\n  /// The set of AST files to merge.\n  std::vector<std::string> ASTFiles;\n\nprotected:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n\n  void ExecuteAction() override;\n  void EndSourceFileAction() override;\n\npublic:\n  ASTMergeAction(std::unique_ptr<FrontendAction> AdaptedAction,\n                 ArrayRef<std::string> ASTFiles);\n  ~ASTMergeAction() override;\n\n  bool usesPreprocessorOnly() const override;\n  TranslationUnitKind getTranslationUnitKind() override;\n  bool hasPCHSupport() const override;\n  bool hasASTFileSupport() const override;\n  bool hasCodeCompletionSupport() const override;\n};\n\nclass PrintPreambleAction : public FrontendAction {\nprotected:\n  void ExecuteAction() override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &,\n                                                 StringRef) override {\n    return nullptr;\n  }\n\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\nclass PrintDependencyDirectivesSourceMinimizerAction : public FrontendAction {\nprotected:\n  void ExecuteAction() override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &,\n                                                 StringRef) override {\n    return nullptr;\n  }\n\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n//===----------------------------------------------------------------------===//\n// Preprocessor Actions\n//===----------------------------------------------------------------------===//\n\nclass DumpRawTokensAction : public PreprocessorFrontendAction {\nprotected:\n  void ExecuteAction() override;\n};\n\nclass DumpTokensAction : public PreprocessorFrontendAction {\nprotected:\n  void ExecuteAction() override;\n};\n\nclass PreprocessOnlyAction : public PreprocessorFrontendAction {\nprotected:\n  void ExecuteAction() override;\n};\n\nclass PrintPreprocessedAction : public PreprocessorFrontendAction {\nprotected:\n  void ExecuteAction() override;\n\n  bool hasPCHSupport() const override { return true; }\n};\n\nclass GetDependenciesByModuleNameAction : public PreprocessOnlyAction {\n  StringRef ModuleName;\n  void ExecuteAction() override;\n\npublic:\n  GetDependenciesByModuleNameAction(StringRef ModuleName)\n      : ModuleName(ModuleName) {}\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18338",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/FrontendActions.h",
  "source_line": 17,
  "validation_status": "validated"
}