{
  "code": "{\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final \\#endif is parsed this is reset back\n  /// to false, that way any tokens before the first \\#ifdef or after the last\n  /// \\#endif can be easily detected.\n  bool ReadAnyTokens;\n\n  /// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens\n  /// processed in the file so far is an #ifndef and an identifier.  Used in\n  /// the detection of header guards in a file.\n  bool ImmediatelyAfterTopLevelIfndef;\n\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final #endif is parsed this is reset back\n  /// to false, that way any tokens before the first #ifdef or after the last\n  /// #endif can be easily detected.\n  bool DidMacroExpansion;\n\n  /// TheMacro - The controlling macro for a file, if valid.\n  ///\n  const IdentifierInfo *TheMacro;\n\n  /// DefinedMacro - The macro defined right after TheMacro, if any.\n  const IdentifierInfo *DefinedMacro;\n\n  SourceLocation MacroLoc;\n  SourceLocation DefinedLoc;\npublic:\n  MultipleIncludeOpt() {\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DidMacroExpansion = false;\n    TheMacro = nullptr;\n    DefinedMacro = nullptr;\n  }\n\n  SourceLocation GetMacroLocation() const {\n    return MacroLoc;\n  }\n\n  SourceLocation GetDefinedLocation() const {\n    return DefinedLoc;\n  }\n\n  void resetImmediatelyAfterTopLevelIfndef() {\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  void SetDefinedMacro(IdentifierInfo *M, SourceLocation Loc) {\n    DefinedMacro = M;\n    DefinedLoc = Loc;\n  }\n\n  /// Invalidate - Permanently mark this file as not being suitable for the\n  /// include-file optimization.\n  void Invalidate() {\n    // If we have read tokens but have no controlling macro, the state-machine\n    // below can never \"accept\".\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DefinedMacro = nullptr;\n    TheMacro = nullptr;\n  }\n\n  /// getHasReadAnyTokensVal - This is used for the \\#ifndef handshake at the\n  /// top of the file when reading preprocessor directives.  Otherwise, reading\n  /// the \"ifndef x\" would count as reading tokens.\n  bool getHasReadAnyTokensVal() const { return ReadAnyTokens; }\n\n  /// getImmediatelyAfterTopLevelIfndef - returns true if the last directive\n  /// was an #ifndef at the beginning of the file.\n  bool getImmediatelyAfterTopLevelIfndef() const {\n    return ImmediatelyAfterTopLevelIfndef;\n  }\n\n  // If a token is read, remember that we have seen a side-effect in this file.\n  void ReadToken() {\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// SetReadToken - Set whether the value of 'ReadAnyTokens'.  Called to\n  /// override when encountering tokens outside of the include guard that have\n  /// no effect if the file in question is is included multiple times (e.g. the\n  /// null directive).\n  void SetReadToken(bool Value) { ReadAnyTokens = Value; }\n\n  /// ExpandedMacro - When a macro is expanded with this lexer as the current\n  /// buffer, this method is called to disable the MIOpt if needed.\n  void ExpandedMacro() { DidMacroExpansion = true; }\n\n  /// Called when entering a top-level \\#ifndef directive (or the\n  /// \"\\#if !defined\" equivalent) without any preceding tokens.\n  ///\n  /// Note, we don't care about the input value of 'ReadAnyTokens'.  The caller\n  /// ensures that this is only called if there are no tokens read before the\n  /// \\#ifndef.  The caller is required to do this, because reading the \\#if\n  /// line obviously reads in tokens.\n  void EnterTopLevelIfndef(const IdentifierInfo *M, SourceLocation Loc) {\n    // If the macro is already set, this is after the top-level #endif.\n    if (TheMacro)\n      return Invalidate();\n\n    // If we have already expanded a macro by the end of the #ifndef line, then\n    // there is a macro expansion *in* the #ifndef line.  This means that the\n    // condition could evaluate differently when subsequently #included.  Reject\n    // this.\n    if (DidMacroExpansion)\n      return Invalidate();\n\n    // Remember that we're in the #if and that we have the macro.\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = true;\n    TheMacro = M;\n    MacroLoc = Loc;\n  }\n\n  /// Invoked when a top level conditional (except \\#ifndef) is found.\n  void EnterTopLevelConditional() {\n    // If a conditional directive (except #ifndef) is found at the top level,\n    // there is a chunk of the file not guarded by the controlling macro.\n    Invalidate();\n  }\n\n  /// Called when the lexer exits the top-level conditional.\n  void ExitTopLevelConditional() {\n    // If we have a macro, that means the top of the file was ok.  Set our state\n    // back to \"not having read any tokens\" so we can detect anything after the\n    // #endif.\n    if (!TheMacro) return Invalidate();\n\n    // At this point, we haven't \"read any tokens\" but we do have a controlling\n    // macro.\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// Once the entire file has been lexed, if there is a controlling\n  /// macro, return it.\n  const IdentifierInfo *GetControllingMacroAtEndOfFile() const {\n    // If we haven't read any tokens after the #endif, return the controlling\n    // macro if it's valid (if it isn't, it will be null).\n    if (!ReadAnyTokens)\n      return TheMacro;\n    return nullptr;\n  }\n\n  /// If the ControllingMacro is followed by a macro definition, return\n  /// the macro that was defined.\n  const IdentifierInfo *GetDefinedMacro() const {\n    return DefinedMacro;\n  }\n}",
  "id": "BLOCK-CPP-18820",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/MultipleIncludeOpt.h",
  "source_line": 28,
  "validation_status": "validated"
}