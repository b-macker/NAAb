{
  "code": "#include <atomic>\n#include <cstdint>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/cycleclock_config.h\"\n#include \"absl/base/internal/unscaledcycleclock.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04568_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\nusing CycleClockSourceFunc = int64_t (*)();\n\n// -----------------------------------------------------------------------------\n// CycleClock\n// -----------------------------------------------------------------------------\nclass CycleClock {\n public:\n  // CycleClock::Now()\n  //\n  // Returns the value of a cycle counter that counts at a rate that is\n  // approximately constant.\n  static int64_t Now();\n\n  // CycleClock::Frequency()\n  //\n  // Returns the amount by which `CycleClock::Now()` increases per second. Note\n  // that this value may not necessarily match the core CPU clock frequency.\n  static double Frequency();\n\n private:\n#if ABSL_USE_UNSCALED_CYCLECLOCK\n  static CycleClockSourceFunc LoadCycleClockSource();\n\n  static constexpr int32_t kShift = kCycleClockShift;\n  static constexpr double kFrequencyScale = kCycleClockFrequencyScale;\n\n  ABSL_CONST_INIT static std::atomic<CycleClockSourceFunc> cycle_clock_source_;\n#endif  //  ABSL_USE_UNSCALED_CYCLECLOC\n\n  CycleClock() = delete;  // no instances\n  CycleClock(const CycleClock&) = delete;\n  CycleClock& operator=(const CycleClock&) = delete;\n\n  friend class CycleClockSource;\n};\n\nclass CycleClockSource {\n private:\n  // CycleClockSource::Register()\n  //\n  // Register a function that provides an alternate source for the unscaled CPU\n  // cycle count value. The source function must be async signal safe, must not\n  // call CycleClock::Now(), and must have a frequency that matches that of the\n  // unscaled clock used by CycleClock. A nullptr value resets CycleClock to use\n  // the default source.\n  static void Register(CycleClockSourceFunc source);\n};\n\n#if ABSL_USE_UNSCALED_CYCLECLOCK\n\ninline CycleClockSourceFunc CycleClock::LoadCycleClockSource() {\n#if !defined(__x86_64__)\n  // Optimize for the common case (no callback) by first doing a relaxed load;\n  // this is significantly faster on non-x86 platforms.\n  if (cycle_clock_source_.load(std::memory_order_relaxed) == nullptr) {\n    return nullptr;\n  }\n#endif  // !defined(__x86_64__)\n\n  // This corresponds to the store(std::memory_order_release) in\n  // CycleClockSource::Register, and makes sure that any updates made prior to\n  // registering the callback are visible to this thread before the callback\n  // is invoked.\n  return cycle_clock_source_.load(std::memory_order_acquire);\n}\n\n// Accessing globals in inlined code in Window DLLs is problematic.\n#ifndef _WIN32\ninline int64_t CycleClock::Now() {\n  auto fn = LoadCycleClockSource();\n  if (fn == nullptr) {\n    return base_internal::UnscaledCycleClock::Now() >> kShift;\n  }\n  return fn() >> kShift;\n}\n#endif\n\ninline double CycleClock::Frequency() {\n  return kFrequencyScale * base_internal::UnscaledCycleClock::Frequency();\n}\n\n#endif  // ABSL_USE_UNSCALED_CYCLECLOCK\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04568",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/cycleclock.h",
  "source_line": 53,
  "validation_status": "validated"
}