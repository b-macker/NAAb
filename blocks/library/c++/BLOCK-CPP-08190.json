{
  "code": "{\n  ///   Integer(long); // construct from a long\n  ///   Integer(double) = delete; // no construction from float or double\n  ///   Integer(long double) = delete; // no construction from long double\n  /// };\n  /// @endcode\n  // If a function is deleted, its first declaration must be.\n  bool isDeleted() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsDeleted;\n  }\n\n  bool isDeletedAsWritten() const {\n    return FunctionDeclBits.IsDeleted && !isDefaulted();\n  }\n\n  void setDeletedAsWritten(bool D = true) { FunctionDeclBits.IsDeleted = D; }\n\n  /// Determines whether this function is \"main\", which is the\n  /// entry point into an executable program.\n  bool isMain() const;\n\n  /// Determines whether this function is a MSVCRT user defined entry\n  /// point.\n  bool isMSVCRTEntryPoint() const;\n\n  /// Determines whether this operator new or delete is one\n  /// of the reserved global placement operators:\n  ///    void *operator new(size_t, void *);\n  ///    void *operator new[](size_t, void *);\n  ///    void operator delete(void *, void *);\n  ///    void operator delete[](void *, void *);\n  /// These functions have special behavior under [new.delete.placement]:\n  ///    These functions are reserved, a C++ program may not define\n  ///    functions that displace the versions in the Standard C++ library.\n  ///    The provisions of [basic.stc.dynamic] do not apply to these\n  ///    reserved placement forms of operator new and operator delete.\n  ///\n  /// This function must be an allocation or deallocation function.\n  bool isReservedGlobalPlacementOperator() const;\n\n  /// Determines whether this function is one of the replaceable\n  /// global allocation functions:\n  ///    void *operator new(size_t);\n  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;\n  ///    void *operator new[](size_t);\n  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;\n  ///    void operator delete(void *) noexcept;\n  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]\n  ///    void operator delete(void *, const std::nothrow_t &) noexcept;\n  ///    void operator delete[](void *) noexcept;\n  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]\n  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;\n  /// These functions have special behavior under C++1y [expr.new]:\n  ///    An implementation is allowed to omit a call to a replaceable global\n  ///    allocation function. [...]\n  ///\n  /// If this function is an aligned allocation/deallocation function, return\n  /// the parameter number of the requested alignment through AlignmentParam.\n  ///\n  /// If this function is an allocation/deallocation function that takes\n  /// the `std::nothrow_t` tag, return true through IsNothrow,\n  bool isReplaceableGlobalAllocationFunction(\n      std::optional<unsigned> *AlignmentParam = nullptr,\n      bool *IsNothrow = nullptr) const;\n\n  /// Determine if this function provides an inline implementation of a builtin.\n  bool isInlineBuiltinDeclaration() const;\n\n  /// Determine whether this is a destroying operator delete.\n  bool isDestroyingOperatorDelete() const;\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this function is a function with\n  /// external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Determines whether this is a global function.\n  bool isGlobal() const;\n\n  /// Determines whether this function is known to be 'noreturn', through\n  /// an attribute on its declaration or its type.\n  bool isNoReturn() const;\n\n  /// True if the function was a definition but its body was skipped.\n  bool hasSkippedBody() const { return FunctionDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    FunctionDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if this function will eventually have a body, once it's fully parsed.\n  bool willHaveBody() const { return FunctionDeclBits.WillHaveBody; }\n  void setWillHaveBody(bool V = true) { FunctionDeclBits.WillHaveBody = V; }\n\n  /// True if this function is considered a multiversioned function.\n  bool isMultiVersion() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsMultiVersion;\n  }\n\n  /// Sets the multiversion state for this declaration and all of its\n  /// redeclarations.\n  void setIsMultiVersion(bool V = true) {\n    getCanonicalDecl()->FunctionDeclBits.IsMultiVersion = V;\n  }\n\n  // Sets that this is a constrained friend where the constraint refers to an\n  // enclosing template.\n  void setFriendConstraintRefersToEnclosingTemplate(bool V = true) {\n    getCanonicalDecl()\n        ->FunctionDeclBits.FriendConstraintRefersToEnclosingTemplate = V;\n  }\n  // Indicates this function is a constrained friend, where the constraint\n  // refers to an enclosing template for hte purposes of [temp.friend]p9.\n  bool FriendConstraintRefersToEnclosingTemplate() const {\n    return getCanonicalDecl()\n        ->FunctionDeclBits.FriendConstraintRefersToEnclosingTemplate;\n  }\n\n  /// Determine whether a function is a friend function that cannot be\n  /// redeclared outside of its class, per C++ [temp.friend]p9.\n  bool isMemberLikeConstrainedFriend() const;\n\n  /// Gets the kind of multiversioning attribute this declaration has. Note that\n  /// this can return a value even if the function is not multiversion, such as\n  /// the case of 'target'.\n  MultiVersionKind getMultiVersionKind() const;\n\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the cpu_specific/cpu_dispatch functionality.\n  bool isCPUDispatchMultiVersion() const;\n  /// True if this function is a multiversioned processor specific function as a\n  /// part of the cpu_specific/cpu_dispatch functionality.\n  bool isCPUSpecificMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target functionality.\n  bool isTargetMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target-clones functionality.\n  bool isTargetClonesMultiVersion() const;\n\n  /// \\brief Get the associated-constraints of this function declaration.\n  /// Currently, this will either be a vector of size 1 containing the\n  /// trailing-requires-clause or an empty vector.\n  ///\n  /// Use this instead of getTrailingRequiresClause for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(SmallVectorImpl<const Expr *> &AC) const {\n    if (auto *TRC = getTrailingRequiresClause())\n      AC.push_back(TRC);\n  }\n\n  void setPreviousDeclaration(FunctionDecl * PrevDecl);\n\n  FunctionDecl *getCanonicalDecl() override;\n  const FunctionDecl *getCanonicalDecl() const {\n    return const_cast<FunctionDecl*>(this)->getCanonicalDecl();\n  }\n\n  unsigned getBuiltinID(bool ConsiderWrapperFunctions = false) const;\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  /// Return the number of parameters this function must have based on its\n  /// FunctionType.  This is the length of the ParamInfo array after it has been\n  /// created.\n  unsigned getNumParams() const;\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo) {\n    setParams(getASTContext(), NewParamInfo);\n  }\n\n  /// Returns the minimum number of arguments needed to call this function. This\n  /// may be fewer than the number of function parameters, if some of the\n  /// parameters have default arguments (in C++).\n  unsigned getMinRequiredArguments() const;\n\n  /// Determine whether this function has a single parameter, or multiple\n  /// parameters where all but the first have default arguments.\n  ///\n  /// This notion is used in the definition of copy/move constructors and\n  /// initializer list constructors. Note that, unlike getMinRequiredArguments,\n  /// parameter packs are not treated specially here.\n  bool hasOneParamOrDefaultArgs() const;\n\n  /// Find the source location information for how the type of this function\n  /// was written. May be absent (for example if the function was declared via\n  /// a typedef) and may contain a different type from that of the function\n  /// (for example if the function type was adjusted by an attribute).\n  FunctionTypeLoc getFunctionTypeLoc() const;\n\n  QualType getReturnType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function return type. This may omit qualifiers and other information with\n  /// limited representation in the AST.\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Attempt to compute an informative source range covering the\n  /// function parameters, including the ellipsis of a variadic function.\n  /// The source range excludes the parentheses, and is invalid if there are\n  /// no parameters and no ellipsis.\n  SourceRange getParametersSourceRange() const;\n\n  /// Get the declared return type, which may differ from the actual return\n  /// type if the return type is deduced.\n  QualType getDeclaredReturnType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    return T->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Gets the ExceptionSpecificationType as declared.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    const auto *FPT = T->getAs<FunctionProtoType>();\n    return FPT ? FPT->getExceptionSpecType() : EST_None;\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function exception specification, if any.\n  SourceRange getExceptionSpecSourceRange() const;\n\n  /// Determine the type of an expression that calls this function.\n  QualType getCallResultType() const {\n    return getType()->castAs<FunctionType>()->getCallResultType(\n        getASTContext());\n  }\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return static_cast<StorageClass>(FunctionDeclBits.SClass);\n  }\n\n  /// Sets the storage class as written in the source.\n  void setStorageClass(StorageClass SClass) {\n    FunctionDeclBits.SClass = SClass;\n  }\n\n  /// Determine whether the \"inline\" keyword was specified for this\n  /// function.\n  bool isInlineSpecified() const { return FunctionDeclBits.IsInlineSpecified; }\n\n  /// Set whether the \"inline\" keyword was specified for this function.\n  void setInlineSpecified(bool I) {\n    FunctionDeclBits.IsInlineSpecified = I;\n    FunctionDeclBits.IsInline = I;\n  }\n\n  /// Determine whether the function was declared in source context\n  /// that requires constrained FP intrinsics\n  bool UsesFPIntrin() const { return FunctionDeclBits.UsesFPIntrin; }\n\n  /// Set whether the function was declared in source context\n  /// that requires constrained FP intrinsics\n  void setUsesFPIntrin(bool I) { FunctionDeclBits.UsesFPIntrin = I; }\n\n  /// Flag that this function is implicitly inline.\n  void setImplicitlyInline(bool I = true) { FunctionDeclBits.IsInline = I; }\n\n  /// Determine whether this function should be inlined, because it is\n  /// either marked \"inline\" or \"constexpr\" or is a member function of a class\n  /// that was defined in the class body.\n  bool isInlined() const { return FunctionDeclBits.IsInline; }\n\n  bool isInlineDefinitionExternallyVisible() const;\n\n  bool isMSExternInline() const;\n\n  bool doesDeclarationForceExternallyVisibleDefinition() const;\n\n  bool isStatic() const { return getStorageClass() == SC_Static; }\n\n  /// Whether this function declaration represents an C++ overloaded\n  /// operator, e.g., \"operator+\".\n  bool isOverloadedOperator() const {\n    return getOverloadedOperator() != OO_None;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const;\n\n  const IdentifierInfo *getLiteralIdentifier() const;\n\n  /// If this function is an instantiation of a member function\n  /// of a class template specialization, retrieves the function from\n  /// which it was instantiated.\n  ///\n  /// This routine will return non-NULL for (non-templated) member\n  /// functions of class templates and for instantiations of function\n  /// templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   void f(T);\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::f is a (non-templated) FunctionDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromFunction() will return\n  /// the FunctionDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberFunction().\n  FunctionDecl *getInstantiatedFromMemberFunction() const;\n\n  /// What kind of templated function this is.\n  TemplatedKind getTemplatedKind() const;\n\n  /// If this function is an instantiation of a member function of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberFunction(getASTContext(), FD, TSK);\n  }\n\n  /// Specify that this function declaration was instantiated from a\n  /// FunctionDecl FD. This is only used if this is a function declaration\n  /// declared locally inside of a function template.\n  void setInstantiatedFromDecl(FunctionDecl *FD);\n\n  FunctionDecl *getInstantiatedFromDecl() const;\n\n  /// Retrieves the function template that is described by this\n  /// function declaration.\n  ///\n  /// Every function template is represented as a FunctionTemplateDecl\n  /// and a FunctionDecl (or something derived from FunctionDecl). The\n  /// former contains template properties (such as the template\n  /// parameter lists) while the latter contains the actual\n  /// description of the template's\n  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the\n  /// FunctionDecl that describes the function template,\n  /// getDescribedFunctionTemplate() retrieves the\n  /// FunctionTemplateDecl from a FunctionDecl.\n  FunctionTemplateDecl *getDescribedFunctionTemplate() const;\n\n  void setDescribedFunctionTemplate(FunctionTemplateDecl *Template);\n\n  /// Determine whether this function is a function template\n  /// specialization.\n  bool isFunctionTemplateSpecialization() const {\n    return getPrimaryTemplate() != nullptr;\n  }\n\n  /// If this function is actually a function template specialization,\n  /// retrieve information about this function template specialization.\n  /// Otherwise, returns NULL.\n  FunctionTemplateSpecializationInfo *getTemplateSpecializationInfo() const;\n\n  /// Determines whether this function is a function template\n  /// specialization or a member of a class template specialization that can\n  /// be implicitly instantiated.\n  bool isImplicitlyInstantiable() const;\n\n  /// Determines if the given function was instantiated from a\n  /// function template.\n  bool isTemplateInstantiation() const;\n\n  /// Retrieve the function declaration from which this function could\n  /// be instantiated, if it is an instantiation (rather than a non-template\n  /// or a specialization, for example).\n  ///\n  /// If \\p ForDefinition is \\c false, explicit specializations will be treated\n  /// as if they were implicit instantiations. This will then find the pattern\n  /// corresponding to non-definition portions of the declaration, such as\n  /// default arguments and the exception specification.\n  FunctionDecl *\n  getTemplateInstantiationPattern(bool ForDefinition = true) const;\n\n  /// Retrieve the primary template that this function template\n  /// specialization either specializes or was instantiated from.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  FunctionTemplateDecl *getPrimaryTemplate() const;\n\n  /// Retrieve the template arguments used to produce this function\n  /// template specialization from the primary template.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  const TemplateArgumentList *getTemplateSpecializationArgs() const;\n\n  /// Retrieve the template argument list as written in the sources,\n  /// if any.\n  ///\n  /// If this function declaration is not a function template specialization\n  /// or if it had no explicit template argument list, returns NULL.\n  /// Note that it an explicit template argument list may be written empty,\n  /// e.g., template<> void foo<>(char* s);\n  const ASTTemplateArgumentListInfo*\n  getTemplateSpecializationArgsAsWritten() const;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(FunctionTemplateDecl *Template,\n                const TemplateArgumentList *TemplateArgs,\n                void *InsertPos,\n                TemplateSpecializationKind TSK = TSK_ImplicitInstantiation,\n                const TemplateArgumentListInfo *TemplateArgsAsWritten = nullptr,\n                SourceLocation PointOfInstantiation = SourceLocation()) {\n    setFunctionTemplateSpecialization(getASTContext(), Template, TemplateArgs,\n                                      InsertPos, TSK, TemplateArgsAsWritten,\n                                      PointOfInstantiation);\n  }\n\n  /// Specifies that this function declaration is actually a\n  /// dependent function template specialization.\n  void setDependentTemplateSpecialization(ASTContext &Context,\n                             const UnresolvedSetImpl &Templates,\n                      const TemplateArgumentListInfo &TemplateArgs);\n\n  DependentFunctionTemplateSpecializationInfo *\n  getDependentSpecializationInfo() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Determine the kind of template specialization this function represents\n  /// for the purpose of template instantiation.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Retrieve the (first) point of instantiation of a function template\n  /// specialization or a member of a class template specialization.\n  ///\n  /// \\returns the first point of instantiation, if this function was\n  /// instantiated from a template; otherwise, returns an invalid source\n  /// location.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a member function.\n  bool isOutOfLine() const override;\n\n  /// Identify a memory copying or setting function.\n  /// If the given function is a memory copy or setting function, returns\n  /// the corresponding Builtin ID. If the function is not a memory function,\n  /// returns 0.\n  unsigned getMemoryFunctionKind() const;\n\n  /// Returns ODRHash of the function.  This value is calculated and\n  /// stored on first call, then the stored value returned on the other calls.\n  unsigned getODRHash();\n\n  /// Returns cached ODRHash of the function.  This must have been previously\n  /// computed and stored.\n  unsigned getODRHash() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstFunction && K <= lastFunction;\n  }\n  static DeclContext *castToDeclContext(const FunctionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<FunctionDecl*>(D));\n  }\n  static FunctionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<FunctionDecl *>(const_cast<DeclContext*>(DC));\n  }\n}",
  "id": "BLOCK-CPP-08190",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Decl.h",
  "source_line": 2428,
  "validation_status": "validated"
}