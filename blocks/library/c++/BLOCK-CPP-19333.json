{
  "code": "{\n  friend class ColonProtectionRAIIObject;\n  friend class ParsingOpenMPDirectiveRAII;\n  friend class InMessageExpressionRAIIObject;\n  friend class OffsetOfStateRAIIObject;\n  friend class PoisonSEHIdentifiersRAIIObject;\n  friend class ObjCDeclContextSwitch;\n  friend class ParenBraceBracketBalancer;\n  friend class BalancedDelimiterTracker;\n\n  Preprocessor &PP;\n\n  /// Tok - The current token we are peeking ahead.  All parsing methods assume\n  /// that this is valid.\n  Token Tok;\n\n  // PrevTokLocation - The location of the token we previously\n  // consumed. This token is used for diagnostics where we expected to\n  // see a token following another token (e.g., the ';' at the end of\n  // a statement).\n  SourceLocation PrevTokLocation;\n\n  /// Tracks an expected type for the current token when parsing an expression.\n  /// Used by code completion for ranking.\n  PreferredTypeBuilder PreferredType;\n\n  unsigned short ParenCount = 0, BracketCount = 0, BraceCount = 0;\n  unsigned short MisplacedModuleBeginCount = 0;\n\n  /// Actions - These are the callbacks we invoke as we parse various constructs\n  /// in the file.\n  Sema &Actions;\n\n  DiagnosticsEngine &Diags;\n\n  /// ScopeCache - Cache scopes to reduce malloc traffic.\n  enum { ScopeCacheSize = 16 };\n  unsigned NumCachedScopes;\n  Scope *ScopeCache[ScopeCacheSize];\n\n  /// Identifiers used for SEH handling in Borland. These are only\n  /// allowed in particular circumstances\n  // __except block\n  IdentifierInfo *Ident__exception_code,\n                 *Ident___exception_code,\n                 *Ident_GetExceptionCode;\n  // __except filter expression\n  IdentifierInfo *Ident__exception_info,\n                 *Ident___exception_info,\n                 *Ident_GetExceptionInfo;\n  // __finally\n  IdentifierInfo *Ident__abnormal_termination,\n                 *Ident___abnormal_termination,\n                 *Ident_AbnormalTermination;\n\n  /// Contextual keywords for Microsoft extensions.\n  IdentifierInfo *Ident__except;\n  mutable IdentifierInfo *Ident_sealed;\n  mutable IdentifierInfo *Ident_abstract;\n\n  /// Ident_super - IdentifierInfo for \"super\", to support fast\n  /// comparison.\n  IdentifierInfo *Ident_super;\n  /// Ident_vector, Ident_bool, Ident_Bool - cached IdentifierInfos for \"vector\"\n  /// and \"bool\" fast comparison.  Only present if AltiVec or ZVector are\n  /// enabled.\n  IdentifierInfo *Ident_vector;\n  IdentifierInfo *Ident_bool;\n  IdentifierInfo *Ident_Bool;\n  /// Ident_pixel - cached IdentifierInfos for \"pixel\" fast comparison.\n  /// Only present if AltiVec enabled.\n  IdentifierInfo *Ident_pixel;\n\n  /// Objective-C contextual keywords.\n  IdentifierInfo *Ident_instancetype;\n\n  /// Identifier for \"introduced\".\n  IdentifierInfo *Ident_introduced;\n\n  /// Identifier for \"deprecated\".\n  IdentifierInfo *Ident_deprecated;\n\n  /// Identifier for \"obsoleted\".\n  IdentifierInfo *Ident_obsoleted;\n\n  /// Identifier for \"unavailable\".\n  IdentifierInfo *Ident_unavailable;\n\n  /// Identifier for \"message\".\n  IdentifierInfo *Ident_message;\n\n  /// Identifier for \"strict\".\n  IdentifierInfo *Ident_strict;\n\n  /// Identifier for \"replacement\".\n  IdentifierInfo *Ident_replacement;\n\n  /// Identifiers used by the 'external_source_symbol' attribute.\n  IdentifierInfo *Ident_language, *Ident_defined_in,\n      *Ident_generated_declaration, *Ident_USR;\n\n  /// C++11 contextual keywords.\n  mutable IdentifierInfo *Ident_final;\n  mutable IdentifierInfo *Ident_GNU_final;\n  mutable IdentifierInfo *Ident_override;\n\n  // C++2a contextual keywords.\n  mutable IdentifierInfo *Ident_import;\n  mutable IdentifierInfo *Ident_module;\n\n  // C++ type trait keywords that can be reverted to identifiers and still be\n  // used as type traits.\n  llvm::SmallDenseMap<IdentifierInfo *, tok::TokenKind> RevertibleTypeTraits;\n\n  std::unique_ptr<PragmaHandler> AlignHandler;\n  std::unique_ptr<PragmaHandler> GCCVisibilityHandler;\n  std::unique_ptr<PragmaHandler> OptionsHandler;\n  std::unique_ptr<PragmaHandler> PackHandler;\n  std::unique_ptr<PragmaHandler> MSStructHandler;\n  std::unique_ptr<PragmaHandler> UnusedHandler;\n  std::unique_ptr<PragmaHandler> WeakHandler;\n  std::unique_ptr<PragmaHandler> RedefineExtnameHandler;\n  std::unique_ptr<PragmaHandler> FPContractHandler;\n  std::unique_ptr<PragmaHandler> OpenCLExtensionHandler;\n  std::unique_ptr<PragmaHandler> OpenMPHandler;\n  std::unique_ptr<PragmaHandler> PCSectionHandler;\n  std::unique_ptr<PragmaHandler> MSCommentHandler;\n  std::unique_ptr<PragmaHandler> MSDetectMismatchHandler;\n  std::unique_ptr<PragmaHandler> FPEvalMethodHandler;\n  std::unique_ptr<PragmaHandler> FloatControlHandler;\n  std::unique_ptr<PragmaHandler> MSPointersToMembers;\n  std::unique_ptr<PragmaHandler> MSVtorDisp;\n  std::unique_ptr<PragmaHandler> MSInitSeg;\n  std::unique_ptr<PragmaHandler> MSDataSeg;\n  std::unique_ptr<PragmaHandler> MSBSSSeg;\n  std::unique_ptr<PragmaHandler> MSConstSeg;\n  std::unique_ptr<PragmaHandler> MSCodeSeg;\n  std::unique_ptr<PragmaHandler> MSSection;\n  std::unique_ptr<PragmaHandler> MSStrictGuardStackCheck;\n  std::unique_ptr<PragmaHandler> MSRuntimeChecks;\n  std::unique_ptr<PragmaHandler> MSIntrinsic;\n  std::unique_ptr<PragmaHandler> MSFunction;\n  std::unique_ptr<PragmaHandler> MSOptimize;\n  std::unique_ptr<PragmaHandler> MSFenvAccess;\n  std::unique_ptr<PragmaHandler> MSAllocText;\n  std::unique_ptr<PragmaHandler> CUDAForceHostDeviceHandler;\n  std::unique_ptr<PragmaHandler> OptimizeHandler;\n  std::unique_ptr<PragmaHandler> LoopHintHandler;\n  std::unique_ptr<PragmaHandler> UnrollHintHandler;\n  std::unique_ptr<PragmaHandler> NoUnrollHintHandler;\n  std::unique_ptr<PragmaHandler> UnrollAndJamHintHandler;\n  std::unique_ptr<PragmaHandler> NoUnrollAndJamHintHandler;\n  std::unique_ptr<PragmaHandler> FPHandler;\n  std::unique_ptr<PragmaHandler> STDCFenvAccessHandler;\n  std::unique_ptr<PragmaHandler> STDCFenvRoundHandler;\n  std::unique_ptr<PragmaHandler> STDCCXLIMITHandler;\n  std::unique_ptr<PragmaHandler> STDCUnknownHandler;\n  std::unique_ptr<PragmaHandler> AttributePragmaHandler;\n  std::unique_ptr<PragmaHandler> MaxTokensHerePragmaHandler;\n  std::unique_ptr<PragmaHandler> MaxTokensTotalPragmaHandler;\n  std::unique_ptr<PragmaHandler> RISCVPragmaHandler;\n\n  std::unique_ptr<CommentHandler> CommentSemaHandler;\n\n  /// Whether the '>' token acts as an operator or not. This will be\n  /// true except when we are parsing an expression within a C++\n  /// template argument list, where the '>' closes the template\n  /// argument list.\n  bool GreaterThanIsOperator;\n\n  /// ColonIsSacred - When this is false, we aggressively try to recover from\n  /// code like \"foo : bar\" as if it were a typo for \"foo :: bar\".  This is not\n  /// safe in case statements and a few other things.  This is managed by the\n  /// ColonProtectionRAIIObject RAII object.\n  bool ColonIsSacred;\n\n  /// Parsing OpenMP directive mode.\n  bool OpenMPDirectiveParsing = false;\n\n  /// When true, we are directly inside an Objective-C message\n  /// send expression.\n  ///\n  /// This is managed by the \\c InMessageExpressionRAIIObject class, and\n  /// should not be set directly.\n  bool InMessageExpression;\n\n  /// Gets set to true after calling ProduceSignatureHelp, it is for a\n  /// workaround to make sure ProduceSignatureHelp is only called at the deepest\n  /// function call.\n  bool CalledSignatureHelp = false;\n\n  Sema::OffsetOfKind OffsetOfState = Sema::OffsetOfKind::OOK_Outside;\n\n  /// The \"depth\" of the template parameters currently being parsed.\n  unsigned TemplateParameterDepth;\n\n  /// Current kind of OpenMP clause\n  OpenMPClauseKind OMPClauseKind = llvm::omp::OMPC_unknown;\n\n  /// RAII class that manages the template parameter depth.\n  class TemplateParameterDepthRAII {\n    unsigned &Depth;\n    unsigned AddedLevels;\n  public:\n    explicit TemplateParameterDepthRAII(unsigned &Depth)\n      : Depth(Depth), AddedLevels(0) {}\n\n    ~TemplateParameterDepthRAII() {\n      Depth -= AddedLevels;\n    }\n\n    void operator++() {\n      ++Depth;\n      ++AddedLevels;\n    }\n    void addDepth(unsigned D) {\n      Depth += D;\n      AddedLevels += D;\n    }\n    void setAddedDepth(unsigned D) {\n      Depth = Depth - AddedLevels + D;\n      AddedLevels = D;\n    }\n\n    unsigned getDepth() const { return Depth; }\n    unsigned getOriginalDepth() const { return Depth - AddedLevels; }\n  };\n\n  /// Factory object for creating ParsedAttr objects.\n  AttributeFactory AttrFactory;\n\n  /// Gathers and cleans up TemplateIdAnnotations when parsing of a\n  /// top-level declaration is finished.\n  SmallVector<TemplateIdAnnotation *, 16> TemplateIds;\n\n  void MaybeDestroyTemplateIds() {\n    if (!TemplateIds.empty() &&\n        (Tok.is(tok::eof) || !PP.mightHavePendingAnnotationTokens()))\n      DestroyTemplateIds();\n  }\n  void DestroyTemplateIds();\n\n  /// RAII object to destroy TemplateIdAnnotations where possible, from a\n  /// likely-good position during parsing.\n  struct DestroyTemplateIdAnnotationsRAIIObj {\n    Parser &Self;\n\n    DestroyTemplateIdAnnotationsRAIIObj(Parser &Self) : Self(Self) {}\n    ~DestroyTemplateIdAnnotationsRAIIObj() { Self.MaybeDestroyTemplateIds(); }\n  };\n\n  /// Identifiers which have been declared within a tentative parse.\n  SmallVector<IdentifierInfo *, 8> TentativelyDeclaredIdentifiers;\n\n  /// Tracker for '<' tokens that might have been intended to be treated as an\n  /// angle bracket instead of a less-than comparison.\n  ///\n  /// This happens when the user intends to form a template-id, but typoes the\n  /// template-name or forgets a 'template' keyword for a dependent template\n  /// name.\n  ///\n  /// We track these locations from the point where we see a '<' with a\n  /// name-like expression on its left until we see a '>' or '>>' that might\n  /// match it.\n  struct AngleBracketTracker {\n    /// Flags used to rank candidate template names when there is more than one\n    /// '<' in a scope.\n    enum Priority : unsigned short {\n      /// A non-dependent name that is a potential typo for a template name.\n      PotentialTypo = 0x0,\n      /// A dependent name that might instantiate to a template-name.\n      DependentName = 0x2,\n\n      /// A space appears before the '<' token.\n      SpaceBeforeLess = 0x0,\n      /// No space before the '<' token\n      NoSpaceBeforeLess = 0x1,\n\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue*/ DependentName)\n    };\n\n    struct Loc {\n      Expr *TemplateName;\n      SourceLocation LessLoc;\n      AngleBracketTracker::Priority Priority;\n      unsigned short ParenCount, BracketCount, BraceCount;\n\n      bool isActive(Parser &P) const {\n        return P.ParenCount == ParenCount && P.BracketCount == BracketCount &&\n               P.BraceCount == BraceCount;\n      }\n\n      bool isActiveOrNested(Parser &P) const {\n        return isActive(P) || P.ParenCount > ParenCount ||\n               P.BracketCount > BracketCount || P.BraceCount > BraceCount;\n      }\n    };\n\n    SmallVector<Loc, 8> Locs;\n\n    /// Add an expression that might have been intended to be a template name.\n    /// In the case of ambiguity, we arbitrarily select the innermost such\n    /// expression, for example in 'foo < bar < baz', 'bar' is the current\n    /// candidate. No attempt is made to track that 'foo' is also a candidate\n    /// for the case where we see a second suspicious '>' token.\n    void add(Parser &P, Expr *TemplateName, SourceLocation LessLoc,\n             Priority Prio) {\n      if (!Locs.empty() && Locs.back().isActive(P)) {\n        if (Locs.back().Priority <= Prio) {\n          Locs.back().TemplateName = TemplateName;\n          Locs.back().LessLoc = LessLoc;\n          Locs.back().Priority = Prio;\n        }\n      } else {\n        Locs.push_back({TemplateName, LessLoc, Prio,\n                        P.ParenCount, P.BracketCount, P.BraceCount});\n      }\n    }\n\n    /// Mark the current potential missing template location as having been\n    /// handled (this happens if we pass a \"corresponding\" '>' or '>>' token\n    /// or leave a bracket scope).\n    void clear(Parser &P) {\n      while (!Locs.empty() && Locs.back().isActiveOrNested(P))\n        Locs.pop_back();\n    }\n\n    /// Get the current enclosing expression that might hve been intended to be\n    /// a template name.\n    Loc *getCurrent(Parser &P) {\n      if (!Locs.empty() && Locs.back().isActive(P))\n        return &Locs.back();\n      return nullptr;\n    }\n  };\n\n  AngleBracketTracker AngleBrackets;\n\n  IdentifierInfo *getSEHExceptKeyword();\n\n  /// True if we are within an Objective-C container while parsing C-like decls.\n  ///\n  /// This is necessary because Sema thinks we have left the container\n  /// to parse the C-like decls, meaning Actions.getObjCDeclContext() will\n  /// be NULL.\n  bool ParsingInObjCContainer;\n\n  /// Whether to skip parsing of function bodies.\n  ///\n  /// This option can be used, for example, to speed up searches for\n  /// declarations/definitions when indexing.\n  bool SkipFunctionBodies;\n\n  /// The location of the expression statement that is being parsed right now.\n  /// Used to determine if an expression that is being parsed is a statement or\n  /// just a regular sub-expression.\n  SourceLocation ExprStatementTokLoc;\n\n  /// Flags describing a context in which we're parsing a statement.\n  enum class ParsedStmtContext {\n    /// This context permits declarations in language modes where declarations\n    /// are not statements.\n    AllowDeclarationsInC = 0x1,\n    /// This context permits standalone OpenMP directives.\n    AllowStandaloneOpenMPDirectives = 0x2,\n    /// This context is at the top level of a GNU statement expression.\n    InStmtExpr = 0x4,\n\n    /// The context of a regular substatement.\n    SubStmt = 0,\n    /// The context of a compound-statement.\n    Compound = AllowDeclarationsInC | AllowStandaloneOpenMPDirectives,\n\n    LLVM_MARK_AS_BITMASK_ENUM(InStmtExpr)\n  };\n\n  /// Act on an expression statement that might be the last statement in a\n  /// GNU statement expression. Checks whether we are actually at the end of\n  /// a statement expression and builds a suitable expression statement.\n  StmtResult handleExprStmt(ExprResult E, ParsedStmtContext StmtCtx);\n\npublic:\n  Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies);\n  ~Parser() override;\n\n  const LangOptions &getLangOpts() const { return PP.getLangOpts(); }\n  const TargetInfo &getTargetInfo() const { return PP.getTargetInfo(); }\n  Preprocessor &getPreprocessor() const { return PP; }\n  Sema &getActions() const { return Actions; }\n  AttributeFactory &getAttrFactory() { return AttrFactory; }\n\n  const Token &getCurToken() const { return Tok; }\n  Scope *getCurScope() const { return Actions.getCurScope(); }\n  void incrementMSManglingNumber() const {\n    return Actions.incrementMSManglingNumber();\n  }\n\n  ObjCContainerDecl *getObjCDeclContext() const {\n    return Actions.getObjCDeclContext();\n  }\n\n  // Type forwarding.  All of these are statically 'void*', but they may all be\n  // different actual classes based on the actions in place.\n  typedef OpaquePtr<DeclGroupRef> DeclGroupPtrTy;\n  typedef OpaquePtr<TemplateName> TemplateTy;\n\n  typedef SmallVector<TemplateParameterList *, 4> TemplateParameterLists;\n\n  typedef Sema::FullExprArg FullExprArg;\n\n  /// A SmallVector of statements.\n  typedef SmallVector<Stmt *, 32> StmtVector;\n\n  // Parsing methods.\n\n  /// Initialize - Warm up the parser.\n  ///\n  void Initialize();\n\n  /// Parse the first top-level declaration in a translation unit.\n  bool ParseFirstTopLevelDecl(DeclGroupPtrTy &Result,\n                              Sema::ModuleImportState &ImportState);\n\n  /// ParseTopLevelDecl - Parse one top-level declaration. Returns true if\n  /// the EOF was encountered.\n  bool ParseTopLevelDecl(DeclGroupPtrTy &Result,\n                         Sema::ModuleImportState &ImportState);\n  bool ParseTopLevelDecl() {\n    DeclGroupPtrTy Result;\n    Sema::ModuleImportState IS = Sema::ModuleImportState::NotACXX20Module;\n    return ParseTopLevelDecl(Result, IS);\n  }\n\n  /// ConsumeToken - Consume the current 'peek token' and lex the next one.\n  /// This does not work with special tokens: string literals, code completion,\n  /// annotation tokens and balanced tokens must be handled using the specific\n  /// consume methods.\n  /// Returns the location of the consumed token.\n  SourceLocation ConsumeToken() {\n    assert(!isTokenSpecial() &&\n           \"Should consume special tokens with Consume*Token\");\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  bool TryConsumeToken(tok::TokenKind Expected) {\n    if (Tok.isNot(Expected))\n      return false;\n    assert(!isTokenSpecial() &&\n           \"Should consume special tokens with Consume*Token\");\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return true;\n  }\n\n  bool TryConsumeToken(tok::TokenKind Expected, SourceLocation &Loc) {\n    if (!TryConsumeToken(Expected))\n      return false;\n    Loc = PrevTokLocation;\n    return true;\n  }\n\n  /// ConsumeAnyToken - Dispatch to the right Consume* method based on the\n  /// current token type.  This should only be used in cases where the type of\n  /// the token really isn't known, e.g. in error recovery.\n  SourceLocation ConsumeAnyToken(bool ConsumeCodeCompletionTok = false) {\n    if (isTokenParen())\n      return ConsumeParen();\n    if (isTokenBracket())\n      return ConsumeBracket();\n    if (isTokenBrace())\n      return ConsumeBrace();\n    if (isTokenStringLiteral())\n      return ConsumeStringToken();\n    if (Tok.is(tok::code_completion))\n      return ConsumeCodeCompletionTok ? ConsumeCodeCompletionToken()\n                                      : handleUnexpectedCodeCompletionToken();\n    if (Tok.isAnnotation())\n      return ConsumeAnnotationToken();\n    return ConsumeToken();\n  }\n\n\n  SourceLocation getEndOfPreviousToken() {\n    return PP.getLocForEndOfToken(PrevTokLocation);\n  }\n\n  /// Retrieve the underscored keyword (_Nonnull, _Nullable) that corresponds\n  /// to the given nullability kind.\n  IdentifierInfo *getNullabilityKeyword(NullabilityKind nullability) {\n    return Actions.getNullabilityKeyword(nullability);\n  }\n\nprivate:\n  //===--------------------------------------------------------------------===//\n  // Low-Level token peeking and consumption methods.\n  //\n\n  /// isTokenParen - Return true if the cur token is '(' or ')'.\n  bool isTokenParen() const {\n    return Tok.isOneOf(tok::l_paren, tok::r_paren);\n  }\n  /// isTokenBracket - Return true if the cur token is '[' or ']'.\n  bool isTokenBracket() const {\n    return Tok.isOneOf(tok::l_square, tok::r_square);\n  }\n  /// isTokenBrace - Return true if the cur token is '{' or '}'.\n  bool isTokenBrace() const {\n    return Tok.isOneOf(tok::l_brace, tok::r_brace);\n  }\n  /// isTokenStringLiteral - True if this token is a string-literal.\n  bool isTokenStringLiteral() const {\n    return tok::isStringLiteral(Tok.getKind());\n  }\n  /// isTokenSpecial - True if this token requires special consumption methods.\n  bool isTokenSpecial() const {\n    return isTokenStringLiteral() || isTokenParen() || isTokenBracket() ||\n           isTokenBrace() || Tok.is(tok::code_completion) || Tok.isAnnotation();\n  }\n\n  /// Returns true if the current token is '=' or is a type of '='.\n  /// For typos, give a fixit to '='\n  bool isTokenEqualOrEqualTypo();\n\n  /// Return the current token to the token stream and make the given\n  /// token the current token.\n  void UnconsumeToken(Token &Consumed) {\n      Token Next = Tok;\n      PP.EnterToken(Consumed, /*IsReinject*/true);\n      PP.Lex(Tok);\n      PP.EnterToken(Next, /*IsReinject*/true);\n  }\n\n  SourceLocation ConsumeAnnotationToken() {\n    assert(Tok.isAnnotation() && \"wrong consume method\");\n    SourceLocation Loc = Tok.getLocation();\n    PrevTokLocation = Tok.getAnnotationEndLoc();\n    PP.Lex(Tok);\n    return Loc;\n  }\n\n  /// ConsumeParen - This consume method keeps the paren count up-to-date.\n  ///\n  SourceLocation ConsumeParen() {\n    assert(isTokenParen() && \"wrong consume method\");\n    if (Tok.getKind() == tok::l_paren)\n      ++ParenCount;\n    else if (ParenCount) {\n      AngleBrackets.clear(*this);\n      --ParenCount;       // Don't let unbalanced )'s drive the count negative.\n    }\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  /// ConsumeBracket - This consume method keeps the bracket count up-to-date.\n  ///\n  SourceLocation ConsumeBracket() {\n    assert(isTokenBracket() && \"wrong consume method\");\n    if (Tok.getKind() == tok::l_square)\n      ++BracketCount;\n    else if (BracketCount) {\n      AngleBrackets.clear(*this);\n      --BracketCount;     // Don't let unbalanced ]'s drive the count negative.\n    }\n\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  /// ConsumeBrace - This consume method keeps the brace count up-to-date.\n  ///\n  SourceLocation ConsumeBrace() {\n    assert(isTokenBrace() && \"wrong consume method\");\n    if (Tok.getKind() == tok::l_brace)\n      ++BraceCount;\n    else if (BraceCount) {\n      AngleBrackets.clear(*this);\n      --BraceCount;     // Don't let unbalanced }'s drive the count negative.\n    }\n\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  /// ConsumeStringToken - Consume the current 'peek token', lexing a new one\n  /// and returning the token kind.  This method is specific to strings, as it\n  /// handles string literal concatenation, as per C99 5.1.1.2, translation\n  /// phase #6.\n  SourceLocation ConsumeStringToken() {\n    assert(isTokenStringLiteral() &&\n           \"Should only consume string literals with this method\");\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  /// Consume the current code-completion token.\n  ///\n  /// This routine can be called to consume the code-completion token and\n  /// continue processing in special cases where \\c cutOffParsing() isn't\n  /// desired, such as token caching or completion with lookahead.\n  SourceLocation ConsumeCodeCompletionToken() {\n    assert(Tok.is(tok::code_completion));\n    PrevTokLocation = Tok.getLocation();\n    PP.Lex(Tok);\n    return PrevTokLocation;\n  }\n\n  ///\\ brief When we are consuming a code-completion token without having\n  /// matched specific position in the grammar, provide code-completion results\n  /// based on context.\n  ///\n  /// \\returns the source location of the code-completion token.\n  SourceLocation handleUnexpectedCodeCompletionToken();\n\n  /// Abruptly cut off parsing; mainly used when we have reached the\n  /// code-completion point.\n  void cutOffParsing() {\n    if (PP.isCodeCompletionEnabled())\n      PP.setCodeCompletionReached();\n    // Cut off parsing by acting as if we reached the end-of-file.\n    Tok.setKind(tok::eof);\n  }\n\n  /// Determine if we're at the end of the file or at a transition\n  /// between modules.\n  bool isEofOrEom() {\n    tok::TokenKind Kind = Tok.getKind();\n    return Kind == tok::eof || Kind == tok::annot_module_begin ||\n           Kind == tok::annot_module_end || Kind == tok::annot_module_include ||\n           Kind == tok::annot_repl_input_end;\n  }\n\n  /// Checks if the \\p Level is valid for use in a fold expression.\n  bool isFoldOperator(prec::Level Level) const;\n\n  /// Checks if the \\p Kind is a valid operator for fold expressions.\n  bool isFoldOperator(tok::TokenKind Kind) const;\n\n  /// Initialize all pragma handlers.\n  void initializePragmaHandlers();\n\n  /// Destroy and reset all pragma handlers.\n  void resetPragmaHandlers();\n\n  /// Handle the annotation token produced for #pragma unused(...)\n  void HandlePragmaUnused();\n\n  /// Handle the annotation token produced for\n  /// #pragma GCC visibility...\n  void HandlePragmaVisibility();\n\n  /// Handle the annotation token produced for\n  /// #pragma pack...\n  void HandlePragmaPack();\n\n  /// Handle the annotation token produced for\n  /// #pragma ms_struct...\n  void HandlePragmaMSStruct();\n\n  void HandlePragmaMSPointersToMembers();\n\n  void HandlePragmaMSVtorDisp();\n\n  void HandlePragmaMSPragma();\n  bool HandlePragmaMSSection(StringRef PragmaName,\n                             SourceLocation PragmaLocation);\n  bool HandlePragmaMSSegment(StringRef PragmaName,\n                             SourceLocation PragmaLocation);\n  bool HandlePragmaMSInitSeg(StringRef PragmaName,\n                             SourceLocation PragmaLocation);\n  bool HandlePragmaMSStrictGuardStackCheck(StringRef PragmaName,\n                                           SourceLocation PragmaLocation);\n  bool HandlePragmaMSFunction(StringRef PragmaName,\n                              SourceLocation PragmaLocation);\n  bool HandlePragmaMSAllocText(StringRef PragmaName,\n                               SourceLocation PragmaLocation);\n  bool HandlePragmaMSOptimize(StringRef PragmaName,\n                              SourceLocation PragmaLocation);\n\n  /// Handle the annotation token produced for\n  /// #pragma align...\n  void HandlePragmaAlign();\n\n  /// Handle the annotation token produced for\n  /// #pragma clang __debug dump...\n  void HandlePragmaDump();\n\n  /// Handle the annotation token produced for\n  /// #pragma weak id...\n  void HandlePragmaWeak();\n\n  /// Handle the annotation token produced for\n  /// #pragma weak id = id...\n  void HandlePragmaWeakAlias();\n\n  /// Handle the annotation token produced for\n  /// #pragma redefine_extname...\n  void HandlePragmaRedefineExtname();\n\n  /// Handle the annotation token produced for\n  /// #pragma STDC FP_CONTRACT...\n  void HandlePragmaFPContract();\n\n  /// Handle the annotation token produced for\n  /// #pragma STDC FENV_ACCESS...\n  void HandlePragmaFEnvAccess();\n\n  /// Handle the annotation token produced for\n  /// #pragma STDC FENV_ROUND...\n  void HandlePragmaFEnvRound();\n\n  /// Handle the annotation token produced for\n  /// #pragma float_control\n  void HandlePragmaFloatControl();\n\n  /// \\brief Handle the annotation token produced for\n  /// #pragma clang fp ...\n  void HandlePragmaFP();\n\n  /// Handle the annotation token produced for\n  /// #pragma OPENCL EXTENSION...\n  void HandlePragmaOpenCLExtension();\n\n  /// Handle the annotation token produced for\n  /// #pragma clang __debug captured\n  StmtResult HandlePragmaCaptured();\n\n  /// Handle the annotation token produced for\n  /// #pragma clang loop and #pragma unroll.\n  bool HandlePragmaLoopHint(LoopHint &Hint);\n\n  bool ParsePragmaAttributeSubjectMatchRuleSet(\n      attr::ParsedSubjectMatchRuleSet &SubjectMatchRules,\n      SourceLocation &AnyLoc, SourceLocation &LastMatchRuleEndLoc);\n\n  void HandlePragmaAttribute();\n\n  /// GetLookAheadToken - This peeks ahead N tokens and returns that token\n  /// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)\n  /// returns the token after Tok, etc.\n  ///\n  /// Note that this differs from the Preprocessor's LookAhead method, because\n  /// the Parser always has one token lexed that the preprocessor doesn't.\n  ///\n  const Token &GetLookAheadToken(unsigned N) {\n    if (N == 0 || Tok.is(tok::eof)) return Tok;\n    return PP.LookAhead(N-1);\n  }\n\npublic:\n  /// NextToken - This peeks ahead one token and returns it without\n  /// consuming it.\n  const Token &NextToken() {\n    return PP.LookAhead(0);\n  }\n\n  /// getTypeAnnotation - Read a parsed type out of an annotation token.\n  static TypeResult getTypeAnnotation(const Token &Tok) {\n    if (!Tok.getAnnotationValue())\n      return TypeError();\n    return ParsedType::getFromOpaquePtr(Tok.getAnnotationValue());\n  }\n\nprivate:\n  static void setTypeAnnotation(Token &Tok, TypeResult T) {\n    assert((T.isInvalid() || T.get()) &&\n           \"produced a valid-but-null type annotation?\");\n    Tok.setAnnotationValue(T.isInvalid() ? nullptr : T.get().getAsOpaquePtr());\n  }\n\n  static NamedDecl *getNonTypeAnnotation(const Token &Tok) {\n    return static_cast<NamedDecl*>(Tok.getAnnotationValue());\n  }\n\n  static void setNonTypeAnnotation(Token &Tok, NamedDecl *ND) {\n    Tok.setAnnotationValue(ND);\n  }\n\n  static IdentifierInfo *getIdentifierAnnotation(const Token &Tok) {\n    return static_cast<IdentifierInfo*>(Tok.getAnnotationValue());\n  }\n\n  static void setIdentifierAnnotation(Token &Tok, IdentifierInfo *ND) {\n    Tok.setAnnotationValue(ND);\n  }\n\n  /// Read an already-translated primary expression out of an annotation\n  /// token.\n  static ExprResult getExprAnnotation(const Token &Tok) {\n    return ExprResult::getFromOpaquePointer(Tok.getAnnotationValue());\n  }\n\n  /// Set the primary expression corresponding to the given annotation\n  /// token.\n  static void setExprAnnotation(Token &Tok, ExprResult ER) {\n    Tok.setAnnotationValue(ER.getAsOpaquePointer());\n  }\n\npublic:\n  // If NeedType is true, then TryAnnotateTypeOrScopeToken will try harder to\n  // find a type name by attempting typo correction.\n  bool\n  TryAnnotateTypeOrScopeToken(ImplicitTypenameContext AllowImplicitTypename =\n                                  ImplicitTypenameContext::No);\n  bool TryAnnotateTypeOrScopeTokenAfterScopeSpec(\n      CXXScopeSpec &SS, bool IsNewScope,\n      ImplicitTypenameContext AllowImplicitTypename);\n  bool TryAnnotateCXXScopeToken(bool EnteringContext = false);\n\n  bool MightBeCXXScopeToken() {\n    return getLangOpts().CPlusPlus &&\n           (Tok.is(tok::identifier) || Tok.is(tok::coloncolon) ||\n            (Tok.is(tok::annot_template_id) &&\n             NextToken().is(tok::coloncolon)) ||\n            Tok.is(tok::kw_decltype) || Tok.is(tok::kw___super));\n  }\n  bool TryAnnotateOptionalCXXScopeToken(bool EnteringContext = false) {\n    return MightBeCXXScopeToken() && TryAnnotateCXXScopeToken(EnteringContext);\n  }\n\nprivate:\n  enum AnnotatedNameKind {\n    /// Annotation has failed and emitted an error.\n    ANK_Error,\n    /// The identifier is a tentatively-declared name.\n    ANK_TentativeDecl,\n    /// The identifier is a template name. FIXME: Add an annotation for that.\n    ANK_TemplateName,\n    /// The identifier can't be resolved.\n    ANK_Unresolved,\n    /// Annotation was successful.\n    ANK_Success\n  };\n\n  AnnotatedNameKind\n  TryAnnotateName(CorrectionCandidateCallback *CCC = nullptr,\n                  ImplicitTypenameContext AllowImplicitTypename =\n                      ImplicitTypenameContext::No);\n\n  /// Push a tok::annot_cxxscope token onto the token stream.\n  void AnnotateScopeToken(CXXScopeSpec &SS, bool IsNewAnnotation);\n\n  /// TryAltiVecToken - Check for context-sensitive AltiVec identifier tokens,\n  /// replacing them with the non-context-sensitive keywords.  This returns\n  /// true if the token was replaced.\n  bool TryAltiVecToken(DeclSpec &DS, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       bool &isInvalid) {\n    if (!getLangOpts().AltiVec && !getLangOpts().ZVector)\n      return false;\n\n    if (Tok.getIdentifierInfo() != Ident_vector &&\n        Tok.getIdentifierInfo() != Ident_bool &&\n        Tok.getIdentifierInfo() != Ident_Bool &&\n        (!getLangOpts().AltiVec || Tok.getIdentifierInfo() != Ident_pixel))\n      return false;\n\n    return TryAltiVecTokenOutOfLine(DS, Loc, PrevSpec, DiagID, isInvalid);\n  }\n\n  /// TryAltiVecVectorToken - Check for context-sensitive AltiVec vector\n  /// identifier token, replacing it with the non-context-sensitive __vector.\n  /// This returns true if the token was replaced.\n  bool TryAltiVecVectorToken() {\n    if ((!getLangOpts().AltiVec && !getLangOpts().ZVector) ||\n        Tok.getIdentifierInfo() != Ident_vector) return false;\n    return TryAltiVecVectorTokenOutOfLine();\n  }\n\n  bool TryAltiVecVectorTokenOutOfLine();\n  bool TryAltiVecTokenOutOfLine(DeclSpec &DS, SourceLocation Loc,\n                                const char *&PrevSpec, unsigned &DiagID,\n                                bool &isInvalid);\n\n  /// Returns true if the current token is the identifier 'instancetype'.\n  ///\n  /// Should only be used in Objective-C language modes.\n  bool isObjCInstancetype() {\n    assert(getLangOpts().ObjC);\n    if (Tok.isAnnotation())\n      return false;\n    if (!Ident_instancetype)\n      Ident_instancetype = PP.getIdentifierInfo(\"instancetype\");\n    return Tok.getIdentifierInfo() == Ident_instancetype;\n  }\n\n  /// TryKeywordIdentFallback - For compatibility with system headers using\n  /// keywords as identifiers, attempt to convert the current token to an\n  /// identifier and optionally disable the keyword for the remainder of the\n  /// translation unit. This returns false if the token was not replaced,\n  /// otherwise emits a diagnostic and returns true.\n  bool TryKeywordIdentFallback(bool DisableKeyword);\n\n  /// Get the TemplateIdAnnotation from the token.\n  TemplateIdAnnotation *takeTemplateIdAnnotation(const Token &tok);\n\n  /// TentativeParsingAction - An object that is used as a kind of \"tentative\n  /// parsing transaction\". It gets instantiated to mark the token position and\n  /// after the token consumption is done, Commit() or Revert() is called to\n  /// either \"commit the consumed tokens\" or revert to the previously marked\n  /// token position. Example:\n  ///\n  ///   TentativeParsingAction TPA(*this);\n  ///   ConsumeToken();\n  ///   ....\n  ///   TPA.Revert();\n  ///\n  class TentativeParsingAction {\n    Parser &P;\n    PreferredTypeBuilder PrevPreferredType;\n    Token PrevTok;\n    size_t PrevTentativelyDeclaredIdentifierCount;\n    unsigned short PrevParenCount, PrevBracketCount, PrevBraceCount;\n    bool isActive;\n\n  public:\n    explicit TentativeParsingAction(Parser &p)\n        : P(p), PrevPreferredType(P.PreferredType) {\n      PrevTok = P.Tok;\n      PrevTentativelyDeclaredIdentifierCount =\n          P.TentativelyDeclaredIdentifiers.size();\n      PrevParenCount = P.ParenCount;\n      PrevBracketCount = P.BracketCount;\n      PrevBraceCount = P.BraceCount;\n      P.PP.EnableBacktrackAtThisPos();\n      isActive = true;\n    }\n    void Commit() {\n      assert(isActive && \"Parsing action was finished!\");\n      P.TentativelyDeclaredIdentifiers.resize(\n          PrevTentativelyDeclaredIdentifierCount);\n      P.PP.CommitBacktrackedTokens();\n      isActive = false;\n    }\n    void Revert() {\n      assert(isActive && \"Parsing action was finished!\");\n      P.PP.Backtrack();\n      P.PreferredType = PrevPreferredType;\n      P.Tok = PrevTok;\n      P.TentativelyDeclaredIdentifiers.resize(\n          PrevTentativelyDeclaredIdentifierCount);\n      P.ParenCount = PrevParenCount;\n      P.BracketCount = PrevBracketCount;\n      P.BraceCount = PrevBraceCount;\n      isActive = false;\n    }\n    ~TentativeParsingAction() {\n      assert(!isActive && \"Forgot to call Commit or Revert!\");\n    }\n  };\n  /// A TentativeParsingAction that automatically reverts in its destructor.\n  /// Useful for disambiguation parses that will always be reverted.\n  class RevertingTentativeParsingAction\n      : private Parser::TentativeParsingAction {\n  public:\n    RevertingTentativeParsingAction(Parser &P)\n        : Parser::TentativeParsingAction(P) {}\n    ~RevertingTentativeParsingAction() { Revert(); }\n  };\n\n  class UnannotatedTentativeParsingAction;\n\n  /// ObjCDeclContextSwitch - An object used to switch context from\n  /// an objective-c decl context to its enclosing decl context and\n  /// back.\n  class ObjCDeclContextSwitch {\n    Parser &P;\n    ObjCContainerDecl *DC;\n    SaveAndRestore<bool> WithinObjCContainer;\n  public:\n    explicit ObjCDeclContextSwitch(Parser &p)\n      : P(p), DC(p.getObjCDeclContext()),\n        WithinObjCContainer(P.ParsingInObjCContainer, DC != nullptr) {\n      if (DC)\n        P.Actions.ActOnObjCTemporaryExitContainerContext(DC);\n    }\n    ~ObjCDeclContextSwitch() {\n      if (DC)\n        P.Actions.ActOnObjCReenterContainerContext(DC);\n    }\n  };\n\n  /// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the\n  /// input.  If so, it is consumed and false is returned.\n  ///\n  /// If a trivial punctuator misspelling is encountered, a FixIt error\n  /// diagnostic is issued and false is returned after recovery.\n  ///\n  /// If the input is malformed, this emits the specified diagnostic and true is\n  /// returned.\n  bool ExpectAndConsume(tok::TokenKind ExpectedTok,\n                        unsigned Diag = diag::err_expected,\n                        StringRef DiagMsg = \"\");\n\n  /// The parser expects a semicolon and, if present, will consume it.\n  ///\n  /// If the next token is not a semicolon, this emits the specified diagnostic,\n  /// or, if there's just some closing-delimiter noise (e.g., ')' or ']') prior\n  /// to the semicolon, consumes that extra token.\n  bool ExpectAndConsumeSemi(unsigned DiagID , StringRef TokenUsed = \"\");\n\n  /// The kind of extra semi diagnostic to emit.\n  enum ExtraSemiKind {\n    OutsideFunction = 0,\n    InsideStruct = 1,\n    InstanceVariableList = 2,\n    AfterMemberFunctionDefinition = 3\n  };\n\n  /// Consume any extra semi-colons until the end of the line.\n  void ConsumeExtraSemi(ExtraSemiKind Kind, DeclSpec::TST T = TST_unspecified);\n\n  /// Return false if the next token is an identifier. An 'expected identifier'\n  /// error is emitted otherwise.\n  ///\n  /// The parser tries to recover from the error by checking if the next token\n  /// is a C++ keyword when parsing Objective-C++. Return false if the recovery\n  /// was successful.\n  bool expectIdentifier();\n\n  /// Kinds of compound pseudo-tokens formed by a sequence of two real tokens.\n  enum class CompoundToken {\n    /// A '(' '{' beginning a statement-expression.\n    StmtExprBegin,\n    /// A '}' ')' ending a statement-expression.\n    StmtExprEnd,\n    /// A '[' '[' beginning a C++11 or C2x attribute.\n    AttrBegin,\n    /// A ']' ']' ending a C++11 or C2x attribute.\n    AttrEnd,\n    /// A '::' '*' forming a C++ pointer-to-member declaration.\n    MemberPtr,\n  };\n\n  /// Check that a compound operator was written in a \"sensible\" way, and warn\n  /// if not.\n  void checkCompoundToken(SourceLocation FirstTokLoc,\n                          tok::TokenKind FirstTokKind, CompoundToken Op);\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // Scope manipulation\n\n  /// ParseScope - Introduces a new scope for parsing. The kind of\n  /// scope is determined by ScopeFlags. Objects of this type should\n  /// be created on the stack to coincide with the position where the\n  /// parser enters the new scope, and this object's constructor will\n  /// create that new scope. Similarly, once the object is destroyed\n  /// the parser will exit the scope.\n  class ParseScope {\n    Parser *Self;\n    ParseScope(const ParseScope &) = delete;\n    void operator=(const ParseScope &) = delete;\n\n  public:\n    // ParseScope - Construct a new object to manage a scope in the\n    // parser Self where the new Scope is created with the flags\n    // ScopeFlags, but only when we aren't about to enter a compound statement.\n    ParseScope(Parser *Self, unsigned ScopeFlags, bool EnteredScope = true,\n               bool BeforeCompoundStmt = false)\n      : Self(Self) {\n      if (EnteredScope && !BeforeCompoundStmt)\n        Self->EnterScope(ScopeFlags);\n      else {\n        if (BeforeCompoundStmt)\n          Self->incrementMSManglingNumber();\n\n        this->Self = nullptr;\n      }\n    }\n\n    // Exit - Exit the scope associated with this object now, rather\n    // than waiting until the object is destroyed.\n    void Exit() {\n      if (Self) {\n        Self->ExitScope();\n        Self = nullptr;\n      }\n    }\n\n    ~ParseScope() {\n      Exit();\n    }\n  };\n\n  /// Introduces zero or more scopes for parsing. The scopes will all be exited\n  /// when the object is destroyed.\n  class MultiParseScope {\n    Parser &Self;\n    unsigned NumScopes = 0;\n\n    MultiParseScope(const MultiParseScope&) = delete;\n\n  public:\n    MultiParseScope(Parser &Self) : Self(Self) {}\n    void Enter(unsigned ScopeFlags) {\n      Self.EnterScope(ScopeFlags);\n      ++NumScopes;\n    }\n    void Exit() {\n      while (NumScopes) {\n        Self.ExitScope();\n        --NumScopes;\n      }\n    }\n    ~MultiParseScope() {\n      Exit();\n    }\n  };\n\n  /// EnterScope - Start a new scope.\n  void EnterScope(unsigned ScopeFlags);\n\n  /// ExitScope - Pop a scope off the scope stack.\n  void ExitScope();\n\n  /// Re-enter the template scopes for a declaration that might be a template.\n  unsigned ReenterTemplateScopes(MultiParseScope &S, Decl *D);\n\nprivate:\n  /// RAII object used to modify the scope flags for the current scope.\n  class ParseScopeFlags {\n    Scope *CurScope;\n    unsigned OldFlags = 0;\n    ParseScopeFlags(const ParseScopeFlags &) = delete;\n    void operator=(const ParseScopeFlags &) = delete;\n\n  public:\n    ParseScopeFlags(Parser *Self, unsigned ScopeFlags, bool ManageFlags = true);\n    ~ParseScopeFlags();\n  };\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic Emission and Error recovery.\n\npublic:\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID);\n  DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID);\n  DiagnosticBuilder Diag(unsigned DiagID) {\n    return Diag(Tok, DiagID);\n  }\n\nprivate:\n  void SuggestParentheses(SourceLocation Loc, unsigned DK,\n                          SourceRange ParenRange);\n  void CheckNestedObjCContexts(SourceLocation AtLoc);\n\npublic:\n\n  /// Control flags for SkipUntil functions.\n  enum SkipUntilFlags {\n    StopAtSemi = 1 << 0,  ///< Stop skipping at semicolon\n    /// Stop skipping at specified token, but don't skip the token itself\n    StopBeforeMatch = 1 << 1,\n    StopAtCodeCompletion = 1 << 2 ///< Stop at code completion\n  };\n\n  friend constexpr SkipUntilFlags operator|(SkipUntilFlags L,\n                                            SkipUntilFlags R) {\n    return static_cast<SkipUntilFlags>(static_cast<unsigned>(L) |\n                                       static_cast<unsigned>(R));\n  }\n\n  /// SkipUntil - Read tokens until we get to the specified token, then consume\n  /// it (unless StopBeforeMatch is specified).  Because we cannot guarantee\n  /// that the token will ever occur, this skips to the next token, or to some\n  /// likely good stopping point.  If Flags has StopAtSemi flag, skipping will\n  /// stop at a ';' character. Balances (), [], and {} delimiter tokens while\n  /// skipping.\n  ///\n  /// If SkipUntil finds the specified token, it returns true, otherwise it\n  /// returns false.\n  bool SkipUntil(tok::TokenKind T,\n                 SkipUntilFlags Flags = static_cast<SkipUntilFlags>(0)) {\n    return SkipUntil(llvm::ArrayRef(T), Flags);\n  }\n  bool SkipUntil(tok::TokenKind T1, tok::TokenKind T2,\n                 SkipUntilFlags Flags = static_cast<SkipUntilFlags>(0)) {\n    tok::TokenKind TokArray[] = {T1, T2};\n    return SkipUntil(TokArray, Flags);\n  }\n  bool SkipUntil(tok::TokenKind T1, tok::TokenKind T2, tok::TokenKind T3,\n                 SkipUntilFlags Flags = static_cast<SkipUntilFlags>(0)) {\n    tok::TokenKind TokArray[] = {T1, T2, T3};\n    return SkipUntil(TokArray, Flags);\n  }\n  bool SkipUntil(ArrayRef<tok::TokenKind> Toks,\n                 SkipUntilFlags Flags = static_cast<SkipUntilFlags>(0));\n\n  /// SkipMalformedDecl - Read tokens until we get to some likely good stopping\n  /// point for skipping past a simple-declaration.\n  void SkipMalformedDecl();\n\n  /// The location of the first statement inside an else that might\n  /// have a missleading indentation. If there is no\n  /// MisleadingIndentationChecker on an else active, this location is invalid.\n  SourceLocation MisleadingIndentationElseLoc;\n\nprivate:\n  //===--------------------------------------------------------------------===//\n  // Lexing and parsing of C++ inline methods.\n\n  struct ParsingClass;\n\n  /// [class.mem]p1: \"... the class is regarded as complete within\n  /// - function bodies\n  /// - default arguments\n  /// - exception-specifications (TODO: C++0x)\n  /// - and brace-or-equal-initializers for non-static data members\n  /// (including such things in nested classes).\"\n  /// LateParsedDeclarations build the tree of those elements so they can\n  /// be parsed after parsing the top-level class.\n  class LateParsedDeclaration {\n  public:\n    virtual ~LateParsedDeclaration();\n\n    virtual void ParseLexedMethodDeclarations();\n    virtual void ParseLexedMemberInitializers();\n    virtual void ParseLexedMethodDefs();\n    virtual void ParseLexedAttributes();\n    virtual void ParseLexedPragmas();\n  };\n\n  /// Inner node of the LateParsedDeclaration tree that parses\n  /// all its members recursively.\n  class LateParsedClass : public LateParsedDeclaration {\n  public:\n    LateParsedClass(Parser *P, ParsingClass *C);\n    ~LateParsedClass() override;\n\n    void ParseLexedMethodDeclarations() override;\n    void ParseLexedMemberInitializers() override;\n    void ParseLexedMethodDefs() override;\n    void ParseLexedAttributes() override;\n    void ParseLexedPragmas() override;\n\n  private:\n    Parser *Self;\n    ParsingClass *Class;\n  };\n\n  /// Contains the lexed tokens of an attribute with arguments that\n  /// may reference member variables and so need to be parsed at the\n  /// end of the class declaration after parsing all other member\n  /// member declarations.\n  /// FIXME: Perhaps we should change the name of LateParsedDeclaration to\n  /// LateParsedTokens.\n  struct LateParsedAttribute : public LateParsedDeclaration {\n    Parser *Self;\n    CachedTokens Toks;\n    IdentifierInfo &AttrName;\n    IdentifierInfo *MacroII = nullptr;\n    SourceLocation AttrNameLoc;\n    SmallVector<Decl*, 2> Decls;\n\n    explicit LateParsedAttribute(Parser *P, IdentifierInfo &Name,\n                                 SourceLocation Loc)\n      : Self(P), AttrName(Name), AttrNameLoc(Loc) {}\n\n    void ParseLexedAttributes() override;\n\n    void addDecl(Decl *D) { Decls.push_back(D); }\n  };\n\n  /// Contains the lexed tokens of a pragma with arguments that\n  /// may reference member variables and so need to be parsed at the\n  /// end of the class declaration after parsing all other member\n  /// member declarations.\n  class LateParsedPragma : public LateParsedDeclaration {\n    Parser *Self = nullptr;\n    AccessSpecifier AS = AS_none;\n    CachedTokens Toks;\n\n  public:\n    explicit LateParsedPragma(Parser *P, AccessSpecifier AS)\n        : Self(P), AS(AS) {}\n\n    void takeToks(CachedTokens &Cached) { Toks.swap(Cached); }\n    const CachedTokens &toks() const { return Toks; }\n    AccessSpecifier getAccessSpecifier() const { return AS; }\n\n    void ParseLexedPragmas() override;\n  };\n\n  // A list of late-parsed attributes.  Used by ParseGNUAttributes.\n  class LateParsedAttrList: public SmallVector<LateParsedAttribute *, 2> {\n  public:\n    LateParsedAttrList(bool PSoon = false) : ParseSoon(PSoon) { }\n\n    bool parseSoon() { return ParseSoon; }\n\n  private:\n    bool ParseSoon;  // Are we planning to parse these shortly after creation?\n  };\n\n  /// Contains the lexed tokens of a member function definition\n  /// which needs to be parsed at the end of the class declaration\n  /// after parsing all other member declarations.\n  struct LexedMethod : public LateParsedDeclaration {\n    Parser *Self;\n    Decl *D;\n    CachedTokens Toks;\n\n    explicit LexedMethod(Parser *P, Decl *MD) : Self(P), D(MD) {}\n\n    void ParseLexedMethodDefs() override;\n  };\n\n  /// LateParsedDefaultArgument - Keeps track of a parameter that may\n  /// have a default argument that cannot be parsed yet because it\n  /// occurs within a member function declaration inside the class\n  /// (C++ [class.mem]p2).\n  struct LateParsedDefaultArgument {\n    explicit LateParsedDefaultArgument(Decl *P,\n                                       std::unique_ptr<CachedTokens> Toks = nullptr)\n      : Param(P), Toks(std::move(Toks)) { }\n\n    /// Param - The parameter declaration for this parameter.\n    Decl *Param;\n\n    /// Toks - The sequence of tokens that comprises the default\n    /// argument expression, not including the '=' or the terminating\n    /// ')' or ','. This will be NULL for parameters that have no\n    /// default argument.\n    std::unique_ptr<CachedTokens> Toks;\n  };\n\n  /// LateParsedMethodDeclaration - A method declaration inside a class that\n  /// contains at least one entity whose parsing needs to be delayed\n  /// until the class itself is completely-defined, such as a default\n  /// argument (C++ [class.mem]p2).\n  struct LateParsedMethodDeclaration : public LateParsedDeclaration {\n    explicit LateParsedMethodDeclaration(Parser *P, Decl *M)\n        : Self(P), Method(M), ExceptionSpecTokens(nullptr) {}\n\n    void ParseLexedMethodDeclarations() override;\n\n    Parser *Self;\n\n    /// Method - The method declaration.\n    Decl *Method;\n\n    /// DefaultArgs - Contains the parameters of the function and\n    /// their default arguments. At least one of the parameters will\n    /// have a default argument, but all of the parameters of the\n    /// method will be stored so that they can be reintroduced into\n    /// scope at the appropriate times.\n    SmallVector<LateParsedDefaultArgument, 8> DefaultArgs;\n\n    /// The set of tokens that make up an exception-specification that\n    /// has not yet been parsed.\n    CachedTokens *ExceptionSpecTokens;\n  };\n\n  /// LateParsedMemberInitializer - An initializer for a non-static class data\n  /// member whose parsing must to be delayed until the class is completely\n  /// defined (C++11 [class.mem]p2).\n  struct LateParsedMemberInitializer : public LateParsedDeclaration {\n    LateParsedMemberInitializer(Parser *P, Decl *FD)\n      : Self(P), Field(FD) { }\n\n    void ParseLexedMemberInitializers() override;\n\n    Parser *Self;\n\n    /// Field - The field declaration.\n    Decl *Field;\n\n    /// CachedTokens - The sequence of tokens that comprises the initializer,\n    /// including any leading '='.\n    CachedTokens Toks;\n  };\n\n  /// LateParsedDeclarationsContainer - During parsing of a top (non-nested)\n  /// C++ class, its method declarations that contain parts that won't be\n  /// parsed until after the definition is completed (C++ [class.mem]p2),\n  /// the method declarations and possibly attached inline definitions\n  /// will be stored here with the tokens that will be parsed to create those\n  /// entities.\n  typedef SmallVector<LateParsedDeclaration*,2> LateParsedDeclarationsContainer;\n\n  /// Representation of a class that has been parsed, including\n  /// any member function declarations or definitions that need to be\n  /// parsed after the corresponding top-level class is complete.\n  struct ParsingClass {\n    ParsingClass(Decl *TagOrTemplate, bool TopLevelClass, bool IsInterface)\n        : TopLevelClass(TopLevelClass), IsInterface(IsInterface),\n          TagOrTemplate(TagOrTemplate) {}\n\n    /// Whether this is a \"top-level\" class, meaning that it is\n    /// not nested within another class.\n    bool TopLevelClass : 1;\n\n    /// Whether this class is an __interface.\n    bool IsInterface : 1;\n\n    /// The class or class template whose definition we are parsing.\n    Decl *TagOrTemplate;\n\n    /// LateParsedDeclarations - Method declarations, inline definitions and\n    /// nested classes that contain pieces whose parsing will be delayed until\n    /// the top-level class is fully defined.\n    LateParsedDeclarationsContainer LateParsedDeclarations;\n  };\n\n  /// The stack of classes that is currently being\n  /// parsed. Nested and local classes will be pushed onto this stack\n  /// when they are parsed, and removed afterward.\n  std::stack<ParsingClass *> ClassStack;\n\n  ParsingClass &getCurrentClass() {\n    assert(!ClassStack.empty() && \"No lexed method stacks!\");\n    return *ClassStack.top();\n  }\n\n  /// RAII object used to manage the parsing of a class definition.\n  class ParsingClassDefinition {\n    Parser &P;\n    bool Popped;\n    Sema::ParsingClassState State;\n\n  public:\n    ParsingClassDefinition(Parser &P, Decl *TagOrTemplate, bool TopLevelClass,\n                           bool IsInterface)\n      : P(P), Popped(false),\n        State(P.PushParsingClass(TagOrTemplate, TopLevelClass, IsInterface)) {\n    }\n\n    /// Pop this class of the stack.\n    void Pop() {\n      assert(!Popped && \"Nested class has already been popped\");\n      Popped = true;\n      P.PopParsingClass(State);\n    }\n\n    ~ParsingClassDefinition() {\n      if (!Popped)\n        P.PopParsingClass(State);\n    }\n  };\n\n  /// Contains information about any template-specific\n  /// information that has been parsed prior to parsing declaration\n  /// specifiers.\n  struct ParsedTemplateInfo {\n    ParsedTemplateInfo() : Kind(NonTemplate), TemplateParams(nullptr) {}\n\n    ParsedTemplateInfo(TemplateParameterLists *TemplateParams,\n                       bool isSpecialization,\n                       bool lastParameterListWasEmpty = false)\n      : Kind(isSpecialization? ExplicitSpecialization : Template),\n        TemplateParams(TemplateParams),\n        LastParameterListWasEmpty(lastParameterListWasEmpty) { }\n\n    explicit ParsedTemplateInfo(SourceLocation ExternLoc,\n                                SourceLocation TemplateLoc)\n      : Kind(ExplicitInstantiation), TemplateParams(nullptr),\n        ExternLoc(ExternLoc), TemplateLoc(TemplateLoc),\n        LastParameterListWasEmpty(false){ }\n\n    /// The kind of template we are parsing.\n    enum {\n      /// We are not parsing a template at all.\n      NonTemplate = 0,\n      /// We are parsing a template declaration.\n      Template,\n      /// We are parsing an explicit specialization.\n      ExplicitSpecialization,\n      /// We are parsing an explicit instantiation.\n      ExplicitInstantiation\n    } Kind;\n\n    /// The template parameter lists, for template declarations\n    /// and explicit specializations.\n    TemplateParameterLists *TemplateParams;\n\n    /// The location of the 'extern' keyword, if any, for an explicit\n    /// instantiation\n    SourceLocation ExternLoc;\n\n    /// The location of the 'template' keyword, for an explicit\n    /// instantiation.\n    SourceLocation TemplateLoc;\n\n    /// Whether the last template parameter list was empty.\n    bool LastParameterListWasEmpty;\n\n    SourceRange getSourceRange() const LLVM_READONLY;\n  };\n\n  // In ParseCXXInlineMethods.cpp.\n  struct ReenterTemplateScopeRAII;\n  struct ReenterClassScopeRAII;\n\n  void LexTemplateFunctionForLateParsing(CachedTokens &Toks);\n  void ParseLateTemplatedFuncDef(LateParsedTemplate &LPT);\n\n  static void LateTemplateParserCallback(void *P, LateParsedTemplate &LPT);\n\n  Sema::ParsingClassState\n  PushParsingClass(Decl *TagOrTemplate, bool TopLevelClass, bool IsInterface);\n  void DeallocateParsedClasses(ParsingClass *Class);\n  void PopParsingClass(Sema::ParsingClassState);\n\n  enum CachedInitKind {\n    CIK_DefaultArgument,\n    CIK_DefaultInitializer\n  };\n\n  NamedDecl *ParseCXXInlineMethodDef(AccessSpecifier AS,\n                                     const ParsedAttributesView &AccessAttrs,\n                                     ParsingDeclarator &D,\n                                     const ParsedTemplateInfo &TemplateInfo,\n                                     const VirtSpecifiers &VS,\n                                     SourceLocation PureSpecLoc);\n  void ParseCXXNonStaticMemberInitializer(Decl *VarD);\n  void ParseLexedAttributes(ParsingClass &Class);\n  void ParseLexedAttributeList(LateParsedAttrList &LAs, Decl *D,\n                               bool EnterScope, bool OnDefinition);\n  void ParseLexedAttribute(LateParsedAttribute &LA,\n                           bool EnterScope, bool OnDefinition);\n  void ParseLexedMethodDeclarations(ParsingClass &Class);\n  void ParseLexedMethodDeclaration(LateParsedMethodDeclaration &LM);\n  void ParseLexedMethodDefs(ParsingClass &Class);\n  void ParseLexedMethodDef(LexedMethod &LM);\n  void ParseLexedMemberInitializers(ParsingClass &Class);\n  void ParseLexedMemberInitializer(LateParsedMemberInitializer &MI);\n  void ParseLexedObjCMethodDefs(LexedMethod &LM, bool parseMethod);\n  void ParseLexedPragmas(ParsingClass &Class);\n  void ParseLexedPragma(LateParsedPragma &LP);\n  bool ConsumeAndStoreFunctionPrologue(CachedTokens &Toks);\n  bool ConsumeAndStoreInitializer(CachedTokens &Toks, CachedInitKind CIK);\n  bool ConsumeAndStoreConditional(CachedTokens &Toks);\n  bool ConsumeAndStoreUntil(tok::TokenKind T1,\n                            CachedTokens &Toks,\n                            bool StopAtSemi = true,\n                            bool ConsumeFinalToken = true) {\n    return ConsumeAndStoreUntil(T1, T1, Toks, StopAtSemi, ConsumeFinalToken);\n  }\n  bool ConsumeAndStoreUntil(tok::TokenKind T1, tok::TokenKind T2,\n                            CachedTokens &Toks,\n                            bool StopAtSemi = true,\n                            bool ConsumeFinalToken = true);\n\n  //===--------------------------------------------------------------------===//\n  // C99 6.9: External Definitions.\n  DeclGroupPtrTy ParseExternalDeclaration(ParsedAttributes &DeclAttrs,\n                                          ParsedAttributes &DeclSpecAttrs,\n                                          ParsingDeclSpec *DS = nullptr);\n  bool isDeclarationAfterDeclarator();\n  bool isStartOfFunctionDefinition(const ParsingDeclarator &Declarator);\n  DeclGroupPtrTy ParseDeclarationOrFunctionDefinition(\n      ParsedAttributes &DeclAttrs, ParsedAttributes &DeclSpecAttrs,\n      ParsingDeclSpec *DS = nullptr, AccessSpecifier AS = AS_none);\n  DeclGroupPtrTy ParseDeclOrFunctionDefInternal(ParsedAttributes &Attrs,\n                                                ParsedAttributes &DeclSpecAttrs,\n                                                ParsingDeclSpec &DS,\n                                                AccessSpecifier AS);\n\n  void SkipFunctionBody();\n  Decl *ParseFunctionDefinition(ParsingDeclarator &D,\n                 const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),\n                 LateParsedAttrList *LateParsedAttrs = nullptr);\n  void ParseKNRParamDeclarations(Declarator &D);\n  // EndLoc is filled with the location of the last token of the simple-asm.\n  ExprResult ParseSimpleAsm(bool ForAsmLabel, SourceLocation *EndLoc);\n  ExprResult ParseAsmStringLiteral(bool ForAsmLabel);\n\n  // Objective-C External Declarations\n  void MaybeSkipAttributes(tok::ObjCKeywordKind Kind);\n  DeclGroupPtrTy ParseObjCAtDirectives(ParsedAttributes &DeclAttrs,\n                                       ParsedAttributes &DeclSpecAttrs);\n  DeclGroupPtrTy ParseObjCAtClassDeclaration(SourceLocation atLoc);\n  Decl *ParseObjCAtInterfaceDeclaration(SourceLocation AtLoc,\n                                        ParsedAttributes &prefixAttrs);\n  class ObjCTypeParamListScope;\n  ObjCTypeParamList *parseObjCTypeParamList();\n  ObjCTypeParamList *parseObjCTypeParamListOrProtocolRefs(\n      ObjCTypeParamListScope &Scope, SourceLocation &lAngleLoc,\n      SmallVectorImpl<IdentifierLocPair> &protocolIdents,\n      SourceLocation &rAngleLoc, bool mayBeProtocolList = true);\n\n  void HelperActionsForIvarDeclarations(ObjCContainerDecl *interfaceDecl,\n                                        SourceLocation atLoc,\n                                        BalancedDelimiterTracker &T,\n                                        SmallVectorImpl<Decl *> &AllIvarDecls,\n                                        bool RBraceMissing);\n  void ParseObjCClassInstanceVariables(ObjCContainerDecl *interfaceDecl,\n                                       tok::ObjCKeywordKind visibility,\n                                       SourceLocation atLoc);\n  bool ParseObjCProtocolReferences(SmallVectorImpl<Decl *> &P,\n                                   SmallVectorImpl<SourceLocation> &PLocs,\n                                   bool WarnOnDeclarations,\n                                   bool ForObjCContainer,\n                                   SourceLocation &LAngleLoc,\n                                   SourceLocation &EndProtoLoc,\n                                   bool consumeLastToken);\n\n  /// Parse the first angle-bracket-delimited clause for an\n  /// Objective-C object or object pointer type, which may be either\n  /// type arguments or protocol qualifiers.\n  void parseObjCTypeArgsOrProtocolQualifiers(\n         ParsedType baseType,\n         SourceLocation &typeArgsLAngleLoc,\n         SmallVectorImpl<ParsedType> &typeArgs,\n         SourceLocation &typeArgsRAngleLoc,\n         SourceLocation &protocolLAngleLoc,\n         SmallVectorImpl<Decl *> &protocols,\n         SmallVectorImpl<SourceLocation> &protocolLocs,\n         SourceLocation &protocolRAngleLoc,\n         bool consumeLastToken,\n         bool warnOnIncompleteProtocols);\n\n  /// Parse either Objective-C type arguments or protocol qualifiers; if the\n  /// former, also parse protocol qualifiers afterward.\n  void parseObjCTypeArgsAndProtocolQualifiers(\n         ParsedType baseType,\n         SourceLocation &typeArgsLAngleLoc,\n         SmallVectorImpl<ParsedType> &typeArgs,\n         SourceLocation &typeArgsRAngleLoc,\n         SourceLocation &protocolLAngleLoc,\n         SmallVectorImpl<Decl *> &protocols,\n         SmallVectorImpl<SourceLocation> &protocolLocs,\n         SourceLocation &protocolRAngleLoc,\n         bool consumeLastToken);\n\n  /// Parse a protocol qualifier type such as '<NSCopying>', which is\n  /// an anachronistic way of writing 'id<NSCopying>'.\n  TypeResult parseObjCProtocolQualifierType(SourceLocation &rAngleLoc);\n\n  /// Parse Objective-C type arguments and protocol qualifiers, extending the\n  /// current type with the parsed result.\n  TypeResult parseObjCTypeArgsAndProtocolQualifiers(SourceLocation loc,\n                                                    ParsedType type,\n                                                    bool consumeLastToken,\n                                                    SourceLocation &endLoc);\n\n  void ParseObjCInterfaceDeclList(tok::ObjCKeywordKind contextKey,\n                                  Decl *CDecl);\n  DeclGroupPtrTy ParseObjCAtProtocolDeclaration(SourceLocation atLoc,\n                                                ParsedAttributes &prefixAttrs);\n\n  struct ObjCImplParsingDataRAII {\n    Parser &P;\n    Decl *Dcl;\n    bool HasCFunction;\n    typedef SmallVector<LexedMethod*, 8> LateParsedObjCMethodContainer;\n    LateParsedObjCMethodContainer LateParsedObjCMethods;\n\n    ObjCImplParsingDataRAII(Parser &parser, Decl *D)\n      : P(parser), Dcl(D), HasCFunction(false) {\n      P.CurParsedObjCImpl = this;\n      Finished = false;\n    }\n    ~ObjCImplParsingDataRAII();\n\n    void finish(SourceRange AtEnd);\n    bool isFinished() const { return Finished; }\n\n  private:\n    bool Finished;\n  };\n  ObjCImplParsingDataRAII *CurParsedObjCImpl;\n  void StashAwayMethodOrFunctionBodyTokens(Decl *MDecl);\n\n  DeclGroupPtrTy ParseObjCAtImplementationDeclaration(SourceLocation AtLoc,\n                                                      ParsedAttributes &Attrs);\n  DeclGroupPtrTy ParseObjCAtEndDeclaration(SourceRange atEnd);\n  Decl *ParseObjCAtAliasDeclaration(SourceLocation atLoc);\n  Decl *ParseObjCPropertySynthesize(SourceLocation atLoc);\n  Decl *ParseObjCPropertyDynamic(SourceLocation atLoc);\n\n  IdentifierInfo *ParseObjCSelectorPiece(SourceLocation &MethodLocation);\n  // Definitions for Objective-c context sensitive keywords recognition.\n  enum ObjCTypeQual {\n    objc_in=0, objc_out, objc_inout, objc_oneway, objc_bycopy, objc_byref,\n    objc_nonnull, objc_nullable, objc_null_unspecified,\n    objc_NumQuals\n  };\n  IdentifierInfo *ObjCTypeQuals[objc_NumQuals];\n\n  bool isTokIdentifier_in() const;\n\n  ParsedType ParseObjCTypeName(ObjCDeclSpec &DS, DeclaratorContext Ctx,\n                               ParsedAttributes *ParamAttrs);\n  Decl *ParseObjCMethodPrototype(\n            tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,\n            bool MethodDefinition = true);\n  Decl *ParseObjCMethodDecl(SourceLocation mLoc, tok::TokenKind mType,\n            tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,\n            bool MethodDefinition=true);\n  void ParseObjCPropertyAttribute(ObjCDeclSpec &DS);\n\n  Decl *ParseObjCMethodDefinition();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // C99 6.5: Expressions.\n\n  /// TypeCastState - State whether an expression is or may be a type cast.\n  enum TypeCastState {\n    NotTypeCast = 0,\n    MaybeTypeCast,\n    IsTypeCast\n  };\n\n  ExprResult ParseExpression(TypeCastState isTypeCast = NotTypeCast);\n  ExprResult ParseConstantExpressionInExprEvalContext(\n      TypeCastState isTypeCast = NotTypeCast);\n  ExprResult ParseConstantExpression();\n  ExprResult ParseCaseExpression(SourceLocation CaseLoc);\n  ExprResult ParseConstraintExpression();\n  ExprResult\n  ParseConstraintLogicalAndExpression(bool IsTrailingRequiresClause);\n  ExprResult ParseConstraintLogicalOrExpression(bool IsTrailingRequiresClause);\n  // Expr that doesn't include commas.\n  ExprResult ParseAssignmentExpression(TypeCastState isTypeCast = NotTypeCast);\n\n  ExprResult ParseMSAsmIdentifier(llvm::SmallVectorImpl<Token> &LineToks,\n                                  unsigned &NumLineToksConsumed,\n                                  bool IsUnevaluated);\n\n  ExprResult ParseStringLiteralExpression(bool AllowUserDefinedLiteral = false);\n  ExprResult ParseUnevaluatedStringLiteralExpression();\n\nprivate:\n  ExprResult ParseStringLiteralExpression(bool AllowUserDefinedLiteral,\n                                          bool Unevaluated);\n\n  ExprResult ParseExpressionWithLeadingAt(SourceLocation AtLoc);\n\n  ExprResult ParseExpressionWithLeadingExtension(SourceLocation ExtLoc);\n\n  ExprResult ParseRHSOfBinaryExpression(ExprResult LHS,\n                                        prec::Level MinPrec);\n  /// Control what ParseCastExpression will parse.\n  enum CastParseKind {\n    AnyCastExpr = 0,\n    UnaryExprOnly,\n    PrimaryExprOnly\n  };\n  ExprResult ParseCastExpression(CastParseKind ParseKind,\n                                 bool isAddressOfOperand,\n                                 bool &NotCastExpr,\n                                 TypeCastState isTypeCast,\n                                 bool isVectorLiteral = false,\n                                 bool *NotPrimaryExpression = nullptr);\n  ExprResult ParseCastExpression(CastParseKind ParseKind,\n                                 bool isAddressOfOperand = false,\n                                 TypeCastState isTypeCast = NotTypeCast,\n                                 bool isVectorLiteral = false,\n                                 bool *NotPrimaryExpression = nullptr);\n\n  /// Returns true if the next token cannot start an expression.\n  bool isNotExpressionStart();\n\n  /// Returns true if the next token would start a postfix-expression\n  /// suffix.\n  bool isPostfixExpressionSuffixStart() {\n    tok::TokenKind K = Tok.getKind();\n    return (K == tok::l_square || K == tok::l_paren ||\n            K == tok::period || K == tok::arrow ||\n            K == tok::plusplus || K == tok::minusminus);\n  }\n\n  bool diagnoseUnknownTemplateId(ExprResult TemplateName, SourceLocation Less);\n  void checkPotentialAngleBracket(ExprResult &PotentialTemplateName);\n  bool checkPotentialAngleBracketDelimiter(const AngleBracketTracker::Loc &,\n                                           const Token &OpToken);\n  bool checkPotentialAngleBracketDelimiter(const Token &OpToken) {\n    if (auto *Info = AngleBrackets.getCurrent(*this))\n      return checkPotentialAngleBracketDelimiter(*Info, OpToken);\n    return false;\n  }\n\n  ExprResult ParsePostfixExpressionSuffix(ExprResult LHS);\n  ExprResult ParseUnaryExprOrTypeTraitExpression();\n  ExprResult ParseBuiltinPrimaryExpression();\n  ExprResult ParseSYCLUniqueStableNameExpression();\n\n  ExprResult ParseExprAfterUnaryExprOrTypeTrait(const Token &OpTok,\n                                                     bool &isCastExpr,\n                                                     ParsedType &CastTy,\n                                                     SourceRange &CastRange);\n\n  /// ParseExpressionList - Used for C/C++ (argument-)expression-list.\n  bool ParseExpressionList(SmallVectorImpl<Expr *> &Exprs,\n                           llvm::function_ref<void()> ExpressionStarts =\n                               llvm::function_ref<void()>(),\n                           bool FailImmediatelyOnInvalidExpr = false,\n                           bool EarlyTypoCorrection = false);\n\n  /// ParseSimpleExpressionList - A simple comma-separated list of expressions,\n  /// used for misc language extensions.\n  bool ParseSimpleExpressionList(SmallVectorImpl<Expr *> &Exprs);\n\n  /// ParenParseOption - Control what ParseParenExpression will parse.\n  enum ParenParseOption {\n    SimpleExpr,      // Only parse '(' expression ')'\n    FoldExpr,        // Also allow fold-expression <anything>\n    CompoundStmt,    // Also allow '(' compound-statement ')'\n    CompoundLiteral, // Also allow '(' type-name ')' '{' ... '}'\n    CastExpr         // Also allow '(' type-name ')' <anything>\n  };\n  ExprResult ParseParenExpression(ParenParseOption &ExprType,\n                                        bool stopIfCastExpr,\n                                        bool isTypeCast,\n                                        ParsedType &CastTy,\n                                        SourceLocation &RParenLoc);\n\n  ExprResult ParseCXXAmbiguousParenExpression(\n      ParenParseOption &ExprType, ParsedType &CastTy,\n      BalancedDelimiterTracker &Tracker, ColonProtectionRAIIObject &ColonProt);\n  ExprResult ParseCompoundLiteralExpression(ParsedType Ty,\n                                                  SourceLocation LParenLoc,\n                                                  SourceLocation RParenLoc);\n\n  ExprResult ParseGenericSelectionExpression();\n\n  ExprResult ParseObjCBoolLiteral();\n\n  ExprResult ParseFoldExpression(ExprResult LHS, BalancedDelimiterTracker &T);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Expressions\n  ExprResult tryParseCXXIdExpression(CXXScopeSpec &SS, bool isAddressOfOperand,\n                                     Token &Replacement);\n  ExprResult ParseCXXIdExpression(bool isAddressOfOperand = false);\n\n  bool areTokensAdjacent(const Token &A, const Token &B);\n\n  void CheckForTemplateAndDigraph(Token &Next, ParsedType ObjectTypePtr,\n                                  bool EnteringContext, IdentifierInfo &II,\n                                  CXXScopeSpec &SS);\n\n  bool ParseOptionalCXXScopeSpecifier(CXXScopeSpec &SS,\n                                      ParsedType ObjectType,\n                                      bool ObjectHasErrors,\n                                      bool EnteringContext,\n                                      bool *MayBePseudoDestructor = nullptr,\n                                      bool IsTypename = false,\n                                      IdentifierInfo **LastII = nullptr,\n                                      bool OnlyNamespace = false,\n                                      bool InUsingDeclaration = false);\n\n  //===--------------------------------------------------------------------===//\n  // C++11 5.1.2: Lambda expressions\n\n  /// Result of tentatively parsing a lambda-introducer.\n  enum class LambdaIntroducerTentativeParse {\n    /// This appears to be a lambda-introducer, which has been fully parsed.\n    Success,\n    /// This is a lambda-introducer, but has not been fully parsed, and this\n    /// function needs to be called again to parse it.\n    Incomplete,\n    /// This is definitely an Objective-C message send expression, rather than\n    /// a lambda-introducer, attribute-specifier, or array designator.\n    MessageSend,\n    /// This is not a lambda-introducer.\n    Invalid,\n  };\n\n  // [...] () -> type {...}\n  ExprResult ParseLambdaExpression();\n  ExprResult TryParseLambdaExpression();\n  bool\n  ParseLambdaIntroducer(LambdaIntroducer &Intro,\n                        LambdaIntroducerTentativeParse *Tentative = nullptr);\n  ExprResult ParseLambdaExpressionAfterIntroducer(LambdaIntroducer &Intro);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 5.2p1: C++ Casts\n  ExprResult ParseCXXCasts();\n\n  /// Parse a __builtin_bit_cast(T, E), used to implement C++2a std::bit_cast.\n  ExprResult ParseBuiltinBitCast();\n\n  //===--------------------------------------------------------------------===//\n  // C++ 5.2p1: C++ Type Identification\n  ExprResult ParseCXXTypeid();\n\n  //===--------------------------------------------------------------------===//\n  //  C++ : Microsoft __uuidof Expression\n  ExprResult ParseCXXUuidof();\n\n  //===--------------------------------------------------------------------===//\n  // C++ 5.2.4: C++ Pseudo-Destructor Expressions\n  ExprResult ParseCXXPseudoDestructor(Expr *Base, SourceLocation OpLoc,\n                                            tok::TokenKind OpKind,\n                                            CXXScopeSpec &SS,\n                                            ParsedType ObjectType);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 9.3.2: C++ 'this' pointer\n  ExprResult ParseCXXThis();\n\n  //===--------------------------------------------------------------------===//\n  // C++ 15: C++ Throw Expression\n  ExprResult ParseThrowExpression();\n\n  ExceptionSpecificationType tryParseExceptionSpecification(\n                    bool Delayed,\n                    SourceRange &SpecificationRange,\n                    SmallVectorImpl<ParsedType> &DynamicExceptions,\n                    SmallVectorImpl<SourceRange> &DynamicExceptionRanges,\n                    ExprResult &NoexceptExpr,\n                    CachedTokens *&ExceptionSpecTokens);\n\n  // EndLoc is filled with the location of the last token of the specification.\n  ExceptionSpecificationType ParseDynamicExceptionSpecification(\n                                  SourceRange &SpecificationRange,\n                                  SmallVectorImpl<ParsedType> &Exceptions,\n                                  SmallVectorImpl<SourceRange> &Ranges);\n\n  //===--------------------------------------------------------------------===//\n  // C++0x 8: Function declaration trailing-return-type\n  TypeResult ParseTrailingReturnType(SourceRange &Range,\n                                     bool MayBeFollowedByDirectInit);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 2.13.5: C++ Boolean Literals\n  ExprResult ParseCXXBoolLiteral();\n\n  //===--------------------------------------------------------------------===//\n  // C++ 5.2.3: Explicit type conversion (functional notation)\n  ExprResult ParseCXXTypeConstructExpression(const DeclSpec &DS);\n\n  /// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.\n  /// This should only be called when the current token is known to be part of\n  /// simple-type-specifier.\n  void ParseCXXSimpleTypeSpecifier(DeclSpec &DS);\n\n  bool ParseCXXTypeSpecifierSeq(\n      DeclSpec &DS, DeclaratorContext Context = DeclaratorContext::TypeName);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 5.3.4 and 5.3.5: C++ new and delete\n  bool ParseExpressionListOrTypeId(SmallVectorImpl<Expr*> &Exprs,\n                                   Declarator &D);\n  void ParseDirectNewDeclarator(Declarator &D);\n  ExprResult ParseCXXNewExpression(bool UseGlobal, SourceLocation Start);\n  ExprResult ParseCXXDeleteExpression(bool UseGlobal,\n                                            SourceLocation Start);\n\n  //===--------------------------------------------------------------------===//\n  // C++ if/switch/while/for condition expression.\n  struct ForRangeInfo;\n  Sema::ConditionResult ParseCXXCondition(StmtResult *InitStmt,\n                                          SourceLocation Loc,\n                                          Sema::ConditionKind CK,\n                                          bool MissingOK,\n                                          ForRangeInfo *FRI = nullptr,\n                                          bool EnterForConditionScope = false);\n  DeclGroupPtrTy ParseAliasDeclarationInInitStatement(DeclaratorContext Context,\n                                                      ParsedAttributes &Attrs);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Coroutines\n\n  ExprResult ParseCoyieldExpression();\n\n  //===--------------------------------------------------------------------===//\n  // C++ Concepts\n\n  ExprResult ParseRequiresExpression();\n  void ParseTrailingRequiresClause(Declarator &D);\n\n  //===--------------------------------------------------------------------===//\n  // C99 6.7.8: Initialization.\n\n  /// ParseInitializer\n  ///       initializer: [C99 6.7.8]\n  ///         assignment-expression\n  ///         '{' ...\n  ExprResult ParseInitializer() {\n    if (Tok.isNot(tok::l_brace))\n      return ParseAssignmentExpression();\n    return ParseBraceInitializer();\n  }\n  bool MayBeDesignationStart();\n  ExprResult ParseBraceInitializer();\n  struct DesignatorCompletionInfo {\n    SmallVectorImpl<Expr *> &InitExprs;\n    QualType PreferredBaseType;\n  };\n  ExprResult ParseInitializerWithPotentialDesignator(DesignatorCompletionInfo);\n\n  //===--------------------------------------------------------------------===//\n  // clang Expressions\n\n  ExprResult ParseBlockLiteralExpression();  // ^{...}\n\n  //===--------------------------------------------------------------------===//\n  // Objective-C Expressions\n  ExprResult ParseObjCAtExpression(SourceLocation AtLocation);\n  ExprResult ParseObjCStringLiteral(SourceLocation AtLoc);\n  ExprResult ParseObjCCharacterLiteral(SourceLocation AtLoc);\n  ExprResult ParseObjCNumericLiteral(SourceLocation AtLoc);\n  ExprResult ParseObjCBooleanLiteral(SourceLocation AtLoc, bool ArgValue);\n  ExprResult ParseObjCArrayLiteral(SourceLocation AtLoc);\n  ExprResult ParseObjCDictionaryLiteral(SourceLocation AtLoc);\n  ExprResult ParseObjCBoxedExpr(SourceLocation AtLoc);\n  ExprResult ParseObjCEncodeExpression(SourceLocation AtLoc);\n  ExprResult ParseObjCSelectorExpression(SourceLocation AtLoc);\n  ExprResult ParseObjCProtocolExpression(SourceLocation AtLoc);\n  bool isSimpleObjCMessageExpression();\n  ExprResult ParseObjCMessageExpression();\n  ExprResult ParseObjCMessageExpressionBody(SourceLocation LBracloc,\n                                            SourceLocation SuperLoc,\n                                            ParsedType ReceiverType,\n                                            Expr *ReceiverExpr);\n  ExprResult ParseAssignmentExprWithObjCMessageExprStart(\n      SourceLocation LBracloc, SourceLocation SuperLoc,\n      ParsedType ReceiverType, Expr *ReceiverExpr);\n  bool ParseObjCXXMessageReceiver(bool &IsExpr, void *&TypeOrExpr);\n\n  //===--------------------------------------------------------------------===//\n  // C99 6.8: Statements and Blocks.\n\n  /// A SmallVector of expressions.\n  typedef SmallVector<Expr*, 12> ExprVector;\n\n  StmtResult\n  ParseStatement(SourceLocation *TrailingElseLoc = nullptr,\n                 ParsedStmtContext StmtCtx = ParsedStmtContext::SubStmt);\n  StmtResult ParseStatementOrDeclaration(\n      StmtVector &Stmts, ParsedStmtContext StmtCtx,\n      SourceLocation *TrailingElseLoc = nullptr);\n  StmtResult ParseStatementOrDeclarationAfterAttributes(\n      StmtVector &Stmts, ParsedStmtContext StmtCtx,\n      SourceLocation *TrailingElseLoc, ParsedAttributes &DeclAttrs,\n      ParsedAttributes &DeclSpecAttrs);\n  StmtResult ParseExprStatement(ParsedStmtContext StmtCtx);\n  StmtResult ParseLabeledStatement(ParsedAttributes &Attrs,\n                                   ParsedStmtContext StmtCtx);\n  StmtResult ParseCaseStatement(ParsedStmtContext StmtCtx,\n                                bool MissingCase = false,\n                                ExprResult Expr = ExprResult());\n  StmtResult ParseDefaultStatement(ParsedStmtContext StmtCtx);\n  StmtResult ParseCompoundStatement(bool isStmtExpr = false);\n  StmtResult ParseCompoundStatement(bool isStmtExpr,\n                                    unsigned ScopeFlags);\n  void ParseCompoundStatementLeadingPragmas();\n  void DiagnoseLabelAtEndOfCompoundStatement();\n  bool ConsumeNullStmt(StmtVector &Stmts);\n  StmtResult ParseCompoundStatementBody(bool isStmtExpr = false);\n  bool ParseParenExprOrCondition(StmtResult *InitStmt,\n                                 Sema::ConditionResult &CondResult,\n                                 SourceLocation Loc, Sema::ConditionKind CK,\n                                 SourceLocation &LParenLoc,\n                                 SourceLocation &RParenLoc);\n  StmtResult ParseIfStatement(SourceLocation *TrailingElseLoc);\n  StmtResult ParseSwitchStatement(SourceLocation *TrailingElseLoc);\n  StmtResult ParseWhileStatement(SourceLocation *TrailingElseLoc);\n  StmtResult ParseDoStatement();\n  StmtResult ParseForStatement(SourceLocation *TrailingElseLoc);\n  StmtResult ParseGotoStatement();\n  StmtResult ParseContinueStatement();\n  StmtResult ParseBreakStatement();\n  StmtResult ParseReturnStatement();\n  StmtResult ParseAsmStatement(bool &msAsm);\n  StmtResult ParseMicrosoftAsmStatement(SourceLocation AsmLoc);\n  StmtResult ParsePragmaLoopHint(StmtVector &Stmts, ParsedStmtContext StmtCtx,\n                                 SourceLocation *TrailingElseLoc,\n                                 ParsedAttributes &Attrs);\n\n  /// Describes the behavior that should be taken for an __if_exists\n  /// block.\n  enum IfExistsBehavior {\n    /// Parse the block; this code is always used.\n    IEB_Parse,\n    /// Skip the block entirely; this code is never used.\n    IEB_Skip,\n    /// Parse the block as a dependent block, which may be used in\n    /// some template instantiations but not others.\n    IEB_Dependent\n  };\n\n  /// Describes the condition of a Microsoft __if_exists or\n  /// __if_not_exists block.\n  struct IfExistsCondition {\n    /// The location of the initial keyword.\n    SourceLocation KeywordLoc;\n    /// Whether this is an __if_exists block (rather than an\n    /// __if_not_exists block).\n    bool IsIfExists;\n\n    /// Nested-name-specifier preceding the name.\n    CXXScopeSpec SS;\n\n    /// The name we're looking for.\n    UnqualifiedId Name;\n\n    /// The behavior of this __if_exists or __if_not_exists block\n    /// should.\n    IfExistsBehavior Behavior;\n  };\n\n  bool ParseMicrosoftIfExistsCondition(IfExistsCondition& Result);\n  void ParseMicrosoftIfExistsStatement(StmtVector &Stmts);\n  void ParseMicrosoftIfExistsExternalDeclaration();\n  void ParseMicrosoftIfExistsClassDeclaration(DeclSpec::TST TagType,\n                                              ParsedAttributes &AccessAttrs,\n                                              AccessSpecifier &CurAS);\n  bool ParseMicrosoftIfExistsBraceInitializer(ExprVector &InitExprs,\n                                              bool &InitExprsOk);\n  bool ParseAsmOperandsOpt(SmallVectorImpl<IdentifierInfo *> &Names,\n                           SmallVectorImpl<Expr *> &Constraints,\n                           SmallVectorImpl<Expr *> &Exprs);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 6: Statements and Blocks\n\n  StmtResult ParseCXXTryBlock();\n  StmtResult ParseCXXTryBlockCommon(SourceLocation TryLoc, bool FnTry = false);\n  StmtResult ParseCXXCatchBlock(bool FnCatch = false);\n\n  //===--------------------------------------------------------------------===//\n  // MS: SEH Statements and Blocks\n\n  StmtResult ParseSEHTryBlock();\n  StmtResult ParseSEHExceptBlock(SourceLocation Loc);\n  StmtResult ParseSEHFinallyBlock(SourceLocation Loc);\n  StmtResult ParseSEHLeaveStatement();\n\n  //===--------------------------------------------------------------------===//\n  // Objective-C Statements\n\n  StmtResult ParseObjCAtStatement(SourceLocation atLoc,\n                                  ParsedStmtContext StmtCtx);\n  StmtResult ParseObjCTryStmt(SourceLocation atLoc);\n  StmtResult ParseObjCThrowStmt(SourceLocation atLoc);\n  StmtResult ParseObjCSynchronizedStmt(SourceLocation atLoc);\n  StmtResult ParseObjCAutoreleasePoolStmt(SourceLocation atLoc);\n\n\n  //===--------------------------------------------------------------------===//\n  // C99 6.7: Declarations.\n\n  /// A context for parsing declaration specifiers.  TODO: flesh this\n  /// out, there are other significant restrictions on specifiers than\n  /// would be best implemented in the parser.\n  enum class DeclSpecContext {\n    DSC_normal,         // normal context\n    DSC_class,          // class context, enables 'friend'\n    DSC_type_specifier, // C++ type-specifier-seq or C specifier-qualifier-list\n    DSC_trailing, // C++11 trailing-type-specifier in a trailing return type\n    DSC_alias_declaration,  // C++11 type-specifier-seq in an alias-declaration\n    DSC_conv_operator,      // C++ type-specifier-seq in an conversion operator\n    DSC_top_level,          // top-level/namespace declaration context\n    DSC_template_param,     // template parameter context\n    DSC_template_arg,       // template argument context\n    DSC_template_type_arg,  // template type argument context\n    DSC_objc_method_result, // ObjC method result context, enables\n                            // 'instancetype'\n    DSC_condition,          // condition declaration context\n    DSC_association, // A _Generic selection expression's type association\n    DSC_new,         // C++ new expression\n  };\n\n  /// Is this a context in which we are parsing just a type-specifier (or\n  /// trailing-type-specifier)?\n  static bool isTypeSpecifier(DeclSpecContext DSC) {\n    switch (DSC) {\n    case DeclSpecContext::DSC_normal:\n    case DeclSpecContext::DSC_template_param:\n    case DeclSpecContext::DSC_template_arg:\n    case DeclSpecContext::DSC_class:\n    case DeclSpecContext::DSC_top_level:\n    case DeclSpecContext::DSC_objc_method_result:\n    case DeclSpecContext::DSC_condition:\n      return false;\n\n    case DeclSpecContext::DSC_template_type_arg:\n    case DeclSpecContext::DSC_type_specifier:\n    case DeclSpecContext::DSC_conv_operator:\n    case DeclSpecContext::DSC_trailing:\n    case DeclSpecContext::DSC_alias_declaration:\n    case DeclSpecContext::DSC_association:\n    case DeclSpecContext::DSC_new:\n      return true;\n    }\n    llvm_unreachable(\"Missing DeclSpecContext case\");\n  }\n\n  /// Whether a defining-type-specifier is permitted in a given context.\n  enum class AllowDefiningTypeSpec {\n    /// The grammar doesn't allow a defining-type-specifier here, and we must\n    /// not parse one (eg, because a '{' could mean something else).\n    No,\n    /// The grammar doesn't allow a defining-type-specifier here, but we permit\n    /// one for error recovery purposes. Sema will reject.\n    NoButErrorRecovery,\n    /// The grammar allows a defining-type-specifier here, even though it's\n    /// always invalid. Sema will reject.\n    YesButInvalid,\n    /// The grammar allows a defining-type-specifier here, and one can be valid.\n    Yes\n  };\n\n  /// Is this a context in which we are parsing defining-type-specifiers (and\n  /// so permit class and enum definitions in addition to non-defining class and\n  /// enum elaborated-type-specifiers)?\n  static AllowDefiningTypeSpec\n  isDefiningTypeSpecifierContext(DeclSpecContext DSC, bool IsCPlusPlus) {\n    switch (DSC) {\n    case DeclSpecContext::DSC_normal:\n    case DeclSpecContext::DSC_class:\n    case DeclSpecContext::DSC_top_level:\n    case DeclSpecContext::DSC_alias_declaration:\n    case DeclSpecContext::DSC_objc_method_result:\n      return AllowDefiningTypeSpec::Yes;\n\n    case DeclSpecContext::DSC_condition:\n    case DeclSpecContext::DSC_template_param:\n      return AllowDefiningTypeSpec::YesButInvalid;\n\n    case DeclSpecContext::DSC_template_type_arg:\n    case DeclSpecContext::DSC_type_specifier:\n      return AllowDefiningTypeSpec::NoButErrorRecovery;\n\n    case DeclSpecContext::DSC_association:\n      return IsCPlusPlus ? AllowDefiningTypeSpec::NoButErrorRecovery\n                         : AllowDefiningTypeSpec::Yes;\n\n    case DeclSpecContext::DSC_trailing:\n    case DeclSpecContext::DSC_conv_operator:\n    case DeclSpecContext::DSC_template_arg:\n    case DeclSpecContext::DSC_new:\n      return AllowDefiningTypeSpec::No;\n    }\n    llvm_unreachable(\"Missing DeclSpecContext case\");\n  }\n\n  /// Is this a context in which an opaque-enum-declaration can appear?\n  static bool isOpaqueEnumDeclarationContext(DeclSpecContext DSC) {\n    switch (DSC) {\n    case DeclSpecContext::DSC_normal:\n    case DeclSpecContext::DSC_class:\n    case DeclSpecContext::DSC_top_level:\n      return true;\n\n    case DeclSpecContext::DSC_alias_declaration:\n    case DeclSpecContext::DSC_objc_method_result:\n    case DeclSpecContext::DSC_condition:\n    case DeclSpecContext::DSC_template_param:\n    case DeclSpecContext::DSC_template_type_arg:\n    case DeclSpecContext::DSC_type_specifier:\n    case DeclSpecContext::DSC_trailing:\n    case DeclSpecContext::DSC_association:\n    case DeclSpecContext::DSC_conv_operator:\n    case DeclSpecContext::DSC_template_arg:\n    case DeclSpecContext::DSC_new:\n\n      return false;\n    }\n    llvm_unreachable(\"Missing DeclSpecContext case\");\n  }\n\n  /// Is this a context in which we can perform class template argument\n  /// deduction?\n  static bool isClassTemplateDeductionContext(DeclSpecContext DSC) {\n    switch (DSC) {\n    case DeclSpecContext::DSC_normal:\n    case DeclSpecContext::DSC_template_param:\n    case DeclSpecContext::DSC_template_arg:\n    case DeclSpecContext::DSC_class:\n    case DeclSpecContext::DSC_top_level:\n    case DeclSpecContext::DSC_condition:\n    case DeclSpecContext::DSC_type_specifier:\n    case DeclSpecContext::DSC_association:\n    case DeclSpecContext::DSC_conv_operator:\n    case DeclSpecContext::DSC_new:\n      return true;\n\n    case DeclSpecContext::DSC_objc_method_result:\n    case DeclSpecContext::DSC_template_type_arg:\n    case DeclSpecContext::DSC_trailing:\n    case DeclSpecContext::DSC_alias_declaration:\n      return false;\n    }\n    llvm_unreachable(\"Missing DeclSpecContext case\");\n  }\n\n  // Is this a context in which an implicit 'typename' is allowed?\n  static ImplicitTypenameContext\n  getImplicitTypenameContext(DeclSpecContext DSC) {\n    switch (DSC) {\n    case DeclSpecContext::DSC_class:\n    case DeclSpecContext::DSC_top_level:\n    case DeclSpecContext::DSC_type_specifier:\n    case DeclSpecContext::DSC_template_type_arg:\n    case DeclSpecContext::DSC_trailing:\n    case DeclSpecContext::DSC_alias_declaration:\n    case DeclSpecContext::DSC_template_param:\n    case DeclSpecContext::DSC_new:\n      return ImplicitTypenameContext::Yes;\n\n    case DeclSpecContext::DSC_normal:\n    case DeclSpecContext::DSC_objc_method_result:\n    case DeclSpecContext::DSC_condition:\n    case DeclSpecContext::DSC_template_arg:\n    case DeclSpecContext::DSC_conv_operator:\n    case DeclSpecContext::DSC_association:\n      return ImplicitTypenameContext::No;\n    }\n    llvm_unreachable(\"Missing DeclSpecContext case\");\n  }\n\n  /// Information on a C++0x for-range-initializer found while parsing a\n  /// declaration which turns out to be a for-range-declaration.\n  struct ForRangeInit {\n    SourceLocation ColonLoc;\n    ExprResult RangeExpr;\n\n    bool ParsedForRangeDecl() { return !ColonLoc.isInvalid(); }\n  };\n  struct ForRangeInfo : ForRangeInit {\n    StmtResult LoopVar;\n  };\n\n  DeclGroupPtrTy ParseDeclaration(DeclaratorContext Context,\n                                  SourceLocation &DeclEnd,\n                                  ParsedAttributes &DeclAttrs,\n                                  ParsedAttributes &DeclSpecAttrs,\n                                  SourceLocation *DeclSpecStart = nullptr);\n  DeclGroupPtrTy\n  ParseSimpleDeclaration(DeclaratorContext Context, SourceLocation &DeclEnd,\n                         ParsedAttributes &DeclAttrs,\n                         ParsedAttributes &DeclSpecAttrs, bool RequireSemi,\n                         ForRangeInit *FRI = nullptr,\n                         SourceLocation *DeclSpecStart = nullptr);\n  bool MightBeDeclarator(DeclaratorContext Context);\n  DeclGroupPtrTy ParseDeclGroup(ParsingDeclSpec &DS, DeclaratorContext Context,\n                                ParsedAttributes &Attrs,\n                                SourceLocation *DeclEnd = nullptr,\n                                ForRangeInit *FRI = nullptr);\n  Decl *ParseDeclarationAfterDeclarator(Declarator &D,\n               const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo());\n  bool ParseAsmAttributesAfterDeclarator(Declarator &D);\n  Decl *ParseDeclarationAfterDeclaratorAndAttributes(\n      Declarator &D,\n      const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),\n      ForRangeInit *FRI = nullptr);\n  Decl *ParseFunctionStatementBody(Decl *Decl, ParseScope &BodyScope);\n  Decl *ParseFunctionTryBlock(Decl *Decl, ParseScope &BodyScope);\n\n  /// When in code-completion, skip parsing of the function/method body\n  /// unless the body contains the code-completion point.\n  ///\n  /// \\returns true if the function body was skipped.\n  bool trySkippingFunctionBody();\n\n  bool ParseImplicitInt(DeclSpec &DS, CXXScopeSpec *SS,\n                        const ParsedTemplateInfo &TemplateInfo,\n                        AccessSpecifier AS, DeclSpecContext DSC,\n                        ParsedAttributes &Attrs);\n  DeclSpecContext\n  getDeclSpecContextFromDeclaratorContext(DeclaratorContext Context);\n  void ParseDeclarationSpecifiers(\n      DeclSpec &DS,\n      const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),\n      AccessSpecifier AS = AS_none,\n      DeclSpecContext DSC = DeclSpecContext::DSC_normal,\n      LateParsedAttrList *LateAttrs = nullptr) {\n    return ParseDeclarationSpecifiers(DS, TemplateInfo, AS, DSC, LateAttrs,\n                                      getImplicitTypenameContext(DSC));\n  }\n  void ParseDeclarationSpecifiers(\n      DeclSpec &DS, const ParsedTemplateInfo &TemplateInfo, AccessSpecifier AS,\n      DeclSpecContext DSC, LateParsedAttrList *LateAttrs,\n      ImplicitTypenameContext AllowImplicitTypename);\n\n  bool DiagnoseMissingSemiAfterTagDefinition(\n      DeclSpec &DS, AccessSpecifier AS, DeclSpecContext DSContext,\n      LateParsedAttrList *LateAttrs = nullptr);\n\n  void ParseSpecifierQualifierList(\n      DeclSpec &DS, AccessSpecifier AS = AS_none,\n      DeclSpecContext DSC = DeclSpecContext::DSC_normal) {\n    ParseSpecifierQualifierList(DS, getImplicitTypenameContext(DSC), AS, DSC);\n  }\n\n  void ParseSpecifierQualifierList(\n      DeclSpec &DS, ImplicitTypenameContext AllowImplicitTypename,\n      AccessSpecifier AS = AS_none,\n      DeclSpecContext DSC = DeclSpecContext::DSC_normal);\n\n  void ParseObjCTypeQualifierList(ObjCDeclSpec &DS,\n                                  DeclaratorContext Context);\n\n  void ParseEnumSpecifier(SourceLocation TagLoc, DeclSpec &DS,\n                          const ParsedTemplateInfo &TemplateInfo,\n                          AccessSpecifier AS, DeclSpecContext DSC);\n  void ParseEnumBody(SourceLocation StartLoc, Decl *TagDecl);\n  void ParseStructUnionBody(SourceLocation StartLoc, DeclSpec::TST TagType,\n                            RecordDecl *TagDecl);\n\n  void ParseStructDeclaration(\n      ParsingDeclSpec &DS,\n      llvm::function_ref<void(ParsingFieldDeclarator &)> FieldsCallback);\n\n  DeclGroupPtrTy ParseTopLevelStmtDecl();\n\n  bool isDeclarationSpecifier(ImplicitTypenameContext AllowImplicitTypename,\n                              bool DisambiguatingWithExpression = false);\n  bool isTypeSpecifierQualifier();\n\n  /// isKnownToBeTypeSpecifier - Return true if we know that the specified token\n  /// is definitely a type-specifier.  Return false if it isn't part of a type\n  /// specifier or if we're not sure.\n  bool isKnownToBeTypeSpecifier(const Token &Tok) const;\n\n  /// Return true if we know that we are definitely looking at a\n  /// decl-specifier, and isn't part of an expression such as a function-style\n  /// cast. Return false if it's no a decl-specifier, or we're not sure.\n  bool isKnownToBeDeclarationSpecifier() {\n    if (getLangOpts().CPlusPlus)\n      return isCXXDeclarationSpecifier(ImplicitTypenameContext::No) ==\n             TPResult::True;\n    return isDeclarationSpecifier(ImplicitTypenameContext::No, true);\n  }\n\n  /// isDeclarationStatement - Disambiguates between a declaration or an\n  /// expression statement, when parsing function bodies.\n  ///\n  /// \\param DisambiguatingWithExpression - True to indicate that the purpose of\n  /// this check is to disambiguate between an expression and a declaration.\n  /// Returns true for declaration, false for expression.\n  bool isDeclarationStatement(bool DisambiguatingWithExpression = false) {\n    if (getLangOpts().CPlusPlus)\n      return isCXXDeclarationStatement(DisambiguatingWithExpression);\n    return isDeclarationSpecifier(ImplicitTypenameContext::No, true);\n  }\n\n  /// isForInitDeclaration - Disambiguates between a declaration or an\n  /// expression in the context of the C 'clause-1' or the C++\n  // 'for-init-statement' part of a 'for' statement.\n  /// Returns true for declaration, false for expression.\n  bool isForInitDeclaration() {\n    if (getLangOpts().OpenMP)\n      Actions.startOpenMPLoop();\n    if (getLangOpts().CPlusPlus)\n      return Tok.is(tok::kw_using) ||\n             isCXXSimpleDeclaration(/*AllowForRangeDecl=*/true);\n    return isDeclarationSpecifier(ImplicitTypenameContext::No, true);\n  }\n\n  /// Determine whether this is a C++1z for-range-identifier.\n  bool isForRangeIdentifier();\n\n  /// Determine whether we are currently at the start of an Objective-C\n  /// class message that appears to be missing the open bracket '['.\n  bool isStartOfObjCClassMessageMissingOpenBracket();\n\n  /// Starting with a scope specifier, identifier, or\n  /// template-id that refers to the current class, determine whether\n  /// this is a constructor declarator.\n  bool isConstructorDeclarator(\n      bool Unqualified, bool DeductionGuide = false,\n      DeclSpec::FriendSpecified IsFriend = DeclSpec::FriendSpecified::No,\n      const ParsedTemplateInfo *TemplateInfo = nullptr);\n\n  /// Specifies the context in which type-id/expression\n  /// disambiguation will occur.\n  enum TentativeCXXTypeIdContext {\n    TypeIdInParens,\n    TypeIdUnambiguous,\n    TypeIdAsTemplateArgument,\n    TypeIdInTrailingReturnType,\n    TypeIdAsGenericSelectionArgument,\n  };\n\n  /// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know\n  /// whether the parens contain an expression or a type-id.\n  /// Returns true for a type-id and false for an expression.\n  bool isTypeIdInParens(bool &isAmbiguous) {\n    if (getLangOpts().CPlusPlus)\n      return isCXXTypeId(TypeIdInParens, isAmbiguous);\n    isAmbiguous = false;\n    return isTypeSpecifierQualifier();\n  }\n  bool isTypeIdInParens() {\n    bool isAmbiguous;\n    return isTypeIdInParens(isAmbiguous);\n  }\n\n  /// Checks whether the current tokens form a type-id or an expression for the\n  /// purposes of use as the initial operand to a generic selection expression.\n  /// This requires special handling in C++ because it accepts either a type or\n  /// an expression, and we need to disambiguate which is which. However, we\n  /// cannot use the same logic as we've used for sizeof expressions, because\n  /// that logic relies on the operator only accepting a single argument,\n  /// whereas _Generic accepts a list of arguments.\n  bool isTypeIdForGenericSelection() {\n    if (getLangOpts().CPlusPlus) {\n      bool isAmbiguous;\n      return isCXXTypeId(TypeIdAsGenericSelectionArgument, isAmbiguous);\n    }\n    return isTypeSpecifierQualifier();\n  }\n\n  /// Checks if the current tokens form type-id or expression.\n  /// It is similar to isTypeIdInParens but does not suppose that type-id\n  /// is in parenthesis.\n  bool isTypeIdUnambiguously() {\n    if (getLangOpts().CPlusPlus) {\n      bool isAmbiguous;\n      return isCXXTypeId(TypeIdUnambiguous, isAmbiguous);\n    }\n    return isTypeSpecifierQualifier();\n  }\n\n  /// isCXXDeclarationStatement - C++-specialized function that disambiguates\n  /// between a declaration or an expression statement, when parsing function\n  /// bodies. Returns true for declaration, false for expression.\n  bool isCXXDeclarationStatement(bool DisambiguatingWithExpression = false);\n\n  /// isCXXSimpleDeclaration - C++-specialized function that disambiguates\n  /// between a simple-declaration or an expression-statement.\n  /// If during the disambiguation process a parsing error is encountered,\n  /// the function returns true to let the declaration parsing code handle it.\n  /// Returns false if the statement is disambiguated as expression.\n  bool isCXXSimpleDeclaration(bool AllowForRangeDecl);\n\n  /// isCXXFunctionDeclarator - Disambiguates between a function declarator or\n  /// a constructor-style initializer, when parsing declaration statements.\n  /// Returns true for function declarator and false for constructor-style\n  /// initializer. Sets 'IsAmbiguous' to true to indicate that this declaration\n  /// might be a constructor-style initializer.\n  /// If during the disambiguation process a parsing error is encountered,\n  /// the function returns true to let the declaration parsing code handle it.\n  bool isCXXFunctionDeclarator(bool *IsAmbiguous = nullptr,\n                               ImplicitTypenameContext AllowImplicitTypename =\n                                   ImplicitTypenameContext::No);\n\n  struct ConditionDeclarationOrInitStatementState;\n  enum class ConditionOrInitStatement {\n    Expression,    ///< Disambiguated as an expression (either kind).\n    ConditionDecl, ///< Disambiguated as the declaration form of condition.\n    InitStmtDecl,  ///< Disambiguated as a simple-declaration init-statement.\n    ForRangeDecl,  ///< Disambiguated as a for-range declaration.\n    Error          ///< Can't be any of the above!\n  };\n  /// Disambiguates between the different kinds of things that can happen\n  /// after 'if (' or 'switch ('. This could be one of two different kinds of\n  /// declaration (depending on whether there is a ';' later) or an expression.\n  ConditionOrInitStatement\n  isCXXConditionDeclarationOrInitStatement(bool CanBeInitStmt,\n                                           bool CanBeForRangeDecl);\n\n  bool isCXXTypeId(TentativeCXXTypeIdContext Context, bool &isAmbiguous);\n  bool isCXXTypeId(TentativeCXXTypeIdContext Context) {\n    bool isAmbiguous;\n    return isCXXTypeId(Context, isAmbiguous);\n  }\n\n  /// TPResult - Used as the result value for functions whose purpose is to\n  /// disambiguate C++ constructs by \"tentatively parsing\" them.\n  enum class TPResult {\n    True, False, Ambiguous, Error\n  };\n\n  /// Determine whether we could have an enum-base.\n  ///\n  /// \\p AllowSemi If \\c true, then allow a ';' after the enum-base; otherwise\n  /// only consider this to be an enum-base if the next token is a '{'.\n  ///\n  /// \\return \\c false if this cannot possibly be an enum base; \\c true\n  /// otherwise.\n  bool isEnumBase(bool AllowSemi);\n\n  /// isCXXDeclarationSpecifier - Returns TPResult::True if it is a\n  /// declaration specifier, TPResult::False if it is not,\n  /// TPResult::Ambiguous if it could be either a decl-specifier or a\n  /// function-style cast, and TPResult::Error if a parsing error was\n  /// encountered. If it could be a braced C++11 function-style cast, returns\n  /// BracedCastResult.\n  /// Doesn't consume tokens.\n  TPResult\n  isCXXDeclarationSpecifier(ImplicitTypenameContext AllowImplicitTypename,\n                            TPResult BracedCastResult = TPResult::False,\n                            bool *InvalidAsDeclSpec = nullptr);\n\n  /// Given that isCXXDeclarationSpecifier returns \\c TPResult::True or\n  /// \\c TPResult::Ambiguous, determine whether the decl-specifier would be\n  /// a type-specifier other than a cv-qualifier.\n  bool isCXXDeclarationSpecifierAType();\n\n  /// Determine whether the current token sequence might be\n  ///   '<' template-argument-list '>'\n  /// rather than a less-than expression.\n  TPResult isTemplateArgumentList(unsigned TokensToSkip);\n\n  /// Determine whether an '(' after an 'explicit' keyword is part of a C++20\n  /// 'explicit(bool)' declaration, in earlier language modes where that is an\n  /// extension.\n  TPResult isExplicitBool();\n\n  /// Determine whether an identifier has been tentatively declared as a\n  /// non-type. Such tentative declarations should not be found to name a type\n  /// during a tentative parse, but also should not be annotated as a non-type.\n  bool isTentativelyDeclared(IdentifierInfo *II);\n\n  // \"Tentative parsing\" functions, used for disambiguation. If a parsing error\n  // is encountered they will return TPResult::Error.\n  // Returning TPResult::True/False indicates that the ambiguity was\n  // resolved and tentative parsing may stop. TPResult::Ambiguous indicates\n  // that more tentative parsing is necessary for disambiguation.\n  // They all consume tokens, so backtracking should be used after calling them.\n\n  TPResult TryParseSimpleDeclaration(bool AllowForRangeDecl);\n  TPResult TryParseTypeofSpecifier();\n  TPResult TryParseProtocolQualifiers();\n  TPResult TryParsePtrOperatorSeq();\n  TPResult TryParseOperatorId();\n  TPResult TryParseInitDeclaratorList(bool MayHaveTrailingReturnType = false);\n  TPResult TryParseDeclarator(bool mayBeAbstract, bool mayHaveIdentifier = true,\n                              bool mayHaveDirectInit = false,\n                              bool mayHaveTrailingReturnType = false);\n  TPResult TryParseParameterDeclarationClause(\n      bool *InvalidAsDeclaration = nullptr, bool VersusTemplateArg = false,\n      ImplicitTypenameContext AllowImplicitTypename =\n          ImplicitTypenameContext::No);\n  TPResult TryParseFunctionDeclarator(bool MayHaveTrailingReturnType = false);\n  bool NameAfterArrowIsNonType();\n  TPResult TryParseBracketDeclarator();\n  TPResult TryConsumeDeclarationSpecifier();\n\n  /// Try to skip a possibly empty sequence of 'attribute-specifier's without\n  /// full validation of the syntactic structure of attributes.\n  bool TrySkipAttributes();\n\n  /// Diagnoses use of _ExtInt as being deprecated, and diagnoses use of\n  /// _BitInt as an extension when appropriate.\n  void DiagnoseBitIntUse(const Token &Tok);\n\npublic:\n  TypeResult\n  ParseTypeName(SourceRange *Range = nullptr,\n                DeclaratorContext Context = DeclaratorContext::TypeName,\n                AccessSpecifier AS = AS_none, Decl **OwnedType = nullptr,\n                ParsedAttributes *Attrs = nullptr);\n\nprivate:\n  void ParseBlockId(SourceLocation CaretLoc);\n\n  /// Return true if the next token should be treated as a [[]] attribute,\n  /// or as a keyword that behaves like one.  The former is only true if\n  /// [[]] attributes are enabled, whereas the latter is true whenever\n  /// such a keyword appears.  The arguments are as for\n  /// isCXX11AttributeSpecifier.\n  bool isAllowedCXX11AttributeSpecifier(bool Disambiguate = false,\n                                        bool OuterMightBeMessageSend = false) {\n    return (Tok.isRegularKeywordAttribute() ||\n            isCXX11AttributeSpecifier(Disambiguate, OuterMightBeMessageSend));\n  }\n\n  // Check for the start of an attribute-specifier-seq in a context where an\n  // attribute is not allowed.\n  bool CheckProhibitedCXX11Attribute() {\n    assert(Tok.is(tok::l_square));\n    if (NextToken().isNot(tok::l_square))\n      return false;\n    return DiagnoseProhibitedCXX11Attribute();\n  }\n\n  bool DiagnoseProhibitedCXX11Attribute();\n  void CheckMisplacedCXX11Attribute(ParsedAttributes &Attrs,\n                                    SourceLocation CorrectLocation) {\n    if (!Tok.isRegularKeywordAttribute() &&\n        (Tok.isNot(tok::l_square) || NextToken().isNot(tok::l_square)) &&\n        Tok.isNot(tok::kw_alignas))\n      return;\n    DiagnoseMisplacedCXX11Attribute(Attrs, CorrectLocation);\n  }\n  void DiagnoseMisplacedCXX11Attribute(ParsedAttributes &Attrs,\n                                       SourceLocation CorrectLocation);\n\n  void stripTypeAttributesOffDeclSpec(ParsedAttributes &Attrs, DeclSpec &DS,\n                                      Sema::TagUseKind TUK);\n\n  // FixItLoc = possible correct location for the attributes\n  void ProhibitAttributes(ParsedAttributes &Attrs,\n                          SourceLocation FixItLoc = SourceLocation()) {\n    if (Attrs.Range.isInvalid())\n      return;\n    DiagnoseProhibitedAttributes(Attrs, FixItLoc);\n    Attrs.clear();\n  }\n\n  void ProhibitAttributes(ParsedAttributesView &Attrs,\n                          SourceLocation FixItLoc = SourceLocation()) {\n    if (Attrs.Range.isInvalid())\n      return;\n    DiagnoseProhibitedAttributes(Attrs, FixItLoc);\n    Attrs.clearListOnly();\n  }\n  void DiagnoseProhibitedAttributes(const ParsedAttributesView &Attrs,\n                                    SourceLocation FixItLoc);\n\n  // Forbid C++11 and C2x attributes that appear on certain syntactic locations\n  // which standard permits but we don't supported yet, for example, attributes\n  // appertain to decl specifiers.\n  // For the most cases we don't want to warn on unknown type attributes, but\n  // left them to later diagnoses. However, for a few cases like module\n  // declarations and module import declarations, we should do it.\n  void ProhibitCXX11Attributes(ParsedAttributes &Attrs, unsigned AttrDiagID,\n                               unsigned KeywordDiagId,\n                               bool DiagnoseEmptyAttrs = false,\n                               bool WarnOnUnknownAttrs = false);\n\n  /// Skip C++11 and C2x attributes and return the end location of the\n  /// last one.\n  /// \\returns SourceLocation() if there are no attributes.\n  SourceLocation SkipCXX11Attributes();\n\n  /// Diagnose and skip C++11 and C2x attributes that appear in syntactic\n  /// locations where attributes are not allowed.\n  void DiagnoseAndSkipCXX11Attributes();\n\n  /// Emit warnings for C++11 and C2x attributes that are in a position that\n  /// clang accepts as an extension.\n  void DiagnoseCXX11AttributeExtension(ParsedAttributes &Attrs);\n\n  /// Parses syntax-generic attribute arguments for attributes which are\n  /// known to the implementation, and adds them to the given ParsedAttributes\n  /// list with the given attribute syntax. Returns the number of arguments\n  /// parsed for the attribute.\n  unsigned\n  ParseAttributeArgsCommon(IdentifierInfo *AttrName, SourceLocation AttrNameLoc,\n                           ParsedAttributes &Attrs, SourceLocation *EndLoc,\n                           IdentifierInfo *ScopeName, SourceLocation ScopeLoc,\n                           ParsedAttr::Form Form);\n\n  enum ParseAttrKindMask {\n    PAKM_GNU = 1 << 0,\n    PAKM_Declspec = 1 << 1,\n    PAKM_CXX11 = 1 << 2,\n  };\n\n  /// \\brief Parse attributes based on what syntaxes are desired, allowing for\n  /// the order to vary. e.g. with PAKM_GNU | PAKM_Declspec:\n  /// __attribute__((...)) __declspec(...) __attribute__((...)))\n  /// Note that Microsoft attributes (spelled with single square brackets) are\n  /// not supported by this because of parsing ambiguities with other\n  /// constructs.\n  ///\n  /// There are some attribute parse orderings that should not be allowed in\n  /// arbitrary order. e.g.,\n  ///\n  ///   [[]] __attribute__(()) int i; // OK\n  ///   __attribute__(()) [[]] int i; // Not OK\n  ///\n  /// Such situations should use the specific attribute parsing functionality.\n  void ParseAttributes(unsigned WhichAttrKinds, ParsedAttributes &Attrs,\n                       LateParsedAttrList *LateAttrs = nullptr);\n  /// \\brief Possibly parse attributes based on what syntaxes are desired,\n  /// allowing for the order to vary.\n  bool MaybeParseAttributes(unsigned WhichAttrKinds, ParsedAttributes &Attrs,\n                            LateParsedAttrList *LateAttrs = nullptr) {\n    if (Tok.isOneOf(tok::kw___attribute, tok::kw___declspec) ||\n        isAllowedCXX11AttributeSpecifier()) {\n      ParseAttributes(WhichAttrKinds, Attrs, LateAttrs);\n      return true;\n    }\n    return false;\n  }\n\n  void MaybeParseGNUAttributes(Declarator &D,\n                               LateParsedAttrList *LateAttrs = nullptr) {\n    if (Tok.is(tok::kw___attribute)) {\n      ParsedAttributes Attrs(AttrFactory);\n      ParseGNUAttributes(Attrs, LateAttrs, &D);\n      D.takeAttributes(Attrs);\n    }\n  }\n\n  bool MaybeParseGNUAttributes(ParsedAttributes &Attrs,\n                               LateParsedAttrList *LateAttrs = nullptr) {\n    if (Tok.is(tok::kw___attribute)) {\n      ParseGNUAttributes(Attrs, LateAttrs);\n      return true;\n    }\n    return false;\n  }\n\n  void ParseGNUAttributes(ParsedAttributes &Attrs,\n                          LateParsedAttrList *LateAttrs = nullptr,\n                          Declarator *D = nullptr);\n  void ParseGNUAttributeArgs(IdentifierInfo *AttrName,\n                             SourceLocation AttrNameLoc,\n                             ParsedAttributes &Attrs, SourceLocation *EndLoc,\n                             IdentifierInfo *ScopeName, SourceLocation ScopeLoc,\n                             ParsedAttr::Form Form, Declarator *D);\n  IdentifierLoc *ParseIdentifierLoc();\n\n  unsigned\n  ParseClangAttributeArgs(IdentifierInfo *AttrName, SourceLocation AttrNameLoc,\n                          ParsedAttributes &Attrs, SourceLocation *EndLoc,\n                          IdentifierInfo *ScopeName, SourceLocation ScopeLoc,\n                          ParsedAttr::Form Form);\n\n  void ReplayOpenMPAttributeTokens(CachedTokens &OpenMPTokens) {\n    // If parsing the attributes found an OpenMP directive, emit those tokens\n    // to the parse stream now.\n    if (!OpenMPTokens.empty()) {\n      PP.EnterToken(Tok, /*IsReinject*/ true);\n      PP.EnterTokenStream(OpenMPTokens, /*DisableMacroExpansion*/ true,\n                          /*IsReinject*/ true);\n      ConsumeAnyToken(/*ConsumeCodeCompletionTok*/ true);\n    }\n  }\n  void MaybeParseCXX11Attributes(Declarator &D) {\n    if (isAllowedCXX11AttributeSpecifier()) {\n      ParsedAttributes Attrs(AttrFactory);\n      ParseCXX11Attributes(Attrs);\n      D.takeAttributes(Attrs);\n    }\n  }\n\n  bool MaybeParseCXX11Attributes(ParsedAttributes &Attrs,\n                                 bool OuterMightBeMessageSend = false) {\n    if (isAllowedCXX11AttributeSpecifier(false, OuterMightBeMessageSend)) {\n      ParseCXX11Attributes(Attrs);\n      return true;\n    }\n    return false;\n  }\n\n  void ParseOpenMPAttributeArgs(IdentifierInfo *AttrName,\n                                CachedTokens &OpenMPTokens);\n\n  void ParseCXX11AttributeSpecifierInternal(ParsedAttributes &Attrs,\n                                            CachedTokens &OpenMPTokens,\n                                            SourceLocation *EndLoc = nullptr);\n  void ParseCXX11AttributeSpecifier(ParsedAttributes &Attrs,\n                                    SourceLocation *EndLoc = nullptr) {\n    CachedTokens OpenMPTokens;\n    ParseCXX11AttributeSpecifierInternal(Attrs, OpenMPTokens, EndLoc);\n    ReplayOpenMPAttributeTokens(OpenMPTokens);\n  }\n  void ParseCXX11Attributes(ParsedAttributes &attrs);\n  /// Parses a C++11 (or C2x)-style attribute argument list. Returns true\n  /// if this results in adding an attribute to the ParsedAttributes list.\n  bool ParseCXX11AttributeArgs(IdentifierInfo *AttrName,\n                               SourceLocation AttrNameLoc,\n                               ParsedAttributes &Attrs, SourceLocation *EndLoc,\n                               IdentifierInfo *ScopeName,\n                               SourceLocation ScopeLoc,\n                               CachedTokens &OpenMPTokens);\n\n  IdentifierInfo *TryParseCXX11AttributeIdentifier(\n      SourceLocation &Loc,\n      Sema::AttributeCompletion Completion = Sema::AttributeCompletion::None,\n      const IdentifierInfo *EnclosingScope = nullptr);\n\n  void MaybeParseHLSLSemantics(Declarator &D,\n                               SourceLocation *EndLoc = nullptr) {\n    assert(getLangOpts().HLSL && \"MaybeParseHLSLSemantics is for HLSL only\");\n    if (Tok.is(tok::colon)) {\n      ParsedAttributes Attrs(AttrFactory);\n      ParseHLSLSemantics(Attrs, EndLoc);\n      D.takeAttributes(Attrs);\n    }\n  }\n\n  void MaybeParseHLSLSemantics(ParsedAttributes &Attrs,\n                               SourceLocation *EndLoc = nullptr) {\n    assert(getLangOpts().HLSL && \"MaybeParseHLSLSemantics is for HLSL only\");\n    if (getLangOpts().HLSL && Tok.is(tok::colon))\n      ParseHLSLSemantics(Attrs, EndLoc);\n  }\n\n  void ParseHLSLSemantics(ParsedAttributes &Attrs,\n                          SourceLocation *EndLoc = nullptr);\n  Decl *ParseHLSLBuffer(SourceLocation &DeclEnd);\n\n  void MaybeParseMicrosoftAttributes(ParsedAttributes &Attrs) {\n    if ((getLangOpts().MicrosoftExt || getLangOpts().HLSL) &&\n        Tok.is(tok::l_square)) {\n      ParsedAttributes AttrsWithRange(AttrFactory);\n      ParseMicrosoftAttributes(AttrsWithRange);\n      Attrs.takeAllFrom(AttrsWithRange);\n    }\n  }\n  void ParseMicrosoftUuidAttributeArgs(ParsedAttributes &Attrs);\n  void ParseMicrosoftAttributes(ParsedAttributes &Attrs);\n  bool MaybeParseMicrosoftDeclSpecs(ParsedAttributes &Attrs) {\n    if (getLangOpts().DeclSpecKeyword && Tok.is(tok::kw___declspec)) {\n      ParseMicrosoftDeclSpecs(Attrs);\n      return true;\n    }\n    return false;\n  }\n  void ParseMicrosoftDeclSpecs(ParsedAttributes &Attrs);\n  bool ParseMicrosoftDeclSpecArgs(IdentifierInfo *AttrName,\n                                  SourceLocation AttrNameLoc,\n                                  ParsedAttributes &Attrs);\n  void ParseMicrosoftTypeAttributes(ParsedAttributes &attrs);\n  void ParseWebAssemblyFuncrefTypeAttribute(ParsedAttributes &Attrs);\n  void DiagnoseAndSkipExtendedMicrosoftTypeAttributes();\n  SourceLocation SkipExtendedMicrosoftTypeAttributes();\n  void ParseMicrosoftInheritanceClassAttributes(ParsedAttributes &attrs);\n  void ParseBorlandTypeAttributes(ParsedAttributes &attrs);\n  void ParseOpenCLKernelAttributes(ParsedAttributes &attrs);\n  void ParseOpenCLQualifiers(ParsedAttributes &Attrs);\n  void ParseNullabilityTypeSpecifiers(ParsedAttributes &attrs);\n  void ParseCUDAFunctionAttributes(ParsedAttributes &attrs);\n  bool isHLSLQualifier(const Token &Tok) const;\n  void ParseHLSLQualifiers(ParsedAttributes &Attrs);\n\n  VersionTuple ParseVersionTuple(SourceRange &Range);\n  void ParseAvailabilityAttribute(IdentifierInfo &Availability,\n                                  SourceLocation AvailabilityLoc,\n                                  ParsedAttributes &attrs,\n                                  SourceLocation *endLoc,\n                                  IdentifierInfo *ScopeName,\n                                  SourceLocation ScopeLoc,\n                                  ParsedAttr::Form Form);\n\n  std::optional<AvailabilitySpec> ParseAvailabilitySpec();\n  ExprResult ParseAvailabilityCheckExpr(SourceLocation StartLoc);\n\n  void ParseExternalSourceSymbolAttribute(IdentifierInfo &ExternalSourceSymbol,\n                                          SourceLocation Loc,\n                                          ParsedAttributes &Attrs,\n                                          SourceLocation *EndLoc,\n                                          IdentifierInfo *ScopeName,\n                                          SourceLocation ScopeLoc,\n                                          ParsedAttr::Form Form);\n\n  void ParseObjCBridgeRelatedAttribute(IdentifierInfo &ObjCBridgeRelated,\n                                       SourceLocation ObjCBridgeRelatedLoc,\n                                       ParsedAttributes &Attrs,\n                                       SourceLocation *EndLoc,\n                                       IdentifierInfo *ScopeName,\n                                       SourceLocation ScopeLoc,\n                                       ParsedAttr::Form Form);\n\n  void ParseSwiftNewTypeAttribute(IdentifierInfo &AttrName,\n                                  SourceLocation AttrNameLoc,\n                                  ParsedAttributes &Attrs,\n                                  SourceLocation *EndLoc,\n                                  IdentifierInfo *ScopeName,\n                                  SourceLocation ScopeLoc,\n                                  ParsedAttr::Form Form);\n\n  void ParseTypeTagForDatatypeAttribute(IdentifierInfo &AttrName,\n                                        SourceLocation AttrNameLoc,\n                                        ParsedAttributes &Attrs,\n                                        SourceLocation *EndLoc,\n                                        IdentifierInfo *ScopeName,\n                                        SourceLocation ScopeLoc,\n                                        ParsedAttr::Form Form);\n\n  void ParseAttributeWithTypeArg(IdentifierInfo &AttrName,\n                                 SourceLocation AttrNameLoc,\n                                 ParsedAttributes &Attrs,\n                                 IdentifierInfo *ScopeName,\n                                 SourceLocation ScopeLoc,\n                                 ParsedAttr::Form Form);\n\n  void ParseTypeofSpecifier(DeclSpec &DS);\n  SourceLocation ParseDecltypeSpecifier(DeclSpec &DS);\n  void AnnotateExistingDecltypeSpecifier(const DeclSpec &DS,\n                                         SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  void ParseAtomicSpecifier(DeclSpec &DS);\n\n  ExprResult ParseAlignArgument(StringRef KWName, SourceLocation Start,\n                                SourceLocation &EllipsisLoc, bool &IsType,\n                                ParsedType &Ty);\n  void ParseAlignmentSpecifier(ParsedAttributes &Attrs,\n                               SourceLocation *endLoc = nullptr);\n  ExprResult ParseExtIntegerArgument();\n\n  VirtSpecifiers::Specifier isCXX11VirtSpecifier(const Token &Tok) const;\n  VirtSpecifiers::Specifier isCXX11VirtSpecifier() const {\n    return isCXX11VirtSpecifier(Tok);\n  }\n  void ParseOptionalCXX11VirtSpecifierSeq(VirtSpecifiers &VS, bool IsInterface,\n                                          SourceLocation FriendLoc);\n\n  bool isCXX11FinalKeyword() const;\n  bool isClassCompatibleKeyword() const;\n\n  /// DeclaratorScopeObj - RAII object used in Parser::ParseDirectDeclarator to\n  /// enter a new C++ declarator scope and exit it when the function is\n  /// finished.\n  class DeclaratorScopeObj {\n    Parser &P;\n    CXXScopeSpec &SS;\n    bool EnteredScope;\n    bool CreatedScope;\n  public:\n    DeclaratorScopeObj(Parser &p, CXXScopeSpec &ss)\n      : P(p), SS(ss), EnteredScope(false), CreatedScope(false) {}\n\n    void EnterDeclaratorScope() {\n      assert(!EnteredScope && \"Already entered the scope!\");\n      assert(SS.isSet() && \"C++ scope was not set!\");\n\n      CreatedScope = true;\n      P.EnterScope(0); // Not a decl scope.\n\n      if (!P.Actions.ActOnCXXEnterDeclaratorScope(P.getCurScope(), SS))\n        EnteredScope = true;\n    }\n\n    ~DeclaratorScopeObj() {\n      if (EnteredScope) {\n        assert(SS.isSet() && \"C++ scope was cleared ?\");\n        P.Actions.ActOnCXXExitDeclaratorScope(P.getCurScope(), SS);\n      }\n      if (CreatedScope)\n        P.ExitScope();\n    }\n  };\n\n  /// ParseDeclarator - Parse and verify a newly-initialized declarator.\n  void ParseDeclarator(Declarator &D);\n  /// A function that parses a variant of direct-declarator.\n  typedef void (Parser::*DirectDeclParseFunction)(Declarator&);\n  void ParseDeclaratorInternal(Declarator &D,\n                               DirectDeclParseFunction DirectDeclParser);\n\n  enum AttrRequirements {\n    AR_NoAttributesParsed = 0, ///< No attributes are diagnosed.\n    AR_GNUAttributesParsedAndRejected = 1 << 0, ///< Diagnose GNU attributes.\n    AR_GNUAttributesParsed = 1 << 1,\n    AR_CXX11AttributesParsed = 1 << 2,\n    AR_DeclspecAttributesParsed = 1 << 3,\n    AR_AllAttributesParsed = AR_GNUAttributesParsed |\n                             AR_CXX11AttributesParsed |\n                             AR_DeclspecAttributesParsed,\n    AR_VendorAttributesParsed = AR_GNUAttributesParsed |\n                                AR_DeclspecAttributesParsed\n  };\n\n  void ParseTypeQualifierListOpt(\n      DeclSpec &DS, unsigned AttrReqs = AR_AllAttributesParsed,\n      bool AtomicAllowed = true, bool IdentifierRequired = false,\n      std::optional<llvm::function_ref<void()>> CodeCompletionHandler =\n          std::nullopt);\n  void ParseDirectDeclarator(Declarator &D);\n  void ParseDecompositionDeclarator(Declarator &D);\n  void ParseParenDeclarator(Declarator &D);\n  void ParseFunctionDeclarator(Declarator &D, ParsedAttributes &FirstArgAttrs,\n                               BalancedDelimiterTracker &Tracker,\n                               bool IsAmbiguous, bool RequiresArg = false);\n  void InitCXXThisScopeForDeclaratorIfRelevant(\n      const Declarator &D, const DeclSpec &DS,\n      std::optional<Sema::CXXThisScopeRAII> &ThisScope);\n  bool ParseRefQualifier(bool &RefQualifierIsLValueRef,\n                         SourceLocation &RefQualifierLoc);\n  bool isFunctionDeclaratorIdentifierList();\n  void ParseFunctionDeclaratorIdentifierList(\n         Declarator &D,\n         SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo);\n  void ParseParameterDeclarationClause(\n      Declarator &D, ParsedAttributes &attrs,\n      SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo,\n      SourceLocation &EllipsisLoc) {\n    return ParseParameterDeclarationClause(\n        D.getContext(), attrs, ParamInfo, EllipsisLoc,\n        D.getCXXScopeSpec().isSet() &&\n            D.isFunctionDeclaratorAFunctionDeclaration());\n  }\n  void ParseParameterDeclarationClause(\n      DeclaratorContext DeclaratorContext, ParsedAttributes &attrs,\n      SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo,\n      SourceLocation &EllipsisLoc, bool IsACXXFunctionDeclaration = false);\n\n  void ParseBracketDeclarator(Declarator &D);\n  void ParseMisplacedBracketDeclarator(Declarator &D);\n  bool MaybeParseTypeTransformTypeSpecifier(DeclSpec &DS);\n  DeclSpec::TST TypeTransformTokToDeclSpec();\n\n  //===--------------------------------------------------------------------===//\n  // C++ 7: Declarations [dcl.dcl]\n\n  /// The kind of attribute specifier we have found.\n  enum CXX11AttributeKind {\n    /// This is not an attribute specifier.\n    CAK_NotAttributeSpecifier,\n    /// This should be treated as an attribute-specifier.\n    CAK_AttributeSpecifier,\n    /// The next tokens are '[[', but this is not an attribute-specifier. This\n    /// is ill-formed by C++11 [dcl.attr.grammar]p6.\n    CAK_InvalidAttributeSpecifier\n  };\n  CXX11AttributeKind\n  isCXX11AttributeSpecifier(bool Disambiguate = false,\n                            bool OuterMightBeMessageSend = false);\n\n  void DiagnoseUnexpectedNamespace(NamedDecl *Context);\n\n  DeclGroupPtrTy ParseNamespace(DeclaratorContext Context,\n                                SourceLocation &DeclEnd,\n                                SourceLocation InlineLoc = SourceLocation());\n\n  struct InnerNamespaceInfo {\n    SourceLocation NamespaceLoc;\n    SourceLocation InlineLoc;\n    SourceLocation IdentLoc;\n    IdentifierInfo *Ident;\n  };\n  using InnerNamespaceInfoList = llvm::SmallVector<InnerNamespaceInfo, 4>;\n\n  void ParseInnerNamespace(const InnerNamespaceInfoList &InnerNSs,\n                           unsigned int index, SourceLocation &InlineLoc,\n                           ParsedAttributes &attrs,\n                           BalancedDelimiterTracker &Tracker);\n  Decl *ParseLinkage(ParsingDeclSpec &DS, DeclaratorContext Context);\n  Decl *ParseExportDeclaration();\n  DeclGroupPtrTy ParseUsingDirectiveOrDeclaration(\n      DeclaratorContext Context, const ParsedTemplateInfo &TemplateInfo,\n      SourceLocation &DeclEnd, ParsedAttributes &Attrs);\n  Decl *ParseUsingDirective(DeclaratorContext Context,\n                            SourceLocation UsingLoc,\n                            SourceLocation &DeclEnd,\n                            ParsedAttributes &attrs);\n\n  struct UsingDeclarator {\n    SourceLocation TypenameLoc;\n    CXXScopeSpec SS;\n    UnqualifiedId Name;\n    SourceLocation EllipsisLoc;\n\n    void clear() {\n      TypenameLoc = EllipsisLoc = SourceLocation();\n      SS.clear();\n      Name.clear();\n    }\n  };\n\n  bool ParseUsingDeclarator(DeclaratorContext Context, UsingDeclarator &D);\n  DeclGroupPtrTy ParseUsingDeclaration(DeclaratorContext Context,\n                                       const ParsedTemplateInfo &TemplateInfo,\n                                       SourceLocation UsingLoc,\n                                       SourceLocation &DeclEnd,\n                                       ParsedAttributes &Attrs,\n                                       AccessSpecifier AS = AS_none);\n  Decl *ParseAliasDeclarationAfterDeclarator(\n      const ParsedTemplateInfo &TemplateInfo, SourceLocation UsingLoc,\n      UsingDeclarator &D, SourceLocation &DeclEnd, AccessSpecifier AS,\n      ParsedAttributes &Attrs, Decl **OwnedType = nullptr);\n\n  Decl *ParseStaticAssertDeclaration(SourceLocation &DeclEnd);\n  Decl *ParseNamespaceAlias(SourceLocation NamespaceLoc,\n                            SourceLocation AliasLoc, IdentifierInfo *Alias,\n                            SourceLocation &DeclEnd);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 9: classes [class] and C structs/unions.\n  bool isValidAfterTypeSpecifier(bool CouldBeBitfield);\n  void ParseClassSpecifier(tok::TokenKind TagTokKind, SourceLocation TagLoc,\n                           DeclSpec &DS, const ParsedTemplateInfo &TemplateInfo,\n                           AccessSpecifier AS, bool EnteringContext,\n                           DeclSpecContext DSC, ParsedAttributes &Attributes);\n  void SkipCXXMemberSpecification(SourceLocation StartLoc,\n                                  SourceLocation AttrFixitLoc,\n                                  unsigned TagType,\n                                  Decl *TagDecl);\n  void ParseCXXMemberSpecification(SourceLocation StartLoc,\n                                   SourceLocation AttrFixitLoc,\n                                   ParsedAttributes &Attrs, unsigned TagType,\n                                   Decl *TagDecl);\n  ExprResult ParseCXXMemberInitializer(Decl *D, bool IsFunction,\n                                       SourceLocation &EqualLoc);\n  bool\n  ParseCXXMemberDeclaratorBeforeInitializer(Declarator &DeclaratorInfo,\n                                            VirtSpecifiers &VS,\n                                            ExprResult &BitfieldSize,\n                                            LateParsedAttrList &LateAttrs);\n  void MaybeParseAndDiagnoseDeclSpecAfterCXX11VirtSpecifierSeq(Declarator &D,\n                                                               VirtSpecifiers &VS);\n  DeclGroupPtrTy ParseCXXClassMemberDeclaration(\n      AccessSpecifier AS, ParsedAttributes &Attr,\n      const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),\n      ParsingDeclRAIIObject *DiagsFromTParams = nullptr);\n  DeclGroupPtrTy\n  ParseCXXClassMemberDeclarationWithPragmas(AccessSpecifier &AS,\n                                            ParsedAttributes &AccessAttrs,\n                                            DeclSpec::TST TagType, Decl *Tag);\n  void ParseConstructorInitializer(Decl *ConstructorDecl);\n  MemInitResult ParseMemInitializer(Decl *ConstructorDecl);\n  void HandleMemberFunctionDeclDelays(Declarator& DeclaratorInfo,\n                                      Decl *ThisDecl);\n\n  //===--------------------------------------------------------------------===//\n  // C++ 10: Derived classes [class.derived]\n  TypeResult ParseBaseTypeSpecifier(SourceLocation &BaseLoc,\n                                    SourceLocation &EndLocation);\n  void ParseBaseClause(Decl *ClassDecl);\n  BaseResult ParseBaseSpecifier(Decl *ClassDecl);\n  AccessSpecifier getAccessSpecifierIfPresent() const;\n\n  bool ParseUnqualifiedIdTemplateId(CXXScopeSpec &SS,\n                                    ParsedType ObjectType,\n                                    bool ObjectHadErrors,\n                                    SourceLocation TemplateKWLoc,\n                                    IdentifierInfo *Name,\n                                    SourceLocation NameLoc,\n                                    bool EnteringContext,\n                                    UnqualifiedId &Id,\n                                    bool AssumeTemplateId);\n  bool ParseUnqualifiedIdOperator(CXXScopeSpec &SS, bool EnteringContext,\n                                  ParsedType ObjectType,\n                                  UnqualifiedId &Result);\n\n  //===--------------------------------------------------------------------===//\n  // OpenMP: Directives and clauses.\n  /// Parse clauses for '#pragma omp declare simd'.\n  DeclGroupPtrTy ParseOMPDeclareSimdClauses(DeclGroupPtrTy Ptr,\n                                            CachedTokens &Toks,\n                                            SourceLocation Loc);\n\n  /// Parse a property kind into \\p TIProperty for the selector set \\p Set and\n  /// selector \\p Selector.\n  void parseOMPTraitPropertyKind(OMPTraitProperty &TIProperty,\n                                 llvm::omp::TraitSet Set,\n                                 llvm::omp::TraitSelector Selector,\n                                 llvm::StringMap<SourceLocation> &Seen);\n\n  /// Parse a selector kind into \\p TISelector for the selector set \\p Set.\n  void parseOMPTraitSelectorKind(OMPTraitSelector &TISelector,\n                                 llvm::omp::TraitSet Set,\n                                 llvm::StringMap<SourceLocation> &Seen);\n\n  /// Parse a selector set kind into \\p TISet.\n  void parseOMPTraitSetKind(OMPTraitSet &TISet,\n                            llvm::StringMap<SourceLocation> &Seen);\n\n  /// Parses an OpenMP context property.\n  void parseOMPContextProperty(OMPTraitSelector &TISelector,\n                               llvm::omp::TraitSet Set,\n                               llvm::StringMap<SourceLocation> &Seen);\n\n  /// Parses an OpenMP context selector.\n  void parseOMPContextSelector(OMPTraitSelector &TISelector,\n                               llvm::omp::TraitSet Set,\n                               llvm::StringMap<SourceLocation> &SeenSelectors);\n\n  /// Parses an OpenMP context selector set.\n  void parseOMPContextSelectorSet(OMPTraitSet &TISet,\n                                  llvm::StringMap<SourceLocation> &SeenSets);\n\n  /// Parses OpenMP context selectors.\n  bool parseOMPContextSelectors(SourceLocation Loc, OMPTraitInfo &TI);\n\n  /// Parse an 'append_args' clause for '#pragma omp declare variant'.\n  bool parseOpenMPAppendArgs(SmallVectorImpl<OMPInteropInfo> &InteropInfos);\n\n  /// Parse a `match` clause for an '#pragma omp declare variant'. Return true\n  /// if there was an error.\n  bool parseOMPDeclareVariantMatchClause(SourceLocation Loc, OMPTraitInfo &TI,\n                                         OMPTraitInfo *ParentTI);\n\n  /// Parse clauses for '#pragma omp declare variant'.\n  void ParseOMPDeclareVariantClauses(DeclGroupPtrTy Ptr, CachedTokens &Toks,\n                                     SourceLocation Loc);\n\n  /// Parse 'omp [begin] assume[s]' directive.\n  void ParseOpenMPAssumesDirective(OpenMPDirectiveKind DKind,\n                                   SourceLocation Loc);\n\n  /// Parse 'omp end assumes' directive.\n  void ParseOpenMPEndAssumesDirective(SourceLocation Loc);\n\n  /// Parses clauses for directive.\n  ///\n  /// \\param DKind Kind of current directive.\n  /// \\param clauses for current directive.\n  /// \\param start location for clauses of current directive\n  void ParseOpenMPClauses(OpenMPDirectiveKind DKind,\n                          SmallVectorImpl<clang::OMPClause *> &Clauses,\n                          SourceLocation Loc);\n\n  /// Parse clauses for '#pragma omp [begin] declare target'.\n  void ParseOMPDeclareTargetClauses(Sema::DeclareTargetContextInfo &DTCI);\n\n  /// Parse '#pragma omp end declare target'.\n  void ParseOMPEndDeclareTargetDirective(OpenMPDirectiveKind BeginDKind,\n                                         OpenMPDirectiveKind EndDKind,\n                                         SourceLocation Loc);\n\n  /// Skip tokens until a `annot_pragma_openmp_end` was found. Emit a warning if\n  /// it is not the current token.\n  void skipUntilPragmaOpenMPEnd(OpenMPDirectiveKind DKind);\n\n  /// Check the \\p FoundKind against the \\p ExpectedKind, if not issue an error\n  /// that the \"end\" matching the \"begin\" directive of kind \\p BeginKind was not\n  /// found. Finally, if the expected kind was found or if \\p SkipUntilOpenMPEnd\n  /// is set, skip ahead using the helper `skipUntilPragmaOpenMPEnd`.\n  void parseOMPEndDirective(OpenMPDirectiveKind BeginKind,\n                            OpenMPDirectiveKind ExpectedKind,\n                            OpenMPDirectiveKind FoundKind,\n                            SourceLocation MatchingLoc,\n                            SourceLocation FoundLoc,\n                            bool SkipUntilOpenMPEnd);\n\n  /// Parses declarative OpenMP directives.\n  DeclGroupPtrTy ParseOpenMPDeclarativeDirectiveWithExtDecl(\n      AccessSpecifier &AS, ParsedAttributes &Attrs, bool Delayed = false,\n      DeclSpec::TST TagType = DeclSpec::TST_unspecified,\n      Decl *TagDecl = nullptr);\n  /// Parse 'omp declare reduction' construct.\n  DeclGroupPtrTy ParseOpenMPDeclareReductionDirective(AccessSpecifier AS);\n  /// Parses initializer for provided omp_priv declaration inside the reduction\n  /// initializer.\n  void ParseOpenMPReductionInitializerForDecl(VarDecl *OmpPrivParm);\n\n  /// Parses 'omp declare mapper' directive.\n  DeclGroupPtrTy ParseOpenMPDeclareMapperDirective(AccessSpecifier AS);\n  /// Parses variable declaration in 'omp declare mapper' directive.\n  TypeResult parseOpenMPDeclareMapperVarDecl(SourceRange &Range,\n                                             DeclarationName &Name,\n                                             AccessSpecifier AS = AS_none);\n\n  /// Tries to parse cast part of OpenMP array shaping operation:\n  /// '[' expression ']' { '[' expression ']' } ')'.\n  bool tryParseOpenMPArrayShapingCastPart();\n\n  /// Parses simple list of variables.\n  ///\n  /// \\param Kind Kind of the directive.\n  /// \\param Callback Callback function to be called for the list elements.\n  /// \\param AllowScopeSpecifier true, if the variables can have fully\n  /// qualified names.\n  ///\n  bool ParseOpenMPSimpleVarList(\n      OpenMPDirectiveKind Kind,\n      const llvm::function_ref<void(CXXScopeSpec &, DeclarationNameInfo)> &\n          Callback,\n      bool AllowScopeSpecifier);\n  /// Parses declarative or executable directive.\n  ///\n  /// \\param StmtCtx The context in which we're parsing the directive.\n  /// \\param ReadDirectiveWithinMetadirective true if directive is within a\n  /// metadirective and therefore ends on the closing paren.\n  StmtResult ParseOpenMPDeclarativeOrExecutableDirective(\n      ParsedStmtContext StmtCtx, bool ReadDirectiveWithinMetadirective = false);\n  /// Parses clause of kind \\a CKind for directive of a kind \\a Kind.\n  ///\n  /// \\param DKind Kind of current directive.\n  /// \\param CKind Kind of current clause.\n  /// \\param FirstClause true, if this is the first clause of a kind \\a CKind\n  /// in current directive.\n  ///\n  OMPClause *ParseOpenMPClause(OpenMPDirectiveKind DKind,\n                               OpenMPClauseKind CKind, bool FirstClause);\n  /// Parses clause with a single expression of a kind \\a Kind.\n  ///\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  ///\n  OMPClause *ParseOpenMPSingleExprClause(OpenMPClauseKind Kind,\n                                         bool ParseOnly);\n  /// Parses simple clause of a kind \\a Kind.\n  ///\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  ///\n  OMPClause *ParseOpenMPSimpleClause(OpenMPClauseKind Kind, bool ParseOnly);\n  /// Parses indirect clause\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  // false;\n  bool ParseOpenMPIndirectClause(Sema::DeclareTargetContextInfo &DTCI,\n                                 bool ParseOnly);\n  /// Parses clause with a single expression and an additional argument\n  /// of a kind \\a Kind.\n  ///\n  /// \\param DKind Directive kind.\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  ///\n  OMPClause *ParseOpenMPSingleExprWithArgClause(OpenMPDirectiveKind DKind,\n                                                OpenMPClauseKind Kind,\n                                                bool ParseOnly);\n\n  /// Parses the 'sizes' clause of a '#pragma omp tile' directive.\n  OMPClause *ParseOpenMPSizesClause();\n\n  /// Parses clause without any additional arguments.\n  ///\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  ///\n  OMPClause *ParseOpenMPClause(OpenMPClauseKind Kind, bool ParseOnly = false);\n  /// Parses clause with the list of variables of a kind \\a Kind.\n  ///\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  ///\n  OMPClause *ParseOpenMPVarListClause(OpenMPDirectiveKind DKind,\n                                      OpenMPClauseKind Kind, bool ParseOnly);\n\n  /// Parses and creates OpenMP 5.0 iterators expression:\n  /// <iterators> = 'iterator' '(' { [ <iterator-type> ] identifier =\n  /// <range-specification> }+ ')'\n  ExprResult ParseOpenMPIteratorsExpr();\n\n  /// Parses allocators and traits in the context of the uses_allocator clause.\n  /// Expected format:\n  /// '(' { <allocator> [ '(' <allocator_traits> ')' ] }+ ')'\n  OMPClause *ParseOpenMPUsesAllocatorClause(OpenMPDirectiveKind DKind);\n\n  /// Parses the 'interop' parts of the 'append_args' and 'init' clauses.\n  bool ParseOMPInteropInfo(OMPInteropInfo &InteropInfo, OpenMPClauseKind Kind);\n\n  /// Parses clause with an interop variable of kind \\a Kind.\n  ///\n  /// \\param Kind Kind of current clause.\n  /// \\param ParseOnly true to skip the clause's semantic actions and return\n  /// nullptr.\n  //\n  OMPClause *ParseOpenMPInteropClause(OpenMPClauseKind Kind, bool ParseOnly);\n\npublic:\n  /// Parses simple expression in parens for single-expression clauses of OpenMP\n  /// constructs.\n  /// \\param RLoc Returned location of right paren.\n  ExprResult ParseOpenMPParensExpr(StringRef ClauseName, SourceLocation &RLoc,\n                                   bool IsAddressOfOperand = false);\n\n  /// Parses a reserved locator like 'omp_all_memory'.\n  bool ParseOpenMPReservedLocator(OpenMPClauseKind Kind,\n                                  Sema::OpenMPVarListDataTy &Data,\n                                  const LangOptions &LangOpts);\n  /// Parses clauses with list.\n  bool ParseOpenMPVarList(OpenMPDirectiveKind DKind, OpenMPClauseKind Kind,\n                          SmallVectorImpl<Expr *> &Vars,\n                          Sema::OpenMPVarListDataTy &Data);\n  bool ParseUnqualifiedId(CXXScopeSpec &SS, ParsedType ObjectType,\n                          bool ObjectHadErrors, bool EnteringContext,\n                          bool AllowDestructorName, bool AllowConstructorName,\n                          bool AllowDeductionGuide,\n                          SourceLocation *TemplateKWLoc, UnqualifiedId &Result);\n\n  /// Parses the mapper modifier in map, to, and from clauses.\n  bool parseMapperModifier(Sema::OpenMPVarListDataTy &Data);\n  /// Parses map-type-modifiers in map clause.\n  /// map([ [map-type-modifier[,] [map-type-modifier[,] ...] map-type : ] list)\n  /// where, map-type-modifier ::= always | close | mapper(mapper-identifier)\n  bool parseMapTypeModifiers(Sema::OpenMPVarListDataTy &Data);\n\nprivate:\n  //===--------------------------------------------------------------------===//\n  // C++ 14: Templates [temp]\n\n  // C++ 14.1: Template Parameters [temp.param]\n  Decl *ParseDeclarationStartingWithTemplate(DeclaratorContext Context,\n                                             SourceLocation &DeclEnd,\n                                             ParsedAttributes &AccessAttrs,\n                                             AccessSpecifier AS = AS_none);\n  Decl *ParseTemplateDeclarationOrSpecialization(DeclaratorContext Context,\n                                                 SourceLocation &DeclEnd,\n                                                 ParsedAttributes &AccessAttrs,\n                                                 AccessSpecifier AS);\n  Decl *ParseSingleDeclarationAfterTemplate(\n      DeclaratorContext Context, const ParsedTemplateInfo &TemplateInfo,\n      ParsingDeclRAIIObject &DiagsFromParams, SourceLocation &DeclEnd,\n      ParsedAttributes &AccessAttrs, AccessSpecifier AS = AS_none);\n  bool ParseTemplateParameters(MultiParseScope &TemplateScopes, unsigned Depth,\n                               SmallVectorImpl<NamedDecl *> &TemplateParams,\n                               SourceLocation &LAngleLoc,\n                               SourceLocation &RAngleLoc);\n  bool ParseTemplateParameterList(unsigned Depth,\n                                  SmallVectorImpl<NamedDecl*> &TemplateParams);\n  TPResult isStartOfTemplateTypeParameter();\n  NamedDecl *ParseTemplateParameter(unsigned Depth, unsigned Position);\n  NamedDecl *ParseTypeParameter(unsigned Depth, unsigned Position);\n  NamedDecl *ParseTemplateTemplateParameter(unsigned Depth, unsigned Position);\n  NamedDecl *ParseNonTypeTemplateParameter(unsigned Depth, unsigned Position);\n  bool isTypeConstraintAnnotation();\n  bool TryAnnotateTypeConstraint();\n  void DiagnoseMisplacedEllipsis(SourceLocation EllipsisLoc,\n                                 SourceLocation CorrectLoc,\n                                 bool AlreadyHasEllipsis,\n                                 bool IdentifierHasName);\n  void DiagnoseMisplacedEllipsisInDeclarator(SourceLocation EllipsisLoc,\n                                             Declarator &D);\n  // C++ 14.3: Template arguments [temp.arg]\n  typedef SmallVector<ParsedTemplateArgument, 16> TemplateArgList;\n\n  bool ParseGreaterThanInTemplateList(SourceLocation LAngleLoc,\n                                      SourceLocation &RAngleLoc,\n                                      bool ConsumeLastToken,\n                                      bool ObjCGenericList);\n  bool ParseTemplateIdAfterTemplateName(bool ConsumeLastToken,\n                                        SourceLocation &LAngleLoc,\n                                        TemplateArgList &TemplateArgs,\n                                        SourceLocation &RAngleLoc,\n                                        TemplateTy NameHint = nullptr);\n\n  bool AnnotateTemplateIdToken(TemplateTy Template, TemplateNameKind TNK,\n                               CXXScopeSpec &SS,\n                               SourceLocation TemplateKWLoc,\n                               UnqualifiedId &TemplateName,\n                               bool AllowTypeAnnotation = true,\n                               bool TypeConstraint = false);\n  void\n  AnnotateTemplateIdTokenAsType(CXXScopeSpec &SS,\n                                ImplicitTypenameContext AllowImplicitTypename,\n                                bool IsClassName = false);\n  bool ParseTemplateArgumentList(TemplateArgList &TemplateArgs,\n                                 TemplateTy Template, SourceLocation OpenLoc);\n  ParsedTemplateArgument ParseTemplateTemplateArgument();\n  ParsedTemplateArgument ParseTemplateArgument();\n  Decl *ParseExplicitInstantiation(DeclaratorContext Context,\n                                   SourceLocation ExternLoc,\n                                   SourceLocation TemplateLoc,\n                                   SourceLocation &DeclEnd,\n                                   ParsedAttributes &AccessAttrs,\n                                   AccessSpecifier AS = AS_none);\n  // C++2a: Template, concept definition [temp]\n  Decl *\n  ParseConceptDefinition(const ParsedTemplateInfo &TemplateInfo,\n                         SourceLocation &DeclEnd);\n\n  //===--------------------------------------------------------------------===//\n  // Modules\n  DeclGroupPtrTy ParseModuleDecl(Sema::ModuleImportState &ImportState);\n  Decl *ParseModuleImport(SourceLocation AtLoc,\n                          Sema::ModuleImportState &ImportState);\n  bool parseMisplacedModuleImport();\n  bool tryParseMisplacedModuleImport() {\n    tok::TokenKind Kind = Tok.getKind();\n    if (Kind == tok::annot_module_begin || Kind == tok::annot_module_end ||\n        Kind == tok::annot_module_include)\n      return parseMisplacedModuleImport();\n    return false;\n  }\n\n  bool ParseModuleName(\n      SourceLocation UseLoc,\n      SmallVectorImpl<std::pair<IdentifierInfo *, SourceLocation>> &Path,\n      bool IsImport);\n\n  //===--------------------------------------------------------------------===//\n  // C++11/G++: Type Traits [Type-Traits.html in the GCC manual]\n  ExprResult ParseTypeTrait();\n\n  //===--------------------------------------------------------------------===//\n  // Embarcadero: Arary and Expression Traits\n  ExprResult ParseArrayTypeTrait();\n  ExprResult ParseExpressionTrait();\n\n  //===--------------------------------------------------------------------===//\n  // Preprocessor code-completion pass-through\n  void CodeCompleteDirective(bool InConditional) override;\n  void CodeCompleteInConditionalExclusion() override;\n  void CodeCompleteMacroName(bool IsDefinition) override;\n  void CodeCompletePreprocessorExpression() override;\n  void CodeCompleteMacroArgument(IdentifierInfo *Macro, MacroInfo *MacroInfo,\n                                 unsigned ArgumentIndex) override;\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled) override;\n  void CodeCompleteNaturalLanguage() override;\n\n  class GNUAsmQualifiers {\n    unsigned Qualifiers = AQ_unspecified;\n\n  public:\n    enum AQ {\n      AQ_unspecified = 0,\n      AQ_volatile    = 1,\n      AQ_inline      = 2,\n      AQ_goto        = 4,\n    };\n    static const char *getQualifierName(AQ Qualifier);\n    bool setAsmQualifier(AQ Qualifier);\n    inline bool isVolatile() const { return Qualifiers & AQ_volatile; };\n    inline bool isInline() const { return Qualifiers & AQ_inline; };\n    inline bool isGoto() const { return Qualifiers & AQ_goto; }\n  };\n  bool isGCCAsmStatement(const Token &TokAfterAsm) const;\n  bool isGNUAsmQualifier(const Token &TokAfterAsm) const;\n  GNUAsmQualifiers::AQ getGNUAsmQualifier(const Token &Tok) const;\n  bool parseGNUAsmQualifierListOpt(GNUAsmQualifiers &AQ);\n}",
  "id": "BLOCK-CPP-19333",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Parse/Parser.h",
  "source_line": 62,
  "validation_status": "validated"
}