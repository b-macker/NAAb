{
  "code": "{\nprotected:\n  enum ScopeKind {\n    SK_Function,\n    SK_Block,\n    SK_Lambda,\n    SK_CapturedRegion\n  };\n\npublic:\n  /// What kind of scope we are describing.\n  ScopeKind Kind : 3;\n\n  /// Whether this function contains a VLA, \\@try, try, C++\n  /// initializer, or anything else that can't be jumped past.\n  bool HasBranchProtectedScope : 1;\n\n  /// Whether this function contains any switches or direct gotos.\n  bool HasBranchIntoScope : 1;\n\n  /// Whether this function contains any indirect gotos.\n  bool HasIndirectGoto : 1;\n\n  /// Whether this function contains any statement marked with\n  /// \\c [[clang::musttail]].\n  bool HasMustTail : 1;\n\n  /// Whether a statement was dropped because it was invalid.\n  bool HasDroppedStmt : 1;\n\n  /// True if current scope is for OpenMP declare reduction combiner.\n  bool HasOMPDeclareReductionCombiner : 1;\n\n  /// Whether there is a fallthrough statement in this function.\n  bool HasFallthroughStmt : 1;\n\n  /// Whether this function uses constrained floating point intrinsics\n  bool UsesFPIntrin : 1;\n\n  /// Whether we make reference to a declaration that could be\n  /// unavailable.\n  bool HasPotentialAvailabilityViolations : 1;\n\n  /// A flag that is set when parsing a method that must call super's\n  /// implementation, such as \\c -dealloc, \\c -finalize, or any method marked\n  /// with \\c __attribute__((objc_requires_super)).\n  bool ObjCShouldCallSuper : 1;\n\n  /// True when this is a method marked as a designated initializer.\n  bool ObjCIsDesignatedInit : 1;\n\n  /// This starts true for a method marked as designated initializer and will\n  /// be set to false if there is an invocation to a designated initializer of\n  /// the super class.\n  bool ObjCWarnForNoDesignatedInitChain : 1;\n\n  /// True when this is an initializer method not marked as a designated\n  /// initializer within a class that has at least one initializer marked as a\n  /// designated initializer.\n  bool ObjCIsSecondaryInit : 1;\n\n  /// This starts true for a secondary initializer method and will be set to\n  /// false if there is an invocation of an initializer on 'self'.\n  bool ObjCWarnForNoInitDelegation : 1;\n\n  /// True only when this function has not already built, or attempted\n  /// to build, the initial and final coroutine suspend points\n  bool NeedsCoroutineSuspends : 1;\n\n  /// An enumeration represeting the kind of the first coroutine statement\n  /// in the function. One of co_return, co_await, or co_yield.\n  unsigned char FirstCoroutineStmtKind : 2;\n\n  /// Whether we found an immediate-escalating expression.\n  bool FoundImmediateEscalatingExpression : 1;\n\n  /// First coroutine statement in the current function.\n  /// (ex co_return, co_await, co_yield)\n  SourceLocation FirstCoroutineStmtLoc;\n\n  /// First 'return' statement in the current function.\n  SourceLocation FirstReturnLoc;\n\n  /// First C++ 'try' or ObjC @try statement in the current function.\n  SourceLocation FirstCXXOrObjCTryLoc;\n  enum { TryLocIsCXX, TryLocIsObjC, Unknown } FirstTryType = Unknown;\n\n  /// First SEH '__try' statement in the current function.\n  SourceLocation FirstSEHTryLoc;\n\nprivate:\n  /// Used to determine if errors occurred in this function or block.\n  DiagnosticErrorTrap ErrorTrap;\n\npublic:\n  /// A SwitchStmt, along with a flag indicating if its list of case statements\n  /// is incomplete (because we dropped an invalid one while parsing).\n  using SwitchInfo = llvm::PointerIntPair<SwitchStmt*, 1, bool>;\n\n  /// SwitchStack - This is the current set of active switch statements in the\n  /// block.\n  SmallVector<SwitchInfo, 8> SwitchStack;\n\n  /// The list of return statements that occur within the function or\n  /// block, if there is any chance of applying the named return value\n  /// optimization, or if we need to infer a return type.\n  SmallVector<ReturnStmt*, 4> Returns;\n\n  /// The promise object for this coroutine, if any.\n  VarDecl *CoroutinePromise = nullptr;\n\n  /// A mapping between the coroutine function parameters that were moved\n  /// to the coroutine frame, and their move statements.\n  llvm::SmallMapVector<ParmVarDecl *, Stmt *, 4> CoroutineParameterMoves;\n\n  /// The initial and final coroutine suspend points.\n  std::pair<Stmt *, Stmt *> CoroutineSuspends;\n\n  /// The stack of currently active compound stamement scopes in the\n  /// function.\n  SmallVector<CompoundScopeInfo, 4> CompoundScopes;\n\n  /// The set of blocks that are introduced in this function.\n  llvm::SmallPtrSet<const BlockDecl *, 1> Blocks;\n\n  /// The set of __block variables that are introduced in this function.\n  llvm::TinyPtrVector<VarDecl *> ByrefBlockVars;\n\n  /// A list of PartialDiagnostics created but delayed within the\n  /// current function scope.  These diagnostics are vetted for reachability\n  /// prior to being emitted.\n  SmallVector<PossiblyUnreachableDiag, 4> PossiblyUnreachableDiags;\n\n  /// A list of parameters which have the nonnull attribute and are\n  /// modified in the function.\n  llvm::SmallPtrSet<const ParmVarDecl *, 8> ModifiedNonNullParams;\n\n  /// The set of GNU address of label extension \"&&label\".\n  llvm::SmallVector<AddrLabelExpr *, 4> AddrLabels;\n\npublic:\n  /// Represents a simple identification of a weak object.\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  ///\n  /// This is used to determine if two weak accesses refer to the same object.\n  /// Here are some examples of how various accesses are \"profiled\":\n  ///\n  /// Access Expression |     \"Base\" Decl     |          \"Property\" Decl\n  /// :---------------: | :-----------------: | :------------------------------:\n  /// self.property     | self (VarDecl)      | property (ObjCPropertyDecl)\n  /// self.implicitProp | self (VarDecl)      | -implicitProp (ObjCMethodDecl)\n  /// self->ivar.prop   | ivar (ObjCIvarDecl) | prop (ObjCPropertyDecl)\n  /// cxxObj.obj.prop   | obj (FieldDecl)     | prop (ObjCPropertyDecl)\n  /// [self foo].prop   | 0 (unknown)         | prop (ObjCPropertyDecl)\n  /// self.prop1.prop2  | prop1 (ObjCPropertyDecl)    | prop2 (ObjCPropertyDecl)\n  /// MyClass.prop      | MyClass (ObjCInterfaceDecl) | -prop (ObjCMethodDecl)\n  /// MyClass.foo.prop  | +foo (ObjCMethodDecl)       | -prop (ObjCPropertyDecl)\n  /// weakVar           | 0 (known)           | weakVar (VarDecl)\n  /// self->weakIvar    | self (VarDecl)      | weakIvar (ObjCIvarDecl)\n  ///\n  /// Objects are identified with only two Decls to make it reasonably fast to\n  /// compare them.\n  class WeakObjectProfileTy {\n    /// The base object decl, as described in the class documentation.\n    ///\n    /// The extra flag is \"true\" if the Base and Property are enough to uniquely\n    /// identify the object in memory.\n    ///\n    /// \\sa isExactProfile()\n    using BaseInfoTy = llvm::PointerIntPair<const NamedDecl *, 1, bool>;\n    BaseInfoTy Base;\n\n    /// The \"property\" decl, as described in the class documentation.\n    ///\n    /// Note that this may not actually be an ObjCPropertyDecl, e.g. in the\n    /// case of \"implicit\" properties (regular methods accessed via dot syntax).\n    const NamedDecl *Property = nullptr;\n\n    /// Used to find the proper base profile for a given base expression.\n    static BaseInfoTy getBaseInfo(const Expr *BaseE);\n\n    inline WeakObjectProfileTy();\n    static inline WeakObjectProfileTy getSentinel();\n\n  public:\n    WeakObjectProfileTy(const ObjCPropertyRefExpr *RE);\n    WeakObjectProfileTy(const Expr *Base, const ObjCPropertyDecl *Property);\n    WeakObjectProfileTy(const DeclRefExpr *RE);\n    WeakObjectProfileTy(const ObjCIvarRefExpr *RE);\n\n    const NamedDecl *getBase() const { return Base.getPointer(); }\n    const NamedDecl *getProperty() const { return Property; }\n\n    /// Returns true if the object base specifies a known object in memory,\n    /// rather than, say, an instance variable or property of another object.\n    ///\n    /// Note that this ignores the effects of aliasing; that is, \\c foo.bar is\n    /// considered an exact profile if \\c foo is a local variable, even if\n    /// another variable \\c foo2 refers to the same object as \\c foo.\n    ///\n    /// For increased precision, accesses with base variables that are\n    /// properties or ivars of 'self' (e.g. self.prop1.prop2) are considered to\n    /// be exact, though this is not true for arbitrary variables\n    /// (foo.prop1.prop2).\n    bool isExactProfile() const {\n      return Base.getInt();\n    }\n\n    bool operator==(const WeakObjectProfileTy &Other) const {\n      return Base == Other.Base && Property == Other.Property;\n    }\n\n    // For use in DenseMap.\n    // We can't specialize the usual llvm::DenseMapInfo at the end of the file\n    // because by that point the DenseMap in FunctionScopeInfo has already been\n    // instantiated.\n    class DenseMapInfo {\n    public:\n      static inline WeakObjectProfileTy getEmptyKey() {\n        return WeakObjectProfileTy();\n      }\n\n      static inline WeakObjectProfileTy getTombstoneKey() {\n        return WeakObjectProfileTy::getSentinel();\n      }\n\n      static unsigned getHashValue(const WeakObjectProfileTy &Val) {\n        using Pair = std::pair<BaseInfoTy, const NamedDecl *>;\n\n        return llvm::DenseMapInfo<Pair>::getHashValue(Pair(Val.Base,\n                                                           Val.Property));\n      }\n\n      static bool isEqual(const WeakObjectProfileTy &LHS,\n                          const WeakObjectProfileTy &RHS) {\n        return LHS == RHS;\n      }\n    };\n  };\n\n  /// Represents a single use of a weak object.\n  ///\n  /// Stores both the expression and whether the access is potentially unsafe\n  /// (i.e. it could potentially be warned about).\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  class WeakUseTy {\n    llvm::PointerIntPair<const Expr *, 1, bool> Rep;\n\n  public:\n    WeakUseTy(const Expr *Use, bool IsRead) : Rep(Use, IsRead) {}\n\n    const Expr *getUseExpr() const { return Rep.getPointer(); }\n    bool isUnsafe() const { return Rep.getInt(); }\n    void markSafe() { Rep.setInt(false); }\n\n    bool operator==(const WeakUseTy &Other) const {\n      return Rep == Other.Rep;\n    }\n  };\n\n  /// Used to collect uses of a particular weak object in a function body.\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  using WeakUseVector = SmallVector<WeakUseTy, 4>;\n\n  /// Used to collect all uses of weak objects in a function body.\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  using WeakObjectUseMap =\n      llvm::SmallDenseMap<WeakObjectProfileTy, WeakUseVector, 8,\n                          WeakObjectProfileTy::DenseMapInfo>;\n\nprivate:\n  /// Used to collect all uses of weak objects in this function body.\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  WeakObjectUseMap WeakObjectUses;\n\nprotected:\n  FunctionScopeInfo(const FunctionScopeInfo&) = default;\n\npublic:\n  FunctionScopeInfo(DiagnosticsEngine &Diag)\n      : Kind(SK_Function), HasBranchProtectedScope(false),\n        HasBranchIntoScope(false), HasIndirectGoto(false), HasMustTail(false),\n        HasDroppedStmt(false), HasOMPDeclareReductionCombiner(false),\n        HasFallthroughStmt(false), UsesFPIntrin(false),\n        HasPotentialAvailabilityViolations(false), ObjCShouldCallSuper(false),\n        ObjCIsDesignatedInit(false), ObjCWarnForNoDesignatedInitChain(false),\n        ObjCIsSecondaryInit(false), ObjCWarnForNoInitDelegation(false),\n        NeedsCoroutineSuspends(true), FoundImmediateEscalatingExpression(false),\n        ErrorTrap(Diag) {}\n\n  virtual ~FunctionScopeInfo();\n\n  /// Determine whether an unrecoverable error has occurred within this\n  /// function. Note that this may return false even if the function body is\n  /// invalid, because the errors may be suppressed if they're caused by prior\n  /// invalid declarations.\n  ///\n  /// FIXME: Migrate the caller of this to use containsErrors() instead once\n  /// it's ready.\n  bool hasUnrecoverableErrorOccurred() const {\n    return ErrorTrap.hasUnrecoverableErrorOccurred();\n  }\n\n  /// Record that a weak object was accessed.\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  template <typename ExprT>\n  inline void recordUseOfWeak(const ExprT *E, bool IsRead = true);\n\n  void recordUseOfWeak(const ObjCMessageExpr *Msg,\n                       const ObjCPropertyDecl *Prop);\n\n  /// Record that a given expression is a \"safe\" access of a weak object (e.g.\n  /// assigning it to a strong variable.)\n  ///\n  /// Part of the implementation of -Wrepeated-use-of-weak.\n  void markSafeWeakUse(const Expr *E);\n\n  const WeakObjectUseMap &getWeakObjectUses() const {\n    return WeakObjectUses;\n  }\n\n  void setHasBranchIntoScope() {\n    HasBranchIntoScope = true;\n  }\n\n  void setHasBranchProtectedScope() {\n    HasBranchProtectedScope = true;\n  }\n\n  void setHasIndirectGoto() {\n    HasIndirectGoto = true;\n  }\n\n  void setHasMustTail() { HasMustTail = true; }\n\n  void setHasDroppedStmt() {\n    HasDroppedStmt = true;\n  }\n\n  void setHasOMPDeclareReductionCombiner() {\n    HasOMPDeclareReductionCombiner = true;\n  }\n\n  void setHasFallthroughStmt() {\n    HasFallthroughStmt = true;\n  }\n\n  void setUsesFPIntrin() {\n    UsesFPIntrin = true;\n  }\n\n  void setHasCXXTry(SourceLocation TryLoc) {\n    setHasBranchProtectedScope();\n    FirstCXXOrObjCTryLoc = TryLoc;\n    FirstTryType = TryLocIsCXX;\n  }\n\n  void setHasObjCTry(SourceLocation TryLoc) {\n    setHasBranchProtectedScope();\n    FirstCXXOrObjCTryLoc = TryLoc;\n    FirstTryType = TryLocIsObjC;\n  }\n\n  void setHasSEHTry(SourceLocation TryLoc) {\n    setHasBranchProtectedScope();\n    FirstSEHTryLoc = TryLoc;\n  }\n\n  bool NeedsScopeChecking() const {\n    return !HasDroppedStmt && (HasIndirectGoto || HasMustTail ||\n                               (HasBranchProtectedScope && HasBranchIntoScope));\n  }\n\n  // Add a block introduced in this function.\n  void addBlock(const BlockDecl *BD) {\n    Blocks.insert(BD);\n  }\n\n  // Add a __block variable introduced in this function.\n  void addByrefBlockVar(VarDecl *VD) {\n    ByrefBlockVars.push_back(VD);\n  }\n\n  bool isCoroutine() const { return !FirstCoroutineStmtLoc.isInvalid(); }\n\n  void setFirstCoroutineStmt(SourceLocation Loc, StringRef Keyword) {\n    assert(FirstCoroutineStmtLoc.isInvalid() &&\n                   \"first coroutine statement location already set\");\n    FirstCoroutineStmtLoc = Loc;\n    FirstCoroutineStmtKind = llvm::StringSwitch<unsigned char>(Keyword)\n            .Case(\"co_return\", 0)\n            .Case(\"co_await\", 1)\n            .Case(\"co_yield\", 2);\n  }\n\n  StringRef getFirstCoroutineStmtKeyword() const {\n    assert(FirstCoroutineStmtLoc.isValid()\n                   && \"no coroutine statement available\");\n    switch (FirstCoroutineStmtKind) {\n    case 0: return \"co_return\";\n    case 1: return \"co_await\";\n    case 2: return \"co_yield\";\n    default:\n      llvm_unreachable(\"FirstCoroutineStmtKind has an invalid value\");\n    };\n  }\n\n  void setNeedsCoroutineSuspends(bool value = true) {\n    assert((!value || CoroutineSuspends.first == nullptr) &&\n            \"we already have valid suspend points\");\n    NeedsCoroutineSuspends = value;\n  }\n\n  bool hasInvalidCoroutineSuspends() const {\n    return !NeedsCoroutineSuspends && CoroutineSuspends.first == nullptr;\n  }\n\n  void setCoroutineSuspends(Stmt *Initial, Stmt *Final) {\n    assert(Initial && Final && \"suspend points cannot be null\");\n    assert(CoroutineSuspends.first == nullptr && \"suspend points already set\");\n    NeedsCoroutineSuspends = false;\n    CoroutineSuspends.first = Initial;\n    CoroutineSuspends.second = Final;\n  }\n\n  /// Clear out the information in this function scope, making it\n  /// suitable for reuse.\n  void Clear();\n\n  bool isPlainFunction() const { return Kind == SK_Function; }\n}",
  "id": "BLOCK-CPP-20299",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ScopeInfo.h",
  "source_line": 102,
  "validation_status": "validated"
}