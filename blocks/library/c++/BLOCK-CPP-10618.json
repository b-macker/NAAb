{
  "code": "{\n///     return T(a1);\n///   }\n/// \\endcode\n///\n/// When the returned expression is instantiated, it may resolve to a\n/// constructor call, conversion function call, or some kind of type\n/// conversion.\nclass CXXUnresolvedConstructExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXUnresolvedConstructExpr, Expr *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The type being constructed, and whether the construct expression models\n  /// list initialization or not.\n  llvm::PointerIntPair<TypeSourceInfo *, 1> TypeAndInitForm;\n\n  /// The location of the left parentheses ('(').\n  SourceLocation LParenLoc;\n\n  /// The location of the right parentheses (')').\n  SourceLocation RParenLoc;\n\n  CXXUnresolvedConstructExpr(QualType T, TypeSourceInfo *TSI,\n                             SourceLocation LParenLoc, ArrayRef<Expr *> Args,\n                             SourceLocation RParenLoc, bool IsListInit);\n\n  CXXUnresolvedConstructExpr(EmptyShell Empty, unsigned NumArgs)\n      : Expr(CXXUnresolvedConstructExprClass, Empty) {\n    CXXUnresolvedConstructExprBits.NumArgs = NumArgs;\n  }\n\npublic:\n  static CXXUnresolvedConstructExpr *\n  Create(const ASTContext &Context, QualType T, TypeSourceInfo *TSI,\n         SourceLocation LParenLoc, ArrayRef<Expr *> Args,\n         SourceLocation RParenLoc, bool IsListInit);\n\n  static CXXUnresolvedConstructExpr *CreateEmpty(const ASTContext &Context,\n                                                 unsigned NumArgs);\n\n  /// Retrieve the type that is being constructed, as specified\n  /// in the source code.\n  QualType getTypeAsWritten() const { return getTypeSourceInfo()->getType(); }\n\n  /// Retrieve the type source information for the type being\n  /// constructed.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TypeAndInitForm.getPointer();\n  }\n\n  /// Retrieve the location of the left parentheses ('(') that\n  /// precedes the argument list.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  /// Retrieve the location of the right parentheses (')') that\n  /// follows the argument list.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  /// Determine whether this expression models list-initialization.\n  /// If so, there will be exactly one subexpression, which will be\n  /// an InitListExpr.\n  bool isListInitialization() const { return TypeAndInitForm.getInt(); }\n\n  /// Retrieve the number of arguments.\n  unsigned getNumArgs() const { return CXXUnresolvedConstructExprBits.NumArgs; }\n\n  using arg_iterator = Expr **;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n\n  arg_iterator arg_begin() { return getTrailingObjects<Expr *>(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n\n  using const_arg_iterator = const Expr* const *;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  const_arg_iterator arg_begin() const { return getTrailingObjects<Expr *>(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  Expr *getArg(unsigned I) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  const Expr *getArg(unsigned I) const {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  void setArg(unsigned I, Expr *E) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    arg_begin()[I] = E;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (!RParenLoc.isValid() && getNumArgs() > 0)\n      return getArg(getNumArgs() - 1)->getEndLoc();\n    return RParenLoc;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXUnresolvedConstructExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    auto **begin = reinterpret_cast<Stmt **>(arg_begin());\n    return child_range(begin, begin + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto **begin = reinterpret_cast<Stmt **>(\n        const_cast<CXXUnresolvedConstructExpr *>(this)->arg_begin());\n    return const_child_range(begin, begin + getNumArgs());\n  }\n};\n\n/// Represents a C++ member access expression where the actual\n/// member referenced could not be resolved because the base\n/// expression or the member name was dependent.\n///\n/// Like UnresolvedMemberExprs, these can be either implicit or\n/// explicit accesses.  It is only possible to get one of these with\n/// an implicit access if a qualifier is provided.\nclass CXXDependentScopeMemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXDependentScopeMemberExpr,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc, NamedDecl *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.  Can be null in implicit accesses.\n  Stmt *Base;\n\n  /// The type of the base expression.  Never null, even for\n  /// implicit accesses.\n  QualType BaseType;\n\n  /// The nested-name-specifier that precedes the member name, if any.\n  /// FIXME: This could be in principle store as a trailing object.\n  /// However the performance impact of doing so should be investigated first.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The member to which this member expression refers, which\n  /// can be name, overloaded operator, or destructor.\n  ///\n  /// FIXME: could also be a template-id\n  DeclarationNameInfo MemberNameInfo;\n\n  // CXXDependentScopeMemberExpr is followed by several trailing objects,\n  // some of which optional. They are in order:\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing location\n  //   information for the explicitly specified template arguments.\n  //\n  // * An optional NamedDecl *. In a qualified member access expression such\n  //   as t->Base::f, this member stores the resolves of name lookup in the\n  //   context of the member access expression, to be used at instantiation\n  //   time. Present if and only if hasFirstQualifierFoundInScope().\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  bool hasFirstQualifierFoundInScope() const {\n    return CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return getNumTemplateArgs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFirstQualifierFoundInScope();\n  }\n\n  CXXDependentScopeMemberExpr(const ASTContext &Ctx, Expr *Base,\n                              QualType BaseType, bool IsArrow,\n                              SourceLocation OperatorLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TemplateKWLoc,\n                              NamedDecl *FirstQualifierFoundInScope,\n                              DeclarationNameInfo MemberNameInfo,\n                              const TemplateArgumentListInfo *TemplateArgs);\n\n  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasTemplateKWAndArgsInfo,\n                              bool HasFirstQualifierFoundInScope);\n\npublic:\n  static CXXDependentScopeMemberExpr *\n  Create(const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,\n         SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,\n         DeclarationNameInfo MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs);\n\n  static CXXDependentScopeMemberExpr *\n  CreateEmpty(const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,\n              unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope);\n\n  /// True if this is an implicit access, i.e. one in which the\n  /// member being accessed was not written in the source.  The source\n  /// location of the operator is invalid in this case.\n  bool isImplicitAccess() const {\n    if (!Base)\n      return true;\n    return cast<Expr>(Base)->isImplicitCXXThis();\n  }\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return CXXDependentScopeMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const {\n    return CXXDependentScopeMemberExprBits.OperatorLoc;\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member\n  /// name, with source location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the first part of the nested-name-specifier that was\n  /// found in the scope of the member access expression when the member access\n  /// was initially parsed.\n  ///\n  /// This function only returns a useful result when member access expression\n  /// uses a qualified member name, e.g., \"x.Base::f\". Here, the declaration\n  /// returned by this function describes what was found by unqualified name\n  /// lookup for the identifier \"Base\" within the scope of the member access\n  /// expression itself. At template instantiation time, this information is\n  /// combined with the results of name lookup into the type of the object\n  /// expression itself (the class type of x).\n  NamedDecl *getFirstQualifierFoundInScope() const {\n    if (!hasFirstQualifierFoundInScope())\n      return nullptr;\n    return *getTrailingObjects<NamedDecl *>();\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const {\n    return MemberNameInfo;\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMember() const { return MemberNameInfo.getName(); }\n\n  // Retrieve the location of the name of the member that this\n  // expression refers to.\n  SourceLocation getMemberLoc() const { return MemberNameInfo.getLoc(); }\n\n  /// Retrieve the location of the template keyword preceding the\n  /// member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this member expression actually had a C++\n  /// template argument list explicitly specified, e.g., x.f<int>.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (getQualifier())\n      return getQualifierLoc().getBeginLoc();\n    return MemberNameInfo.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return MemberNameInfo.getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDependentScopeMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// Represents a C++ member access expression for which lookup\n/// produced a set of overloaded functions.\n///\n/// The member access may be explicit or implicit:\n/// \\code\n///    struct A {\n///      int a, b;\n///      int explicitAccess() { return this->a + this->A::b; }\n///      int implicitAccess() { return a + A::b; }\n///    };\n/// \\endcode\n///\n/// In the final AST, an explicit access always becomes a MemberExpr.\n/// An implicit access may become either a MemberExpr or a\n/// DeclRefExpr, depending on whether the member is static.\nclass UnresolvedMemberExpr final\n    : public OverloadExpr,\n      private llvm::TrailingObjects<UnresolvedMemberExpr, DeclAccessPair,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class OverloadExpr;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.\n  ///\n  /// This can be null if this is an 'unbased' member expression.\n  Stmt *Base;\n\n  /// The type of the base expression; never null.\n  QualType BaseType;\n\n  /// The location of the '->' or '.' operator.\n  SourceLocation OperatorLoc;\n\n  // UnresolvedMemberExpr is followed by several trailing objects.\n  // They are in order:\n  //\n  // * An array of getNumResults() DeclAccessPair for the results. These are\n  //   undesugared, which is to say, they may include UsingShadowDecls.\n  //   Access is relative to the naming class.\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing\n  //   location information for the explicitly specified template arguments.\n\n  UnresolvedMemberExpr(const ASTContext &Context, bool HasUnresolvedUsing,\n                       Expr *Base, QualType BaseType, bool IsArrow,\n                       SourceLocation OperatorLoc,\n                       NestedNameSpecifierLoc QualifierLoc,\n                       SourceLocation TemplateKWLoc,\n                       const DeclarationNameInfo &MemberNameInfo,\n                       const TemplateArgumentListInfo *TemplateArgs,\n                       UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  UnresolvedMemberExpr(EmptyShell Empty, unsigned NumResults,\n                       bool HasTemplateKWAndArgsInfo);\n\n  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {\n    return getNumDecls();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\npublic:\n  static UnresolvedMemberExpr *\n  Create(const ASTContext &Context, bool HasUnresolvedUsing, Expr *Base,\n         QualType BaseType, bool IsArrow, SourceLocation OperatorLoc,\n         NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,\n         const DeclarationNameInfo &MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs,\n         UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  static UnresolvedMemberExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumResults,\n                                           bool HasTemplateKWAndArgsInfo,\n                                           unsigned NumTemplateArgs);\n\n  /// True if this is an implicit access, i.e., one in which the\n  /// member being accessed was not written in the source.\n  ///\n  /// The source location of the operator is invalid in this case.\n  bool isImplicitAccess() const;\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n  const Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether the lookup results contain an unresolved using\n  /// declaration.\n  bool hasUnresolvedUsing() const {\n    return UnresolvedMemberExprBits.HasUnresolvedUsing;\n  }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return UnresolvedMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the naming class of this lookup.\n  CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<UnresolvedMemberExpr *>(this)->getNamingClass();\n  }\n\n  /// Retrieve the full name info for the member that this expression\n  /// refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const { return getNameInfo(); }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMemberName() const { return getName(); }\n\n  /// Retrieve the location of the name of the member that this\n  /// expression refers to.\n  SourceLocation getMemberLoc() const { return getNameLoc(); }\n\n  /// Return the preferred location (the member name) for the arrow when\n  /// diagnosing a problem with this expression.\n  SourceLocation getExprLoc() const LLVM_READONLY { return getMemberLoc(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (NestedNameSpecifierLoc l = getQualifierLoc())\n      return l.getBeginLoc();\n    return getMemberNameInfo().getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getMemberNameInfo().getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\nDeclAccessPair *OverloadExpr::getTrailingResults() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<DeclAccessPair>();\n  return cast<UnresolvedMemberExpr>(this)->getTrailingObjects<DeclAccessPair>();\n}\n\nASTTemplateKWAndArgsInfo *OverloadExpr::getTrailingASTTemplateKWAndArgsInfo() {\n  if (!hasTemplateKWAndArgsInfo())\n    return nullptr;\n\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n}\n\nTemplateArgumentLoc *OverloadExpr::getTrailingTemplateArgumentLoc() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<TemplateArgumentLoc>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<TemplateArgumentLoc>();\n}\n\nCXXRecordDecl *OverloadExpr::getNamingClass() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getNamingClass();\n  return cast<UnresolvedMemberExpr>(this)->getNamingClass();\n}\n\n/// Represents a C++11 noexcept expression (C++ [expr.unary.noexcept]).\n///\n/// The noexcept expression tests whether a given expression might throw. Its\n/// result is a boolean constant.\nclass CXXNoexceptExpr : public Expr {\n  friend class ASTStmtReader;\n\n  Stmt *Operand;\n  SourceRange Range;\n\npublic:\n  CXXNoexceptExpr(QualType Ty, Expr *Operand, CanThrowResult Val,\n                  SourceLocation Keyword, SourceLocation RParen)\n      : Expr(CXXNoexceptExprClass, Ty, VK_PRValue, OK_Ordinary),\n        Operand(Operand), Range(Keyword, RParen) {\n    CXXNoexceptExprBits.Value = Val == CT_Cannot;\n    setDependence(computeDependence(this, Val));\n  }\n\n  CXXNoexceptExpr(EmptyShell Empty) : Expr(CXXNoexceptExprClass, Empty) {}\n\n  Expr *getOperand() const { return static_cast<Expr *>(Operand); }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n  SourceRange getSourceRange() const { return Range; }\n\n  bool getValue() const { return CXXNoexceptExprBits.Value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNoexceptExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Operand, &Operand + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, &Operand + 1);\n  }\n};\n\n/// Represents a C++11 pack expansion that produces a sequence of\n/// expressions.\n///\n/// A pack expansion expression contains a pattern (which itself is an\n/// expression) followed by an ellipsis. For example:\n///\n/// \\code\n/// template<typename F, typename ...Types>\n/// void forward(F f, Types &&...args) {\n///   f(static_cast<Types&&>(args)...);\n/// }\n/// \\endcode\n///\n/// Here, the argument to the function object \\c f is a pack expansion whose\n/// pattern is \\c static_cast<Types&&>(args). When the \\c forward function\n/// template is instantiated, the pack expansion will instantiate to zero or\n/// or more function arguments to the function object \\c f.\nclass PackExpansionExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  SourceLocation EllipsisLoc;\n\n  /// The number of expansions that will be produced by this pack\n  /// expansion expression, if known.\n  ///\n  /// When zero, the number of expansions is not known. Otherwise, this value\n  /// is the number of expansions + 1.\n  unsigned NumExpansions;\n\n  Stmt *Pattern;\n\npublic:\n  PackExpansionExpr(QualType T, Expr *Pattern, SourceLocation EllipsisLoc,\n                    std::optional<unsigned> NumExpansions)\n      : Expr(PackExpansionExprClass, T, Pattern->getValueKind(),\n             Pattern->getObjectKind()),\n        EllipsisLoc(EllipsisLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0),\n        Pattern(Pattern) {\n    setDependence(computeDependence(this));\n  }\n\n  PackExpansionExpr(EmptyShell Empty) : Expr(PackExpansionExprClass, Empty) {}\n\n  /// Retrieve the pattern of the pack expansion.\n  Expr *getPattern() { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the pattern of the pack expansion.\n  const Expr *getPattern() const { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the location of the ellipsis that describes this pack\n  /// expansion.\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// Determine the number of expansions that will be produced when\n  /// this pack expansion is instantiated, if already known.\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Pattern->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return EllipsisLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PackExpansionExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&Pattern, &Pattern + 1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Pattern, &Pattern + 1);\n  }\n};\n\n/// Represents an expression that computes the length of a parameter\n/// pack.\n///\n/// \\code\n/// template<typename ...Types>\n/// struct count {\n///   static const unsigned value = sizeof...(Types);\n/// };\n/// \\endcode\nclass SizeOfPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<SizeOfPackExpr, TemplateArgument> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The location of the \\c sizeof keyword.\n  SourceLocation OperatorLoc;\n\n  /// The location of the name of the parameter pack.\n  SourceLocation PackLoc;\n\n  /// The location of the closing parenthesis.\n  SourceLocation RParenLoc;\n\n  /// The length of the parameter pack, if known.\n  ///\n  /// When this expression is not value-dependent, this is the length of\n  /// the pack. When the expression was parsed rather than instantiated\n  /// (and thus is value-dependent), this is zero.\n  ///\n  /// After partial substitution into a sizeof...(X) expression (for instance,\n  /// within an alias template or during function template argument deduction),\n  /// we store a trailing array of partially-substituted TemplateArguments,\n  /// and this is the length of that array.\n  unsigned Length;\n\n  /// The parameter pack.\n  NamedDecl *Pack = nullptr;\n\n  /// Create an expression that computes the length of\n  /// the given parameter pack.\n  SizeOfPackExpr(QualType SizeType, SourceLocation OperatorLoc, NamedDecl *Pack,\n                 SourceLocation PackLoc, SourceLocation RParenLoc,\n                 std::optional<unsigned> Length,\n                 ArrayRef<TemplateArgument> PartialArgs)\n      : Expr(SizeOfPackExprClass, SizeType, VK_PRValue, OK_Ordinary),\n        OperatorLoc(OperatorLoc), PackLoc(PackLoc), RParenLoc(RParenLoc),\n        Length(Length ? *Length : PartialArgs.size()), Pack(Pack) {\n    assert((!Length || PartialArgs.empty()) &&\n           \"have partial args for non-dependent sizeof... expression\");\n    auto *Args = getTrailingObjects<TemplateArgument>();\n    std::uninitialized_copy(PartialArgs.begin(), PartialArgs.end(), Args);\n    setDependence(Length ? ExprDependence::None\n                         : ExprDependence::ValueInstantiation);\n  }\n\n  /// Create an empty expression.\n  SizeOfPackExpr(EmptyShell Empty, unsigned NumPartialArgs)\n      : Expr(SizeOfPackExprClass, Empty), Length(NumPartialArgs) {}\n\npublic:\n  static SizeOfPackExpr *\n  Create(ASTContext &Context, SourceLocation OperatorLoc, NamedDecl *Pack,\n         SourceLocation PackLoc, SourceLocation RParenLoc,\n         std::optional<unsigned> Length = std::nullopt,\n         ArrayRef<TemplateArgument> PartialArgs = std::nullopt);\n  static SizeOfPackExpr *CreateDeserialized(ASTContext &Context,\n                                            unsigned NumPartialArgs);\n\n  /// Determine the location of the 'sizeof' keyword.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Determine the location of the parameter pack.\n  SourceLocation getPackLoc() const { return PackLoc; }\n\n  /// Determine the location of the right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Retrieve the parameter pack.\n  NamedDecl *getPack() const { return Pack; }\n\n  /// Retrieve the length of the parameter pack.\n  ///\n  /// This routine may only be invoked when the expression is not\n  /// value-dependent.\n  unsigned getPackLength() const {\n    assert(!isValueDependent() &&\n           \"Cannot get the length of a value-dependent pack size expression\");\n    return Length;\n  }\n\n  /// Determine whether this represents a partially-substituted sizeof...\n  /// expression, such as is produced for:\n  ///\n  ///   template<typename ...Ts> using X = int[sizeof...(Ts)];\n  ///   template<typename ...Us> void f(X<Us..., 1, 2, 3, Us...>);\n  bool isPartiallySubstituted() const {\n    return isValueDependent() && Length;\n  }\n\n  /// Get\n  ArrayRef<TemplateArgument> getPartialArguments() const {\n    assert(isPartiallySubstituted());\n    const auto *Args = getTrailingObjects<TemplateArgument>();\n    return llvm::ArrayRef(Args, Args + Length);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SizeOfPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a non-type template parameter\n/// that has been substituted with a template argument.\nclass SubstNonTypeTemplateParmExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The replacement expression.\n  Stmt *Replacement;\n\n  /// The associated declaration and a flag indicating if it was a reference\n  /// parameter. For class NTTPs, we can't determine that based on the value\n  /// category alone.\n  llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndRef;\n\n  unsigned Index : 15;\n  unsigned PackIndex : 16;\n\n  explicit SubstNonTypeTemplateParmExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmExpr(QualType Ty, ExprValueKind ValueKind,\n                               SourceLocation Loc, Expr *Replacement,\n                               Decl *AssociatedDecl, unsigned Index,\n                               std::optional<unsigned> PackIndex, bool RefParam)\n      : Expr(SubstNonTypeTemplateParmExprClass, Ty, ValueKind, OK_Ordinary),\n        Replacement(Replacement),\n        AssociatedDeclAndRef(AssociatedDecl, RefParam), Index(Index),\n        PackIndex(PackIndex ? *PackIndex + 1 : 0) {\n    assert(AssociatedDecl != nullptr);\n    SubstNonTypeTemplateParmExprBits.NameLoc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  SourceLocation getNameLoc() const {\n    return SubstNonTypeTemplateParmExprBits.NameLoc;\n  }\n  SourceLocation getBeginLoc() const { return getNameLoc(); }\n  SourceLocation getEndLoc() const { return getNameLoc(); }\n\n  Expr *getReplacement() const { return cast<Expr>(Replacement); }\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDeclAndRef.getPointer(); }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameter()->getIndex()`.\n  unsigned getIndex() const { return Index; }\n\n  std::optional<unsigned> getPackIndex() const {\n    if (PackIndex == 0)\n      return std::nullopt;\n    return PackIndex - 1;\n  }\n\n  NonTypeTemplateParmDecl *getParameter() const;\n\n  bool isReferenceParameter() const { return AssociatedDeclAndRef.getInt(); }\n\n  /// Determine the substituted type of the template parameter.\n  QualType getParameterType(const ASTContext &Ctx) const;\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == SubstNonTypeTemplateParmExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Replacement, &Replacement + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Replacement, &Replacement + 1);\n  }\n};\n\n/// Represents a reference to a non-type template parameter pack that\n/// has been substituted with a non-template argument pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this node is used to represent a non-type template\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the appropriate underlying\n/// expression at the current pack substitution index.\nclass SubstNonTypeTemplateParmPackExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The non-type template parameter pack itself.\n  Decl *AssociatedDecl;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in \\c Arguments.\n  unsigned NumArguments : 16;\n\n  unsigned Index : 16;\n\n  /// The location of the non-type template parameter pack reference.\n  SourceLocation NameLoc;\n\n  explicit SubstNonTypeTemplateParmPackExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmPackExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmPackExpr(QualType T, ExprValueKind ValueKind,\n                                   SourceLocation NameLoc,\n                                   const TemplateArgument &ArgPack,\n                                   Decl *AssociatedDecl, unsigned Index);\n\n  /// A template-like entity which owns the whole pattern being substituted.\n  /// This will own a set of template parameters.\n  Decl *getAssociatedDecl() const { return AssociatedDecl; }\n\n  /// Returns the index of the replaced parameter in the associated declaration.\n  /// This should match the result of `getParameterPack()->getIndex()`.\n  unsigned getIndex() const { return Index; }\n\n  /// Retrieve the non-type template parameter pack being substituted.\n  NonTypeTemplateParmDecl *getParameterPack() const;\n\n  /// Retrieve the location of the parameter pack name.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Retrieve the template argument pack containing the substituted\n  /// template arguments.\n  TemplateArgument getArgumentPack() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SubstNonTypeTemplateParmPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a function parameter pack or init-capture pack\n/// that has been substituted but not yet expanded.\n///\n/// When a pack expansion contains multiple parameter packs at different levels,\n/// this node is used to represent a function parameter pack at an outer level\n/// which we have already substituted to refer to expanded parameters, but where\n/// the containing pack expansion cannot yet be expanded.\n///\n/// \\code\n/// template<typename...Ts> struct S {\n///   template<typename...Us> auto f(Ts ...ts) -> decltype(g(Us(ts)...));\n/// };\n/// template struct S<int, int>;\n/// \\endcode\nclass FunctionParmPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<FunctionParmPackExpr, VarDecl *> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The function parameter pack which was referenced.\n  VarDecl *ParamPack;\n\n  /// The location of the function parameter pack reference.\n  SourceLocation NameLoc;\n\n  /// The number of expansions of this pack.\n  unsigned NumParameters;\n\n  FunctionParmPackExpr(QualType T, VarDecl *ParamPack,\n                       SourceLocation NameLoc, unsigned NumParams,\n                       VarDecl *const *Params);\n\npublic:\n  static FunctionParmPackExpr *Create(const ASTContext &Context, QualType T,\n                                      VarDecl *ParamPack,\n                                      SourceLocation NameLoc,\n                                      ArrayRef<VarDecl *> Params);\n  static FunctionParmPackExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumParams);\n\n  /// Get the parameter pack which this expression refers to.\n  VarDecl *getParameterPack() const { return ParamPack; }\n\n  /// Get the location of the parameter pack.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Iterators over the parameters which the parameter pack expanded\n  /// into.\n  using iterator = VarDecl * const *;\n  iterator begin() const { return getTrailingObjects<VarDecl *>(); }\n  iterator end() const { return begin() + NumParameters; }\n\n  /// Get the number of parameters in this parameter pack.\n  unsigned getNumExpansions() const { return NumParameters; }\n\n  /// Get an expansion of the parameter pack by index.\n  VarDecl *getExpansion(unsigned I) const { return begin()[I]; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FunctionParmPackExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a prvalue temporary that is written into memory so that\n/// a reference can bind to it.\n///\n/// Prvalue expressions are materialized when they need to have an address\n/// in memory for a reference to bind to. This happens when binding a\n/// reference to the result of a conversion, e.g.,\n///\n/// \\code\n/// const int &r = 1.0;\n/// \\endcode\n///\n/// Here, 1.0 is implicitly converted to an \\c int. That resulting \\c int is\n/// then materialized via a \\c MaterializeTemporaryExpr, and the reference\n/// binds to the temporary. \\c MaterializeTemporaryExprs are always glvalues\n/// (either an lvalue or an xvalue, depending on the kind of reference binding\n/// to it), maintaining the invariant that references always bind to glvalues.\n///\n/// Reference binding and copy-elision can both extend the lifetime of a\n/// temporary. When either happens, the expression will also track the\n/// declaration which is responsible for the lifetime extension.\nclass MaterializeTemporaryExpr : public Expr {\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  llvm::PointerUnion<Stmt *, LifetimeExtendedTemporaryDecl *> State;\n\npublic:\n  MaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                           bool BoundToLvalueReference,\n                           LifetimeExtendedTemporaryDecl *MTD = nullptr);\n\n  MaterializeTemporaryExpr(EmptyShell Empty)\n      : Expr(MaterializeTemporaryExprClass, Empty) {}\n\n  /// Retrieve the temporary-generating subexpression whose value will\n  /// be materialized into a glvalue.\n  Expr *getSubExpr() const {\n    return cast<Expr>(\n        State.is<Stmt *>()\n            ? State.get<Stmt *>()\n            : State.get<LifetimeExtendedTemporaryDecl *>()->getTemporaryExpr());\n  }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const {\n    return State.is<Stmt *>() ? SD_FullExpression\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getStorageDuration();\n  }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const {\n    assert(State.is<LifetimeExtendedTemporaryDecl *>() &&\n           \"the temporary has not been lifetime extended\");\n    return State.get<LifetimeExtendedTemporaryDecl *>()->getOrCreateValue(\n        MayCreate);\n  }\n\n  LifetimeExtendedTemporaryDecl *getLifetimeExtendedTemporaryDecl() {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n  const LifetimeExtendedTemporaryDecl *\n  getLifetimeExtendedTemporaryDecl() const {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n\n  /// Get the declaration which triggered the lifetime-extension of this\n  /// temporary, if any.\n  ValueDecl *getExtendingDecl() {\n    return State.is<Stmt *>() ? nullptr\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getExtendingDecl();\n  }\n  const ValueDecl *getExtendingDecl() const {\n    return const_cast<MaterializeTemporaryExpr *>(this)->getExtendingDecl();\n  }\n\n  void setExtendingDecl(ValueDecl *ExtendedBy, unsigned ManglingNumber);\n\n  unsigned getManglingNumber() const {\n    return State.is<Stmt *>() ? 0\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getManglingNumber();\n  }\n\n  /// Determine whether this materialized temporary is bound to an\n  /// lvalue reference; otherwise, it's bound to an rvalue reference.\n  bool isBoundToLvalueReference() const { return isLValue(); }\n\n  /// Determine whether this temporary object is usable in constant\n  /// expressions, as specified in C++20 [expr.const]p4.\n  bool isUsableInConstantExpressions(const ASTContext &Context) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MaterializeTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return State.is<Stmt *>()\n               ? child_range(State.getAddrOfPtr1(), State.getAddrOfPtr1() + 1)\n               : State.get<LifetimeExtendedTemporaryDecl *>()->childrenExpr();\n  }\n\n  const_child_range children() const {\n    return State.is<Stmt *>()\n               ? const_child_range(State.getAddrOfPtr1(),\n                                   State.getAddrOfPtr1() + 1)\n               : const_cast<const LifetimeExtendedTemporaryDecl *>(\n                     State.get<LifetimeExtendedTemporaryDecl *>())\n                     ->childrenExpr();\n  }\n};\n\n/// Represents a folding of a pack over an operator.\n///\n/// This expression is always dependent and represents a pack expansion of the\n/// forms:\n///\n///    ( expr op ... )\n///    ( ... op expr )\n///    ( expr op ... op expr )\nclass CXXFoldExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  enum SubExpr { Callee, LHS, RHS, Count };\n\n  SourceLocation LParenLoc;\n  SourceLocation EllipsisLoc;\n  SourceLocation RParenLoc;\n  // When 0, the number of expansions is not known. Otherwise, this is one more\n  // than the number of expansions.\n  unsigned NumExpansions;\n  Stmt *SubExprs[SubExpr::Count];\n  BinaryOperatorKind Opcode;\n\npublic:\n  CXXFoldExpr(QualType T, UnresolvedLookupExpr *Callee,\n              SourceLocation LParenLoc, Expr *LHS, BinaryOperatorKind Opcode,\n              SourceLocation EllipsisLoc, Expr *RHS, SourceLocation RParenLoc,\n              std::optional<unsigned> NumExpansions)\n      : Expr(CXXFoldExprClass, T, VK_PRValue, OK_Ordinary),\n        LParenLoc(LParenLoc), EllipsisLoc(EllipsisLoc), RParenLoc(RParenLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0), Opcode(Opcode) {\n    SubExprs[SubExpr::Callee] = Callee;\n    SubExprs[SubExpr::LHS] = LHS;\n    SubExprs[SubExpr::RHS] = RHS;\n    setDependence(computeDependence(this));\n  }\n\n  CXXFoldExpr(EmptyShell Empty) : Expr(CXXFoldExprClass, Empty) {}\n\n  UnresolvedLookupExpr *getCallee() const {\n    return static_cast<UnresolvedLookupExpr *>(SubExprs[SubExpr::Callee]);\n  }\n  Expr *getLHS() const { return static_cast<Expr*>(SubExprs[SubExpr::LHS]); }\n  Expr *getRHS() const { return static_cast<Expr*>(SubExprs[SubExpr::RHS]); }\n\n  /// Does this produce a right-associated sequence of operators?\n  bool isRightFold() const {\n    return getLHS() && getLHS()->containsUnexpandedParameterPack();\n  }\n\n  /// Does this produce a left-associated sequence of operators?\n  bool isLeftFold() const { return !isRightFold(); }\n\n  /// Get the pattern, that is, the operand that contains an unexpanded pack.\n  Expr *getPattern() const { return isLeftFold() ? getRHS() : getLHS(); }\n\n  /// Get the operand that doesn't contain a pack, for a binary fold.\n  Expr *getInit() const { return isLeftFold() ? getLHS() : getRHS(); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  BinaryOperatorKind getOperator() const { return Opcode; }\n\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (LParenLoc.isValid())\n      return LParenLoc;\n    if (isLeftFold())\n      return getEllipsisLoc();\n    return getLHS()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (RParenLoc.isValid())\n      return RParenLoc;\n    if (isRightFold())\n      return getEllipsisLoc();\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFoldExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n};\n\n/// Represents a list-initialization with parenthesis.\n///\n/// As per P0960R3, this is a C++20 feature that allows aggregate to\n/// be initialized with a parenthesized list of values:\n/// ```\n/// struct A {\n///   int a;\n///   double b;\n/// };\n///\n/// void foo() {\n///   A a1(0);        // Well-formed in C++20\n///   A a2(1.5, 1.0); // Well-formed in C++20\n/// }\n/// ```\n/// It has some sort of similiarity to braced\n/// list-initialization, with some differences such as\n/// it allows narrowing conversion whilst braced\n/// list-initialization doesn't.\n/// ```\n/// struct A {\n///   char a;\n/// };\n/// void foo() {\n///   A a(1.5); // Well-formed in C++20\n///   A b{1.5}; // Ill-formed !\n/// }\n/// ```\nclass CXXParenListInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXParenListInitExpr, Expr *> {\n  friend class TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  unsigned NumExprs;\n  unsigned NumUserSpecifiedExprs;\n  SourceLocation InitLoc, LParenLoc, RParenLoc;\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\n  CXXParenListInitExpr(ArrayRef<Expr *> Args, QualType T,\n                       unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n                       SourceLocation LParenLoc, SourceLocation RParenLoc)\n      : Expr(CXXParenListInitExprClass, T, getValueKindForType(T), OK_Ordinary),\n        NumExprs(Args.size()), NumUserSpecifiedExprs(NumUserSpecifiedExprs),\n        InitLoc(InitLoc), LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    std::copy(Args.begin(), Args.end(), getTrailingObjects<Expr *>());\n    assert(NumExprs >= NumUserSpecifiedExprs &&\n           \"number of user specified inits is greater than the number of \"\n           \"passed inits\");\n    setDependence(computeDependence(this));\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const { return NumExprs; }\n\npublic:\n  static CXXParenListInitExpr *\n  Create(ASTContext &C, ArrayRef<Expr *> Args, QualType T,\n         unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n         SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  static CXXParenListInitExpr *CreateEmpty(ASTContext &C, unsigned numExprs,\n                                           EmptyShell Empty);\n\n  explicit CXXParenListInitExpr(EmptyShell Empty, unsigned NumExprs)\n      : Expr(CXXParenListInitExprClass, Empty), NumExprs(NumExprs),\n        NumUserSpecifiedExprs(0) {}\n\n  void updateDependence() { setDependence(computeDependence(this)); }\n\n  ArrayRef<Expr *> getInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  const ArrayRef<Expr *> getInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  ArrayRef<Expr *> getUserSpecifiedInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  const ArrayRef<Expr *> getUserSpecifiedInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getInitLoc() const LLVM_READONLY { return InitLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  void setArrayFiller(Expr *E) { ArrayFillerOrUnionFieldInit = E; }\n\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  const Expr *getArrayFiller() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumExprs);\n  }\n\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumExprs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXParenListInitExprClass;\n  }\n};\n\n/// Represents an expression that might suspend coroutine execution;\n/// either a co_await or co_yield expression.\n///\n/// Evaluation of this expression first evaluates its 'ready' expression. If\n/// that returns 'false':\n///  -- execution of the coroutine is suspended\n///  -- the 'suspend' expression is evaluated\n///     -- if the 'suspend' expression returns 'false', the coroutine is\n///        resumed\n///     -- otherwise, control passes back to the resumer.\n/// If the coroutine is not suspended, or when it is resumed, the 'resume'\n/// expression is evaluated, and its result is the result of the overall\n/// expression.\nclass CoroutineSuspendExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n\n  enum SubExpr { Operand, Common, Ready, Suspend, Resume, Count };\n\n  Stmt *SubExprs[SubExpr::Count];\n  OpaqueValueExpr *OpaqueValue = nullptr;\n\npublic:\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, Expr *Operand,\n                       Expr *Common, Expr *Ready, Expr *Suspend, Expr *Resume,\n                       OpaqueValueExpr *OpaqueValue)\n      : Expr(SC, Resume->getType(), Resume->getValueKind(),\n             Resume->getObjectKind()),\n        KeywordLoc(KeywordLoc), OpaqueValue(OpaqueValue) {\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = Ready;\n    SubExprs[SubExpr::Suspend] = Suspend;\n    SubExprs[SubExpr::Resume] = Resume;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, QualType Ty,\n                       Expr *Operand, Expr *Common)\n      : Expr(SC, Ty, VK_PRValue, OK_Ordinary), KeywordLoc(KeywordLoc) {\n    assert(Common->isTypeDependent() && Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    SubExprs[SubExpr::Operand] = nullptr;\n    SubExprs[SubExpr::Common] = nullptr;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n  }\n\n  Expr *getCommonExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Common]);\n  }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  Expr *getReadyExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Ready]);\n  }\n\n  Expr *getSuspendExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Suspend]);\n  }\n\n  Expr *getResumeExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Resume]);\n  }\n\n  // The syntactic operand written in the code\n  Expr *getOperand() const {\n    return static_cast<Expr *>(SubExprs[SubExpr::Operand]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass ||\n           T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression.\nclass CoawaitExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoawaitExpr(SourceLocation CoawaitLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(SourceLocation CoawaitLoc, QualType Ty, Expr *Operand,\n              Expr *Common, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Ty, Operand,\n                             Common) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoawaitExprClass, Empty) {}\n\n  bool isImplicit() const { return CoawaitBits.IsImplicit; }\n  void setIsImplicit(bool value = true) { CoawaitBits.IsImplicit = value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression while the type of the promise\n/// is dependent.\nclass DependentCoawaitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n  Stmt *SubExprs[2];\n\npublic:\n  DependentCoawaitExpr(SourceLocation KeywordLoc, QualType Ty, Expr *Op,\n                       UnresolvedLookupExpr *OpCoawait)\n      : Expr(DependentCoawaitExprClass, Ty, VK_PRValue, OK_Ordinary),\n        KeywordLoc(KeywordLoc) {\n    // NOTE: A co_await expression is dependent on the coroutines promise\n    // type and may be dependent even when the `Op` expression is not.\n    assert(Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[0] = Op;\n    SubExprs[1] = OpCoawait;\n    setDependence(computeDependence(this));\n  }\n\n  DependentCoawaitExpr(EmptyShell Empty)\n      : Expr(DependentCoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const { return cast<Expr>(SubExprs[0]); }\n\n  UnresolvedLookupExpr *getOperatorCoawaitLookup() const {\n    return cast<UnresolvedLookupExpr>(SubExprs[1]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() { return child_range(SubExprs, SubExprs + 2); }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentCoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_yield' expression.\nclass CoyieldExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoyieldExpr(SourceLocation CoyieldLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {}\n  CoyieldExpr(SourceLocation CoyieldLoc, QualType Ty, Expr *Operand,\n              Expr *Common)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Ty, Operand,\n                             Common) {}\n  CoyieldExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoyieldExprClass, Empty) {}\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a C++2a __builtin_bit_cast(T, v) expression. Used to implement\n/// std::bit_cast. These can sometimes be evaluated as part of a constant\n/// expression, but otherwise CodeGen to a simple memcpy in general.\nclass BuiltinBitCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<BuiltinBitCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation KWLoc;\n  SourceLocation RParenLoc;\n\npublic:\n  BuiltinBitCastExpr(QualType T, ExprValueKind VK, CastKind CK, Expr *SrcExpr,\n                     TypeSourceInfo *DstType, SourceLocation KWLoc,\n                     SourceLocation RParenLoc)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, T, VK, CK, SrcExpr, 0, false,\n                         DstType),\n        KWLoc(KWLoc), RParenLoc(RParenLoc) {}\n  BuiltinBitCastExpr(EmptyShell Empty)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, Empty, 0, false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KWLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BuiltinBitCastExprClass;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-10618",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 3501,
  "validation_status": "validated"
}