{
  "code": "{\n  CodeGenModule &CGM;\n\n  struct StorageEntry {\n    CharUnits Begin;\n    CharUnits End;\n    llvm::Type *Type;\n\n    CharUnits getWidth() const {\n      return End - Begin;\n    }\n  };\n  SmallVector<StorageEntry, 4> Entries;\n  bool Finished = false;\n\npublic:\n  SwiftAggLowering(CodeGenModule &CGM) : CGM(CGM) {}\n\n  void addOpaqueData(CharUnits begin, CharUnits end) {\n    addEntry(nullptr, begin, end);\n  }\n\n  void addTypedData(QualType type, CharUnits begin);\n  void addTypedData(const RecordDecl *record, CharUnits begin);\n  void addTypedData(const RecordDecl *record, CharUnits begin,\n                    const ASTRecordLayout &layout);\n  void addTypedData(llvm::Type *type, CharUnits begin);\n  void addTypedData(llvm::Type *type, CharUnits begin, CharUnits end);\n\n  void finish();\n\n  /// Does this lowering require passing any data?\n  bool empty() const {\n    assert(Finished && \"didn't finish lowering before calling empty()\");\n    return Entries.empty();\n  }\n\n  /// According to the target Swift ABI, should a value with this lowering\n  /// be passed indirectly?\n  ///\n  /// Note that this decision is based purely on the data layout of the\n  /// value and does not consider whether the type is address-only,\n  /// must be passed indirectly to match a function abstraction pattern, or\n  /// anything else that is expected to be handled by high-level lowering.\n  ///\n  /// \\param asReturnValue - if true, answer whether it should be passed\n  ///   indirectly as a return value; if false, answer whether it should be\n  ///   passed indirectly as an argument\n  bool shouldPassIndirectly(bool asReturnValue) const;\n\n  using EnumerationCallback =\n    llvm::function_ref<void(CharUnits offset, CharUnits end, llvm::Type *type)>;\n\n  /// Enumerate the expanded components of this type.\n  ///\n  /// The component types will always be legal vector, floating-point,\n  /// integer, or pointer types.\n  void enumerateComponents(EnumerationCallback callback) const;\n\n  /// Return the types for a coerce-and-expand operation.\n  ///\n  /// The first type matches the memory layout of the data that's been\n  /// added to this structure, including explicit [N x i8] arrays for any\n  /// internal padding.\n  ///\n  /// The second type removes any internal padding members and, if only\n  /// one element remains, is simply that element type.\n  std::pair<llvm::StructType*, llvm::Type*> getCoerceAndExpandTypes() const;\n\nprivate:\n  void addBitFieldData(const FieldDecl *field, CharUnits begin,\n                       uint64_t bitOffset);\n  void addLegalTypedData(llvm::Type *type, CharUnits begin, CharUnits end);\n  void addEntry(llvm::Type *type, CharUnits begin, CharUnits end);\n  void splitVectorEntry(unsigned index);\n  static bool shouldMergeEntries(const StorageEntry &first,\n                                 const StorageEntry &second,\n                                 CharUnits chunkSize);\n}",
  "id": "BLOCK-CPP-17607",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/SwiftCallingConv.h",
  "source_line": 41,
  "validation_status": "validated"
}