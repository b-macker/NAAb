{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// bind_front()\n//\n// Binds the first N arguments of an invocable object and stores them by value.\n//\n// Like `std::bind()`, `absl::bind_front()` is implicitly convertible to\n// `std::function`.  In particular, it may be used as a simpler replacement for\n// `std::bind()` in most cases, as it does not require placeholders to be\n// specified. More importantly, it provides more reliable correctness guarantees\n// than `std::bind()`; while `std::bind()` will silently ignore passing more\n// parameters than expected, for example, `absl::bind_front()` will report such\n// mis-uses as errors. In C++20, `absl::bind_front` is replaced by\n// `std::bind_front`.\n//\n// absl::bind_front(a...) can be seen as storing the results of\n// std::make_tuple(a...).\n//\n// Example: Binding a free function.\n//\n//   int Minus(int a, int b) { return a - b; }\n//\n//   assert(absl::bind_front(Minus)(3, 2) == 3 - 2);\n//   assert(absl::bind_front(Minus, 3)(2) == 3 - 2);\n//   assert(absl::bind_front(Minus, 3, 2)() == 3 - 2);\n//\n// Example: Binding a member function.\n//\n//   struct Math {\n//     int Double(int a) const { return 2 * a; }\n//   };\n//\n//   Math math;\n//\n//   assert(absl::bind_front(&Math::Double)(&math, 3) == 2 * 3);\n//   // Stores a pointer to math inside the functor.\n//   assert(absl::bind_front(&Math::Double, &math)(3) == 2 * 3);\n//   // Stores a copy of math inside the functor.\n//   assert(absl::bind_front(&Math::Double, math)(3) == 2 * 3);\n//   // Stores std::unique_ptr<Math> inside the functor.\n//   assert(absl::bind_front(&Math::Double,\n//                           std::unique_ptr<Math>(new Math))(3) == 2 * 3);\n//\n// Example: Using `absl::bind_front()`, instead of `std::bind()`, with\n//          `std::function`.\n//\n//   class FileReader {\n//    public:\n//     void ReadFileAsync(const std::string& filename, std::string* content,\n//                        const std::function<void()>& done) {\n//       // Calls Executor::Schedule(std::function<void()>).\n//       Executor::DefaultExecutor()->Schedule(\n//           absl::bind_front(&FileReader::BlockingRead, this,\n//                            filename, content, done));\n//     }\n//\n//    private:\n//     void BlockingRead(const std::string& filename, std::string* content,\n//                       const std::function<void()>& done) {\n//       CHECK_OK(file::GetContents(filename, content, {}));\n//       done();\n//     }\n//   };\n//\n// `absl::bind_front()` stores bound arguments explicitly using the type passed\n// rather than implicitly based on the type accepted by its functor.\n//\n// Example: Binding arguments explicitly.\n//\n//   void LogStringView(absl::string_view sv) {\n//     LOG(INFO) << sv;\n//   }\n//\n//   Executor* e = Executor::DefaultExecutor();\n//   std::string s = \"hello\";\n//   absl::string_view sv = s;\n//\n//   // absl::bind_front(LogStringView, arg) makes a copy of arg and stores it.\n//   e->Schedule(absl::bind_front(LogStringView, sv)); // ERROR: dangling\n//                                                     // string_view.\n//\n//   e->Schedule(absl::bind_front(LogStringView, s));  // OK: stores a copy of\n//                                                     // s.\n//\n// To store some of the arguments passed to `absl::bind_front()` by reference,\n//  use std::ref()` and `std::cref()`.\n//\n// Example: Storing some of the bound arguments by reference.\n//\n//   class Service {\n//    public:\n//     void Serve(const Request& req, std::function<void()>* done) {\n//       // The request protocol buffer won't be deleted until done is called.\n//       // It's safe to store a reference to it inside the functor.\n//       Executor::DefaultExecutor()->Schedule(\n//           absl::bind_front(&Service::BlockingServe, this, std::cref(req),\n//           done));\n//     }\n//\n//    private:\n//     void BlockingServe(const Request& req, std::function<void()>* done);\n//   };\n//\n// Example: Storing bound arguments by reference.\n//\n//   void Print(const std::string& a, const std::string& b) {\n//     std::cerr << a << b;\n//   }\n//\n//   std::string hi = \"Hello, \";\n//   std::vector<std::string> names = {\"Chuk\", \"Gek\"};\n//   // Doesn't copy hi.\n//   for_each(names.begin(), names.end(),\n//            absl::bind_front(Print, std::ref(hi)));\n//\n//   // DO NOT DO THIS: the functor may outlive \"hi\", resulting in\n//   // dangling references.\n//   foo->DoInFuture(absl::bind_front(Print, std::ref(hi), \"Guest\"));  // BAD!\n//   auto f = absl::bind_front(Print, std::ref(hi), \"Guest\"); // BAD!\n//\n// Example: Storing reference-like types.\n//\n//   void Print(absl::string_view a, const std::string& b) {\n//     std::cerr << a << b;\n//   }\n//\n//   std::string hi = \"Hello, \";\n//   // Copies \"hi\".\n//   absl::bind_front(Print, hi)(\"Chuk\");\n//\n//   // Compile error: std::reference_wrapper<const string> is not implicitly\n//   // convertible to string_view.\n//   // absl::bind_front(Print, std::cref(hi))(\"Chuk\");\n//\n//   // Doesn't copy \"hi\".\n//   absl::bind_front(Print, absl::string_view(hi))(\"Chuk\");\n//\n#if defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L\nusing std::bind_front;\n#else   // defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L\ntemplate <class F, class... BoundArgs>\nconstexpr functional_internal::bind_front_t<F, BoundArgs...> bind_front(\n    F&& func, BoundArgs&&... args) {\n  return functional_internal::bind_front_t<F, BoundArgs...>(\n      absl::in_place, absl::forward<F>(func),\n      absl::forward<BoundArgs>(args)...);\n}\n#endif  // defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03631",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/functional/bind_front.h",
  "source_line": 40,
  "validation_status": "validated"
}