{
  "code": "{\n\ntemplate <typename D, size_t I>\nstruct Elem;\ntemplate <typename... B, size_t I>\nstruct Elem<CompressedTuple<B...>, I>\n    : std::tuple_element<I, std::tuple<B...>> {};\ntemplate <typename D, size_t I>\nusing ElemT = typename Elem<D, I>::type;\n\n// We can't use EBCO on other CompressedTuples because that would mean that we\n// derive from multiple Storage<> instantiations with the same I parameter,\n// and potentially from multiple identical Storage<> instantiations.  So anytime\n// we use type inheritance rather than encapsulation, we mark\n// CompressedTupleImpl, to make this easy to detect.\nstruct uses_inheritance {};\n\ntemplate <typename T>\nconstexpr bool ShouldUseBase() {\n  return std::is_class<T>::value && std::is_empty<T>::value &&\n         !std::is_final<T>::value &&\n         !std::is_base_of<uses_inheritance, T>::value;\n}\n\n// The storage class provides two specializations:\n//  - For empty classes, it stores T as a base class.\n//  - For everything else, it stores T as a member.\ntemplate <typename T, size_t I, bool UseBase = ShouldUseBase<T>()>\nstruct Storage {\n  T value;\n  constexpr Storage() = default;\n  template <typename V>\n  explicit constexpr Storage(absl::in_place_t, V&& v)\n      : value(absl::forward<V>(v)) {}\n  constexpr const T& get() const& { return value; }\n  T& get() & { return value; }\n  constexpr const T&& get() const&& { return absl::move(*this).value; }\n  T&& get() && { return std::move(*this).value; }\n};\n\ntemplate <typename T, size_t I>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC Storage<T, I, true> : T {\n  constexpr Storage() = default;\n\n  template <typename V>\n  explicit constexpr Storage(absl::in_place_t, V&& v)\n      : T(absl::forward<V>(v)) {}\n\n  constexpr const T& get() const& { return *this; }\n  T& get() & { return *this; }\n  constexpr const T&& get() const&& { return absl::move(*this); }\n  T&& get() && { return std::move(*this); }\n};\n\ntemplate <typename D, typename I, bool ShouldAnyUseBase>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl;\n\ntemplate <typename... Ts, size_t... I, bool ShouldAnyUseBase>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl<\n    CompressedTuple<Ts...>, absl::index_sequence<I...>, ShouldAnyUseBase>\n    // We use the dummy identity function through std::integral_constant to\n    // convince MSVC of accepting and expanding I in that context. Without it\n    // you would get:\n    //   error C3548: 'I': parameter pack cannot be used in this context\n    : uses_inheritance,\n      Storage<Ts, std::integral_constant<size_t, I>::value>... {\n  constexpr CompressedTupleImpl() = default;\n  template <typename... Vs>\n  explicit constexpr CompressedTupleImpl(absl::in_place_t, Vs&&... args)\n      : Storage<Ts, I>(absl::in_place, absl::forward<Vs>(args))... {}\n  friend CompressedTuple<Ts...>;\n};\n\ntemplate <typename... Ts, size_t... I>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl<\n    CompressedTuple<Ts...>, absl::index_sequence<I...>, false>\n    // We use the dummy identity function as above...\n    : Storage<Ts, std::integral_constant<size_t, I>::value, false>... {\n  constexpr CompressedTupleImpl() = default;\n  template <typename... Vs>\n  explicit constexpr CompressedTupleImpl(absl::in_place_t, Vs&&... args)\n      : Storage<Ts, I, false>(absl::in_place, absl::forward<Vs>(args))... {}\n  friend CompressedTuple<Ts...>;\n};\n\nstd::false_type Or(std::initializer_list<std::false_type>);\nstd::true_type Or(std::initializer_list<bool>);\n\n// MSVC requires this to be done separately rather than within the declaration\n// of CompressedTuple below.\ntemplate <typename... Ts>\nconstexpr bool ShouldAnyUseBase() {\n  return decltype(\n      Or({std::integral_constant<bool, ShouldUseBase<Ts>()>()...})){};\n}\n\ntemplate <typename T, typename V>\nusing TupleElementMoveConstructible =\n    typename std::conditional<std::is_reference<T>::value,\n                              std::is_convertible<V, T>,\n                              std::is_constructible<T, V&&>>::type;\n\ntemplate <bool SizeMatches, class T, class... Vs>\nstruct TupleMoveConstructible : std::false_type {};\n\ntemplate <class... Ts, class... Vs>\nstruct TupleMoveConstructible<true, CompressedTuple<Ts...>, Vs...>\n    : std::integral_constant<\n          bool, absl::conjunction<\n                    TupleElementMoveConstructible<Ts, Vs&&>...>::value> {};\n\ntemplate <typename T>\nstruct compressed_tuple_size;\n\ntemplate <typename... Es>\nstruct compressed_tuple_size<CompressedTuple<Es...>>\n    : public std::integral_constant<std::size_t, sizeof...(Es)> {};\n\ntemplate <class T, class... Vs>\nstruct TupleItemsMoveConstructible\n    : std::integral_constant<\n          bool, TupleMoveConstructible<compressed_tuple_size<T>::value ==\n                                           sizeof...(Vs),\n                                       T, Vs...>::value> {};\n\n}",
  "id": "BLOCK-CPP-04961",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/compressed_tuple.h",
  "source_line": 57,
  "validation_status": "validated"
}