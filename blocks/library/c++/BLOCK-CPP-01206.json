{
  "code": "{\n  // Step 1: integer promotion & Schubfach multiplier calculation.\n\n  using carrier_uint = typename float_info<T>::carrier_uint;\n  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;\n  auto br = bit_cast<carrier_uint>(x);\n\n  // Extract significand bits and exponent bits.\n  const carrier_uint significand_mask =\n      (static_cast<carrier_uint>(1) << num_significand_bits<T>()) - 1;\n  carrier_uint significand = (br & significand_mask);\n  int exponent =\n      static_cast<int>((br & exponent_mask<T>()) >> num_significand_bits<T>());\n\n  if (exponent != 0) {  // Check if normal.\n    exponent -= exponent_bias<T>() + num_significand_bits<T>();\n\n    // Shorter interval case; proceed like Schubfach.\n    // In fact, when exponent == 1 and significand == 0, the interval is\n    // regular. However, it can be shown that the end-results are anyway same.\n    if (significand == 0) return shorter_interval_case<T>(exponent);\n\n    significand |= (static_cast<carrier_uint>(1) << num_significand_bits<T>());\n  } else {\n    // Subnormal case; the interval is always regular.\n    if (significand == 0) return {0, 0};\n    exponent =\n        std::numeric_limits<T>::min_exponent - num_significand_bits<T>() - 1;\n  }\n\n  const bool include_left_endpoint = (significand % 2 == 0);\n  const bool include_right_endpoint = include_left_endpoint;\n\n  // Compute k and beta.\n  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;\n  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);\n  const int beta = exponent + floor_log2_pow10(-minus_k);\n\n  // Compute zi and deltai.\n  // 10^kappa <= deltai < 10^(kappa + 1)\n  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta);\n  const carrier_uint two_fc = significand << 1;\n\n  // For the case of binary32, the result of integer check is not correct for\n  // 29711844 * 2^-82\n  // = 6.1442653300000000008655037797566933477355632930994033813476... * 10^-18\n  // and 29711844 * 2^-81\n  // = 1.2288530660000000001731007559513386695471126586198806762695... * 10^-17,\n  // and they are the unique counterexamples. However, since 29711844 is even,\n  // this does not cause any problem for the endpoints calculations; it can only\n  // cause a problem when we need to perform integer check for the center.\n  // Fortunately, with these inputs, that branch is never executed, so we are\n  // fine.\n  const typename cache_accessor<T>::compute_mul_result z_mul =\n      cache_accessor<T>::compute_mul((two_fc | 1) << beta, cache);\n\n  // Step 2: Try larger divisor; remove trailing zeros if necessary.\n\n  // Using an upper bound on zi, we might be able to optimize the division\n  // better than the compiler; we are computing zi / big_divisor here.\n  decimal_fp<T> ret_value;\n  ret_value.significand = divide_by_10_to_kappa_plus_1(z_mul.result);\n  uint32_t r = static_cast<uint32_t>(z_mul.result - float_info<T>::big_divisor *\n                                                        ret_value.significand);\n\n  if (r < deltai) {\n    // Exclude the right endpoint if necessary.\n    if (r == 0 && (z_mul.is_integer & !include_right_endpoint)) {\n      --ret_value.significand;\n      r = float_info<T>::big_divisor;\n      goto small_divisor_case_label;\n    }\n  } else if (r > deltai) {\n    goto small_divisor_case_label;\n  } else {\n    // r == deltai; compare fractional parts.\n    const typename cache_accessor<T>::compute_mul_parity_result x_mul =\n        cache_accessor<T>::compute_mul_parity(two_fc - 1, cache, beta);\n\n    if (!(x_mul.parity | (x_mul.is_integer & include_left_endpoint)))\n      goto small_divisor_case_label;\n  }\n  ret_value.exponent = minus_k + float_info<T>::kappa + 1;\n\n  // We may need to remove trailing zeros.\n  ret_value.exponent += remove_trailing_zeros(ret_value.significand);\n  return ret_value;\n\n  // Step 3: Find the significand with the smaller divisor.\n\nsmall_divisor_case_label:\n  ret_value.significand *= 10;\n  ret_value.exponent = minus_k + float_info<T>::kappa;\n\n  uint32_t dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);\n  const bool approx_y_parity =\n      ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;\n\n  // Is dist divisible by 10^kappa?\n  const bool divisible_by_small_divisor =\n      check_divisibility_and_divide_by_pow10<float_info<T>::kappa>(dist);\n\n  // Add dist / 10^kappa to the significand.\n  ret_value.significand += dist;\n\n  if (!divisible_by_small_divisor) return ret_value;\n\n  // Check z^(f) >= epsilon^(f).\n  // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,\n  // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f).\n  // Since there are only 2 possibilities, we only need to care about the\n  // parity. Also, zi and r should have the same parity since the divisor\n  // is an even number.\n  const auto y_mul = cache_accessor<T>::compute_mul_parity(two_fc, cache, beta);\n\n  // If z^(f) >= epsilon^(f), we might have a tie when z^(f) == epsilon^(f),\n  // or equivalently, when y is an integer.\n  if (y_mul.parity != approx_y_parity)\n    --ret_value.significand;\n  else if (y_mul.is_integer & (ret_value.significand % 2 != 0))\n    --ret_value.significand;\n  return ret_value;\n}",
  "id": "BLOCK-CPP-01206",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format-inl.h",
  "source_line": 1273,
  "validation_status": "validated"
}