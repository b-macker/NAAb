{
  "code": "#include <array>\n#include <initializer_list>\n#include <iterator>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n#include \"absl/base/macros.h\"\n#include \"absl/base/port.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/strings/internal/stl_type_traits.h\"\n\nusing namespace absl;\nusing namespace strings_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06264_execute() {\n    {\n public:\n  using iterator_category = std::input_iterator_tag;\n  using value_type = absl::string_view;\n  using difference_type = ptrdiff_t;\n  using pointer = const value_type*;\n  using reference = const value_type&;\n\n  enum State { kInitState, kLastState, kEndState };\n  SplitIterator(State state, const Splitter* splitter)\n      : pos_(0),\n        state_(state),\n        splitter_(splitter),\n        delimiter_(splitter->delimiter()),\n        predicate_(splitter->predicate()) {\n    // Hack to maintain backward compatibility. This one block makes it so an\n    // empty absl::string_view whose .data() happens to be nullptr behaves\n    // *differently* from an otherwise empty absl::string_view whose .data() is\n    // not nullptr. This is an undesirable difference in general, but this\n    // behavior is maintained to avoid breaking existing code that happens to\n    // depend on this old behavior/bug. Perhaps it will be fixed one day. The\n    // difference in behavior is as follows:\n    //   Split(absl::string_view(\"\"), '-');  // {\"\"}\n    //   Split(absl::string_view(), '-');    // {}\n    if (splitter_->text().data() == nullptr) {\n      state_ = kEndState;\n      pos_ = splitter_->text().size();\n      return;\n    }\n\n    if (state_ == kEndState) {\n      pos_ = splitter_->text().size();\n    } else {\n      ++(*this);\n    }\n  }\n\n  bool at_end() const { return state_ == kEndState; }\n\n  reference operator*() const { return curr_; }\n  pointer operator->() const { return &curr_; }\n\n  SplitIterator& operator++() {\n    do {\n      if (state_ == kLastState) {\n        state_ = kEndState;\n        return *this;\n      }\n      const absl::string_view text = splitter_->text();\n      const absl::string_view d = delimiter_.Find(text, pos_);\n      if (d.data() == text.data() + text.size()) state_ = kLastState;\n      curr_ = text.substr(pos_,\n                          static_cast<size_t>(d.data() - (text.data() + pos_)));\n      pos_ += curr_.size() + d.size();\n    } while (!predicate_(curr_));\n    return *this;\n  }\n\n  SplitIterator operator++(int) {\n    SplitIterator old(*this);\n    ++(*this);\n    return old;\n  }\n\n  friend bool operator==(const SplitIterator& a, const SplitIterator& b) {\n    return a.state_ == b.state_ && a.pos_ == b.pos_;\n  }\n\n  friend bool operator!=(const SplitIterator& a, const SplitIterator& b) {\n    return !(a == b);\n  }\n\n private:\n  size_t pos_;\n  State state_;\n  absl::string_view curr_;\n  const Splitter* splitter_;\n  typename Splitter::DelimiterType delimiter_;\n  typename Splitter::PredicateType predicate_;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06264",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_split_internal.h",
  "source_line": 83,
  "validation_status": "validated"
}