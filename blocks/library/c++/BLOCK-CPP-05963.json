{
  "code": "{\n public:\n  using inner_sequence_type = SSeq;\n  using result_type = typename SSeq::result_type;\n\n  SaltedSeedSeq() : seq_(absl::make_unique<SSeq>()) {}\n\n  template <typename Iterator>\n  SaltedSeedSeq(Iterator begin, Iterator end)\n      : seq_(absl::make_unique<SSeq>(begin, end)) {}\n\n  template <typename T>\n  SaltedSeedSeq(std::initializer_list<T> il)\n      : SaltedSeedSeq(il.begin(), il.end()) {}\n\n  SaltedSeedSeq(const SaltedSeedSeq&) = delete;\n  SaltedSeedSeq& operator=(const SaltedSeedSeq&) = delete;\n\n  SaltedSeedSeq(SaltedSeedSeq&&) = default;\n  SaltedSeedSeq& operator=(SaltedSeedSeq&&) = default;\n\n  template <typename RandomAccessIterator>\n  void generate(RandomAccessIterator begin, RandomAccessIterator end) {\n    using U = typename std::iterator_traits<RandomAccessIterator>::value_type;\n\n    // The common case is that generate is called with ContiguousIterators\n    // to uint arrays. Such contiguous memory regions may be optimized,\n    // which we detect here.\n    using TagType = absl::conditional_t<\n        (std::is_same<U, uint32_t>::value &&\n         (std::is_pointer<RandomAccessIterator>::value ||\n          std::is_same<RandomAccessIterator,\n                       typename std::vector<U>::iterator>::value)),\n        ContiguousAndUint32Tag, DefaultTag>;\n    if (begin != end) {\n      generate_impl(TagType{}, begin, end, std::distance(begin, end));\n    }\n  }\n\n  template <typename OutIterator>\n  void param(OutIterator out) const {\n    seq_->param(out);\n  }\n\n  size_t size() const { return seq_->size(); }\n\n private:\n  struct ContiguousAndUint32Tag {};\n  struct DefaultTag {};\n\n  // Generate which requires the iterators are contiguous pointers to uint32_t.\n  // Fills the initial seed buffer the underlying SSeq::generate() call,\n  // then mixes in the salt material.\n  template <typename Contiguous>\n  void generate_impl(ContiguousAndUint32Tag, Contiguous begin, Contiguous end,\n                     size_t n) {\n    seq_->generate(begin, end);\n    const uint32_t salt = absl::random_internal::GetSaltMaterial().value_or(0);\n    auto span = absl::Span<uint32_t>(&*begin, n);\n    MixIntoSeedMaterial(absl::MakeConstSpan(&salt, 1), span);\n  }\n\n  // The uncommon case for generate is that it is called with iterators over\n  // some other buffer type which is assignable from a 32-bit value. In this\n  // case we allocate a temporary 32-bit buffer and then copy-assign back\n  // to the initial inputs.\n  template <typename RandomAccessIterator>\n  void generate_impl(DefaultTag, RandomAccessIterator begin,\n                     RandomAccessIterator, size_t n) {\n    // Allocates a seed buffer of `n` elements, generates the seed, then\n    // copies the result into the `out` iterator.\n    absl::InlinedVector<uint32_t, 8> data(n, 0);\n    generate_impl(ContiguousAndUint32Tag{}, data.begin(), data.end(), n);\n    std::copy(data.begin(), data.end(), begin);\n  }\n\n  // Because [rand.req.seedseq] is not required to be copy-constructible,\n  // copy-assignable nor movable, we wrap it with unique pointer to be able\n  // to move SaltedSeedSeq.\n  std::unique_ptr<SSeq> seq_;\n}",
  "id": "BLOCK-CPP-05963",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/salted_seed_seq.h",
  "source_line": 45,
  "validation_status": "validated"
}