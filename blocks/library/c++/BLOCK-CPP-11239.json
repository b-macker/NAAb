{
  "code": "#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-11239_execute() {\n    {\nnamespace detail {\n/// Given an expression E and functions Fn_1,...,Fn_n : Expr * -> Expr *,\n/// Return Fn_n(...(Fn_1(E)))\ninline Expr *IgnoreExprNodesImpl(Expr *E) { return E; }\ntemplate <typename FnTy, typename... FnTys>\nExpr *IgnoreExprNodesImpl(Expr *E, FnTy &&Fn, FnTys &&... Fns) {\n  return IgnoreExprNodesImpl(std::forward<FnTy>(Fn)(E),\n                             std::forward<FnTys>(Fns)...);\n}\n} // namespace detail\n\n/// Given an expression E and functions Fn_1,...,Fn_n : Expr * -> Expr *,\n/// Recursively apply each of the functions to E until reaching a fixed point.\n/// Note that a null E is valid; in this case nothing is done.\ntemplate <typename... FnTys> Expr *IgnoreExprNodes(Expr *E, FnTys &&... Fns) {\n  Expr *LastE = nullptr;\n  while (E != LastE) {\n    LastE = E;\n    E = detail::IgnoreExprNodesImpl(E, std::forward<FnTys>(Fns)...);\n  }\n  return E;\n}\n\ntemplate <typename... FnTys>\nconst Expr *IgnoreExprNodes(const Expr *E, FnTys &&...Fns) {\n  return IgnoreExprNodes(const_cast<Expr *>(E), std::forward<FnTys>(Fns)...);\n}\n\ninline Expr *IgnoreImplicitCastsSingleStep(Expr *E) {\n  if (auto *ICE = dyn_cast<ImplicitCastExpr>(E))\n    return ICE->getSubExpr();\n\n  if (auto *FE = dyn_cast<FullExpr>(E))\n    return FE->getSubExpr();\n\n  return E;\n}\n\ninline Expr *IgnoreImplicitCastsExtraSingleStep(Expr *E) {\n  // FIXME: Skip MaterializeTemporaryExpr and SubstNonTypeTemplateParmExpr in\n  // addition to what IgnoreImpCasts() skips to account for the current\n  // behaviour of IgnoreParenImpCasts().\n  Expr *SubE = IgnoreImplicitCastsSingleStep(E);\n  if (SubE != E)\n    return SubE;\n\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E))\n    return MTE->getSubExpr();\n\n  if (auto *NTTP = dyn_cast<SubstNonTypeTemplateParmExpr>(E))\n    return NTTP->getReplacement();\n\n  return E;\n}\n\ninline Expr *IgnoreCastsSingleStep(Expr *E) {\n  if (auto *CE = dyn_cast<CastExpr>(E))\n    return CE->getSubExpr();\n\n  if (auto *FE = dyn_cast<FullExpr>(E))\n    return FE->getSubExpr();\n\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E))\n    return MTE->getSubExpr();\n\n  if (auto *NTTP = dyn_cast<SubstNonTypeTemplateParmExpr>(E))\n    return NTTP->getReplacement();\n\n  return E;\n}\n\ninline Expr *IgnoreLValueCastsSingleStep(Expr *E) {\n  // Skip what IgnoreCastsSingleStep skips, except that only\n  // lvalue-to-rvalue casts are skipped.\n  if (auto *CE = dyn_cast<CastExpr>(E))\n    if (CE->getCastKind() != CK_LValueToRValue)\n      return E;\n\n  return IgnoreCastsSingleStep(E);\n}\n\ninline Expr *IgnoreBaseCastsSingleStep(Expr *E) {\n  if (auto *CE = dyn_cast<CastExpr>(E))\n    if (CE->getCastKind() == CK_DerivedToBase ||\n        CE->getCastKind() == CK_UncheckedDerivedToBase ||\n        CE->getCastKind() == CK_NoOp)\n      return CE->getSubExpr();\n\n  return E;\n}\n\ninline Expr *IgnoreImplicitSingleStep(Expr *E) {\n  Expr *SubE = IgnoreImplicitCastsSingleStep(E);\n  if (SubE != E)\n    return SubE;\n\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E))\n    return MTE->getSubExpr();\n\n  if (auto *BTE = dyn_cast<CXXBindTemporaryExpr>(E))\n    return BTE->getSubExpr();\n\n  return E;\n}\n\ninline Expr *IgnoreElidableImplicitConstructorSingleStep(Expr *E) {\n  auto *CCE = dyn_cast<CXXConstructExpr>(E);\n  if (CCE && CCE->isElidable() && !isa<CXXTemporaryObjectExpr>(CCE)) {\n    unsigned NumArgs = CCE->getNumArgs();\n    if ((NumArgs == 1 ||\n         (NumArgs > 1 && CCE->getArg(1)->isDefaultArgument())) &&\n        !CCE->getArg(0)->isDefaultArgument() && !CCE->isListInitialization())\n      return CCE->getArg(0);\n  }\n  return E;\n}\n\ninline Expr *IgnoreImplicitAsWrittenSingleStep(Expr *E) {\n  if (auto *ICE = dyn_cast<ImplicitCastExpr>(E))\n    return ICE->getSubExprAsWritten();\n\n  return IgnoreImplicitSingleStep(E);\n}\n\ninline Expr *IgnoreParensOnlySingleStep(Expr *E) {\n  if (auto *PE = dyn_cast<ParenExpr>(E))\n    return PE->getSubExpr();\n  return E;\n}\n\ninline Expr *IgnoreParensSingleStep(Expr *E) {\n  if (auto *PE = dyn_cast<ParenExpr>(E))\n    return PE->getSubExpr();\n\n  if (auto *UO = dyn_cast<UnaryOperator>(E)) {\n    if (UO->getOpcode() == UO_Extension)\n      return UO->getSubExpr();\n  }\n\n  else if (auto *GSE = dyn_cast<GenericSelectionExpr>(E)) {\n    if (!GSE->isResultDependent())\n      return GSE->getResultExpr();\n  }\n\n  else if (auto *CE = dyn_cast<ChooseExpr>(E)) {\n    if (!CE->isConditionDependent())\n      return CE->getChosenSubExpr();\n  }\n\n  else if (auto *PE = dyn_cast<PredefinedExpr>(E)) {\n    if (PE->isTransparent() && PE->getFunctionName())\n      return PE->getFunctionName();\n  }\n\n  return E;\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-11239",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/IgnoreExpr.h",
  "source_line": 19,
  "validation_status": "validated"
}