{
  "code": "{\n  public:\n    /// First -- The first conversion can be an lvalue-to-rvalue\n    /// conversion, array-to-pointer conversion, or\n    /// function-to-pointer conversion.\n    ImplicitConversionKind First : 8;\n\n    /// Second - The second conversion can be an integral promotion,\n    /// floating point promotion, integral conversion, floating point\n    /// conversion, floating-integral conversion, pointer conversion,\n    /// pointer-to-member conversion, or boolean conversion.\n    ImplicitConversionKind Second : 8;\n\n    /// Third - The third conversion can be a qualification conversion\n    /// or a function conversion.\n    ImplicitConversionKind Third : 8;\n\n    /// Whether this is the deprecated conversion of a\n    /// string literal to a pointer to non-const character data\n    /// (C++ 4.2p2).\n    unsigned DeprecatedStringLiteralToCharPtr : 1;\n\n    /// Whether the qualification conversion involves a change in the\n    /// Objective-C lifetime (for automatic reference counting).\n    unsigned QualificationIncludesObjCLifetime : 1;\n\n    /// IncompatibleObjC - Whether this is an Objective-C conversion\n    /// that we should warn about (if we actually use it).\n    unsigned IncompatibleObjC : 1;\n\n    /// ReferenceBinding - True when this is a reference binding\n    /// (C++ [over.ics.ref]).\n    unsigned ReferenceBinding : 1;\n\n    /// DirectBinding - True when this is a reference binding that is a\n    /// direct binding (C++ [dcl.init.ref]).\n    unsigned DirectBinding : 1;\n\n    /// Whether this is an lvalue reference binding (otherwise, it's\n    /// an rvalue reference binding).\n    unsigned IsLvalueReference : 1;\n\n    /// Whether we're binding to a function lvalue.\n    unsigned BindsToFunctionLvalue : 1;\n\n    /// Whether we're binding to an rvalue.\n    unsigned BindsToRvalue : 1;\n\n    /// Whether this binds an implicit object argument to a\n    /// non-static member function without a ref-qualifier.\n    unsigned BindsImplicitObjectArgumentWithoutRefQualifier : 1;\n\n    /// Whether this binds a reference to an object with a different\n    /// Objective-C lifetime qualifier.\n    unsigned ObjCLifetimeConversionBinding : 1;\n\n    /// FromType - The type that this conversion is converting\n    /// from. This is an opaque pointer that can be translated into a\n    /// QualType.\n    void *FromTypePtr;\n\n    /// ToType - The types that this conversion is converting to in\n    /// each step. This is an opaque pointer that can be translated\n    /// into a QualType.\n    void *ToTypePtrs[3];\n\n    /// CopyConstructor - The copy constructor that is used to perform\n    /// this conversion, when the conversion is actually just the\n    /// initialization of an object via copy constructor. Such\n    /// conversions are either identity conversions or derived-to-base\n    /// conversions.\n    CXXConstructorDecl *CopyConstructor;\n    DeclAccessPair FoundCopyConstructor;\n\n    void setFromType(QualType T) { FromTypePtr = T.getAsOpaquePtr(); }\n\n    void setToType(unsigned Idx, QualType T) {\n      assert(Idx < 3 && \"To type index is out of range\");\n      ToTypePtrs[Idx] = T.getAsOpaquePtr();\n    }\n\n    void setAllToTypes(QualType T) {\n      ToTypePtrs[0] = T.getAsOpaquePtr();\n      ToTypePtrs[1] = ToTypePtrs[0];\n      ToTypePtrs[2] = ToTypePtrs[0];\n    }\n\n    QualType getFromType() const {\n      return QualType::getFromOpaquePtr(FromTypePtr);\n    }\n\n    QualType getToType(unsigned Idx) const {\n      assert(Idx < 3 && \"To type index is out of range\");\n      return QualType::getFromOpaquePtr(ToTypePtrs[Idx]);\n    }\n\n    void setAsIdentityConversion();\n\n    bool isIdentityConversion() const {\n      return Second == ICK_Identity && Third == ICK_Identity;\n    }\n\n    ImplicitConversionRank getRank() const;\n    NarrowingKind\n    getNarrowingKind(ASTContext &Context, const Expr *Converted,\n                     APValue &ConstantValue, QualType &ConstantType,\n                     bool IgnoreFloatToIntegralConversion = false) const;\n    bool isPointerConversionToBool() const;\n    bool isPointerConversionToVoidPointer(ASTContext& Context) const;\n    void dump() const;\n  }",
  "id": "BLOCK-CPP-20045",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Overload.h",
  "source_line": 261,
  "validation_status": "validated"
}