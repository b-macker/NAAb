{
  "code": "{\n\n/// A lattice that maps keys to individual lattice elements. When instantiated\n/// with an `ElementLattice` that is a bounded semi-lattice, `MapLattice` is\n/// itself a bounded semi-lattice, so long as the user limits themselves to a\n/// finite number of keys. In that case, `top` is (implicitly), the map\n/// containing all valid keys mapped to `top` of `ElementLattice`.\n///\n/// Requirements on `ElementLattice`:\n/// * Provides standard declarations of a bounded semi-lattice.\ntemplate <typename Key, typename ElementLattice> class MapLattice {\n  using Container = llvm::DenseMap<Key, ElementLattice>;\n  Container C;\n\npublic:\n  using key_type = Key;\n  using mapped_type = ElementLattice;\n  using value_type = typename Container::value_type;\n  using iterator = typename Container::iterator;\n  using const_iterator = typename Container::const_iterator;\n\n  MapLattice() = default;\n\n  explicit MapLattice(Container C) { C = std::move(C); }\n\n  // The `bottom` element is the empty map.\n  static MapLattice bottom() { return MapLattice(); }\n\n  std::pair<iterator, bool>\n  insert(const std::pair<const key_type, mapped_type> &P) {\n    return C.insert(P);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<const key_type, mapped_type> &&P) {\n    return C.insert(std::move(P));\n  }\n\n  unsigned size() const { return C.size(); }\n  bool empty() const { return C.empty(); }\n\n  iterator begin() { return C.begin(); }\n  iterator end() { return C.end(); }\n  const_iterator begin() const { return C.begin(); }\n  const_iterator end() const { return C.end(); }\n\n  // Equality is direct equality of underlying map entries. One implication of\n  // this definition is that a map with (only) keys that map to bottom is not\n  // equal to the empty map.\n  friend bool operator==(const MapLattice &LHS, const MapLattice &RHS) {\n    return LHS.C == RHS.C;\n  }\n\n  friend bool operator!=(const MapLattice &LHS, const MapLattice &RHS) {\n    return !(LHS == RHS);\n  }\n\n  bool contains(const key_type &K) const { return C.find(K) != C.end(); }\n\n  iterator find(const key_type &K) { return C.find(K); }\n  const_iterator find(const key_type &K) const { return C.find(K); }\n\n  mapped_type &operator[](const key_type &K) { return C[K]; }\n\n  /// If an entry exists in one map but not the other, the missing entry is\n  /// treated as implicitly mapping to `bottom`. So, the joined map contains the\n  /// entry as it was in the source map.\n  LatticeJoinEffect join(const MapLattice &Other) {\n    LatticeJoinEffect Effect = LatticeJoinEffect::Unchanged;\n    for (const auto &O : Other.C) {\n      auto It = C.find(O.first);\n      if (It == C.end()) {\n        C.insert(O);\n        Effect = LatticeJoinEffect::Changed;\n      } else if (It->second.join(O.second) == LatticeJoinEffect::Changed)\n        Effect = LatticeJoinEffect::Changed;\n    }\n    return Effect;\n  }\n};\n\n/// Convenience alias that captures the common use of map lattices to model\n/// in-scope variables.\ntemplate <typename ElementLattice>\nusing VarMapLattice = MapLattice<const clang::VarDecl *, ElementLattice>;\n\ntemplate <typename Key, typename ElementLattice>\nstd::ostream &\noperator<<(std::ostream &Os,\n           const clang::dataflow::MapLattice<Key, ElementLattice> &M) {\n  std::string Separator;\n  Os << \"{\";\n  for (const auto &E : M) {\n    Os << std::exchange(Separator, \", \") << E.first << \" => \" << E.second;\n  }\n  Os << \"}\";\n  return Os;\n}\n\ntemplate <typename ElementLattice>\nstd::ostream &\noperator<<(std::ostream &Os,\n           const clang::dataflow::VarMapLattice<ElementLattice> &M) {\n  std::string Separator;\n  Os << \"{\";\n  for (const auto &E : M) {\n    Os << std::exchange(Separator, \", \") << E.first->getName().str() << \" => \"\n       << E.second;\n  }\n  Os << \"}\";\n  return Os;\n}\n}",
  "id": "BLOCK-CPP-21969",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/MapLattice.h",
  "source_line": 29,
  "validation_status": "validated"
}