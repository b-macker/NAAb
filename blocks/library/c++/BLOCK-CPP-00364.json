{
  "code": "    #include <spdlog/sinks/ansicolor_sink.h>\n#include <spdlog/details/os.h>\n#include <spdlog/pattern_formatter.h>\n\nusing namespace spdlog;\nusing namespace sinks;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00364_execute() {\n    {\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE ansicolor_sink<ConsoleMutex>::ansicolor_sink(FILE *target_file, color_mode mode)\n    : target_file_(target_file),\n      mutex_(ConsoleMutex::mutex()),\n      formatter_(details::make_unique<spdlog::pattern_formatter>())\n\n{\n    set_color_mode(mode);\n    colors_.at(level::trace) = to_string_(white);\n    colors_.at(level::debug) = to_string_(cyan);\n    colors_.at(level::info) = to_string_(green);\n    colors_.at(level::warn) = to_string_(yellow_bold);\n    colors_.at(level::err) = to_string_(red_bold);\n    colors_.at(level::critical) = to_string_(bold_on_red);\n    colors_.at(level::off) = to_string_(reset);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color(level::level_enum color_level,\n                                                           string_view_t color) {\n    std::lock_guard<mutex_t> lock(mutex_);\n    colors_.at(static_cast<size_t>(color_level)) = to_string_(color);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::log(const details::log_msg &msg) {\n    // Wrap the originally formatted message in color codes.\n    // If color is not supported in the terminal, log as is instead.\n    std::lock_guard<mutex_t> lock(mutex_);\n    msg.color_range_start = 0;\n    msg.color_range_end = 0;\n    memory_buf_t formatted;\n    formatter_->format(msg, formatted);\n    if (should_do_colors_ && msg.color_range_end > msg.color_range_start) {\n        // before color range\n        print_range_(formatted, 0, msg.color_range_start);\n        // in color range\n        print_ccode_(colors_.at(static_cast<size_t>(msg.level)));\n        print_range_(formatted, msg.color_range_start, msg.color_range_end);\n        print_ccode_(reset);\n        // after color range\n        print_range_(formatted, msg.color_range_end, formatted.size());\n    } else  // no color\n    {\n        print_range_(formatted, 0, formatted.size());\n    }\n    fflush(target_file_);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::flush() {\n    std::lock_guard<mutex_t> lock(mutex_);\n    fflush(target_file_);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_pattern(const std::string &pattern) {\n    std::lock_guard<mutex_t> lock(mutex_);\n    formatter_ = std::unique_ptr<spdlog::formatter>(new pattern_formatter(pattern));\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_formatter(\n    std::unique_ptr<spdlog::formatter> sink_formatter) {\n    std::lock_guard<mutex_t> lock(mutex_);\n    formatter_ = std::move(sink_formatter);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE bool ansicolor_sink<ConsoleMutex>::should_color() {\n    return should_do_colors_;\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color_mode(color_mode mode) {\n    switch (mode) {\n        case color_mode::always:\n            should_do_colors_ = true;\n            return;\n        case color_mode::automatic:\n            should_do_colors_ =\n                details::os::in_terminal(target_file_) && details::os::is_color_terminal();\n            return;\n        case color_mode::never:\n            should_do_colors_ = false;\n            return;\n        default:\n            should_do_colors_ = false;\n    }\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(const string_view_t &color_code) {\n    fwrite(color_code.data(), sizeof(char), color_code.size(), target_file_);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_range_(const memory_buf_t &formatted,\n                                                              size_t start,\n                                                              size_t end) {\n    fwrite(formatted.data() + start, sizeof(char), end - start, target_file_);\n}\n\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE std::string ansicolor_sink<ConsoleMutex>::to_string_(const string_view_t &sv) {\n    return std::string(sv.data(), sv.size());\n}\n\n// ansicolor_stdout_sink\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE ansicolor_stdout_sink<ConsoleMutex>::ansicolor_stdout_sink(color_mode mode)\n    : ansicolor_sink<ConsoleMutex>(stdout, mode) {}\n\n// ansicolor_stderr_sink\ntemplate <typename ConsoleMutex>\nSPDLOG_INLINE ansicolor_stderr_sink<ConsoleMutex>::ansicolor_stderr_sink(color_mode mode)\n    : ansicolor_sink<ConsoleMutex>(stderr, mode) {}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00364",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/ansicolor_sink-inl.h",
  "source_line": 14,
  "validation_status": "validated"
}