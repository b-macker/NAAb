{
  "code": "{\n// protected:\n//   Impl &asImpl();\n// public:\n//   ...\n// };\n\n// The actual classes are auto-generated; see ClangASTPropertiesEmitter.cpp.\n#include \"clang/AST/AbstractBasicWriter.inc\"\n\n/// DataStreamBasicWriter provides convenience implementations for many\n/// BasicWriter methods based on the assumption that the\n/// ultimate writer implementation is based on a variable-length stream\n/// of unstructured data (like Clang's module files).  It is designed\n/// to pair with DataStreamBasicReader.\n///\n/// This class can also act as a PropertyWriter, implementing find(\"...\")\n/// by simply forwarding to itself.\n///\n/// Unimplemented methods:\n///   writeBool\n///   writeUInt32\n///   writeUInt64\n///   writeIdentifier\n///   writeSelector\n///   writeSourceLocation\n///   writeQualType\n///   writeStmtRef\n///   writeDeclRef\ntemplate <class Impl>\nclass DataStreamBasicWriter : public BasicWriterBase<Impl> {\nprotected:\n  using BasicWriterBase<Impl>::asImpl;\n  DataStreamBasicWriter(ASTContext &ctx) : BasicWriterBase<Impl>(ctx) {}\n\npublic:\n  /// Implement property-find by ignoring it.  We rely on properties being\n  /// serialized and deserialized in a reliable order instead.\n  Impl &find(const char *propertyName) {\n    return asImpl();\n  }\n\n  // Implement object writing by forwarding to this, collapsing the\n  // structure into a single data stream.\n  Impl &writeObject() { return asImpl(); }\n\n  template <class T>\n  void writeEnum(T value) {\n    asImpl().writeUInt32(uint32_t(value));\n  }\n\n  template <class T>\n  void writeArray(llvm::ArrayRef<T> array) {\n    asImpl().writeUInt32(array.size());\n    for (const T &elt : array) {\n      WriteDispatcher<T>::write(asImpl(), elt);\n    }\n  }\n\n  template <class T> void writeOptional(std::optional<T> value) {\n    WriteDispatcher<T>::write(asImpl(), PackOptionalValue<T>::pack(value));\n  }\n\n  void writeAPSInt(const llvm::APSInt &value) {\n    asImpl().writeBool(value.isUnsigned());\n    asImpl().writeAPInt(value);\n  }\n\n  void writeAPInt(const llvm::APInt &value) {\n    asImpl().writeUInt32(value.getBitWidth());\n    const uint64_t *words = value.getRawData();\n    for (size_t i = 0, e = value.getNumWords(); i != e; ++i)\n      asImpl().writeUInt64(words[i]);\n  }\n\n  void writeFixedPointSemantics(const llvm::FixedPointSemantics &sema) {\n    asImpl().writeUInt32(sema.getWidth());\n    asImpl().writeUInt32(sema.getScale());\n    asImpl().writeUInt32(sema.isSigned() | sema.isSaturated() << 1 |\n                         sema.hasUnsignedPadding() << 2);\n  }\n\n  void writeLValuePathSerializationHelper(\n      APValue::LValuePathSerializationHelper lvaluePath) {\n    ArrayRef<APValue::LValuePathEntry> path = lvaluePath.Path;\n    QualType elemTy = lvaluePath.getType();\n    asImpl().writeQualType(elemTy);\n    asImpl().writeUInt32(path.size());\n    auto &ctx = ((BasicWriterBase<Impl> *)this)->getASTContext();\n    for (auto elem : path) {\n      if (elemTy->getAs<RecordType>()) {\n        asImpl().writeUInt32(elem.getAsBaseOrMember().getInt());\n        const Decl *baseOrMember = elem.getAsBaseOrMember().getPointer();\n        if (const auto *recordDecl = dyn_cast<CXXRecordDecl>(baseOrMember)) {\n          asImpl().writeDeclRef(recordDecl);\n          elemTy = ctx.getRecordType(recordDecl);\n        } else {\n          const auto *valueDecl = cast<ValueDecl>(baseOrMember);\n          asImpl().writeDeclRef(valueDecl);\n          elemTy = valueDecl->getType();\n        }\n      } else {\n        asImpl().writeUInt32(elem.getAsArrayIndex());\n        elemTy = ctx.getAsArrayType(elemTy)->getElementType();\n      }\n    }\n  }\n\n  void writeQualifiers(Qualifiers value) {\n    static_assert(sizeof(value.getAsOpaqueValue()) <= sizeof(uint32_t),\n                  \"update this if the value size changes\");\n    asImpl().writeUInt32(value.getAsOpaqueValue());\n  }\n\n  void writeExceptionSpecInfo(\n                        const FunctionProtoType::ExceptionSpecInfo &esi) {\n    asImpl().writeUInt32(uint32_t(esi.Type));\n    if (esi.Type == EST_Dynamic) {\n      asImpl().writeArray(esi.Exceptions);\n    } else if (isComputedNoexcept(esi.Type)) {\n      asImpl().writeExprRef(esi.NoexceptExpr);\n    } else if (esi.Type == EST_Uninstantiated) {\n      asImpl().writeDeclRef(esi.SourceDecl);\n      asImpl().writeDeclRef(esi.SourceTemplate);\n    } else if (esi.Type == EST_Unevaluated) {\n      asImpl().writeDeclRef(esi.SourceDecl);\n    }\n  }\n\n  void writeExtParameterInfo(FunctionProtoType::ExtParameterInfo epi) {\n    static_assert(sizeof(epi.getOpaqueValue()) <= sizeof(uint32_t),\n                  \"opaque value doesn't fit into uint32_t\");\n    asImpl().writeUInt32(epi.getOpaqueValue());\n  }\n\n  void writeNestedNameSpecifier(NestedNameSpecifier *NNS) {\n    // Nested name specifiers usually aren't too long. I think that 8 would\n    // typically accommodate the vast majority.\n    SmallVector<NestedNameSpecifier *, 8> nestedNames;\n\n    // Push each of the NNS's onto a stack for serialization in reverse order.\n    while (NNS) {\n      nestedNames.push_back(NNS);\n      NNS = NNS->getPrefix();\n    }\n\n    asImpl().writeUInt32(nestedNames.size());\n    while (!nestedNames.empty()) {\n      NNS = nestedNames.pop_back_val();\n      NestedNameSpecifier::SpecifierKind kind = NNS->getKind();\n      asImpl().writeNestedNameSpecifierKind(kind);\n      switch (kind) {\n      case NestedNameSpecifier::Identifier:\n        asImpl().writeIdentifier(NNS->getAsIdentifier());\n        continue;\n\n      case NestedNameSpecifier::Namespace:\n        asImpl().writeNamespaceDeclRef(NNS->getAsNamespace());\n        continue;\n\n      case NestedNameSpecifier::NamespaceAlias:\n        asImpl().writeNamespaceAliasDeclRef(NNS->getAsNamespaceAlias());\n        continue;\n\n      case NestedNameSpecifier::TypeSpec:\n      case NestedNameSpecifier::TypeSpecWithTemplate:\n        asImpl().writeQualType(QualType(NNS->getAsType(), 0));\n        continue;\n\n      case NestedNameSpecifier::Global:\n        // Don't need to write an associated value.\n        continue;\n\n      case NestedNameSpecifier::Super:\n        asImpl().writeDeclRef(NNS->getAsRecordDecl());\n        continue;\n      }\n      llvm_unreachable(\"bad nested name specifier kind\");\n    }\n  }\n};\n\n}",
  "id": "BLOCK-CPP-23124",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/AbstractBasicWriter.h",
  "source_line": 90,
  "validation_status": "validated"
}