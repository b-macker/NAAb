{
  "code": "{\npublic:\n  /// storage-class-specifier\n  /// \\note The order of these enumerators is important for diagnostics.\n  enum SCS {\n    SCS_unspecified = 0,\n    SCS_typedef,\n    SCS_extern,\n    SCS_static,\n    SCS_auto,\n    SCS_register,\n    SCS_private_extern,\n    SCS_mutable\n  };\n\n  // Import thread storage class specifier enumeration and constants.\n  // These can be combined with SCS_extern and SCS_static.\n  typedef ThreadStorageClassSpecifier TSCS;\n  static const TSCS TSCS_unspecified = clang::TSCS_unspecified;\n  static const TSCS TSCS___thread = clang::TSCS___thread;\n  static const TSCS TSCS_thread_local = clang::TSCS_thread_local;\n  static const TSCS TSCS__Thread_local = clang::TSCS__Thread_local;\n\n  enum TSC {\n    TSC_unspecified,\n    TSC_imaginary,\n    TSC_complex\n  };\n\n  // Import type specifier type enumeration and constants.\n  typedef TypeSpecifierType TST;\n  static const TST TST_unspecified = clang::TST_unspecified;\n  static const TST TST_void = clang::TST_void;\n  static const TST TST_char = clang::TST_char;\n  static const TST TST_wchar = clang::TST_wchar;\n  static const TST TST_char8 = clang::TST_char8;\n  static const TST TST_char16 = clang::TST_char16;\n  static const TST TST_char32 = clang::TST_char32;\n  static const TST TST_int = clang::TST_int;\n  static const TST TST_int128 = clang::TST_int128;\n  static const TST TST_bitint = clang::TST_bitint;\n  static const TST TST_half = clang::TST_half;\n  static const TST TST_BFloat16 = clang::TST_BFloat16;\n  static const TST TST_float = clang::TST_float;\n  static const TST TST_double = clang::TST_double;\n  static const TST TST_float16 = clang::TST_Float16;\n  static const TST TST_accum = clang::TST_Accum;\n  static const TST TST_fract = clang::TST_Fract;\n  static const TST TST_float128 = clang::TST_float128;\n  static const TST TST_ibm128 = clang::TST_ibm128;\n  static const TST TST_bool = clang::TST_bool;\n  static const TST TST_decimal32 = clang::TST_decimal32;\n  static const TST TST_decimal64 = clang::TST_decimal64;\n  static const TST TST_decimal128 = clang::TST_decimal128;\n  static const TST TST_enum = clang::TST_enum;\n  static const TST TST_union = clang::TST_union;\n  static const TST TST_struct = clang::TST_struct;\n  static const TST TST_interface = clang::TST_interface;\n  static const TST TST_class = clang::TST_class;\n  static const TST TST_typename = clang::TST_typename;\n  static const TST TST_typeofType = clang::TST_typeofType;\n  static const TST TST_typeofExpr = clang::TST_typeofExpr;\n  static const TST TST_typeof_unqualType = clang::TST_typeof_unqualType;\n  static const TST TST_typeof_unqualExpr = clang::TST_typeof_unqualExpr;\n  static const TST TST_decltype = clang::TST_decltype;\n  static const TST TST_decltype_auto = clang::TST_decltype_auto;\n#define TRANSFORM_TYPE_TRAIT_DEF(_, Trait)                                     \\\n  static const TST TST_##Trait = clang::TST_##Trait;\n#include \"clang/Basic/TransformTypeTraits.def\"\n  static const TST TST_auto = clang::TST_auto;\n  static const TST TST_auto_type = clang::TST_auto_type;\n  static const TST TST_unknown_anytype = clang::TST_unknown_anytype;\n  static const TST TST_atomic = clang::TST_atomic;\n#define GENERIC_IMAGE_TYPE(ImgType, Id) \\\n  static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  static const TST TST_error = clang::TST_error;\n\n  // type-qualifiers\n  enum TQ {   // NOTE: These flags must be kept in sync with Qualifiers::TQ.\n    TQ_unspecified = 0,\n    TQ_const       = 1,\n    TQ_restrict    = 2,\n    TQ_volatile    = 4,\n    TQ_unaligned   = 8,\n    // This has no corresponding Qualifiers::TQ value, because it's not treated\n    // as a qualifier in our type system.\n    TQ_atomic      = 16\n  };\n\n  /// ParsedSpecifiers - Flags to query which specifiers were applied.  This is\n  /// returned by getParsedSpecifiers.\n  enum ParsedSpecifiers {\n    PQ_None                  = 0,\n    PQ_StorageClassSpecifier = 1,\n    PQ_TypeSpecifier         = 2,\n    PQ_TypeQualifier         = 4,\n    PQ_FunctionSpecifier     = 8\n    // FIXME: Attributes should be included here.\n  };\n\n  enum FriendSpecified : bool {\n    No,\n    Yes,\n  };\n\nprivate:\n  // storage-class-specifier\n  /*SCS*/unsigned StorageClassSpec : 3;\n  /*TSCS*/unsigned ThreadStorageClassSpec : 2;\n  unsigned SCS_extern_in_linkage_spec : 1;\n\n  // type-specifier\n  /*TypeSpecifierWidth*/ unsigned TypeSpecWidth : 2;\n  /*TSC*/unsigned TypeSpecComplex : 2;\n  /*TSS*/unsigned TypeSpecSign : 2;\n  /*TST*/unsigned TypeSpecType : 7;\n  unsigned TypeAltiVecVector : 1;\n  unsigned TypeAltiVecPixel : 1;\n  unsigned TypeAltiVecBool : 1;\n  unsigned TypeSpecOwned : 1;\n  unsigned TypeSpecPipe : 1;\n  unsigned TypeSpecSat : 1;\n  unsigned ConstrainedAuto : 1;\n\n  // type-qualifiers\n  unsigned TypeQualifiers : 5;  // Bitwise OR of TQ.\n\n  // function-specifier\n  unsigned FS_inline_specified : 1;\n  unsigned FS_forceinline_specified: 1;\n  unsigned FS_virtual_specified : 1;\n  unsigned FS_noreturn_specified : 1;\n\n  // friend-specifier\n  unsigned Friend_specified : 1;\n\n  // constexpr-specifier\n  unsigned ConstexprSpecifier : 2;\n\n  union {\n    UnionParsedType TypeRep;\n    Decl *DeclRep;\n    Expr *ExprRep;\n    TemplateIdAnnotation *TemplateIdRep;\n  };\n\n  /// ExplicitSpecifier - Store information about explicit spicifer.\n  ExplicitSpecifier FS_explicit_specifier;\n\n  // attributes.\n  ParsedAttributes Attrs;\n\n  // Scope specifier for the type spec, if applicable.\n  CXXScopeSpec TypeScope;\n\n  // SourceLocation info.  These are null if the item wasn't specified or if\n  // the setting was synthesized.\n  SourceRange Range;\n\n  SourceLocation StorageClassSpecLoc, ThreadStorageClassSpecLoc;\n  SourceRange TSWRange;\n  SourceLocation TSCLoc, TSSLoc, TSTLoc, AltiVecLoc, TSSatLoc;\n  /// TSTNameLoc - If TypeSpecType is any of class, enum, struct, union,\n  /// typename, then this is the location of the named type (if present);\n  /// otherwise, it is the same as TSTLoc. Hence, the pair TSTLoc and\n  /// TSTNameLoc provides source range info for tag types.\n  SourceLocation TSTNameLoc;\n  SourceRange TypeofParensRange;\n  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc,\n      TQ_unalignedLoc;\n  SourceLocation FS_inlineLoc, FS_virtualLoc, FS_explicitLoc, FS_noreturnLoc;\n  SourceLocation FS_explicitCloseParenLoc;\n  SourceLocation FS_forceinlineLoc;\n  SourceLocation FriendLoc, ModulePrivateLoc, ConstexprLoc;\n  SourceLocation TQ_pipeLoc;\n\n  WrittenBuiltinSpecs writtenBS;\n  void SaveWrittenBuiltinSpecs();\n\n  ObjCDeclSpec *ObjCQualifiers;\n\n  static bool isTypeRep(TST T) {\n    return T == TST_atomic || T == TST_typename || T == TST_typeofType ||\n           T == TST_typeof_unqualType || isTransformTypeTrait(T);\n  }\n  static bool isExprRep(TST T) {\n    return T == TST_typeofExpr || T == TST_typeof_unqualExpr ||\n           T == TST_decltype || T == TST_bitint;\n  }\n  static bool isTemplateIdRep(TST T) {\n    return (T == TST_auto || T == TST_decltype_auto);\n  }\n\n  DeclSpec(const DeclSpec &) = delete;\n  void operator=(const DeclSpec &) = delete;\npublic:\n  static bool isDeclRep(TST T) {\n    return (T == TST_enum || T == TST_struct ||\n            T == TST_interface || T == TST_union ||\n            T == TST_class);\n  }\n  static bool isTransformTypeTrait(TST T) {\n    constexpr std::array<TST, 16> Traits = {\n#define TRANSFORM_TYPE_TRAIT_DEF(_, Trait) TST_##Trait,\n#include \"clang/Basic/TransformTypeTraits.def\"\n    };\n\n    return T >= Traits.front() && T <= Traits.back();\n  }\n\n  DeclSpec(AttributeFactory &attrFactory)\n      : StorageClassSpec(SCS_unspecified),\n        ThreadStorageClassSpec(TSCS_unspecified),\n        SCS_extern_in_linkage_spec(false),\n        TypeSpecWidth(static_cast<unsigned>(TypeSpecifierWidth::Unspecified)),\n        TypeSpecComplex(TSC_unspecified),\n        TypeSpecSign(static_cast<unsigned>(TypeSpecifierSign::Unspecified)),\n        TypeSpecType(TST_unspecified), TypeAltiVecVector(false),\n        TypeAltiVecPixel(false), TypeAltiVecBool(false), TypeSpecOwned(false),\n        TypeSpecPipe(false), TypeSpecSat(false), ConstrainedAuto(false),\n        TypeQualifiers(TQ_unspecified), FS_inline_specified(false),\n        FS_forceinline_specified(false), FS_virtual_specified(false),\n        FS_noreturn_specified(false), Friend_specified(false),\n        ConstexprSpecifier(\n            static_cast<unsigned>(ConstexprSpecKind::Unspecified)),\n        Attrs(attrFactory), writtenBS(), ObjCQualifiers(nullptr) {}\n\n  // storage-class-specifier\n  SCS getStorageClassSpec() const { return (SCS)StorageClassSpec; }\n  TSCS getThreadStorageClassSpec() const {\n    return (TSCS)ThreadStorageClassSpec;\n  }\n  bool isExternInLinkageSpec() const { return SCS_extern_in_linkage_spec; }\n  void setExternInLinkageSpec(bool Value) {\n    SCS_extern_in_linkage_spec = Value;\n  }\n\n  SourceLocation getStorageClassSpecLoc() const { return StorageClassSpecLoc; }\n  SourceLocation getThreadStorageClassSpecLoc() const {\n    return ThreadStorageClassSpecLoc;\n  }\n\n  void ClearStorageClassSpecs() {\n    StorageClassSpec           = DeclSpec::SCS_unspecified;\n    ThreadStorageClassSpec     = DeclSpec::TSCS_unspecified;\n    SCS_extern_in_linkage_spec = false;\n    StorageClassSpecLoc        = SourceLocation();\n    ThreadStorageClassSpecLoc  = SourceLocation();\n  }\n\n  void ClearTypeSpecType() {\n    TypeSpecType = DeclSpec::TST_unspecified;\n    TypeSpecOwned = false;\n    TSTLoc = SourceLocation();\n  }\n\n  // type-specifier\n  TypeSpecifierWidth getTypeSpecWidth() const {\n    return static_cast<TypeSpecifierWidth>(TypeSpecWidth);\n  }\n  TSC getTypeSpecComplex() const { return (TSC)TypeSpecComplex; }\n  TypeSpecifierSign getTypeSpecSign() const {\n    return static_cast<TypeSpecifierSign>(TypeSpecSign);\n  }\n  TST getTypeSpecType() const { return (TST)TypeSpecType; }\n  bool isTypeAltiVecVector() const { return TypeAltiVecVector; }\n  bool isTypeAltiVecPixel() const { return TypeAltiVecPixel; }\n  bool isTypeAltiVecBool() const { return TypeAltiVecBool; }\n  bool isTypeSpecOwned() const { return TypeSpecOwned; }\n  bool isTypeRep() const { return isTypeRep((TST) TypeSpecType); }\n  bool isTypeSpecPipe() const { return TypeSpecPipe; }\n  bool isTypeSpecSat() const { return TypeSpecSat; }\n  bool isConstrainedAuto() const { return ConstrainedAuto; }\n\n  ParsedType getRepAsType() const {\n    assert(isTypeRep((TST) TypeSpecType) && \"DeclSpec does not store a type\");\n    return TypeRep;\n  }\n  Decl *getRepAsDecl() const {\n    assert(isDeclRep((TST) TypeSpecType) && \"DeclSpec does not store a decl\");\n    return DeclRep;\n  }\n  Expr *getRepAsExpr() const {\n    assert(isExprRep((TST) TypeSpecType) && \"DeclSpec does not store an expr\");\n    return ExprRep;\n  }\n  TemplateIdAnnotation *getRepAsTemplateId() const {\n    assert(isTemplateIdRep((TST) TypeSpecType) &&\n           \"DeclSpec does not store a template id\");\n    return TemplateIdRep;\n  }\n  CXXScopeSpec &getTypeSpecScope() { return TypeScope; }\n  const CXXScopeSpec &getTypeSpecScope() const { return TypeScope; }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getTypeSpecWidthLoc() const { return TSWRange.getBegin(); }\n  SourceRange getTypeSpecWidthRange() const { return TSWRange; }\n  SourceLocation getTypeSpecComplexLoc() const { return TSCLoc; }\n  SourceLocation getTypeSpecSignLoc() const { return TSSLoc; }\n  SourceLocation getTypeSpecTypeLoc() const { return TSTLoc; }\n  SourceLocation getAltiVecLoc() const { return AltiVecLoc; }\n  SourceLocation getTypeSpecSatLoc() const { return TSSatLoc; }\n\n  SourceLocation getTypeSpecTypeNameLoc() const {\n    assert(isDeclRep((TST)TypeSpecType) || isTypeRep((TST)TypeSpecType) ||\n           isExprRep((TST)TypeSpecType));\n    return TSTNameLoc;\n  }\n\n  SourceRange getTypeofParensRange() const { return TypeofParensRange; }\n  void setTypeArgumentRange(SourceRange range) { TypeofParensRange = range; }\n\n  bool hasAutoTypeSpec() const {\n    return (TypeSpecType == TST_auto || TypeSpecType == TST_auto_type ||\n            TypeSpecType == TST_decltype_auto);\n  }\n\n  bool hasTagDefinition() const;\n\n  /// Turn a type-specifier-type into a string like \"_Bool\" or \"union\".\n  static const char *getSpecifierName(DeclSpec::TST T,\n                                      const PrintingPolicy &Policy);\n  static const char *getSpecifierName(DeclSpec::TQ Q);\n  static const char *getSpecifierName(TypeSpecifierSign S);\n  static const char *getSpecifierName(DeclSpec::TSC C);\n  static const char *getSpecifierName(TypeSpecifierWidth W);\n  static const char *getSpecifierName(DeclSpec::SCS S);\n  static const char *getSpecifierName(DeclSpec::TSCS S);\n  static const char *getSpecifierName(ConstexprSpecKind C);\n\n  // type-qualifiers\n\n  /// getTypeQualifiers - Return a set of TQs.\n  unsigned getTypeQualifiers() const { return TypeQualifiers; }\n  SourceLocation getConstSpecLoc() const { return TQ_constLoc; }\n  SourceLocation getRestrictSpecLoc() const { return TQ_restrictLoc; }\n  SourceLocation getVolatileSpecLoc() const { return TQ_volatileLoc; }\n  SourceLocation getAtomicSpecLoc() const { return TQ_atomicLoc; }\n  SourceLocation getUnalignedSpecLoc() const { return TQ_unalignedLoc; }\n  SourceLocation getPipeLoc() const { return TQ_pipeLoc; }\n\n  /// Clear out all of the type qualifiers.\n  void ClearTypeQualifiers() {\n    TypeQualifiers = 0;\n    TQ_constLoc = SourceLocation();\n    TQ_restrictLoc = SourceLocation();\n    TQ_volatileLoc = SourceLocation();\n    TQ_atomicLoc = SourceLocation();\n    TQ_unalignedLoc = SourceLocation();\n    TQ_pipeLoc = SourceLocation();\n  }\n\n  // function-specifier\n  bool isInlineSpecified() const {\n    return FS_inline_specified | FS_forceinline_specified;\n  }\n  SourceLocation getInlineSpecLoc() const {\n    return FS_inline_specified ? FS_inlineLoc : FS_forceinlineLoc;\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() const {\n    return FS_explicit_specifier;\n  }\n\n  bool isVirtualSpecified() const { return FS_virtual_specified; }\n  SourceLocation getVirtualSpecLoc() const { return FS_virtualLoc; }\n\n  bool hasExplicitSpecifier() const {\n    return FS_explicit_specifier.isSpecified();\n  }\n  SourceLocation getExplicitSpecLoc() const { return FS_explicitLoc; }\n  SourceRange getExplicitSpecRange() const {\n    return FS_explicit_specifier.getExpr()\n               ? SourceRange(FS_explicitLoc, FS_explicitCloseParenLoc)\n               : SourceRange(FS_explicitLoc);\n  }\n\n  bool isNoreturnSpecified() const { return FS_noreturn_specified; }\n  SourceLocation getNoreturnSpecLoc() const { return FS_noreturnLoc; }\n\n  void ClearFunctionSpecs() {\n    FS_inline_specified = false;\n    FS_inlineLoc = SourceLocation();\n    FS_forceinline_specified = false;\n    FS_forceinlineLoc = SourceLocation();\n    FS_virtual_specified = false;\n    FS_virtualLoc = SourceLocation();\n    FS_explicit_specifier = ExplicitSpecifier();\n    FS_explicitLoc = SourceLocation();\n    FS_explicitCloseParenLoc = SourceLocation();\n    FS_noreturn_specified = false;\n    FS_noreturnLoc = SourceLocation();\n  }\n\n  /// This method calls the passed in handler on each CVRU qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachCVRUQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// This method calls the passed in handler on each qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// Return true if any type-specifier has been found.\n  bool hasTypeSpecifier() const {\n    return getTypeSpecType() != DeclSpec::TST_unspecified ||\n           getTypeSpecWidth() != TypeSpecifierWidth::Unspecified ||\n           getTypeSpecComplex() != DeclSpec::TSC_unspecified ||\n           getTypeSpecSign() != TypeSpecifierSign::Unspecified;\n  }\n\n  /// Return a bitmask of which flavors of specifiers this\n  /// DeclSpec includes.\n  unsigned getParsedSpecifiers() const;\n\n  /// isEmpty - Return true if this declaration specifier is completely empty:\n  /// no tokens were parsed in the production of it.\n  bool isEmpty() const {\n    return getParsedSpecifiers() == DeclSpec::PQ_None;\n  }\n\n  void SetRangeStart(SourceLocation Loc) { Range.setBegin(Loc); }\n  void SetRangeEnd(SourceLocation Loc) { Range.setEnd(Loc); }\n\n  /// These methods set the specified attribute of the DeclSpec and\n  /// return false if there was no error.  If an error occurs (for\n  /// example, if we tried to set \"auto\" on a spec with \"extern\"\n  /// already set), they return true and set PrevSpec and DiagID\n  /// such that\n  ///   Diag(Loc, DiagID) << PrevSpec;\n  /// will yield a useful result.\n  ///\n  /// TODO: use a more general approach that still allows these\n  /// diagnostics to be ignored when desired.\n  bool SetStorageClassSpec(Sema &S, SCS SC, SourceLocation Loc,\n                           const char *&PrevSpec, unsigned &DiagID,\n                           const PrintingPolicy &Policy);\n  bool SetStorageClassSpecThread(TSCS TSC, SourceLocation Loc,\n                                 const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecWidth(TypeSpecifierWidth W, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID,\n                        const PrintingPolicy &Policy);\n  bool SetTypeSpecComplex(TSC C, SourceLocation Loc, const char *&PrevSpec,\n                          unsigned &DiagID);\n  bool SetTypeSpecSign(TypeSpecifierSign S, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TypeResult Rep,\n                       const PrintingPolicy &Policy) {\n    if (Rep.isInvalid())\n      return SetTypeSpecError();\n    return SetTypeSpecType(T, Loc, PrevSpec, DiagID, Rep.get(), Policy);\n  }\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TemplateIdAnnotation *Rep,\n                       const PrintingPolicy &Policy);\n\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Expr *Rep,\n                       const PrintingPolicy &policy);\n  bool SetTypeAltiVecVector(bool isAltiVecVector, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecPixel(bool isAltiVecPixel, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecBool(bool isAltiVecBool, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypePipe(bool isPipe, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetBitIntType(SourceLocation KWLoc, Expr *BitWidth,\n                     const char *&PrevSpec, unsigned &DiagID,\n                     const PrintingPolicy &Policy);\n  bool SetTypeSpecSat(SourceLocation Loc, const char *&PrevSpec,\n                      unsigned &DiagID);\n  bool SetTypeSpecError();\n  void UpdateDeclRep(Decl *Rep) {\n    assert(isDeclRep((TST) TypeSpecType));\n    DeclRep = Rep;\n  }\n  void UpdateTypeRep(ParsedType Rep) {\n    assert(isTypeRep((TST) TypeSpecType));\n    TypeRep = Rep;\n  }\n  void UpdateExprRep(Expr *Rep) {\n    assert(isExprRep((TST) TypeSpecType));\n    ExprRep = Rep;\n  }\n\n  bool SetTypeQual(TQ T, SourceLocation Loc);\n\n  bool SetTypeQual(TQ T, SourceLocation Loc, const char *&PrevSpec,\n                   unsigned &DiagID, const LangOptions &Lang);\n\n  bool setFunctionSpecInline(SourceLocation Loc, const char *&PrevSpec,\n                             unsigned &DiagID);\n  bool setFunctionSpecForceInline(SourceLocation Loc, const char *&PrevSpec,\n                                  unsigned &DiagID);\n  bool setFunctionSpecVirtual(SourceLocation Loc, const char *&PrevSpec,\n                              unsigned &DiagID);\n  bool setFunctionSpecExplicit(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID, ExplicitSpecifier ExplicitSpec,\n                               SourceLocation CloseParenLoc);\n  bool setFunctionSpecNoreturn(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID);\n\n  bool SetFriendSpec(SourceLocation Loc, const char *&PrevSpec,\n                     unsigned &DiagID);\n  bool setModulePrivateSpec(SourceLocation Loc, const char *&PrevSpec,\n                            unsigned &DiagID);\n  bool SetConstexprSpec(ConstexprSpecKind ConstexprKind, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID);\n\n  FriendSpecified isFriendSpecified() const {\n    return static_cast<FriendSpecified>(Friend_specified);\n  }\n\n  SourceLocation getFriendSpecLoc() const { return FriendLoc; }\n\n  bool isModulePrivateSpecified() const { return ModulePrivateLoc.isValid(); }\n  SourceLocation getModulePrivateSpecLoc() const { return ModulePrivateLoc; }\n\n  ConstexprSpecKind getConstexprSpecifier() const {\n    return ConstexprSpecKind(ConstexprSpecifier);\n  }\n\n  SourceLocation getConstexprSpecLoc() const { return ConstexprLoc; }\n  bool hasConstexprSpecifier() const {\n    return getConstexprSpecifier() != ConstexprSpecKind::Unspecified;\n  }\n\n  void ClearConstexprSpec() {\n    ConstexprSpecifier = static_cast<unsigned>(ConstexprSpecKind::Unspecified);\n    ConstexprLoc = SourceLocation();\n  }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// Concatenates two attribute lists.\n  ///\n  /// The GCC attribute syntax allows for the following:\n  ///\n  /// \\code\n  /// short __attribute__(( unused, deprecated ))\n  /// int __attribute__(( may_alias, aligned(16) )) var;\n  /// \\endcode\n  ///\n  /// This declares 4 attributes using 2 lists. The following syntax is\n  /// also allowed and equivalent to the previous declaration.\n  ///\n  /// \\code\n  /// short __attribute__((unused)) __attribute__((deprecated))\n  /// int __attribute__((may_alias)) __attribute__((aligned(16))) var;\n  /// \\endcode\n  ///\n  void addAttributes(const ParsedAttributesView &AL) {\n    Attrs.addAll(AL.begin(), AL.end());\n  }\n\n  bool hasAttributes() const { return !Attrs.empty(); }\n\n  ParsedAttributes &getAttributes() { return Attrs; }\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n\n  void takeAttributesFrom(ParsedAttributes &attrs) {\n    Attrs.takeAllFrom(attrs);\n  }\n\n  /// Finish - This does final analysis of the declspec, issuing diagnostics for\n  /// things like \"_Imaginary\" (lacking an FP type).  After calling this method,\n  /// DeclSpec is guaranteed self-consistent, even if an error occurred.\n  void Finish(Sema &S, const PrintingPolicy &Policy);\n\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return writtenBS;\n  }\n\n  ObjCDeclSpec *getObjCQualifiers() const { return ObjCQualifiers; }\n  void setObjCQualifiers(ObjCDeclSpec *quals) { ObjCQualifiers = quals; }\n\n  /// Checks if this DeclSpec can stand alone, without a Declarator.\n  ///\n  /// Only tag declspecs can stand alone.\n  bool isMissingDeclaratorOk();\n}",
  "id": "BLOCK-CPP-19707",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DeclSpec.h",
  "source_line": 246,
  "validation_status": "validated"
}