{
  "code": "#include <atomic>\n#include <vector>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/raw_logging.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06176_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\n// This base class allows multiple types of object (CordzInfo and\n// CordzSampleToken) to exist simultaneously on the delete queue (pointed to by\n// global_dq_tail and traversed using dq_prev_ and dq_next_). The\n// delete queue guarantees that once a profiler creates a CordzSampleToken and\n// has gained visibility into a CordzInfo object, that CordzInfo object will not\n// be deleted prematurely. This allows the profiler to inspect all CordzInfo\n// objects that are alive without needing to hold a global lock.\nclass ABSL_DLL CordzHandle {\n public:\n  CordzHandle() : CordzHandle(false) {}\n\n  bool is_snapshot() const { return is_snapshot_; }\n\n  // Returns true if this instance is safe to be deleted because it is either a\n  // snapshot, which is always safe to delete, or not included in the global\n  // delete queue and thus not included in any snapshot.\n  // Callers are responsible for making sure this instance can not be newly\n  // discovered by other threads. For example, CordzInfo instances first de-list\n  // themselves from the global CordzInfo list before determining if they are\n  // safe to be deleted directly.\n  // If SafeToDelete returns false, callers MUST use the Delete() method to\n  // safely queue CordzHandle instances for deletion.\n  bool SafeToDelete() const;\n\n  // Deletes the provided instance, or puts it on the delete queue to be deleted\n  // once there are no more sample tokens (snapshot) instances potentially\n  // referencing the instance. `handle` should not be null.\n  static void Delete(CordzHandle* handle);\n\n  // Returns the current entries in the delete queue in LIFO order.\n  static std::vector<const CordzHandle*> DiagnosticsGetDeleteQueue();\n\n  // Returns true if the provided handle is nullptr or guarded by this handle.\n  // Since the CordzSnapshot token is itself a CordzHandle, this method will\n  // allow tests to check if that token is keeping an arbitrary CordzHandle\n  // alive.\n  bool DiagnosticsHandleIsSafeToInspect(const CordzHandle* handle) const;\n\n  // Returns the current entries in the delete queue, in LIFO order, that are\n  // protected by this. CordzHandle objects are only placed on the delete queue\n  // after CordzHandle::Delete is called with them as an argument. Only\n  // CordzHandle objects that are not also CordzSnapshot objects will be\n  // included in the return vector. For each of the handles in the return\n  // vector, the earliest that their memory can be freed is when this\n  // CordzSnapshot object is deleted.\n  std::vector<const CordzHandle*> DiagnosticsGetSafeToInspectDeletedHandles();\n\n protected:\n  explicit CordzHandle(bool is_snapshot);\n  virtual ~CordzHandle();\n\n private:\n  const bool is_snapshot_;\n\n  // dq_prev_ and dq_next_ require the global queue mutex to be held.\n  // Unfortunately we can't use thread annotations such that the thread safety\n  // analysis understands that queue_ and global_queue_ are one and the same.\n  CordzHandle* dq_prev_  = nullptr;\n  CordzHandle* dq_next_ = nullptr;\n};\n\nclass CordzSnapshot : public CordzHandle {\n public:\n  CordzSnapshot() : CordzHandle(true) {}\n};\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06176",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_handle.h",
  "source_line": 24,
  "validation_status": "validated"
}