{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace ascii_internal {\n\n// # Table generated by this Python code (bit 0x02 is currently unused):\n// TODO(mbar) Move Python code for generation of table to BUILD and link here.\n\n// NOTE: The kAsciiPropertyBits table used within this code was generated by\n// Python code of the following form. (Bit 0x02 is currently unused and\n// available.)\n//\n// def Hex2(n):\n//   return '0x' + hex(n/16)[2:] + hex(n%16)[2:]\n// def IsPunct(ch):\n//   return (ord(ch) >= 32 and ord(ch) < 127 and\n//           not ch.isspace() and not ch.isalnum())\n// def IsBlank(ch):\n//   return ch in ' \\t'\n// def IsCntrl(ch):\n//   return ord(ch) < 32 or ord(ch) == 127\n// def IsXDigit(ch):\n//   return ch.isdigit() or ch.lower() in 'abcdef'\n// for i in range(128):\n//   ch = chr(i)\n//   mask = ((ch.isalpha() and 0x01 or 0) |\n//           (ch.isalnum() and 0x04 or 0) |\n//           (ch.isspace() and 0x08 or 0) |\n//           (IsPunct(ch) and 0x10 or 0) |\n//           (IsBlank(ch) and 0x20 or 0) |\n//           (IsCntrl(ch) and 0x40 or 0) |\n//           (IsXDigit(ch) and 0x80 or 0))\n//   print Hex2(mask) + ',',\n//   if i % 16 == 7:\n//     print ' //', Hex2(i & 0x78)\n//   elif i % 16 == 15:\n//     print\n\n// clang-format off\n// Array of bitfields holding character information. Each bit value corresponds\n// to a particular character feature. For readability, and because the value\n// of these bits is tightly coupled to this implementation, the individual bits\n// are not named. Note that bitfields for all characters above ASCII 127 are\n// zero-initialized.\nABSL_DLL const unsigned char kPropertyBits[256] = {\n    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x00\n    0x40, 0x68, 0x48, 0x48, 0x48, 0x48, 0x40, 0x40,\n    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x10\n    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,\n    0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  // 0x20\n    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n    0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,  // 0x30\n    0x84, 0x84, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n    0x10, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x05,  // 0x40\n    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,  // 0x50\n    0x05, 0x05, 0x05, 0x10, 0x10, 0x10, 0x10, 0x10,\n    0x10, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x05,  // 0x60\n    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,  // 0x70\n    0x05, 0x05, 0x05, 0x10, 0x10, 0x10, 0x10, 0x40,\n};\n\n// Array of characters for the ascii_tolower() function. For values 'A'\n// through 'Z', return the lower-case character; otherwise, return the\n// identity of the passed character.\nABSL_DLL const char kToLower[256] = {\n  '\\x00', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07',\n  '\\x08', '\\x09', '\\x0a', '\\x0b', '\\x0c', '\\x0d', '\\x0e', '\\x0f',\n  '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17',\n  '\\x18', '\\x19', '\\x1a', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f',\n  '\\x20', '\\x21', '\\x22', '\\x23', '\\x24', '\\x25', '\\x26', '\\x27',\n  '\\x28', '\\x29', '\\x2a', '\\x2b', '\\x2c', '\\x2d', '\\x2e', '\\x2f',\n  '\\x30', '\\x31', '\\x32', '\\x33', '\\x34', '\\x35', '\\x36', '\\x37',\n  '\\x38', '\\x39', '\\x3a', '\\x3b', '\\x3c', '\\x3d', '\\x3e', '\\x3f',\n  '\\x40',    'a',    'b',    'c',    'd',    'e',    'f',    'g',\n     'h',    'i',    'j',    'k',    'l',    'm',    'n',    'o',\n     'p',    'q',    'r',    's',    't',    'u',    'v',    'w',\n     'x',    'y',    'z', '\\x5b', '\\x5c', '\\x5d', '\\x5e', '\\x5f',\n  '\\x60', '\\x61', '\\x62', '\\x63', '\\x64', '\\x65', '\\x66', '\\x67',\n  '\\x68', '\\x69', '\\x6a', '\\x6b', '\\x6c', '\\x6d', '\\x6e', '\\x6f',\n  '\\x70', '\\x71', '\\x72', '\\x73', '\\x74', '\\x75', '\\x76', '\\x77',\n  '\\x78', '\\x79', '\\x7a', '\\x7b', '\\x7c', '\\x7d', '\\x7e', '\\x7f',\n  '\\x80', '\\x81', '\\x82', '\\x83', '\\x84', '\\x85', '\\x86', '\\x87',\n  '\\x88', '\\x89', '\\x8a', '\\x8b', '\\x8c', '\\x8d', '\\x8e', '\\x8f',\n  '\\x90', '\\x91', '\\x92', '\\x93', '\\x94', '\\x95', '\\x96', '\\x97',\n  '\\x98', '\\x99', '\\x9a', '\\x9b', '\\x9c', '\\x9d', '\\x9e', '\\x9f',\n  '\\xa0', '\\xa1', '\\xa2', '\\xa3', '\\xa4', '\\xa5', '\\xa6', '\\xa7',\n  '\\xa8', '\\xa9', '\\xaa', '\\xab', '\\xac', '\\xad', '\\xae', '\\xaf',\n  '\\xb0', '\\xb1', '\\xb2', '\\xb3', '\\xb4', '\\xb5', '\\xb6', '\\xb7',\n  '\\xb8', '\\xb9', '\\xba', '\\xbb', '\\xbc', '\\xbd', '\\xbe', '\\xbf',\n  '\\xc0', '\\xc1', '\\xc2', '\\xc3', '\\xc4', '\\xc5', '\\xc6', '\\xc7',\n  '\\xc8', '\\xc9', '\\xca', '\\xcb', '\\xcc', '\\xcd', '\\xce', '\\xcf',\n  '\\xd0', '\\xd1', '\\xd2', '\\xd3', '\\xd4', '\\xd5', '\\xd6', '\\xd7',\n  '\\xd8', '\\xd9', '\\xda', '\\xdb', '\\xdc', '\\xdd', '\\xde', '\\xdf',\n  '\\xe0', '\\xe1', '\\xe2', '\\xe3', '\\xe4', '\\xe5', '\\xe6', '\\xe7',\n  '\\xe8', '\\xe9', '\\xea', '\\xeb', '\\xec', '\\xed', '\\xee', '\\xef',\n  '\\xf0', '\\xf1', '\\xf2', '\\xf3', '\\xf4', '\\xf5', '\\xf6', '\\xf7',\n  '\\xf8', '\\xf9', '\\xfa', '\\xfb', '\\xfc', '\\xfd', '\\xfe', '\\xff',\n};\n\n// Array of characters for the ascii_toupper() function. For values 'a'\n// through 'z', return the upper-case character; otherwise, return the\n// identity of the passed character.\nABSL_DLL const char kToUpper[256] = {\n  '\\x00', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07',\n  '\\x08', '\\x09', '\\x0a', '\\x0b', '\\x0c', '\\x0d', '\\x0e', '\\x0f',\n  '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17',\n  '\\x18', '\\x19', '\\x1a', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f',\n  '\\x20', '\\x21', '\\x22', '\\x23', '\\x24', '\\x25', '\\x26', '\\x27',\n  '\\x28', '\\x29', '\\x2a', '\\x2b', '\\x2c', '\\x2d', '\\x2e', '\\x2f',\n  '\\x30', '\\x31', '\\x32', '\\x33', '\\x34', '\\x35', '\\x36', '\\x37',\n  '\\x38', '\\x39', '\\x3a', '\\x3b', '\\x3c', '\\x3d', '\\x3e', '\\x3f',\n  '\\x40', '\\x41', '\\x42', '\\x43', '\\x44', '\\x45', '\\x46', '\\x47',\n  '\\x48', '\\x49', '\\x4a', '\\x4b', '\\x4c', '\\x4d', '\\x4e', '\\x4f',\n  '\\x50', '\\x51', '\\x52', '\\x53', '\\x54', '\\x55', '\\x56', '\\x57',\n  '\\x58', '\\x59', '\\x5a', '\\x5b', '\\x5c', '\\x5d', '\\x5e', '\\x5f',\n  '\\x60',    'A',    'B',    'C',    'D',    'E',    'F',    'G',\n     'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',\n     'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',\n     'X',    'Y',    'Z', '\\x7b', '\\x7c', '\\x7d', '\\x7e', '\\x7f',\n  '\\x80', '\\x81', '\\x82', '\\x83', '\\x84', '\\x85', '\\x86', '\\x87',\n  '\\x88', '\\x89', '\\x8a', '\\x8b', '\\x8c', '\\x8d', '\\x8e', '\\x8f',\n  '\\x90', '\\x91', '\\x92', '\\x93', '\\x94', '\\x95', '\\x96', '\\x97',\n  '\\x98', '\\x99', '\\x9a', '\\x9b', '\\x9c', '\\x9d', '\\x9e', '\\x9f',\n  '\\xa0', '\\xa1', '\\xa2', '\\xa3', '\\xa4', '\\xa5', '\\xa6', '\\xa7',\n  '\\xa8', '\\xa9', '\\xaa', '\\xab', '\\xac', '\\xad', '\\xae', '\\xaf',\n  '\\xb0', '\\xb1', '\\xb2', '\\xb3', '\\xb4', '\\xb5', '\\xb6', '\\xb7',\n  '\\xb8', '\\xb9', '\\xba', '\\xbb', '\\xbc', '\\xbd', '\\xbe', '\\xbf',\n  '\\xc0', '\\xc1', '\\xc2', '\\xc3', '\\xc4', '\\xc5', '\\xc6', '\\xc7',\n  '\\xc8', '\\xc9', '\\xca', '\\xcb', '\\xcc', '\\xcd', '\\xce', '\\xcf',\n  '\\xd0', '\\xd1', '\\xd2', '\\xd3', '\\xd4', '\\xd5', '\\xd6', '\\xd7',\n  '\\xd8', '\\xd9', '\\xda', '\\xdb', '\\xdc', '\\xdd', '\\xde', '\\xdf',\n  '\\xe0', '\\xe1', '\\xe2', '\\xe3', '\\xe4', '\\xe5', '\\xe6', '\\xe7',\n  '\\xe8', '\\xe9', '\\xea', '\\xeb', '\\xec', '\\xed', '\\xee', '\\xef',\n  '\\xf0', '\\xf1', '\\xf2', '\\xf3', '\\xf4', '\\xf5', '\\xf6', '\\xf7',\n  '\\xf8', '\\xf9', '\\xfa', '\\xfb', '\\xfc', '\\xfd', '\\xfe', '\\xff',\n};\n// clang-format on\n\ntemplate <class T>\nstatic constexpr T BroadcastByte(unsigned char value) {\n  static_assert(std::is_integral<T>::value && sizeof(T) <= sizeof(uint64_t) &&\n                    std::is_unsigned<T>::value,\n                \"only unsigned integers up to 64-bit allowed\");\n  T result = value;\n  constexpr size_t result_bit_width = sizeof(result) * CHAR_BIT;\n  result |= result << ((CHAR_BIT << 0) & (result_bit_width - 1));\n  result |= result << ((CHAR_BIT << 1) & (result_bit_width - 1));\n  result |= result << ((CHAR_BIT << 2) & (result_bit_width - 1));\n  return result;\n}\n\n// Returns whether `c` is in the a-z/A-Z range (w.r.t. `ToUpper`).\n// Implemented by:\n//  1. Pushing the a-z/A-Z range to [SCHAR_MIN, SCHAR_MIN + 26).\n//  2. Comparing to SCHAR_MIN + 26.\ntemplate <bool ToUpper>\nconstexpr bool AsciiInAZRange(unsigned char c) {\n  constexpr unsigned char sub = (ToUpper ? 'a' : 'A') - SCHAR_MIN;\n  constexpr signed char threshold = SCHAR_MIN + 26;  // 26 = alphabet size.\n  // Using unsigned arithmetic as overflows/underflows are well defined.\n  unsigned char u = c - sub;\n  // Using signed cmp, as SIMD unsigned cmp isn't available in many platforms.\n  return static_cast<signed char>(u) < threshold;\n}\n\ntemplate <bool ToUpper>\nstatic constexpr char* PartialAsciiStrCaseFold(absl::Nonnull<char*> p,\n                                               absl::Nonnull<char*> end) {\n  using vec_t = size_t;\n  const size_t n = static_cast<size_t>(end - p);\n\n  // SWAR algorithm: http://0x80.pl/notesen/2016-01-06-swar-swap-case.html\n  constexpr char ch_a = ToUpper ? 'a' : 'A', ch_z = ToUpper ? 'z' : 'Z';\n  char* const swar_end = p + (n / sizeof(vec_t)) * sizeof(vec_t);\n  while (p < swar_end) {\n    vec_t v = vec_t();\n\n    // memcpy the vector, but constexpr\n    for (size_t i = 0; i < sizeof(vec_t); ++i) {\n      v |= static_cast<vec_t>(static_cast<unsigned char>(p[i]))\n           << (i * CHAR_BIT);\n    }\n\n    constexpr unsigned int msb = 1u << (CHAR_BIT - 1);\n    const vec_t v_msb = v & BroadcastByte<vec_t>(msb);\n    const vec_t v_nonascii_mask = (v_msb << 1) - (v_msb >> (CHAR_BIT - 1));\n    const vec_t v_nonascii = v & v_nonascii_mask;\n    const vec_t v_ascii = v & ~v_nonascii_mask;\n    const vec_t a = v_ascii + BroadcastByte<vec_t>(msb - ch_a - 0),\n                z = v_ascii + BroadcastByte<vec_t>(msb - ch_z - 1);\n    v = v_nonascii | (v_ascii ^ ((a ^ z) & BroadcastByte<vec_t>(msb)) >> 2);\n\n    // memcpy the vector, but constexpr\n    for (size_t i = 0; i < sizeof(vec_t); ++i) {\n      p[i] = static_cast<char>(v >> (i * CHAR_BIT));\n    }\n\n    p += sizeof(v);\n  }\n\n  return p;\n}\n\ntemplate <bool ToUpper>\nstatic constexpr void AsciiStrCaseFold(absl::Nonnull<char*> p,\n                                       absl::Nonnull<char*> end) {\n  // The upper- and lowercase versions of ASCII characters differ by only 1 bit.\n  // When we need to flip the case, we can xor with this bit to achieve the\n  // desired result. Note that the choice of 'a' and 'A' here is arbitrary. We\n  // could have chosen 'z' and 'Z', or any other pair of characters as they all\n  // have the same single bit difference.\n  constexpr unsigned char kAsciiCaseBitFlip = 'a' ^ 'A';\n\n  using vec_t = size_t;\n  // TODO(b/316380338): When FDO becomes able to vectorize these,\n  // revert this manual optimization and just leave the naive loop.\n  if (static_cast<size_t>(end - p) >= sizeof(vec_t)) {\n    p = ascii_internal::PartialAsciiStrCaseFold<ToUpper>(p, end);\n  }\n  while (p < end) {\n    unsigned char v = static_cast<unsigned char>(*p);\n    v ^= AsciiInAZRange<ToUpper>(v) ? kAsciiCaseBitFlip : 0;\n    *p = static_cast<char>(v);\n    ++p;\n  }\n}\n\nstatic constexpr size_t ValidateAsciiCasefold() {\n  constexpr size_t num_chars = 1 + CHAR_MAX - CHAR_MIN;\n  size_t incorrect_index = 0;\n  char lowered[num_chars] = {};\n  char uppered[num_chars] = {};\n  for (unsigned int i = 0; i < num_chars; ++i) {\n    uppered[i] = lowered[i] = static_cast<char>(i);\n  }\n  AsciiStrCaseFold<false>(&lowered[0], &lowered[num_chars]);\n  AsciiStrCaseFold<true>(&uppered[0], &uppered[num_chars]);\n  for (size_t i = 0; i < num_chars; ++i) {\n    const char ch = static_cast<char>(i),\n               ch_upper = ('a' <= ch && ch <= 'z' ? 'A' + (ch - 'a') : ch),\n               ch_lower = ('A' <= ch && ch <= 'Z' ? 'a' + (ch - 'A') : ch);\n    if (uppered[i] != ch_upper || lowered[i] != ch_lower) {\n      incorrect_index = i > 0 ? i : num_chars;\n      break;\n    }\n  }\n  return incorrect_index;\n}\n\nstatic_assert(ValidateAsciiCasefold() == 0, \"error in case conversion\");\n\n}  // namespace ascii_internal\n\nvoid AsciiStrToLower(absl::Nonnull<std::string*> s) {\n  char* p = &(*s)[0];  // Guaranteed to be valid for empty strings\n  return ascii_internal::AsciiStrCaseFold<false>(p, p + s->size());\n}\n\nvoid AsciiStrToUpper(absl::Nonnull<std::string*> s) {\n  char* p = &(*s)[0];  // Guaranteed to be valid for empty strings\n  return ascii_internal::AsciiStrCaseFold<true>(p, p + s->size());\n}\n\nvoid RemoveExtraAsciiWhitespace(absl::Nonnull<std::string*> str) {\n  auto stripped = StripAsciiWhitespace(*str);\n\n  if (stripped.empty()) {\n    str->clear();\n    return;\n  }\n\n  auto input_it = stripped.begin();\n  auto input_end = stripped.end();\n  auto output_it = &(*str)[0];\n  bool is_ws = false;\n\n  for (; input_it < input_end; ++input_it) {\n    if (is_ws) {\n      // Consecutive whitespace?  Keep only the last.\n      is_ws = absl::ascii_isspace(static_cast<unsigned char>(*input_it));\n      if (is_ws) --output_it;\n    } else {\n      is_ws = absl::ascii_isspace(static_cast<unsigned char>(*input_it));\n    }\n\n    *output_it = *input_it;\n    ++output_it;\n  }\n\n  str->erase(static_cast<size_t>(output_it - &(*str)[0]));\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01827",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/ascii.cc",
  "source_line": 26,
  "validation_status": "validated"
}