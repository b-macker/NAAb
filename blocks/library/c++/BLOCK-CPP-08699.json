{
  "code": "{\n  /// The source code range that covers the full base\n  /// specifier, including the \"virtual\" (if present) and access\n  /// specifier (if present).\n  SourceRange Range;\n\n  /// The source location of the ellipsis, if this is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// Whether this is a virtual base class or not.\n  unsigned Virtual : 1;\n\n  /// Whether this is the base of a class (true) or of a struct (false).\n  ///\n  /// This determines the mapping from the access specifier as written in the\n  /// source code to the access specifier used for semantic analysis.\n  unsigned BaseOfClass : 1;\n\n  /// Access specifier as written in the source code (may be AS_none).\n  ///\n  /// The actual type of data stored here is an AccessSpecifier, but we use\n  /// \"unsigned\" here to work around a VC++ bug.\n  unsigned Access : 2;\n\n  /// Whether the class contains a using declaration\n  /// to inherit the named class's constructors.\n  unsigned InheritConstructors : 1;\n\n  /// The type of the base class.\n  ///\n  /// This will be a class or struct (or a typedef of such). The source code\n  /// range does not include the \\c virtual or the access specifier.\n  TypeSourceInfo *BaseTypeInfo;\n\npublic:\n  CXXBaseSpecifier() = default;\n  CXXBaseSpecifier(SourceRange R, bool V, bool BC, AccessSpecifier A,\n                   TypeSourceInfo *TInfo, SourceLocation EllipsisLoc)\n    : Range(R), EllipsisLoc(EllipsisLoc), Virtual(V), BaseOfClass(BC),\n      Access(A), InheritConstructors(false), BaseTypeInfo(TInfo) {}\n\n  /// Retrieves the source range that contains the entire base specifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  /// Get the location at which the base class type was written.\n  SourceLocation getBaseTypeLoc() const LLVM_READONLY {\n    return BaseTypeInfo->getTypeLoc().getBeginLoc();\n  }\n\n  /// Determines whether the base class is a virtual base class (or not).\n  bool isVirtual() const { return Virtual; }\n\n  /// Determine whether this base class is a base of a class declared\n  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).\n  bool isBaseOfClass() const { return BaseOfClass; }\n\n  /// Determine whether this base specifier is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Determine whether this base class's constructors get inherited.\n  bool getInheritConstructors() const { return InheritConstructors; }\n\n  /// Set that this base class's constructors should be inherited.\n  void setInheritConstructors(bool Inherit = true) {\n    InheritConstructors = Inherit;\n  }\n\n  /// For a pack expansion, determine the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  /// Returns the access specifier for this base specifier.\n  ///\n  /// This is the actual base specifier as used for semantic analysis, so\n  /// the result can never be AS_none. To retrieve the access specifier as\n  /// written in the source code, use getAccessSpecifierAsWritten().\n  AccessSpecifier getAccessSpecifier() const {\n    if ((AccessSpecifier)Access == AS_none)\n      return BaseOfClass? AS_private : AS_public;\n    else\n      return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the access specifier as written in the source code\n  /// (which may mean that no access specifier was explicitly written).\n  ///\n  /// Use getAccessSpecifier() to retrieve the access specifier for use in\n  /// semantic analysis.\n  AccessSpecifier getAccessSpecifierAsWritten() const {\n    return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the type of the base class.\n  ///\n  /// This type will always be an unqualified class type.\n  QualType getType() const {\n    return BaseTypeInfo->getType().getUnqualifiedType();\n  }\n\n  /// Retrieves the type and source location of the base class.\n  TypeSourceInfo *getTypeSourceInfo() const { return BaseTypeInfo; }\n}",
  "id": "BLOCK-CPP-08699",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 146,
  "validation_status": "validated"
}