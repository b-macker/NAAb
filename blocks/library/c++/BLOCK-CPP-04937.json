{
  "code": "{\n protected:\n  using slot_type = typename PolicyTraits::slot_type;\n\n public:\n  using allocator_type = Alloc;\n\n  constexpr node_handle_base() = default;\n  node_handle_base(node_handle_base&& other) noexcept {\n    *this = std::move(other);\n  }\n  ~node_handle_base() { destroy(); }\n  node_handle_base& operator=(node_handle_base&& other) noexcept {\n    destroy();\n    if (!other.empty()) {\n      alloc_ = other.alloc_;\n      PolicyTraits::transfer(alloc(), slot(), other.slot());\n      other.reset();\n    }\n    return *this;\n  }\n\n  bool empty() const noexcept { return !alloc_; }\n  explicit operator bool() const noexcept { return !empty(); }\n  allocator_type get_allocator() const { return *alloc_; }\n\n protected:\n  friend struct CommonAccess;\n\n  struct transfer_tag_t {};\n  node_handle_base(transfer_tag_t, const allocator_type& a, slot_type* s)\n      : alloc_(a) {\n    PolicyTraits::transfer(alloc(), slot(), s);\n  }\n\n  struct construct_tag_t {};\n  template <typename... Args>\n  node_handle_base(construct_tag_t, const allocator_type& a, Args&&... args)\n      : alloc_(a) {\n    PolicyTraits::construct(alloc(), slot(), std::forward<Args>(args)...);\n  }\n\n  void destroy() {\n    if (!empty()) {\n      PolicyTraits::destroy(alloc(), slot());\n      reset();\n    }\n  }\n\n  void reset() {\n    assert(alloc_.has_value());\n    alloc_ = absl::nullopt;\n  }\n\n  slot_type* slot() const {\n    assert(!empty());\n    return reinterpret_cast<slot_type*>(std::addressof(slot_space_));\n  }\n  allocator_type* alloc() { return std::addressof(*alloc_); }\n\n private:\n  absl::optional<allocator_type> alloc_ = {};\n  alignas(slot_type) mutable unsigned char slot_space_[sizeof(slot_type)] = {};\n}",
  "id": "BLOCK-CPP-04937",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/common.h",
  "source_line": 51,
  "validation_status": "validated"
}