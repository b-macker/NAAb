{
  "code": "#include \"absl/synchronization/internal/pthread_waiter.h\"\n#include <pthread.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <cassert>\n#include <cerrno>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/synchronization/internal/kernel_timeout.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03183_execute() {\n    {\n\nnamespace {\nclass PthreadMutexHolder {\n public:\n  explicit PthreadMutexHolder(pthread_mutex_t *mu) : mu_(mu) {\n    const int err = pthread_mutex_lock(mu_);\n    if (err != 0) {\n      ABSL_RAW_LOG(FATAL, \"pthread_mutex_lock failed: %d\", err);\n    }\n  }\n\n  PthreadMutexHolder(const PthreadMutexHolder &rhs) = delete;\n  PthreadMutexHolder &operator=(const PthreadMutexHolder &rhs) = delete;\n\n  ~PthreadMutexHolder() {\n    const int err = pthread_mutex_unlock(mu_);\n    if (err != 0) {\n      ABSL_RAW_LOG(FATAL, \"pthread_mutex_unlock failed: %d\", err);\n    }\n  }\n\n private:\n  pthread_mutex_t *mu_;\n};\n}  // namespace\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\nconstexpr char PthreadWaiter::kName[];\n#endif\n\nPthreadWaiter::PthreadWaiter() : waiter_count_(0), wakeup_count_(0) {\n  const int err = pthread_mutex_init(&mu_, 0);\n  if (err != 0) {\n    ABSL_RAW_LOG(FATAL, \"pthread_mutex_init failed: %d\", err);\n  }\n\n  const int err2 = pthread_cond_init(&cv_, 0);\n  if (err2 != 0) {\n    ABSL_RAW_LOG(FATAL, \"pthread_cond_init failed: %d\", err2);\n  }\n}\n\n#ifdef __APPLE__\n#define ABSL_INTERNAL_HAS_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP 1\n#endif\n\n#if defined(__GLIBC__) && \\\n    (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 30))\n#define ABSL_INTERNAL_HAVE_PTHREAD_COND_CLOCKWAIT 1\n#elif defined(__ANDROID_API__) && __ANDROID_API__ >= 30\n#define ABSL_INTERNAL_HAVE_PTHREAD_COND_CLOCKWAIT 1\n#endif\n\n// Calls pthread_cond_timedwait() or possibly something else like\n// pthread_cond_timedwait_relative_np() depending on the platform and\n// KernelTimeout requested. The return value is the same as the return\n// value of pthread_cond_timedwait().\nint PthreadWaiter::TimedWait(KernelTimeout t) {\n  assert(t.has_timeout());\n  if (KernelTimeout::SupportsSteadyClock() && t.is_relative_timeout()) {\n#ifdef ABSL_INTERNAL_HAS_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP\n    const auto rel_timeout = t.MakeRelativeTimespec();\n    return pthread_cond_timedwait_relative_np(&cv_, &mu_, &rel_timeout);\n#elif defined(ABSL_INTERNAL_HAVE_PTHREAD_COND_CLOCKWAIT) && \\\n    defined(CLOCK_MONOTONIC)\n    const auto abs_clock_timeout = t.MakeClockAbsoluteTimespec(CLOCK_MONOTONIC);\n    return pthread_cond_clockwait(&cv_, &mu_, CLOCK_MONOTONIC,\n                                  &abs_clock_timeout);\n#endif\n  }\n\n  const auto abs_timeout = t.MakeAbsTimespec();\n  return pthread_cond_timedwait(&cv_, &mu_, &abs_timeout);\n}\n\nbool PthreadWaiter::Wait(KernelTimeout t) {\n  PthreadMutexHolder h(&mu_);\n  ++waiter_count_;\n  // Loop until we find a wakeup to consume or timeout.\n  // Note that, since the thread ticker is just reset, we don't need to check\n  // whether the thread is idle on the very first pass of the loop.\n  bool first_pass = true;\n  while (wakeup_count_ == 0) {\n    if (!first_pass) MaybeBecomeIdle();\n    // No wakeups available, time to wait.\n    if (!t.has_timeout()) {\n      const int err = pthread_cond_wait(&cv_, &mu_);\n      if (err != 0) {\n        ABSL_RAW_LOG(FATAL, \"pthread_cond_wait failed: %d\", err);\n      }\n    } else {\n      const int err = TimedWait(t);\n      if (err == ETIMEDOUT) {\n        --waiter_count_;\n        return false;\n      }\n      if (err != 0) {\n        ABSL_RAW_LOG(FATAL, \"PthreadWaiter::TimedWait() failed: %d\", err);\n      }\n    }\n    first_pass = false;\n  }\n  // Consume a wakeup and we're done.\n  --wakeup_count_;\n  --waiter_count_;\n  return true;\n}\n\nvoid PthreadWaiter::Post() {\n  PthreadMutexHolder h(&mu_);\n  ++wakeup_count_;\n  InternalCondVarPoke();\n}\n\nvoid PthreadWaiter::Poke() {\n  PthreadMutexHolder h(&mu_);\n  InternalCondVarPoke();\n}\n\nvoid PthreadWaiter::InternalCondVarPoke() {\n  if (waiter_count_ != 0) {\n    const int err = pthread_cond_signal(&cv_);\n    if (ABSL_PREDICT_FALSE(err != 0)) {\n      ABSL_RAW_LOG(FATAL, \"pthread_cond_signal failed: %d\", err);\n    }\n  }\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03183",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/pthread_waiter.cc",
  "source_line": 34,
  "validation_status": "validated"
}