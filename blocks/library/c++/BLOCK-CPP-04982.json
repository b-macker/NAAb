{
  "code": "{\n  using slot_type = map_slot_type<K, V>;\n  using value_type = std::pair<const K, V>;\n  using mutable_value_type =\n      std::pair<absl::remove_const_t<K>, absl::remove_const_t<V>>;\n\n private:\n  static void emplace(slot_type* slot) {\n    // The construction of union doesn't do anything at runtime but it allows us\n    // to access its members without violating aliasing rules.\n    new (slot) slot_type;\n  }\n  // If pair<const K, V> and pair<K, V> are layout-compatible, we can accept one\n  // or the other via slot_type. We are also free to access the key via\n  // slot_type::key in this case.\n  using kMutableKeys = memory_internal::IsLayoutCompatible<K, V>;\n\n public:\n  static value_type& element(slot_type* slot) { return slot->value; }\n  static const value_type& element(const slot_type* slot) {\n    return slot->value;\n  }\n\n  // When C++17 is available, we can use std::launder to provide mutable\n  // access to the key for use in node handle.\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n  static K& mutable_key(slot_type* slot) {\n    // Still check for kMutableKeys so that we can avoid calling std::launder\n    // unless necessary because it can interfere with optimizations.\n    return kMutableKeys::value ? slot->key\n                               : *std::launder(const_cast<K*>(\n                                     std::addressof(slot->value.first)));\n  }\n#else  // !(defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606)\n  static const K& mutable_key(slot_type* slot) { return key(slot); }\n#endif\n\n  static const K& key(const slot_type* slot) {\n    return kMutableKeys::value ? slot->key : slot->value.first;\n  }\n\n  template <class Allocator, class... Args>\n  static void construct(Allocator* alloc, slot_type* slot, Args&&... args) {\n    emplace(slot);\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->mutable_value,\n                                                   std::forward<Args>(args)...);\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                   std::forward<Args>(args)...);\n    }\n  }\n\n  // Construct this slot by moving from another slot.\n  template <class Allocator>\n  static void construct(Allocator* alloc, slot_type* slot, slot_type* other) {\n    emplace(slot);\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(\n          *alloc, &slot->mutable_value, std::move(other->mutable_value));\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                   std::move(other->value));\n    }\n  }\n\n  // Construct this slot by copying from another slot.\n  template <class Allocator>\n  static void construct(Allocator* alloc, slot_type* slot,\n                        const slot_type* other) {\n    emplace(slot);\n    absl::allocator_traits<Allocator>::construct(*alloc, &slot->value,\n                                                 other->value);\n  }\n\n  template <class Allocator>\n  static void destroy(Allocator* alloc, slot_type* slot) {\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::destroy(*alloc, &slot->mutable_value);\n    } else {\n      absl::allocator_traits<Allocator>::destroy(*alloc, &slot->value);\n    }\n  }\n\n  template <class Allocator>\n  static auto transfer(Allocator* alloc, slot_type* new_slot,\n                       slot_type* old_slot) {\n    auto is_relocatable =\n        typename absl::is_trivially_relocatable<value_type>::type();\n\n    emplace(new_slot);\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n    if (is_relocatable) {\n      // TODO(b/247130232,b/251814870): remove casts after fixing warnings.\n      std::memcpy(static_cast<void*>(std::launder(&new_slot->value)),\n                  static_cast<const void*>(&old_slot->value),\n                  sizeof(value_type));\n      return is_relocatable;\n    }\n#endif\n\n    if (kMutableKeys::value) {\n      absl::allocator_traits<Allocator>::construct(\n          *alloc, &new_slot->mutable_value, std::move(old_slot->mutable_value));\n    } else {\n      absl::allocator_traits<Allocator>::construct(*alloc, &new_slot->value,\n                                                   std::move(old_slot->value));\n    }\n    destroy(alloc, old_slot);\n    return is_relocatable;\n  }\n}",
  "id": "BLOCK-CPP-04982",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/container_memory.h",
  "source_line": 340,
  "validation_status": "validated"
}