{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// Deterministic pseudorandom byte generator with backtracking resistance\n// (leaking the state does not compromise prior outputs). Based on Reverie\n// (see \"A Robust and Sponge-Like PRNG with Improved Efficiency\") instantiated\n// with an improved Simpira-like permutation.\n// Returns values of type \"T\" (must be a built-in unsigned integer type).\n//\n// RANDen = RANDom generator or beetroots in Swiss High German.\n// 'Strong' (well-distributed, unpredictable, backtracking-resistant) random\n// generator, faster in some benchmarks than std::mt19937_64 and pcg64_c32.\ntemplate <typename T>\nclass alignas(8) randen_engine {\n public:\n  // C++11 URBG interface:\n  using result_type = T;\n  static_assert(std::is_unsigned<result_type>::value,\n                \"randen_engine template argument must be a built-in unsigned \"\n                \"integer type\");\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  randen_engine() : randen_engine(0) {}\n  explicit randen_engine(result_type seed_value) { seed(seed_value); }\n\n  template <class SeedSequence,\n            typename = typename absl::enable_if_t<\n                !std::is_same<SeedSequence, randen_engine>::value>>\n  explicit randen_engine(SeedSequence&& seq) {\n    seed(seq);\n  }\n\n  // alignment requirements dictate custom copy and move constructors.\n  randen_engine(const randen_engine& other)\n      : next_(other.next_), impl_(other.impl_) {\n    std::memcpy(state(), other.state(), kStateSizeT * sizeof(result_type));\n  }\n  randen_engine& operator=(const randen_engine& other) {\n    next_ = other.next_;\n    impl_ = other.impl_;\n    std::memcpy(state(), other.state(), kStateSizeT * sizeof(result_type));\n    return *this;\n  }\n\n  // Returns random bits from the buffer in units of result_type.\n  result_type operator()() {\n    // Refill the buffer if needed (unlikely).\n    auto* begin = state();\n    if (next_ >= kStateSizeT) {\n      next_ = kCapacityT;\n      impl_.Generate(begin);\n    }\n    return little_endian::ToHost(begin[next_++]);\n  }\n\n  template <class SeedSequence>\n  typename absl::enable_if_t<\n      !std::is_convertible<SeedSequence, result_type>::value>\n  seed(SeedSequence&& seq) {\n    // Zeroes the state.\n    seed();\n    reseed(seq);\n  }\n\n  void seed(result_type seed_value = 0) {\n    next_ = kStateSizeT;\n    // Zeroes the inner state and fills the outer state with seed_value to\n    // mimic the behaviour of reseed\n    auto* begin = state();\n    std::fill(begin, begin + kCapacityT, 0);\n    std::fill(begin + kCapacityT, begin + kStateSizeT, seed_value);\n  }\n\n  // Inserts entropy into (part of) the state. Calling this periodically with\n  // sufficient entropy ensures prediction resistance (attackers cannot predict\n  // future outputs even if state is compromised).\n  template <class SeedSequence>\n  void reseed(SeedSequence& seq) {\n    using sequence_result_type = typename SeedSequence::result_type;\n    static_assert(sizeof(sequence_result_type) == 4,\n                  \"SeedSequence::result_type must be 32-bit\");\n    constexpr size_t kBufferSize =\n        Randen::kSeedBytes / sizeof(sequence_result_type);\n    alignas(16) sequence_result_type buffer[kBufferSize];\n\n    // Randen::Absorb XORs the seed into state, which is then mixed by a call\n    // to Randen::Generate. Seeding with only the provided entropy is preferred\n    // to using an arbitrary generate() call, so use [rand.req.seed_seq]\n    // size as a proxy for the number of entropy units that can be generated\n    // without relying on seed sequence mixing...\n    const size_t entropy_size = seq.size();\n    if (entropy_size < kBufferSize) {\n      // ... and only request that many values, or 256-bits, when unspecified.\n      const size_t requested_entropy = (entropy_size == 0) ? 8u : entropy_size;\n      std::fill(buffer + requested_entropy, buffer + kBufferSize, 0);\n      seq.generate(buffer, buffer + requested_entropy);\n#ifdef ABSL_IS_BIG_ENDIAN\n      // Randen expects the seed buffer to be in Little Endian; reverse it on\n      // Big Endian platforms.\n      for (sequence_result_type& e : buffer) {\n        e = absl::little_endian::FromHost(e);\n      }\n#endif\n      // The Randen paper suggests preferentially initializing even-numbered\n      // 128-bit vectors of the randen state (there are 16 such vectors).\n      // The seed data is merged into the state offset by 128-bits, which\n      // implies preferring seed bytes [16..31, ..., 208..223]. Since the\n      // buffer is 32-bit values, we swap the corresponding buffer positions in\n      // 128-bit chunks.\n      size_t dst = kBufferSize;\n      while (dst > 7) {\n        // leave the odd bucket as-is.\n        dst -= 4;\n        size_t src = dst >> 1;\n        // swap 128-bits into the even bucket\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n        std::swap(buffer[--dst], buffer[--src]);\n      }\n    } else {\n      seq.generate(buffer, buffer + kBufferSize);\n    }\n    impl_.Absorb(buffer, state());\n\n    // Generate will be called when operator() is called\n    next_ = kStateSizeT;\n  }\n\n  void discard(uint64_t count) {\n    uint64_t step = std::min<uint64_t>(kStateSizeT - next_, count);\n    count -= step;\n\n    constexpr uint64_t kRateT = kStateSizeT - kCapacityT;\n    auto* begin = state();\n    while (count > 0) {\n      next_ = kCapacityT;\n      impl_.Generate(*reinterpret_cast<result_type(*)[kStateSizeT]>(begin));\n      step = std::min<uint64_t>(kRateT, count);\n      count -= step;\n    }\n    next_ += step;\n  }\n\n  bool operator==(const randen_engine& other) const {\n    const auto* begin = state();\n    return next_ == other.next_ &&\n           std::equal(begin, begin + kStateSizeT, other.state());\n  }\n\n  bool operator!=(const randen_engine& other) const {\n    return !(*this == other);\n  }\n\n  template <class CharT, class Traits>\n  friend std::basic_ostream<CharT, Traits>& operator<<(\n      std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n      const randen_engine<T>& engine) {       // NOLINT(runtime/references)\n    using numeric_type =\n        typename random_internal::stream_format_type<result_type>::type;\n    auto saver = random_internal::make_ostream_state_saver(os);\n    auto* it = engine.state();\n    for (auto* end = it + kStateSizeT; it < end; ++it) {\n      // In the case that `elem` is `uint8_t`, it must be cast to something\n      // larger so that it prints as an integer rather than a character. For\n      // simplicity, apply the cast all circumstances.\n      os << static_cast<numeric_type>(little_endian::FromHost(*it))\n         << os.fill();\n    }\n    os << engine.next_;\n    return os;\n  }\n\n  template <class CharT, class Traits>\n  friend std::basic_istream<CharT, Traits>& operator>>(\n      std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n      randen_engine<T>& engine) {             // NOLINT(runtime/references)\n    using numeric_type =\n        typename random_internal::stream_format_type<result_type>::type;\n    result_type state[kStateSizeT];\n    size_t next;\n    for (auto& elem : state) {\n      // It is not possible to read uint8_t from wide streams, so it is\n      // necessary to read a wider type and then cast it to uint8_t.\n      numeric_type value;\n      is >> value;\n      elem = little_endian::ToHost(static_cast<result_type>(value));\n    }\n    is >> next;\n    if (is.fail()) {\n      return is;\n    }\n    std::memcpy(engine.state(), state, sizeof(state));\n    engine.next_ = next;\n    return is;\n  }\n\n private:\n  static constexpr size_t kStateSizeT =\n      Randen::kStateBytes / sizeof(result_type);\n  static constexpr size_t kCapacityT =\n      Randen::kCapacityBytes / sizeof(result_type);\n\n  // Returns the state array pointer, which is aligned to 16 bytes.\n  // The first kCapacityT are the `inner' sponge; the remainder are available.\n  result_type* state() {\n    return reinterpret_cast<result_type*>(\n        (reinterpret_cast<uintptr_t>(&raw_state_) & 0xf) ? (raw_state_ + 8)\n                                                         : raw_state_);\n  }\n  const result_type* state() const {\n    return const_cast<randen_engine*>(this)->state();\n  }\n\n  // raw state array, manually aligned in state(). This overallocates\n  // by 8 bytes since C++ does not guarantee extended heap alignment.\n  alignas(8) char raw_state_[Randen::kStateBytes + 8];\n  size_t next_;  // index within state()\n  Randen impl_;\n};\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05946",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/randen_engine.h",
  "source_line": 31,
  "validation_status": "validated"
}