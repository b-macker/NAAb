{
  "code": "{\n  friend class QualifierCollector;\n\n  // Thankfully, these are efficiently composable.\n  llvm::PointerIntPair<llvm::PointerUnion<const Type *, const ExtQuals *>,\n                       Qualifiers::FastWidth> Value;\n\n  const ExtQuals *getExtQualsUnsafe() const {\n    return Value.getPointer().get<const ExtQuals*>();\n  }\n\n  const Type *getTypePtrUnsafe() const {\n    return Value.getPointer().get<const Type*>();\n  }\n\n  const ExtQualsTypeCommonBase *getCommonPtr() const {\n    assert(!isNull() && \"Cannot retrieve a NULL type pointer\");\n    auto CommonPtrVal = reinterpret_cast<uintptr_t>(Value.getOpaqueValue());\n    CommonPtrVal &= ~(uintptr_t)((1 << TypeAlignmentInBits) - 1);\n    return reinterpret_cast<ExtQualsTypeCommonBase*>(CommonPtrVal);\n  }\n\npublic:\n  QualType() = default;\n  QualType(const Type *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n  QualType(const ExtQuals *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n\n  unsigned getLocalFastQualifiers() const { return Value.getInt(); }\n  void setLocalFastQualifiers(unsigned Quals) { Value.setInt(Quals); }\n\n  bool UseExcessPrecision(const ASTContext &Ctx);\n\n  /// Retrieves a pointer to the underlying (unqualified) type.\n  ///\n  /// This function requires that the type not be NULL. If the type might be\n  /// NULL, use the (slightly less efficient) \\c getTypePtrOrNull().\n  const Type *getTypePtr() const;\n\n  const Type *getTypePtrOrNull() const;\n\n  /// Retrieves a pointer to the name of the base type.\n  const IdentifierInfo *getBaseTypeIdentifier() const;\n\n  /// Divides a QualType into its unqualified type and a set of local\n  /// qualifiers.\n  SplitQualType split() const;\n\n  void *getAsOpaquePtr() const { return Value.getOpaqueValue(); }\n\n  static QualType getFromOpaquePtr(const void *Ptr) {\n    QualType T;\n    T.Value.setFromOpaqueValue(const_cast<void*>(Ptr));\n    return T;\n  }\n\n  const Type &operator*() const {\n    return *getTypePtr();\n  }\n\n  const Type *operator->() const {\n    return getTypePtr();\n  }\n\n  bool isCanonical() const;\n  bool isCanonicalAsParam() const;\n\n  /// Return true if this QualType doesn't point to a type yet.\n  bool isNull() const {\n    return Value.getPointer().isNull();\n  }\n\n  // Determines if a type can form `T&`.\n  bool isReferenceable() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"const\" qualifier set, without looking through typedefs that may have\n  /// added \"const\" at a different level.\n  bool isLocalConstQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Const);\n  }\n\n  /// Determine whether this type is const-qualified.\n  bool isConstQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"restrict\" qualifier set, without looking through typedefs that may have\n  /// added \"restrict\" at a different level.\n  bool isLocalRestrictQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Restrict);\n  }\n\n  /// Determine whether this type is restrict-qualified.\n  bool isRestrictQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"volatile\" qualifier set, without looking through typedefs that may have\n  /// added \"volatile\" at a different level.\n  bool isLocalVolatileQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Volatile);\n  }\n\n  /// Determine whether this type is volatile-qualified.\n  bool isVolatileQualified() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// qualifiers, without looking through any typedefs that might add\n  /// qualifiers at a different level.\n  bool hasLocalQualifiers() const {\n    return getLocalFastQualifiers() || hasLocalNonFastQualifiers();\n  }\n\n  /// Determine whether this type has any qualifiers.\n  bool hasQualifiers() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// \"non-fast\" qualifiers, e.g., those that are stored in an ExtQualType\n  /// instance.\n  bool hasLocalNonFastQualifiers() const {\n    return Value.getPointer().is<const ExtQuals*>();\n  }\n\n  /// Retrieve the set of qualifiers local to this particular QualType\n  /// instance, not including any qualifiers acquired through typedefs or\n  /// other sugar.\n  Qualifiers getLocalQualifiers() const;\n\n  /// Retrieve the set of qualifiers applied to this type.\n  Qualifiers getQualifiers() const;\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// local to this particular QualType instance, not including any qualifiers\n  /// acquired through typedefs or other sugar.\n  unsigned getLocalCVRQualifiers() const {\n    return getLocalFastQualifiers();\n  }\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// applied to this type.\n  unsigned getCVRQualifiers() const;\n\n  bool isConstant(const ASTContext& Ctx) const {\n    return QualType::isConstant(*this, Ctx);\n  }\n\n  /// Determine whether this is a Plain Old Data (POD) type (C++ 3.9p10).\n  bool isPODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the rules of the C++98\n  /// standard, regardless of the current compilation's language.\n  bool isCXX98PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the more relaxed rules\n  /// of the C++11 standard, regardless of the current compilation's language.\n  /// (C++0x [basic.types]p9). Note that, unlike\n  /// CXXRecordDecl::isCXX11StandardLayout, this takes DRs into account.\n  bool isCXX11PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivial type per (C++0x [basic.types]p9)\n  bool isTrivialType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially copyable type (C++0x [basic.types]p9)\n  bool isTriviallyCopyableType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially relocatable type.\n  bool isTriviallyRelocatableType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially equality comparable type.\n  bool isTriviallyEqualityComparableType(const ASTContext &Context) const;\n\n  /// Returns true if it is a class and it might be dynamic.\n  bool mayBeDynamicClass() const;\n\n  /// Returns true if it is not a class or if the class might not be dynamic.\n  bool mayBeNotDynamicClass() const;\n\n  /// Returns true if it is a WebAssembly Reference Type.\n  bool isWebAssemblyReferenceType() const;\n\n  /// Returns true if it is a WebAssembly Externref Type.\n  bool isWebAssemblyExternrefType() const;\n\n  /// Returns true if it is a WebAssembly Funcref Type.\n  bool isWebAssemblyFuncrefType() const;\n\n  // Don't promise in the API that anything besides 'const' can be\n  // easily added.\n\n  /// Add the `const` type qualifier to this QualType.\n  void addConst() {\n    addFastQualifiers(Qualifiers::Const);\n  }\n  QualType withConst() const {\n    return withFastQualifiers(Qualifiers::Const);\n  }\n\n  /// Add the `volatile` type qualifier to this QualType.\n  void addVolatile() {\n    addFastQualifiers(Qualifiers::Volatile);\n  }\n  QualType withVolatile() const {\n    return withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Add the `restrict` qualifier to this QualType.\n  void addRestrict() {\n    addFastQualifiers(Qualifiers::Restrict);\n  }\n  QualType withRestrict() const {\n    return withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  QualType withCVRQualifiers(unsigned CVR) const {\n    return withFastQualifiers(CVR);\n  }\n\n  void addFastQualifiers(unsigned TQs) {\n    assert(!(TQs & ~Qualifiers::FastMask)\n           && \"non-fast qualifier bits set in mask!\");\n    Value.setInt(Value.getInt() | TQs);\n  }\n\n  void removeLocalConst();\n  void removeLocalVolatile();\n  void removeLocalRestrict();\n\n  void removeLocalFastQualifiers() { Value.setInt(0); }\n  void removeLocalFastQualifiers(unsigned Mask) {\n    assert(!(Mask & ~Qualifiers::FastMask) && \"mask has non-fast qualifiers\");\n    Value.setInt(Value.getInt() & ~Mask);\n  }\n\n  // Creates a type with the given qualifiers in addition to any\n  // qualifiers already on this type.\n  QualType withFastQualifiers(unsigned TQs) const {\n    QualType T = *this;\n    T.addFastQualifiers(TQs);\n    return T;\n  }\n\n  // Creates a type with exactly the given fast qualifiers, removing\n  // any existing fast qualifiers.\n  QualType withExactLocalFastQualifiers(unsigned TQs) const {\n    return withoutLocalFastQualifiers().withFastQualifiers(TQs);\n  }\n\n  // Removes fast qualifiers, but leaves any extended qualifiers in place.\n  QualType withoutLocalFastQualifiers() const {\n    QualType T = *this;\n    T.removeLocalFastQualifiers();\n    return T;\n  }\n\n  QualType getCanonicalType() const;\n\n  /// Return this type with all of the instance-specific qualifiers\n  /// removed, but without removing any qualifiers that may have been applied\n  /// through typedefs.\n  QualType getLocalUnqualifiedType() const { return QualType(getTypePtr(), 0); }\n\n  /// Retrieve the unqualified variant of the given type,\n  /// removing as little sugar as possible.\n  ///\n  /// This routine looks through various kinds of sugar to find the\n  /// least-desugared type that is unqualified. For example, given:\n  ///\n  /// \\code\n  /// typedef int Integer;\n  /// typedef const Integer CInteger;\n  /// typedef CInteger DifferenceType;\n  /// \\endcode\n  ///\n  /// Executing \\c getUnqualifiedType() on the type \\c DifferenceType will\n  /// desugar until we hit the type \\c Integer, which has no qualifiers on it.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  ///\n  /// Note: In C, the _Atomic qualifier is special (see C2x 6.2.5p29 for\n  /// details), and it is not stripped by this function. Use\n  /// getAtomicUnqualifiedType() to strip qualifiers including _Atomic.\n  inline QualType getUnqualifiedType() const;\n\n  /// Retrieve the unqualified variant of the given type, removing as little\n  /// sugar as possible.\n  ///\n  /// Like getUnqualifiedType(), but also returns the set of\n  /// qualifiers that were built up.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline SplitQualType getSplitUnqualifiedType() const;\n\n  /// Determine whether this type is more qualified than the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isMoreQualifiedThan(QualType Other) const;\n\n  /// Determine whether this type is at least as qualified as the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isAtLeastAsQualifiedAs(QualType Other) const;\n\n  QualType getNonReferenceType() const;\n\n  /// Determine the type of a (typically non-lvalue) expression with the\n  /// specified result type.\n  ///\n  /// This routine should be used for expressions for which the return type is\n  /// explicitly specified (e.g., in a cast or call) and isn't necessarily\n  /// an lvalue. It removes a top-level reference (since there are no\n  /// expressions of reference type) and deletes top-level cvr-qualifiers\n  /// from non-class types (in C++) or all types (in C).\n  QualType getNonLValueExprType(const ASTContext &Context) const;\n\n  /// Remove an outer pack expansion type (if any) from this type. Used as part\n  /// of converting the type of a declaration to the type of an expression that\n  /// references that expression. It's meaningless for an expression to have a\n  /// pack expansion type.\n  QualType getNonPackExpansionType() const;\n\n  /// Return the specified type with any \"sugar\" removed from\n  /// the type.  This takes off typedefs, typeof's etc.  If the outer level of\n  /// the type is already concrete, it returns it unmodified.  This is similar\n  /// to getting the canonical type, but it doesn't remove *all* typedefs.  For\n  /// example, it returns \"T*\" as \"T*\", (not as \"int*\"), because the pointer is\n  /// concrete.\n  ///\n  /// Qualifiers are left in place.\n  QualType getDesugaredType(const ASTContext &Context) const {\n    return getDesugaredType(*this, Context);\n  }\n\n  SplitQualType getSplitDesugaredType() const {\n    return getSplitDesugaredType(*this);\n  }\n\n  /// Return the specified type with one level of \"sugar\" removed from\n  /// the type.\n  ///\n  /// This routine takes off the first typedef, typeof, etc. If the outer level\n  /// of the type is already concrete, it returns it unmodified.\n  QualType getSingleStepDesugaredType(const ASTContext &Context) const {\n    return getSingleStepDesugaredTypeImpl(*this, Context);\n  }\n\n  /// Returns the specified type after dropping any\n  /// outer-level parentheses.\n  QualType IgnoreParens() const {\n    if (isa<ParenType>(*this))\n      return QualType::IgnoreParens(*this);\n    return *this;\n  }\n\n  /// Indicate whether the specified types and qualifiers are identical.\n  friend bool operator==(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value == RHS.Value;\n  }\n  friend bool operator!=(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value != RHS.Value;\n  }\n  friend bool operator<(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value < RHS.Value;\n  }\n\n  static std::string getAsString(SplitQualType split,\n                                 const PrintingPolicy &Policy) {\n    return getAsString(split.Ty, split.Quals, Policy);\n  }\n  static std::string getAsString(const Type *ty, Qualifiers qs,\n                                 const PrintingPolicy &Policy);\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             const Twine &PlaceHolder = Twine(),\n             unsigned Indentation = 0) const;\n\n  static void print(SplitQualType split, raw_ostream &OS,\n                    const PrintingPolicy &policy, const Twine &PlaceHolder,\n                    unsigned Indentation = 0) {\n    return print(split.Ty, split.Quals, OS, policy, PlaceHolder, Indentation);\n  }\n\n  static void print(const Type *ty, Qualifiers qs,\n                    raw_ostream &OS, const PrintingPolicy &policy,\n                    const Twine &PlaceHolder,\n                    unsigned Indentation = 0);\n\n  void getAsStringInternal(std::string &Str,\n                           const PrintingPolicy &Policy) const;\n\n  static void getAsStringInternal(SplitQualType split, std::string &out,\n                                  const PrintingPolicy &policy) {\n    return getAsStringInternal(split.Ty, split.Quals, out, policy);\n  }\n\n  static void getAsStringInternal(const Type *ty, Qualifiers qs,\n                                  std::string &out,\n                                  const PrintingPolicy &policy);\n\n  class StreamedQualTypeHelper {\n    const QualType &T;\n    const PrintingPolicy &Policy;\n    const Twine &PlaceHolder;\n    unsigned Indentation;\n\n  public:\n    StreamedQualTypeHelper(const QualType &T, const PrintingPolicy &Policy,\n                           const Twine &PlaceHolder, unsigned Indentation)\n        : T(T), Policy(Policy), PlaceHolder(PlaceHolder),\n          Indentation(Indentation) {}\n\n    friend raw_ostream &operator<<(raw_ostream &OS,\n                                   const StreamedQualTypeHelper &SQT) {\n      SQT.T.print(OS, SQT.Policy, SQT.PlaceHolder, SQT.Indentation);\n      return OS;\n    }\n  };\n\n  StreamedQualTypeHelper stream(const PrintingPolicy &Policy,\n                                const Twine &PlaceHolder = Twine(),\n                                unsigned Indentation = 0) const {\n    return StreamedQualTypeHelper(*this, Policy, PlaceHolder, Indentation);\n  }\n\n  void dump(const char *s) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n\n  /// Check if this type has any address space qualifier.\n  inline bool hasAddressSpace() const;\n\n  /// Return the address space of this type.\n  inline LangAS getAddressSpace() const;\n\n  /// Returns true if address space qualifiers overlap with T address space\n  /// qualifiers.\n  /// OpenCL C defines conversion rules for pointers to different address spaces\n  /// and notion of overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   address spaces overlap iff they are they same.\n  /// OpenCL C v2.0 s6.5.5 adds:\n  ///   __generic overlaps with any address space except for __constant.\n  bool isAddressSpaceOverlapping(QualType T) const {\n    Qualifiers Q = getQualifiers();\n    Qualifiers TQ = T.getQualifiers();\n    // Address spaces overlap if at least one of them is a superset of another\n    return Q.isAddressSpaceSupersetOf(TQ) || TQ.isAddressSpaceSupersetOf(Q);\n  }\n\n  /// Returns gc attribute of this type.\n  inline Qualifiers::GC getObjCGCAttr() const;\n\n  /// true when Type is objc's weak.\n  bool isObjCGCWeak() const {\n    return getObjCGCAttr() == Qualifiers::Weak;\n  }\n\n  /// true when Type is objc's strong.\n  bool isObjCGCStrong() const {\n    return getObjCGCAttr() == Qualifiers::Strong;\n  }\n\n  /// Returns lifetime attribute of this type.\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return getQualifiers().getObjCLifetime();\n  }\n\n  bool hasNonTrivialObjCLifetime() const {\n    return getQualifiers().hasNonTrivialObjCLifetime();\n  }\n\n  bool hasStrongOrWeakObjCLifetime() const {\n    return getQualifiers().hasStrongOrWeakObjCLifetime();\n  }\n\n  // true when Type is objc's weak and weak is enabled but ARC isn't.\n  bool isNonWeakInMRRWithObjCWeak(const ASTContext &Context) const;\n\n  enum PrimitiveDefaultInitializeKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PDIK_Trivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PDIK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PDIK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is not PCK_Trivial.\n    PDIK_Struct\n  };\n\n  /// Functions to query basic properties of non-trivial C struct types.\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to default initialize\n  /// and return the kind.\n  PrimitiveDefaultInitializeKind\n  isNonTrivialToPrimitiveDefaultInitialize() const;\n\n  enum PrimitiveCopyKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PCK_Trivial,\n\n    /// The type would be trivial except that it is volatile-qualified. Types\n    /// that fall into one of the other non-trivial cases may additionally be\n    /// volatile-qualified.\n    PCK_VolatileTrivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PCK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PCK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is neither\n    /// PCK_Trivial nor PCK_VolatileTrivial.\n    /// Note that a C++ struct type does not necessarily match this; C++ copying\n    /// semantics are too complex to express here, in part because they depend\n    /// on the exact constructor or assignment operator that is chosen by\n    /// overload resolution to do the copy.\n    PCK_Struct\n  };\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to copy and return the\n  /// kind.\n  PrimitiveCopyKind isNonTrivialToPrimitiveCopy() const;\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to destructively\n  /// move and return the kind. Destructive move in this context is a C++-style\n  /// move in which the source object is placed in a valid but unspecified state\n  /// after it is moved, as opposed to a truly destructive move in which the\n  /// source object is placed in an uninitialized state.\n  PrimitiveCopyKind isNonTrivialToPrimitiveDestructiveMove() const;\n\n  enum DestructionKind {\n    DK_none,\n    DK_cxx_destructor,\n    DK_objc_strong_lifetime,\n    DK_objc_weak_lifetime,\n    DK_nontrivial_c_struct\n  };\n\n  /// Returns a nonzero value if objects of this type require\n  /// non-trivial work to clean up after.  Non-zero because it's\n  /// conceivable that qualifiers (objc_gc(weak)?) could make\n  /// something require destruction.\n  DestructionKind isDestructedType() const {\n    return isDestructedTypeImpl(*this);\n  }\n\n  /// Check if this is or contains a C union that is non-trivial to\n  /// default-initialize, which is a union that has a member that is non-trivial\n  /// to default-initialize. If this returns true,\n  /// isNonTrivialToPrimitiveDefaultInitialize returns PDIK_Struct.\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to destruct,\n  /// which is a union that has a member that is non-trivial to destruct. If\n  /// this returns true, isDestructedType returns DK_nontrivial_c_struct.\n  bool hasNonTrivialToPrimitiveDestructCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to copy, which\n  /// is a union that has a member that is non-trivial to copy. If this returns\n  /// true, isNonTrivialToPrimitiveCopy returns PCK_Struct.\n  bool hasNonTrivialToPrimitiveCopyCUnion() const;\n\n  /// Determine whether expressions of the given type are forbidden\n  /// from being lvalues in C.\n  ///\n  /// The expression types that are forbidden to be lvalues are:\n  ///   - 'void', but not qualified void\n  ///   - function types\n  ///\n  /// The exact rule here is C99 6.3.2.1:\n  ///   An lvalue is an expression with an object type or an incomplete\n  ///   type other than void.\n  bool isCForbiddenLValueType() const;\n\n  /// Substitute type arguments for the Objective-C type parameters used in the\n  /// subject type.\n  ///\n  /// \\param ctx ASTContext in which the type exists.\n  ///\n  /// \\param typeArgs The type arguments that will be substituted for the\n  /// Objective-C type parameters in the subject type, which are generally\n  /// computed via \\c Type::getObjCSubstitutions. If empty, the type\n  /// parameters will be replaced with their bounds or id/Class, as appropriate\n  /// for the context.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the resulting type.\n  QualType substObjCTypeArgs(ASTContext &ctx,\n                             ArrayRef<QualType> typeArgs,\n                             ObjCSubstitutionContext context) const;\n\n  /// Substitute type arguments from an object type for the Objective-C type\n  /// parameters used in the subject type.\n  ///\n  /// This operation combines the computation of type arguments for\n  /// substitution (\\c Type::getObjCSubstitutions) with the actual process of\n  /// substitution (\\c QualType::substObjCTypeArgs) for the convenience of\n  /// callers that need to perform a single substitution in isolation.\n  ///\n  /// \\param objectType The type of the object whose member type we're\n  /// substituting into. For example, this might be the receiver of a message\n  /// or the base of a property access.\n  ///\n  /// \\param dc The declaration context from which the subject type was\n  /// retrieved, which indicates (for example) which type parameters should\n  /// be substituted.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the subject type after replacing all of the Objective-C type\n  /// parameters with their corresponding arguments.\n  QualType substObjCMemberType(QualType objectType,\n                               const DeclContext *dc,\n                               ObjCSubstitutionContext context) const;\n\n  /// Strip Objective-C \"__kindof\" types from the given type.\n  QualType stripObjCKindOfType(const ASTContext &ctx) const;\n\n  /// Remove all qualifiers including _Atomic.\n  QualType getAtomicUnqualifiedType() const;\n\nprivate:\n  // These methods are implemented in a separate translation unit;\n  // \"static\"-ize them to avoid creating temporary QualTypes in the\n  // caller.\n  static bool isConstant(QualType T, const ASTContext& Ctx);\n  static QualType getDesugaredType(QualType T, const ASTContext &Context);\n  static SplitQualType getSplitDesugaredType(QualType T);\n  static SplitQualType getSplitUnqualifiedTypeImpl(QualType type);\n  static QualType getSingleStepDesugaredTypeImpl(QualType type,\n                                                 const ASTContext &C);\n  static QualType IgnoreParens(QualType T);\n  static DestructionKind isDestructedTypeImpl(QualType type);\n\n  /// Check if \\param RD is or contains a non-trivial C union.\n  static bool hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveDestructCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveCopyCUnion(const RecordDecl *RD);\n}",
  "id": "BLOCK-CPP-14102",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Type.h",
  "source_line": 736,
  "validation_status": "validated"
}