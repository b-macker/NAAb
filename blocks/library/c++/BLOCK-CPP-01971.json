{
  "code": "{\n  ExpDigits exp_dig;\n  int exp = 5;\n  double d = value;\n  // First step: calculate a close approximation of the output, where the\n  // value d will be between 100,000 and 999,999, representing the digits\n  // in the output ASCII array, and exp is the base-10 exponent.  It would be\n  // faster to use a table here, and to look up the base-2 exponent of value,\n  // however value is an IEEE-754 64-bit number, so the table would have 2,000\n  // entries, which is not cache-friendly.\n  if (d >= 999999.5) {\n    if (d >= 1e+261) exp += 256, d *= 1e-256;\n    if (d >= 1e+133) exp += 128, d *= 1e-128;\n    if (d >= 1e+69) exp += 64, d *= 1e-64;\n    if (d >= 1e+37) exp += 32, d *= 1e-32;\n    if (d >= 1e+21) exp += 16, d *= 1e-16;\n    if (d >= 1e+13) exp += 8, d *= 1e-8;\n    if (d >= 1e+9) exp += 4, d *= 1e-4;\n    if (d >= 1e+7) exp += 2, d *= 1e-2;\n    if (d >= 1e+6) exp += 1, d *= 1e-1;\n  } else {\n    if (d < 1e-250) exp -= 256, d *= 1e256;\n    if (d < 1e-122) exp -= 128, d *= 1e128;\n    if (d < 1e-58) exp -= 64, d *= 1e64;\n    if (d < 1e-26) exp -= 32, d *= 1e32;\n    if (d < 1e-10) exp -= 16, d *= 1e16;\n    if (d < 1e-2) exp -= 8, d *= 1e8;\n    if (d < 1e+2) exp -= 4, d *= 1e4;\n    if (d < 1e+4) exp -= 2, d *= 1e2;\n    if (d < 1e+5) exp -= 1, d *= 1e1;\n  }\n  // At this point, d is in the range [99999.5..999999.5) and exp is in the\n  // range [-324..308]. Since we need to round d up, we want to add a half\n  // and truncate.\n  // However, the technique above may have lost some precision, due to its\n  // repeated multiplication by constants that each may be off by half a bit\n  // of precision.  This only matters if we're close to the edge though.\n  // Since we'd like to know if the fractional part of d is close to a half,\n  // we multiply it by 65536 and see if the fractional part is close to 32768.\n  // (The number doesn't have to be a power of two,but powers of two are faster)\n  uint64_t d64k = d * 65536;\n  uint32_t dddddd;  // A 6-digit decimal integer.\n  if ((d64k % 65536) == 32767 || (d64k % 65536) == 32768) {\n    // OK, it's fairly likely that precision was lost above, which is\n    // not a surprise given only 52 mantissa bits are available.  Therefore\n    // redo the calculation using 128-bit numbers.  (64 bits are not enough).\n\n    // Start out with digits rounded down; maybe add one below.\n    dddddd = static_cast<uint32_t>(d64k / 65536);\n\n    // mantissa is a 64-bit integer representing M.mmm... * 2^63.  The actual\n    // value we're representing, of course, is M.mmm... * 2^exp2.\n    int exp2;\n    double m = std::frexp(value, &exp2);\n    uint64_t mantissa = m * (32768.0 * 65536.0 * 65536.0 * 65536.0);\n    // std::frexp returns an m value in the range [0.5, 1.0), however we\n    // can't multiply it by 2^64 and convert to an integer because some FPUs\n    // throw an exception when converting an number higher than 2^63 into an\n    // integer - even an unsigned 64-bit integer!  Fortunately it doesn't matter\n    // since m only has 52 significant bits anyway.\n    mantissa <<= 1;\n    exp2 -= 64;  // not needed, but nice for debugging\n\n    // OK, we are here to compare:\n    //     (dddddd + 0.5) * 10^(exp-5)  vs.  mantissa * 2^exp2\n    // so we can round up dddddd if appropriate.  Those values span the full\n    // range of 600 orders of magnitude of IEE 64-bit floating-point.\n    // Fortunately, we already know they are very close, so we don't need to\n    // track the base-2 exponent of both sides.  This greatly simplifies the\n    // the math since the 2^exp2 calculation is unnecessary and the power-of-10\n    // calculation can become a power-of-5 instead.\n\n    std::pair<uint64_t, uint64_t> edge, val;\n    if (exp >= 6) {\n      // Compare (dddddd + 0.5) * 5 ^ (exp - 5) to mantissa\n      // Since we're tossing powers of two, 2 * dddddd + 1 is the\n      // same as dddddd + 0.5\n      edge = PowFive(2 * dddddd + 1, exp - 5);\n\n      val.first = mantissa;\n      val.second = 0;\n    } else {\n      // We can't compare (dddddd + 0.5) * 5 ^ (exp - 5) to mantissa as we did\n      // above because (exp - 5) is negative.  So we compare (dddddd + 0.5) to\n      // mantissa * 5 ^ (5 - exp)\n      edge = PowFive(2 * dddddd + 1, 0);\n\n      val = PowFive(mantissa, 5 - exp);\n    }\n    // printf(\"exp=%d %016lx %016lx vs %016lx %016lx\\n\", exp, val.first,\n    //        val.second, edge.first, edge.second);\n    if (val > edge) {\n      dddddd++;\n    } else if (val == edge) {\n      dddddd += (dddddd & 1);\n    }\n  } else {\n    // Here, we are not close to the edge.\n    dddddd = static_cast<uint32_t>((d64k + 32768) / 65536);\n  }\n  if (dddddd == 1000000) {\n    dddddd = 100000;\n    exp += 1;\n  }\n  exp_dig.exponent = exp;\n\n  uint32_t two_digits = dddddd / 10000;\n  dddddd -= two_digits * 10000;\n  numbers_internal::PutTwoDigits(two_digits, &exp_dig.digits[0]);\n\n  two_digits = dddddd / 100;\n  dddddd -= two_digits * 100;\n  numbers_internal::PutTwoDigits(two_digits, &exp_dig.digits[2]);\n\n  numbers_internal::PutTwoDigits(dddddd, &exp_dig.digits[4]);\n  return exp_dig;\n}",
  "id": "BLOCK-CPP-01971",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/numbers.cc",
  "source_line": 652,
  "validation_status": "validated"
}