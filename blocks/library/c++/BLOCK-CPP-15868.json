{
  "code": "{\npublic:\n  enum Kind { BlockEdgeKind,\n              BlockEntranceKind,\n              BlockExitKind,\n              PreStmtKind,\n              PreStmtPurgeDeadSymbolsKind,\n              PostStmtPurgeDeadSymbolsKind,\n              PostStmtKind,\n              PreLoadKind,\n              PostLoadKind,\n              PreStoreKind,\n              PostStoreKind,\n              PostConditionKind,\n              PostLValueKind,\n              PostAllocatorCallKind,\n              MinPostStmtKind = PostStmtKind,\n              MaxPostStmtKind = PostAllocatorCallKind,\n              PostInitializerKind,\n              CallEnterKind,\n              CallExitBeginKind,\n              CallExitEndKind,\n              FunctionExitKind,\n              PreImplicitCallKind,\n              PostImplicitCallKind,\n              MinImplicitCallKind = PreImplicitCallKind,\n              MaxImplicitCallKind = PostImplicitCallKind,\n              LoopExitKind,\n              EpsilonKind};\n\nprivate:\n  const void *Data1;\n  llvm::PointerIntPair<const void *, 2, unsigned> Data2;\n\n  // The LocationContext could be NULL to allow ProgramPoint to be used in\n  // context insensitive analysis.\n  llvm::PointerIntPair<const LocationContext *, 2, unsigned> L;\n\n  llvm::PointerIntPair<const ProgramPointTag *, 2, unsigned> Tag;\n\n  CFGBlock::ConstCFGElementRef ElemRef = {nullptr, 0};\n\nprotected:\n  ProgramPoint() = default;\n  ProgramPoint(const void *P, Kind k, const LocationContext *l,\n               const ProgramPointTag *tag = nullptr,\n               CFGBlock::ConstCFGElementRef ElemRef = {nullptr, 0})\n      : Data1(P), Data2(nullptr, (((unsigned)k) >> 0) & 0x3),\n        L(l, (((unsigned)k) >> 2) & 0x3), Tag(tag, (((unsigned)k) >> 4) & 0x3),\n        ElemRef(ElemRef) {\n    assert(getKind() == k);\n    assert(getLocationContext() == l);\n    assert(getData1() == P);\n  }\n\n  ProgramPoint(const void *P1, const void *P2, Kind k, const LocationContext *l,\n               const ProgramPointTag *tag = nullptr,\n               CFGBlock::ConstCFGElementRef ElemRef = {nullptr, 0})\n      : Data1(P1), Data2(P2, (((unsigned)k) >> 0) & 0x3),\n        L(l, (((unsigned)k) >> 2) & 0x3), Tag(tag, (((unsigned)k) >> 4) & 0x3),\n        ElemRef(ElemRef) {}\n\nprotected:\n  const void *getData1() const { return Data1; }\n  const void *getData2() const { return Data2.getPointer(); }\n  void setData2(const void *d) { Data2.setPointer(d); }\n  CFGBlock::ConstCFGElementRef getElementRef() const { return ElemRef; }\n\npublic:\n  /// Create a new ProgramPoint object that is the same as the original\n  /// except for using the specified tag value.\n  ProgramPoint withTag(const ProgramPointTag *tag) const {\n    return ProgramPoint(getData1(), getData2(), getKind(),\n                        getLocationContext(), tag);\n  }\n\n  /// Convert to the specified ProgramPoint type, asserting that this\n  /// ProgramPoint is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  /// Convert to the specified ProgramPoint type, returning std::nullopt if this\n  /// ProgramPoint is not of the desired type.\n  template <typename T> std::optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return std::nullopt;\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Tag.getInt();\n    x <<= 2;\n    x |= L.getInt();\n    x <<= 2;\n    x |= Data2.getInt();\n    return (Kind) x;\n  }\n\n  /// Is this a program point corresponding to purge/removal of dead\n  /// symbols and bindings.\n  bool isPurgeKind() {\n    Kind K = getKind();\n    return (K == PostStmtPurgeDeadSymbolsKind ||\n            K == PreStmtPurgeDeadSymbolsKind);\n  }\n\n  const ProgramPointTag *getTag() const { return Tag.getPointer(); }\n\n  const LocationContext *getLocationContext() const {\n    return L.getPointer();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocationContext()->getStackFrame();\n  }\n\n  // For use with DenseMap.  This hash is probably slow.\n  unsigned getHashValue() const {\n    llvm::FoldingSetNodeID ID;\n    Profile(ID);\n    return ID.ComputeHash();\n  }\n\n  bool operator==(const ProgramPoint & RHS) const {\n    return Data1 == RHS.Data1 && Data2 == RHS.Data2 && L == RHS.L &&\n           Tag == RHS.Tag && ElemRef == RHS.ElemRef;\n  }\n\n  bool operator!=(const ProgramPoint &RHS) const {\n    return Data1 != RHS.Data1 || Data2 != RHS.Data2 || L != RHS.L ||\n           Tag != RHS.Tag || ElemRef != RHS.ElemRef;\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.AddInteger((unsigned) getKind());\n    ID.AddPointer(getData1());\n    ID.AddPointer(getData2());\n    ID.AddPointer(getLocationContext());\n    ID.AddPointer(getTag());\n    ID.AddPointer(ElemRef.getParent());\n    ID.AddInteger(ElemRef.getIndexInBlock());\n  }\n\n  void printJson(llvm::raw_ostream &Out, const char *NL = \"\\n\") const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static ProgramPoint getProgramPoint(const Stmt *S, ProgramPoint::Kind K,\n                                      const LocationContext *LC,\n                                      const ProgramPointTag *tag);\n}",
  "id": "BLOCK-CPP-15868",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/ProgramPoint.h",
  "source_line": 58,
  "validation_status": "validated"
}