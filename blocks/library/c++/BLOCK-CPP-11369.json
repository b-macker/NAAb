{
  "code": "{\n\n/// An OSLogBufferItem represents a single item in the data written by a call\n/// to os_log() or os_trace().\nclass OSLogBufferItem {\npublic:\n  enum Kind {\n    // The item is a scalar (int, float, raw pointer, etc.). No further copying\n    // is required. This is the only kind allowed by os_trace().\n    ScalarKind = 0,\n\n    // The item is a count, which describes the length of the following item to\n    // be copied. A count may only be followed by an item of kind StringKind,\n    // WideStringKind, or PointerKind.\n    CountKind,\n\n    // The item is a pointer to a C string. If preceded by a count 'n',\n    // os_log() will copy at most 'n' bytes from the pointer.\n    StringKind,\n\n    // The item is a pointer to a block of raw data. This item must be preceded\n    // by a count 'n'. os_log() will copy exactly 'n' bytes from the pointer.\n    PointerKind,\n\n    // The item is a pointer to an Objective-C object. os_log() may retain the\n    // object for later processing.\n    ObjCObjKind,\n\n    // The item is a pointer to wide-char string.\n    WideStringKind,\n\n    // The item is corresponding to the '%m' format specifier, no value is\n    // populated in the buffer and the runtime is loading the errno value.\n    ErrnoKind,\n\n    // The item is a mask type.\n    MaskKind\n  };\n\n  enum {\n    // The item is marked \"private\" in the format string.\n    IsPrivate = 0x1,\n\n    // The item is marked \"public\" in the format string.\n    IsPublic = 0x2,\n\n    // The item is marked \"sensitive\" in the format string.\n    IsSensitive = 0x4 | IsPrivate\n  };\n\nprivate:\n  Kind TheKind = ScalarKind;\n  const Expr *TheExpr = nullptr;\n  CharUnits ConstValue;\n  CharUnits Size; // size of the data, not including the header bytes\n  unsigned Flags = 0;\n  StringRef MaskType;\n\npublic:\n  OSLogBufferItem(Kind kind, const Expr *expr, CharUnits size, unsigned flags,\n                  StringRef maskType = StringRef())\n      : TheKind(kind), TheExpr(expr), Size(size), Flags(flags),\n        MaskType(maskType) {\n    assert(((Flags == 0) || (Flags == IsPrivate) || (Flags == IsPublic) ||\n            (Flags == IsSensitive)) &&\n           \"unexpected privacy flag\");\n  }\n\n  OSLogBufferItem(ASTContext &Ctx, CharUnits value, unsigned flags)\n      : TheKind(CountKind), ConstValue(value),\n        Size(Ctx.getTypeSizeInChars(Ctx.IntTy)), Flags(flags) {}\n\n  unsigned char getDescriptorByte() const {\n    unsigned char result = Flags;\n    result |= ((unsigned)getKind()) << 4;\n    return result;\n  }\n\n  unsigned char getSizeByte() const { return size().getQuantity(); }\n\n  Kind getKind() const { return TheKind; }\n  bool getIsPrivate() const { return (Flags & IsPrivate) != 0; }\n\n  const Expr *getExpr() const { return TheExpr; }\n  CharUnits getConstValue() const { return ConstValue; }\n  CharUnits size() const { return Size; }\n\n  StringRef getMaskType() const { return MaskType; }\n};\n\nclass OSLogBufferLayout {\npublic:\n  SmallVector<OSLogBufferItem, 4> Items;\n\n  enum Flags { HasPrivateItems = 1, HasNonScalarItems = 1 << 1 };\n\n  CharUnits size() const {\n    CharUnits result;\n    result += CharUnits::fromQuantity(2); // summary byte, num-args byte\n    for (auto &item : Items) {\n      // descriptor byte, size byte\n      result += item.size() + CharUnits::fromQuantity(2);\n    }\n    return result;\n  }\n\n  bool hasPrivateItems() const {\n    return llvm::any_of(\n        Items, [](const OSLogBufferItem &Item) { return Item.getIsPrivate(); });\n  }\n\n  bool hasNonScalarOrMask() const {\n    return llvm::any_of(Items, [](const OSLogBufferItem &Item) {\n      return Item.getKind() != OSLogBufferItem::ScalarKind ||\n             !Item.getMaskType().empty();\n    });\n  }\n\n  unsigned char getSummaryByte() const {\n    unsigned char result = 0;\n    if (hasPrivateItems())\n      result |= HasPrivateItems;\n    if (hasNonScalarOrMask())\n      result |= HasNonScalarItems;\n    return result;\n  }\n\n  unsigned char getNumArgsByte() const { return Items.size(); }\n};\n\n// Given a call 'E' to one of the builtins __builtin_os_log_format() or\n// __builtin_os_log_format_buffer_size(), compute the layout of the buffer that\n// the call will write into and store it in 'layout'. Returns 'false' if there\n// was some error encountered while computing the layout, and 'true' otherwise.\nbool computeOSLogBufferLayout(clang::ASTContext &Ctx, const clang::CallExpr *E,\n                              OSLogBufferLayout &layout);\n\n}",
  "id": "BLOCK-CPP-11369",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/OSLog.h",
  "source_line": 21,
  "validation_status": "validated"
}