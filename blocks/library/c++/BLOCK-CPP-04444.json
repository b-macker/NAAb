{
  "code": "#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/utility/utility.h\"\n#include <any>  // IWYU pragma: export\n#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <typeinfo>\n#include <utility>\n#include \"absl/base/internal/fast_type_id.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/types/bad_any_cast.h\"\n\nusing namespace absl;\nusing namespace absl;\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04444_execute() {\n    {\n private:\n  template <typename T>\n  struct IsInPlaceType;\n\n public:\n  // Constructors\n\n  // Constructs an empty `absl::any` object (`any::has_value()` will return\n  // `false`).\n  constexpr any() noexcept;\n\n  // Copy constructs an `absl::any` object with a \"contained object\" of the\n  // passed type of `other` (or an empty `absl::any` if `other.has_value()` is\n  // `false`.\n  any(const any& other)\n      : obj_(other.has_value() ? other.obj_->Clone()\n                               : std::unique_ptr<ObjInterface>()) {}\n\n  // Move constructs an `absl::any` object with a \"contained object\" of the\n  // passed type of `other` (or an empty `absl::any` if `other.has_value()` is\n  // `false`).\n  any(any&& other) noexcept = default;\n\n  // Constructs an `absl::any` object with a \"contained object\" of the decayed\n  // type of `T`, which is initialized via `std::forward<T>(value)`.\n  //\n  // This constructor will not participate in overload resolution if the\n  // decayed type of `T` is not copy-constructible.\n  template <\n      typename T, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<!absl::disjunction<\n          std::is_same<any, VT>, IsInPlaceType<VT>,\n          absl::negation<std::is_copy_constructible<VT> > >::value>* = nullptr>\n  any(T&& value) : obj_(new Obj<VT>(in_place, std::forward<T>(value))) {}\n\n  // Constructs an `absl::any` object with a \"contained object\" of the decayed\n  // type of `T`, which is initialized via `std::forward<T>(value)`.\n  template <typename T, typename... Args, typename VT = absl::decay_t<T>,\n            absl::enable_if_t<absl::conjunction<\n                std::is_copy_constructible<VT>,\n                std::is_constructible<VT, Args...>>::value>* = nullptr>\n  explicit any(in_place_type_t<T> /*tag*/, Args&&... args)\n      : obj_(new Obj<VT>(in_place, std::forward<Args>(args)...)) {}\n\n  // Constructs an `absl::any` object with a \"contained object\" of the passed\n  // type `VT` as a decayed type of `T`. `VT` is initialized as if\n  // direct-non-list-initializing an object of type `VT` with the arguments\n  // `initializer_list, std::forward<Args>(args)...`.\n  template <\n      typename T, typename U, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<\n          absl::conjunction<std::is_copy_constructible<VT>,\n                            std::is_constructible<VT, std::initializer_list<U>&,\n                                                  Args...>>::value>* = nullptr>\n  explicit any(in_place_type_t<T> /*tag*/, std::initializer_list<U> ilist,\n               Args&&... args)\n      : obj_(new Obj<VT>(in_place, ilist, std::forward<Args>(args)...)) {}\n\n  // Assignment operators\n\n  // Copy assigns an `absl::any` object with a \"contained object\" of the\n  // passed type.\n  any& operator=(const any& rhs) {\n    any(rhs).swap(*this);\n    return *this;\n  }\n\n  // Move assigns an `absl::any` object with a \"contained object\" of the\n  // passed type. `rhs` is left in a valid but otherwise unspecified state.\n  any& operator=(any&& rhs) noexcept {\n    any(std::move(rhs)).swap(*this);\n    return *this;\n  }\n\n  // Assigns an `absl::any` object with a \"contained object\" of the passed type.\n  template <typename T, typename VT = absl::decay_t<T>,\n            absl::enable_if_t<absl::conjunction<\n                absl::negation<std::is_same<VT, any>>,\n                std::is_copy_constructible<VT>>::value>* = nullptr>\n  any& operator=(T&& rhs) {\n    any tmp(in_place_type_t<VT>(), std::forward<T>(rhs));\n    tmp.swap(*this);\n    return *this;\n  }\n\n  // Modifiers\n\n  // any::emplace()\n  //\n  // Emplaces a value within an `absl::any` object by calling `any::reset()`,\n  // initializing the contained value as if direct-non-list-initializing an\n  // object of type `VT` with the arguments `std::forward<Args>(args)...`, and\n  // returning a reference to the new contained value.\n  //\n  // Note: If an exception is thrown during the call to `VT`'s constructor,\n  // `*this` does not contain a value, and any previously contained value has\n  // been destroyed.\n  template <\n      typename T, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<std::is_copy_constructible<VT>::value &&\n                        std::is_constructible<VT, Args...>::value>* = nullptr>\n  VT& emplace(Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    reset();  // NOTE: reset() is required here even in the world of exceptions.\n    Obj<VT>* const object_ptr =\n        new Obj<VT>(in_place, std::forward<Args>(args)...);\n    obj_ = std::unique_ptr<ObjInterface>(object_ptr);\n    return object_ptr->value;\n  }\n\n  // Overload of `any::emplace()` to emplace a value within an `absl::any`\n  // object by calling `any::reset()`, initializing the contained value as if\n  // direct-non-list-initializing an object of type `VT` with the arguments\n  // `initializer_list, std::forward<Args>(args)...`, and returning a reference\n  // to the new contained value.\n  //\n  // Note: If an exception is thrown during the call to `VT`'s constructor,\n  // `*this` does not contain a value, and any previously contained value has\n  // been destroyed. The function shall not participate in overload resolution\n  // unless `is_copy_constructible_v<VT>` is `true` and\n  // `is_constructible_v<VT, initializer_list<U>&, Args...>` is `true`.\n  template <\n      typename T, typename U, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<std::is_copy_constructible<VT>::value &&\n                        std::is_constructible<VT, std::initializer_list<U>&,\n                                              Args...>::value>* = nullptr>\n  VT& emplace(std::initializer_list<U> ilist,\n              Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    reset();  // NOTE: reset() is required here even in the world of exceptions.\n    Obj<VT>* const object_ptr =\n        new Obj<VT>(in_place, ilist, std::forward<Args>(args)...);\n    obj_ = std::unique_ptr<ObjInterface>(object_ptr);\n    return object_ptr->value;\n  }\n\n  // any::reset()\n  //\n  // Resets the state of the `absl::any` object, destroying the contained object\n  // if present.\n  void reset() noexcept { obj_ = nullptr; }\n\n  // any::swap()\n  //\n  // Swaps the passed value and the value of this `absl::any` object.\n  void swap(any& other) noexcept { obj_.swap(other.obj_); }\n\n  // Observers\n\n  // any::has_value()\n  //\n  // Returns `true` if the `any` object has a contained value, otherwise\n  // returns `false`.\n  bool has_value() const noexcept { return obj_ != nullptr; }\n\n#ifdef ABSL_INTERNAL_HAS_RTTI\n  // Returns: typeid(T) if *this has a contained object of type T, otherwise\n  // typeid(void).\n  const std::type_info& type() const noexcept {\n    if (has_value()) {\n      return obj_->Type();\n    }\n\n    return typeid(void);\n  }\n#endif  // ABSL_INTERNAL_HAS_RTTI\n\n private:\n  // Tagged type-erased abstraction for holding a cloneable object.\n  class ObjInterface {\n   public:\n    virtual ~ObjInterface() = default;\n    virtual std::unique_ptr<ObjInterface> Clone() const = 0;\n    virtual const void* ObjTypeId() const noexcept = 0;\n#ifdef ABSL_INTERNAL_HAS_RTTI\n    virtual const std::type_info& Type() const noexcept = 0;\n#endif  // ABSL_INTERNAL_HAS_RTTI\n  };\n\n  // Hold a value of some queryable type, with an ability to Clone it.\n  template <typename T>\n  class Obj : public ObjInterface {\n   public:\n    template <typename... Args>\n    explicit Obj(in_place_t /*tag*/, Args&&... args)\n        : value(std::forward<Args>(args)...) {}\n\n    std::unique_ptr<ObjInterface> Clone() const final {\n      return std::unique_ptr<ObjInterface>(new Obj(in_place, value));\n    }\n\n    const void* ObjTypeId() const noexcept final { return IdForType<T>(); }\n\n#ifdef ABSL_INTERNAL_HAS_RTTI\n    const std::type_info& Type() const noexcept final { return typeid(T); }\n#endif  // ABSL_INTERNAL_HAS_RTTI\n\n    T value;\n  };\n\n  std::unique_ptr<ObjInterface> CloneObj() const {\n    if (!obj_) return nullptr;\n    return obj_->Clone();\n  }\n\n  template <typename T>\n  constexpr static const void* IdForType() {\n    // Note: This type dance is to make the behavior consistent with typeid.\n    using NormalizedType =\n        typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n\n    return base_internal::FastTypeId<NormalizedType>();\n  }\n\n  const void* GetObjTypeId() const {\n    return obj_ ? obj_->ObjTypeId() : base_internal::FastTypeId<void>();\n  }\n\n  // `absl::any` nonmember functions //\n\n  // Description at the declaration site (top of file).\n  template <typename ValueType>\n  friend ValueType any_cast(const any& operand);\n\n  // Description at the declaration site (top of file).\n  template <typename ValueType>\n  friend ValueType any_cast(any& operand);  // NOLINT(runtime/references)\n\n  // Description at the declaration site (top of file).\n  template <typename T>\n  friend const T* any_cast(const any* operand) noexcept;\n\n  // Description at the declaration site (top of file).\n  template <typename T>\n  friend T* any_cast(any* operand) noexcept;\n\n  std::unique_ptr<ObjInterface> obj_;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04444",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/any.h",
  "source_line": 190,
  "validation_status": "validated"
}