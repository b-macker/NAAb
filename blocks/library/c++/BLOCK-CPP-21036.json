{
  "code": "#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/Support/ExtensibleRTTI.h\"\n#include \"llvm/Support/HashBuilder.h\"\n#include \"llvm/Support/MD5.h\"\n#include <memory>\n#include <string>\n\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21036_execute() {\n    {\n\nclass ASTReader;\nclass ASTWriter;\nclass Sema;\n\nnamespace serialization {\n  class ModuleFile;\n} // end namespace serialization\n\n/// Metadata for a module file extension.\nstruct ModuleFileExtensionMetadata {\n  /// The name used to identify this particular extension block within\n  /// the resulting module file. It should be unique to the particular\n  /// extension, because this name will be used to match the name of\n  /// an extension block to the appropriate reader.\n  std::string BlockName;\n\n  /// The major version of the extension data.\n  unsigned MajorVersion;\n\n  /// The minor version of the extension data.\n  unsigned MinorVersion;\n\n  /// A string containing additional user information that will be\n  /// stored with the metadata.\n  std::string UserInfo;\n};\n\nclass ModuleFileExtensionReader;\nclass ModuleFileExtensionWriter;\n\n/// An abstract superclass that describes a custom extension to the\n/// module/precompiled header file format.\n///\n/// A module file extension can introduce additional information into\n/// compiled module files (.pcm) and precompiled headers (.pch) via a\n/// custom writer that can then be accessed via a custom reader when\n/// the module file or precompiled header is loaded.\n///\n/// Subclasses must use LLVM RTTI for open class hierarchies.\nclass ModuleFileExtension\n    : public llvm::RTTIExtends<ModuleFileExtension, llvm::RTTIRoot> {\npublic:\n  /// Discriminator for LLVM RTTI.\n  static char ID;\n\n  virtual ~ModuleFileExtension();\n\n  /// Retrieves the metadata for this module file extension.\n  virtual ModuleFileExtensionMetadata getExtensionMetadata() const = 0;\n\n  /// Hash information about the presence of this extension into the\n  /// module hash.\n  ///\n  /// The module hash is used to distinguish different variants of a module that\n  /// are incompatible. If the presence, absence, or version of the module file\n  /// extension should force the creation of a separate set of module files,\n  /// override this method to combine that distinguishing information into the\n  /// module hash.\n  ///\n  /// The default implementation of this function simply does nothing, so the\n  /// presence/absence of this extension does not distinguish module files.\n  using ExtensionHashBuilder =\n      llvm::HashBuilderImpl<llvm::MD5,\n                            llvm::support::endian::system_endianness()>;\n  virtual void hashExtension(ExtensionHashBuilder &HBuilder) const;\n\n  /// Create a new module file extension writer, which will be\n  /// responsible for writing the extension contents into a particular\n  /// module file.\n  virtual std::unique_ptr<ModuleFileExtensionWriter>\n  createExtensionWriter(ASTWriter &Writer) = 0;\n\n  /// Create a new module file extension reader, given the\n  /// metadata read from the block and the cursor into the extension\n  /// block.\n  ///\n  /// May return null to indicate that an extension block with the\n  /// given metadata cannot be read.\n  virtual std::unique_ptr<ModuleFileExtensionReader>\n  createExtensionReader(const ModuleFileExtensionMetadata &Metadata,\n                        ASTReader &Reader, serialization::ModuleFile &Mod,\n                        const llvm::BitstreamCursor &Stream) = 0;\n};\n\n/// Abstract base class that writes a module file extension block into\n/// a module file.\nclass ModuleFileExtensionWriter {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionWriter(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  virtual ~ModuleFileExtensionWriter();\n\n  /// Retrieve the module file extension with which this writer is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  /// Write the contents of the extension block into the given bitstream.\n  ///\n  /// Responsible for writing the contents of the extension into the\n  /// given stream. All of the contents should be written into custom\n  /// records with IDs >= FIRST_EXTENSION_RECORD_ID.\n  virtual void writeExtensionContents(Sema &SemaRef,\n                                      llvm::BitstreamWriter &Stream) = 0;\n};\n\n/// Abstract base class that reads a module file extension block from\n/// a module file.\n///\n/// Subclasses\nclass ModuleFileExtensionReader {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionReader(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  /// Retrieve the module file extension with which this reader is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  virtual ~ModuleFileExtensionReader();\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21036",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ModuleFileExtension.h",
  "source_line": 25,
  "validation_status": "validated"
}