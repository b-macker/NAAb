{
  "code": "{\n  public:\n    enum CandidateSetKind {\n      /// Normal lookup.\n      CSK_Normal,\n\n      /// C++ [over.match.oper]:\n      /// Lookup of operator function candidates in a call using operator\n      /// syntax. Candidates that have no parameters of class type will be\n      /// skipped unless there is a parameter of (reference to) enum type and\n      /// the corresponding argument is of the same enum type.\n      CSK_Operator,\n\n      /// C++ [over.match.copy]:\n      /// Copy-initialization of an object of class type by user-defined\n      /// conversion.\n      CSK_InitByUserDefinedConversion,\n\n      /// C++ [over.match.ctor], [over.match.list]\n      /// Initialization of an object of class type by constructor,\n      /// using either a parenthesized or braced list of arguments.\n      CSK_InitByConstructor,\n    };\n\n    /// Information about operator rewrites to consider when adding operator\n    /// functions to a candidate set.\n    struct OperatorRewriteInfo {\n      OperatorRewriteInfo()\n          : OriginalOperator(OO_None), OpLoc(), AllowRewrittenCandidates(false) {}\n      OperatorRewriteInfo(OverloadedOperatorKind Op, SourceLocation OpLoc,\n                          bool AllowRewritten)\n          : OriginalOperator(Op), OpLoc(OpLoc),\n            AllowRewrittenCandidates(AllowRewritten) {}\n\n      /// The original operator as written in the source.\n      OverloadedOperatorKind OriginalOperator;\n      /// The source location of the operator.\n      SourceLocation OpLoc;\n      /// Whether we should include rewritten candidates in the overload set.\n      bool AllowRewrittenCandidates;\n\n      /// Would use of this function result in a rewrite using a different\n      /// operator?\n      bool isRewrittenOperator(const FunctionDecl *FD) {\n        return OriginalOperator &&\n               FD->getDeclName().getCXXOverloadedOperator() != OriginalOperator;\n      }\n\n      bool isAcceptableCandidate(const FunctionDecl *FD) {\n        if (!OriginalOperator)\n          return true;\n\n        // For an overloaded operator, we can have candidates with a different\n        // name in our unqualified lookup set. Make sure we only consider the\n        // ones we're supposed to.\n        OverloadedOperatorKind OO =\n            FD->getDeclName().getCXXOverloadedOperator();\n        return OO && (OO == OriginalOperator ||\n                      (AllowRewrittenCandidates &&\n                       OO == getRewrittenOverloadedOperator(OriginalOperator)));\n      }\n\n      /// Determine the kind of rewrite that should be performed for this\n      /// candidate.\n      OverloadCandidateRewriteKind\n      getRewriteKind(const FunctionDecl *FD, OverloadCandidateParamOrder PO) {\n        OverloadCandidateRewriteKind CRK = CRK_None;\n        if (isRewrittenOperator(FD))\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_DifferentOperator);\n        if (PO == OverloadCandidateParamOrder::Reversed)\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_Reversed);\n        return CRK;\n      }\n      /// Determines whether this operator could be implemented by a function\n      /// with reversed parameter order.\n      bool isReversible() {\n        return AllowRewrittenCandidates && OriginalOperator &&\n               (getRewrittenOverloadedOperator(OriginalOperator) != OO_None ||\n                allowsReversed(OriginalOperator));\n      }\n\n      /// Determine whether reversing parameter order is allowed for operator\n      /// Op.\n      bool allowsReversed(OverloadedOperatorKind Op);\n\n      /// Determine whether we should add a rewritten candidate for \\p FD with\n      /// reversed parameter order.\n      /// \\param OriginalArgs are the original non reversed arguments.\n      bool shouldAddReversed(Sema &S, ArrayRef<Expr *> OriginalArgs,\n                             FunctionDecl *FD);\n    };\n\n  private:\n    SmallVector<OverloadCandidate, 16> Candidates;\n    llvm::SmallPtrSet<uintptr_t, 16> Functions;\n\n    // Allocator for ConversionSequenceLists. We store the first few of these\n    // inline to avoid allocation for small sets.\n    llvm::BumpPtrAllocator SlabAllocator;\n\n    SourceLocation Loc;\n    CandidateSetKind Kind;\n    OperatorRewriteInfo RewriteInfo;\n\n    constexpr static unsigned NumInlineBytes =\n        24 * sizeof(ImplicitConversionSequence);\n    unsigned NumInlineBytesUsed = 0;\n    alignas(void *) char InlineSpace[NumInlineBytes];\n\n    // Address space of the object being constructed.\n    LangAS DestAS = LangAS::Default;\n\n    /// If we have space, allocates from inline storage. Otherwise, allocates\n    /// from the slab allocator.\n    /// FIXME: It would probably be nice to have a SmallBumpPtrAllocator\n    /// instead.\n    /// FIXME: Now that this only allocates ImplicitConversionSequences, do we\n    /// want to un-generalize this?\n    template <typename T>\n    T *slabAllocate(unsigned N) {\n      // It's simpler if this doesn't need to consider alignment.\n      static_assert(alignof(T) == alignof(void *),\n                    \"Only works for pointer-aligned types.\");\n      static_assert(std::is_trivial<T>::value ||\n                        std::is_same<ImplicitConversionSequence, T>::value,\n                    \"Add destruction logic to OverloadCandidateSet::clear().\");\n\n      unsigned NBytes = sizeof(T) * N;\n      if (NBytes > NumInlineBytes - NumInlineBytesUsed)\n        return SlabAllocator.Allocate<T>(N);\n      char *FreeSpaceStart = InlineSpace + NumInlineBytesUsed;\n      assert(uintptr_t(FreeSpaceStart) % alignof(void *) == 0 &&\n             \"Misaligned storage!\");\n\n      NumInlineBytesUsed += NBytes;\n      return reinterpret_cast<T *>(FreeSpaceStart);\n    }\n\n    void destroyCandidates();\n\n  public:\n    OverloadCandidateSet(SourceLocation Loc, CandidateSetKind CSK,\n                         OperatorRewriteInfo RewriteInfo = {})\n        : Loc(Loc), Kind(CSK), RewriteInfo(RewriteInfo) {}\n    OverloadCandidateSet(const OverloadCandidateSet &) = delete;\n    OverloadCandidateSet &operator=(const OverloadCandidateSet &) = delete;\n    ~OverloadCandidateSet() { destroyCandidates(); }\n\n    SourceLocation getLocation() const { return Loc; }\n    CandidateSetKind getKind() const { return Kind; }\n    OperatorRewriteInfo getRewriteInfo() const { return RewriteInfo; }\n\n    /// Whether diagnostics should be deferred.\n    bool shouldDeferDiags(Sema &S, ArrayRef<Expr *> Args, SourceLocation OpLoc);\n\n    /// Determine when this overload candidate will be new to the\n    /// overload set.\n    bool isNewCandidate(Decl *F, OverloadCandidateParamOrder PO =\n                                     OverloadCandidateParamOrder::Normal) {\n      uintptr_t Key = reinterpret_cast<uintptr_t>(F->getCanonicalDecl());\n      Key |= static_cast<uintptr_t>(PO);\n      return Functions.insert(Key).second;\n    }\n\n    /// Exclude a function from being considered by overload resolution.\n    void exclude(Decl *F) {\n      isNewCandidate(F, OverloadCandidateParamOrder::Normal);\n      isNewCandidate(F, OverloadCandidateParamOrder::Reversed);\n    }\n\n    /// Clear out all of the candidates.\n    void clear(CandidateSetKind CSK);\n\n    using iterator = SmallVectorImpl<OverloadCandidate>::iterator;\n\n    iterator begin() { return Candidates.begin(); }\n    iterator end() { return Candidates.end(); }\n\n    size_t size() const { return Candidates.size(); }\n    bool empty() const { return Candidates.empty(); }\n\n    /// Allocate storage for conversion sequences for NumConversions\n    /// conversions.\n    ConversionSequenceList\n    allocateConversionSequences(unsigned NumConversions) {\n      ImplicitConversionSequence *Conversions =\n          slabAllocate<ImplicitConversionSequence>(NumConversions);\n\n      // Construct the new objects.\n      for (unsigned I = 0; I != NumConversions; ++I)\n        new (&Conversions[I]) ImplicitConversionSequence();\n\n      return ConversionSequenceList(Conversions, NumConversions);\n    }\n\n    /// Add a new candidate with NumConversions conversion sequence slots\n    /// to the overload set.\n    OverloadCandidate &\n    addCandidate(unsigned NumConversions = 0,\n                 ConversionSequenceList Conversions = std::nullopt) {\n      assert((Conversions.empty() || Conversions.size() == NumConversions) &&\n             \"preallocated conversion sequence has wrong length\");\n\n      Candidates.push_back(OverloadCandidate());\n      OverloadCandidate &C = Candidates.back();\n      C.Conversions = Conversions.empty()\n                          ? allocateConversionSequences(NumConversions)\n                          : Conversions;\n      return C;\n    }\n\n    /// Find the best viable function on this overload set, if it exists.\n    OverloadingResult BestViableFunction(Sema &S, SourceLocation Loc,\n                                         OverloadCandidateSet::iterator& Best);\n\n    SmallVector<OverloadCandidate *, 32> CompleteCandidates(\n        Sema &S, OverloadCandidateDisplayKind OCD, ArrayRef<Expr *> Args,\n        SourceLocation OpLoc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(\n        PartialDiagnosticAt PA, Sema &S, OverloadCandidateDisplayKind OCD,\n        ArrayRef<Expr *> Args, StringRef Opc = \"\",\n        SourceLocation Loc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(Sema &S, ArrayRef<Expr *> Args,\n                        ArrayRef<OverloadCandidate *> Cands,\n                        StringRef Opc = \"\",\n                        SourceLocation OpLoc = SourceLocation());\n\n    LangAS getDestAS() { return DestAS; }\n\n    void setDestAS(LangAS AS) {\n      assert((Kind == CSK_InitByConstructor ||\n              Kind == CSK_InitByUserDefinedConversion) &&\n             \"can't set the destination address space when not constructing an \"\n             \"object\");\n      DestAS = AS;\n    }\n\n  }",
  "id": "BLOCK-CPP-20047",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Overload.h",
  "source_line": 954,
  "validation_status": "validated"
}