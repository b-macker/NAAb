{
  "code": "{\n\nclass SanitizerMask {\n  // NOTE: this class assumes kNumElem == 2 in most of the constexpr functions,\n  // in order to work within the C++11 constexpr function constraints. If you\n  // change kNumElem, you'll need to update those member functions as well.\n\n  /// Number of array elements.\n  static constexpr unsigned kNumElem = 2;\n  /// Mask value initialized to 0.\n  uint64_t maskLoToHigh[kNumElem]{};\n  /// Number of bits in a mask.\n  static constexpr unsigned kNumBits = sizeof(decltype(maskLoToHigh)) * 8;\n  /// Number of bits in a mask element.\n  static constexpr unsigned kNumBitElem = sizeof(decltype(maskLoToHigh[0])) * 8;\n\n  constexpr SanitizerMask(uint64_t mask1, uint64_t mask2)\n      : maskLoToHigh{mask1, mask2} {}\n\npublic:\n  SanitizerMask() = default;\n\n  static constexpr bool checkBitPos(const unsigned Pos) {\n    return Pos < kNumBits;\n  }\n\n  /// Create a mask with a bit enabled at position Pos.\n  static constexpr SanitizerMask bitPosToMask(const unsigned Pos) {\n    uint64_t mask1 = (Pos < kNumBitElem) ? 1ULL << (Pos % kNumBitElem) : 0;\n    uint64_t mask2 = (Pos >= kNumBitElem && Pos < (kNumBitElem * 2))\n                         ? 1ULL << (Pos % kNumBitElem)\n                         : 0;\n    return SanitizerMask(mask1, mask2);\n  }\n\n  unsigned countPopulation() const;\n\n  void flipAllBits() {\n    for (auto &Val : maskLoToHigh)\n      Val = ~Val;\n  }\n\n  bool isPowerOf2() const {\n    return countPopulation() == 1;\n  }\n\n  llvm::hash_code hash_value() const;\n\n  template <typename HasherT, llvm::support::endianness Endianness>\n  friend void addHash(llvm::HashBuilderImpl<HasherT, Endianness> &HBuilder,\n                      const SanitizerMask &SM) {\n    HBuilder.addRange(&SM.maskLoToHigh[0], &SM.maskLoToHigh[kNumElem]);\n  }\n\n  constexpr explicit operator bool() const {\n    return maskLoToHigh[0] || maskLoToHigh[1];\n  }\n\n  constexpr bool operator==(const SanitizerMask &V) const {\n    return maskLoToHigh[0] == V.maskLoToHigh[0] &&\n           maskLoToHigh[1] == V.maskLoToHigh[1];\n  }\n\n  SanitizerMask &operator&=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] &= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  SanitizerMask &operator|=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] |= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  constexpr bool operator!() const { return !bool(*this); }\n\n  constexpr bool operator!=(const SanitizerMask &RHS) const {\n    return !((*this) == RHS);\n  }\n\n  friend constexpr inline SanitizerMask operator~(SanitizerMask v) {\n    return SanitizerMask(~v.maskLoToHigh[0], ~v.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator&(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] & b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] & b.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator|(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] | b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] | b.maskLoToHigh[1]);\n  }\n};\n\n// Declaring in clang namespace so that it can be found by ADL.\nllvm::hash_code hash_value(const clang::SanitizerMask &Arg);\n\n// Define the set of sanitizer kinds, as well as the set of sanitizers each\n// sanitizer group expands into.\nstruct SanitizerKind {\n  // Assign ordinals to possible values of -fsanitize= flag, which we will use\n  // as bit positions.\n  enum SanitizerOrdinal : uint64_t {\n#define SANITIZER(NAME, ID) SO_##ID,\n#define SANITIZER_GROUP(NAME, ID, ALIAS) SO_##ID##Group,\n#include \"clang/Basic/Sanitizers.def\"\n    SO_Count\n  };\n\n#define SANITIZER(NAME, ID)                                                    \\\n  static constexpr SanitizerMask ID = SanitizerMask::bitPosToMask(SO_##ID);    \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID), \"Bit position too big.\");\n#define SANITIZER_GROUP(NAME, ID, ALIAS)                                       \\\n  static constexpr SanitizerMask ID = SanitizerMask(ALIAS);                    \\\n  static constexpr SanitizerMask ID##Group =                                   \\\n      SanitizerMask::bitPosToMask(SO_##ID##Group);                             \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID##Group),                    \\\n                \"Bit position too big.\");\n#include \"clang/Basic/Sanitizers.def\"\n}; // SanitizerKind\n\nstruct SanitizerSet {\n  /// Check if a certain (single) sanitizer is enabled.\n  bool has(SanitizerMask K) const {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    return static_cast<bool>(Mask & K);\n  }\n\n  /// Check if one or more sanitizers are enabled.\n  bool hasOneOf(SanitizerMask K) const { return static_cast<bool>(Mask & K); }\n\n  /// Enable or disable a certain (single) sanitizer.\n  void set(SanitizerMask K, bool Value) {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    Mask = Value ? (Mask | K) : (Mask & ~K);\n  }\n\n  /// Disable the sanitizers specified in \\p K.\n  void clear(SanitizerMask K = SanitizerKind::All) { Mask &= ~K; }\n\n  /// Returns true if no sanitizers are enabled.\n  bool empty() const { return !Mask; }\n\n  /// Bitmask of enabled sanitizers.\n  SanitizerMask Mask;\n};\n\n/// Parse a single value from a -fsanitize= or -fno-sanitize= value list.\n/// Returns a non-zero SanitizerMask, or \\c 0 if \\p Value is not known.\nSanitizerMask parseSanitizerValue(StringRef Value, bool AllowGroups);\n\n/// Serialize a SanitizerSet into values for -fsanitize= or -fno-sanitize=.\nvoid serializeSanitizerSet(SanitizerSet Set,\n                           SmallVectorImpl<StringRef> &Values);\n\n/// For each sanitizer group bit set in \\p Kinds, set the bits for sanitizers\n/// this group enables.\nSanitizerMask expandSanitizerGroups(SanitizerMask Kinds);\n\n/// Return the sanitizers which do not affect preprocessing.\ninline SanitizerMask getPPTransparentSanitizers() {\n  return SanitizerKind::CFI | SanitizerKind::Integer |\n         SanitizerKind::ImplicitConversion | SanitizerKind::Nullability |\n         SanitizerKind::Undefined | SanitizerKind::FloatDivideByZero;\n}\n\nStringRef AsanDtorKindToString(llvm::AsanDtorKind kind);\n\nllvm::AsanDtorKind AsanDtorKindFromString(StringRef kind);\n\nStringRef AsanDetectStackUseAfterReturnModeToString(\n    llvm::AsanDetectStackUseAfterReturnMode mode);\n\nllvm::AsanDetectStackUseAfterReturnMode\nAsanDetectStackUseAfterReturnModeFromString(StringRef modeStr);\n\n}",
  "id": "BLOCK-CPP-16766",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Sanitizers.h",
  "source_line": 32,
  "validation_status": "validated"
}