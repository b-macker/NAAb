{
  "code": "{\n\n/*\n * Generator of daily log file names in format basename.YYYY-MM-DD.ext\n */\nstruct daily_filename_calculator {\n    // Create filename for the form basename.YYYY-MM-DD\n    static filename_t calc_filename(const filename_t &filename, const tm &now_tm) {\n        filename_t basename, ext;\n        std::tie(basename, ext) = details::file_helper::split_by_extension(filename);\n        return fmt_lib::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}{}\")),\n                               basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday,\n                               ext);\n    }\n};\n\n/*\n * Generator of daily log file names with strftime format.\n * Usages:\n *    auto sink =\n * std::make_shared<spdlog::sinks::daily_file_format_sink_mt>(\"myapp-%Y-%m-%d:%H:%M:%S.log\", hour,\n * minute);\" auto logger = spdlog::daily_logger_format_mt(\"loggername, \"myapp-%Y-%m-%d:%X.log\",\n * hour,  minute)\"\n *\n */\nstruct daily_filename_format_calculator {\n    static filename_t calc_filename(const filename_t &file_path, const tm &now_tm) {\n#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\n        std::wstringstream stream;\n#else\n        std::stringstream stream;\n#endif\n        stream << std::put_time(&now_tm, file_path.c_str());\n        return stream.str();\n    }\n};\n\n/*\n * Rotating file sink based on date.\n * If truncate != false , the created file will be truncated.\n * If max_files > 0, retain only the last max_files and delete previous.\n */\ntemplate <typename Mutex, typename FileNameCalc = daily_filename_calculator>\nclass daily_file_sink final : public base_sink<Mutex> {\npublic:\n    // create daily file sink which rotates on given time\n    daily_file_sink(filename_t base_filename,\n                    int rotation_hour,\n                    int rotation_minute,\n                    bool truncate = false,\n                    uint16_t max_files = 0,\n                    const file_event_handlers &event_handlers = {})\n        : base_filename_(std::move(base_filename)),\n          rotation_h_(rotation_hour),\n          rotation_m_(rotation_minute),\n          file_helper_{event_handlers},\n          truncate_(truncate),\n          max_files_(max_files),\n          filenames_q_() {\n        if (rotation_hour < 0 || rotation_hour > 23 || rotation_minute < 0 ||\n            rotation_minute > 59) {\n            throw_spdlog_ex(\"daily_file_sink: Invalid rotation time in ctor\");\n        }\n\n        auto now = log_clock::now();\n        auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));\n        file_helper_.open(filename, truncate_);\n        rotation_tp_ = next_rotation_tp_();\n\n        if (max_files_ > 0) {\n            init_filenames_q_();\n        }\n    }\n\n    filename_t filename() {\n        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n        return file_helper_.filename();\n    }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        auto time = msg.time;\n        bool should_rotate = time >= rotation_tp_;\n        if (should_rotate) {\n            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(time));\n            file_helper_.open(filename, truncate_);\n            rotation_tp_ = next_rotation_tp_();\n        }\n        memory_buf_t formatted;\n        base_sink<Mutex>::formatter_->format(msg, formatted);\n        file_helper_.write(formatted);\n\n        // Do the cleaning only at the end because it might throw on failure.\n        if (should_rotate && max_files_ > 0) {\n            delete_old_();\n        }\n    }\n\n    void flush_() override { file_helper_.flush(); }\n\nprivate:\n    void init_filenames_q_() {\n        using details::os::path_exists;\n\n        filenames_q_ = details::circular_q<filename_t>(static_cast<size_t>(max_files_));\n        std::vector<filename_t> filenames;\n        auto now = log_clock::now();\n        while (filenames.size() < max_files_) {\n            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));\n            if (!path_exists(filename)) {\n                break;\n            }\n            filenames.emplace_back(filename);\n            now -= std::chrono::hours(24);\n        }\n        for (auto iter = filenames.rbegin(); iter != filenames.rend(); ++iter) {\n            filenames_q_.push_back(std::move(*iter));\n        }\n    }\n\n    tm now_tm(log_clock::time_point tp) {\n        time_t tnow = log_clock::to_time_t(tp);\n        return spdlog::details::os::localtime(tnow);\n    }\n\n    log_clock::time_point next_rotation_tp_() {\n        auto now = log_clock::now();\n        tm date = now_tm(now);\n        date.tm_hour = rotation_h_;\n        date.tm_min = rotation_m_;\n        date.tm_sec = 0;\n        auto rotation_time = log_clock::from_time_t(std::mktime(&date));\n        if (rotation_time > now) {\n            return rotation_time;\n        }\n        return {rotation_time + std::chrono::hours(24)};\n    }\n\n    // Delete the file N rotations ago.\n    // Throw spdlog_ex on failure to delete the old file.\n    void delete_old_() {\n        using details::os::filename_to_str;\n        using details::os::remove_if_exists;\n\n        filename_t current_file = file_helper_.filename();\n        if (filenames_q_.full()) {\n            auto old_filename = std::move(filenames_q_.front());\n            filenames_q_.pop_front();\n            bool ok = remove_if_exists(old_filename) == 0;\n            if (!ok) {\n                filenames_q_.push_back(std::move(current_file));\n                throw_spdlog_ex(\"Failed removing daily file \" + filename_to_str(old_filename),\n                                errno);\n            }\n        }\n        filenames_q_.push_back(std::move(current_file));\n    }\n\n    filename_t base_filename_;\n    int rotation_h_;\n    int rotation_m_;\n    log_clock::time_point rotation_tp_;\n    details::file_helper file_helper_;\n    bool truncate_;\n    uint16_t max_files_;\n    details::circular_q<filename_t> filenames_q_;\n};\n\nusing daily_file_sink_mt = daily_file_sink<std::mutex>;\nusing daily_file_sink_st = daily_file_sink<details::null_mutex>;\nusing daily_file_format_sink_mt = daily_file_sink<std::mutex, daily_filename_format_calculator>;\nusing daily_file_format_sink_st =\n    daily_file_sink<details::null_mutex, daily_filename_format_calculator>;\n\n}",
  "id": "BLOCK-CPP-00394",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/daily_file_sink.h",
  "source_line": 24,
  "validation_status": "validated"
}