{
  "code": "{\n\n// RandenPoolSeedSeq is a custom seed sequence type where generate() fills the\n// provided buffer via the RandenPool entropy source.\nclass RandenPoolSeedSeq {\n private:\n  struct ContiguousTag {};\n  struct BufferTag {};\n\n  // Generate random unsigned values directly into the buffer.\n  template <typename Contiguous>\n  void generate_impl(ContiguousTag, Contiguous begin, Contiguous end) {\n    const size_t n = static_cast<size_t>(std::distance(begin, end));\n    auto* a = &(*begin);\n    RandenPool<uint8_t>::Fill(\n        absl::MakeSpan(reinterpret_cast<uint8_t*>(a), sizeof(*a) * n));\n  }\n\n  // Construct a buffer of size n and fill it with values, then copy\n  // those values into the seed iterators.\n  template <typename RandomAccessIterator>\n  void generate_impl(BufferTag, RandomAccessIterator begin,\n                     RandomAccessIterator end) {\n    const size_t n = std::distance(begin, end);\n    absl::InlinedVector<uint32_t, 8> data(n, 0);\n    RandenPool<uint32_t>::Fill(absl::MakeSpan(data.begin(), data.end()));\n    std::copy(std::begin(data), std::end(data), begin);\n  }\n\n public:\n  using result_type = uint32_t;\n\n  size_t size() { return 0; }\n\n  template <typename OutIterator>\n  void param(OutIterator) const {}\n\n  template <typename RandomAccessIterator>\n  void generate(RandomAccessIterator begin, RandomAccessIterator end) {\n    // RandomAccessIterator must be assignable from uint32_t\n    if (begin != end) {\n      using U = typename std::iterator_traits<RandomAccessIterator>::value_type;\n      // ContiguousTag indicates the common case of a known contiguous buffer,\n      // which allows directly filling the buffer. In C++20,\n      // std::contiguous_iterator_tag provides a mechanism for testing this\n      // capability, however until Abseil's support requirements allow us to\n      // assume C++20, limit checks to a few common cases.\n      using TagType = absl::conditional_t<\n          (std::is_pointer<RandomAccessIterator>::value ||\n           std::is_same<RandomAccessIterator,\n                        typename std::vector<U>::iterator>::value),\n          ContiguousTag, BufferTag>;\n\n      generate_impl(TagType{}, begin, end);\n    }\n  }\n};\n\n// Each instance of NonsecureURBGBase<URBG> will be seeded by variates produced\n// by a thread-unique URBG-instance.\ntemplate <typename URBG, typename Seeder = RandenPoolSeedSeq>\nclass NonsecureURBGBase {\n public:\n  using result_type = typename URBG::result_type;\n\n  // Default constructor\n  NonsecureURBGBase() : urbg_(ConstructURBG()) {}\n\n  // Copy disallowed, move allowed.\n  NonsecureURBGBase(const NonsecureURBGBase&) = delete;\n  NonsecureURBGBase& operator=(const NonsecureURBGBase&) = delete;\n  NonsecureURBGBase(NonsecureURBGBase&&) = default;\n  NonsecureURBGBase& operator=(NonsecureURBGBase&&) = default;\n\n  // Constructor using a seed\n  template <class SSeq, typename = typename absl::enable_if_t<\n                            !std::is_same<SSeq, NonsecureURBGBase>::value>>\n  explicit NonsecureURBGBase(SSeq&& seq)\n      : urbg_(ConstructURBG(std::forward<SSeq>(seq))) {}\n\n  // Note: on MSVC, min() or max() can be interpreted as MIN() or MAX(), so we\n  // enclose min() or max() in parens as (min)() and (max)().\n  // Additionally, clang-format requires no space before this construction.\n\n  // NonsecureURBGBase::min()\n  static constexpr result_type(min)() { return (URBG::min)(); }\n\n  // NonsecureURBGBase::max()\n  static constexpr result_type(max)() { return (URBG::max)(); }\n\n  // NonsecureURBGBase::operator()()\n  result_type operator()() { return urbg_(); }\n\n  // NonsecureURBGBase::discard()\n  void discard(unsigned long long values) {  // NOLINT(runtime/int)\n    urbg_.discard(values);\n  }\n\n  bool operator==(const NonsecureURBGBase& other) const {\n    return urbg_ == other.urbg_;\n  }\n\n  bool operator!=(const NonsecureURBGBase& other) const {\n    return !(urbg_ == other.urbg_);\n  }\n\n private:\n  static URBG ConstructURBG() {\n    Seeder seeder;\n    return URBG(seeder);\n  }\n\n  template <typename SSeq>\n  static URBG ConstructURBG(SSeq&& seq) {  // NOLINT(runtime/references)\n    auto salted_seq =\n        random_internal::MakeSaltedSeedSeq(std::forward<SSeq>(seq));\n    return URBG(salted_seq);\n  }\n\n  URBG urbg_;\n};\n\n}",
  "id": "BLOCK-CPP-05908",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/nonsecure_base.h",
  "source_line": 35,
  "validation_status": "validated"
}