{
  "code": "{\n\n/// Describes the different kinds of linkage\n/// (C++ [basic.link], C99 6.2.2) that an entity may have.\nenum Linkage : unsigned char {\n  /// No linkage, which means that the entity is unique and\n  /// can only be referred to from within its scope.\n  NoLinkage = 0,\n\n  /// Internal linkage, which indicates that the entity can\n  /// be referred to from within the translation unit (but not other\n  /// translation units).\n  InternalLinkage,\n\n  /// External linkage within a unique namespace.\n  ///\n  /// From the language perspective, these entities have external\n  /// linkage. However, since they reside in an anonymous namespace,\n  /// their names are unique to this translation unit, which is\n  /// equivalent to having internal linkage from the code-generation\n  /// point of view.\n  UniqueExternalLinkage,\n\n  /// No linkage according to the standard, but is visible from other\n  /// translation units because of types defined in a inline function.\n  VisibleNoLinkage,\n\n  /// Module linkage, which indicates that the entity can be referred\n  /// to from other translation units within the same module, and indirectly\n  /// from arbitrary other translation units through inline functions and\n  /// templates in the module interface.\n  ModuleLinkage,\n\n  /// External linkage, which indicates that the entity can\n  /// be referred to from other translation units.\n  ExternalLinkage\n};\n\n/// Describes the different kinds of language linkage\n/// (C++ [dcl.link]) that an entity may have.\nenum LanguageLinkage {\n  CLanguageLinkage,\n  CXXLanguageLinkage,\n  NoLanguageLinkage\n};\n\n/// A more specific kind of linkage than enum Linkage.\n///\n/// This is relevant to CodeGen and AST file reading.\nenum GVALinkage {\n  GVA_Internal,\n  GVA_AvailableExternally,\n  GVA_DiscardableODR,\n  GVA_StrongExternal,\n  GVA_StrongODR\n};\n\ninline bool isDiscardableGVALinkage(GVALinkage L) {\n  return L <= GVA_DiscardableODR;\n}\n\n/// Do we know that this will be the only definition of this symbol (excluding\n/// inlining-only definitions)?\ninline bool isUniqueGVALinkage(GVALinkage L) {\n  return L == GVA_Internal || L == GVA_StrongExternal;\n}\n\ninline bool isExternallyVisible(Linkage L) {\n  return L >= VisibleNoLinkage;\n}\n\ninline Linkage getFormalLinkage(Linkage L) {\n  switch (L) {\n  case UniqueExternalLinkage:\n    return ExternalLinkage;\n  case VisibleNoLinkage:\n    return NoLinkage;\n  default:\n    return L;\n  }\n}\n\ninline bool isExternalFormalLinkage(Linkage L) {\n  return getFormalLinkage(L) == ExternalLinkage;\n}\n\n/// Compute the minimum linkage given two linkages.\n///\n/// The linkage can be interpreted as a pair formed by the formal linkage and\n/// a boolean for external visibility. This is just what getFormalLinkage and\n/// isExternallyVisible return. We want the minimum of both components. The\n/// Linkage enum is defined in an order that makes this simple, we just need\n/// special cases for when VisibleNoLinkage would lose the visible bit and\n/// become NoLinkage.\ninline Linkage minLinkage(Linkage L1, Linkage L2) {\n  if (L2 == VisibleNoLinkage)\n    std::swap(L1, L2);\n  if (L1 == VisibleNoLinkage) {\n    if (L2 == InternalLinkage)\n      return NoLinkage;\n    if (L2 == UniqueExternalLinkage)\n      return NoLinkage;\n  }\n  return L1 < L2 ? L1 : L2;\n}\n\n}",
  "id": "BLOCK-CPP-16591",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Linkage.h",
  "source_line": 19,
  "validation_status": "validated"
}