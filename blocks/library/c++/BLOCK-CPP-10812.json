{
  "code": "{\n///   template<typename...Us> auto f(Ts ...ts) -> decltype(g(Us(ts)...));\n/// };\n/// template struct S<int, int>;\n/// \\endcode\nclass FunctionParmPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<FunctionParmPackExpr, VarDecl *> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The function parameter pack which was referenced.\n  VarDecl *ParamPack;\n\n  /// The location of the function parameter pack reference.\n  SourceLocation NameLoc;\n\n  /// The number of expansions of this pack.\n  unsigned NumParameters;\n\n  FunctionParmPackExpr(QualType T, VarDecl *ParamPack,\n                       SourceLocation NameLoc, unsigned NumParams,\n                       VarDecl *const *Params);\n\npublic:\n  static FunctionParmPackExpr *Create(const ASTContext &Context, QualType T,\n                                      VarDecl *ParamPack,\n                                      SourceLocation NameLoc,\n                                      ArrayRef<VarDecl *> Params);\n  static FunctionParmPackExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumParams);\n\n  /// Get the parameter pack which this expression refers to.\n  VarDecl *getParameterPack() const { return ParamPack; }\n\n  /// Get the location of the parameter pack.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Iterators over the parameters which the parameter pack expanded\n  /// into.\n  using iterator = VarDecl * const *;\n  iterator begin() const { return getTrailingObjects<VarDecl *>(); }\n  iterator end() const { return begin() + NumParameters; }\n\n  /// Get the number of parameters in this parameter pack.\n  unsigned getNumExpansions() const { return NumParameters; }\n\n  /// Get an expansion of the parameter pack by index.\n  VarDecl *getExpansion(unsigned I) const { return begin()[I]; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FunctionParmPackExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a prvalue temporary that is written into memory so that\n/// a reference can bind to it.\n///\n/// Prvalue expressions are materialized when they need to have an address\n/// in memory for a reference to bind to. This happens when binding a\n/// reference to the result of a conversion, e.g.,\n///\n/// \\code\n/// const int &r = 1.0;\n/// \\endcode\n///\n/// Here, 1.0 is implicitly converted to an \\c int. That resulting \\c int is\n/// then materialized via a \\c MaterializeTemporaryExpr, and the reference\n/// binds to the temporary. \\c MaterializeTemporaryExprs are always glvalues\n/// (either an lvalue or an xvalue, depending on the kind of reference binding\n/// to it), maintaining the invariant that references always bind to glvalues.\n///\n/// Reference binding and copy-elision can both extend the lifetime of a\n/// temporary. When either happens, the expression will also track the\n/// declaration which is responsible for the lifetime extension.\nclass MaterializeTemporaryExpr : public Expr {\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  llvm::PointerUnion<Stmt *, LifetimeExtendedTemporaryDecl *> State;\n\npublic:\n  MaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                           bool BoundToLvalueReference,\n                           LifetimeExtendedTemporaryDecl *MTD = nullptr);\n\n  MaterializeTemporaryExpr(EmptyShell Empty)\n      : Expr(MaterializeTemporaryExprClass, Empty) {}\n\n  /// Retrieve the temporary-generating subexpression whose value will\n  /// be materialized into a glvalue.\n  Expr *getSubExpr() const {\n    return cast<Expr>(\n        State.is<Stmt *>()\n            ? State.get<Stmt *>()\n            : State.get<LifetimeExtendedTemporaryDecl *>()->getTemporaryExpr());\n  }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const {\n    return State.is<Stmt *>() ? SD_FullExpression\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getStorageDuration();\n  }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const {\n    assert(State.is<LifetimeExtendedTemporaryDecl *>() &&\n           \"the temporary has not been lifetime extended\");\n    return State.get<LifetimeExtendedTemporaryDecl *>()->getOrCreateValue(\n        MayCreate);\n  }\n\n  LifetimeExtendedTemporaryDecl *getLifetimeExtendedTemporaryDecl() {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n  const LifetimeExtendedTemporaryDecl *\n  getLifetimeExtendedTemporaryDecl() const {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n\n  /// Get the declaration which triggered the lifetime-extension of this\n  /// temporary, if any.\n  ValueDecl *getExtendingDecl() {\n    return State.is<Stmt *>() ? nullptr\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getExtendingDecl();\n  }\n  const ValueDecl *getExtendingDecl() const {\n    return const_cast<MaterializeTemporaryExpr *>(this)->getExtendingDecl();\n  }\n\n  void setExtendingDecl(ValueDecl *ExtendedBy, unsigned ManglingNumber);\n\n  unsigned getManglingNumber() const {\n    return State.is<Stmt *>() ? 0\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getManglingNumber();\n  }\n\n  /// Determine whether this materialized temporary is bound to an\n  /// lvalue reference; otherwise, it's bound to an rvalue reference.\n  bool isBoundToLvalueReference() const { return isLValue(); }\n\n  /// Determine whether this temporary object is usable in constant\n  /// expressions, as specified in C++20 [expr.const]p4.\n  bool isUsableInConstantExpressions(const ASTContext &Context) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MaterializeTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return State.is<Stmt *>()\n               ? child_range(State.getAddrOfPtr1(), State.getAddrOfPtr1() + 1)\n               : State.get<LifetimeExtendedTemporaryDecl *>()->childrenExpr();\n  }\n\n  const_child_range children() const {\n    return State.is<Stmt *>()\n               ? const_child_range(State.getAddrOfPtr1(),\n                                   State.getAddrOfPtr1() + 1)\n               : const_cast<const LifetimeExtendedTemporaryDecl *>(\n                     State.get<LifetimeExtendedTemporaryDecl *>())\n                     ->childrenExpr();\n  }\n};\n\n/// Represents a folding of a pack over an operator.\n///\n/// This expression is always dependent and represents a pack expansion of the\n/// forms:\n///\n///    ( expr op ... )\n///    ( ... op expr )\n///    ( expr op ... op expr )\nclass CXXFoldExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  enum SubExpr { Callee, LHS, RHS, Count };\n\n  SourceLocation LParenLoc;\n  SourceLocation EllipsisLoc;\n  SourceLocation RParenLoc;\n  // When 0, the number of expansions is not known. Otherwise, this is one more\n  // than the number of expansions.\n  unsigned NumExpansions;\n  Stmt *SubExprs[SubExpr::Count];\n  BinaryOperatorKind Opcode;\n\npublic:\n  CXXFoldExpr(QualType T, UnresolvedLookupExpr *Callee,\n              SourceLocation LParenLoc, Expr *LHS, BinaryOperatorKind Opcode,\n              SourceLocation EllipsisLoc, Expr *RHS, SourceLocation RParenLoc,\n              std::optional<unsigned> NumExpansions)\n      : Expr(CXXFoldExprClass, T, VK_PRValue, OK_Ordinary),\n        LParenLoc(LParenLoc), EllipsisLoc(EllipsisLoc), RParenLoc(RParenLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0), Opcode(Opcode) {\n    SubExprs[SubExpr::Callee] = Callee;\n    SubExprs[SubExpr::LHS] = LHS;\n    SubExprs[SubExpr::RHS] = RHS;\n    setDependence(computeDependence(this));\n  }\n\n  CXXFoldExpr(EmptyShell Empty) : Expr(CXXFoldExprClass, Empty) {}\n\n  UnresolvedLookupExpr *getCallee() const {\n    return static_cast<UnresolvedLookupExpr *>(SubExprs[SubExpr::Callee]);\n  }\n  Expr *getLHS() const { return static_cast<Expr*>(SubExprs[SubExpr::LHS]); }\n  Expr *getRHS() const { return static_cast<Expr*>(SubExprs[SubExpr::RHS]); }\n\n  /// Does this produce a right-associated sequence of operators?\n  bool isRightFold() const {\n    return getLHS() && getLHS()->containsUnexpandedParameterPack();\n  }\n\n  /// Does this produce a left-associated sequence of operators?\n  bool isLeftFold() const { return !isRightFold(); }\n\n  /// Get the pattern, that is, the operand that contains an unexpanded pack.\n  Expr *getPattern() const { return isLeftFold() ? getRHS() : getLHS(); }\n\n  /// Get the operand that doesn't contain a pack, for a binary fold.\n  Expr *getInit() const { return isLeftFold() ? getLHS() : getRHS(); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  BinaryOperatorKind getOperator() const { return Opcode; }\n\n  std::optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n    return std::nullopt;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (LParenLoc.isValid())\n      return LParenLoc;\n    if (isLeftFold())\n      return getEllipsisLoc();\n    return getLHS()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (RParenLoc.isValid())\n      return RParenLoc;\n    if (isRightFold())\n      return getEllipsisLoc();\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFoldExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n};\n\n/// Represents a list-initialization with parenthesis.\n///\n/// As per P0960R3, this is a C++20 feature that allows aggregate to\n/// be initialized with a parenthesized list of values:\n/// ```\n/// struct A {\n///   int a;\n///   double b;\n/// };\n///\n/// void foo() {\n///   A a1(0);        // Well-formed in C++20\n///   A a2(1.5, 1.0); // Well-formed in C++20\n/// }\n/// ```\n/// It has some sort of similiarity to braced\n/// list-initialization, with some differences such as\n/// it allows narrowing conversion whilst braced\n/// list-initialization doesn't.\n/// ```\n/// struct A {\n///   char a;\n/// };\n/// void foo() {\n///   A a(1.5); // Well-formed in C++20\n///   A b{1.5}; // Ill-formed !\n/// }\n/// ```\nclass CXXParenListInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXParenListInitExpr, Expr *> {\n  friend class TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  unsigned NumExprs;\n  unsigned NumUserSpecifiedExprs;\n  SourceLocation InitLoc, LParenLoc, RParenLoc;\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\n  CXXParenListInitExpr(ArrayRef<Expr *> Args, QualType T,\n                       unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n                       SourceLocation LParenLoc, SourceLocation RParenLoc)\n      : Expr(CXXParenListInitExprClass, T, getValueKindForType(T), OK_Ordinary),\n        NumExprs(Args.size()), NumUserSpecifiedExprs(NumUserSpecifiedExprs),\n        InitLoc(InitLoc), LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    std::copy(Args.begin(), Args.end(), getTrailingObjects<Expr *>());\n    assert(NumExprs >= NumUserSpecifiedExprs &&\n           \"number of user specified inits is greater than the number of \"\n           \"passed inits\");\n    setDependence(computeDependence(this));\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const { return NumExprs; }\n\npublic:\n  static CXXParenListInitExpr *\n  Create(ASTContext &C, ArrayRef<Expr *> Args, QualType T,\n         unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n         SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  static CXXParenListInitExpr *CreateEmpty(ASTContext &C, unsigned numExprs,\n                                           EmptyShell Empty);\n\n  explicit CXXParenListInitExpr(EmptyShell Empty, unsigned NumExprs)\n      : Expr(CXXParenListInitExprClass, Empty), NumExprs(NumExprs),\n        NumUserSpecifiedExprs(0) {}\n\n  void updateDependence() { setDependence(computeDependence(this)); }\n\n  ArrayRef<Expr *> getInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  const ArrayRef<Expr *> getInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  ArrayRef<Expr *> getUserSpecifiedInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  const ArrayRef<Expr *> getUserSpecifiedInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getInitLoc() const LLVM_READONLY { return InitLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  void setArrayFiller(Expr *E) { ArrayFillerOrUnionFieldInit = E; }\n\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  const Expr *getArrayFiller() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumExprs);\n  }\n\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumExprs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXParenListInitExprClass;\n  }\n};\n\n/// Represents an expression that might suspend coroutine execution;\n/// either a co_await or co_yield expression.\n///\n/// Evaluation of this expression first evaluates its 'ready' expression. If\n/// that returns 'false':\n///  -- execution of the coroutine is suspended\n///  -- the 'suspend' expression is evaluated\n///     -- if the 'suspend' expression returns 'false', the coroutine is\n///        resumed\n///     -- otherwise, control passes back to the resumer.\n/// If the coroutine is not suspended, or when it is resumed, the 'resume'\n/// expression is evaluated, and its result is the result of the overall\n/// expression.\nclass CoroutineSuspendExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n\n  enum SubExpr { Operand, Common, Ready, Suspend, Resume, Count };\n\n  Stmt *SubExprs[SubExpr::Count];\n  OpaqueValueExpr *OpaqueValue = nullptr;\n\npublic:\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, Expr *Operand,\n                       Expr *Common, Expr *Ready, Expr *Suspend, Expr *Resume,\n                       OpaqueValueExpr *OpaqueValue)\n      : Expr(SC, Resume->getType(), Resume->getValueKind(),\n             Resume->getObjectKind()),\n        KeywordLoc(KeywordLoc), OpaqueValue(OpaqueValue) {\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = Ready;\n    SubExprs[SubExpr::Suspend] = Suspend;\n    SubExprs[SubExpr::Resume] = Resume;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, QualType Ty,\n                       Expr *Operand, Expr *Common)\n      : Expr(SC, Ty, VK_PRValue, OK_Ordinary), KeywordLoc(KeywordLoc) {\n    assert(Common->isTypeDependent() && Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    SubExprs[SubExpr::Operand] = nullptr;\n    SubExprs[SubExpr::Common] = nullptr;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n  }\n\n  Expr *getCommonExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Common]);\n  }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  Expr *getReadyExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Ready]);\n  }\n\n  Expr *getSuspendExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Suspend]);\n  }\n\n  Expr *getResumeExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Resume]);\n  }\n\n  // The syntactic operand written in the code\n  Expr *getOperand() const {\n    return static_cast<Expr *>(SubExprs[SubExpr::Operand]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass ||\n           T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression.\nclass CoawaitExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoawaitExpr(SourceLocation CoawaitLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(SourceLocation CoawaitLoc, QualType Ty, Expr *Operand,\n              Expr *Common, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Ty, Operand,\n                             Common) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoawaitExprClass, Empty) {}\n\n  bool isImplicit() const { return CoawaitBits.IsImplicit; }\n  void setIsImplicit(bool value = true) { CoawaitBits.IsImplicit = value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression while the type of the promise\n/// is dependent.\nclass DependentCoawaitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n  Stmt *SubExprs[2];\n\npublic:\n  DependentCoawaitExpr(SourceLocation KeywordLoc, QualType Ty, Expr *Op,\n                       UnresolvedLookupExpr *OpCoawait)\n      : Expr(DependentCoawaitExprClass, Ty, VK_PRValue, OK_Ordinary),\n        KeywordLoc(KeywordLoc) {\n    // NOTE: A co_await expression is dependent on the coroutines promise\n    // type and may be dependent even when the `Op` expression is not.\n    assert(Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[0] = Op;\n    SubExprs[1] = OpCoawait;\n    setDependence(computeDependence(this));\n  }\n\n  DependentCoawaitExpr(EmptyShell Empty)\n      : Expr(DependentCoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const { return cast<Expr>(SubExprs[0]); }\n\n  UnresolvedLookupExpr *getOperatorCoawaitLookup() const {\n    return cast<UnresolvedLookupExpr>(SubExprs[1]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() { return child_range(SubExprs, SubExprs + 2); }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentCoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_yield' expression.\nclass CoyieldExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoyieldExpr(SourceLocation CoyieldLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {}\n  CoyieldExpr(SourceLocation CoyieldLoc, QualType Ty, Expr *Operand,\n              Expr *Common)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Ty, Operand,\n                             Common) {}\n  CoyieldExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoyieldExprClass, Empty) {}\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a C++2a __builtin_bit_cast(T, v) expression. Used to implement\n/// std::bit_cast. These can sometimes be evaluated as part of a constant\n/// expression, but otherwise CodeGen to a simple memcpy in general.\nclass BuiltinBitCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<BuiltinBitCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation KWLoc;\n  SourceLocation RParenLoc;\n\npublic:\n  BuiltinBitCastExpr(QualType T, ExprValueKind VK, CastKind CK, Expr *SrcExpr,\n                     TypeSourceInfo *DstType, SourceLocation KWLoc,\n                     SourceLocation RParenLoc)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, T, VK, CK, SrcExpr, 0, false,\n                         DstType),\n        KWLoc(KWLoc), RParenLoc(RParenLoc) {}\n  BuiltinBitCastExpr(EmptyShell Empty)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, Empty, 0, false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KWLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BuiltinBitCastExprClass;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-10812",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 4485,
  "validation_status": "validated"
}