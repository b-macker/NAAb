{
  "code": "{\npublic:\n  using ValArray = SimpleArray<SExpr *>;\n\n  // In minimal SSA form, all Phi nodes are MultiVal.\n  // During conversion to SSA, incomplete Phi nodes may be introduced, which\n  // are later determined to be SingleVal, and are thus redundant.\n  enum Status {\n    PH_MultiVal = 0, // Phi node has multiple distinct values.  (Normal)\n    PH_SingleVal,    // Phi node has one distinct value, and can be eliminated\n    PH_Incomplete    // Phi node is incomplete\n  };\n\n  Phi() : SExpr(COP_Phi) {}\n  Phi(MemRegionRef A, unsigned Nvals) : SExpr(COP_Phi), Values(A, Nvals)  {}\n  Phi(const Phi &P, ValArray &&Vs) : SExpr(P), Values(std::move(Vs)) {}\n\n  static bool classof(const SExpr *E) { return E->opcode() == COP_Phi; }\n\n  const ValArray &values() const { return Values; }\n  ValArray &values() { return Values; }\n\n  Status status() const { return static_cast<Status>(Flags); }\n  void setStatus(Status s) { Flags = s; }\n\n  /// Return the clang declaration of the variable for this Phi node, if any.\n  const ValueDecl *clangDecl() const { return Cvdecl; }\n\n  /// Set the clang variable associated with this Phi node.\n  void setClangDecl(const ValueDecl *Cvd) { Cvdecl = Cvd; }\n\n  template <class V>\n  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {\n    typename V::template Container<typename V::R_SExpr>\n      Nvs(Vs, Values.size());\n\n    for (const auto *Val : Values)\n      Nvs.push_back( Vs.traverse(Val, Vs.subExprCtx(Ctx)) );\n    return Vs.reducePhi(*this, Nvs);\n  }\n\n  template <class C>\n  typename C::CType compare(const Phi *E, C &Cmp) const {\n    // TODO: implement CFG comparisons\n    return Cmp.comparePointers(this, E);\n  }\n\nprivate:\n  ValArray Values;\n  const ValueDecl* Cvdecl = nullptr;\n}",
  "id": "BLOCK-CPP-21669",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h",
  "source_line": 1302,
  "validation_status": "validated"
}