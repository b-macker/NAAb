{
  "code": "{\npublic:\n  CFGWalker() = default;\n\n  // Initialize the CFGWalker.  This setup only needs to be done once, even\n  // if there are multiple passes over the CFG.\n  bool init(AnalysisDeclContext &AC) {\n    ACtx = &AC;\n    CFGraph = AC.getCFG();\n    if (!CFGraph)\n      return false;\n\n    // Ignore anonymous functions.\n    if (!isa_and_nonnull<NamedDecl>(AC.getDecl()))\n      return false;\n\n    SortedGraph = AC.getAnalysis<PostOrderCFGView>();\n    if (!SortedGraph)\n      return false;\n\n    return true;\n  }\n\n  // Traverse the CFG, calling methods on V as appropriate.\n  template <class Visitor>\n  void walk(Visitor &V) {\n    PostOrderCFGView::CFGBlockSet VisitedBlocks(CFGraph);\n\n    V.enterCFG(CFGraph, getDecl(), &CFGraph->getEntry());\n\n    for (const auto *CurrBlock : *SortedGraph) {\n      VisitedBlocks.insert(CurrBlock);\n\n      V.enterCFGBlock(CurrBlock);\n\n      // Process predecessors, handling back edges last\n      if (V.visitPredecessors()) {\n        SmallVector<CFGBlock*, 4> BackEdges;\n        // Process successors\n        for (CFGBlock::const_pred_iterator SI = CurrBlock->pred_begin(),\n                                           SE = CurrBlock->pred_end();\n             SI != SE; ++SI) {\n          if (*SI == nullptr)\n            continue;\n\n          if (!VisitedBlocks.alreadySet(*SI)) {\n            BackEdges.push_back(*SI);\n            continue;\n          }\n          V.handlePredecessor(*SI);\n        }\n\n        for (auto *Blk : BackEdges)\n          V.handlePredecessorBackEdge(Blk);\n      }\n\n      V.enterCFGBlockBody(CurrBlock);\n\n      // Process statements\n      for (const auto &BI : *CurrBlock) {\n        switch (BI.getKind()) {\n        case CFGElement::Statement:\n          V.handleStatement(BI.castAs<CFGStmt>().getStmt());\n          break;\n\n        case CFGElement::AutomaticObjectDtor: {\n          CFGAutomaticObjDtor AD = BI.castAs<CFGAutomaticObjDtor>();\n          auto *DD = const_cast<CXXDestructorDecl *>(\n              AD.getDestructorDecl(ACtx->getASTContext()));\n          auto *VD = const_cast<VarDecl *>(AD.getVarDecl());\n          V.handleDestructorCall(VD, DD);\n          break;\n        }\n        default:\n          break;\n        }\n      }\n\n      V.exitCFGBlockBody(CurrBlock);\n\n      // Process successors, handling back edges first.\n      if (V.visitSuccessors()) {\n        SmallVector<CFGBlock*, 8> ForwardEdges;\n\n        // Process successors\n        for (CFGBlock::const_succ_iterator SI = CurrBlock->succ_begin(),\n                                           SE = CurrBlock->succ_end();\n             SI != SE; ++SI) {\n          if (*SI == nullptr)\n            continue;\n\n          if (!VisitedBlocks.alreadySet(*SI)) {\n            ForwardEdges.push_back(*SI);\n            continue;\n          }\n          V.handleSuccessorBackEdge(*SI);\n        }\n\n        for (auto *Blk : ForwardEdges)\n          V.handleSuccessor(Blk);\n      }\n\n      V.exitCFGBlock(CurrBlock);\n    }\n    V.exitCFG(&CFGraph->getExit());\n  }\n\n  const CFG *getGraph() const { return CFGraph; }\n  CFG *getGraph() { return CFGraph; }\n\n  const NamedDecl *getDecl() const {\n    return dyn_cast<NamedDecl>(ACtx->getDecl());\n  }\n\n  const PostOrderCFGView *getSortedGraph() const { return SortedGraph; }\n\nprivate:\n  CFG *CFGraph = nullptr;\n  AnalysisDeclContext *ACtx = nullptr;\n  PostOrderCFGView *SortedGraph = nullptr;\n}",
  "id": "BLOCK-CPP-21458",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h",
  "source_line": 147,
  "validation_status": "validated"
}