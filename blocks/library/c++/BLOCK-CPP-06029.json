{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\ntemplate <typename T>\nclass ABSL_MUST_USE_RESULT StatusOr;\n\nnamespace internal_statusor {\n\n// Detects whether `U` has conversion operator to `StatusOr<T>`, i.e. `operator\n// StatusOr<T>()`.\ntemplate <typename T, typename U, typename = void>\nstruct HasConversionOperatorToStatusOr : std::false_type {};\n\ntemplate <typename T, typename U>\nvoid test(char (*)[sizeof(std::declval<U>().operator absl::StatusOr<T>())]);\n\ntemplate <typename T, typename U>\nstruct HasConversionOperatorToStatusOr<T, U, decltype(test<T, U>(0))>\n    : std::true_type {};\n\n// Detects whether `T` is constructible or convertible from `StatusOr<U>`.\ntemplate <typename T, typename U>\nusing IsConstructibleOrConvertibleFromStatusOr =\n    absl::disjunction<std::is_constructible<T, StatusOr<U>&>,\n                      std::is_constructible<T, const StatusOr<U>&>,\n                      std::is_constructible<T, StatusOr<U>&&>,\n                      std::is_constructible<T, const StatusOr<U>&&>,\n                      std::is_convertible<StatusOr<U>&, T>,\n                      std::is_convertible<const StatusOr<U>&, T>,\n                      std::is_convertible<StatusOr<U>&&, T>,\n                      std::is_convertible<const StatusOr<U>&&, T>>;\n\n// Detects whether `T` is constructible or convertible or assignable from\n// `StatusOr<U>`.\ntemplate <typename T, typename U>\nusing IsConstructibleOrConvertibleOrAssignableFromStatusOr =\n    absl::disjunction<IsConstructibleOrConvertibleFromStatusOr<T, U>,\n                      std::is_assignable<T&, StatusOr<U>&>,\n                      std::is_assignable<T&, const StatusOr<U>&>,\n                      std::is_assignable<T&, StatusOr<U>&&>,\n                      std::is_assignable<T&, const StatusOr<U>&&>>;\n\n// Detects whether direct initializing `StatusOr<T>` from `U` is ambiguous, i.e.\n// when `U` is `StatusOr<V>` and `T` is constructible or convertible from `V`.\ntemplate <typename T, typename U>\nstruct IsDirectInitializationAmbiguous\n    : public absl::conditional_t<\n          std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,\n          IsDirectInitializationAmbiguous<T, absl::remove_cvref_t<U>>> {};\n\ntemplate <typename T, typename V>\nstruct IsDirectInitializationAmbiguous<T, absl::StatusOr<V>>\n    : public IsConstructibleOrConvertibleFromStatusOr<T, V> {};\n\n// Checks against the constraints of the direction initialization, i.e. when\n// `StatusOr<T>::StatusOr(U&&)` should participate in overload resolution.\ntemplate <typename T, typename U>\nusing IsDirectInitializationValid = absl::disjunction<\n    // Short circuits if T is basically U.\n    std::is_same<T, absl::remove_cvref_t<U>>,\n    absl::negation<absl::disjunction<\n        std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,\n        std::is_same<absl::Status, absl::remove_cvref_t<U>>,\n        std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,\n        IsDirectInitializationAmbiguous<T, U>>>>;\n\n// This trait detects whether `StatusOr<T>::operator=(U&&)` is ambiguous, which\n// is equivalent to whether all the following conditions are met:\n// 1. `U` is `StatusOr<V>`.\n// 2. `T` is constructible and assignable from `V`.\n// 3. `T` is constructible and assignable from `U` (i.e. `StatusOr<V>`).\n// For example, the following code is considered ambiguous:\n// (`T` is `bool`, `U` is `StatusOr<bool>`, `V` is `bool`)\n//   StatusOr<bool> s1 = true;  // s1.ok() && s1.ValueOrDie() == true\n//   StatusOr<bool> s2 = false;  // s2.ok() && s2.ValueOrDie() == false\n//   s1 = s2;  // ambiguous, `s1 = s2.ValueOrDie()` or `s1 = bool(s2)`?\ntemplate <typename T, typename U>\nstruct IsForwardingAssignmentAmbiguous\n    : public absl::conditional_t<\n          std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,\n          IsForwardingAssignmentAmbiguous<T, absl::remove_cvref_t<U>>> {};\n\ntemplate <typename T, typename U>\nstruct IsForwardingAssignmentAmbiguous<T, absl::StatusOr<U>>\n    : public IsConstructibleOrConvertibleOrAssignableFromStatusOr<T, U> {};\n\n// Checks against the constraints of the forwarding assignment, i.e. whether\n// `StatusOr<T>::operator(U&&)` should participate in overload resolution.\ntemplate <typename T, typename U>\nusing IsForwardingAssignmentValid = absl::disjunction<\n    // Short circuits if T is basically U.\n    std::is_same<T, absl::remove_cvref_t<U>>,\n    absl::negation<absl::disjunction<\n        std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,\n        std::is_same<absl::Status, absl::remove_cvref_t<U>>,\n        std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,\n        IsForwardingAssignmentAmbiguous<T, U>>>>;\n\nclass Helper {\n public:\n  // Move type-agnostic error handling to the .cc.\n  static void HandleInvalidStatusCtorArg(absl::Nonnull<Status*>);\n  ABSL_ATTRIBUTE_NORETURN static void Crash(const absl::Status& status);\n};\n\n// Construct an instance of T in `p` through placement new, passing Args... to\n// the constructor.\n// This abstraction is here mostly for the gcc performance fix.\ntemplate <typename T, typename... Args>\nABSL_ATTRIBUTE_NONNULL(1)\nvoid PlacementNew(absl::Nonnull<void*> p, Args&&... args) {\n  new (p) T(std::forward<Args>(args)...);\n}\n\n// Helper base class to hold the data and all operations.\n// We move all this to a base class to allow mixing with the appropriate\n// TraitsBase specialization.\ntemplate <typename T>\nclass StatusOrData {\n  template <typename U>\n  friend class StatusOrData;\n\n public:\n  StatusOrData() = delete;\n\n  StatusOrData(const StatusOrData& other) {\n    if (other.ok()) {\n      MakeValue(other.data_);\n      MakeStatus();\n    } else {\n      MakeStatus(other.status_);\n    }\n  }\n\n  StatusOrData(StatusOrData&& other) noexcept {\n    if (other.ok()) {\n      MakeValue(std::move(other.data_));\n      MakeStatus();\n    } else {\n      MakeStatus(std::move(other.status_));\n    }\n  }\n\n  template <typename U>\n  explicit StatusOrData(const StatusOrData<U>& other) {\n    if (other.ok()) {\n      MakeValue(other.data_);\n      MakeStatus();\n    } else {\n      MakeStatus(other.status_);\n    }\n  }\n\n  template <typename U>\n  explicit StatusOrData(StatusOrData<U>&& other) {\n    if (other.ok()) {\n      MakeValue(std::move(other.data_));\n      MakeStatus();\n    } else {\n      MakeStatus(std::move(other.status_));\n    }\n  }\n\n  template <typename... Args>\n  explicit StatusOrData(absl::in_place_t, Args&&... args)\n      : data_(std::forward<Args>(args)...) {\n    MakeStatus();\n  }\n\n  explicit StatusOrData(const T& value) : data_(value) {\n    MakeStatus();\n  }\n  explicit StatusOrData(T&& value) : data_(std::move(value)) {\n    MakeStatus();\n  }\n\n  template <typename U,\n            absl::enable_if_t<std::is_constructible<absl::Status, U&&>::value,\n                              int> = 0>\n  explicit StatusOrData(U&& v) : status_(std::forward<U>(v)) {\n    EnsureNotOk();\n  }\n\n  StatusOrData& operator=(const StatusOrData& other) {\n    if (this == &other) return *this;\n    if (other.ok())\n      Assign(other.data_);\n    else\n      AssignStatus(other.status_);\n    return *this;\n  }\n\n  StatusOrData& operator=(StatusOrData&& other) {\n    if (this == &other) return *this;\n    if (other.ok())\n      Assign(std::move(other.data_));\n    else\n      AssignStatus(std::move(other.status_));\n    return *this;\n  }\n\n  ~StatusOrData() {\n    if (ok()) {\n      status_.~Status();\n      data_.~T();\n    } else {\n      status_.~Status();\n    }\n  }\n\n  template <typename U>\n  void Assign(U&& value) {\n    if (ok()) {\n      data_ = std::forward<U>(value);\n    } else {\n      MakeValue(std::forward<U>(value));\n      status_ = OkStatus();\n    }\n  }\n\n  template <typename U>\n  void AssignStatus(U&& v) {\n    Clear();\n    status_ = static_cast<absl::Status>(std::forward<U>(v));\n    EnsureNotOk();\n  }\n\n  bool ok() const { return status_.ok(); }\n\n protected:\n  // status_ will always be active after the constructor.\n  // We make it a union to be able to initialize exactly how we need without\n  // waste.\n  // Eg. in the copy constructor we use the default constructor of Status in\n  // the ok() path to avoid an extra Ref call.\n  union {\n    Status status_;\n  };\n\n  // data_ is active iff status_.ok()==true\n  struct Dummy {};\n  union {\n    // When T is const, we need some non-const object we can cast to void* for\n    // the placement new. dummy_ is that object.\n    Dummy dummy_;\n    T data_;\n  };\n\n  void Clear() {\n    if (ok()) data_.~T();\n  }\n\n  void EnsureOk() const {\n    if (ABSL_PREDICT_FALSE(!ok())) Helper::Crash(status_);\n  }\n\n  void EnsureNotOk() {\n    if (ABSL_PREDICT_FALSE(ok())) Helper::HandleInvalidStatusCtorArg(&status_);\n  }\n\n  // Construct the value (ie. data_) through placement new with the passed\n  // argument.\n  template <typename... Arg>\n  void MakeValue(Arg&&... arg) {\n    internal_statusor::PlacementNew<T>(&dummy_, std::forward<Arg>(arg)...);\n  }\n\n  // Construct the status (ie. status_) through placement new with the passed\n  // argument.\n  template <typename... Args>\n  void MakeStatus(Args&&... args) {\n    internal_statusor::PlacementNew<Status>(&status_,\n                                            std::forward<Args>(args)...);\n  }\n};\n\n// Helper base classes to allow implicitly deleted constructors and assignment\n// operators in `StatusOr`. For example, `CopyCtorBase` will explicitly delete\n// the copy constructor when T is not copy constructible and `StatusOr` will\n// inherit that behavior implicitly.\ntemplate <typename T, bool = std::is_copy_constructible<T>::value>\nstruct CopyCtorBase {\n  CopyCtorBase() = default;\n  CopyCtorBase(const CopyCtorBase&) = default;\n  CopyCtorBase(CopyCtorBase&&) = default;\n  CopyCtorBase& operator=(const CopyCtorBase&) = default;\n  CopyCtorBase& operator=(CopyCtorBase&&) = default;\n};\n\ntemplate <typename T>\nstruct CopyCtorBase<T, false> {\n  CopyCtorBase() = default;\n  CopyCtorBase(const CopyCtorBase&) = delete;\n  CopyCtorBase(CopyCtorBase&&) = default;\n  CopyCtorBase& operator=(const CopyCtorBase&) = default;\n  CopyCtorBase& operator=(CopyCtorBase&&) = default;\n};\n\ntemplate <typename T, bool = std::is_move_constructible<T>::value>\nstruct MoveCtorBase {\n  MoveCtorBase() = default;\n  MoveCtorBase(const MoveCtorBase&) = default;\n  MoveCtorBase(MoveCtorBase&&) = default;\n  MoveCtorBase& operator=(const MoveCtorBase&) = default;\n  MoveCtorBase& operator=(MoveCtorBase&&) = default;\n};\n\ntemplate <typename T>\nstruct MoveCtorBase<T, false> {\n  MoveCtorBase() = default;\n  MoveCtorBase(const MoveCtorBase&) = default;\n  MoveCtorBase(MoveCtorBase&&) = delete;\n  MoveCtorBase& operator=(const MoveCtorBase&) = default;\n  MoveCtorBase& operator=(MoveCtorBase&&) = default;\n};\n\ntemplate <typename T, bool = std::is_copy_constructible<T>::value&&\n                          std::is_copy_assignable<T>::value>\nstruct CopyAssignBase {\n  CopyAssignBase() = default;\n  CopyAssignBase(const CopyAssignBase&) = default;\n  CopyAssignBase(CopyAssignBase&&) = default;\n  CopyAssignBase& operator=(const CopyAssignBase&) = default;\n  CopyAssignBase& operator=(CopyAssignBase&&) = default;\n};\n\ntemplate <typename T>\nstruct CopyAssignBase<T, false> {\n  CopyAssignBase() = default;\n  CopyAssignBase(const CopyAssignBase&) = default;\n  CopyAssignBase(CopyAssignBase&&) = default;\n  CopyAssignBase& operator=(const CopyAssignBase&) = delete;\n  CopyAssignBase& operator=(CopyAssignBase&&) = default;\n};\n\ntemplate <typename T, bool = std::is_move_constructible<T>::value&&\n                          std::is_move_assignable<T>::value>\nstruct MoveAssignBase {\n  MoveAssignBase() = default;\n  MoveAssignBase(const MoveAssignBase&) = default;\n  MoveAssignBase(MoveAssignBase&&) = default;\n  MoveAssignBase& operator=(const MoveAssignBase&) = default;\n  MoveAssignBase& operator=(MoveAssignBase&&) = default;\n};\n\ntemplate <typename T>\nstruct MoveAssignBase<T, false> {\n  MoveAssignBase() = default;\n  MoveAssignBase(const MoveAssignBase&) = default;\n  MoveAssignBase(MoveAssignBase&&) = default;\n  MoveAssignBase& operator=(const MoveAssignBase&) = default;\n  MoveAssignBase& operator=(MoveAssignBase&&) = delete;\n};\n\nABSL_ATTRIBUTE_NORETURN void ThrowBadStatusOrAccess(absl::Status status);\n\n// Used to introduce jitter into the output of printing functions for\n// `StatusOr` (i.e. `AbslStringify` and `operator<<`).\nclass StringifyRandom {\n  enum BracesType {\n    kBareParens = 0,\n    kSpaceParens,\n    kBareBrackets,\n    kSpaceBrackets,\n  };\n\n  // Returns a random `BracesType` determined once per binary load.\n  static BracesType RandomBraces() {\n    static const BracesType kRandomBraces = static_cast<BracesType>(\n        (reinterpret_cast<uintptr_t>(&kRandomBraces) >> 4) % 4);\n    return kRandomBraces;\n  }\n\n public:\n  static inline absl::string_view OpenBrackets() {\n    switch (RandomBraces()) {\n      case kBareParens:\n        return \"(\";\n      case kSpaceParens:\n        return \"( \";\n      case kBareBrackets:\n        return \"[\";\n      case kSpaceBrackets:\n        return \"[ \";\n    }\n    return \"(\";\n  }\n\n  static inline absl::string_view CloseBrackets() {\n    switch (RandomBraces()) {\n      case kBareParens:\n        return \")\";\n      case kSpaceParens:\n        return \" )\";\n      case kBareBrackets:\n        return \"]\";\n      case kSpaceBrackets:\n        return \" ]\";\n    }\n    return \")\";\n  }\n};\n\n}  // namespace internal_statusor\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06029",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/internal/statusor_internal.h",
  "source_line": 28,
  "validation_status": "validated"
}