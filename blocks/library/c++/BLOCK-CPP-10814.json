{
  "code": "{\n///   char a;\n/// };\n/// void foo() {\n///   A a(1.5); // Well-formed in C++20\n///   A b{1.5}; // Ill-formed !\n/// }\n/// ```\nclass CXXParenListInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXParenListInitExpr, Expr *> {\n  friend class TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  unsigned NumExprs;\n  unsigned NumUserSpecifiedExprs;\n  SourceLocation InitLoc, LParenLoc, RParenLoc;\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\n  CXXParenListInitExpr(ArrayRef<Expr *> Args, QualType T,\n                       unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n                       SourceLocation LParenLoc, SourceLocation RParenLoc)\n      : Expr(CXXParenListInitExprClass, T, getValueKindForType(T), OK_Ordinary),\n        NumExprs(Args.size()), NumUserSpecifiedExprs(NumUserSpecifiedExprs),\n        InitLoc(InitLoc), LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    std::copy(Args.begin(), Args.end(), getTrailingObjects<Expr *>());\n    assert(NumExprs >= NumUserSpecifiedExprs &&\n           \"number of user specified inits is greater than the number of \"\n           \"passed inits\");\n    setDependence(computeDependence(this));\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const { return NumExprs; }\n\npublic:\n  static CXXParenListInitExpr *\n  Create(ASTContext &C, ArrayRef<Expr *> Args, QualType T,\n         unsigned NumUserSpecifiedExprs, SourceLocation InitLoc,\n         SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  static CXXParenListInitExpr *CreateEmpty(ASTContext &C, unsigned numExprs,\n                                           EmptyShell Empty);\n\n  explicit CXXParenListInitExpr(EmptyShell Empty, unsigned NumExprs)\n      : Expr(CXXParenListInitExprClass, Empty), NumExprs(NumExprs),\n        NumUserSpecifiedExprs(0) {}\n\n  void updateDependence() { setDependence(computeDependence(this)); }\n\n  ArrayRef<Expr *> getInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  const ArrayRef<Expr *> getInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumExprs);\n  }\n\n  ArrayRef<Expr *> getUserSpecifiedInitExprs() {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  const ArrayRef<Expr *> getUserSpecifiedInitExprs() const {\n    return ArrayRef(getTrailingObjects<Expr *>(), NumUserSpecifiedExprs);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getInitLoc() const LLVM_READONLY { return InitLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  void setArrayFiller(Expr *E) { ArrayFillerOrUnionFieldInit = E; }\n\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  const Expr *getArrayFiller() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumExprs);\n  }\n\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumExprs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXParenListInitExprClass;\n  }\n};\n\n/// Represents an expression that might suspend coroutine execution;\n/// either a co_await or co_yield expression.\n///\n/// Evaluation of this expression first evaluates its 'ready' expression. If\n/// that returns 'false':\n///  -- execution of the coroutine is suspended\n///  -- the 'suspend' expression is evaluated\n///     -- if the 'suspend' expression returns 'false', the coroutine is\n///        resumed\n///     -- otherwise, control passes back to the resumer.\n/// If the coroutine is not suspended, or when it is resumed, the 'resume'\n/// expression is evaluated, and its result is the result of the overall\n/// expression.\nclass CoroutineSuspendExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n\n  enum SubExpr { Operand, Common, Ready, Suspend, Resume, Count };\n\n  Stmt *SubExprs[SubExpr::Count];\n  OpaqueValueExpr *OpaqueValue = nullptr;\n\npublic:\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, Expr *Operand,\n                       Expr *Common, Expr *Ready, Expr *Suspend, Expr *Resume,\n                       OpaqueValueExpr *OpaqueValue)\n      : Expr(SC, Resume->getType(), Resume->getValueKind(),\n             Resume->getObjectKind()),\n        KeywordLoc(KeywordLoc), OpaqueValue(OpaqueValue) {\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = Ready;\n    SubExprs[SubExpr::Suspend] = Suspend;\n    SubExprs[SubExpr::Resume] = Resume;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, QualType Ty,\n                       Expr *Operand, Expr *Common)\n      : Expr(SC, Ty, VK_PRValue, OK_Ordinary), KeywordLoc(KeywordLoc) {\n    assert(Common->isTypeDependent() && Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[SubExpr::Operand] = Operand;\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    SubExprs[SubExpr::Operand] = nullptr;\n    SubExprs[SubExpr::Common] = nullptr;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n  }\n\n  Expr *getCommonExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Common]);\n  }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  Expr *getReadyExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Ready]);\n  }\n\n  Expr *getSuspendExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Suspend]);\n  }\n\n  Expr *getResumeExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Resume]);\n  }\n\n  // The syntactic operand written in the code\n  Expr *getOperand() const {\n    return static_cast<Expr *>(SubExprs[SubExpr::Operand]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass ||\n           T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression.\nclass CoawaitExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoawaitExpr(SourceLocation CoawaitLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(SourceLocation CoawaitLoc, QualType Ty, Expr *Operand,\n              Expr *Common, bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Ty, Operand,\n                             Common) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoawaitExprClass, Empty) {}\n\n  bool isImplicit() const { return CoawaitBits.IsImplicit; }\n  void setIsImplicit(bool value = true) { CoawaitBits.IsImplicit = value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression while the type of the promise\n/// is dependent.\nclass DependentCoawaitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n  Stmt *SubExprs[2];\n\npublic:\n  DependentCoawaitExpr(SourceLocation KeywordLoc, QualType Ty, Expr *Op,\n                       UnresolvedLookupExpr *OpCoawait)\n      : Expr(DependentCoawaitExprClass, Ty, VK_PRValue, OK_Ordinary),\n        KeywordLoc(KeywordLoc) {\n    // NOTE: A co_await expression is dependent on the coroutines promise\n    // type and may be dependent even when the `Op` expression is not.\n    assert(Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[0] = Op;\n    SubExprs[1] = OpCoawait;\n    setDependence(computeDependence(this));\n  }\n\n  DependentCoawaitExpr(EmptyShell Empty)\n      : Expr(DependentCoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const { return cast<Expr>(SubExprs[0]); }\n\n  UnresolvedLookupExpr *getOperatorCoawaitLookup() const {\n    return cast<UnresolvedLookupExpr>(SubExprs[1]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() { return child_range(SubExprs, SubExprs + 2); }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentCoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_yield' expression.\nclass CoyieldExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoyieldExpr(SourceLocation CoyieldLoc, Expr *Operand, Expr *Common,\n              Expr *Ready, Expr *Suspend, Expr *Resume,\n              OpaqueValueExpr *OpaqueValue)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Operand, Common,\n                             Ready, Suspend, Resume, OpaqueValue) {}\n  CoyieldExpr(SourceLocation CoyieldLoc, QualType Ty, Expr *Operand,\n              Expr *Common)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Ty, Operand,\n                             Common) {}\n  CoyieldExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoyieldExprClass, Empty) {}\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a C++2a __builtin_bit_cast(T, v) expression. Used to implement\n/// std::bit_cast. These can sometimes be evaluated as part of a constant\n/// expression, but otherwise CodeGen to a simple memcpy in general.\nclass BuiltinBitCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<BuiltinBitCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation KWLoc;\n  SourceLocation RParenLoc;\n\npublic:\n  BuiltinBitCastExpr(QualType T, ExprValueKind VK, CastKind CK, Expr *SrcExpr,\n                     TypeSourceInfo *DstType, SourceLocation KWLoc,\n                     SourceLocation RParenLoc)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, T, VK, CK, SrcExpr, 0, false,\n                         DstType),\n        KWLoc(KWLoc), RParenLoc(RParenLoc) {}\n  BuiltinBitCastExpr(EmptyShell Empty)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, Empty, 0, false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KWLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BuiltinBitCastExprClass;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-10814",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 4796,
  "validation_status": "validated"
}