{
  "code": "{\n\n/// Determines the object kind of a tracked object.\nenum class ObjKind {\n  /// Indicates that the tracked object is a CF object.\n  CF,\n\n  /// Indicates that the tracked object is an Objective-C object.\n  ObjC,\n\n  /// Indicates that the tracked object could be a CF or Objective-C object.\n  AnyObj,\n\n  /// Indicates that the tracked object is a generalized object.\n  Generalized,\n\n  /// Indicates that the tracking object is a descendant of a\n  /// referenced-counted OSObject, used in the Darwin kernel.\n  OS\n};\n\nenum ArgEffectKind {\n  /// There is no effect.\n  DoNothing,\n\n  /// The argument is treated as if an -autorelease message had been sent to\n  /// the referenced object.\n  Autorelease,\n\n  /// The argument is treated as if the referenced object was deallocated.\n  Dealloc,\n\n  /// The argument has its reference count decreased by 1.\n  DecRef,\n\n  /// The argument has its reference count decreased by 1 to model\n  /// a transferred bridge cast under ARC.\n  DecRefBridgedTransferred,\n\n  /// The argument has its reference count increased by 1.\n  IncRef,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +0 value.\n  UnretainedOutParameter,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value.\n  RetainedOutParameter,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value iff the return code is zero.\n  RetainedOutParameterOnZero,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value iff the return code is non-zero.\n  RetainedOutParameterOnNonZero,\n\n  /// The argument is treated as potentially escaping, meaning that\n  /// even when its reference count hits 0 it should be treated as still\n  /// possibly being alive as someone else *may* be holding onto the object.\n  MayEscape,\n\n  /// All typestate tracking of the object ceases.  This is usually employed\n  /// when the effect of the call is completely unknown.\n  StopTracking,\n\n  /// All typestate tracking of the object ceases.  Unlike StopTracking,\n  /// this is also enforced when the method body is inlined.\n  ///\n  /// In some cases, we obtain a better summary for this checker\n  /// by looking at the call site than by inlining the function.\n  /// Signifies that we should stop tracking the symbol even if\n  /// the function is inlined.\n  StopTrackingHard,\n\n  /// Performs the combined functionality of DecRef and StopTrackingHard.\n  ///\n  /// The models the effect that the called function decrements the reference\n  /// count of the argument and all typestate tracking on that argument\n  /// should cease.\n  DecRefAndStopTrackingHard,\n};\n\n/// An ArgEffect summarizes the retain count behavior on an argument or receiver\n/// to a function or method.\nclass ArgEffect {\n  ArgEffectKind K;\n  ObjKind O;\npublic:\n  explicit ArgEffect(ArgEffectKind K = DoNothing, ObjKind O = ObjKind::AnyObj)\n      : K(K), O(O) {}\n\n  ArgEffectKind getKind() const { return K; }\n  ObjKind getObjKind() const { return O; }\n\n  ArgEffect withKind(ArgEffectKind NewK) {\n    return ArgEffect(NewK, O);\n  }\n\n  bool operator==(const ArgEffect &Other) const {\n    return K == Other.K && O == Other.O;\n  }\n};\n\n/// RetEffect summarizes a call's retain/release behavior with respect\n/// to its return value.\nclass RetEffect {\npublic:\n  enum Kind {\n    /// Indicates that no retain count information is tracked for\n    /// the return value.\n    NoRet,\n\n    /// Indicates that the returned value is an owned (+1) symbol.\n    OwnedSymbol,\n\n    /// Indicates that the returned value is an object with retain count\n    /// semantics but that it is not owned (+0).  This is the default\n    /// for getters, etc.\n    NotOwnedSymbol,\n\n    /// Indicates that the return value is an owned object when the\n    /// receiver is also a tracked object.\n    OwnedWhenTrackedReceiver,\n\n    // Treat this function as returning a non-tracked symbol even if\n    // the function has been inlined. This is used where the call\n    // site summary is more precise than the summary indirectly produced\n    // by inlining the function\n    NoRetHard\n  };\n\nprivate:\n  Kind K;\n  ObjKind O;\n\n  RetEffect(Kind k, ObjKind o = ObjKind::AnyObj) : K(k), O(o) {}\n\npublic:\n  Kind getKind() const { return K; }\n\n  ObjKind getObjKind() const { return O; }\n\n  bool isOwned() const {\n    return K == OwnedSymbol || K == OwnedWhenTrackedReceiver;\n  }\n\n  bool notOwned() const {\n    return K == NotOwnedSymbol;\n  }\n\n  bool operator==(const RetEffect &Other) const {\n    return K == Other.K && O == Other.O;\n  }\n\n  static RetEffect MakeOwnedWhenTrackedReceiver() {\n    return RetEffect(OwnedWhenTrackedReceiver, ObjKind::ObjC);\n  }\n\n  static RetEffect MakeOwned(ObjKind o) {\n    return RetEffect(OwnedSymbol, o);\n  }\n  static RetEffect MakeNotOwned(ObjKind o) {\n    return RetEffect(NotOwnedSymbol, o);\n  }\n  static RetEffect MakeNoRet() {\n    return RetEffect(NoRet);\n  }\n  static RetEffect MakeNoRetHard() {\n    return RetEffect(NoRetHard);\n  }\n};\n\n/// A key identifying a summary.\nclass ObjCSummaryKey {\n  IdentifierInfo* II;\n  Selector S;\npublic:\n  ObjCSummaryKey(IdentifierInfo* ii, Selector s)\n    : II(ii), S(s) {}\n\n  ObjCSummaryKey(const ObjCInterfaceDecl *d, Selector s)\n    : II(d ? d->getIdentifier() : nullptr), S(s) {}\n\n  ObjCSummaryKey(Selector s)\n    : II(nullptr), S(s) {}\n\n  IdentifierInfo *getIdentifier() const { return II; }\n  Selector getSelector() const { return S; }\n};\n\n}",
  "id": "BLOCK-CPP-15950",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/RetainSummaryManager.h",
  "source_line": 33,
  "validation_status": "validated"
}