{
  "code": "{\n  void* ucontext = nullptr;\n#else\nstatic void AbslFailureSignalHandler(int signo, siginfo_t*, void* ucontext) {\n#endif\n\n  const GetTidType this_tid = absl::base_internal::GetTID();\n  GetTidType previous_failed_tid = 0;\n  if (!failed_tid.compare_exchange_strong(previous_failed_tid, this_tid,\n                                          std::memory_order_acq_rel,\n                                          std::memory_order_relaxed)) {\n    ABSL_RAW_LOG(\n        ERROR,\n        \"Signal %d raised at PC=%p while already in AbslFailureSignalHandler()\",\n        signo, absl::debugging_internal::GetProgramCounter(ucontext));\n    if (this_tid != previous_failed_tid) {\n      // Another thread is already in AbslFailureSignalHandler(), so wait\n      // a bit for it to finish. If the other thread doesn't kill us,\n      // we do so after sleeping.\n      PortableSleepForSeconds(3);\n      RaiseToDefaultHandler(signo);\n      // The recursively raised signal may be blocked until we return.\n      return;\n    }\n  }\n\n  // Increase the chance that the CPU we report was the same CPU on which the\n  // signal was received by doing this as early as possible, i.e. after\n  // verifying that this is not a recursive signal handler invocation.\n  int my_cpu = -1;\n#ifdef ABSL_HAVE_SCHED_GETCPU\n  my_cpu = sched_getcpu();\n#endif\n\n#ifdef ABSL_HAVE_ALARM\n  // Set an alarm to abort the program in case this code hangs or deadlocks.\n  if (fsh_options.alarm_on_failure_secs > 0) {\n    alarm(0);  // Cancel any existing alarms.\n    signal(SIGALRM, ImmediateAbortSignalHandler);\n    alarm(static_cast<unsigned int>(fsh_options.alarm_on_failure_secs));\n  }\n#endif\n\n  // First write to stderr.\n  WriteFailureInfo(\n      signo, ucontext, my_cpu, +[](const char* data) {\n        absl::raw_log_internal::AsyncSignalSafeWriteError(data, strlen(data));\n      });\n\n  // Riskier code (because it is less likely to be async-signal-safe)\n  // goes after this point.\n  if (fsh_options.writerfn != nullptr) {\n    WriteFailureInfo(signo, ucontext, my_cpu, fsh_options.writerfn);\n    fsh_options.writerfn(nullptr);\n  }\n\n  if (fsh_options.call_previous_handler) {\n    RaiseToPreviousHandler(signo);\n  } else {\n    RaiseToDefaultHandler(signo);\n  }\n}\n\nvoid InstallFailureSignalHandler(const FailureSignalHandlerOptions& options) {\n  fsh_options = options;\n  for (auto& it : failure_signal_data) {\n    InstallOneFailureHandler(&it, AbslFailureSignalHandler);\n  }\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01628",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/failure_signal_handler.cc",
  "source_line": 334,
  "validation_status": "validated"
}