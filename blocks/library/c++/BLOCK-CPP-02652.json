{
  "code": "{\nnamespace {\n\nusing PerFlagFilter = std::function<bool(const absl::CommandLineFlag&)>;\n\n// Maximum length size in a human readable format.\nconstexpr size_t kHrfMaxLineLength = 80;\n\n// This class is used to emit an XML element with `tag` and `text`.\n// It adds opening and closing tags and escapes special characters in the text.\n// For example:\n// std::cout << XMLElement(\"title\", \"Milk & Cookies\");\n// prints \"<title>Milk &amp; Cookies</title>\"\nclass XMLElement {\n public:\n  XMLElement(absl::string_view tag, absl::string_view txt)\n      : tag_(tag), txt_(txt) {}\n\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const XMLElement& xml_elem) {\n    out << \"<\" << xml_elem.tag_ << \">\";\n\n    for (auto c : xml_elem.txt_) {\n      switch (c) {\n        case '\"':\n          out << \"&quot;\";\n          break;\n        case '\\'':\n          out << \"&apos;\";\n          break;\n        case '&':\n          out << \"&amp;\";\n          break;\n        case '<':\n          out << \"&lt;\";\n          break;\n        case '>':\n          out << \"&gt;\";\n          break;\n        case '\\n':\n        case '\\v':\n        case '\\f':\n        case '\\t':\n          out << \" \";\n          break;\n        default:\n          if (IsValidXmlCharacter(static_cast<unsigned char>(c))) {\n            out << c;\n          }\n          break;\n      }\n    }\n\n    return out << \"</\" << xml_elem.tag_ << \">\";\n  }\n\n private:\n  static bool IsValidXmlCharacter(unsigned char c) { return c >= 0x20; }\n  absl::string_view tag_;\n  absl::string_view txt_;\n};\n\n// --------------------------------------------------------------------\n// Helper class to pretty-print info about a flag.\n\nclass FlagHelpPrettyPrinter {\n public:\n  // Pretty printer holds on to the std::ostream& reference to direct an output\n  // to that stream.\n  FlagHelpPrettyPrinter(size_t max_line_len, size_t min_line_len,\n                        size_t wrapped_line_indent, std::ostream& out)\n      : out_(out),\n        max_line_len_(max_line_len),\n        min_line_len_(min_line_len),\n        wrapped_line_indent_(wrapped_line_indent),\n        line_len_(0),\n        first_line_(true) {}\n\n  void Write(absl::string_view str, bool wrap_line = false) {\n    // Empty string - do nothing.\n    if (str.empty()) return;\n\n    std::vector<absl::string_view> tokens;\n    if (wrap_line) {\n      for (auto line : absl::StrSplit(str, absl::ByAnyChar(\"\\n\\r\"))) {\n        if (!tokens.empty()) {\n          // Keep line separators in the input string.\n          tokens.emplace_back(\"\\n\");\n        }\n        for (auto token :\n             absl::StrSplit(line, absl::ByAnyChar(\" \\t\"), absl::SkipEmpty())) {\n          tokens.push_back(token);\n        }\n      }\n    } else {\n      tokens.push_back(str);\n    }\n\n    for (auto token : tokens) {\n      bool new_line = (line_len_ == 0);\n\n      // Respect line separators in the input string.\n      if (token == \"\\n\") {\n        EndLine();\n        continue;\n      }\n\n      // Write the token, ending the string first if necessary/possible.\n      if (!new_line && (line_len_ + token.size() >= max_line_len_)) {\n        EndLine();\n        new_line = true;\n      }\n\n      if (new_line) {\n        StartLine();\n      } else {\n        out_ << ' ';\n        ++line_len_;\n      }\n\n      out_ << token;\n      line_len_ += token.size();\n    }\n  }\n\n  void StartLine() {\n    if (first_line_) {\n      line_len_ = min_line_len_;\n      first_line_ = false;\n    } else {\n      line_len_ = min_line_len_ + wrapped_line_indent_;\n    }\n    out_ << std::string(line_len_, ' ');\n  }\n  void EndLine() {\n    out_ << '\\n';\n    line_len_ = 0;\n  }\n\n private:\n  std::ostream& out_;\n  const size_t max_line_len_;\n  const size_t min_line_len_;\n  const size_t wrapped_line_indent_;\n  size_t line_len_;\n  bool first_line_;\n};\n\nvoid FlagHelpHumanReadable(const CommandLineFlag& flag, std::ostream& out) {\n  FlagHelpPrettyPrinter printer(kHrfMaxLineLength, 4, 2, out);\n\n  // Flag name.\n  printer.Write(absl::StrCat(\"--\", flag.Name()));\n\n  // Flag help.\n  printer.Write(absl::StrCat(\"(\", flag.Help(), \");\"), /*wrap_line=*/true);\n\n  // The listed default value will be the actual default from the flag\n  // definition in the originating source file, unless the value has\n  // subsequently been modified using SetCommandLineOption() with mode\n  // SET_FLAGS_DEFAULT.\n  std::string dflt_val = flag.DefaultValue();\n  std::string curr_val = flag.CurrentValue();\n  bool is_modified = curr_val != dflt_val;\n\n  if (flag.IsOfType<std::string>()) {\n    dflt_val = absl::StrCat(\"\\\"\", dflt_val, \"\\\"\");\n  }\n  printer.Write(absl::StrCat(\"default: \", dflt_val, \";\"));\n\n  if (is_modified) {\n    if (flag.IsOfType<std::string>()) {\n      curr_val = absl::StrCat(\"\\\"\", curr_val, \"\\\"\");\n    }\n    printer.Write(absl::StrCat(\"currently: \", curr_val, \";\"));\n  }\n\n  printer.EndLine();\n}\n\n// Shows help for every filename which matches any of the filters\n// If filters are empty, shows help for every file.\n// If a flag's help message has been stripped (e.g. by adding '#define\n// STRIP_FLAG_HELP 1' then this flag will not be displayed by '--help'\n// and its variants.\nvoid FlagsHelpImpl(std::ostream& out, PerFlagFilter filter_cb,\n                   HelpFormat format, absl::string_view program_usage_message) {\n  if (format == HelpFormat::kHumanReadable) {\n    out << flags_internal::ShortProgramInvocationName() << \": \"\n        << program_usage_message << \"\\n\\n\";\n  } else {\n    // XML schema is not a part of our public API for now.\n    out << \"<?xml version=\\\"1.0\\\"?>\\n\"\n        << \"<!-- This output should be used with care. We do not report type \"\n           \"names for flags with user defined types -->\\n\"\n        << \"<!-- Prefer flag only_check_args for validating flag inputs -->\\n\"\n        // The document.\n        << \"<AllFlags>\\n\"\n        // The program name and usage.\n        << XMLElement(\"program\", flags_internal::ShortProgramInvocationName())\n        << '\\n'\n        << XMLElement(\"usage\", program_usage_message) << '\\n';\n  }\n\n  // Ordered map of package name to\n  //   map of file name to\n  //     vector of flags in the file.\n  // This map is used to output matching flags grouped by package and file\n  // name.\n  std::map<std::string,\n           std::map<std::string, std::vector<const absl::CommandLineFlag*>>>\n      matching_flags;\n\n  flags_internal::ForEachFlag([&](absl::CommandLineFlag& flag) {\n    // Ignore retired flags.\n    if (flag.IsRetired()) return;\n\n    // If the flag has been stripped, pretend that it doesn't exist.\n    if (flag.Help() == flags_internal::kStrippedFlagHelp) return;\n\n    // Make sure flag satisfies the filter\n    if (!filter_cb(flag)) return;\n\n    std::string flag_filename = flag.Filename();\n\n    matching_flags[std::string(flags_internal::Package(flag_filename))]\n                  [flag_filename]\n                      .push_back(&flag);\n  });\n\n  absl::string_view package_separator;  // controls blank lines between packages\n  absl::string_view file_separator;     // controls blank lines between files\n  for (auto& package : matching_flags) {\n    if (format == HelpFormat::kHumanReadable) {\n      out << package_separator;\n      package_separator = \"\\n\\n\";\n    }\n\n    file_separator = \"\";\n    for (auto& flags_in_file : package.second) {\n      if (format == HelpFormat::kHumanReadable) {\n        out << file_separator << \"  Flags from \" << flags_in_file.first\n            << \":\\n\";\n        file_separator = \"\\n\";\n      }\n\n      std::sort(std::begin(flags_in_file.second),\n                std::end(flags_in_file.second),\n                [](const CommandLineFlag* lhs, const CommandLineFlag* rhs) {\n                  return lhs->Name() < rhs->Name();\n                });\n\n      for (const auto* flag : flags_in_file.second) {\n        flags_internal::FlagHelp(out, *flag, format);\n      }\n    }\n  }\n\n  if (format == HelpFormat::kHumanReadable) {\n    FlagHelpPrettyPrinter printer(kHrfMaxLineLength, 0, 0, out);\n\n    if (filter_cb && matching_flags.empty()) {\n      printer.Write(\"No flags matched.\\n\", true);\n    }\n    printer.EndLine();\n    printer.Write(\n        \"Try --helpfull to get a list of all flags or --help=substring \"\n        \"shows help for flags which include specified substring in either \"\n        \"in the name, or description or path.\\n\",\n        true);\n  } else {\n    // The end of the document.\n    out << \"</AllFlags>\\n\";\n  }\n}\n\nvoid FlagsHelpImpl(std::ostream& out,\n                   flags_internal::FlagKindFilter filename_filter_cb,\n                   HelpFormat format, absl::string_view program_usage_message) {\n  FlagsHelpImpl(\n      out,\n      [&](const absl::CommandLineFlag& flag) {\n        return filename_filter_cb && filename_filter_cb(flag.Filename());\n      },\n      format, program_usage_message);\n}\n\n}  // namespace\n\n// --------------------------------------------------------------------\n// Produces the help message describing specific flag.\nvoid FlagHelp(std::ostream& out, const CommandLineFlag& flag,\n              HelpFormat format) {\n  if (format == HelpFormat::kHumanReadable)\n    flags_internal::FlagHelpHumanReadable(flag, out);\n}\n\n// --------------------------------------------------------------------\n// Produces the help messages for all flags matching the filename filter.\n// If filter is empty produces help messages for all flags.\nvoid FlagsHelp(std::ostream& out, absl::string_view filter, HelpFormat format,\n               absl::string_view program_usage_message) {\n  flags_internal::FlagKindFilter filter_cb = [&](absl::string_view filename) {\n    return filter.empty() || absl::StrContains(filename, filter);\n  };\n  flags_internal::FlagsHelpImpl(out, filter_cb, format, program_usage_message);\n}\n\n// --------------------------------------------------------------------\n// Checks all the 'usage' command line flags to see if any have been set.\n// If so, handles them appropriately.\nHelpMode HandleUsageFlags(std::ostream& out,\n                          absl::string_view program_usage_message) {\n  switch (GetFlagsHelpMode()) {\n    case HelpMode::kNone:\n      break;\n    case HelpMode::kImportant:\n      flags_internal::FlagsHelpImpl(\n          out, flags_internal::GetUsageConfig().contains_help_flags,\n          GetFlagsHelpFormat(), program_usage_message);\n      break;\n\n    case HelpMode::kShort:\n      flags_internal::FlagsHelpImpl(\n          out, flags_internal::GetUsageConfig().contains_helpshort_flags,\n          GetFlagsHelpFormat(), program_usage_message);\n      break;\n\n    case HelpMode::kFull:\n      flags_internal::FlagsHelp(out, \"\", GetFlagsHelpFormat(),\n                                program_usage_message);\n      break;\n\n    case HelpMode::kPackage:\n      flags_internal::FlagsHelpImpl(\n          out, flags_internal::GetUsageConfig().contains_helppackage_flags,\n          GetFlagsHelpFormat(), program_usage_message);\n      break;\n\n    case HelpMode::kMatch: {\n      std::string substr = GetFlagsHelpMatchSubstr();\n      if (substr.empty()) {\n        // show all options\n        flags_internal::FlagsHelp(out, substr, GetFlagsHelpFormat(),\n                                  program_usage_message);\n      } else {\n        auto filter_cb = [&substr](const absl::CommandLineFlag& flag) {\n          if (absl::StrContains(flag.Name(), substr)) return true;\n          if (absl::StrContains(flag.Filename(), substr)) return true;\n          if (absl::StrContains(flag.Help(), substr)) return true;\n\n          return false;\n        };\n        flags_internal::FlagsHelpImpl(\n            out, filter_cb, HelpFormat::kHumanReadable, program_usage_message);\n      }\n      break;\n    }\n    case HelpMode::kVersion:\n      if (flags_internal::GetUsageConfig().version_string)\n        out << flags_internal::GetUsageConfig().version_string();\n      // Unlike help, we may be asking for version in a script, so return 0\n      break;\n\n    case HelpMode::kOnlyCheckArgs:\n      break;\n  }\n\n  return GetFlagsHelpMode();\n}\n\n// --------------------------------------------------------------------\n// Globals representing usage reporting flags\n\nnamespace {\n\nABSL_CONST_INIT absl::Mutex help_attributes_guard(absl::kConstInit);\nABSL_CONST_INIT std::string* match_substr\n    ABSL_GUARDED_BY(help_attributes_guard) = nullptr;\nABSL_CONST_INIT HelpMode help_mode ABSL_GUARDED_BY(help_attributes_guard) =\n    HelpMode::kNone;\nABSL_CONST_INIT HelpFormat help_format ABSL_GUARDED_BY(help_attributes_guard) =\n    HelpFormat::kHumanReadable;\n\n}  // namespace\n\nstd::string GetFlagsHelpMatchSubstr() {\n  absl::MutexLock l(&help_attributes_guard);\n  if (match_substr == nullptr) return \"\";\n  return *match_substr;\n}\n\nvoid SetFlagsHelpMatchSubstr(absl::string_view substr) {\n  absl::MutexLock l(&help_attributes_guard);\n  if (match_substr == nullptr) match_substr = new std::string;\n  match_substr->assign(substr.data(), substr.size());\n}\n\nHelpMode GetFlagsHelpMode() {\n  absl::MutexLock l(&help_attributes_guard);\n  return help_mode;\n}\n\nvoid SetFlagsHelpMode(HelpMode mode) {\n  absl::MutexLock l(&help_attributes_guard);\n  help_mode = mode;\n}\n\nHelpFormat GetFlagsHelpFormat() {\n  absl::MutexLock l(&help_attributes_guard);\n  return help_format;\n}\n\nvoid SetFlagsHelpFormat(HelpFormat format) {\n  absl::MutexLock l(&help_attributes_guard);\n  help_format = format;\n}\n\n// Deduces usage flags from the input argument in a form --name=value or\n// --name. argument is already split into name and value before we call this\n// function.\nbool DeduceUsageFlags(absl::string_view name, absl::string_view value) {\n  if (absl::ConsumePrefix(&name, \"help\")) {\n    if (name.empty()) {\n      if (value.empty()) {\n        SetFlagsHelpMode(HelpMode::kImportant);\n      } else {\n        SetFlagsHelpMode(HelpMode::kMatch);\n        SetFlagsHelpMatchSubstr(value);\n      }\n      return true;\n    }\n\n    if (name == \"match\") {\n      SetFlagsHelpMode(HelpMode::kMatch);\n      SetFlagsHelpMatchSubstr(value);\n      return true;\n    }\n\n    if (name == \"on\") {\n      SetFlagsHelpMode(HelpMode::kMatch);\n      SetFlagsHelpMatchSubstr(absl::StrCat(\"/\", value, \".\"));\n      return true;\n    }\n\n    if (name == \"full\") {\n      SetFlagsHelpMode(HelpMode::kFull);\n      return true;\n    }\n\n    if (name == \"short\") {\n      SetFlagsHelpMode(HelpMode::kShort);\n      return true;\n    }\n\n    if (name == \"package\") {\n      SetFlagsHelpMode(HelpMode::kPackage);\n      return true;\n    }\n\n    return false;\n  }\n\n  if (name == \"version\") {\n    SetFlagsHelpMode(HelpMode::kVersion);\n    return true;\n  }\n\n  if (name == \"only_check_args\") {\n    SetFlagsHelpMode(HelpMode::kOnlyCheckArgs);\n    return true;\n  }\n\n  return false;\n}\n\n// --------------------------------------------------------------------\n\nvoid MaybeExit(HelpMode mode) {\n  switch (mode) {\n    case flags_internal::HelpMode::kNone:\n      return;\n    case flags_internal::HelpMode::kOnlyCheckArgs:\n    case flags_internal::HelpMode::kVersion:\n      std::exit(0);\n    default:  // For all the other modes we exit with 1\n      std::exit(1);\n  }\n}\n\n// --------------------------------------------------------------------\n\n}",
  "id": "BLOCK-CPP-02652",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/internal/usage.cc",
  "source_line": 61,
  "validation_status": "validated"
}