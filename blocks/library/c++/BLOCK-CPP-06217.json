{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace strings_internal {\n\n// The same as std::ostringstream but appends to a user-specified std::string,\n// and is faster. It is ~70% faster to create, ~50% faster to write to, and\n// completely free to extract the result std::string.\n//\n//   std::string s;\n//   OStringStream strm(&s);\n//   strm << 42 << ' ' << 3.14;  // appends to `s`\n//\n// The stream object doesn't have to be named. Starting from C++11 operator<<\n// works with rvalues of std::ostream.\n//\n//   std::string s;\n//   OStringStream(&s) << 42 << ' ' << 3.14;  // appends to `s`\n//\n// OStringStream is faster to create than std::ostringstream but it's still\n// relatively slow. Avoid creating multiple streams where a single stream will\n// do.\n//\n// Creates unnecessary instances of OStringStream: slow.\n//\n//   std::string s;\n//   OStringStream(&s) << 42;\n//   OStringStream(&s) << ' ';\n//   OStringStream(&s) << 3.14;\n//\n// Creates a single instance of OStringStream and reuses it: fast.\n//\n//   std::string s;\n//   OStringStream strm(&s);\n//   strm << 42;\n//   strm << ' ';\n//   strm << 3.14;\n//\n// Note: flush() has no effect. No reason to call it.\nclass OStringStream final : public std::ostream {\n public:\n  // The argument can be null, in which case you'll need to call str(p) with a\n  // non-null argument before you can write to the stream.\n  //\n  // The destructor of OStringStream doesn't use the std::string. It's OK to\n  // destroy the std::string before the stream.\n  explicit OStringStream(std::string* str)\n      : std::ostream(&buf_), buf_(str) {}\n  OStringStream(OStringStream&& that)\n      : std::ostream(std::move(static_cast<std::ostream&>(that))),\n        buf_(that.buf_) {\n    rdbuf(&buf_);\n  }\n  OStringStream& operator=(OStringStream&& that) {\n    std::ostream::operator=(std::move(static_cast<std::ostream&>(that)));\n    buf_ = that.buf_;\n    rdbuf(&buf_);\n    return *this;\n  }\n\n  std::string* str() { return buf_.str(); }\n  const std::string* str() const { return buf_.str(); }\n  void str(std::string* str) { buf_.str(str); }\n\n private:\n  class Streambuf final : public std::streambuf {\n   public:\n    explicit Streambuf(std::string* str) : str_(str) {}\n    Streambuf(const Streambuf&) = default;\n    Streambuf& operator=(const Streambuf&) = default;\n\n    std::string* str() { return str_; }\n    const std::string* str() const { return str_; }\n    void str(std::string* str) { str_ = str; }\n\n   protected:\n    int_type overflow(int c) override;\n    std::streamsize xsputn(const char* s, std::streamsize n) override;\n\n   private:\n    std::string* str_;\n  } buf_;\n};\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06217",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/ostringstream.h",
  "source_line": 27,
  "validation_status": "validated"
}