{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace flags_internal {\n\n// --------------------------------------------------------------------\n// AbslParseFlag specializations for boolean type.\n\nbool AbslParseFlag(absl::string_view text, bool* dst, std::string*) {\n  const char* kTrue[] = {\"1\", \"t\", \"true\", \"y\", \"yes\"};\n  const char* kFalse[] = {\"0\", \"f\", \"false\", \"n\", \"no\"};\n  static_assert(sizeof(kTrue) == sizeof(kFalse), \"true_false_equal\");\n\n  text = absl::StripAsciiWhitespace(text);\n\n  for (size_t i = 0; i < ABSL_ARRAYSIZE(kTrue); ++i) {\n    if (absl::EqualsIgnoreCase(text, kTrue[i])) {\n      *dst = true;\n      return true;\n    } else if (absl::EqualsIgnoreCase(text, kFalse[i])) {\n      *dst = false;\n      return true;\n    }\n  }\n  return false;  // didn't match a legal input\n}\n\n// --------------------------------------------------------------------\n// AbslParseFlag for integral types.\n\n// Return the base to use for parsing text as an integer.  Leading 0x\n// puts us in base 16.  But leading 0 does not put us in base 8. It\n// caused too many bugs when we had that behavior.\nstatic int NumericBase(absl::string_view text) {\n  if (text.empty()) return 0;\n  size_t num_start = (text[0] == '-' || text[0] == '+') ? 1 : 0;\n  const bool hex = (text.size() >= num_start + 2 && text[num_start] == '0' &&\n                    (text[num_start + 1] == 'x' || text[num_start + 1] == 'X'));\n  return hex ? 16 : 10;\n}\n\ntemplate <typename IntType>\ninline bool ParseFlagImpl(absl::string_view text, IntType& dst) {\n  text = absl::StripAsciiWhitespace(text);\n\n  return absl::numbers_internal::safe_strtoi_base(text, &dst,\n                                                  NumericBase(text));\n}\n\nbool AbslParseFlag(absl::string_view text, short* dst, std::string*) {\n  int val;\n  if (!ParseFlagImpl(text, val)) return false;\n  if (static_cast<short>(val) != val)  // worked, but number out of range\n    return false;\n  *dst = static_cast<short>(val);\n  return true;\n}\n\nbool AbslParseFlag(absl::string_view text, unsigned short* dst, std::string*) {\n  unsigned int val;\n  if (!ParseFlagImpl(text, val)) return false;\n  if (static_cast<unsigned short>(val) !=\n      val)  // worked, but number out of range\n    return false;\n  *dst = static_cast<unsigned short>(val);\n  return true;\n}\n\nbool AbslParseFlag(absl::string_view text, int* dst, std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, unsigned int* dst, std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, long* dst, std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, unsigned long* dst, std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, long long* dst, std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, unsigned long long* dst,\n                   std::string*) {\n  return ParseFlagImpl(text, *dst);\n}\n\nbool AbslParseFlag(absl::string_view text, absl::int128* dst, std::string*) {\n  text = absl::StripAsciiWhitespace(text);\n\n  // check hex\n  int base = NumericBase(text);\n  if (!absl::numbers_internal::safe_strto128_base(text, dst, base)) {\n    return false;\n  }\n\n  return base == 16 ? absl::SimpleHexAtoi(text, dst)\n                    : absl::SimpleAtoi(text, dst);\n}\n\nbool AbslParseFlag(absl::string_view text, absl::uint128* dst, std::string*) {\n  text = absl::StripAsciiWhitespace(text);\n\n  // check hex\n  int base = NumericBase(text);\n  if (!absl::numbers_internal::safe_strtou128_base(text, dst, base)) {\n    return false;\n  }\n\n  return base == 16 ? absl::SimpleHexAtoi(text, dst)\n                    : absl::SimpleAtoi(text, dst);\n}\n\n// --------------------------------------------------------------------\n// AbslParseFlag for floating point types.\n\nbool AbslParseFlag(absl::string_view text, float* dst, std::string*) {\n  return absl::SimpleAtof(text, dst);\n}\n\nbool AbslParseFlag(absl::string_view text, double* dst, std::string*) {\n  return absl::SimpleAtod(text, dst);\n}\n\n// --------------------------------------------------------------------\n// AbslParseFlag for strings.\n\nbool AbslParseFlag(absl::string_view text, std::string* dst, std::string*) {\n  dst->assign(text.data(), text.size());\n  return true;\n}\n\n// --------------------------------------------------------------------\n// AbslParseFlag for vector of strings.\n\nbool AbslParseFlag(absl::string_view text, std::vector<std::string>* dst,\n                   std::string*) {\n  // An empty flag value corresponds to an empty vector, not a vector\n  // with a single, empty std::string.\n  if (text.empty()) {\n    dst->clear();\n    return true;\n  }\n  *dst = absl::StrSplit(text, ',', absl::AllowEmpty());\n  return true;\n}\n\n// --------------------------------------------------------------------\n// AbslUnparseFlag specializations for various builtin flag types.\n\nstd::string Unparse(bool v) { return v ? \"true\" : \"false\"; }\nstd::string Unparse(short v) { return absl::StrCat(v); }\nstd::string Unparse(unsigned short v) { return absl::StrCat(v); }\nstd::string Unparse(int v) { return absl::StrCat(v); }\nstd::string Unparse(unsigned int v) { return absl::StrCat(v); }\nstd::string Unparse(long v) { return absl::StrCat(v); }\nstd::string Unparse(unsigned long v) { return absl::StrCat(v); }\nstd::string Unparse(long long v) { return absl::StrCat(v); }\nstd::string Unparse(unsigned long long v) { return absl::StrCat(v); }\nstd::string Unparse(absl::int128 v) {\n  std::stringstream ss;\n  ss << v;\n  return ss.str();\n}\nstd::string Unparse(absl::uint128 v) {\n  std::stringstream ss;\n  ss << v;\n  return ss.str();\n}\n\ntemplate <typename T>\nstd::string UnparseFloatingPointVal(T v) {\n  // digits10 is guaranteed to roundtrip correctly in string -> value -> string\n  // conversions, but may not be enough to represent all the values correctly.\n  std::string digit10_str =\n      absl::StrFormat(\"%.*g\", std::numeric_limits<T>::digits10, v);\n  if (std::isnan(v) || std::isinf(v)) return digit10_str;\n\n  T roundtrip_val = 0;\n  std::string err;\n  if (absl::ParseFlag(digit10_str, &roundtrip_val, &err) &&\n      roundtrip_val == v) {\n    return digit10_str;\n  }\n\n  // max_digits10 is the number of base-10 digits that are necessary to uniquely\n  // represent all distinct values.\n  return absl::StrFormat(\"%.*g\", std::numeric_limits<T>::max_digits10, v);\n}\nstd::string Unparse(float v) { return UnparseFloatingPointVal(v); }\nstd::string Unparse(double v) { return UnparseFloatingPointVal(v); }\nstd::string AbslUnparseFlag(absl::string_view v) { return std::string(v); }\nstd::string AbslUnparseFlag(const std::vector<std::string>& v) {\n  return absl::StrJoin(v, \",\");\n}\n\n}  // namespace flags_internal\n\nbool AbslParseFlag(absl::string_view text, absl::LogSeverity* dst,\n                   std::string* err) {\n  text = absl::StripAsciiWhitespace(text);\n  if (text.empty()) {\n    *err = \"no value provided\";\n    return false;\n  }\n  if (absl::EqualsIgnoreCase(text, \"dfatal\")) {\n    *dst = absl::kLogDebugFatal;\n    return true;\n  }\n  if (absl::EqualsIgnoreCase(text, \"klogdebugfatal\")) {\n    *dst = absl::kLogDebugFatal;\n    return true;\n  }\n  if (text.front() == 'k' || text.front() == 'K') text.remove_prefix(1);\n  if (absl::EqualsIgnoreCase(text, \"info\")) {\n    *dst = absl::LogSeverity::kInfo;\n    return true;\n  }\n  if (absl::EqualsIgnoreCase(text, \"warning\")) {\n    *dst = absl::LogSeverity::kWarning;\n    return true;\n  }\n  if (absl::EqualsIgnoreCase(text, \"error\")) {\n    *dst = absl::LogSeverity::kError;\n    return true;\n  }\n  if (absl::EqualsIgnoreCase(text, \"fatal\")) {\n    *dst = absl::LogSeverity::kFatal;\n    return true;\n  }\n  std::underlying_type<absl::LogSeverity>::type numeric_value;\n  if (absl::ParseFlag(text, &numeric_value, err)) {\n    *dst = static_cast<absl::LogSeverity>(numeric_value);\n    return true;\n  }\n  *err =\n      \"only integers, absl::LogSeverity enumerators, and DFATAL are accepted\";\n  return false;\n}\n\nstd::string AbslUnparseFlag(absl::LogSeverity v) {\n  if (v == absl::NormalizeLogSeverity(v)) return absl::LogSeverityName(v);\n  return absl::UnparseFlag(static_cast<int>(v));\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01692",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/marshalling.cc",
  "source_line": 40,
  "validation_status": "validated"
}