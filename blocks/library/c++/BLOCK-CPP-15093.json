{
  "code": "{\n///     int x;\n///   };\n///   static_assert(sizeof(S) == sizeof(int));\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, StaticAssertDecl>\n    staticAssertDecl;\n\n/// Matches a reinterpret_cast expression.\n///\n/// Either the source expression or the destination type can be matched\n/// using has(), but hasDestinationType() is more specific and can be\n/// more readable.\n///\n/// Example matches reinterpret_cast<char*>(&p) in\n/// \\code\n///   void* p = reinterpret_cast<char*>(&p);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXReinterpretCastExpr>\n    cxxReinterpretCastExpr;\n\n/// Matches a C++ static_cast expression.\n///\n/// \\see hasDestinationType\n/// \\see reinterpretCast\n///\n/// Example:\n///   cxxStaticCastExpr()\n/// matches\n///   static_cast<long>(8)\n/// in\n/// \\code\n///   long eight(static_cast<long>(8));\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXStaticCastExpr>\n    cxxStaticCastExpr;\n\n/// Matches a dynamic_cast expression.\n///\n/// Example:\n///   cxxDynamicCastExpr()\n/// matches\n///   dynamic_cast<D*>(&b);\n/// in\n/// \\code\n///   struct B { virtual ~B() {} }; struct D : B {};\n///   B b;\n///   D* p = dynamic_cast<D*>(&b);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXDynamicCastExpr>\n    cxxDynamicCastExpr;\n\n/// Matches a const_cast expression.\n///\n/// Example: Matches const_cast<int*>(&r) in\n/// \\code\n///   int n = 42;\n///   const int &r(n);\n///   int* p = const_cast<int*>(&r);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXConstCastExpr>\n    cxxConstCastExpr;\n\n/// Matches a C-style cast expression.\n///\n/// Example: Matches (int) 2.2f in\n/// \\code\n///   int i = (int) 2.2f;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CStyleCastExpr>\n    cStyleCastExpr;\n\n/// Matches explicit cast expressions.\n///\n/// Matches any cast expression written in user code, whether it be a\n/// C-style cast, a functional-style cast, or a keyword cast.\n///\n/// Does not match implicit conversions.\n///\n/// Note: the name \"explicitCast\" is chosen to match Clang's terminology, as\n/// Clang uses the term \"cast\" to apply to implicit conversions as well as to\n/// actual cast expressions.\n///\n/// \\see hasDestinationType.\n///\n/// Example: matches all five of the casts in\n/// \\code\n///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))\n/// \\endcode\n/// but does not match the implicit conversion in\n/// \\code\n///   long ell = 42;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ExplicitCastExpr>\n    explicitCastExpr;\n\n/// Matches the implicit cast nodes of Clang's AST.\n///\n/// This matches many different places, including function call return value\n/// eliding, as well as any type conversions.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ImplicitCastExpr>\n    implicitCastExpr;\n\n/// Matches any cast nodes of Clang's AST.\n///\n/// Example: castExpr() matches each of the following:\n/// \\code\n///   (int) 3;\n///   const_cast<Expr *>(SubExpr);\n///   char c = 0;\n/// \\endcode\n/// but does not match\n/// \\code\n///   int i = (0);\n///   int k = 0;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CastExpr> castExpr;\n\n/// Matches functional cast expressions\n///\n/// Example: Matches Foo(bar);\n/// \\code\n///   Foo f = bar;\n///   Foo g = (Foo) bar;\n///   Foo h = Foo(bar);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXFunctionalCastExpr>\n    cxxFunctionalCastExpr;\n\n/// Matches functional cast expressions having N != 1 arguments\n///\n/// Example: Matches Foo(bar, bar)\n/// \\code\n///   Foo h = Foo(bar, bar);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXTemporaryObjectExpr>\n    cxxTemporaryObjectExpr;\n\n/// Matches predefined identifier expressions [C99 6.4.2.2].\n///\n/// Example: Matches __func__\n/// \\code\n///   printf(\"%s\", __func__);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, PredefinedExpr>\n    predefinedExpr;\n\n/// Matches C99 designated initializer expressions [C99 6.7.8].\n///\n/// Example: Matches { [2].y = 1.0, [0].x = 1.0 }\n/// \\code\n///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DesignatedInitExpr>\n    designatedInitExpr;\n\n/// Matches designated initializer expressions that contain\n/// a specific number of designators.\n///\n/// Example: Given\n/// \\code\n///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };\n///   point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };\n/// \\endcode\n/// designatorCountIs(2)\n///   matches '{ [2].y = 1.0, [0].x = 1.0 }',\n///   but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'.\nAST_MATCHER_P(DesignatedInitExpr, designatorCountIs, unsigned, N) {\n  return Node.size() == N;\n}\n\n/// Matches \\c QualTypes in the clang AST.\nextern const internal::VariadicAllOfMatcher<QualType> qualType;\n\n/// Matches \\c Types in the clang AST.\nextern const internal::VariadicAllOfMatcher<Type> type;\n\n/// Matches \\c TypeLocs in the clang AST.\nextern const internal::VariadicAllOfMatcher<TypeLoc> typeLoc;\n\n/// Matches if any of the given matchers matches.\n///\n/// Unlike \\c anyOf, \\c eachOf will generate a match result for each\n/// matching submatcher.\n///\n/// For example, in:\n/// \\code\n///   class A { int a; int b; };\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(eachOf(has(fieldDecl(hasName(\"a\")).bind(\"v\")),\n///                        has(fieldDecl(hasName(\"b\")).bind(\"v\"))))\n/// \\endcode\n/// will generate two results binding \"v\", the first of which binds\n/// the field declaration of \\c a, the second the field declaration of\n/// \\c b.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    eachOf;\n\n/// Matches if any of the given matchers matches.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    anyOf;\n\n/// Matches if all given matchers match.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    allOf;\n\n/// Matches any node regardless of the submatcher.\n///\n/// However, \\c optionally will retain any bindings generated by the submatcher.\n/// Useful when additional information which may or may not present about a main\n/// matching node is desired.\n///\n/// For example, in:\n/// \\code\n///   class Foo {\n///     int bar;\n///   }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(\n///     optionally(has(\n///       fieldDecl(hasName(\"bar\")).bind(\"var\")\n///   ))).bind(\"record\")\n/// \\endcode\n/// will produce a result binding for both \"record\" and \"var\".\n/// The matcher will produce a \"record\" binding for even if there is no data\n/// member named \"bar\" in that class.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<1, 1> optionally;\n\n/// Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)\n///\n/// Given\n/// \\code\n///   Foo x = bar;\n///   int y = sizeof(x) + alignof(x);\n/// \\endcode\n/// unaryExprOrTypeTraitExpr()\n///   matches \\c sizeof(x) and \\c alignof(x)\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   UnaryExprOrTypeTraitExpr>\n    unaryExprOrTypeTraitExpr;\n\n/// Matches any of the \\p NodeMatchers with InnerMatchers nested within\n///\n/// Given\n/// \\code\n///   if (true);\n///   for (; true; );\n/// \\endcode\n/// with the matcher\n/// \\code\n///   mapAnyOf(ifStmt, forStmt).with(\n///     hasCondition(cxxBoolLiteralExpr(equals(true)))\n///     ).bind(\"trueCond\")\n/// \\endcode\n/// matches the \\c if and the \\c for. It is equivalent to:\n/// \\code\n///   auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));\n///   anyOf(\n///     ifStmt(trueCond).bind(\"trueCond\"),\n///     forStmt(trueCond).bind(\"trueCond\")\n///     );\n/// \\endcode\n///\n/// The with() chain-call accepts zero or more matchers which are combined\n/// as-if with allOf() in each of the node matchers.\n/// Usable as: Any Matcher\ntemplate <typename T, typename... U>\nauto mapAnyOf(internal::VariadicDynCastAllOfMatcher<T, U> const &...) {\n  return internal::MapAnyOfHelper<U...>();\n}\n\n/// Matches nodes which can be used with binary operators.\n///\n/// The code\n/// \\code\n///   var1 != var2;\n/// \\endcode\n/// might be represented in the clang AST as a binaryOperator, a\n/// cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on\n///\n/// * whether the types of var1 and var2 are fundamental (binaryOperator) or at\n///   least one is a class type (cxxOperatorCallExpr)\n/// * whether the code appears in a template declaration, if at least one of the\n///   vars is a dependent-type (binaryOperator)\n/// * whether the code relies on a rewritten binary operator, such as a\n/// spaceship operator or an inverted equality operator\n/// (cxxRewrittenBinaryOperator)\n///\n/// This matcher elides details in places where the matchers for the nodes are\n/// compatible.\n///\n/// Given\n/// \\code\n///   binaryOperation(\n///     hasOperatorName(\"!=\"),\n///     hasLHS(expr().bind(\"lhs\")),\n///     hasRHS(expr().bind(\"rhs\"))\n///   )\n/// \\endcode\n/// matches each use of \"!=\" in:\n/// \\code\n///   struct S{\n///       bool operator!=(const S&) const;\n///   };\n///\n///   void foo()\n///   {\n///      1 != 2;\n///      S() != S();\n///   }\n///\n///   template<typename T>\n///   void templ()\n///   {\n///      1 != 2;\n///      T() != S();\n///   }\n///   struct HasOpEq\n///   {\n///       bool operator==(const HasOpEq &) const;\n///   };\n///\n///   void inverse()\n///   {\n///       HasOpEq s1;\n///       HasOpEq s2;\n///       if (s1 != s2)\n///           return;\n///   }\n///\n///   struct HasSpaceship\n///   {\n///       bool operator<=>(const HasOpEq &) const;\n///   };\n///\n///   void use_spaceship()\n///   {\n///       HasSpaceship s1;\n///       HasSpaceship s2;\n///       if (s1 != s2)\n///           return;\n///   }\n/// \\endcode\nextern const internal::MapAnyOfMatcher<BinaryOperator, CXXOperatorCallExpr,\n                                       CXXRewrittenBinaryOperator>\n    binaryOperation;\n\n/// Matches function calls and constructor calls\n///\n/// Because CallExpr and CXXConstructExpr do not share a common\n/// base class with API accessing arguments etc, AST Matchers for code\n/// which should match both are typically duplicated. This matcher\n/// removes the need for duplication.\n///\n/// Given code\n/// \\code\n/// struct ConstructorTakesInt\n/// {\n///   ConstructorTakesInt(int i) {}\n/// };\n///\n/// void callTakesInt(int i)\n/// {\n/// }\n///\n/// void doCall()\n/// {\n///   callTakesInt(42);\n/// }\n///\n/// void doConstruct()\n/// {\n///   ConstructorTakesInt cti(42);\n/// }\n/// \\endcode\n///\n/// The matcher\n/// \\code\n/// invocation(hasArgument(0, integerLiteral(equals(42))))\n/// \\endcode\n/// matches the expression in both doCall and doConstruct\nextern const internal::MapAnyOfMatcher<CallExpr, CXXConstructExpr> invocation;\n\n/// Matches unary expressions that have a specific type of argument.\n///\n/// Given\n/// \\code\n///   int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);\n/// \\endcode\n/// unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(\"int\"))\n///   matches \\c sizeof(a) and \\c alignof(c)\nAST_MATCHER_P(UnaryExprOrTypeTraitExpr, hasArgumentOfType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  const QualType ArgumentType = Node.getTypeOfArgument();\n  return InnerMatcher.matches(ArgumentType, Finder, Builder);\n}\n\n/// Matches unary expressions of a certain kind.\n///\n/// Given\n/// \\code\n///   int x;\n///   int s = sizeof(x) + alignof(x)\n/// \\endcode\n/// unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))\n///   matches \\c sizeof(x)\n///\n/// If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter\n/// should be passed as a quoted string. e.g., ofKind(\"UETT_SizeOf\").\nAST_MATCHER_P(UnaryExprOrTypeTraitExpr, ofKind, UnaryExprOrTypeTrait, Kind) {\n  return Node.getKind() == Kind;\n}\n\n/// Same as unaryExprOrTypeTraitExpr, but only matching\n/// alignof.\ninline internal::BindableMatcher<Stmt> alignOfExpr(\n    const internal::Matcher<UnaryExprOrTypeTraitExpr> &InnerMatcher) {\n  return stmt(unaryExprOrTypeTraitExpr(\n      allOf(anyOf(ofKind(UETT_AlignOf), ofKind(UETT_PreferredAlignOf)),\n            InnerMatcher)));\n}\n\n/// Same as unaryExprOrTypeTraitExpr, but only matching\n/// sizeof.\ninline internal::BindableMatcher<Stmt> sizeOfExpr(\n    const internal::Matcher<UnaryExprOrTypeTraitExpr> &InnerMatcher) {\n  return stmt(unaryExprOrTypeTraitExpr(\n      allOf(ofKind(UETT_SizeOf), InnerMatcher)));\n}\n\n/// Matches NamedDecl nodes that have the specified name.\n///\n/// Supports specifying enclosing namespaces or classes by prefixing the name\n/// with '<enclosing>::'.\n/// Does not match typedefs of an underlying type with the given name.\n///\n/// Example matches X (Name == \"X\")\n/// \\code\n///   class X;\n/// \\endcode\n///\n/// Example matches X (Name is one of \"::a::b::X\", \"a::b::X\", \"b::X\", \"X\")\n/// \\code\n///   namespace a { namespace b { class X; } }\n/// \\endcode\ninline internal::Matcher<NamedDecl> hasName(StringRef Name) {\n  return internal::Matcher<NamedDecl>(\n      new internal::HasNameMatcher({std::string(Name)}));\n}\n\n/// Matches NamedDecl nodes that have any of the specified names.\n///\n/// This matcher is only provided as a performance optimization of hasName.\n/// \\code\n///     hasAnyName(a, b, c)\n/// \\endcode\n///  is equivalent to, but faster than\n/// \\code\n///     anyOf(hasName(a), hasName(b), hasName(c))\n/// \\endcode\nextern const internal::VariadicFunction<internal::Matcher<NamedDecl>, StringRef,\n                                        internal::hasAnyNameFunc>\n    hasAnyName;\n\n/// Matches NamedDecl nodes whose fully qualified names contain\n/// a substring matched by the given RegExp.\n///\n/// Supports specifying enclosing namespaces or classes by\n/// prefixing the name with '<enclosing>::'.  Does not match typedefs\n/// of an underlying type with the given name.\n///\n/// Example matches X (regexp == \"::X\")\n/// \\code\n///   class X;\n/// \\endcode\n///\n/// Example matches X (regexp is one of \"::X\", \"^foo::.*X\", among others)\n/// \\code\n///   namespace foo { namespace bar { class X; } }\n/// \\endcode\nAST_MATCHER_REGEX(NamedDecl, matchesName, RegExp) {\n  std::string FullNameString = \"::\" + Node.getQualifiedNameAsString();\n  return RegExp->match(FullNameString);\n}\n\n/// Matches overloaded operator names.\n///\n/// Matches overloaded operator names specified in strings without the\n/// \"operator\" prefix: e.g. \"<<\".\n///\n/// Given:\n/// \\code\n///   class A { int operator*(); };\n///   const A &operator<<(const A &a, const A &b);\n///   A a;\n///   a << a;   // <-- This matches\n/// \\endcode\n///\n/// \\c cxxOperatorCallExpr(hasOverloadedOperatorName(\"<<\"))) matches the\n/// specified line and\n/// \\c cxxRecordDecl(hasMethod(hasOverloadedOperatorName(\"*\")))\n/// matches the declaration of \\c A.\n///\n/// Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>\ninline internal::PolymorphicMatcher<\n    internal::HasOverloadedOperatorNameMatcher,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXOperatorCallExpr, FunctionDecl),\n    std::vector<std::string>>\nhasOverloadedOperatorName(StringRef Name) {\n  return internal::PolymorphicMatcher<\n      internal::HasOverloadedOperatorNameMatcher,\n      AST_POLYMORPHIC_SUPPORTED_TYPES(CXXOperatorCallExpr, FunctionDecl),\n      std::vector<std::string>>({std::string(Name)});\n}\n\n/// Matches overloaded operator names.\n///\n/// Matches overloaded operator names specified in strings without the\n/// \"operator\" prefix: e.g. \"<<\".\n///\n///   hasAnyOverloadedOperatorName(\"+\", \"-\")\n/// Is equivalent to\n///   anyOf(hasOverloadedOperatorName(\"+\"), hasOverloadedOperatorName(\"-\"))\nextern const internal::VariadicFunction<\n    internal::PolymorphicMatcher<internal::HasOverloadedOperatorNameMatcher,\n                                 AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                     CXXOperatorCallExpr, FunctionDecl),\n                                 std::vector<std::string>>,\n    StringRef, internal::hasAnyOverloadedOperatorNameFunc>\n    hasAnyOverloadedOperatorName;\n\n/// Matches template-dependent, but known, member names.\n///\n/// In template declarations, dependent members are not resolved and so can\n/// not be matched to particular named declarations.\n///\n/// This matcher allows to match on the known name of members.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   struct S {\n///       void mem();\n///   };\n///   template <typename T>\n///   void x() {\n///       S<T> s;\n///       s.mem();\n///   }\n/// \\endcode\n/// \\c cxxDependentScopeMemberExpr(hasMemberName(\"mem\")) matches `s.mem()`\nAST_MATCHER_P(CXXDependentScopeMemberExpr, hasMemberName, std::string, N) {\n  return Node.getMember().getAsString() == N;\n}\n\n/// Matches template-dependent, but known, member names against an already-bound\n/// node\n///\n/// In template declarations, dependent members are not resolved and so can\n/// not be matched to particular named declarations.\n///\n/// This matcher allows to match on the name of already-bound VarDecl, FieldDecl\n/// and CXXMethodDecl nodes.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   struct S {\n///       void mem();\n///   };\n///   template <typename T>\n///   void x() {\n///       S<T> s;\n///       s.mem();\n///   }\n/// \\endcode\n/// The matcher\n/// @code\n/// \\c cxxDependentScopeMemberExpr(\n///   hasObjectExpression(declRefExpr(hasType(templateSpecializationType(\n///       hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(\n///           cxxMethodDecl(hasName(\"mem\")).bind(\"templMem\")\n///           )))))\n///       )))),\n///   memberHasSameNameAsBoundNode(\"templMem\")\n///   )\n/// @endcode\n/// first matches and binds the @c mem member of the @c S template, then\n/// compares its name to the usage in @c s.mem() in the @c x function template\nAST_MATCHER_P(CXXDependentScopeMemberExpr, memberHasSameNameAsBoundNode,\n              std::string, BindingID) {\n  auto MemberName = Node.getMember().getAsString();\n\n  return Builder->removeBindings(\n      [this, MemberName](const BoundNodesMap &Nodes) {\n        const auto &BN = Nodes.getNode(this->BindingID);\n        if (const auto *ND = BN.get<NamedDecl>()) {\n          if (!isa<FieldDecl, CXXMethodDecl, VarDecl>(ND))\n            return true;\n          return ND->getName() != MemberName;\n        }\n        return true;\n      });\n}\n\n/// Matches C++ classes that are directly or indirectly derived from a class\n/// matching \\c Base, or Objective-C classes that directly or indirectly\n/// subclass a class matching \\c Base.\n///\n/// Note that a class is not considered to be derived from itself.\n///\n/// Example matches Y, Z, C (Base == hasName(\"X\"))\n/// \\code\n///   class X;\n///   class Y : public X {};  // directly derived\n///   class Z : public Y {};  // indirectly derived\n///   typedef X A;\n///   typedef A B;\n///   class C : public B {};  // derived from a typedef of X\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"X\")):\n/// \\code\n///   class Foo;\n///   typedef Foo X;\n///   class Bar : public Foo {};  // derived from a type that X is a typedef of\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"NSObject\"))\n/// \\code\n///   @interface NSObject @end\n///   @interface Bar : NSObject @end\n/// \\endcode\n///\n/// Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>\nAST_POLYMORPHIC_MATCHER_P(\n    isDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base) {\n  // Check if the node is a C++ struct/union/class.\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Finder->classIsDerivedFrom(RD, Base, Builder, /*Directly=*/false);\n\n  // The node must be an Objective-C class.\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Finder->objcClassIsDerivedFrom(InterfaceDecl, Base, Builder,\n                                        /*Directly=*/false);\n}\n\n/// Overloaded method as shortcut for \\c isDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n\n  const auto M = isDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Matches C++ classes that have a direct or indirect base matching \\p\n/// BaseSpecMatcher.\n///\n/// Example:\n/// matcher hasAnyBase(hasType(cxxRecordDecl(hasName(\"SpecialBase\"))))\n/// \\code\n///   class Foo;\n///   class Bar : Foo {};\n///   class Baz : Bar {};\n///   class SpecialBase;\n///   class Proxy : SpecialBase {};  // matches Proxy\n///   class IndirectlyDerived : Proxy {};  //matches IndirectlyDerived\n/// \\endcode\n///\n// FIXME: Refactor this and isDerivedFrom to reuse implementation.\nAST_MATCHER_P(CXXRecordDecl, hasAnyBase, internal::Matcher<CXXBaseSpecifier>,\n              BaseSpecMatcher) {\n  return internal::matchesAnyBase(Node, BaseSpecMatcher, Finder, Builder);\n}\n\n/// Matches C++ classes that have a direct base matching \\p BaseSpecMatcher.\n///\n/// Example:\n/// matcher hasDirectBase(hasType(cxxRecordDecl(hasName(\"SpecialBase\"))))\n/// \\code\n///   class Foo;\n///   class Bar : Foo {};\n///   class Baz : Bar {};\n///   class SpecialBase;\n///   class Proxy : SpecialBase {};  // matches Proxy\n///   class IndirectlyDerived : Proxy {};  // doesn't match\n/// \\endcode\nAST_MATCHER_P(CXXRecordDecl, hasDirectBase, internal::Matcher<CXXBaseSpecifier>,\n              BaseSpecMatcher) {\n  return Node.hasDefinition() &&\n         llvm::any_of(Node.bases(), [&](const CXXBaseSpecifier &Base) {\n           return BaseSpecMatcher.matches(Base, Finder, Builder);\n         });\n}\n\n/// Similar to \\c isDerivedFrom(), but also matches classes that directly\n/// match \\c Base.\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isSameOrDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base, 0) {\n  const auto M = anyOf(Base, isDerivedFrom(Base));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Overloaded method as shortcut for\n/// \\c isSameOrDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isSameOrDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n\n  const auto M = isSameOrDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Matches C++ or Objective-C classes that are directly derived from a class\n/// matching \\c Base.\n///\n/// Note that a class is not considered to be derived from itself.\n///\n/// Example matches Y, C (Base == hasName(\"X\"))\n/// \\code\n///   class X;\n///   class Y : public X {};  // directly derived\n///   class Z : public Y {};  // indirectly derived\n///   typedef X A;\n///   typedef A B;\n///   class C : public B {};  // derived from a typedef of X\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"X\")):\n/// \\code\n///   class Foo;\n///   typedef Foo X;\n///   class Bar : public Foo {};  // derived from a type that X is a typedef of\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDirectlyDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base, 0) {\n  // Check if the node is a C++ struct/union/class.\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Finder->classIsDerivedFrom(RD, Base, Builder, /*Directly=*/true);\n\n  // The node must be an Objective-C class.\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Finder->objcClassIsDerivedFrom(InterfaceDecl, Base, Builder,\n                                        /*Directly=*/true);\n}\n\n/// Overloaded method as shortcut for \\c isDirectlyDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDirectlyDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n  const auto M = isDirectlyDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n/// Matches the first method of a class or struct that satisfies \\c\n/// InnerMatcher.\n///\n/// Given:\n/// \\code\n///   class A { void func(); };\n///   class B { void member(); };\n/// \\endcode\n///\n/// \\c cxxRecordDecl(hasMethod(hasName(\"func\"))) matches the declaration of\n/// \\c A but not \\c B.\nAST_MATCHER_P(CXXRecordDecl, hasMethod, internal::Matcher<CXXMethodDecl>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result(*Builder);\n  auto MatchIt = matchesFirstInPointerRange(InnerMatcher, Node.method_begin(),\n                                            Node.method_end(), Finder, &Result);\n  if (MatchIt == Node.method_end())\n    return false;\n\n  if (Finder->isTraversalIgnoringImplicitNodes() && (*MatchIt)->isImplicit())\n    return false;\n  *Builder = std::move(Result);\n  return true;\n}\n\n/// Matches the generated class of lambda expressions.\n///\n/// Given:\n/// \\code\n///   auto x = []{};\n/// \\endcode\n///\n/// \\c cxxRecordDecl(isLambda()) matches the implicit class declaration of\n/// \\c decltype(x)\nAST_MATCHER(CXXRecordDecl, isLambda) {\n  return Node.isLambda();\n}\n\n/// Matches AST nodes that have child AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y\n///   (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(\"X\")))\n/// \\code\n///   class X {};  // Matches X, because X::X is a class of name X inside X.\n///   class Y { class X {}; };\n///   class Z { class Y { class X {}; }; };  // Does not match Z.\n/// \\endcode\n///\n/// ChildT must be an AST base type.\n///\n/// Usable as: Any Matcher\n/// Note that has is direct matcher, so it also matches things like implicit\n/// casts and paren casts. If you are matching with expr then you should\n/// probably consider using ignoringParenImpCasts like:\n/// has(ignoringParenImpCasts(expr())).\nextern const internal::ArgumentAdaptingMatcherFunc<internal::HasMatcher> has;\n\n/// Matches AST nodes that have descendant AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y, Z\n///     (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(\"X\")))))\n/// \\code\n///   class X {};  // Matches X, because X::X is a class of name X inside X.\n///   class Y { class X {}; };\n///   class Z { class Y { class X {}; }; };\n/// \\endcode\n///\n/// DescendantT must be an AST base type.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasDescendantMatcher>\n    hasDescendant;\n\n/// Matches AST nodes that have child AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y, Y::X, Z::Y, Z::Y::X\n///   (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(\"X\")))\n/// \\code\n///   class X {};\n///   class Y { class X {}; };  // Matches Y, because Y::X is a class of name X\n///                             // inside Y.\n///   class Z { class Y { class X {}; }; };  // Does not match Z.\n/// \\endcode\n///\n/// ChildT must be an AST base type.\n///\n/// As opposed to 'has', 'forEach' will cause a match for each result that\n/// matches instead of only on the first one.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<internal::ForEachMatcher>\n    forEach;\n\n/// Matches AST nodes that have descendant AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, A, A::X, B, B::C, B::C::X\n///   (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(\"X\")))))\n/// \\code\n///   class X {};\n///   class A { class X {}; };  // Matches A, because A::X is a class of name\n///                             // X inside A.\n///   class B { class C { class X {}; }; };\n/// \\endcode\n///\n/// DescendantT must be an AST base type.\n///\n/// As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for\n/// each result that matches instead of only on the first one.\n///\n/// Note: Recursively combined ForEachDescendant can cause many matches:\n///   cxxRecordDecl(forEachDescendant(cxxRecordDecl(\n///     forEachDescendant(cxxRecordDecl())\n///   )))\n/// will match 10 times (plus injected class name matches) on:\n/// \\code\n///   class A { class B { class C { class D { class E {}; }; }; }; };\n/// \\endcode\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::ForEachDescendantMatcher>\n    forEachDescendant;\n\n/// Matches if the node or any descendant matches.\n///\n/// Generates results for each match.\n///\n/// For example, in:\n/// \\code\n///   class A { class B {}; class C {}; };\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(hasName(\"::A\"),\n///                 findAll(cxxRecordDecl(isDefinition()).bind(\"m\")))\n/// \\endcode\n/// will generate results for \\c A, \\c B and \\c C.\n///\n/// Usable as: Any Matcher\ntemplate <typename T>\ninternal::Matcher<T> findAll(const internal::Matcher<T> &Matcher) {\n  return eachOf(Matcher, forEachDescendant(Matcher));\n}\n\n/// Matches AST nodes that have a parent that matches the provided\n/// matcher.\n///\n/// Given\n/// \\code\n/// void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }\n/// \\endcode\n/// \\c compoundStmt(hasParent(ifStmt())) matches \"{ int x = 43; }\".\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasParentMatcher,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc, Attr>,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc, Attr>>\n    hasParent;\n\n/// Matches AST nodes that have an ancestor that matches the provided\n/// matcher.\n///\n/// Given\n/// \\code\n/// void f() { if (true) { int x = 42; } }\n/// void g() { for (;;) { int x = 43; } }\n/// \\endcode\n/// \\c expr(integerLiteral(hasAncestor(ifStmt()))) matches \\c 42, but not 43.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasAncestorMatcher,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc, Attr>,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc, Attr>>\n    hasAncestor;\n\n/// Matches if the provided matcher does not match.\n///\n/// Example matches Y (matcher = cxxRecordDecl(unless(hasName(\"X\"))))\n/// \\code\n///   class X {};\n///   class Y {};\n/// \\endcode\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<1, 1> unless;\n\n/// Matches a node if the declaration associated with that node\n/// matches the given matcher.\n///\n/// The associated declaration is:\n/// - for type nodes, the declaration of the underlying type\n/// - for CallExpr, the declaration of the callee\n/// - for MemberExpr, the declaration of the referenced member\n/// - for CXXConstructExpr, the declaration of the constructor\n/// - for CXXNewExpr, the declaration of the operator new\n/// - for ObjCIvarExpr, the declaration of the ivar\n///\n/// For type nodes, hasDeclaration will generally match the declaration of the\n/// sugared type. Given\n/// \\code\n///   class X {};\n///   typedef X Y;\n///   Y y;\n/// \\endcode\n/// in varDecl(hasType(hasDeclaration(decl()))) the decl will match the\n/// typedefDecl. A common use case is to match the underlying, desugared type.\n/// This can be achieved by using the hasUnqualifiedDesugaredType matcher:\n/// \\code\n///   varDecl(hasType(hasUnqualifiedDesugaredType(\n///       recordType(hasDeclaration(decl())))))\n/// \\endcode\n/// In this matcher, the decl will match the CXXRecordDecl of class X.\n///\n/// Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,\n///   Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,\n///   Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,\n///   Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,\n///   Matcher<TagType>, Matcher<TemplateSpecializationType>,\n///   Matcher<TemplateTypeParmType>, Matcher<TypedefType>,\n///   Matcher<UnresolvedUsingType>\ninline internal::PolymorphicMatcher<\n    internal::HasDeclarationMatcher,\n    void(internal::HasDeclarationSupportedTypes), internal::Matcher<Decl>>\nhasDeclaration(const internal::Matcher<Decl> &InnerMatcher) {\n  return internal::PolymorphicMatcher<\n      internal::HasDeclarationMatcher,\n      void(internal::HasDeclarationSupportedTypes), internal::Matcher<Decl>>(\n      InnerMatcher);\n}\n\n/// Matches a \\c NamedDecl whose underlying declaration matches the given\n/// matcher.\n///\n/// Given\n/// \\code\n///   namespace N { template<class T> void f(T t); }\n///   template <class T> void g() { using N::f; f(T()); }\n/// \\endcode\n/// \\c unresolvedLookupExpr(hasAnyDeclaration(\n///     namedDecl(hasUnderlyingDecl(hasName(\"::N::f\")))))\n///   matches the use of \\c f in \\c g() .\nAST_MATCHER_P(NamedDecl, hasUnderlyingDecl, internal::Matcher<NamedDecl>,\n              InnerMatcher) {\n  const NamedDecl *UnderlyingDecl = Node.getUnderlyingDecl();\n\n  return UnderlyingDecl != nullptr &&\n         InnerMatcher.matches(*UnderlyingDecl, Finder, Builder);\n}\n\n/// Matches on the implicit object argument of a member call expression, after\n/// stripping off any parentheses or implicit casts.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   Y g();\n///   class X : public Y {};\n///   void z(Y y, X x) { y.m(); (g()).m(); x.m(); }\n/// \\endcode\n/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()` and `(g()).m()`.\n/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.m()`.\n/// cxxMemberCallExpr(on(callExpr()))\n///   matches `(g()).m()`.\n///\n/// FIXME: Overload to allow directly matching types?\nAST_MATCHER_P(CXXMemberCallExpr, on, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *ExprNode = Node.getImplicitObjectArgument()\n                            ->IgnoreParenImpCasts();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n\n/// Matches on the receiver of an ObjectiveC Message expression.\n///\n/// Example\n/// matcher = objCMessageExpr(hasReceiverType(asString(\"UIWebView *\")));\n/// matches the [webView ...] message invocation.\n/// \\code\n///   NSString *webViewJavaScript = ...\n///   UIWebView *webView = ...\n///   [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, hasReceiverType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  const QualType TypeDecl = Node.getReceiverType();\n  return InnerMatcher.matches(TypeDecl, Finder, Builder);\n}\n\n/// Returns true when the Objective-C method declaration is a class method.\n///\n/// Example\n/// matcher = objcMethodDecl(isClassMethod())\n/// matches\n/// \\code\n/// @interface I + (void)foo; @end\n/// \\endcode\n/// but not\n/// \\code\n/// @interface I - (void)bar; @end\n/// \\endcode\nAST_MATCHER(ObjCMethodDecl, isClassMethod) {\n  return Node.isClassMethod();\n}\n\n/// Returns true when the Objective-C method declaration is an instance method.\n///\n/// Example\n/// matcher = objcMethodDecl(isInstanceMethod())\n/// matches\n/// \\code\n/// @interface I - (void)bar; @end\n/// \\endcode\n/// but not\n/// \\code\n/// @interface I + (void)foo; @end\n/// \\endcode\nAST_MATCHER(ObjCMethodDecl, isInstanceMethod) {\n  return Node.isInstanceMethod();\n}\n\n/// Returns true when the Objective-C message is sent to a class.\n///\n/// Example\n/// matcher = objcMessageExpr(isClassMessage())\n/// matches\n/// \\code\n///   [NSString stringWithFormat:@\"format\"];\n/// \\endcode\n/// but not\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, isClassMessage) {\n  return Node.isClassMessage();\n}\n\n/// Returns true when the Objective-C message is sent to an instance.\n///\n/// Example\n/// matcher = objcMessageExpr(isInstanceMessage())\n/// matches\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\n/// but not\n/// \\code\n///   [NSString stringWithFormat:@\"format\"];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, isInstanceMessage) {\n  return Node.isInstanceMessage();\n}\n\n/// Matches if the Objective-C message is sent to an instance,\n/// and the inner matcher matches on that instance.\n///\n/// For example the method call in\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\n/// is matched by\n/// objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(\"x\"))))))\nAST_MATCHER_P(ObjCMessageExpr, hasReceiver, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *ReceiverNode = Node.getInstanceReceiver();\n  return (ReceiverNode != nullptr &&\n          InnerMatcher.matches(*ReceiverNode->IgnoreParenImpCasts(), Finder,\n                               Builder));\n}\n\n/// Matches when BaseName == Selector.getAsString()\n///\n///  matcher = objCMessageExpr(hasSelector(\"loadHTMLString:baseURL:\"));\n///  matches the outer message expr in the code below, but NOT the message\n///  invocation for self.bodyView.\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, hasSelector, std::string, BaseName) {\n  Selector Sel = Node.getSelector();\n  return BaseName == Sel.getAsString();\n}\n\n/// Matches when at least one of the supplied string equals to the\n/// Selector.getAsString()\n///\n///  matcher = objCMessageExpr(hasSelector(\"methodA:\", \"methodB:\"));\n///  matches both of the expressions below:\n/// \\code\n///     [myObj methodA:argA];\n///     [myObj methodB:argB];\n/// \\endcode\nextern const internal::VariadicFunction<internal::Matcher<ObjCMessageExpr>,\n                                        StringRef,\n                                        internal::hasAnySelectorFunc>\n                                        hasAnySelector;\n\n/// Matches ObjC selectors whose name contains\n/// a substring matched by the given RegExp.\n///  matcher = objCMessageExpr(matchesSelector(\"loadHTMLString\\:baseURL?\"));\n///  matches the outer message expr in the code below, but NOT the message\n///  invocation for self.bodyView.\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_REGEX(ObjCMessageExpr, matchesSelector, RegExp) {\n  std::string SelectorString = Node.getSelector().getAsString();\n  return RegExp->match(SelectorString);\n}\n\n/// Matches when the selector is the empty selector\n///\n/// Matches only when the selector of the objCMessageExpr is NULL. This may\n/// represent an error condition in the tree!\nAST_MATCHER(ObjCMessageExpr, hasNullSelector) {\n  return Node.getSelector().isNull();\n}\n\n/// Matches when the selector is a Unary Selector\n///\n///  matcher = objCMessageExpr(matchesSelector(hasUnarySelector());\n///  matches self.bodyView in the code below, but NOT the outer message\n///  invocation of \"loadHTMLString:baseURL:\".\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, hasUnarySelector) {\n  return Node.getSelector().isUnarySelector();\n}\n\n/// Matches when the selector is a keyword selector\n///\n/// objCMessageExpr(hasKeywordSelector()) matches the generated setFrame\n/// message expression in\n///\n/// \\code\n///   UIWebView *webView = ...;\n///   CGRect bodyFrame = webView.frame;\n///   bodyFrame.size.height = self.bodyContentHeight;\n///   webView.frame = bodyFrame;\n///   //     ^---- matches here\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, hasKeywordSelector) {\n  return Node.getSelector().isKeywordSelector();\n}\n\n/// Matches when the selector has the specified number of arguments\n///\n///  matcher = objCMessageExpr(numSelectorArgs(0));\n///  matches self.bodyView in the code below\n///\n///  matcher = objCMessageExpr(numSelectorArgs(2));\n///  matches the invocation of \"loadHTMLString:baseURL:\" but not that\n///  of self.bodyView\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, numSelectorArgs, unsigned, N) {\n  return Node.getSelector().getNumArgs() == N;\n}\n\n/// Matches if the call expression's callee expression matches.\n///\n/// Given\n/// \\code\n///   class Y { void x() { this->x(); x(); Y y; y.x(); } };\n///   void f() { f(); }\n/// \\endcode\n/// callExpr(callee(expr()))\n///   matches this->x(), x(), y.x(), f()\n/// with callee(...)\n///   matching this->x, x, y.x, f respectively\n///\n/// Note: Callee cannot take the more general internal::Matcher<Expr>\n/// because this introduces ambiguous overloads with calls to Callee taking a\n/// internal::Matcher<Decl>, as the matcher hierarchy is purely\n/// implemented in terms of implicit casts.\nAST_MATCHER_P(CallExpr, callee, internal::Matcher<Stmt>,\n              InnerMatcher) {\n  const Expr *ExprNode = Node.getCallee();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n/// Matches 1) if the call expression's callee's declaration matches the\n/// given matcher; or 2) if the Obj-C message expression's callee's method\n/// declaration matches the given matcher.\n///\n/// Example matches y.x() (matcher = callExpr(callee(\n///                                    cxxMethodDecl(hasName(\"x\")))))\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y y; y.x(); }\n/// \\endcode\n///\n/// Example 2. Matches [I foo] with\n/// objcMessageExpr(callee(objcMethodDecl(hasName(\"foo\"))))\n///\n/// \\code\n///   @interface I: NSObject\n///   +(void)foo;\n///   @end\n///   ...\n///   [I foo]\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    callee, AST_POLYMORPHIC_SUPPORTED_TYPES(ObjCMessageExpr, CallExpr),\n    internal::Matcher<Decl>, InnerMatcher, 1) {\n  if (const auto *CallNode = dyn_cast<CallExpr>(&Node))\n    return callExpr(hasDeclaration(InnerMatcher))\n        .matches(Node, Finder, Builder);\n  else {\n    // The dynamic cast below is guaranteed to succeed as there are only 2\n    // supported return types.\n    const auto *MsgNode = cast<ObjCMessageExpr>(&Node);\n    const Decl *DeclNode = MsgNode->getMethodDecl();\n    return (DeclNode != nullptr &&\n            InnerMatcher.matches(*DeclNode, Finder, Builder));\n  }\n}\n\n/// Matches if the expression's or declaration's type matches a type\n/// matcher.\n///\n/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and U (matcher = typedefDecl(hasType(asString(\"int\")))\n///             and friend class X (matcher = friendDecl(hasType(\"X\"))\n///             and public virtual X (matcher = cxxBaseSpecifier(hasType(\n///                                               asString(\"class X\")))\n/// \\code\n///  class X {};\n///  void y(X &x) { x; X z; }\n///  typedef int U;\n///  class Y { friend class X; };\n///  class Z : public virtual X {};\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    hasType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, TypedefNameDecl,\n                                    ValueDecl, CXXBaseSpecifier),\n    internal::Matcher<QualType>, InnerMatcher, 0) {\n  QualType QT = internal::getUnderlyingType(Node);\n  if (!QT.isNull())\n    return InnerMatcher.matches(QT, Finder, Builder);\n  return false;\n}\n\n/// Overloaded to match the declaration of the expression's or value\n/// declaration's type.\n///\n/// In case of a value declaration (for example a variable declaration),\n/// this resolves one layer of indirection. For example, in the value\n/// declaration \"X x;\", cxxRecordDecl(hasName(\"X\")) matches the declaration of\n/// X, while varDecl(hasType(cxxRecordDecl(hasName(\"X\")))) matches the\n/// declaration of x.\n///\n/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and friend class X (matcher = friendDecl(hasType(\"X\"))\n///             and public virtual X (matcher = cxxBaseSpecifier(hasType(\n///                                               cxxRecordDecl(hasName(\"X\"))))\n/// \\code\n///  class X {};\n///  void y(X &x) { x; X z; }\n///  class Y { friend class X; };\n///  class Z : public virtual X {};\n/// \\endcode\n///\n/// Example matches class Derived\n/// (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(\"Base\"))))))\n/// \\code\n/// class Base {};\n/// class Derived : Base {};\n/// \\endcode\n///\n/// Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,\n/// Matcher<CXXBaseSpecifier>\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    hasType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, ValueDecl,\n                                    CXXBaseSpecifier),\n    internal::Matcher<Decl>, InnerMatcher, 1) {\n  QualType QT = internal::getUnderlyingType(Node);\n  if (!QT.isNull())\n    return qualType(hasDeclaration(InnerMatcher)).matches(QT, Finder, Builder);\n  return false;\n}\n\n/// Matches if the type location of a node matches the inner matcher.\n///\n/// Examples:\n/// \\code\n///   int x;\n/// \\endcode\n/// declaratorDecl(hasTypeLoc(loc(asString(\"int\"))))\n///   matches int x\n///\n/// \\code\n/// auto x = int(3);\n/// \\endcode\n/// cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(\"int\"))))\n///   matches int(3)\n///\n/// \\code\n/// struct Foo { Foo(int, int); };\n/// auto x = Foo(1, 2);\n/// \\endcode\n/// cxxFunctionalCastExpr(hasTypeLoc(loc(asString(\"struct Foo\"))))\n///   matches Foo(1, 2)\n///\n/// Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,\n///   Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,\n///   Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,\n///   Matcher<CXXUnresolvedConstructExpr>,\n///   Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,\n///   Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,\n///   Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,\n///   Matcher<TypedefNameDecl>\nAST_POLYMORPHIC_MATCHER_P(\n    hasTypeLoc,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(\n        BlockDecl, CXXBaseSpecifier, CXXCtorInitializer, CXXFunctionalCastExpr,\n        CXXNewExpr, CXXTemporaryObjectExpr, CXXUnresolvedConstructExpr,\n        ClassTemplateSpecializationDecl, CompoundLiteralExpr, DeclaratorDecl,\n        ExplicitCastExpr, ObjCPropertyDecl, TemplateArgumentLoc,\n        TypedefNameDecl),\n    internal::Matcher<TypeLoc>, Inner) {\n  TypeSourceInfo *source = internal::GetTypeSourceInfo(Node);\n  if (source == nullptr) {\n    // This happens for example for implicit destructors.\n    return false;\n  }\n  return Inner.matches(source->getTypeLoc(), Finder, Builder);\n}\n\n/// Matches if the matched type is represented by the given string.\n///\n/// Given\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y* y; y->x(); }\n/// \\endcode\n/// cxxMemberCallExpr(on(hasType(asString(\"class Y *\"))))\n///   matches y->x()\nAST_MATCHER_P(QualType, asString, std::string, Name) {\n  return Name == Node.getAsString();\n}\n\n/// Matches if the matched type is a pointer type and the pointee type\n/// matches the specified matcher.\n///\n/// Example matches y->x()\n///   (matcher = cxxMemberCallExpr(on(hasType(pointsTo\n///      cxxRecordDecl(hasName(\"Y\")))))))\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y *y; y->x(); }\n/// \\endcode\nAST_MATCHER_P(\n    QualType, pointsTo, internal::Matcher<QualType>,\n    InnerMatcher) {\n  return (!Node.isNull() && Node->isAnyPointerType() &&\n          InnerMatcher.matches(Node->getPointeeType(), Finder, Builder));\n}\n\n/// Overloaded to match the pointee type's declaration.\nAST_MATCHER_P_OVERLOAD(QualType, pointsTo, internal::Matcher<Decl>,\n                       InnerMatcher, 1) {\n  return pointsTo(qualType(hasDeclaration(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if the matched type matches the unqualified desugared\n/// type of the matched node.\n///\n/// For example, in:\n/// \\code\n///   class A {};\n///   using B = A;\n/// \\endcode\n/// The matcher type(hasUnqualifiedDesugaredType(recordType())) matches\n/// both B and A.\nAST_MATCHER_P(Type, hasUnqualifiedDesugaredType, internal::Matcher<Type>,\n              InnerMatcher) {\n  return InnerMatcher.matches(*Node.getUnqualifiedDesugaredType(), Finder,\n                              Builder);\n}\n\n/// Matches if the matched type is a reference type and the referenced\n/// type matches the specified matcher.\n///\n/// Example matches X &x and const X &y\n///     (matcher = varDecl(hasType(references(cxxRecordDecl(hasName(\"X\"))))))\n/// \\code\n///   class X {\n///     void a(X b) {\n///       X &x = b;\n///       const X &y = b;\n///     }\n///   };\n/// \\endcode\nAST_MATCHER_P(QualType, references, internal::Matcher<QualType>,\n              InnerMatcher) {\n  return (!Node.isNull() && Node->isReferenceType() &&\n          InnerMatcher.matches(Node->getPointeeType(), Finder, Builder));\n}\n\n/// Matches QualTypes whose canonical type matches InnerMatcher.\n///\n/// Given:\n/// \\code\n///   typedef int &int_ref;\n///   int a;\n///   int_ref b = a;\n/// \\endcode\n///\n/// \\c varDecl(hasType(qualType(referenceType()))))) will not match the\n/// declaration of b but \\c\n/// varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does.\nAST_MATCHER_P(QualType, hasCanonicalType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  if (Node.isNull())\n    return false;\n  return InnerMatcher.matches(Node.getCanonicalType(), Finder, Builder);\n}\n\n/// Overloaded to match the referenced type's declaration.\nAST_MATCHER_P_OVERLOAD(QualType, references, internal::Matcher<Decl>,\n                       InnerMatcher, 1) {\n  return references(qualType(hasDeclaration(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches on the implicit object argument of a member call expression. Unlike\n/// `on`, matches the argument directly without stripping away anything.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   Y g();\n///   class X : public Y { void g(); };\n///   void z(Y y, X x) { y.m(); x.m(); x.g(); (g()).m(); }\n/// \\endcode\n/// cxxMemberCallExpr(onImplicitObjectArgument(hasType(\n///     cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()`, `x.m()` and (g()).m(), but not `x.g()`.\n/// cxxMemberCallExpr(on(callExpr()))\n///   does not match `(g()).m()`, because the parens are not ignored.\n///\n/// FIXME: Overload to allow directly matching types?\nAST_MATCHER_P(CXXMemberCallExpr, onImplicitObjectArgument,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *ExprNode = Node.getImplicitObjectArgument();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n/// Matches if the type of the expression's implicit object argument either\n/// matches the InnerMatcher, or is a pointer to a type that matches the\n/// InnerMatcher.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   class X : public Y { void g(); };\n///   void z() { Y y; y.m(); Y *p; p->m(); X x; x.m(); x.g(); }\n/// \\endcode\n/// cxxMemberCallExpr(thisPointerType(hasDeclaration(\n///     cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()`, `p->m()` and `x.m()`.\n/// cxxMemberCallExpr(thisPointerType(hasDeclaration(\n///     cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.g()`.\nAST_MATCHER_P_OVERLOAD(CXXMemberCallExpr, thisPointerType,\n                       internal::Matcher<QualType>, InnerMatcher, 0) {\n  return onImplicitObjectArgument(\n      anyOf(hasType(InnerMatcher), hasType(pointsTo(InnerMatcher))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Overloaded to match the type's declaration.\nAST_MATCHER_P_OVERLOAD(CXXMemberCallExpr, thisPointerType,\n                       internal::Matcher<Decl>, InnerMatcher, 1) {\n  return onImplicitObjectArgument(\n      anyOf(hasType(InnerMatcher), hasType(pointsTo(InnerMatcher))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches a DeclRefExpr that refers to a declaration that matches the\n/// specified matcher.\n///\n/// Example matches x in if(x)\n///     (matcher = declRefExpr(to(varDecl(hasName(\"x\")))))\n/// \\code\n///   bool x;\n///   if (x) {}\n/// \\endcode\nAST_MATCHER_P(DeclRefExpr, to, internal::Matcher<Decl>,\n              InnerMatcher) {\n  const Decl *DeclNode = Node.getDecl();\n  return (DeclNode != nullptr &&\n          InnerMatcher.matches(*DeclNode, Finder, Builder));\n}\n\n/// Matches if a node refers to a declaration through a specific\n/// using shadow declaration.\n///\n/// Examples:\n/// \\code\n///   namespace a { int f(); }\n///   using a::f;\n///   int x = f();\n/// \\endcode\n/// declRefExpr(throughUsingDecl(anything()))\n///   matches \\c f\n///\n/// \\code\n///   namespace a { class X{}; }\n///   using a::X;\n///   X x;\n/// \\endcode\n/// typeLoc(loc(usingType(throughUsingDecl(anything()))))\n///   matches \\c X\n///\n/// Usable as: Matcher<DeclRefExpr>, Matcher<UsingType>\nAST_POLYMORPHIC_MATCHER_P(throughUsingDecl,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(DeclRefExpr,\n                                                          UsingType),\n                          internal::Matcher<UsingShadowDecl>, Inner) {\n  const NamedDecl *FoundDecl = Node.getFoundDecl();\n  if (const UsingShadowDecl *UsingDecl = dyn_cast<UsingShadowDecl>(FoundDecl))\n    return Inner.matches(*UsingDecl, Finder, Builder);\n  return false;\n}\n\n/// Matches an \\c OverloadExpr if any of the declarations in the set of\n/// overloads matches the given matcher.\n///\n/// Given\n/// \\code\n///   template <typename T> void foo(T);\n///   template <typename T> void bar(T);\n///   template <typename T> void baz(T t) {\n///     foo(t);\n///     bar(t);\n///   }\n/// \\endcode\n/// unresolvedLookupExpr(hasAnyDeclaration(\n///     functionTemplateDecl(hasName(\"foo\"))))\n///   matches \\c foo in \\c foo(t); but not \\c bar in \\c bar(t);\nAST_MATCHER_P(OverloadExpr, hasAnyDeclaration, internal::Matcher<Decl>,\n              InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.decls_begin(),\n                                    Node.decls_end(), Finder,\n                                    Builder) != Node.decls_end();\n}\n\n/// Matches the Decl of a DeclStmt which has a single declaration.\n///\n/// Given\n/// \\code\n///   int a, b;\n///   int c;\n/// \\endcode\n/// declStmt(hasSingleDecl(anything()))\n///   matches 'int c;' but not 'int a, b;'.\nAST_MATCHER_P(DeclStmt, hasSingleDecl, internal::Matcher<Decl>, InnerMatcher) {\n  if (Node.isSingleDecl()) {\n    const Decl *FoundDecl = Node.getSingleDecl();\n    return InnerMatcher.matches(*FoundDecl, Finder, Builder);\n  }\n  return false;\n}\n\n/// Matches a variable declaration that has an initializer expression\n/// that matches the given matcher.\n///\n/// Example matches x (matcher = varDecl(hasInitializer(callExpr())))\n/// \\code\n///   bool y() { return true; }\n///   bool x = y();\n/// \\endcode\nAST_MATCHER_P(\n    VarDecl, hasInitializer, internal::Matcher<Expr>,\n    InnerMatcher) {\n  const Expr *Initializer = Node.getAnyInitializer();\n  return (Initializer != nullptr &&\n          InnerMatcher.matches(*Initializer, Finder, Builder));\n}\n\n/// Matches a variable serving as the implicit variable for a lambda init-\n/// capture.\n///\n/// Example matches x (matcher = varDecl(isInitCapture()))\n/// \\code\n/// auto f = [x=3]() { return x; };\n/// \\endcode\nAST_MATCHER(VarDecl, isInitCapture) { return Node.isInitCapture(); }\n\n/// Matches each lambda capture in a lambda expression.\n///\n/// Given\n/// \\code\n///   int main() {\n///     int x, y;\n///     float z;\n///     auto f = [=]() { return x + y + z; };\n///   }\n/// \\endcode\n/// lambdaExpr(forEachLambdaCapture(\n///     lambdaCapture(capturesVar(varDecl(hasType(isInteger()))))))\n/// will trigger two matches, binding for 'x' and 'y' respectively.\nAST_MATCHER_P(LambdaExpr, forEachLambdaCapture,\n              internal::Matcher<LambdaCapture>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto &Capture : Node.captures()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() && Capture.isImplicit())\n      continue;\n    BoundNodesTreeBuilder CaptureBuilder(*Builder);\n    if (InnerMatcher.matches(Capture, Finder, &CaptureBuilder)) {\n      Matched = true;\n      Result.addMatch(CaptureBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// \\brief Matches a static variable with local scope.\n///\n/// Example matches y (matcher = varDecl(isStaticLocal()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// static int z;\n/// \\endcode\nAST_MATCHER(VarDecl, isStaticLocal) {\n  return Node.isStaticLocal();\n}\n\n/// Matches a variable declaration that has function scope and is a\n/// non-static local variable.\n///\n/// Example matches x (matcher = varDecl(hasLocalStorage())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\nAST_MATCHER(VarDecl, hasLocalStorage) {\n  return Node.hasLocalStorage();\n}\n\n/// Matches a variable declaration that does not have local storage.\n///\n/// Example matches y and z (matcher = varDecl(hasGlobalStorage())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\nAST_MATCHER(VarDecl, hasGlobalStorage) {\n  return Node.hasGlobalStorage();\n}\n\n/// Matches a variable declaration that has automatic storage duration.\n///\n/// Example matches x, but not y, z, or a.\n/// (matcher = varDecl(hasAutomaticStorageDuration())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// \\endcode\nAST_MATCHER(VarDecl, hasAutomaticStorageDuration) {\n  return Node.getStorageDuration() == SD_Automatic;\n}\n\n/// Matches a variable declaration that has static storage duration.\n/// It includes the variable declared at namespace scope and those declared\n/// with \"static\" and \"extern\" storage class specifiers.\n///\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// static int b;\n/// extern int c;\n/// varDecl(hasStaticStorageDuration())\n///   matches the function declaration y, a, b and c.\n/// \\endcode\nAST_MATCHER(VarDecl, hasStaticStorageDuration) {\n  return Node.getStorageDuration() == SD_Static;\n}\n\n/// Matches a variable declaration that has thread storage duration.\n///\n/// Example matches z, but not x, z, or a.\n/// (matcher = varDecl(hasThreadStorageDuration())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// \\endcode\nAST_MATCHER(VarDecl, hasThreadStorageDuration) {\n  return Node.getStorageDuration() == SD_Thread;\n}\n\n/// Matches a variable declaration that is an exception variable from\n/// a C++ catch block, or an Objective-C \\@catch statement.\n///\n/// Example matches x (matcher = varDecl(isExceptionVariable())\n/// \\code\n/// void f(int y) {\n///   try {\n///   } catch (int x) {\n///   }\n/// }\n/// \\endcode\nAST_MATCHER(VarDecl, isExceptionVariable) {\n  return Node.isExceptionVariable();\n}\n\n/// Checks that a call expression or a constructor call expression has\n/// a specific number of arguments (including absent default arguments).\n///\n/// Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2)))\n/// \\code\n///   void f(int x, int y);\n///   f(0, 0);\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(argumentCountIs,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              CallExpr, CXXConstructExpr,\n                              CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                          unsigned, N) {\n  unsigned NumArgs = Node.getNumArgs();\n  if (!Finder->isTraversalIgnoringImplicitNodes())\n    return NumArgs == N;\n  while (NumArgs) {\n    if (!isa<CXXDefaultArgExpr>(Node.getArg(NumArgs - 1)))\n      break;\n    --NumArgs;\n  }\n  return NumArgs == N;\n}\n\n/// Checks that a call expression or a constructor call expression has at least\n/// the specified number of arguments (including absent default arguments).\n///\n/// Example matches f(0, 0) and g(0, 0, 0)\n/// (matcher = callExpr(argumentCountAtLeast(2)))\n/// \\code\n///   void f(int x, int y);\n///   void g(int x, int y, int z);\n///   f(0, 0);\n///   g(0, 0, 0);\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(argumentCountAtLeast,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              CallExpr, CXXConstructExpr,\n                              CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                          unsigned, N) {\n  unsigned NumArgs = Node.getNumArgs();\n  if (!Finder->isTraversalIgnoringImplicitNodes())\n    return NumArgs >= N;\n  while (NumArgs) {\n    if (!isa<CXXDefaultArgExpr>(Node.getArg(NumArgs - 1)))\n      break;\n    --NumArgs;\n  }\n  return NumArgs >= N;\n}\n\n/// Matches the n'th argument of a call expression or a constructor\n/// call expression.\n///\n/// Example matches y in x(y)\n///     (matcher = callExpr(hasArgument(0, declRefExpr())))\n/// \\code\n///   void x(int) { int y; x(y); }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P2(hasArgument,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(\n                               CallExpr, CXXConstructExpr,\n                               CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                           unsigned, N, internal::Matcher<Expr>, InnerMatcher) {\n  if (N >= Node.getNumArgs())\n    return false;\n  const Expr *Arg = Node.getArg(N);\n  if (Finder->isTraversalIgnoringImplicitNodes() && isa<CXXDefaultArgExpr>(Arg))\n    return false;\n  return InnerMatcher.matches(*Arg->IgnoreParenImpCasts(), Finder, Builder);\n}\n\n/// Matches the n'th item of an initializer list expression.\n///\n/// Example matches y.\n///     (matcher = initListExpr(hasInit(0, expr())))\n/// \\code\n///   int x{y}.\n/// \\endcode\nAST_MATCHER_P2(InitListExpr, hasInit, unsigned, N,\n               ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  return N < Node.getNumInits() &&\n          InnerMatcher.matches(*Node.getInit(N), Finder, Builder);\n}\n\n/// Matches declaration statements that contain a specific number of\n/// declarations.\n///\n/// Example: Given\n/// \\code\n///   int a, b;\n///   int c;\n///   int d = 2, e;\n/// \\endcode\n/// declCountIs(2)\n///   matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'.\nAST_MATCHER_P(DeclStmt, declCountIs, unsigned, N) {\n  return std::distance(Node.decl_begin(), Node.decl_end()) == (ptrdiff_t)N;\n}\n\n/// Matches the n'th declaration of a declaration statement.\n///\n/// Note that this does not work for global declarations because the AST\n/// breaks up multiple-declaration DeclStmt's into multiple single-declaration\n/// DeclStmt's.\n/// Example: Given non-global declarations\n/// \\code\n///   int a, b = 0;\n///   int c;\n///   int d = 2, e;\n/// \\endcode\n/// declStmt(containsDeclaration(\n///       0, varDecl(hasInitializer(anything()))))\n///   matches only 'int d = 2, e;', and\n/// declStmt(containsDeclaration(1, varDecl()))\n/// \\code\n///   matches 'int a, b = 0' as well as 'int d = 2, e;'\n///   but 'int c;' is not matched.\n/// \\endcode\nAST_MATCHER_P2(DeclStmt, containsDeclaration, unsigned, N,\n               internal::Matcher<Decl>, InnerMatcher) {\n  const unsigned NumDecls = std::distance(Node.decl_begin(), Node.decl_end());\n  if (N >= NumDecls)\n    return false;\n  DeclStmt::const_decl_iterator Iterator = Node.decl_begin();\n  std::advance(Iterator, N);\n  return InnerMatcher.matches(**Iterator, Finder, Builder);\n}\n\n/// Matches a C++ catch statement that has a catch-all handler.\n///\n/// Given\n/// \\code\n///   try {\n///     // ...\n///   } catch (int) {\n///     // ...\n///   } catch (...) {\n///     // ...\n///   }\n/// \\endcode\n/// cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int).\nAST_MATCHER(CXXCatchStmt, isCatchAll) {\n  return Node.getExceptionDecl() == nullptr;\n}\n\n/// Matches a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(\n///   hasAnyConstructorInitializer(anything())\n/// )))\n///   record matches Foo, hasAnyConstructorInitializer matches foo_(1)\nAST_MATCHER_P(CXXConstructorDecl, hasAnyConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  auto MatchIt = matchesFirstInPointerRange(InnerMatcher, Node.init_begin(),\n                                            Node.init_end(), Finder, Builder);\n  if (MatchIt == Node.init_end())\n    return false;\n  return (*MatchIt)->isWritten() || !Finder->isTraversalIgnoringImplicitNodes();\n}\n\n/// Matches the field declaration of a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(\n///     forField(hasName(\"foo_\"))))))\n///   matches Foo\n/// with forField matching foo_\nAST_MATCHER_P(CXXCtorInitializer, forField,\n              internal::Matcher<FieldDecl>, InnerMatcher) {\n  const FieldDecl *NodeAsDecl = Node.getAnyMember();\n  return (NodeAsDecl != nullptr &&\n      InnerMatcher.matches(*NodeAsDecl, Finder, Builder));\n}\n\n/// Matches the initializer expression of a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(\n///     withInitializer(integerLiteral(equals(1)))))))\n///   matches Foo\n/// with withInitializer matching (1)\nAST_MATCHER_P(CXXCtorInitializer, withInitializer,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr* NodeAsExpr = Node.getInit();\n  return (NodeAsExpr != nullptr &&\n      InnerMatcher.matches(*NodeAsExpr, Finder, Builder));\n}\n\n/// Matches a constructor initializer if it is explicitly written in\n/// code (as opposed to implicitly added by the compiler).\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() { }\n///     Foo(int) : foo_(\"A\") { }\n///     string foo_;\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isWritten()))\n///   will match Foo(int), but not Foo()\nAST_MATCHER(CXXCtorInitializer, isWritten) {\n  return Node.isWritten();\n}\n\n/// Matches a constructor initializer if it is initializing a base, as\n/// opposed to a member.\n///\n/// Given\n/// \\code\n///   struct B {};\n///   struct D : B {\n///     int I;\n///     D(int i) : I(i) {}\n///   };\n///   struct E : B {\n///     E() : B() {}\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer()))\n///   will match E(), but not match D(int).\nAST_MATCHER(CXXCtorInitializer, isBaseInitializer) {\n  return Node.isBaseInitializer();\n}\n\n/// Matches a constructor initializer if it is initializing a member, as\n/// opposed to a base.\n///\n/// Given\n/// \\code\n///   struct B {};\n///   struct D : B {\n///     int I;\n///     D(int i) : I(i) {}\n///   };\n///   struct E : B {\n///     E() : B() {}\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer()))\n///   will match D(int), but not match E().\nAST_MATCHER(CXXCtorInitializer, isMemberInitializer) {\n  return Node.isMemberInitializer();\n}\n\n/// Matches any argument of a call expression or a constructor call\n/// expression, or an ObjC-message-send expression.\n///\n/// Given\n/// \\code\n///   void x(int, int, int) { int y; x(1, y, 42); }\n/// \\endcode\n/// callExpr(hasAnyArgument(declRefExpr()))\n///   matches x(1, y, 42)\n/// with hasAnyArgument(...)\n///   matching y\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n///   void foo(I *i) { [i f:12]; }\n/// \\endcode\n/// objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))\n///   matches [i f:12]\nAST_POLYMORPHIC_MATCHER_P(hasAnyArgument,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              CallExpr, CXXConstructExpr,\n                              CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  for (const Expr *Arg : Node.arguments()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() &&\n        isa<CXXDefaultArgExpr>(Arg))\n      break;\n    BoundNodesTreeBuilder Result(*Builder);\n    if (InnerMatcher.matches(*Arg, Finder, &Result)) {\n      *Builder = std::move(Result);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Matches lambda captures.\n///\n/// Given\n/// \\code\n///   int main() {\n///     int x;\n///     auto f = [x](){};\n///     auto g = [x = 1](){};\n///   }\n/// \\endcode\n/// In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,\n/// `lambdaCapture()` matches `x` and `x=1`.\nextern const internal::VariadicAllOfMatcher<LambdaCapture> lambdaCapture;\n\n/// Matches any capture in a lambda expression.\n///\n/// Given\n/// \\code\n///   void foo() {\n///     int t = 5;\n///     auto f = [=](){ return t; };\n///   }\n/// \\endcode\n/// lambdaExpr(hasAnyCapture(lambdaCapture())) and\n/// lambdaExpr(hasAnyCapture(lambdaCapture(refersToVarDecl(hasName(\"t\")))))\n///   both match `[=](){ return t; }`.\nAST_MATCHER_P(LambdaExpr, hasAnyCapture, internal::Matcher<LambdaCapture>,\n              InnerMatcher) {\n  for (const LambdaCapture &Capture : Node.captures()) {\n    clang::ast_matchers::internal::BoundNodesTreeBuilder Result(*Builder);\n    if (InnerMatcher.matches(Capture, Finder, &Result)) {\n      *Builder = std::move(Result);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Matches a `LambdaCapture` that refers to the specified `VarDecl`. The\n/// `VarDecl` can be a separate variable that is captured by value or\n/// reference, or a synthesized variable if the capture has an initializer.\n///\n/// Given\n/// \\code\n///   void foo() {\n///     int x;\n///     auto f = [x](){};\n///     auto g = [x = 1](){};\n///   }\n/// \\endcode\n/// In the matcher\n/// lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(\"x\")))),\n/// capturesVar(hasName(\"x\")) matches `x` and `x = 1`.\nAST_MATCHER_P(LambdaCapture, capturesVar, internal::Matcher<ValueDecl>,\n              InnerMatcher) {\n  auto *capturedVar = Node.getCapturedVar();\n  return capturedVar && InnerMatcher.matches(*capturedVar, Finder, Builder);\n}\n\n/// Matches a `LambdaCapture` that refers to 'this'.\n///\n/// Given\n/// \\code\n/// class C {\n///   int cc;\n///   int f() {\n///     auto l = [this]() { return cc; };\n///     return l();\n///   }\n/// };\n/// \\endcode\n/// lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis())))\n///   matches `[this]() { return cc; }`.\nAST_MATCHER(LambdaCapture, capturesThis) { return Node.capturesThis(); }\n\n/// Matches a constructor call expression which uses list initialization.\nAST_MATCHER(CXXConstructExpr, isListInitialization) {\n  return Node.isListInitialization();\n}\n\n/// Matches a constructor call expression which requires\n/// zero initialization.\n///\n/// Given\n/// \\code\n/// void foo() {\n///   struct point { double x; double y; };\n///   point pt[2] = { { 1.0, 2.0 } };\n/// }\n/// \\endcode\n/// initListExpr(has(cxxConstructExpr(requiresZeroInitialization()))\n/// will match the implicit array filler for pt[1].\nAST_MATCHER(CXXConstructExpr, requiresZeroInitialization) {\n  return Node.requiresZeroInitialization();\n}\n\n/// Matches the n'th parameter of a function or an ObjC method\n/// declaration or a block.\n///\n/// Given\n/// \\code\n///   class X { void f(int x) {} };\n/// \\endcode\n/// cxxMethodDecl(hasParameter(0, hasType(varDecl())))\n///   matches f(int x) {}\n/// with hasParameter(...)\n///   matching int x\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n/// \\endcode\n//\n/// the matcher objcMethodDecl(hasParameter(0, hasName(\"y\")))\n/// matches the declaration of method f with hasParameter\n/// matching y.\nAST_POLYMORPHIC_MATCHER_P2(hasParameter,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                           ObjCMethodDecl,\n                                                           BlockDecl),\n                           unsigned, N, internal::Matcher<ParmVarDecl>,\n                           InnerMatcher) {\n  return (N < Node.parameters().size()\n          && InnerMatcher.matches(*Node.parameters()[N], Finder, Builder));\n}\n\n/// Matches all arguments and their respective ParmVarDecl.\n///\n/// Given\n/// \\code\n///   void f(int i);\n///   int y;\n///   f(y);\n/// \\endcode\n/// callExpr(\n///   forEachArgumentWithParam(\n///     declRefExpr(to(varDecl(hasName(\"y\")))),\n///     parmVarDecl(hasType(isInteger()))\n/// ))\n///   matches f(y);\n/// with declRefExpr(...)\n///   matching int y\n/// and parmVarDecl(...)\n///   matching int i\nAST_POLYMORPHIC_MATCHER_P2(forEachArgumentWithParam,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,\n                                                           CXXConstructExpr),\n                           internal::Matcher<Expr>, ArgMatcher,\n                           internal::Matcher<ParmVarDecl>, ParamMatcher) {\n  BoundNodesTreeBuilder Result;\n  // The first argument of an overloaded member operator is the implicit object\n  // argument of the method which should not be matched against a parameter, so\n  // we skip over it here.\n  BoundNodesTreeBuilder Matches;\n  unsigned ArgIndex = cxxOperatorCallExpr(callee(cxxMethodDecl()))\n                              .matches(Node, Finder, &Matches)\n                          ? 1\n                          : 0;\n  int ParamIndex = 0;\n  bool Matched = false;\n  for (; ArgIndex < Node.getNumArgs(); ++ArgIndex) {\n    BoundNodesTreeBuilder ArgMatches(*Builder);\n    if (ArgMatcher.matches(*(Node.getArg(ArgIndex)->IgnoreParenCasts()),\n                           Finder, &ArgMatches)) {\n      BoundNodesTreeBuilder ParamMatches(ArgMatches);\n      if (expr(anyOf(cxxConstructExpr(hasDeclaration(cxxConstructorDecl(\n                         hasParameter(ParamIndex, ParamMatcher)))),\n                     callExpr(callee(functionDecl(\n                         hasParameter(ParamIndex, ParamMatcher))))))\n              .matches(Node, Finder, &ParamMatches)) {\n        Result.addMatch(ParamMatches);\n        Matched = true;\n      }\n    }\n    ++ParamIndex;\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches all arguments and their respective types for a \\c CallExpr or\n/// \\c CXXConstructExpr. It is very similar to \\c forEachArgumentWithParam but\n/// it works on calls through function pointers as well.\n///\n/// The difference is, that function pointers do not provide access to a\n/// \\c ParmVarDecl, but only the \\c QualType for each argument.\n///\n/// Given\n/// \\code\n///   void f(int i);\n///   int y;\n///   f(y);\n///   void (*f_ptr)(int) = f;\n///   f_ptr(y);\n/// \\endcode\n/// callExpr(\n///   forEachArgumentWithParamType(\n///     declRefExpr(to(varDecl(hasName(\"y\")))),\n///     qualType(isInteger()).bind(\"type)\n/// ))\n///   matches f(y) and f_ptr(y)\n/// with declRefExpr(...)\n///   matching int y\n/// and qualType(...)\n///   matching int\nAST_POLYMORPHIC_MATCHER_P2(forEachArgumentWithParamType,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,\n                                                           CXXConstructExpr),\n                           internal::Matcher<Expr>, ArgMatcher,\n                           internal::Matcher<QualType>, ParamMatcher) {\n  BoundNodesTreeBuilder Result;\n  // The first argument of an overloaded member operator is the implicit object\n  // argument of the method which should not be matched against a parameter, so\n  // we skip over it here.\n  BoundNodesTreeBuilder Matches;\n  unsigned ArgIndex = cxxOperatorCallExpr(callee(cxxMethodDecl()))\n                              .matches(Node, Finder, &Matches)\n                          ? 1\n                          : 0;\n\n  const FunctionProtoType *FProto = nullptr;\n\n  if (const auto *Call = dyn_cast<CallExpr>(&Node)) {\n    if (const auto *Value =\n            dyn_cast_or_null<ValueDecl>(Call->getCalleeDecl())) {\n      QualType QT = Value->getType().getCanonicalType();\n\n      // This does not necessarily lead to a `FunctionProtoType`,\n      // e.g. K&R functions do not have a function prototype.\n      if (QT->isFunctionPointerType())\n        FProto = QT->getPointeeType()->getAs<FunctionProtoType>();\n\n      if (QT->isMemberFunctionPointerType()) {\n        const auto *MP = QT->getAs<MemberPointerType>();\n        assert(MP && \"Must be member-pointer if its a memberfunctionpointer\");\n        FProto = MP->getPointeeType()->getAs<FunctionProtoType>();\n        assert(FProto &&\n               \"The call must have happened through a member function \"\n               \"pointer\");\n      }\n    }\n  }\n\n  unsigned ParamIndex = 0;\n  bool Matched = false;\n  unsigned NumArgs = Node.getNumArgs();\n  if (FProto && FProto->isVariadic())\n    NumArgs = std::min(NumArgs, FProto->getNumParams());\n\n  for (; ArgIndex < NumArgs; ++ArgIndex, ++ParamIndex) {\n    BoundNodesTreeBuilder ArgMatches(*Builder);\n    if (ArgMatcher.matches(*(Node.getArg(ArgIndex)->IgnoreParenCasts()), Finder,\n                           &ArgMatches)) {\n      BoundNodesTreeBuilder ParamMatches(ArgMatches);\n\n      // This test is cheaper compared to the big matcher in the next if.\n      // Therefore, please keep this order.\n      if (FProto && FProto->getNumParams() > ParamIndex) {\n        QualType ParamType = FProto->getParamType(ParamIndex);\n        if (ParamMatcher.matches(ParamType, Finder, &ParamMatches)) {\n          Result.addMatch(ParamMatches);\n          Matched = true;\n          continue;\n        }\n      }\n      if (expr(anyOf(cxxConstructExpr(hasDeclaration(cxxConstructorDecl(\n                         hasParameter(ParamIndex, hasType(ParamMatcher))))),\n                     callExpr(callee(functionDecl(\n                         hasParameter(ParamIndex, hasType(ParamMatcher)))))))\n              .matches(Node, Finder, &ParamMatches)) {\n        Result.addMatch(ParamMatches);\n        Matched = true;\n        continue;\n      }\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches the ParmVarDecl nodes that are at the N'th position in the parameter\n/// list. The parameter list could be that of either a block, function, or\n/// objc-method.\n///\n///\n/// Given\n///\n/// \\code\n/// void f(int a, int b, int c) {\n/// }\n/// \\endcode\n///\n/// ``parmVarDecl(isAtPosition(0))`` matches ``int a``.\n///\n/// ``parmVarDecl(isAtPosition(1))`` matches ``int b``.\nAST_MATCHER_P(ParmVarDecl, isAtPosition, unsigned, N) {\n  const clang::DeclContext *Context = Node.getParentFunctionOrMethod();\n\n  if (const auto *Decl = dyn_cast_or_null<FunctionDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n  if (const auto *Decl = dyn_cast_or_null<BlockDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n  if (const auto *Decl = dyn_cast_or_null<ObjCMethodDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n\n  return false;\n}\n\n/// Matches any parameter of a function or an ObjC method declaration or a\n/// block.\n///\n/// Does not match the 'this' parameter of a method.\n///\n/// Given\n/// \\code\n///   class X { void f(int x, int y, int z) {} };\n/// \\endcode\n/// cxxMethodDecl(hasAnyParameter(hasName(\"y\")))\n///   matches f(int x, int y, int z) {}\n/// with hasAnyParameter(...)\n///   matching int y\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n/// \\endcode\n//\n/// the matcher objcMethodDecl(hasAnyParameter(hasName(\"y\")))\n/// matches the declaration of method f with hasParameter\n/// matching y.\n///\n/// For blocks, given\n/// \\code\n///   b = ^(int y) { printf(\"%d\", y) };\n/// \\endcode\n///\n/// the matcher blockDecl(hasAnyParameter(hasName(\"y\")))\n/// matches the declaration of the block b with hasParameter\n/// matching y.\nAST_POLYMORPHIC_MATCHER_P(hasAnyParameter,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                          ObjCMethodDecl,\n                                                          BlockDecl),\n                          internal::Matcher<ParmVarDecl>,\n                          InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.param_begin(),\n                                    Node.param_end(), Finder,\n                                    Builder) != Node.param_end();\n}\n\n/// Matches \\c FunctionDecls and \\c FunctionProtoTypes that have a\n/// specific parameter count.\n///\n/// Given\n/// \\code\n///   void f(int i) {}\n///   void g(int i, int j) {}\n///   void h(int i, int j);\n///   void j(int i);\n///   void k(int x, int y, int z, ...);\n/// \\endcode\n/// functionDecl(parameterCountIs(2))\n///   matches \\c g and \\c h\n/// functionProtoType(parameterCountIs(2))\n///   matches \\c g and \\c h\n/// functionProtoType(parameterCountIs(3))\n///   matches \\c k\nAST_POLYMORPHIC_MATCHER_P(parameterCountIs,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                          FunctionProtoType),\n                          unsigned, N) {\n  return Node.getNumParams() == N;\n}\n\n/// Matches classTemplateSpecialization, templateSpecializationType and\n/// functionDecl nodes where the template argument matches the inner matcher.\n/// This matcher may produce multiple matches.\n///\n/// Given\n/// \\code\n///   template <typename T, unsigned N, unsigned M>\n///   struct Matrix {};\n///\n///   constexpr unsigned R = 2;\n///   Matrix<int, R * 2, R * 4> M;\n///\n///   template <typename T, typename U>\n///   void f(T&& t, U&& u) {}\n///\n///   bool B = false;\n///   f(R, B);\n/// \\endcode\n/// templateSpecializationType(forEachTemplateArgument(isExpr(expr())))\n///   matches twice, with expr() matching 'R * 2' and 'R * 4'\n/// functionDecl(forEachTemplateArgument(refersToType(builtinType())))\n///   matches the specialization f<unsigned, bool> twice, for 'unsigned'\n///   and 'bool'\nAST_POLYMORPHIC_MATCHER_P(\n    forEachTemplateArgument,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,\n                                    TemplateSpecializationType, FunctionDecl),\n    clang::ast_matchers::internal::Matcher<TemplateArgument>, InnerMatcher) {\n  ArrayRef<TemplateArgument> TemplateArgs =\n      clang::ast_matchers::internal::getTemplateSpecializationArgs(Node);\n  clang::ast_matchers::internal::BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto &Arg : TemplateArgs) {\n    clang::ast_matchers::internal::BoundNodesTreeBuilder ArgBuilder(*Builder);\n    if (InnerMatcher.matches(Arg, Finder, &ArgBuilder)) {\n      Matched = true;\n      Result.addMatch(ArgBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches \\c FunctionDecls that have a noreturn attribute.\n///\n/// Given\n/// \\code\n///   void nope();\n///   [[noreturn]] void a();\n///   __attribute__((noreturn)) void b();\n///   struct c { [[noreturn]] c(); };\n/// \\endcode\n/// functionDecl(isNoReturn())\n///   matches all of those except\n/// \\code\n///   void nope();\n/// \\endcode\nAST_MATCHER(FunctionDecl, isNoReturn) { return Node.isNoReturn(); }\n\n/// Matches the return type of a function declaration.\n///\n/// Given:\n/// \\code\n///   class X { int f() { return 1; } };\n/// \\endcode\n/// cxxMethodDecl(returns(asString(\"int\")))\n///   matches int f() { return 1; }\nAST_MATCHER_P(FunctionDecl, returns,\n              internal::Matcher<QualType>, InnerMatcher) {\n  return InnerMatcher.matches(Node.getReturnType(), Finder, Builder);\n}\n\n/// Matches extern \"C\" function or variable declarations.\n///\n/// Given:\n/// \\code\n///   extern \"C\" void f() {}\n///   extern \"C\" { void g() {} }\n///   void h() {}\n///   extern \"C\" int x = 1;\n///   extern \"C\" int y = 2;\n///   int z = 3;\n/// \\endcode\n/// functionDecl(isExternC())\n///   matches the declaration of f and g, but not the declaration of h.\n/// varDecl(isExternC())\n///   matches the declaration of x and y, but not the declaration of z.\nAST_POLYMORPHIC_MATCHER(isExternC, AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                                   VarDecl)) {\n  return Node.isExternC();\n}\n\n/// Matches variable/function declarations that have \"static\" storage\n/// class specifier (\"static\" keyword) written in the source.\n///\n/// Given:\n/// \\code\n///   static void f() {}\n///   static int i = 0;\n///   extern int j;\n///   int k;\n/// \\endcode\n/// functionDecl(isStaticStorageClass())\n///   matches the function declaration f.\n/// varDecl(isStaticStorageClass())\n///   matches the variable declaration i.\nAST_POLYMORPHIC_MATCHER(isStaticStorageClass,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        VarDecl)) {\n  return Node.getStorageClass() == SC_Static;\n}\n\n/// Matches deleted function declarations.\n///\n/// Given:\n/// \\code\n///   void Func();\n///   void DeletedFunc() = delete;\n/// \\endcode\n/// functionDecl(isDeleted())\n///   matches the declaration of DeletedFunc, but not Func.\nAST_MATCHER(FunctionDecl, isDeleted) {\n  return Node.isDeleted();\n}\n\n/// Matches defaulted function declarations.\n///\n/// Given:\n/// \\code\n///   class A { ~A(); };\n///   class B { ~B() = default; };\n/// \\endcode\n/// functionDecl(isDefaulted())\n///   matches the declaration of ~B, but not ~A.\nAST_MATCHER(FunctionDecl, isDefaulted) {\n  return Node.isDefaulted();\n}\n\n/// Matches weak function declarations.\n///\n/// Given:\n/// \\code\n///   void foo() __attribute__((__weakref__(\"__foo\")));\n///   void bar();\n/// \\endcode\n/// functionDecl(isWeak())\n///   matches the weak declaration \"foo\", but not \"bar\".\nAST_MATCHER(FunctionDecl, isWeak) { return Node.isWeak(); }\n\n/// Matches functions that have a dynamic exception specification.\n///\n/// Given:\n/// \\code\n///   void f();\n///   void g() noexcept;\n///   void h() noexcept(true);\n///   void i() noexcept(false);\n///   void j() throw();\n///   void k() throw(int);\n///   void l() throw(...);\n/// \\endcode\n/// functionDecl(hasDynamicExceptionSpec()) and\n///   functionProtoType(hasDynamicExceptionSpec())\n///   match the declarations of j, k, and l, but not f, g, h, or i.\nAST_POLYMORPHIC_MATCHER(hasDynamicExceptionSpec,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        FunctionProtoType)) {\n  if (const FunctionProtoType *FnTy = internal::getFunctionProtoType(Node))\n    return FnTy->hasDynamicExceptionSpec();\n  return false;\n}\n\n/// Matches functions that have a non-throwing exception specification.\n///\n/// Given:\n/// \\code\n///   void f();\n///   void g() noexcept;\n///   void h() throw();\n///   void i() throw(int);\n///   void j() noexcept(false);\n/// \\endcode\n/// functionDecl(isNoThrow()) and functionProtoType(isNoThrow())\n///   match the declarations of g, and h, but not f, i or j.\nAST_POLYMORPHIC_MATCHER(isNoThrow,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        FunctionProtoType)) {\n  const FunctionProtoType *FnTy = internal::getFunctionProtoType(Node);\n\n  // If the function does not have a prototype, then it is assumed to be a\n  // throwing function (as it would if the function did not have any exception\n  // specification).\n  if (!FnTy)\n    return false;\n\n  // Assume the best for any unresolved exception specification.\n  if (isUnresolvedExceptionSpec(FnTy->getExceptionSpecType()))\n    return true;\n\n  return FnTy->isNothrow();\n}\n\n/// Matches consteval function declarations and if consteval/if ! consteval\n/// statements.\n///\n/// Given:\n/// \\code\n///   consteval int a();\n///   void b() { if consteval {} }\n///   void c() { if ! consteval {} }\n///   void d() { if ! consteval {} else {} }\n/// \\endcode\n/// functionDecl(isConsteval())\n///   matches the declaration of \"int a()\".\n/// ifStmt(isConsteval())\n///   matches the if statement in \"void b()\", \"void c()\", \"void d()\".\nAST_POLYMORPHIC_MATCHER(isConsteval,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, IfStmt)) {\n  return Node.isConsteval();\n}\n\n/// Matches constexpr variable and function declarations,\n///        and if constexpr.\n///\n/// Given:\n/// \\code\n///   constexpr int foo = 42;\n///   constexpr int bar();\n///   void baz() { if constexpr(1 > 0) {} }\n/// \\endcode\n/// varDecl(isConstexpr())\n///   matches the declaration of foo.\n/// functionDecl(isConstexpr())\n///   matches the declaration of bar.\n/// ifStmt(isConstexpr())\n///   matches the if statement in baz.\nAST_POLYMORPHIC_MATCHER(isConstexpr,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(VarDecl,\n                                                        FunctionDecl,\n                                                        IfStmt)) {\n  return Node.isConstexpr();\n}\n\n/// Matches constinit variable declarations.\n///\n/// Given:\n/// \\code\n///   constinit int foo = 42;\n///   constinit const char* bar = \"bar\";\n///   int baz = 42;\n///   [[clang::require_constant_initialization]] int xyz = 42;\n/// \\endcode\n/// varDecl(isConstinit())\n///   matches the declaration of `foo` and `bar`, but not `baz` and `xyz`.\nAST_MATCHER(VarDecl, isConstinit) {\n  if (const auto *CIA = Node.getAttr<ConstInitAttr>())\n    return CIA->isConstinit();\n  return false;\n}\n\n/// Matches selection statements with initializer.\n///\n/// Given:\n/// \\code\n///  void foo() {\n///    if (int i = foobar(); i > 0) {}\n///    switch (int i = foobar(); i) {}\n///    for (auto& a = get_range(); auto& x : a) {}\n///  }\n///  void bar() {\n///    if (foobar() > 0) {}\n///    switch (foobar()) {}\n///    for (auto& x : get_range()) {}\n///  }\n/// \\endcode\n/// ifStmt(hasInitStatement(anything()))\n///   matches the if statement in foo but not in bar.\n/// switchStmt(hasInitStatement(anything()))\n///   matches the switch statement in foo but not in bar.\n/// cxxForRangeStmt(hasInitStatement(anything()))\n///   matches the range for statement in foo but not in bar.\nAST_POLYMORPHIC_MATCHER_P(hasInitStatement,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, SwitchStmt,\n                                                          CXXForRangeStmt),\n                          internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *Init = Node.getInit();\n  return Init != nullptr && InnerMatcher.matches(*Init, Finder, Builder);\n}\n\n/// Matches the condition expression of an if statement, for loop,\n/// switch statement or conditional operator.\n///\n/// Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true))))\n/// \\code\n///   if (true) {}\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(\n    hasCondition,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, ForStmt, WhileStmt, DoStmt,\n                                    SwitchStmt, AbstractConditionalOperator),\n    internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const Condition = Node.getCond();\n  return (Condition != nullptr &&\n          InnerMatcher.matches(*Condition, Finder, Builder));\n}\n\n/// Matches the then-statement of an if statement.\n///\n/// Examples matches the if statement\n///   (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true)))))\n/// \\code\n///   if (false) true; else false;\n/// \\endcode\nAST_MATCHER_P(IfStmt, hasThen, internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Then = Node.getThen();\n  return (Then != nullptr && InnerMatcher.matches(*Then, Finder, Builder));\n}\n\n/// Matches the else-statement of an if statement.\n///\n/// Examples matches the if statement\n///   (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true)))))\n/// \\code\n///   if (false) false; else true;\n/// \\endcode\nAST_MATCHER_P(IfStmt, hasElse, internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Else = Node.getElse();\n  return (Else != nullptr && InnerMatcher.matches(*Else, Finder, Builder));\n}\n\n/// Matches if a node equals a previously bound node.\n///\n/// Matches a node if it equals the node previously bound to \\p ID.\n///\n/// Given\n/// \\code\n///   class X { int a; int b; };\n/// \\endcode\n/// cxxRecordDecl(\n///     has(fieldDecl(hasName(\"a\"), hasType(type().bind(\"t\")))),\n///     has(fieldDecl(hasName(\"b\"), hasType(type(equalsBoundNode(\"t\"))))))\n///   matches the class \\c X, as \\c a and \\c b have the same type.\n///\n/// Note that when multiple matches are involved via \\c forEach* matchers,\n/// \\c equalsBoundNodes acts as a filter.\n/// For example:\n/// compoundStmt(\n///     forEachDescendant(varDecl().bind(\"d\")),\n///     forEachDescendant(declRefExpr(to(decl(equalsBoundNode(\"d\"))))))\n/// will trigger a match for each combination of variable declaration\n/// and reference to that variable declaration within a compound statement.\nAST_POLYMORPHIC_MATCHER_P(equalsBoundNode,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(Stmt, Decl, Type,\n                                                          QualType),\n                          std::string, ID) {\n  // FIXME: Figure out whether it makes sense to allow this\n  // on any other node types.\n  // For *Loc it probably does not make sense, as those seem\n  // unique. For NestedNameSepcifier it might make sense, as\n  // those also have pointer identity, but I'm not sure whether\n  // they're ever reused.\n  internal::NotEqualsBoundNodePredicate Predicate;\n  Predicate.ID = ID;\n  Predicate.Node = DynTypedNode::create(Node);\n  return Builder->removeBindings(Predicate);\n}\n\n/// Matches the condition variable statement in an if statement.\n///\n/// Given\n/// \\code\n///   if (A* a = GetAPointer()) {}\n/// \\endcode\n/// hasConditionVariableStatement(...)\n///   matches 'A* a = GetAPointer()'.\nAST_MATCHER_P(IfStmt, hasConditionVariableStatement,\n              internal::Matcher<DeclStmt>, InnerMatcher) {\n  const DeclStmt* const DeclarationStatement =\n    Node.getConditionVariableDeclStmt();\n  return DeclarationStatement != nullptr &&\n         InnerMatcher.matches(*DeclarationStatement, Finder, Builder);\n}\n\n/// Matches the index expression of an array subscript expression.\n///\n/// Given\n/// \\code\n///   int i[5];\n///   void f() { i[1] = 42; }\n/// \\endcode\n/// arraySubscriptExpression(hasIndex(integerLiteral()))\n///   matches \\c i[1] with the \\c integerLiteral() matching \\c 1\nAST_MATCHER_P(ArraySubscriptExpr, hasIndex,\n              internal::Matcher<Expr>, InnerMatcher) {\n  if (const Expr* Expression = Node.getIdx())\n    return InnerMatcher.matches(*Expression, Finder, Builder);\n  return false;\n}\n\n/// Matches the base expression of an array subscript expression.\n///\n/// Given\n/// \\code\n///   int i[5];\n///   void f() { i[1] = 42; }\n/// \\endcode\n/// arraySubscriptExpression(hasBase(implicitCastExpr(\n///     hasSourceExpression(declRefExpr()))))\n///   matches \\c i[1] with the \\c declRefExpr() matching \\c i\nAST_MATCHER_P(ArraySubscriptExpr, hasBase,\n              internal::Matcher<Expr>, InnerMatcher) {\n  if (const Expr* Expression = Node.getBase())\n    return InnerMatcher.matches(*Expression, Finder, Builder);\n  return false;\n}\n\n/// Matches a 'for', 'while', 'while' statement or a function or coroutine\n/// definition that has a given body. Note that in case of functions or\n/// coroutines this matcher only matches the definition itself and not the\n/// other declarations of the same function or coroutine.\n///\n/// Given\n/// \\code\n///   for (;;) {}\n/// \\endcode\n/// forStmt(hasBody(compoundStmt()))\n///   matches 'for (;;) {}'\n/// with compoundStmt()\n///   matching '{}'\n///\n/// Given\n/// \\code\n///   void f();\n///   void f() {}\n/// \\endcode\n/// functionDecl(hasBody(compoundStmt()))\n///   matches 'void f() {}'\n/// with compoundStmt()\n///   matching '{}'\n///   but does not match 'void f();'\nAST_POLYMORPHIC_MATCHER_P(\n    hasBody,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(DoStmt, ForStmt, WhileStmt, CXXForRangeStmt,\n                                    FunctionDecl, CoroutineBodyStmt),\n    internal::Matcher<Stmt>, InnerMatcher) {\n  if (Finder->isTraversalIgnoringImplicitNodes() && isDefaultedHelper(&Node))\n    return false;\n  const Stmt *const Statement = internal::GetBodyMatcher<NodeType>::get(Node);\n  return (Statement != nullptr &&\n          InnerMatcher.matches(*Statement, Finder, Builder));\n}\n\n/// Matches a function declaration that has a given body present in the AST.\n/// Note that this matcher matches all the declarations of a function whose\n/// body is present in the AST.\n///\n/// Given\n/// \\code\n///   void f();\n///   void f() {}\n///   void g();\n/// \\endcode\n/// functionDecl(hasAnyBody(compoundStmt()))\n///   matches both 'void f();'\n///   and 'void f() {}'\n/// with compoundStmt()\n///   matching '{}'\n///   but does not match 'void g();'\nAST_MATCHER_P(FunctionDecl, hasAnyBody,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Statement = Node.getBody();\n  return (Statement != nullptr &&\n          InnerMatcher.matches(*Statement, Finder, Builder));\n}\n\n\n/// Matches compound statements where at least one substatement matches\n/// a given matcher. Also matches StmtExprs that have CompoundStmt as children.\n///\n/// Given\n/// \\code\n///   { {}; 1+2; }\n/// \\endcode\n/// hasAnySubstatement(compoundStmt())\n///   matches '{ {}; 1+2; }'\n/// with compoundStmt()\n///   matching '{}'\nAST_POLYMORPHIC_MATCHER_P(hasAnySubstatement,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CompoundStmt,\n                                                          StmtExpr),\n                          internal::Matcher<Stmt>, InnerMatcher) {\n  const CompoundStmt *CS = CompoundStmtMatcher<NodeType>::get(Node);\n  return CS && matchesFirstInPointerRange(InnerMatcher, CS->body_begin(),\n                                          CS->body_end(), Finder,\n                                          Builder) != CS->body_end();\n}\n\n/// Checks that a compound statement contains a specific number of\n/// child statements.\n///\n/// Example: Given\n/// \\code\n///   { for (;;) {} }\n/// \\endcode\n/// compoundStmt(statementCountIs(0)))\n///   matches '{}'\n///   but does not match the outer compound statement.\nAST_MATCHER_P(CompoundStmt, statementCountIs, unsigned, N) {\n  return Node.size() == N;\n}\n\n/// Matches literals that are equal to the given value of type ValueT.\n///\n/// Given\n/// \\code\n///   f('\\0', false, 3.14, 42);\n/// \\endcode\n/// characterLiteral(equals(0))\n///   matches '\\0'\n/// cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0))\n///   match false\n/// floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2))\n///   match 3.14\n/// integerLiteral(equals(42))\n///   matches 42\n///\n/// Note that you cannot directly match a negative numeric literal because the\n/// minus sign is not part of the literal: It is a unary operator whose operand\n/// is the positive numeric literal. Instead, you must use a unaryOperator()\n/// matcher to match the minus sign:\n///\n/// unaryOperator(hasOperatorName(\"-\"),\n///               hasUnaryOperand(integerLiteral(equals(13))))\n///\n/// Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,\n///            Matcher<FloatingLiteral>, Matcher<IntegerLiteral>\ntemplate <typename ValueT>\ninternal::PolymorphicMatcher<internal::ValueEqualsMatcher,\n                             void(internal::AllNodeBaseTypes), ValueT>\nequals(const ValueT &Value) {\n  return internal::PolymorphicMatcher<internal::ValueEqualsMatcher,\n                                      void(internal::AllNodeBaseTypes), ValueT>(\n      Value);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          IntegerLiteral),\n                          bool, Value, 0) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          IntegerLiteral),\n                          unsigned, Value, 1) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          FloatingLiteral,\n                                                          IntegerLiteral),\n                          double, Value, 2) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\n/// Matches the operator Name of operator expressions (binary or\n/// unary).\n///\n/// Example matches a || b (matcher = binaryOperator(hasOperatorName(\"||\")))\n/// \\code\n///   !(a || b)\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(\n    hasOperatorName,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator, UnaryOperator),\n    std::string, Name) {\n  if (std::optional<StringRef> OpName = internal::getOpName(Node))\n    return *OpName == Name;\n  return false;\n}\n\n/// Matches operator expressions (binary or unary) that have any of the\n/// specified names.\n///\n///    hasAnyOperatorName(\"+\", \"-\")\n///  Is equivalent to\n///    anyOf(hasOperatorName(\"+\"), hasOperatorName(\"-\"))\nextern const internal::VariadicFunction<\n    internal::PolymorphicMatcher<internal::HasAnyOperatorNameMatcher,\n                                 AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                     BinaryOperator, CXXOperatorCallExpr,\n                                     CXXRewrittenBinaryOperator, UnaryOperator),\n                                 std::vector<std::string>>,\n    StringRef, internal::hasAnyOperatorNameFunc>\n    hasAnyOperatorName;\n\n/// Matches all kinds of assignment operators.\n///\n/// Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator()))\n/// \\code\n///   if (a == b)\n///     a += b;\n/// \\endcode\n///\n/// Example 2: matches s1 = s2\n///            (matcher = cxxOperatorCallExpr(isAssignmentOperator()))\n/// \\code\n///   struct S { S& operator=(const S&); };\n///   void x() { S s1, s2; s1 = s2; }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(\n    isAssignmentOperator,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator)) {\n  return Node.isAssignmentOp();\n}\n\n/// Matches comparison operators.\n///\n/// Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator()))\n/// \\code\n///   if (a == b)\n///     a += b;\n/// \\endcode\n///\n/// Example 2: matches s1 < s2\n///            (matcher = cxxOperatorCallExpr(isComparisonOperator()))\n/// \\code\n///   struct S { bool operator<(const S& other); };\n///   void x(S s1, S s2) { bool b1 = s1 < s2; }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(\n    isComparisonOperator,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator)) {\n  return Node.isComparisonOp();\n}\n\n/// Matches the left hand side of binary operator expressions.\n///\n/// Example matches a (matcher = binaryOperator(hasLHS()))\n/// \\code\n///   a || b\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasLHS,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              BinaryOperator, CXXOperatorCallExpr,\n                              CXXRewrittenBinaryOperator, ArraySubscriptExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *LeftHandSide = internal::getLHS(Node);\n  return (LeftHandSide != nullptr &&\n          InnerMatcher.matches(*LeftHandSide, Finder, Builder));\n}\n\n/// Matches the right hand side of binary operator expressions.\n///\n/// Example matches b (matcher = binaryOperator(hasRHS()))\n/// \\code\n///   a || b\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasRHS,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              BinaryOperator, CXXOperatorCallExpr,\n                              CXXRewrittenBinaryOperator, ArraySubscriptExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *RightHandSide = internal::getRHS(Node);\n  return (RightHandSide != nullptr &&\n          InnerMatcher.matches(*RightHandSide, Finder, Builder));\n}\n\n/// Matches if either the left hand side or the right hand side of a\n/// binary operator matches.\nAST_POLYMORPHIC_MATCHER_P(\n    hasEitherOperand,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator),\n    internal::Matcher<Expr>, InnerMatcher) {\n  return internal::VariadicDynCastAllOfMatcher<Stmt, NodeType>()(\n             anyOf(hasLHS(InnerMatcher), hasRHS(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if both matchers match with opposite sides of the binary operator.\n///\n/// Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1),\n///                                              integerLiteral(equals(2)))\n/// \\code\n///   1 + 2 // Match\n///   2 + 1 // Match\n///   1 + 1 // No match\n///   2 + 2 // No match\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P2(\n    hasOperands,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator),\n    internal::Matcher<Expr>, Matcher1, internal::Matcher<Expr>, Matcher2) {\n  return internal::VariadicDynCastAllOfMatcher<Stmt, NodeType>()(\n             anyOf(allOf(hasLHS(Matcher1), hasRHS(Matcher2)),\n                   allOf(hasLHS(Matcher2), hasRHS(Matcher1))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if the operand of a unary operator matches.\n///\n/// Example matches true (matcher = hasUnaryOperand(\n///                                   cxxBoolLiteral(equals(true))))\n/// \\code\n///   !true\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasUnaryOperand,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(UnaryOperator,\n                                                          CXXOperatorCallExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const Operand = internal::getSubExpr(Node);\n  return (Operand != nullptr &&\n          InnerMatcher.matches(*Operand, Finder, Builder));\n}\n\n/// Matches if the cast's source expression\n/// or opaque value's source expression matches the given matcher.\n///\n/// Example 1: matches \"a string\"\n/// (matcher = castExpr(hasSourceExpression(cxxConstructExpr())))\n/// \\code\n/// class URL { URL(string); };\n/// URL url = \"a string\";\n/// \\endcode\n///\n/// Example 2: matches 'b' (matcher =\n/// opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr())))\n/// \\code\n/// int a = b ?: 1;\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasSourceExpression,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CastExpr,\n                                                          OpaqueValueExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const SubExpression =\n      internal::GetSourceExpressionMatcher<NodeType>::get(Node);\n  return (SubExpression != nullptr &&\n          InnerMatcher.matches(*SubExpression, Finder, Builder));\n}\n\n/// Matches casts that has a given cast kind.\n///\n/// Example: matches the implicit cast around \\c 0\n/// (matcher = castExpr(hasCastKind(CK_NullToPointer)))\n/// \\code\n///   int *p = 0;\n/// \\endcode\n///\n/// If the matcher is use from clang-query, CastKind parameter\n/// should be passed as a quoted string. e.g., hasCastKind(\"CK_NullToPointer\").\nAST_MATCHER_P(CastExpr, hasCastKind, CastKind, Kind) {\n  return Node.getCastKind() == Kind;\n}\n\n/// Matches casts whose destination type matches a given matcher.\n///\n/// (Note: Clang's AST refers to other conversions as \"casts\" too, and calls\n/// actual casts \"explicit\" casts.)\nAST_MATCHER_P(ExplicitCastExpr, hasDestinationType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  const QualType NodeType = Node.getTypeAsWritten();\n  return InnerMatcher.matches(NodeType, Finder, Builder);\n}\n\n/// Matches implicit casts whose destination type matches a given\n/// matcher.\nAST_MATCHER_P(ImplicitCastExpr, hasImplicitDestinationType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  return InnerMatcher.matches(Node.getType(), Finder, Builder);\n}\n\n/// Matches TagDecl object that are spelled with \"struct.\"\n///\n/// Example matches S, but not C, U or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isStruct) {\n  return Node.isStruct();\n}\n\n/// Matches TagDecl object that are spelled with \"union.\"\n///\n/// Example matches U, but not C, S or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isUnion) {\n  return Node.isUnion();\n}\n\n/// Matches TagDecl object that are spelled with \"class.\"\n///\n/// Example matches C, but not S, U or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isClass) {\n  return Node.isClass();\n}\n\n/// Matches TagDecl object that are spelled with \"enum.\"\n///\n/// Example matches E, but not C, S or U.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isEnum) {\n  return Node.isEnum();\n}\n\n/// Matches the true branch expression of a conditional operator.\n///\n/// Example 1 (conditional ternary operator): matches a\n/// \\code\n///   condition ? a : b\n/// \\endcode\n///\n/// Example 2 (conditional binary operator): matches opaqueValueExpr(condition)\n/// \\code\n///   condition ?: b\n/// \\endcode\nAST_MATCHER_P(AbstractConditionalOperator, hasTrueExpression,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *Expression = Node.getTrueExpr();\n  return (Expression != nullptr &&\n          InnerMatcher.matches(*Expression, Finder, Builder));\n}\n\n/// Matches the false branch expression of a conditional operator\n/// (binary or ternary).\n///\n/// Example matches b\n/// \\code\n///   condition ? a : b\n///   condition ?: b\n/// \\endcode\nAST_MATCHER_P(AbstractConditionalOperator, hasFalseExpression,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *Expression = Node.getFalseExpr();\n  return (Expression != nullptr &&\n          InnerMatcher.matches(*Expression, Finder, Builder));\n}\n\n/// Matches if a declaration has a body attached.\n///\n/// Example matches A, va, fa\n/// \\code\n///   class A {};\n///   class B;  // Doesn't match, as it has no body.\n///   int va;\n///   extern int vb;  // Doesn't match, as it doesn't define the variable.\n///   void fa() {}\n///   void fb();  // Doesn't match, as it has no body.\n///   @interface X\n///   - (void)ma; // Doesn't match, interface is declaration.\n///   @end\n///   @implementation X\n///   - (void)ma {}\n///   @end\n/// \\endcode\n///\n/// Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,\n///   Matcher<ObjCMethodDecl>\nAST_POLYMORPHIC_MATCHER(isDefinition,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(TagDecl, VarDecl,\n                                                        ObjCMethodDecl,\n                                                        FunctionDecl)) {\n  return Node.isThisDeclarationADefinition();\n}\n\n/// Matches if a function declaration is variadic.\n///\n/// Example matches f, but not g or h. The function i will not match, even when\n/// compiled in C mode.\n/// \\code\n///   void f(...);\n///   void g(int);\n///   template <typename... Ts> void h(Ts...);\n///   void i();\n/// \\endcode\nAST_MATCHER(FunctionDecl, isVariadic) {\n  return Node.isVariadic();\n}\n\n/// Matches the class declaration that the given method declaration\n/// belongs to.\n///\n/// FIXME: Generalize this for other kinds of declarations.\n/// FIXME: What other kind of declarations would we need to generalize\n/// this to?\n///\n/// Example matches A() in the last line\n///     (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl(\n///         ofClass(hasName(\"A\"))))))\n/// \\code\n///   class A {\n///    public:\n///     A();\n///   };\n///   A a = A();\n/// \\endcode\nAST_MATCHER_P(CXXMethodDecl, ofClass,\n              internal::Matcher<CXXRecordDecl>, InnerMatcher) {\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  const CXXRecordDecl *Parent = Node.getParent();\n  return (Parent != nullptr &&\n          InnerMatcher.matches(*Parent, Finder, Builder));\n}\n\n/// Matches each method overridden by the given method. This matcher may\n/// produce multiple matches.\n///\n/// Given\n/// \\code\n///   class A { virtual void f(); };\n///   class B : public A { void f(); };\n///   class C : public B { void f(); };\n/// \\endcode\n/// cxxMethodDecl(ofClass(hasName(\"C\")),\n///               forEachOverridden(cxxMethodDecl().bind(\"b\"))).bind(\"d\")\n///   matches once, with \"b\" binding \"A::f\" and \"d\" binding \"C::f\" (Note\n///   that B::f is not overridden by C::f).\n///\n/// The check can produce multiple matches in case of multiple inheritance, e.g.\n/// \\code\n///   class A1 { virtual void f(); };\n///   class A2 { virtual void f(); };\n///   class C : public A1, public A2 { void f(); };\n/// \\endcode\n/// cxxMethodDecl(ofClass(hasName(\"C\")),\n///               forEachOverridden(cxxMethodDecl().bind(\"b\"))).bind(\"d\")\n///   matches twice, once with \"b\" binding \"A1::f\" and \"d\" binding \"C::f\", and\n///   once with \"b\" binding \"A2::f\" and \"d\" binding \"C::f\".\nAST_MATCHER_P(CXXMethodDecl, forEachOverridden,\n              internal::Matcher<CXXMethodDecl>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *Overridden : Node.overridden_methods()) {\n    BoundNodesTreeBuilder OverriddenBuilder(*Builder);\n    const bool OverriddenMatched =\n        InnerMatcher.matches(*Overridden, Finder, &OverriddenBuilder);\n    if (OverriddenMatched) {\n      Matched = true;\n      Result.addMatch(OverriddenBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches declarations of virtual methods and C++ base specifers that specify\n/// virtual inheritance.\n///\n/// Example:\n/// \\code\n///   class A {\n///    public:\n///     virtual void x(); // matches x\n///   };\n/// \\endcode\n///\n/// Example:\n/// \\code\n///   class Base {};\n///   class DirectlyDerived : virtual Base {}; // matches Base\n///   class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base\n/// \\endcode\n///\n/// Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>\nAST_POLYMORPHIC_MATCHER(isVirtual,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXMethodDecl,\n                                                        CXXBaseSpecifier)) {\n  return Node.isVirtual();\n}\n\n/// Matches if the given method declaration has an explicit \"virtual\".\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     void x();\n///   };\n/// \\endcode\n///   matches A::x but not B::x\nAST_MATCHER(CXXMethodDecl, isVirtualAsWritten) {\n  return Node.isVirtualAsWritten();\n}\n\nAST_MATCHER(CXXConstructorDecl, isInheritingConstructor) {\n  return Node.isInheritingConstructor();\n}\n\n/// Matches if the given method or class declaration is final.\n///\n/// Given:\n/// \\code\n///   class A final {};\n///\n///   struct B {\n///     virtual void f();\n///   };\n///\n///   struct C : B {\n///     void f() final;\n///   };\n/// \\endcode\n/// matches A and C::f, but not B, C, or B::f\nAST_POLYMORPHIC_MATCHER(isFinal,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl,\n                                                        CXXMethodDecl)) {\n  return Node.template hasAttr<FinalAttr>();\n}\n\n/// Matches if the given method declaration is pure.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x() = 0;\n///   };\n/// \\endcode\n///   matches A::x\nAST_MATCHER(CXXMethodDecl, isPure) {\n  return Node.isPure();\n}\n\n/// Matches if the given method declaration is const.\n///\n/// Given\n/// \\code\n/// struct A {\n///   void foo() const;\n///   void bar();\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isConst()) matches A::foo() but not A::bar()\nAST_MATCHER(CXXMethodDecl, isConst) {\n  return Node.isConst();\n}\n\n/// Matches if the given method declaration declares a copy assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isCopyAssignmentOperator()) matches the first method but not\n/// the second one.\nAST_MATCHER(CXXMethodDecl, isCopyAssignmentOperator) {\n  return Node.isCopyAssignmentOperator();\n}\n\n/// Matches if the given method declaration declares a move assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not\n/// the first one.\nAST_MATCHER(CXXMethodDecl, isMoveAssignmentOperator) {\n  return Node.isMoveAssignmentOperator();\n}\n\n/// Matches if the given method declaration overrides another method.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     virtual void x();\n///   };\n/// \\endcode\n///   matches B::x\nAST_MATCHER(CXXMethodDecl, isOverride) {\n  return Node.size_overridden_methods() > 0 || Node.hasAttr<OverrideAttr>();\n}\n\n/// Matches method declarations that are user-provided.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &) = default; // #2\n///     S(S &&) = delete; // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXMethodDecl, isUserProvided) {\n  return Node.isUserProvided();\n}\n\n/// Matches member expressions that are called with '->' as opposed\n/// to '.'.\n///\n/// Member calls on the implicit this pointer match as called with '->'.\n///\n/// Given\n/// \\code\n///   class Y {\n///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }\n///     template <class T> void f() { this->f<T>(); f<T>(); }\n///     int a;\n///     static int b;\n///   };\n///   template <class T>\n///   class Z {\n///     void x() { this->m; }\n///   };\n/// \\endcode\n/// memberExpr(isArrow())\n///   matches this->x, x, y.x, a, this->b\n/// cxxDependentScopeMemberExpr(isArrow())\n///   matches this->m\n/// unresolvedMemberExpr(isArrow())\n///   matches this->f<T>, f<T>\nAST_POLYMORPHIC_MATCHER(\n    isArrow, AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                             CXXDependentScopeMemberExpr)) {\n  return Node.isArrow();\n}\n\n/// Matches QualType nodes that are of integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isInteger())))\n/// matches \"a(int)\", \"b(long)\", but not \"c(double)\".\nAST_MATCHER(QualType, isInteger) {\n    return Node->isIntegerType();\n}\n\n/// Matches QualType nodes that are of unsigned integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isUnsignedInteger())))\n/// matches \"b(unsigned long)\", but not \"a(int)\" and \"c(double)\".\nAST_MATCHER(QualType, isUnsignedInteger) {\n    return Node->isUnsignedIntegerType();\n}\n\n/// Matches QualType nodes that are of signed integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isSignedInteger())))\n/// matches \"a(int)\", but not \"b(unsigned long)\" and \"c(double)\".\nAST_MATCHER(QualType, isSignedInteger) {\n    return Node->isSignedIntegerType();\n}\n\n/// Matches QualType nodes that are of character type.\n///\n/// Given\n/// \\code\n///   void a(char);\n///   void b(wchar_t);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isAnyCharacter())))\n/// matches \"a(char)\", \"b(wchar_t)\", but not \"c(double)\".\nAST_MATCHER(QualType, isAnyCharacter) {\n    return Node->isAnyCharacterType();\n}\n\n/// Matches QualType nodes that are of any pointer type; this includes\n/// the Objective-C object pointer type, which is different despite being\n/// syntactically similar.\n///\n/// Given\n/// \\code\n///   int *i = nullptr;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n///\n///   int j;\n/// \\endcode\n/// varDecl(hasType(isAnyPointer()))\n///   matches \"int *i\" and \"Foo *f\", but not \"int j\".\nAST_MATCHER(QualType, isAnyPointer) {\n  return Node->isAnyPointerType();\n}\n\n/// Matches QualType nodes that are const-qualified, i.e., that\n/// include \"top-level\" const.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int const);\n///   void c(const int);\n///   void d(const int*);\n///   void e(int const) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isConstQualified())))\n///   matches \"void b(int const)\", \"void c(const int)\" and\n///   \"void e(int const) {}\". It does not match d as there\n///   is no top-level const on the parameter type \"const int *\".\nAST_MATCHER(QualType, isConstQualified) {\n  return Node.isConstQualified();\n}\n\n/// Matches QualType nodes that are volatile-qualified, i.e., that\n/// include \"top-level\" volatile.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int volatile);\n///   void c(volatile int);\n///   void d(volatile int*);\n///   void e(int volatile) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isVolatileQualified())))\n///   matches \"void b(int volatile)\", \"void c(volatile int)\" and\n///   \"void e(int volatile) {}\". It does not match d as there\n///   is no top-level volatile on the parameter type \"volatile int *\".\nAST_MATCHER(QualType, isVolatileQualified) {\n  return Node.isVolatileQualified();\n}\n\n/// Matches QualType nodes that have local CV-qualifiers attached to\n/// the node, not hidden within a typedef.\n///\n/// Given\n/// \\code\n///   typedef const int const_int;\n///   const_int i;\n///   int *const j;\n///   int *volatile k;\n///   int m;\n/// \\endcode\n/// \\c varDecl(hasType(hasLocalQualifiers())) matches only \\c j and \\c k.\n/// \\c i is const-qualified but the qualifier is not local.\nAST_MATCHER(QualType, hasLocalQualifiers) {\n  return Node.hasLocalQualifiers();\n}\n\n/// Matches a member expression where the member is matched by a\n/// given matcher.\n///\n/// Given\n/// \\code\n///   struct { int first, second; } first, second;\n///   int i(second.first);\n///   int j(first.second);\n/// \\endcode\n/// memberExpr(member(hasName(\"first\")))\n///   matches second.first\n///   but not first.second (because the member name there is \"second\").\nAST_MATCHER_P(MemberExpr, member,\n              internal::Matcher<ValueDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n}\n\n/// Matches a member expression where the object expression is matched by a\n/// given matcher. Implicit object expressions are included; that is, it matches\n/// use of implicit `this`.\n///\n/// Given\n/// \\code\n///   struct X {\n///     int m;\n///     int f(X x) { x.m; return m; }\n///   };\n/// \\endcode\n/// memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.m`, but not `m`; however,\n/// memberExpr(hasObjectExpression(hasType(pointsTo(\n//      cxxRecordDecl(hasName(\"X\"))))))\n///   matches `m` (aka. `this->m`), but not `x.m`.\nAST_POLYMORPHIC_MATCHER_P(\n    hasObjectExpression,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                    CXXDependentScopeMemberExpr),\n    internal::Matcher<Expr>, InnerMatcher) {\n  if (const auto *E = dyn_cast<UnresolvedMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  if (const auto *E = dyn_cast<CXXDependentScopeMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  return InnerMatcher.matches(*Node.getBase(), Finder, Builder);\n}\n\n/// Matches any using shadow declaration.\n///\n/// Given\n/// \\code\n///   namespace X { void b(); }\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasName(\"b\"))))\n///   matches \\code using X::b \\endcode\nAST_MATCHER_P(BaseUsingDecl, hasAnyUsingShadowDecl,\n              internal::Matcher<UsingShadowDecl>, InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.shadow_begin(),\n                                    Node.shadow_end(), Finder,\n                                    Builder) != Node.shadow_end();\n}\n\n/// Matches a using shadow declaration where the target declaration is\n/// matched by the given matcher.\n///\n/// Given\n/// \\code\n///   namespace X { int a; void b(); }\n///   using X::a;\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))\n///   matches \\code using X::b \\endcode\n///   but not \\code using X::a \\endcode\nAST_MATCHER_P(UsingShadowDecl, hasTargetDecl,\n              internal::Matcher<NamedDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getTargetDecl(), Finder, Builder);\n}\n\n/// Matches template instantiations of function, class, or static\n/// member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template <typename T> class X {}; class A {}; X<A> x;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; template class X<A>;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; extern template class X<A>;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   matches the template instantiation of X<A>.\n///\n/// But given\n/// \\code\n///   template <typename T>  class X {}; class A {};\n///   template <> class X<A> {}; X<A> x;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   does not match, as X<A> is an explicit template specialization.\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isTemplateInstantiation,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ImplicitInstantiation ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDefinition ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDeclaration);\n}\n\n/// Matches declarations that are template instantiations or are inside\n/// template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { T i; }\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// functionDecl(isInstantiated())\n///   matches 'A(int) {...};' and 'A(unsigned) {...}'.\nAST_MATCHER_FUNCTION(internal::Matcher<Decl>, isInstantiated) {\n  auto IsInstantiation = decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                                    functionDecl(isTemplateInstantiation())));\n  return decl(anyOf(IsInstantiation, hasAncestor(IsInstantiation)));\n}\n\n/// Matches statements inside of a template instantiation.\n///\n/// Given\n/// \\code\n///   int j;\n///   template<typename T> void A(T t) { T i; j += 42;}\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// declStmt(isInTemplateInstantiation())\n///   matches 'int i;' and 'unsigned i'.\n/// unless(stmt(isInTemplateInstantiation()))\n///   will NOT match j += 42; as it's shared between the template definition and\n///   instantiation.\nAST_MATCHER_FUNCTION(internal::Matcher<Stmt>, isInTemplateInstantiation) {\n  return stmt(\n      hasAncestor(decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                             functionDecl(isTemplateInstantiation())))));\n}\n\n/// Matches explicit template specializations of function, class, or\n/// static member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { }\n///   template<> void A(int N) { }\n/// \\endcode\n/// functionDecl(isExplicitTemplateSpecialization())\n///   matches the specialization A<int>().\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isExplicitTemplateSpecialization,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ExplicitSpecialization);\n}\n\n/// Matches \\c TypeLocs for which the given inner\n/// QualType-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(internal::BindableMatcher<TypeLoc>, loc,\n                                internal::Matcher<QualType>, InnerMatcher, 0) {\n  return internal::BindableMatcher<TypeLoc>(\n      new internal::TypeLocTypeMatcher(InnerMatcher));\n}\n\n/// Matches `QualifiedTypeLoc`s in the clang AST.\n///\n/// Given\n/// \\code\n///   const int x = 0;\n/// \\endcode\n/// qualifiedTypeLoc()\n///   matches `const int`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, QualifiedTypeLoc>\n    qualifiedTypeLoc;\n\n/// Matches `QualifiedTypeLoc`s that have an unqualified `TypeLoc` matching\n/// `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   int* const x;\n///   const int y;\n/// \\endcode\n/// qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc()))\n///   matches the `TypeLoc` of the variable declaration of `x`, but not `y`.\nAST_MATCHER_P(QualifiedTypeLoc, hasUnqualifiedLoc, internal::Matcher<TypeLoc>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getUnqualifiedLoc(), Finder, Builder);\n}\n\n/// Matches a function declared with the specified return `TypeLoc`.\n///\n/// Given\n/// \\code\n///   int f() { return 5; }\n///   void g() {}\n/// \\endcode\n/// functionDecl(hasReturnTypeLoc(loc(asString(\"int\"))))\n///   matches the declaration of `f`, but not `g`.\nAST_MATCHER_P(FunctionDecl, hasReturnTypeLoc, internal::Matcher<TypeLoc>,\n              ReturnMatcher) {\n  auto Loc = Node.getFunctionTypeLoc();\n  return Loc && ReturnMatcher.matches(Loc.getReturnLoc(), Finder, Builder);\n}\n\n/// Matches pointer `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   int* x;\n/// \\endcode\n/// pointerTypeLoc()\n///   matches `int*`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, PointerTypeLoc>\n    pointerTypeLoc;\n\n/// Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching\n/// `PointeeMatcher`.\n///\n/// Given\n/// \\code\n///   int* x;\n/// \\endcode\n/// pointerTypeLoc(hasPointeeLoc(loc(asString(\"int\"))))\n///   matches `int*`.\nAST_MATCHER_P(PointerTypeLoc, hasPointeeLoc, internal::Matcher<TypeLoc>,\n              PointeeMatcher) {\n  return PointeeMatcher.matches(Node.getPointeeLoc(), Finder, Builder);\n}\n\n/// Matches reference `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   int x = 3;\n///   int& l = x;\n///   int&& r = 3;\n/// \\endcode\n/// referenceTypeLoc()\n///   matches `int&` and `int&&`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, ReferenceTypeLoc>\n    referenceTypeLoc;\n\n/// Matches reference `TypeLoc`s that have a referent `TypeLoc` matching\n/// `ReferentMatcher`.\n///\n/// Given\n/// \\code\n///   int x = 3;\n///   int& xx = x;\n/// \\endcode\n/// referenceTypeLoc(hasReferentLoc(loc(asString(\"int\"))))\n///   matches `int&`.\nAST_MATCHER_P(ReferenceTypeLoc, hasReferentLoc, internal::Matcher<TypeLoc>,\n              ReferentMatcher) {\n  return ReferentMatcher.matches(Node.getPointeeLoc(), Finder, Builder);\n}\n\n/// Matches template specialization `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   template <typename T> class C {};\n///   C<char> var;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(typeLoc())))\n///   matches `C<char> var`.\nextern const internal::VariadicDynCastAllOfMatcher<\n    TypeLoc, TemplateSpecializationTypeLoc>\n    templateSpecializationTypeLoc;\n\n/// Matches template specialization `TypeLoc`s that have at least one\n/// `TemplateArgumentLoc` matching the given `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template<typename T> class A {};\n///   A<int> a;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(\n///   hasTypeLoc(loc(asString(\"int\")))))))\n///   matches `A<int> a`.\nAST_MATCHER_P(TemplateSpecializationTypeLoc, hasAnyTemplateArgumentLoc,\n              internal::Matcher<TemplateArgumentLoc>, InnerMatcher) {\n  for (unsigned Index = 0, N = Node.getNumArgs(); Index < N; ++Index) {\n    clang::ast_matchers::internal::BoundNodesTreeBuilder Result(*Builder);\n    if (InnerMatcher.matches(Node.getArgLoc(Index), Finder, &Result)) {\n      *Builder = std::move(Result);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Matches template specialization `TypeLoc`s where the n'th\n/// `TemplateArgumentLoc` matches the given `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template<typename T, typename U> class A {};\n///   A<double, int> b;\n///   A<int, double> c;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,\n///   hasTypeLoc(loc(asString(\"double\")))))))\n///   matches `A<double, int> b`, but not `A<int, double> c`.\nAST_POLYMORPHIC_MATCHER_P2(\n    hasTemplateArgumentLoc,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(DeclRefExpr, TemplateSpecializationTypeLoc),\n    unsigned, Index, internal::Matcher<TemplateArgumentLoc>, InnerMatcher) {\n  return internal::MatchTemplateArgLocAt(Node, Index, InnerMatcher, Finder,\n                                         Builder);\n}\n\n/// Matches C or C++ elaborated `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   struct s {};\n///   struct s ss;\n/// \\endcode\n/// elaboratedTypeLoc()\n///   matches the `TypeLoc` of the variable declaration of `ss`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, ElaboratedTypeLoc>\n    elaboratedTypeLoc;\n\n/// Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching\n/// `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C {};\n///   class C<int> c;\n///\n///   class D {};\n///   class D d;\n/// \\endcode\n/// elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));\n///   matches the `TypeLoc` of the variable declaration of `c`, but not `d`.\nAST_MATCHER_P(ElaboratedTypeLoc, hasNamedTypeLoc, internal::Matcher<TypeLoc>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getNamedTypeLoc(), Finder, Builder);\n}\n\n/// Matches type \\c bool.\n///\n/// Given\n/// \\code\n///  struct S { bool func(); };\n/// \\endcode\n/// functionDecl(returns(booleanType()))\n///   matches \"bool func();\"\nAST_MATCHER(Type, booleanType) {\n  return Node.isBooleanType();\n}\n\n/// Matches type \\c void.\n///\n/// Given\n/// \\code\n///  struct S { void func(); };\n/// \\endcode\n/// functionDecl(returns(voidType()))\n///   matches \"void func();\"\nAST_MATCHER(Type, voidType) {\n  return Node.isVoidType();\n}\n\ntemplate <typename NodeType>\nusing AstTypeMatcher = internal::VariadicDynCastAllOfMatcher<Type, NodeType>;\n\n/// Matches builtin Types.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a;\n///   int b;\n///   float c;\n///   bool d;\n/// \\endcode\n/// builtinType()\n///   matches \"int b\", \"float c\" and \"bool d\"\nextern const AstTypeMatcher<BuiltinType> builtinType;\n\n/// Matches all kinds of arrays.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[4];\n///   void f() { int c[a[0]]; }\n/// \\endcode\n/// arrayType()\n///   matches \"int a[]\", \"int b[4]\" and \"int c[a[0]]\";\nextern const AstTypeMatcher<ArrayType> arrayType;\n\n/// Matches C99 complex types.\n///\n/// Given\n/// \\code\n///   _Complex float f;\n/// \\endcode\n/// complexType()\n///   matches \"_Complex float f\"\nextern const AstTypeMatcher<ComplexType> complexType;\n\n/// Matches any real floating-point type (float, double, long double).\n///\n/// Given\n/// \\code\n///   int i;\n///   float f;\n/// \\endcode\n/// realFloatingPointType()\n///   matches \"float f\" but not \"int i\"\nAST_MATCHER(Type, realFloatingPointType) {\n  return Node.isRealFloatingType();\n}\n\n/// Matches arrays and C99 complex types that have a specific element\n/// type.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a[7];\n///   int b[7];\n/// \\endcode\n/// arrayType(hasElementType(builtinType()))\n///   matches \"int b[7]\"\n///\n/// Usable as: Matcher<ArrayType>, Matcher<ComplexType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasElementType, getElement,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(ArrayType,\n                                                                  ComplexType));\n\n/// Matches C arrays with a specified constant size.\n///\n/// Given\n/// \\code\n///   void() {\n///     int a[2];\n///     int b[] = { 2, 3 };\n///     int c[b[0]];\n///   }\n/// \\endcode\n/// constantArrayType()\n///   matches \"int a[2]\"\nextern const AstTypeMatcher<ConstantArrayType> constantArrayType;\n\n/// Matches nodes that have the specified size.\n///\n/// Given\n/// \\code\n///   int a[42];\n///   int b[2 * 21];\n///   int c[41], d[43];\n///   char *s = \"abcd\";\n///   wchar_t *ws = L\"abcd\";\n///   char *w = \"a\";\n/// \\endcode\n/// constantArrayType(hasSize(42))\n///   matches \"int a[42]\" and \"int b[2 * 21]\"\n/// stringLiteral(hasSize(4))\n///   matches \"abcd\", L\"abcd\"\nAST_POLYMORPHIC_MATCHER_P(hasSize,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ConstantArrayType,\n                                                          StringLiteral),\n                          unsigned, N) {\n  return internal::HasSizeMatcher<NodeType>::hasSize(Node, N);\n}\n\n/// Matches C++ arrays whose size is a value-dependent expression.\n///\n/// Given\n/// \\code\n///   template<typename T, int Size>\n///   class array {\n///     T data[Size];\n///   };\n/// \\endcode\n/// dependentSizedArrayType\n///   matches \"T data[Size]\"\nextern const AstTypeMatcher<DependentSizedArrayType> dependentSizedArrayType;\n\n/// Matches C arrays with unspecified size.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[42];\n///   void f(int c[]) { int d[a[0]]; };\n/// \\endcode\n/// incompleteArrayType()\n///   matches \"int a[]\" and \"int c[]\"\nextern const AstTypeMatcher<IncompleteArrayType> incompleteArrayType;\n\n/// Matches C arrays with a specified size that is not an\n/// integer-constant-expression.\n///\n/// Given\n/// \\code\n///   void f() {\n///     int a[] = { 2, 3 }\n///     int b[42];\n///     int c[a[0]];\n///   }\n/// \\endcode\n/// variableArrayType()\n///   matches \"int c[a[0]]\"\nextern const AstTypeMatcher<VariableArrayType> variableArrayType;\n\n/// Matches \\c VariableArrayType nodes that have a specific size\n/// expression.\n///\n/// Given\n/// \\code\n///   void f(int b) {\n///     int a[b];\n///   }\n/// \\endcode\n/// variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(\n///   varDecl(hasName(\"b\")))))))\n///   matches \"int a[b]\"\nAST_MATCHER_P(VariableArrayType, hasSizeExpr,\n              internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getSizeExpr(), Finder, Builder);\n}\n\n/// Matches atomic types.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n/// \\endcode\n/// atomicType()\n///   matches \"_Atomic(int) i\"\nextern const AstTypeMatcher<AtomicType> atomicType;\n\n/// Matches atomic types with a specific value type.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n///   _Atomic(float) f;\n/// \\endcode\n/// atomicType(hasValueType(isInteger()))\n///  matches \"_Atomic(int) i\"\n///\n/// Usable as: Matcher<AtomicType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasValueType, getValue,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(AtomicType));\n\n/// Matches types nodes representing C++11 auto types.\n///\n/// Given:\n/// \\code\n///   auto n = 4;\n///   int v[] = { 2, 3 }\n///   for (auto i : v) { }\n/// \\endcode\n/// autoType()\n///   matches \"auto n\" and \"auto i\"\nextern const AstTypeMatcher<AutoType> autoType;\n\n/// Matches types nodes representing C++11 decltype(<expr>) types.\n///\n/// Given:\n/// \\code\n///   short i = 1;\n///   int j = 42;\n///   decltype(i + j) result = i + j;\n/// \\endcode\n/// decltypeType()\n///   matches \"decltype(i + j)\"\nextern const AstTypeMatcher<DecltypeType> decltypeType;\n\n/// Matches \\c AutoType nodes where the deduced type is a specific type.\n///\n/// Note: There is no \\c TypeLoc for the deduced type and thus no\n/// \\c getDeducedLoc() matcher.\n///\n/// Given\n/// \\code\n///   auto a = 1;\n///   auto b = 2.0;\n/// \\endcode\n/// autoType(hasDeducedType(isInteger()))\n///   matches \"auto a\"\n///\n/// Usable as: Matcher<AutoType>\nAST_TYPE_TRAVERSE_MATCHER(hasDeducedType, getDeducedType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(AutoType));\n\n/// Matches \\c DecltypeType or \\c UsingType nodes to find the underlying type.\n///\n/// Given\n/// \\code\n///   decltype(1) a = 1;\n///   decltype(2.0) b = 2.0;\n/// \\endcode\n/// decltypeType(hasUnderlyingType(isInteger()))\n///   matches the type of \"a\"\n///\n/// Usable as: Matcher<DecltypeType>, Matcher<UsingType>\nAST_TYPE_TRAVERSE_MATCHER(hasUnderlyingType, getUnderlyingType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(DecltypeType,\n                                                          UsingType));\n\n/// Matches \\c FunctionType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionType()\n///   matches \"int (*f)(int)\" and the type of \"g\".\nextern const AstTypeMatcher<FunctionType> functionType;\n\n/// Matches \\c FunctionProtoType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionProtoType()\n///   matches \"int (*f)(int)\" and the type of \"g\" in C++ mode.\n///   In C mode, \"g\" is not matched because it does not contain a prototype.\nextern const AstTypeMatcher<FunctionProtoType> functionProtoType;\n\n/// Matches \\c ParenType nodes.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int *array_of_ptrs[4];\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType()))) matches \\c ptr_to_array but not\n/// \\c array_of_ptrs.\nextern const AstTypeMatcher<ParenType> parenType;\n\n/// Matches \\c ParenType nodes where the inner type is a specific type.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int (*ptr_to_func)(int);\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches\n/// \\c ptr_to_func but not \\c ptr_to_array.\n///\n/// Usable as: Matcher<ParenType>\nAST_TYPE_TRAVERSE_MATCHER(innerType, getInnerType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ParenType));\n\n/// Matches block pointer types, i.e. types syntactically represented as\n/// \"void (^)(int)\".\n///\n/// The \\c pointee is always required to be a \\c FunctionType.\nextern const AstTypeMatcher<BlockPointerType> blockPointerType;\n\n/// Matches member pointer types.\n/// Given\n/// \\code\n///   struct A { int i; }\n///   A::* ptr = A::i;\n/// \\endcode\n/// memberPointerType()\n///   matches \"A::* ptr\"\nextern const AstTypeMatcher<MemberPointerType> memberPointerType;\n\n/// Matches pointer types, but does not match Objective-C object pointer\n/// types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int c = 5;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"int *a\", but does not match \"Foo *f\".\nextern const AstTypeMatcher<PointerType> pointerType;\n\n/// Matches an Objective-C object pointer type, which is different from\n/// a pointer type, despite being syntactically similar.\n///\n/// Given\n/// \\code\n///   int *a;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"Foo *f\", but does not match \"int *a\".\nextern const AstTypeMatcher<ObjCObjectPointerType> objcObjectPointerType;\n\n/// Matches both lvalue and rvalue reference types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c referenceType() matches the types of \\c b, \\c c, \\c d, \\c e, and \\c f.\nextern const AstTypeMatcher<ReferenceType> referenceType;\n\n/// Matches lvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c lValueReferenceType() matches the types of \\c b, \\c d, and \\c e. \\c e is\n/// matched since the type is deduced as int& by reference collapsing rules.\nextern const AstTypeMatcher<LValueReferenceType> lValueReferenceType;\n\n/// Matches rvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c rValueReferenceType() matches the types of \\c c and \\c f. \\c e is not\n/// matched as it is deduced to int& by reference collapsing rules.\nextern const AstTypeMatcher<RValueReferenceType> rValueReferenceType;\n\n/// Narrows PointerType (and similar) matchers to those where the\n/// \\c pointee matches a given matcher.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int const *b;\n///   float const *f;\n/// \\endcode\n/// pointerType(pointee(isConstQualified(), isInteger()))\n///   matches \"int const *b\"\n///\n/// Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,\n///   Matcher<PointerType>, Matcher<ReferenceType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(\n    pointee, getPointee,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BlockPointerType, MemberPointerType,\n                                    PointerType, ReferenceType));\n\n/// Matches typedef types.\n///\n/// Given\n/// \\code\n///   typedef int X;\n/// \\endcode\n/// typedefType()\n///   matches \"typedef int X\"\nextern const AstTypeMatcher<TypedefType> typedefType;\n\n/// Matches enum types.\n///\n/// Given\n/// \\code\n///   enum C { Green };\n///   enum class S { Red };\n///\n///   C c;\n///   S s;\n/// \\endcode\n//\n/// \\c enumType() matches the type of the variable declarations of both \\c c and\n/// \\c s.\nextern const AstTypeMatcher<EnumType> enumType;\n\n/// Matches template specialization types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { };\n///\n///   template class C<int>;  // A\n///   C<char> var;            // B\n/// \\endcode\n///\n/// \\c templateSpecializationType() matches the type of the explicit\n/// instantiation in \\c A and the type of the variable declaration in \\c B.\nextern const AstTypeMatcher<TemplateSpecializationType>\n    templateSpecializationType;\n\n/// Matches C++17 deduced template specialization types, e.g. deduced class\n/// template types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { public: C(T); };\n///\n///   C c(123);\n/// \\endcode\n/// \\c deducedTemplateSpecializationType() matches the type in the declaration\n/// of the variable \\c c.\nextern const AstTypeMatcher<DeducedTemplateSpecializationType>\n    deducedTemplateSpecializationType;\n\n/// Matches types nodes representing unary type transformations.\n///\n/// Given:\n/// \\code\n///   typedef __underlying_type(T) type;\n/// \\endcode\n/// unaryTransformType()\n///   matches \"__underlying_type(T)\"\nextern const AstTypeMatcher<UnaryTransformType> unaryTransformType;\n\n/// Matches record types (e.g. structs, classes).\n///\n/// Given\n/// \\code\n///   class C {};\n///   struct S {};\n///\n///   C c;\n///   S s;\n/// \\endcode\n///\n/// \\c recordType() matches the type of the variable declarations of both \\c c\n/// and \\c s.\nextern const AstTypeMatcher<RecordType> recordType;\n\n/// Matches tag types (record and enum types).\n///\n/// Given\n/// \\code\n///   enum E {};\n///   class C {};\n///\n///   E e;\n///   C c;\n/// \\endcode\n///\n/// \\c tagType() matches the type of the variable declarations of both \\c e\n/// and \\c c.\nextern const AstTypeMatcher<TagType> tagType;\n\n/// Matches types specified with an elaborated type keyword or with a\n/// qualified name.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   class C {};\n///\n///   class C c;\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType() matches the type of the variable declarations of both\n/// \\c c and \\c d.\nextern const AstTypeMatcher<ElaboratedType> elaboratedType;\n\n/// Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,\n/// matches \\c InnerMatcher if the qualifier exists.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(\"N\"))))\n/// matches the type of the variable declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, hasQualifier,\n              internal::Matcher<NestedNameSpecifier>, InnerMatcher) {\n  if (const NestedNameSpecifier *Qualifier = Node.getQualifier())\n    return InnerMatcher.matches(*Qualifier, Finder, Builder);\n\n  return false;\n}\n\n/// Matches ElaboratedTypes whose named type matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(namesType(recordType(\n/// hasDeclaration(namedDecl(hasName(\"D\")))))) matches the type of the variable\n/// declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, namesType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getNamedType(), Finder, Builder);\n}\n\n/// Matches types specified through a using declaration.\n///\n/// Given\n/// \\code\n///   namespace a { struct S {}; }\n///   using a::S;\n///   S s;\n/// \\endcode\n///\n/// \\c usingType() matches the type of the variable declaration of \\c s.\nextern const AstTypeMatcher<UsingType> usingType;\n\n/// Matches types that represent the result of substituting a type for a\n/// template type parameter.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   void F(T t) {\n///     int i = 1 + t;\n///   }\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType() matches the type of 't' but not '1'\nextern const AstTypeMatcher<SubstTemplateTypeParmType>\n    substTemplateTypeParmType;\n\n/// Matches template type parameter substitutions that have a replacement\n/// type that matches the provided matcher.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   double F(T t);\n///   int i;\n///   double j = F(i);\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType(hasReplacementType(type())) matches int\nAST_TYPE_TRAVERSE_MATCHER(\n    hasReplacementType, getReplacementType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(SubstTemplateTypeParmType));\n\n/// Matches template type parameter types.\n///\n/// Example matches T, but not int.\n///     (matcher = templateTypeParmType())\n/// \\code\n///   template <typename T> void f(int i);\n/// \\endcode\nextern const AstTypeMatcher<TemplateTypeParmType> templateTypeParmType;\n\n/// Matches injected class name types.\n///\n/// Example matches S s, but not S<T> s.\n///     (matcher = parmVarDecl(hasType(injectedClassNameType())))\n/// \\code\n///   template <typename T> struct S {\n///     void f(S s);\n///     void g(S<T> s);\n///   };\n/// \\endcode\nextern const AstTypeMatcher<InjectedClassNameType> injectedClassNameType;\n\n/// Matches decayed type\n/// Example matches i[] in declaration of f.\n///     (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType())))))\n/// Example matches i[1].\n///     (matcher = expr(hasType(decayedType(hasDecayedType(pointerType())))))\n/// \\code\n///   void f(int i[]) {\n///     i[1] = 0;\n///   }\n/// \\endcode\nextern const AstTypeMatcher<DecayedType> decayedType;\n\n/// Matches the decayed type, whoes decayed type matches \\c InnerMatcher\nAST_MATCHER_P(DecayedType, hasDecayedType, internal::Matcher<QualType>,\n              InnerType) {\n  return InnerType.matches(Node.getDecayedType(), Finder, Builder);\n}\n\n/// Matches declarations whose declaration context, interpreted as a\n/// Decl, matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n/// \\endcode\n///\n/// \\c cxxRcordDecl(hasDeclContext(namedDecl(hasName(\"M\")))) matches the\n/// declaration of \\c class \\c D.\nAST_MATCHER_P(Decl, hasDeclContext, internal::Matcher<Decl>, InnerMatcher) {\n  const DeclContext *DC = Node.getDeclContext();\n  if (!DC) return false;\n  return InnerMatcher.matches(*Decl::castFromDeclContext(DC), Finder, Builder);\n}\n\n/// Matches nested name specifiers.\n///\n/// Given\n/// \\code\n///   namespace ns {\n///     struct A { static void f(); };\n///     void A::f() {}\n///     void g() { A::f(); }\n///   }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier()\n///   matches \"ns::\" and both \"A::\"\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifier>\n    nestedNameSpecifier;\n\n/// Same as \\c nestedNameSpecifier but matches \\c NestedNameSpecifierLoc.\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifierLoc>\n    nestedNameSpecifierLoc;\n\n/// Matches \\c NestedNameSpecifierLocs for which the given inner\n/// NestedNameSpecifier-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(\n    internal::BindableMatcher<NestedNameSpecifierLoc>, loc,\n    internal::Matcher<NestedNameSpecifier>, InnerMatcher, 1) {\n  return internal::BindableMatcher<NestedNameSpecifierLoc>(\n      new internal::LocMatcher<NestedNameSpecifierLoc, NestedNameSpecifier>(\n          InnerMatcher));\n}\n\n/// Matches nested name specifiers that specify a type matching the\n/// given \\c QualType matcher without qualifiers.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(specifiesType(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))\n/// ))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (!Node.getAsType())\n    return false;\n  return InnerMatcher.matches(QualType(Node.getAsType(), 0), Finder, Builder);\n}\n\n/// Matches nested name specifier locs that specify a type matching the\n/// given \\c TypeLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))))))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifierLoc, specifiesTypeLoc,\n              internal::Matcher<TypeLoc>, InnerMatcher) {\n  return Node && Node.getNestedNameSpecifier()->getAsType() &&\n         InnerMatcher.matches(Node.getTypeLoc(), Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifier.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(hasPrefix(specifiesType(asString(\"struct A\")))) and\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifier, hasPrefix,\n                       internal::Matcher<NestedNameSpecifier>, InnerMatcher,\n                       0) {\n  const NestedNameSpecifier *NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(*NextNode, Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifierLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(\"struct A\")))))\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifierLoc, hasPrefix,\n                       internal::Matcher<NestedNameSpecifierLoc>, InnerMatcher,\n                       1) {\n  NestedNameSpecifierLoc NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(NextNode, Finder, Builder);\n}\n\n/// Matches nested name specifiers that specify a namespace matching the\n/// given namespace matcher.\n///\n/// Given\n/// \\code\n///   namespace ns { struct A {}; }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier(specifiesNamespace(hasName(\"ns\")))\n///   matches \"ns::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesNamespace,\n              internal::Matcher<NamespaceDecl>, InnerMatcher) {\n  if (!Node.getAsNamespace())\n    return false;\n  return InnerMatcher.matches(*Node.getAsNamespace(), Finder, Builder);\n}\n\n/// Matches attributes.\n/// Attributes may be attached with a variety of different syntaxes (including\n/// keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,\n/// and ``#pragma``s). They may also be implicit.\n///\n/// Given\n/// \\code\n///   struct [[nodiscard]] Foo{};\n///   void bar(int * __attribute__((nonnull)) );\n///   __declspec(noinline) void baz();\n///\n///   #pragma omp declare simd\n///   int min();\n/// \\endcode\n/// attr()\n///   matches \"nodiscard\", \"nonnull\", \"noinline\", and the whole \"#pragma\" line.\nextern const internal::VariadicAllOfMatcher<Attr> attr;\n\n/// Overloads for the \\c equalsNode matcher.\n/// FIXME: Implement for other node types.\n/// @{\n\n/// Matches if a node equals another node.\n///\n/// \\c Decl has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Decl, equalsNode, const Decl*, Other, 0) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Stmt has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Stmt, equalsNode, const Stmt*, Other, 1) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Type has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Type, equalsNode, const Type*, Other, 2) {\n    return &Node == Other;\n}\n\n/// @}\n\n/// Matches each case or default statement belonging to the given switch\n/// statement. This matcher may produce multiple matches.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }\n/// \\endcode\n/// switchStmt(forEachSwitchCase(caseStmt().bind(\"c\"))).bind(\"s\")\n///   matches four times, with \"c\" binding each of \"case 1:\", \"case 2:\",\n/// \"case 3:\" and \"case 4:\", and \"s\" respectively binding \"switch (1)\",\n/// \"switch (1)\", \"switch (2)\" and \"switch (2)\".\nAST_MATCHER_P(SwitchStmt, forEachSwitchCase, internal::Matcher<SwitchCase>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  // FIXME: getSwitchCaseList() does not necessarily guarantee a stable\n  // iteration order. We should use the more general iterating matchers once\n  // they are capable of expressing this matcher (for example, it should ignore\n  // case statements belonging to nested switch statements).\n  bool Matched = false;\n  for (const SwitchCase *SC = Node.getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    BoundNodesTreeBuilder CaseBuilder(*Builder);\n    bool CaseMatched = InnerMatcher.matches(*SC, Finder, &CaseBuilder);\n    if (CaseMatched) {\n      Matched = true;\n      Result.addMatch(CaseBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches each constructor initializer in a constructor definition.\n///\n/// Given\n/// \\code\n///   class A { A() : i(42), j(42) {} int i; int j; };\n/// \\endcode\n/// cxxConstructorDecl(forEachConstructorInitializer(\n///   forField(decl().bind(\"x\"))\n/// ))\n///   will trigger two matches, binding for 'i' and 'j' respectively.\nAST_MATCHER_P(CXXConstructorDecl, forEachConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *I : Node.inits()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() && !I->isWritten())\n      continue;\n    BoundNodesTreeBuilder InitBuilder(*Builder);\n    if (InnerMatcher.matches(*I, Finder, &InitBuilder)) {\n      Matched = true;\n      Result.addMatch(InitBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches constructor declarations that are copy constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3.\nAST_MATCHER(CXXConstructorDecl, isCopyConstructor) {\n  return Node.isCopyConstructor();\n}\n\n/// Matches constructor declarations that are move constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isMoveConstructor) {\n  return Node.isMoveConstructor();\n}\n\n/// Matches constructor declarations that are default constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXConstructorDecl, isDefaultConstructor) {\n  return Node.isDefaultConstructor();\n}\n\n/// Matches constructors that delegate to another constructor.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(int) {} // #2\n///     S(S &&) : S() {} // #3\n///   };\n///   S::S() : S(0) {} // #4\n/// \\endcode\n/// cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not\n/// #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isDelegatingConstructor) {\n  return Node.isDelegatingConstructor();\n}\n\n/// Matches constructor, conversion function, and deduction guide declarations\n/// that have an explicit specifier if this explicit specifier is resolved to\n/// true.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.\n/// cxxConversionDecl(isExplicit()) will match #4, but not #3.\n/// cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5.\nAST_POLYMORPHIC_MATCHER(isExplicit, AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                        CXXConstructorDecl, CXXConversionDecl,\n                                        CXXDeductionGuideDecl)) {\n  return Node.isExplicit();\n}\n\n/// Matches the expression in an explicit specifier if present in the given\n/// declaration.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.\n/// cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.\n/// cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6.\nAST_MATCHER_P(FunctionDecl, hasExplicitSpecifier, internal::Matcher<Expr>,\n              InnerMatcher) {\n  ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(&Node);\n  if (!ES.getExpr())\n    return false;\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  return InnerMatcher.matches(*ES.getExpr(), Finder, Builder);\n}\n\n/// Matches functions, variables and namespace declarations that are marked with\n/// the inline keyword.\n///\n/// Given\n/// \\code\n///   inline void f();\n///   void g();\n///   namespace n {\n///   inline namespace m {}\n///   }\n///   inline int Foo = 5;\n/// \\endcode\n/// functionDecl(isInline()) will match ::f().\n/// namespaceDecl(isInline()) will match n::m.\n/// varDecl(isInline()) will match Foo;\nAST_POLYMORPHIC_MATCHER(isInline, AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,\n                                                                  FunctionDecl,\n                                                                  VarDecl)) {\n  // This is required because the spelling of the function used to determine\n  // whether inline is specified or not differs between the polymorphic types.\n  if (const auto *FD = dyn_cast<FunctionDecl>(&Node))\n    return FD->isInlineSpecified();\n  if (const auto *NSD = dyn_cast<NamespaceDecl>(&Node))\n    return NSD->isInline();\n  if (const auto *VD = dyn_cast<VarDecl>(&Node))\n    return VD->isInline();\n  llvm_unreachable(\"Not a valid polymorphic type\");\n}\n\n/// Matches anonymous namespace declarations.\n///\n/// Given\n/// \\code\n///   namespace n {\n///   namespace {} // #1\n///   }\n/// \\endcode\n/// namespaceDecl(isAnonymous()) will match #1 but not ::n.\nAST_MATCHER(NamespaceDecl, isAnonymous) {\n  return Node.isAnonymousNamespace();\n}\n\n/// Matches declarations in the namespace `std`, but not in nested namespaces.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace std {\n///       class vector {};\n///     }\n///   }\n///   namespace std {\n///     inline namespace __1 {\n///       class vector {}; // #1\n///       namespace experimental {\n///         class vector {};\n///       }\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInStdNamespace()) will match only #1.\nAST_MATCHER(Decl, isInStdNamespace) { return Node.isInStdNamespace(); }\n\n/// Matches declarations in an anonymous namespace.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace {\n///       class vector {}; // #1\n///     }\n///   }\n///   namespace {\n///     class vector {}; // #2\n///     namespace foo {\n///       class vector{}; // #3\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInAnonymousNamespace()) will match\n/// #1, #2 and #3.\nAST_MATCHER(Decl, isInAnonymousNamespace) {\n  return Node.isInAnonymousNamespace();\n}\n\n/// If the given case statement does not use the GNU case range\n/// extension, matches the constant given in the statement.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }\n/// \\endcode\n/// caseStmt(hasCaseConstant(integerLiteral()))\n///   matches \"case 1:\"\nAST_MATCHER_P(CaseStmt, hasCaseConstant, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (Node.getRHS())\n    return false;\n\n  return InnerMatcher.matches(*Node.getLHS(), Finder, Builder);\n}\n\n/// Matches declaration that has a given attribute.\n///\n/// Given\n/// \\code\n///   __attribute__((device)) void f() { ... }\n/// \\endcode\n/// decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of\n/// f. If the matcher is used from clang-query, attr::Kind parameter should be\n/// passed as a quoted string. e.g., hasAttr(\"attr::CUDADevice\").\nAST_MATCHER_P(Decl, hasAttr, attr::Kind, AttrKind) {\n  for (const auto *Attr : Node.attrs()) {\n    if (Attr->getKind() == AttrKind)\n      return true;\n  }\n  return false;\n}\n\n/// Matches the return value expression of a return statement\n///\n/// Given\n/// \\code\n///   return a + b;\n/// \\endcode\n/// hasReturnValue(binaryOperator())\n///   matches 'return a + b'\n/// with binaryOperator()\n///   matching 'a + b'\nAST_MATCHER_P(ReturnStmt, hasReturnValue, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (const auto *RetValue = Node.getRetValue())\n    return InnerMatcher.matches(*RetValue, Finder, Builder);\n  return false;\n}\n\n/// Matches CUDA kernel call expression.\n///\n/// Example matches,\n/// \\code\n///   kernel<<<i,j>>>();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CUDAKernelCallExpr>\n    cudaKernelCallExpr;\n\n/// Matches expressions that resolve to a null pointer constant, such as\n/// GNU's __null, C++11's nullptr, or C's NULL macro.\n///\n/// Given:\n/// \\code\n///   void *v1 = NULL;\n///   void *v2 = nullptr;\n///   void *v3 = __null; // GNU extension\n///   char *cp = (char *)0;\n///   int *ip = 0;\n///   int i = 0;\n/// \\endcode\n/// expr(nullPointerConstant())\n///   matches the initializer for v1, v2, v3, cp, and ip. Does not match the\n///   initializer for i.\nAST_MATCHER_FUNCTION(internal::Matcher<Expr>, nullPointerConstant) {\n  return anyOf(\n      gnuNullExpr(), cxxNullPtrLiteralExpr(),\n      integerLiteral(equals(0), hasParent(expr(hasType(pointerType())))));\n}\n\n/// Matches the DecompositionDecl the binding belongs to.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   bindingDecl(hasName(\"f\"),\n///                 forDecomposition(decompositionDecl())\n/// \\endcode\n/// matches 'f' in 'auto &[f, s, t]'.\nAST_MATCHER_P(BindingDecl, forDecomposition, internal::Matcher<ValueDecl>,\n              InnerMatcher) {\n  if (const ValueDecl *VD = Node.getDecomposedDecl())\n    return InnerMatcher.matches(*VD, Finder, Builder);\n  return false;\n}\n\n/// Matches the Nth binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasBinding(0,\n///   bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P2(DecompositionDecl, hasBinding, unsigned, N,\n               internal::Matcher<BindingDecl>, InnerMatcher) {\n  if (Node.bindings().size() <= N)\n    return false;\n  return InnerMatcher.matches(*Node.bindings()[N], Finder, Builder);\n}\n\n/// Matches any binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasAnyBinding(bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P(DecompositionDecl, hasAnyBinding, internal::Matcher<BindingDecl>,\n              InnerMatcher) {\n  return llvm::any_of(Node.bindings(), [&](const auto *Binding) {\n    return InnerMatcher.matches(*Binding, Finder, Builder);\n  });\n}\n\n/// Matches declaration of the function the statement belongs to.\n///\n/// Deprecated. Use forCallable() to correctly handle the situation when\n/// the declaration is not a function (but a block or an Objective-C method).\n/// forFunction() not only fails to take non-functions into account but also\n/// may match the wrong declaration in their presence.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forFunction(hasName(\"operator=\")))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\nAST_MATCHER_P(Stmt, forFunction, internal::Matcher<FunctionDecl>,\n              InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches declaration of the function, method, or block the statement\n/// belongs to.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forCallable(functionDecl(hasName(\"operator=\"))))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\n///\n/// Given:\n/// \\code\n/// -(void) foo {\n///   int x = 1;\n///   dispatch_sync(queue, ^{ int y = 2; });\n/// }\n/// \\endcode\n/// declStmt(forCallable(objcMethodDecl()))\n///   matches 'int x = 1'\n///   but does not match 'int y = 2'.\n/// whereas declStmt(forCallable(blockDecl()))\n///   matches 'int y = 2'\n///   but does not match 'int x = 1'.\nAST_MATCHER_P(Stmt, forCallable, internal::Matcher<Decl>, InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else if (const auto *ObjCMethodDeclNode = CurNode.get<ObjCMethodDecl>()) {\n      if (InnerMatcher.matches(*ObjCMethodDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *BlockDeclNode = CurNode.get<BlockDecl>()) {\n      if (InnerMatcher.matches(*BlockDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches a declaration that has external formal linkage.\n///\n/// Example matches only z (matcher = varDecl(hasExternalFormalLinkage()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\n///\n/// Example matches f() because it has external formal linkage despite being\n/// unique to the translation unit as though it has internal likage\n/// (matcher = functionDecl(hasExternalFormalLinkage()))\n///\n/// \\code\n/// namespace {\n/// void f() {}\n/// }\n/// \\endcode\nAST_MATCHER(NamedDecl, hasExternalFormalLinkage) {\n  return Node.hasExternalFormalLinkage();\n}\n\n/// Matches a declaration that has default arguments.\n///\n/// Example matches y (matcher = parmVarDecl(hasDefaultArgument()))\n/// \\code\n/// void x(int val) {}\n/// void y(int val = 0) {}\n/// \\endcode\n///\n/// Deprecated. Use hasInitializer() instead to be able to\n/// match on the contents of the default argument.  For example:\n///\n/// \\code\n/// void x(int val = 7) {}\n/// void y(int val = 42) {}\n/// \\endcode\n/// parmVarDecl(hasInitializer(integerLiteral(equals(42))))\n///   matches the parameter of y\n///\n/// A matcher such as\n///   parmVarDecl(hasInitializer(anything()))\n/// is equivalent to parmVarDecl(hasDefaultArgument()).\nAST_MATCHER(ParmVarDecl, hasDefaultArgument) {\n  return Node.hasDefaultArg();\n}\n\n/// Matches array new expressions.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(isArray())\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER(CXXNewExpr, isArray) {\n  return Node.isArray();\n}\n\n/// Matches placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage, 16) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16))))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,\n               internal::Matcher<Expr>, InnerMatcher) {\n  return Node.getNumPlacementArgs() > Index &&\n         InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder);\n}\n\n/// Matches any placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasAnyPlacementArg(anything()))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return llvm::any_of(Node.placement_arguments(), [&](const Expr *Arg) {\n    return InnerMatcher.matches(*Arg, Finder, Builder);\n  });\n}\n\n/// Matches array new expressions with a given array size.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(hasArraySize(integerLiteral(equals(10))))\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher<Expr>, InnerMatcher) {\n  return Node.isArray() && *Node.getArraySize() &&\n         InnerMatcher.matches(**Node.getArraySize(), Finder, Builder);\n}\n\n/// Matches a class declaration that is defined.\n///\n/// Example matches x (matcher = cxxRecordDecl(hasDefinition()))\n/// \\code\n/// class x {};\n/// class y;\n/// \\endcode\nAST_MATCHER(CXXRecordDecl, hasDefinition) {\n  return Node.hasDefinition();\n}\n\n/// Matches C++11 scoped enum declaration.\n///\n/// Example matches Y (matcher = enumDecl(isScoped()))\n/// \\code\n/// enum X {};\n/// enum class Y {};\n/// \\endcode\nAST_MATCHER(EnumDecl, isScoped) {\n  return Node.isScoped();\n}\n\n/// Matches a function declared with a trailing return type.\n///\n/// Example matches Y (matcher = functionDecl(hasTrailingReturn()))\n/// \\code\n/// int X() {}\n/// auto Y() -> int {}\n/// \\endcode\nAST_MATCHER(FunctionDecl, hasTrailingReturn) {\n  if (const auto *F = Node.getType()->getAs<FunctionProtoType>())\n    return F->hasTrailingReturn();\n  return false;\n}\n\n/// Matches expressions that match InnerMatcher that are possibly wrapped in an\n/// elidable constructor and other corresponding bookkeeping nodes.\n///\n/// In C++17, elidable copy constructors are no longer being generated in the\n/// AST as it is not permitted by the standard. They are, however, part of the\n/// AST in C++14 and earlier. So, a matcher must abstract over these differences\n/// to work in all language modes. This matcher skips elidable constructor-call\n/// AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and\n/// various implicit nodes inside the constructor calls, all of which will not\n/// appear in the C++17 AST.\n///\n/// Given\n///\n/// \\code\n/// struct H {};\n/// H G();\n/// void f() {\n///   H D = G();\n/// }\n/// \\endcode\n///\n/// ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``\n/// matches ``H D = G()`` in C++11 through C++17 (and beyond).\nAST_MATCHER_P(Expr, ignoringElidableConstructorCall,\n              ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  // E tracks the node that we are examining.\n  const Expr *E = &Node;\n  // If present, remove an outer `ExprWithCleanups` corresponding to the\n  // underlying `CXXConstructExpr`. This check won't cover all cases of added\n  // `ExprWithCleanups` corresponding to `CXXConstructExpr` nodes (because the\n  // EWC is placed on the outermost node of the expression, which this may not\n  // be), but, it still improves the coverage of this matcher.\n  if (const auto *CleanupsExpr = dyn_cast<ExprWithCleanups>(&Node))\n    E = CleanupsExpr->getSubExpr();\n  if (const auto *CtorExpr = dyn_cast<CXXConstructExpr>(E)) {\n    if (CtorExpr->isElidable()) {\n      if (const auto *MaterializeTemp =\n              dyn_cast<MaterializeTemporaryExpr>(CtorExpr->getArg(0))) {\n        return InnerMatcher.matches(*MaterializeTemp->getSubExpr(), Finder,\n                                    Builder);\n      }\n    }\n  }\n  return InnerMatcher.matches(Node, Finder, Builder);\n}\n\n//----------------------------------------------------------------------------//\n// OpenMP handling.\n//----------------------------------------------------------------------------//\n\n/// Matches any ``#pragma omp`` executable directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective()`` matches ``omp parallel``,\n/// ``omp parallel default(none)`` and ``omp taskyield``.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OMPExecutableDirective>\n    ompExecutableDirective;\n\n/// Matches standalone OpenMP directives,\n/// i.e., directives that can't have a structured block.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   {}\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective(isStandaloneDirective()))`` matches\n/// ``omp taskyield``.\nAST_MATCHER(OMPExecutableDirective, isStandaloneDirective) {\n  return Node.isStandaloneDirective();\n}\n\n/// Matches the structured-block of the OpenMP executable directive\n///\n/// Prerequisite: the executable directive must not be standalone directive.\n/// If it is, it will never match.\n///\n/// Given\n///\n/// \\code\n///    #pragma omp parallel\n///    ;\n///    #pragma omp parallel\n///    {}\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``\nAST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  if (Node.isStandaloneDirective())\n    return false; // Standalone directives have no structured blocks.\n  return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder);\n}\n\n/// Matches any clause in an OpenMP directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasAnyClause(anything()))`` matches\n/// ``omp parallel default(none)``.\nAST_MATCHER_P(OMPExecutableDirective, hasAnyClause,\n              internal::Matcher<OMPClause>, InnerMatcher) {\n  ArrayRef<OMPClause *> Clauses = Node.clauses();\n  return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(),\n                                    Clauses.end(), Finder,\n                                    Builder) != Clauses.end();\n}\n\n/// Matches OpenMP ``default`` clause.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n///   #pragma omp parallel\n/// \\endcode\n///\n/// ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,\n/// `` default(private)`` and ``default(firstprivate)``\nextern const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>\n    ompDefaultClause;\n\n/// Matches if the OpenMP ``default`` clause has ``none`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isNoneKind())`` matches only ``default(none)``.\nAST_MATCHER(OMPDefaultClause, isNoneKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``shared`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isSharedKind())`` matches only ``default(shared)``.\nAST_MATCHER(OMPDefaultClause, isSharedKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``private`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isPrivateKind())`` matches only\n/// ``default(private)``.\nAST_MATCHER(OMPDefaultClause, isPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_private;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``firstprivate`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isFirstPrivateKind())`` matches only\n/// ``default(firstprivate)``.\nAST_MATCHER(OMPDefaultClause, isFirstPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate;\n}\n\n/// Matches if the OpenMP directive is allowed to contain the specified OpenMP\n/// clause kind.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel for\n///   #pragma omp          for\n/// \\endcode\n///\n/// `ompExecutableDirective(isAllowedToContainClause(OMPC_default))`` matches\n/// ``omp parallel`` and ``omp parallel for``.\n///\n/// If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter\n/// should be passed as a quoted string. e.g.,\n/// ``isAllowedToContainClauseKind(\"OMPC_default\").``\nAST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,\n              OpenMPClauseKind, CKind) {\n  return llvm::omp::isAllowedClauseForDirective(\n      Node.getDirectiveKind(), CKind,\n      Finder->getASTContext().getLangOpts().OpenMP);\n}\n\n//----------------------------------------------------------------------------//\n// End OpenMP handling.\n//----------------------------------------------------------------------------//\n\n}",
  "id": "BLOCK-CPP-15093",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchers.h",
  "source_line": 2602,
  "validation_status": "validated"
}