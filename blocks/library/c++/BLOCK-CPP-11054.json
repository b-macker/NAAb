{
  "code": "{\nprivate:\n  /// If the bool is true, this is an implicit property reference; the\n  /// pointer is an (optional) ObjCMethodDecl and Setter may be set.\n  /// if the bool is false, this is an explicit property reference;\n  /// the pointer is an ObjCPropertyDecl and Setter is always null.\n  llvm::PointerIntPair<NamedDecl *, 1, bool> PropertyOrGetter;\n\n  /// Indicates whether the property reference will result in a message\n  /// to the getter, the setter, or both.\n  /// This applies to both implicit and explicit property references.\n  enum MethodRefFlags {\n    MethodRef_None = 0,\n    MethodRef_Getter = 0x1,\n    MethodRef_Setter = 0x2\n  };\n\n  /// Contains the Setter method pointer and MethodRefFlags bit flags.\n  llvm::PointerIntPair<ObjCMethodDecl *, 2, unsigned> SetterAndMethodRefFlags;\n\n  // FIXME: Maybe we should store the property identifier here,\n  // because it's not rederivable from the other data when there's an\n  // implicit property with no getter (because the 'foo' -> 'setFoo:'\n  // transformation is lossy on the first character).\n\n  SourceLocation IdLoc;\n\n  /// When the receiver in property access is 'super', this is\n  /// the location of the 'super' keyword.  When it's an interface,\n  /// this is that interface.\n  SourceLocation ReceiverLoc;\n  llvm::PointerUnion<Stmt *, const Type *, ObjCInterfaceDecl *> Receiver;\n\npublic:\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, Expr *base)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), Receiver(base) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, SourceLocation sl,\n                      QualType st)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), ReceiverLoc(sl), Receiver(st.getTypePtr()) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, Expr *Base)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), Receiver(Base) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation SuperLoc,\n                      QualType SuperTy)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(SuperLoc), Receiver(SuperTy.getTypePtr()) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation ReceiverLoc,\n                      ObjCInterfaceDecl *Receiver)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(ReceiverLoc), Receiver(Receiver) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCPropertyRefExpr(EmptyShell Empty)\n      : Expr(ObjCPropertyRefExprClass, Empty) {}\n\n  bool isImplicitProperty() const { return PropertyOrGetter.getInt(); }\n  bool isExplicitProperty() const { return !PropertyOrGetter.getInt(); }\n\n  ObjCPropertyDecl *getExplicitProperty() const {\n    assert(!isImplicitProperty());\n    return cast<ObjCPropertyDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertyGetter() const {\n    assert(isImplicitProperty());\n    return cast_or_null<ObjCMethodDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertySetter() const {\n    assert(isImplicitProperty());\n    return SetterAndMethodRefFlags.getPointer();\n  }\n\n  Selector getGetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertyGetter()->getSelector();\n    return getExplicitProperty()->getGetterName();\n  }\n\n  Selector getSetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertySetter()->getSelector();\n    return getExplicitProperty()->getSetterName();\n  }\n\n  /// True if the property reference will result in a message to the\n  /// getter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingGetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Getter;\n  }\n\n  /// True if the property reference will result in a message to the\n  /// setter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingSetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Setter;\n  }\n\n  void setIsMessagingGetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Getter, val);\n  }\n\n  void setIsMessagingSetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Setter, val);\n  }\n\n  const Expr *getBase() const {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n  Expr *getBase() {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n\n  SourceLocation getLocation() const { return IdLoc; }\n\n  SourceLocation getReceiverLocation() const { return ReceiverLoc; }\n\n  QualType getSuperReceiverType() const {\n    return QualType(Receiver.get<const Type*>(), 0);\n  }\n\n  ObjCInterfaceDecl *getClassReceiver() const {\n    return Receiver.get<ObjCInterfaceDecl*>();\n  }\n\n  bool isObjectReceiver() const { return Receiver.is<Stmt*>(); }\n  bool isSuperReceiver() const { return Receiver.is<const Type*>(); }\n  bool isClassReceiver() const { return Receiver.is<ObjCInterfaceDecl*>(); }\n\n  /// Determine the type of the base, regardless of the kind of receiver.\n  QualType getReceiverType(const ASTContext &ctx) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isObjectReceiver() ? getBase()->getBeginLoc()\n                              : getReceiverLocation();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return IdLoc; }\n\n  // Iterators\n  child_range children() {\n    if (Receiver.is<Stmt*>()) {\n      Stmt **begin = reinterpret_cast<Stmt**>(&Receiver); // hack!\n      return child_range(begin, begin+1);\n    }\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCPropertyRefExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCPropertyRefExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  void setExplicitProperty(ObjCPropertyDecl *D, unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(D);\n    PropertyOrGetter.setInt(false);\n    SetterAndMethodRefFlags.setPointer(nullptr);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setImplicitProperty(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                           unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(Getter);\n    PropertyOrGetter.setInt(true);\n    SetterAndMethodRefFlags.setPointer(Setter);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setBase(Expr *Base) { Receiver = Base; }\n  void setSuperReceiver(QualType T) { Receiver = T.getTypePtr(); }\n  void setClassReceiver(ObjCInterfaceDecl *D) { Receiver = D; }\n\n  void setLocation(SourceLocation L) { IdLoc = L; }\n  void setReceiverLocation(SourceLocation Loc) { ReceiverLoc = Loc; }\n\n  void setMethodRefFlag(MethodRefFlags flag, bool val) {\n    unsigned f = SetterAndMethodRefFlags.getInt();\n    if (val)\n      f |= flag;\n    else\n      f &= ~flag;\n    SetterAndMethodRefFlags.setInt(f);\n  }\n}",
  "id": "BLOCK-CPP-11054",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprObjC.h",
  "source_line": 614,
  "validation_status": "validated"
}