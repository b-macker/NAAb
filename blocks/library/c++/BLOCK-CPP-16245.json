{
  "code": "{\n  public:\n    /// Add an initial diagnostic state.\n    void appendFirst(DiagState *State);\n\n    /// Add a new latest state point.\n    void append(SourceManager &SrcMgr, SourceLocation Loc, DiagState *State);\n\n    /// Look up the diagnostic state at a given source location.\n    DiagState *lookup(SourceManager &SrcMgr, SourceLocation Loc) const;\n\n    /// Determine whether this map is empty.\n    bool empty() const { return Files.empty(); }\n\n    /// Clear out this map.\n    void clear() {\n      Files.clear();\n      FirstDiagState = CurDiagState = nullptr;\n      CurDiagStateLoc = SourceLocation();\n    }\n\n    /// Produce a debugging dump of the diagnostic state.\n    LLVM_DUMP_METHOD void dump(SourceManager &SrcMgr,\n                               StringRef DiagName = StringRef()) const;\n\n    /// Grab the most-recently-added state point.\n    DiagState *getCurDiagState() const { return CurDiagState; }\n\n    /// Get the location at which a diagnostic state was last added.\n    SourceLocation getCurDiagStateLoc() const { return CurDiagStateLoc; }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    /// Represents a point in source where the diagnostic state was\n    /// modified because of a pragma.\n    ///\n    /// 'Loc' can be null if the point represents the diagnostic state\n    /// modifications done through the command-line.\n    struct DiagStatePoint {\n      DiagState *State;\n      unsigned Offset;\n\n      DiagStatePoint(DiagState *State, unsigned Offset)\n          : State(State), Offset(Offset) {}\n    };\n\n    /// Description of the diagnostic states and state transitions for a\n    /// particular FileID.\n    struct File {\n      /// The diagnostic state for the parent file. This is strictly redundant,\n      /// as looking up the DecomposedIncludedLoc for the FileID in the Files\n      /// map would give us this, but we cache it here for performance.\n      File *Parent = nullptr;\n\n      /// The offset of this file within its parent.\n      unsigned ParentOffset = 0;\n\n      /// Whether this file has any local (not imported from an AST file)\n      /// diagnostic state transitions.\n      bool HasLocalTransitions = false;\n\n      /// The points within the file where the state changes. There will always\n      /// be at least one of these (the state on entry to the file).\n      llvm::SmallVector<DiagStatePoint, 4> StateTransitions;\n\n      DiagState *lookup(unsigned Offset) const;\n    };\n\n    /// The diagnostic states for each file.\n    mutable std::map<FileID, File> Files;\n\n    /// The initial diagnostic state.\n    DiagState *FirstDiagState;\n\n    /// The current diagnostic state.\n    DiagState *CurDiagState;\n\n    /// The location at which the current diagnostic state was established.\n    SourceLocation CurDiagStateLoc;\n\n    /// Get the diagnostic state information for a file.\n    File *getFile(SourceManager &SrcMgr, FileID ID) const;\n  }",
  "id": "BLOCK-CPP-16245",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Diagnostic.h",
  "source_line": 362,
  "validation_status": "validated"
}