{
  "code": "{\n\n/// Provides information about an attempted template argument\n/// deduction, whose success or failure was described by a\n/// TemplateDeductionResult value.\nclass TemplateDeductionInfo {\n  /// The deduced template argument list.\n  TemplateArgumentList *DeducedSugared = nullptr, *DeducedCanonical = nullptr;\n\n  /// The source location at which template argument\n  /// deduction is occurring.\n  SourceLocation Loc;\n\n  /// Have we suppressed an error during deduction?\n  bool HasSFINAEDiagnostic = false;\n\n  /// The template parameter depth for which we're performing deduction.\n  unsigned DeducedDepth;\n\n  /// The number of parameters with explicitly-specified template arguments,\n  /// up to and including the partially-specified pack (if any).\n  unsigned ExplicitArgs = 0;\n\n  /// Warnings (and follow-on notes) that were suppressed due to\n  /// SFINAE while performing template argument deduction.\n  SmallVector<PartialDiagnosticAt, 4> SuppressedDiagnostics;\n\npublic:\n  TemplateDeductionInfo(SourceLocation Loc, unsigned DeducedDepth = 0)\n      : Loc(Loc), DeducedDepth(DeducedDepth) {}\n  TemplateDeductionInfo(const TemplateDeductionInfo &) = delete;\n  TemplateDeductionInfo &operator=(const TemplateDeductionInfo &) = delete;\n\n  enum ForBaseTag { ForBase };\n  /// Create temporary template deduction info for speculatively deducing\n  /// against a base class of an argument's type.\n  TemplateDeductionInfo(ForBaseTag, const TemplateDeductionInfo &Info)\n      : DeducedSugared(Info.DeducedSugared), Loc(Info.Loc),\n        DeducedDepth(Info.DeducedDepth), ExplicitArgs(Info.ExplicitArgs) {}\n\n  /// Returns the location at which template argument is\n  /// occurring.\n  SourceLocation getLocation() const {\n    return Loc;\n  }\n\n  /// The depth of template parameters for which deduction is being\n  /// performed.\n  unsigned getDeducedDepth() const {\n    return DeducedDepth;\n  }\n\n  /// Get the number of explicitly-specified arguments.\n  unsigned getNumExplicitArgs() const {\n    return ExplicitArgs;\n  }\n\n  /// Take ownership of the deduced template argument lists.\n  TemplateArgumentList *takeSugared() {\n    TemplateArgumentList *Result = DeducedSugared;\n    DeducedSugared = nullptr;\n    return Result;\n  }\n  TemplateArgumentList *takeCanonical() {\n    TemplateArgumentList *Result = DeducedCanonical;\n    DeducedCanonical = nullptr;\n    return Result;\n  }\n\n  /// Take ownership of the SFINAE diagnostic.\n  void takeSFINAEDiagnostic(PartialDiagnosticAt &PD) {\n    assert(HasSFINAEDiagnostic);\n    PD.first = SuppressedDiagnostics.front().first;\n    PD.second.swap(SuppressedDiagnostics.front().second);\n    clearSFINAEDiagnostic();\n  }\n\n  /// Discard any SFINAE diagnostics.\n  void clearSFINAEDiagnostic() {\n    SuppressedDiagnostics.clear();\n    HasSFINAEDiagnostic = false;\n  }\n\n  /// Peek at the SFINAE diagnostic.\n  const PartialDiagnosticAt &peekSFINAEDiagnostic() const {\n    assert(HasSFINAEDiagnostic);\n    return SuppressedDiagnostics.front();\n  }\n\n  /// Provide an initial template argument list that contains the\n  /// explicitly-specified arguments.\n  void setExplicitArgs(TemplateArgumentList *NewDeducedSugared,\n                       TemplateArgumentList *NewDeducedCanonical) {\n    assert(NewDeducedSugared->size() == NewDeducedCanonical->size());\n    DeducedSugared = NewDeducedSugared;\n    DeducedCanonical = NewDeducedCanonical;\n    ExplicitArgs = DeducedSugared->size();\n  }\n\n  /// Provide a new template argument list that contains the\n  /// results of template argument deduction.\n  void reset(TemplateArgumentList *NewDeducedSugared,\n             TemplateArgumentList *NewDeducedCanonical) {\n    DeducedSugared = NewDeducedSugared;\n    DeducedCanonical = NewDeducedCanonical;\n  }\n\n  /// Is a SFINAE diagnostic available?\n  bool hasSFINAEDiagnostic() const {\n    return HasSFINAEDiagnostic;\n  }\n\n  /// Set the diagnostic which caused the SFINAE failure.\n  void addSFINAEDiagnostic(SourceLocation Loc, PartialDiagnostic PD) {\n    // Only collect the first diagnostic.\n    if (HasSFINAEDiagnostic)\n      return;\n    SuppressedDiagnostics.clear();\n    SuppressedDiagnostics.emplace_back(Loc, std::move(PD));\n    HasSFINAEDiagnostic = true;\n  }\n\n  /// Add a new diagnostic to the set of diagnostics\n  void addSuppressedDiagnostic(SourceLocation Loc,\n                               PartialDiagnostic PD) {\n    if (HasSFINAEDiagnostic)\n      return;\n    SuppressedDiagnostics.emplace_back(Loc, std::move(PD));\n  }\n\n  /// Iterator over the set of suppressed diagnostics.\n  using diag_iterator = SmallVectorImpl<PartialDiagnosticAt>::const_iterator;\n\n  /// Returns an iterator at the beginning of the sequence of suppressed\n  /// diagnostics.\n  diag_iterator diag_begin() const { return SuppressedDiagnostics.begin(); }\n\n  /// Returns an iterator at the end of the sequence of suppressed\n  /// diagnostics.\n  diag_iterator diag_end() const { return SuppressedDiagnostics.end(); }\n\n  /// The template parameter to which a template argument\n  /// deduction failure refers.\n  ///\n  /// Depending on the result of template argument deduction, this\n  /// template parameter may have different meanings:\n  ///\n  ///   TDK_Incomplete: this is the first template parameter whose\n  ///   corresponding template argument was not deduced.\n  ///\n  ///   TDK_IncompletePack: this is the expanded parameter pack for\n  ///   which we deduced too few arguments.\n  ///\n  ///   TDK_Inconsistent: this is the template parameter for which\n  ///   two different template argument values were deduced.\n  TemplateParameter Param;\n\n  /// The first template argument to which the template\n  /// argument deduction failure refers.\n  ///\n  /// Depending on the result of the template argument deduction,\n  /// this template argument may have different meanings:\n  ///\n  ///   TDK_IncompletePack: this is the number of arguments we deduced\n  ///   for the pack.\n  ///\n  ///   TDK_Inconsistent: this argument is the first value deduced\n  ///   for the corresponding template parameter.\n  ///\n  ///   TDK_SubstitutionFailure: this argument is the template\n  ///   argument we were instantiating when we encountered an error.\n  ///\n  ///   TDK_DeducedMismatch: this is the parameter type, after substituting\n  ///   deduced arguments.\n  ///\n  ///   TDK_NonDeducedMismatch: this is the component of the 'parameter'\n  ///   of the deduction, directly provided in the source code.\n  TemplateArgument FirstArg;\n\n  /// The second template argument to which the template\n  /// argument deduction failure refers.\n  ///\n  ///   TDK_Inconsistent: this argument is the second value deduced\n  ///   for the corresponding template parameter.\n  ///\n  ///   TDK_DeducedMismatch: this is the (adjusted) call argument type.\n  ///\n  ///   TDK_NonDeducedMismatch: this is the mismatching component of the\n  ///   'argument' of the deduction, from which we are deducing arguments.\n  ///\n  /// FIXME: Finish documenting this.\n  TemplateArgument SecondArg;\n\n  /// The index of the function argument that caused a deduction\n  /// failure.\n  ///\n  ///   TDK_DeducedMismatch: this is the index of the argument that had a\n  ///   different argument type from its substituted parameter type.\n  unsigned CallArgIndex = 0;\n\n  // C++20 [over.match.class.deduct]p5.2:\n  //   During template argument deduction for the aggregate deduction\n  //   candidate, the number of elements in a trailing parameter pack is only\n  //   deduced from the number of remaining function arguments if it is not\n  //   otherwise deduced.\n  bool AggregateDeductionCandidateHasMismatchedArity = false;\n\n  /// Information on packs that we're currently expanding.\n  ///\n  /// FIXME: This should be kept internal to SemaTemplateDeduction.\n  SmallVector<DeducedPack *, 8> PendingDeducedPacks;\n\n  /// \\brief The constraint satisfaction details resulting from the associated\n  /// constraints satisfaction tests.\n  ConstraintSatisfaction AssociatedConstraintsSatisfaction;\n};\n\n}",
  "id": "BLOCK-CPP-20725",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/TemplateDeduction.h",
  "source_line": 37,
  "validation_status": "validated"
}