{
  "code": "{\nprotected:\n  // The correctness of this relies on the property that, for Type *Ty,\n  //   QualType(Ty, 0).getAsOpaquePtr() == (void*) Ty\n  const void *Ty = nullptr;\n  void *Data = nullptr;\n\npublic:\n  TypeLoc() = default;\n  TypeLoc(QualType ty, void *opaqueData)\n      : Ty(ty.getAsOpaquePtr()), Data(opaqueData) {}\n  TypeLoc(const Type *ty, void *opaqueData)\n      : Ty(ty), Data(opaqueData) {}\n\n  /// Convert to the specified TypeLoc type, asserting that this TypeLoc\n  /// is of the desired type.\n  ///\n  /// \\pre T::isKind(*this)\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type.\n  template<typename T>\n  T getAs() const {\n    if (!T::isKind(*this))\n      return {};\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type. It will consider type\n  /// adjustments from a type that was written as a T to another type that is\n  /// still canonically a T (ignores parens, attributes, elaborated types, etc).\n  template <typename T>\n  T getAsAdjusted() const;\n\n  /// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,\n  /// except it also defines a Qualified enum that corresponds to the\n  /// QualifiedLoc class.\n  enum TypeLocClass {\n#define ABSTRACT_TYPE(Class, Base)\n#define TYPE(Class, Base) \\\n    Class = Type::Class,\n#include \"clang/AST/TypeNodes.inc\"\n    Qualified\n  };\n\n  TypeLocClass getTypeLocClass() const {\n    if (getType().hasLocalQualifiers()) return Qualified;\n    return (TypeLocClass) getType()->getTypeClass();\n  }\n\n  bool isNull() const { return !Ty; }\n  explicit operator bool() const { return Ty; }\n\n  /// Returns the size of type source info data block for the given type.\n  static unsigned getFullDataSizeForType(QualType Ty);\n\n  /// Returns the alignment of type source info data block for\n  /// the given type.\n  static unsigned getLocalAlignmentForType(QualType Ty);\n\n  /// Get the type for which this source info wrapper provides\n  /// information.\n  QualType getType() const {\n    return QualType::getFromOpaquePtr(Ty);\n  }\n\n  const Type *getTypePtr() const {\n    return QualType::getFromOpaquePtr(Ty).getTypePtr();\n  }\n\n  /// Get the pointer where source information is stored.\n  void *getOpaqueData() const {\n    return Data;\n  }\n\n  /// Get the begin source location.\n  SourceLocation getBeginLoc() const;\n\n  /// Get the end source location.\n  SourceLocation getEndLoc() const;\n\n  /// Get the full source range.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n\n  /// Get the local source range.\n  SourceRange getLocalSourceRange() const {\n    return getLocalSourceRangeImpl(*this);\n  }\n\n  /// Returns the size of the type source info data block.\n  unsigned getFullDataSize() const {\n    return getFullDataSizeForType(getType());\n  }\n\n  /// Get the next TypeLoc pointed by this TypeLoc, e.g for \"int*\" the\n  /// TypeLoc is a PointerLoc and next TypeLoc is for \"int\".\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLocImpl(*this);\n  }\n\n  /// Skips past any qualifiers, if this is qualified.\n  UnqualTypeLoc getUnqualifiedLoc() const; // implemented in this header\n\n  TypeLoc IgnoreParens() const;\n\n  /// Find a type with the location of an explicit type qualifier.\n  ///\n  /// The result, if non-null, will be one of:\n  ///   QualifiedTypeLoc\n  ///   AtomicTypeLoc\n  ///   AttributedTypeLoc, for those type attributes that behave as qualifiers\n  TypeLoc findExplicitQualifierLoc() const;\n\n  /// Get the typeloc of an AutoType whose type will be deduced for a variable\n  /// with an initializer of this type. This looks through declarators like\n  /// pointer types, but not through decltype or typedefs.\n  AutoTypeLoc getContainedAutoTypeLoc() const;\n\n  /// Initializes this to state that every location in this\n  /// type is the given location.\n  ///\n  /// This method exists to provide a simple transition for code that\n  /// relies on location-less types.\n  void initialize(ASTContext &Context, SourceLocation Loc) const {\n    initializeImpl(Context, *this, Loc);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.\n  void initializeFullCopy(TypeLoc Other) {\n    assert(getType() == Other.getType());\n    copy(Other);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.  The given size must be the full data\n  /// size.\n  void initializeFullCopy(TypeLoc Other, unsigned Size) {\n    assert(getType() == Other.getType());\n    assert(getFullDataSize() == Size);\n    copy(Other);\n  }\n\n  /// Copies the other type loc into this one.\n  void copy(TypeLoc other);\n\n  friend bool operator==(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return LHS.Ty == RHS.Ty && LHS.Data == RHS.Data;\n  }\n\n  friend bool operator!=(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Find the location of the nullability specifier (__nonnull,\n  /// __nullable, or __null_unspecifier), if there is one.\n  SourceLocation findNullabilityLoc() const;\n\nprivate:\n  static bool isKind(const TypeLoc&) {\n    return true;\n  }\n\n  static void initializeImpl(ASTContext &Context, TypeLoc TL,\n                             SourceLocation Loc);\n  static TypeLoc getNextTypeLocImpl(TypeLoc TL);\n  static TypeLoc IgnoreParensImpl(TypeLoc TL);\n  static SourceRange getLocalSourceRangeImpl(TypeLoc TL);\n}",
  "id": "BLOCK-CPP-14533",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TypeLoc.h",
  "source_line": 58,
  "validation_status": "validated"
}