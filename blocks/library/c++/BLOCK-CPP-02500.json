{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace debugging_internal {\n\n// NOTE: be extra careful about adding any interposable function calls here\n// (such as open(), read(), etc.). These symbols may be interposed and will get\n// invoked in contexts they don't expect.\n//\n// NOTE: any new system calls here may also require sandbox reconfiguration.\n//\nbool AddressIsReadable(const void *addr) {\n  // rt_sigprocmask below checks 8 contiguous bytes. If addr resides in the\n  // last 7 bytes of a page (unaligned), rt_sigprocmask would additionally\n  // check the readability of the next page, which is not desired. Align\n  // address on 8-byte boundary to check only the current page.\n  const uintptr_t u_addr = reinterpret_cast<uintptr_t>(addr) & ~uintptr_t{7};\n  addr = reinterpret_cast<const void *>(u_addr);\n\n  // rt_sigprocmask below will succeed for this input.\n  if (addr == nullptr) return false;\n\n  absl::base_internal::ErrnoSaver errno_saver;\n\n  // Here we probe with some syscall which\n  // - accepts an 8-byte region of user memory as input\n  // - tests for EFAULT before other validation\n  // - has no problematic side-effects\n  //\n  // rt_sigprocmask(2) works for this.  It copies sizeof(kernel_sigset_t)==8\n  // bytes from the address into the kernel memory before any validation.\n  //\n  // The call can never succeed, since the `how` parameter is not one of\n  // SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK.\n  //\n  // This strategy depends on Linux implementation details,\n  // so we rely on the test to alert us if it stops working.\n  //\n  // Some discarded past approaches:\n  // - msync() doesn't reject PROT_NONE regions\n  // - write() on /dev/null doesn't return EFAULT\n  // - write() on a pipe requires creating it and draining the writes\n  // - connect() works but is problematic for sandboxes and needs a valid\n  //   file descriptor\n  //\n  // This can never succeed (invalid first argument to sigprocmask).\n  ABSL_RAW_CHECK(syscall(SYS_rt_sigprocmask, ~0, addr, nullptr,\n                         /*sizeof(kernel_sigset_t)*/ 8) == -1,\n                 \"unexpected success\");\n  ABSL_RAW_CHECK(errno == EFAULT || errno == EINVAL, \"unexpected errno\");\n  return errno != EFAULT;\n}\n\n}  // namespace debugging_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02500",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/address_is_readable.cc",
  "source_line": 42,
  "validation_status": "validated"
}