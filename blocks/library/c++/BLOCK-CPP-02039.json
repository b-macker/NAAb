{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace {\n\n// This GenericFind() template function encapsulates the finding algorithm\n// shared between the ByString and ByAnyChar delimiters. The FindPolicy\n// template parameter allows each delimiter to customize the actual find\n// function to use and the length of the found delimiter. For example, the\n// Literal delimiter will ultimately use absl::string_view::find(), and the\n// AnyOf delimiter will use absl::string_view::find_first_of().\ntemplate <typename FindPolicy>\nabsl::string_view GenericFind(absl::string_view text,\n                              absl::string_view delimiter, size_t pos,\n                              FindPolicy find_policy) {\n  if (delimiter.empty() && text.length() > 0) {\n    // Special case for empty string delimiters: always return a zero-length\n    // absl::string_view referring to the item at position 1 past pos.\n    return absl::string_view(text.data() + pos + 1, 0);\n  }\n  size_t found_pos = absl::string_view::npos;\n  absl::string_view found(text.data() + text.size(),\n                          0);  // By default, not found\n  found_pos = find_policy.Find(text, delimiter, pos);\n  if (found_pos != absl::string_view::npos) {\n    found = absl::string_view(text.data() + found_pos,\n                              find_policy.Length(delimiter));\n  }\n  return found;\n}\n\n// Finds using absl::string_view::find(), therefore the length of the found\n// delimiter is delimiter.length().\nstruct LiteralPolicy {\n  static size_t Find(absl::string_view text, absl::string_view delimiter,\n                     size_t pos) {\n    return text.find(delimiter, pos);\n  }\n  static size_t Length(absl::string_view delimiter) {\n    return delimiter.length();\n  }\n};\n\n// Finds using absl::string_view::find_first_of(), therefore the length of the\n// found delimiter is 1.\nstruct AnyOfPolicy {\n  static size_t Find(absl::string_view text, absl::string_view delimiter,\n                     size_t pos) {\n    return text.find_first_of(delimiter, pos);\n  }\n  static size_t Length(absl::string_view /* delimiter */) { return 1; }\n};\n\n}  // namespace\n\n//\n// ByString\n//\n\nByString::ByString(absl::string_view sp) : delimiter_(sp) {}\n\nabsl::string_view ByString::Find(absl::string_view text, size_t pos) const {\n  if (delimiter_.length() == 1) {\n    // Much faster to call find on a single character than on an\n    // absl::string_view.\n    size_t found_pos = text.find(delimiter_[0], pos);\n    if (found_pos == absl::string_view::npos)\n      return absl::string_view(text.data() + text.size(), 0);\n    return text.substr(found_pos, 1);\n  }\n  return GenericFind(text, delimiter_, pos, LiteralPolicy());\n}\n\nabsl::string_view ByAsciiWhitespace::Find(absl::string_view text,\n                                          size_t pos) const {\n  return GenericFind(text, \" \\t\\v\\f\\r\\n\", pos, AnyOfPolicy());\n}\n\n//\n// ByChar\n//\n\nabsl::string_view ByChar::Find(absl::string_view text, size_t pos) const {\n  size_t found_pos = text.find(c_, pos);\n  if (found_pos == absl::string_view::npos)\n    return absl::string_view(text.data() + text.size(), 0);\n  return text.substr(found_pos, 1);\n}\n\n//\n// ByAnyChar\n//\n\nByAnyChar::ByAnyChar(absl::string_view sp) : delimiters_(sp) {}\n\nabsl::string_view ByAnyChar::Find(absl::string_view text, size_t pos) const {\n  return GenericFind(text, delimiters_, pos, AnyOfPolicy());\n}\n\n//\n// ByLength\n//\nByLength::ByLength(ptrdiff_t length) : length_(length) {\n  ABSL_RAW_CHECK(length > 0, \"\");\n}\n\nabsl::string_view ByLength::Find(absl::string_view text, size_t pos) const {\n  pos = std::min(pos, text.size());  // truncate `pos`\n  absl::string_view substr = text.substr(pos);\n  // If the string is shorter than the chunk size we say we\n  // \"can't find the delimiter\" so this will be the last chunk.\n  if (substr.length() <= static_cast<size_t>(length_))\n    return absl::string_view(text.data() + text.size(), 0);\n\n  return absl::string_view(substr.data() + length_, 0);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02039",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_split.cc",
  "source_line": 26,
  "validation_status": "validated"
}