{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace time_internal {\nnamespace cctz {\n\nnamespace {\n\nconst char kDigits[] = \"0123456789\";\n\nconst char* ParseInt(const char* p, int min, int max, int* vp) {\n  int value = 0;\n  const char* op = p;\n  const int kMaxInt = std::numeric_limits<int>::max();\n  for (; const char* dp = strchr(kDigits, *p); ++p) {\n    int d = static_cast<int>(dp - kDigits);\n    if (d >= 10) break;  // '\\0'\n    if (value > kMaxInt / 10) return nullptr;\n    value *= 10;\n    if (value > kMaxInt - d) return nullptr;\n    value += d;\n  }\n  if (p == op || value < min || value > max) return nullptr;\n  *vp = value;\n  return p;\n}\n\n// abbr = <.*?> | [^-+,\\d]{3,}\nconst char* ParseAbbr(const char* p, std::string* abbr) {\n  const char* op = p;\n  if (*p == '<') {  // special zoneinfo <...> form\n    while (*++p != '>') {\n      if (*p == '\\0') return nullptr;\n    }\n    abbr->assign(op + 1, static_cast<std::size_t>(p - op) - 1);\n    return ++p;\n  }\n  while (*p != '\\0') {\n    if (strchr(\"-+,\", *p)) break;\n    if (strchr(kDigits, *p)) break;\n    ++p;\n  }\n  if (p - op < 3) return nullptr;\n  abbr->assign(op, static_cast<std::size_t>(p - op));\n  return p;\n}\n\n// offset = [+|-]hh[:mm[:ss]] (aggregated into single seconds value)\nconst char* ParseOffset(const char* p, int min_hour, int max_hour, int sign,\n                        std::int_fast32_t* offset) {\n  if (p == nullptr) return nullptr;\n  if (*p == '+' || *p == '-') {\n    if (*p++ == '-') sign = -sign;\n  }\n  int hours = 0;\n  int minutes = 0;\n  int seconds = 0;\n\n  p = ParseInt(p, min_hour, max_hour, &hours);\n  if (p == nullptr) return nullptr;\n  if (*p == ':') {\n    p = ParseInt(p + 1, 0, 59, &minutes);\n    if (p == nullptr) return nullptr;\n    if (*p == ':') {\n      p = ParseInt(p + 1, 0, 59, &seconds);\n      if (p == nullptr) return nullptr;\n    }\n  }\n  *offset = sign * ((((hours * 60) + minutes) * 60) + seconds);\n  return p;\n}\n\n// datetime = ( Jn | n | Mm.w.d ) [ / offset ]\nconst char* ParseDateTime(const char* p, PosixTransition* res) {\n  if (p != nullptr && *p == ',') {\n    if (*++p == 'M') {\n      int month = 0;\n      if ((p = ParseInt(p + 1, 1, 12, &month)) != nullptr && *p == '.') {\n        int week = 0;\n        if ((p = ParseInt(p + 1, 1, 5, &week)) != nullptr && *p == '.') {\n          int weekday = 0;\n          if ((p = ParseInt(p + 1, 0, 6, &weekday)) != nullptr) {\n            res->date.fmt = PosixTransition::M;\n            res->date.m.month = static_cast<std::int_fast8_t>(month);\n            res->date.m.week = static_cast<std::int_fast8_t>(week);\n            res->date.m.weekday = static_cast<std::int_fast8_t>(weekday);\n          }\n        }\n      }\n    } else if (*p == 'J') {\n      int day = 0;\n      if ((p = ParseInt(p + 1, 1, 365, &day)) != nullptr) {\n        res->date.fmt = PosixTransition::J;\n        res->date.j.day = static_cast<std::int_fast16_t>(day);\n      }\n    } else {\n      int day = 0;\n      if ((p = ParseInt(p, 0, 365, &day)) != nullptr) {\n        res->date.fmt = PosixTransition::N;\n        res->date.n.day = static_cast<std::int_fast16_t>(day);\n      }\n    }\n  }\n  if (p != nullptr) {\n    res->time.offset = 2 * 60 * 60;  // default offset is 02:00:00\n    if (*p == '/') p = ParseOffset(p + 1, -167, 167, 1, &res->time.offset);\n  }\n  return p;\n}\n\n}  // namespace\n\n// spec = std offset [ dst [ offset ] , datetime , datetime ]\nbool ParsePosixSpec(const std::string& spec, PosixTimeZone* res) {\n  const char* p = spec.c_str();\n  if (*p == ':') return false;\n\n  p = ParseAbbr(p, &res->std_abbr);\n  p = ParseOffset(p, 0, 24, -1, &res->std_offset);\n  if (p == nullptr) return false;\n  if (*p == '\\0') return true;\n\n  p = ParseAbbr(p, &res->dst_abbr);\n  if (p == nullptr) return false;\n  res->dst_offset = res->std_offset + (60 * 60);  // default\n  if (*p != ',') p = ParseOffset(p, 0, 24, -1, &res->dst_offset);\n\n  p = ParseDateTime(p, &res->dst_start);\n  p = ParseDateTime(p, &res->dst_end);\n\n  return p != nullptr && *p == '\\0';\n}\n\n}  // namespace cctz\n}  // namespace time_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03263",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_posix.cc",
  "source_line": 24,
  "validation_status": "validated"
}