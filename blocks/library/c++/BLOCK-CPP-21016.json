{
  "code": "#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <memory>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21016_execute() {\n    {\n\n/// In-memory cache for modules.\n///\n/// This is a cache for modules for use across a compilation, sharing state\n/// between the CompilerInstances in an implicit modules build.  It must be\n/// shared by each CompilerInstance, ASTReader, ASTWriter, and ModuleManager\n/// that are coordinating.\n///\n/// Critically, it ensures that a single process has a consistent view of each\n/// PCM.  This is used by \\a CompilerInstance when building PCMs to ensure that\n/// each \\a ModuleManager sees the same files.\nclass InMemoryModuleCache : public llvm::RefCountedBase<InMemoryModuleCache> {\n  struct PCM {\n    std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\n    /// Track whether this PCM is known to be good (either built or\n    /// successfully imported by a CompilerInstance/ASTReader using this\n    /// cache).\n    bool IsFinal = false;\n\n    PCM() = default;\n    PCM(std::unique_ptr<llvm::MemoryBuffer> Buffer)\n        : Buffer(std::move(Buffer)) {}\n  };\n\n  /// Cache of buffers.\n  llvm::StringMap<PCM> PCMs;\n\npublic:\n  /// There are four states for a PCM.  It must monotonically increase.\n  ///\n  ///  1. Unknown: the PCM has neither been read from disk nor built.\n  ///  2. Tentative: the PCM has been read from disk but not yet imported or\n  ///     built.  It might work.\n  ///  3. ToBuild: the PCM read from disk did not work but a new one has not\n  ///     been built yet.\n  ///  4. Final: indicating that the current PCM was either built in this\n  ///     process or has been successfully imported.\n  enum State { Unknown, Tentative, ToBuild, Final };\n\n  /// Get the state of the PCM.\n  State getPCMState(llvm::StringRef Filename) const;\n\n  /// Store the PCM under the Filename.\n  ///\n  /// \\pre state is Unknown\n  /// \\post state is Tentative\n  /// \\return a reference to the buffer as a convenience.\n  llvm::MemoryBuffer &addPCM(llvm::StringRef Filename,\n                             std::unique_ptr<llvm::MemoryBuffer> Buffer);\n\n  /// Store a just-built PCM under the Filename.\n  ///\n  /// \\pre state is Unknown or ToBuild.\n  /// \\pre state is not Tentative.\n  /// \\return a reference to the buffer as a convenience.\n  llvm::MemoryBuffer &addBuiltPCM(llvm::StringRef Filename,\n                                  std::unique_ptr<llvm::MemoryBuffer> Buffer);\n\n  /// Try to remove a buffer from the cache.  No effect if state is Final.\n  ///\n  /// \\pre state is Tentative/Final.\n  /// \\post Tentative => ToBuild or Final => Final.\n  /// \\return false on success, i.e. if Tentative => ToBuild.\n  bool tryToDropPCM(llvm::StringRef Filename);\n\n  /// Mark a PCM as final.\n  ///\n  /// \\pre state is Tentative or Final.\n  /// \\post state is Final.\n  void finalizePCM(llvm::StringRef Filename);\n\n  /// Get a pointer to the pCM if it exists; else nullptr.\n  llvm::MemoryBuffer *lookupPCM(llvm::StringRef Filename) const;\n\n  /// Check whether the PCM is final and has been shown to work.\n  ///\n  /// \\return true iff state is Final.\n  bool isPCMFinal(llvm::StringRef Filename) const;\n\n  /// Check whether the PCM is waiting to be built.\n  ///\n  /// \\return true iff state is ToBuild.\n  bool shouldBuildPCM(llvm::StringRef Filename) const;\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21016",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/InMemoryModuleCache.h",
  "source_line": 17,
  "validation_status": "validated"
}