{
  "code": "{\nprivate:\n  UnqualifiedId(const UnqualifiedId &Other) = delete;\n  const UnqualifiedId &operator=(const UnqualifiedId &) = delete;\n\n  /// Describes the kind of unqualified-id parsed.\n  UnqualifiedIdKind Kind;\n\npublic:\n  struct OFI {\n    /// The kind of overloaded operator.\n    OverloadedOperatorKind Operator;\n\n    /// The source locations of the individual tokens that name\n    /// the operator, e.g., the \"new\", \"[\", and \"]\" tokens in\n    /// operator new [].\n    ///\n    /// Different operators have different numbers of tokens in their name,\n    /// up to three. Any remaining source locations in this array will be\n    /// set to an invalid value for operators with fewer than three tokens.\n    SourceLocation SymbolLocations[3];\n  };\n\n  /// Anonymous union that holds extra data associated with the\n  /// parsed unqualified-id.\n  union {\n    /// When Kind == IK_Identifier, the parsed identifier, or when\n    /// Kind == IK_UserLiteralId, the identifier suffix.\n    IdentifierInfo *Identifier;\n\n    /// When Kind == IK_OperatorFunctionId, the overloaded operator\n    /// that we parsed.\n    struct OFI OperatorFunctionId;\n\n    /// When Kind == IK_ConversionFunctionId, the type that the\n    /// conversion function names.\n    UnionParsedType ConversionFunctionId;\n\n    /// When Kind == IK_ConstructorName, the class-name of the type\n    /// whose constructor is being referenced.\n    UnionParsedType ConstructorName;\n\n    /// When Kind == IK_DestructorName, the type referred to by the\n    /// class-name.\n    UnionParsedType DestructorName;\n\n    /// When Kind == IK_DeductionGuideName, the parsed template-name.\n    UnionParsedTemplateTy TemplateName;\n\n    /// When Kind == IK_TemplateId or IK_ConstructorTemplateId,\n    /// the template-id annotation that contains the template name and\n    /// template arguments.\n    TemplateIdAnnotation *TemplateId;\n  };\n\n  /// The location of the first token that describes this unqualified-id,\n  /// which will be the location of the identifier, \"operator\" keyword,\n  /// tilde (for a destructor), or the template name of a template-id.\n  SourceLocation StartLocation;\n\n  /// The location of the last token that describes this unqualified-id.\n  SourceLocation EndLocation;\n\n  UnqualifiedId()\n      : Kind(UnqualifiedIdKind::IK_Identifier), Identifier(nullptr) {}\n\n  /// Clear out this unqualified-id, setting it to default (invalid)\n  /// state.\n  void clear() {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = nullptr;\n    StartLocation = SourceLocation();\n    EndLocation = SourceLocation();\n  }\n\n  /// Determine whether this unqualified-id refers to a valid name.\n  bool isValid() const { return StartLocation.isValid(); }\n\n  /// Determine whether this unqualified-id refers to an invalid name.\n  bool isInvalid() const { return !isValid(); }\n\n  /// Determine what kind of name we have.\n  UnqualifiedIdKind getKind() const { return Kind; }\n\n  /// Specify that this unqualified-id was parsed as an identifier.\n  ///\n  /// \\param Id the parsed identifier.\n  /// \\param IdLoc the location of the parsed identifier.\n  void setIdentifier(const IdentifierInfo *Id, SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as an\n  /// operator-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Op the overloaded operator.\n  ///\n  /// \\param SymbolLocations the locations of the individual operator symbols\n  /// in the operator.\n  void setOperatorFunctionId(SourceLocation OperatorLoc,\n                             OverloadedOperatorKind Op,\n                             SourceLocation SymbolLocations[3]);\n\n  /// Specify that this unqualified-id was parsed as a\n  /// conversion-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Ty the type to which this conversion function is converting.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConversionFunctionId(SourceLocation OperatorLoc,\n                               ParsedType Ty,\n                               SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConversionFunctionId;\n    StartLocation = OperatorLoc;\n    EndLocation = EndLoc;\n    ConversionFunctionId = Ty;\n  }\n\n  /// Specific that this unqualified-id was parsed as a\n  /// literal-operator-id.\n  ///\n  /// \\param Id the parsed identifier.\n  ///\n  /// \\param OpLoc the location of the 'operator' keyword.\n  ///\n  /// \\param IdLoc the location of the identifier.\n  void setLiteralOperatorId(const IdentifierInfo *Id, SourceLocation OpLoc,\n                              SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_LiteralOperatorId;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = OpLoc;\n    EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as a constructor name.\n  ///\n  /// \\param ClassType the class type referred to by the constructor name.\n  ///\n  /// \\param ClassNameLoc the location of the class name.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConstructorName(ParsedType ClassType,\n                          SourceLocation ClassNameLoc,\n                          SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConstructorName;\n    StartLocation = ClassNameLoc;\n    EndLocation = EndLoc;\n    ConstructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a\n  /// template-id that names a constructor.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setConstructorTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a destructor name.\n  ///\n  /// \\param TildeLoc the location of the '~' that introduces the destructor\n  /// name.\n  ///\n  /// \\param ClassType the name of the class referred to by the destructor name.\n  void setDestructorName(SourceLocation TildeLoc,\n                         ParsedType ClassType,\n                         SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_DestructorName;\n    StartLocation = TildeLoc;\n    EndLocation = EndLoc;\n    DestructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a template-id.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a template-name for\n  /// a deduction-guide.\n  ///\n  /// \\param Template The parsed template-name.\n  /// \\param TemplateLoc The location of the parsed template-name.\n  void setDeductionGuideName(ParsedTemplateTy Template,\n                             SourceLocation TemplateLoc) {\n    Kind = UnqualifiedIdKind::IK_DeductionGuideName;\n    TemplateName = Template;\n    StartLocation = EndLocation = TemplateLoc;\n  }\n\n  /// Specify that this unqualified-id is an implicit 'self'\n  /// parameter.\n  ///\n  /// \\param Id the identifier.\n  void setImplicitSelfParam(const IdentifierInfo *Id) {\n    Kind = UnqualifiedIdKind::IK_ImplicitSelfParam;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = SourceLocation();\n  }\n\n  /// Return the source range that covers this unqualified-id.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(StartLocation, EndLocation);\n  }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLocation; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return EndLocation; }\n}",
  "id": "BLOCK-CPP-19710",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DeclSpec.h",
  "source_line": 989,
  "validation_status": "validated"
}