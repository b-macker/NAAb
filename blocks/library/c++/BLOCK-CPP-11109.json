{
  "code": "{\n/// OpenMP 5.0 [2.1.5, Array Sections].\n/// To specify an array section in an OpenMP construct, array subscript\n/// expressions are extended with the following syntax:\n/// \\code\n/// [ lower-bound : length : stride ]\n/// [ lower-bound : length : ]\n/// [ lower-bound : length ]\n/// [ lower-bound : : stride ]\n/// [ lower-bound : : ]\n/// [ lower-bound : ]\n/// [ : length : stride ]\n/// [ : length : ]\n/// [ : length ]\n/// [ : : stride ]\n/// [ : : ]\n/// [ : ]\n/// \\endcode\n/// The array section must be a subset of the original array.\n/// Array sections are allowed on multidimensional arrays. Base language array\n/// subscript expressions can be used to specify length-one dimensions of\n/// multidimensional array sections.\n/// Each of the lower-bound, length, and stride expressions if specified must be\n/// an integral type expressions of the base language. When evaluated\n/// they represent a set of integer values as follows:\n/// \\code\n/// { lower-bound, lower-bound + stride, lower-bound + 2 * stride,... ,\n/// lower-bound + ((length - 1) * stride) }\n/// \\endcode\n/// The lower-bound and length must evaluate to non-negative integers.\n/// The stride must evaluate to a positive integer.\n/// When the size of the array dimension is not known, the length must be\n/// specified explicitly.\n/// When the stride is absent it defaults to 1.\n/// When the length is absent it defaults to ⌈(size − lower-bound)/stride⌉,\n/// where size is the size of the array dimension. When the lower-bound is\n/// absent it defaults to 0.\nclass OMPArraySectionExpr : public Expr {\n  enum { BASE, LOWER_BOUND, LENGTH, STRIDE, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n  SourceLocation ColonLocFirst;\n  SourceLocation ColonLocSecond;\n  SourceLocation RBracketLoc;\n\npublic:\n  OMPArraySectionExpr(Expr *Base, Expr *LowerBound, Expr *Length, Expr *Stride,\n                      QualType Type, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation ColonLocFirst,\n                      SourceLocation ColonLocSecond, SourceLocation RBracketLoc)\n      : Expr(OMPArraySectionExprClass, Type, VK, OK),\n        ColonLocFirst(ColonLocFirst), ColonLocSecond(ColonLocSecond),\n        RBracketLoc(RBracketLoc) {\n    SubExprs[BASE] = Base;\n    SubExprs[LOWER_BOUND] = LowerBound;\n    SubExprs[LENGTH] = Length;\n    SubExprs[STRIDE] = Stride;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array section expression.\n  explicit OMPArraySectionExpr(EmptyShell Shell)\n      : Expr(OMPArraySectionExprClass, Shell) {}\n\n  /// An array section can be written only as Base[LowerBound:Length].\n\n  /// Get base of the array section.\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  /// Set base of the array section.\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  /// Return original type of the base expression for array section.\n  static QualType getBaseOriginalType(const Expr *Base);\n\n  /// Get lower bound of array section.\n  Expr *getLowerBound() { return cast_or_null<Expr>(SubExprs[LOWER_BOUND]); }\n  const Expr *getLowerBound() const {\n    return cast_or_null<Expr>(SubExprs[LOWER_BOUND]);\n  }\n  /// Set lower bound of the array section.\n  void setLowerBound(Expr *E) { SubExprs[LOWER_BOUND] = E; }\n\n  /// Get length of array section.\n  Expr *getLength() { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  const Expr *getLength() const { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  /// Set length of the array section.\n  void setLength(Expr *E) { SubExprs[LENGTH] = E; }\n\n  /// Get stride of array section.\n  Expr *getStride() { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  const Expr *getStride() const { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  /// Set length of the array section.\n  void setStride(Expr *E) { SubExprs[STRIDE] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracketLoc; }\n\n  SourceLocation getColonLocFirst() const { return ColonLocFirst; }\n  void setColonLocFirst(SourceLocation L) { ColonLocFirst = L; }\n\n  SourceLocation getColonLocSecond() const { return ColonLocSecond; }\n  void setColonLocSecond(SourceLocation L) { ColonLocSecond = L; }\n\n  SourceLocation getRBracketLoc() const { return RBracketLoc; }\n  void setRBracketLoc(SourceLocation L) { RBracketLoc = L; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPArraySectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n};\n\n/// An explicit cast in C or a C-style cast in C++, which uses the syntax\n/// ([s1][s2]...[sn])expr. For example: @c ([3][3])f.\nclass OMPArrayShapingExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OMPArrayShapingExpr, Expr *, SourceRange> {\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  /// Base node.\n  SourceLocation LPLoc; /// The location of the left paren\n  SourceLocation RPLoc; /// The location of the right paren\n  unsigned NumDims = 0; /// Number of dimensions in the shaping expression.\n\n  /// Construct full expression.\n  OMPArrayShapingExpr(QualType ExprTy, Expr *Op, SourceLocation L,\n                      SourceLocation R, ArrayRef<Expr *> Dims);\n\n  /// Construct an empty expression.\n  explicit OMPArrayShapingExpr(EmptyShell Shell, unsigned NumDims)\n      : Expr(OMPArrayShapingExprClass, Shell), NumDims(NumDims) {}\n\n  /// Sets the dimensions for the array shaping.\n  void setDimensions(ArrayRef<Expr *> Dims);\n\n  /// Sets the base expression for array shaping operation.\n  void setBase(Expr *Op) { getTrailingObjects<Expr *>()[NumDims] = Op; }\n\n  /// Sets source ranges for the brackets in the array shaping operation.\n  void setBracketsRanges(ArrayRef<SourceRange> BR);\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    // Add an extra one for the base expression.\n    return NumDims + 1;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceRange>) const {\n    return NumDims;\n  }\n\npublic:\n  static OMPArrayShapingExpr *Create(const ASTContext &Context, QualType T,\n                                     Expr *Op, SourceLocation L,\n                                     SourceLocation R, ArrayRef<Expr *> Dims,\n                                     ArrayRef<SourceRange> BracketRanges);\n\n  static OMPArrayShapingExpr *CreateEmpty(const ASTContext &Context,\n                                          unsigned NumDims);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBase()->getEndLoc();\n  }\n\n  /// Fetches the dimensions for array shaping expression.\n  ArrayRef<Expr *> getDimensions() const {\n    return llvm::ArrayRef(getTrailingObjects<Expr *>(), NumDims);\n  }\n\n  /// Fetches source ranges for the brackets os the array shaping expression.\n  ArrayRef<SourceRange> getBracketsRanges() const {\n    return llvm::ArrayRef(getTrailingObjects<SourceRange>(), NumDims);\n  }\n\n  /// Fetches base expression of array shaping expression.\n  Expr *getBase() { return getTrailingObjects<Expr *>()[NumDims]; }\n  const Expr *getBase() const { return getTrailingObjects<Expr *>()[NumDims]; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPArrayShapingExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumDims + 1);\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumDims + 1);\n  }\n};\n\n/// Helper expressions and declaration for OMPIteratorExpr class for each\n/// iteration space.\nstruct OMPIteratorHelperData {\n  /// Internal normalized counter.\n  VarDecl *CounterVD = nullptr;\n  /// Normalized upper bound. Normalized loop iterates from 0 to Upper with\n  /// step 1.\n  Expr *Upper = nullptr;\n  /// Update expression for the originally specified iteration variable,\n  /// calculated as VD = Begin + CounterVD * Step;\n  Expr *Update = nullptr;\n  /// Updater for the internal counter: ++CounterVD;\n  Expr *CounterUpdate = nullptr;\n};\n\n/// OpenMP 5.0 [2.1.6 Iterators]\n/// Iterators are identifiers that expand to multiple values in the clause on\n/// which they appear.\n/// The syntax of the iterator modifier is as follows:\n/// \\code\n/// iterator(iterators-definition)\n/// \\endcode\n/// where iterators-definition is one of the following:\n/// \\code\n/// iterator-specifier [, iterators-definition ]\n/// \\endcode\n/// where iterator-specifier is one of the following:\n/// \\code\n/// [ iterator-type ] identifier = range-specification\n/// \\endcode\n/// where identifier is a base language identifier.\n/// iterator-type is a type name.\n/// range-specification is of the form begin:end[:step], where begin and end are\n/// expressions for which their types can be converted to iterator-type and step\n/// is an integral expression.\n/// In an iterator-specifier, if the iterator-type is not specified then the\n/// type of that iterator is of int type.\n/// The iterator-type must be an integral or pointer type.\n/// The iterator-type must not be const qualified.\nclass OMPIteratorExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OMPIteratorExpr, Decl *, Expr *,\n                                    SourceLocation, OMPIteratorHelperData> {\npublic:\n  /// Iterator range representation begin:end[:step].\n  struct IteratorRange {\n    Expr *Begin = nullptr;\n    Expr *End = nullptr;\n    Expr *Step = nullptr;\n  };\n  /// Iterator definition representation.\n  struct IteratorDefinition {\n    Decl *IteratorDecl = nullptr;\n    IteratorRange Range;\n    SourceLocation AssignmentLoc;\n    SourceLocation ColonLoc, SecondColonLoc;\n  };\n\nprivate:\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Offset in the list of expressions for subelements of the ranges.\n  enum class RangeExprOffset {\n    Begin = 0,\n    End = 1,\n    Step = 2,\n    Total = 3,\n  };\n  /// Offset in the list of locations for subelements of colon symbols\n  /// locations.\n  enum class RangeLocOffset {\n    AssignLoc = 0,\n    FirstColonLoc = 1,\n    SecondColonLoc = 2,\n    Total = 3,\n  };\n  /// Location of 'iterator' keyword.\n  SourceLocation IteratorKwLoc;\n  /// Location of '('.\n  SourceLocation LPLoc;\n  /// Location of ')'.\n  SourceLocation RPLoc;\n  /// Number of iterator definitions.\n  unsigned NumIterators = 0;\n\n  OMPIteratorExpr(QualType ExprTy, SourceLocation IteratorKwLoc,\n                  SourceLocation L, SourceLocation R,\n                  ArrayRef<IteratorDefinition> Data,\n                  ArrayRef<OMPIteratorHelperData> Helpers);\n\n  /// Construct an empty expression.\n  explicit OMPIteratorExpr(EmptyShell Shell, unsigned NumIterators)\n      : Expr(OMPIteratorExprClass, Shell), NumIterators(NumIterators) {}\n\n  /// Sets basic declaration for the specified iterator definition.\n  void setIteratorDeclaration(unsigned I, Decl *D);\n\n  /// Sets the location of the assignment symbol for the specified iterator\n  /// definition.\n  void setAssignmentLoc(unsigned I, SourceLocation Loc);\n\n  /// Sets begin, end and optional step expressions for specified iterator\n  /// definition.\n  void setIteratorRange(unsigned I, Expr *Begin, SourceLocation ColonLoc,\n                        Expr *End, SourceLocation SecondColonLoc, Expr *Step);\n\n  /// Sets helpers for the specified iteration space.\n  void setHelper(unsigned I, const OMPIteratorHelperData &D);\n\n  unsigned numTrailingObjects(OverloadToken<Decl *>) const {\n    return NumIterators;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return NumIterators * static_cast<int>(RangeExprOffset::Total);\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return NumIterators * static_cast<int>(RangeLocOffset::Total);\n  }\n\npublic:\n  static OMPIteratorExpr *Create(const ASTContext &Context, QualType T,\n                                 SourceLocation IteratorKwLoc, SourceLocation L,\n                                 SourceLocation R,\n                                 ArrayRef<IteratorDefinition> Data,\n                                 ArrayRef<OMPIteratorHelperData> Helpers);\n\n  static OMPIteratorExpr *CreateEmpty(const ASTContext &Context,\n                                      unsigned NumIterators);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getIteratorKwLoc() const { return IteratorKwLoc; }\n  void setIteratorKwLoc(SourceLocation L) { IteratorKwLoc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return IteratorKwLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RPLoc; }\n\n  /// Gets the iterator declaration for the given iterator.\n  Decl *getIteratorDecl(unsigned I);\n  const Decl *getIteratorDecl(unsigned I) const {\n    return const_cast<OMPIteratorExpr *>(this)->getIteratorDecl(I);\n  }\n\n  /// Gets the iterator range for the given iterator.\n  IteratorRange getIteratorRange(unsigned I);\n  const IteratorRange getIteratorRange(unsigned I) const {\n    return const_cast<OMPIteratorExpr *>(this)->getIteratorRange(I);\n  }\n\n  /// Gets the location of '=' for the given iterator definition.\n  SourceLocation getAssignLoc(unsigned I) const;\n  /// Gets the location of the first ':' in the range for the given iterator\n  /// definition.\n  SourceLocation getColonLoc(unsigned I) const;\n  /// Gets the location of the second ':' (if any) in the range for the given\n  /// iteratori definition.\n  SourceLocation getSecondColonLoc(unsigned I) const;\n\n  /// Returns number of iterator definitions.\n  unsigned numOfIterators() const { return NumIterators; }\n\n  /// Fetches helper data for the specified iteration space.\n  OMPIteratorHelperData &getHelper(unsigned I);\n  const OMPIteratorHelperData &getHelper(unsigned I) const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPIteratorExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(\n        Begin, Begin + NumIterators * static_cast<int>(RangeExprOffset::Total));\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(\n        Begin, Begin + NumIterators * static_cast<int>(RangeExprOffset::Total));\n  }\n};\n\n}",
  "id": "BLOCK-CPP-11109",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprOpenMP.h",
  "source_line": 19,
  "validation_status": "validated"
}