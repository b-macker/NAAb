{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace numbers_internal {\n\n// Digit conversion.\nABSL_DLL extern const char kHexChar[17];  // 0123456789abcdef\nABSL_DLL extern const char\n    kHexTable[513];  // 000102030405060708090a0b0c0d0e0f1011...\n\n// Writes a two-character representation of 'i' to 'buf'. 'i' must be in the\n// range 0 <= i < 100, and buf must have space for two characters. Example:\n//   char buf[2];\n//   PutTwoDigits(42, buf);\n//   // buf[0] == '4'\n//   // buf[1] == '2'\nvoid PutTwoDigits(uint32_t i, absl::Nonnull<char*> buf);\n\n// safe_strto?() functions for implementing SimpleAtoi()\n\nbool safe_strto32_base(absl::string_view text, absl::Nonnull<int32_t*> value,\n                       int base);\nbool safe_strto64_base(absl::string_view text, absl::Nonnull<int64_t*> value,\n                       int base);\nbool safe_strto128_base(absl::string_view text,\n                        absl::Nonnull<absl::int128*> value, int base);\nbool safe_strtou32_base(absl::string_view text, absl::Nonnull<uint32_t*> value,\n                        int base);\nbool safe_strtou64_base(absl::string_view text, absl::Nonnull<uint64_t*> value,\n                        int base);\nbool safe_strtou128_base(absl::string_view text,\n                         absl::Nonnull<absl::uint128*> value, int base);\n\nstatic const int kFastToBufferSize = 32;\nstatic const int kSixDigitsToBufferSize = 16;\n\ntemplate <class T>\nstd::enable_if_t<!std::is_unsigned<T>::value, bool> IsNegative(const T& v) {\n  return v < T();\n}\n\ntemplate <class T>\nstd::enable_if_t<std::is_unsigned<T>::value, std::false_type> IsNegative(\n    const T&) {\n  // The integer is unsigned, so return a compile-time constant.\n  // This can help the optimizer avoid having to prove bool to be false later.\n  return std::false_type();\n}\n\ntemplate <class T>\nstd::enable_if_t<std::is_unsigned<std::decay_t<T>>::value, T&&>\nUnsignedAbsoluteValue(T&& v ABSL_ATTRIBUTE_LIFETIME_BOUND) {\n  // The value is unsigned; just return the original.\n  return std::forward<T>(v);\n}\n\ntemplate <class T>\nABSL_ATTRIBUTE_CONST_FUNCTION\n    std::enable_if_t<!std::is_unsigned<T>::value, std::make_unsigned_t<T>>\n    UnsignedAbsoluteValue(T v) {\n  using U = std::make_unsigned_t<T>;\n  return IsNegative(v) ? U() - static_cast<U>(v) : static_cast<U>(v);\n}\n\n// Returns the number of base-10 digits in the given number.\n// Note that this strictly counts digits. It does not count the sign.\n// The `initial_digits` parameter is the starting point, which is normally equal\n// to 1 because the number of digits in 0 is 1 (a special case).\n// However, callers may e.g. wish to change it to 2 to account for the sign.\ntemplate <typename T>\nstd::enable_if_t<std::is_unsigned<T>::value, uint32_t> Base10Digits(\n    T v, const uint32_t initial_digits = 1) {\n  uint32_t r = initial_digits;\n  // If code size becomes an issue, the 'if' stage can be removed for a minor\n  // performance loss.\n  for (;;) {\n    if (ABSL_PREDICT_TRUE(v < 10 * 10)) {\n      r += (v >= 10);\n      break;\n    }\n    if (ABSL_PREDICT_TRUE(v < 1000 * 10)) {\n      r += (v >= 1000) + 2;\n      break;\n    }\n    if (ABSL_PREDICT_TRUE(v < 100000 * 10)) {\n      r += (v >= 100000) + 4;\n      break;\n    }\n    r += 6;\n    v = static_cast<T>(v / 1000000);\n  }\n  return r;\n}\n\ntemplate <typename T>\nstd::enable_if_t<std::is_signed<T>::value, uint32_t> Base10Digits(\n    T v, uint32_t r = 1) {\n  // Branchlessly add 1 to account for a minus sign.\n  r += static_cast<uint32_t>(IsNegative(v));\n  return Base10Digits(UnsignedAbsoluteValue(v), r);\n}\n\n// These functions return the number of base-10 digits, but multiplied by -1 if\n// the input itself is negative. This is handy and efficient for later usage,\n// since the bitwise complement of the result becomes equal to the number of\n// characters required.\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    signed char v);\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    unsigned char v);\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    short v);  // NOLINT\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    unsigned short v);  // NOLINT\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(int v);\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    unsigned int v);\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    long v);  // NOLINT\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    unsigned long v);  // NOLINT\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    long long v);  // NOLINT\nABSL_ATTRIBUTE_CONST_FUNCTION int GetNumDigitsOrNegativeIfNegative(\n    unsigned long long v);  // NOLINT\n\n// Helper function for fast formatting of floating-point values.\n// The result is the same as printf's \"%g\", a.k.a. \"%.6g\"; that is, six\n// significant digits are returned, trailing zeros are removed, and numbers\n// outside the range 0.0001-999999 are output using scientific notation\n// (1.23456e+06). This routine is heavily optimized.\n// Required buffer size is `kSixDigitsToBufferSize`.\nsize_t SixDigitsToBuffer(double d, absl::Nonnull<char*> buffer);\n\n// All of these functions take an output buffer\n// as an argument and return a pointer to the last byte they wrote, which is the\n// terminating '\\0'. At most `kFastToBufferSize` bytes are written.\nabsl::Nonnull<char*> FastIntToBuffer(int32_t i, absl::Nonnull<char*> buffer);\nabsl::Nonnull<char*> FastIntToBuffer(uint32_t i, absl::Nonnull<char*> buffer);\nabsl::Nonnull<char*> FastIntToBuffer(int64_t i, absl::Nonnull<char*> buffer);\nabsl::Nonnull<char*> FastIntToBuffer(uint64_t i, absl::Nonnull<char*> buffer);\n\n// For enums and integer types that are not an exact match for the types above,\n// use templates to call the appropriate one of the four overloads above.\ntemplate <typename int_type>\nabsl::Nonnull<char*> FastIntToBuffer(int_type i, absl::Nonnull<char*> buffer) {\n  static_assert(sizeof(i) <= 64 / 8,\n                \"FastIntToBuffer works only with 64-bit-or-less integers.\");\n  // TODO(jorg): This signed-ness check is used because it works correctly\n  // with enums, and it also serves to check that int_type is not a pointer.\n  // If one day something like std::is_signed<enum E> works, switch to it.\n  // These conditions are constexpr bools to suppress MSVC warning C4127.\n  constexpr bool kIsSigned = static_cast<int_type>(1) - 2 < 0;\n  constexpr bool kUse64Bit = sizeof(i) > 32 / 8;\n  if (kIsSigned) {\n    if (kUse64Bit) {\n      return FastIntToBuffer(static_cast<int64_t>(i), buffer);\n    } else {\n      return FastIntToBuffer(static_cast<int32_t>(i), buffer);\n    }\n  } else {\n    if (kUse64Bit) {\n      return FastIntToBuffer(static_cast<uint64_t>(i), buffer);\n    } else {\n      return FastIntToBuffer(static_cast<uint32_t>(i), buffer);\n    }\n  }\n}\n\n// These functions do NOT add any null-terminator.\n// They return a pointer to the beginning of the written string.\n// The digit counts provided must *exactly* match the number of base-10 digits\n// in the number, or the behavior is undefined.\n// (i.e. do NOT count the minus sign, or over- or under-count the digits.)\nabsl::Nonnull<char*> FastIntToBufferBackward(int32_t i,\n                                             absl::Nonnull<char*> buffer_end,\n                                             uint32_t exact_digit_count);\nabsl::Nonnull<char*> FastIntToBufferBackward(uint32_t i,\n                                             absl::Nonnull<char*> buffer_end,\n                                             uint32_t exact_digit_count);\nabsl::Nonnull<char*> FastIntToBufferBackward(int64_t i,\n                                             absl::Nonnull<char*> buffer_end,\n                                             uint32_t exact_digit_count);\nabsl::Nonnull<char*> FastIntToBufferBackward(uint64_t i,\n                                             absl::Nonnull<char*> buffer_end,\n                                             uint32_t exact_digit_count);\n\n// For enums and integer types that are not an exact match for the types above,\n// use templates to call the appropriate one of the four overloads above.\ntemplate <typename int_type>\nabsl::Nonnull<char*> FastIntToBufferBackward(int_type i,\n                                             absl::Nonnull<char*> buffer_end,\n                                             uint32_t exact_digit_count) {\n  static_assert(\n      sizeof(i) <= 64 / 8,\n      \"FastIntToBufferBackward works only with 64-bit-or-less integers.\");\n  // This signed-ness check is used because it works correctly\n  // with enums, and it also serves to check that int_type is not a pointer.\n  // If one day something like std::is_signed<enum E> works, switch to it.\n  // These conditions are constexpr bools to suppress MSVC warning C4127.\n  constexpr bool kIsSigned = static_cast<int_type>(1) - 2 < 0;\n  constexpr bool kUse64Bit = sizeof(i) > 32 / 8;\n  if (kIsSigned) {\n    if (kUse64Bit) {\n      return FastIntToBufferBackward(static_cast<int64_t>(i), buffer_end,\n                                     exact_digit_count);\n    } else {\n      return FastIntToBufferBackward(static_cast<int32_t>(i), buffer_end,\n                                     exact_digit_count);\n    }\n  } else {\n    if (kUse64Bit) {\n      return FastIntToBufferBackward(static_cast<uint64_t>(i), buffer_end,\n                                     exact_digit_count);\n    } else {\n      return FastIntToBufferBackward(static_cast<uint32_t>(i), buffer_end,\n                                     exact_digit_count);\n    }\n  }\n}\n\n// Implementation of SimpleAtoi, generalized to support arbitrary base (used\n// with base different from 10 elsewhere in Abseil implementation).\ntemplate <typename int_type>\nABSL_MUST_USE_RESULT bool safe_strtoi_base(absl::string_view s,\n                                           absl::Nonnull<int_type*> out,\n                                           int base) {\n  static_assert(sizeof(*out) == 4 || sizeof(*out) == 8,\n                \"SimpleAtoi works only with 32-bit or 64-bit integers.\");\n  static_assert(!std::is_floating_point<int_type>::value,\n                \"Use SimpleAtof or SimpleAtod instead.\");\n  bool parsed;\n  // TODO(jorg): This signed-ness check is used because it works correctly\n  // with enums, and it also serves to check that int_type is not a pointer.\n  // If one day something like std::is_signed<enum E> works, switch to it.\n  // These conditions are constexpr bools to suppress MSVC warning C4127.\n  constexpr bool kIsSigned = static_cast<int_type>(1) - 2 < 0;\n  constexpr bool kUse64Bit = sizeof(*out) == 64 / 8;\n  if (kIsSigned) {\n    if (kUse64Bit) {\n      int64_t val;\n      parsed = numbers_internal::safe_strto64_base(s, &val, base);\n      *out = static_cast<int_type>(val);\n    } else {\n      int32_t val;\n      parsed = numbers_internal::safe_strto32_base(s, &val, base);\n      *out = static_cast<int_type>(val);\n    }\n  } else {\n    if (kUse64Bit) {\n      uint64_t val;\n      parsed = numbers_internal::safe_strtou64_base(s, &val, base);\n      *out = static_cast<int_type>(val);\n    } else {\n      uint32_t val;\n      parsed = numbers_internal::safe_strtou32_base(s, &val, base);\n      *out = static_cast<int_type>(val);\n    }\n  }\n  return parsed;\n}\n\n// FastHexToBufferZeroPad16()\n//\n// Outputs `val` into `out` as if by `snprintf(out, 17, \"%016x\", val)` but\n// without the terminating null character. Thus `out` must be of length >= 16.\n// Returns the number of non-pad digits of the output (it can never be zero\n// since 0 has one digit).\ninline size_t FastHexToBufferZeroPad16(uint64_t val, absl::Nonnull<char*> out) {\n#ifdef ABSL_INTERNAL_HAVE_SSSE3\n  uint64_t be = absl::big_endian::FromHost64(val);\n  const auto kNibbleMask = _mm_set1_epi8(0xf);\n  const auto kHexDigits = _mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7',\n                                        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');\n  auto v = _mm_loadl_epi64(reinterpret_cast<__m128i*>(&be));  // load lo dword\n  auto v4 = _mm_srli_epi64(v, 4);                            // shift 4 right\n  auto il = _mm_unpacklo_epi8(v4, v);                        // interleave bytes\n  auto m = _mm_and_si128(il, kNibbleMask);                   // mask out nibbles\n  auto hexchars = _mm_shuffle_epi8(kHexDigits, m);           // hex chars\n  _mm_storeu_si128(reinterpret_cast<__m128i*>(out), hexchars);\n#else\n  for (int i = 0; i < 8; ++i) {\n    auto byte = (val >> (56 - 8 * i)) & 0xFF;\n    auto* hex = &absl::numbers_internal::kHexTable[byte * 2];\n    std::memcpy(out + 2 * i, hex, 2);\n  }\n#endif\n  // | 0x1 so that even 0 has 1 digit.\n  return 16 - static_cast<size_t>(countl_zero(val | 0x1) / 4);\n}\n\n}  // namespace numbers_internal\n\ntemplate <typename int_type>\nABSL_MUST_USE_RESULT bool SimpleAtoi(absl::string_view str,\n                                     absl::Nonnull<int_type*> out) {\n  return numbers_internal::safe_strtoi_base(str, out, 10);\n}\n\nABSL_MUST_USE_RESULT inline bool SimpleAtoi(absl::string_view str,\n                                            absl::Nonnull<absl::int128*> out) {\n  return numbers_internal::safe_strto128_base(str, out, 10);\n}\n\nABSL_MUST_USE_RESULT inline bool SimpleAtoi(absl::string_view str,\n                                            absl::Nonnull<absl::uint128*> out) {\n  return numbers_internal::safe_strtou128_base(str, out, 10);\n}\n\ntemplate <typename int_type>\nABSL_MUST_USE_RESULT bool SimpleHexAtoi(absl::string_view str,\n                                        absl::Nonnull<int_type*> out) {\n  return numbers_internal::safe_strtoi_base(str, out, 16);\n}\n\nABSL_MUST_USE_RESULT inline bool SimpleHexAtoi(\n    absl::string_view str, absl::Nonnull<absl::int128*> out) {\n  return numbers_internal::safe_strto128_base(str, out, 16);\n}\n\nABSL_MUST_USE_RESULT inline bool SimpleHexAtoi(\n    absl::string_view str, absl::Nonnull<absl::uint128*> out) {\n  return numbers_internal::safe_strtou128_base(str, out, 16);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04099",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/numbers.h",
  "source_line": 129,
  "validation_status": "validated"
}