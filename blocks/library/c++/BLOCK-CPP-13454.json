{
  "code": "{\npublic:\n  /// The kind of template argument we're storing.\n  enum ArgKind {\n    /// Represents an empty template argument, e.g., one that has not\n    /// been deduced.\n    Null = 0,\n\n    /// The template argument is a type.\n    Type,\n\n    /// The template argument is a declaration that was provided for a pointer,\n    /// reference, or pointer to member non-type template parameter.\n    Declaration,\n\n    /// The template argument is a null pointer or null pointer to member that\n    /// was provided for a non-type template parameter.\n    NullPtr,\n\n    /// The template argument is an integral value stored in an llvm::APSInt\n    /// that was provided for an integral non-type template parameter.\n    Integral,\n\n    /// The template argument is a template name that was provided for a\n    /// template template parameter.\n    Template,\n\n    /// The template argument is a pack expansion of a template name that was\n    /// provided for a template template parameter.\n    TemplateExpansion,\n\n    /// The template argument is an expression, and we've not resolved it to one\n    /// of the other forms yet, either because it's dependent or because we're\n    /// representing a non-canonical template argument (for instance, in a\n    /// TemplateSpecializationType).\n    Expression,\n\n    /// The template argument is actually a parameter pack. Arguments are stored\n    /// in the Args struct.\n    Pack\n  };\n\nprivate:\n  /// The kind of template argument we're storing.\n\n  struct DA {\n    unsigned Kind : 31;\n    unsigned IsDefaulted : 1;\n    void *QT;\n    ValueDecl *D;\n  };\n  struct I {\n    unsigned Kind : 31;\n    unsigned IsDefaulted : 1;\n    // We store a decomposed APSInt with the data allocated by ASTContext if\n    // BitWidth > 64. The memory may be shared between multiple\n    // TemplateArgument instances.\n    unsigned BitWidth : 31;\n    unsigned IsUnsigned : 1;\n    union {\n      /// Used to store the <= 64 bits integer value.\n      uint64_t VAL;\n\n      /// Used to store the >64 bits integer value.\n      const uint64_t *pVal;\n    };\n    void *Type;\n  };\n  struct A {\n    unsigned Kind : 31;\n    unsigned IsDefaulted : 1;\n    unsigned NumArgs;\n    const TemplateArgument *Args;\n  };\n  struct TA {\n    unsigned Kind : 31;\n    unsigned IsDefaulted : 1;\n    unsigned NumExpansions;\n    void *Name;\n  };\n  struct TV {\n    unsigned Kind : 31;\n    unsigned IsDefaulted : 1;\n    uintptr_t V;\n  };\n  union {\n    struct DA DeclArg;\n    struct I Integer;\n    struct A Args;\n    struct TA TemplateArg;\n    struct TV TypeOrValue;\n  };\n\npublic:\n  /// Construct an empty, invalid template argument.\n  constexpr TemplateArgument() : TypeOrValue({Null, 0, /* IsDefaulted */ 0}) {}\n\n  /// Construct a template type argument.\n  TemplateArgument(QualType T, bool isNullPtr = false,\n                   bool IsDefaulted = false) {\n    TypeOrValue.Kind = isNullPtr ? NullPtr : Type;\n    TypeOrValue.IsDefaulted = IsDefaulted;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n  }\n\n  /// Construct a template argument that refers to a\n  /// declaration, which is either an external declaration or a\n  /// template declaration.\n  TemplateArgument(ValueDecl *D, QualType QT, bool IsDefaulted = false) {\n    assert(D && \"Expected decl\");\n    DeclArg.Kind = Declaration;\n    DeclArg.IsDefaulted = IsDefaulted;\n    DeclArg.QT = QT.getAsOpaquePtr();\n    DeclArg.D = D;\n  }\n\n  /// Construct an integral constant template argument. The memory to\n  /// store the value is allocated with Ctx.\n  TemplateArgument(ASTContext &Ctx, const llvm::APSInt &Value, QualType Type,\n                   bool IsDefaulted = false);\n\n  /// Construct an integral constant template argument with the same\n  /// value as Other but a different type.\n  TemplateArgument(const TemplateArgument &Other, QualType Type) {\n    Integer = Other.Integer;\n    Integer.Type = Type.getAsOpaquePtr();\n  }\n\n  /// Construct a template argument that is a template.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  ///\n  /// \\param IsDefaulted If 'true', implies that this TemplateArgument\n  /// corresponds to a default template parameter\n  TemplateArgument(TemplateName Name, bool IsDefaulted = false) {\n    TemplateArg.Kind = Template;\n    TemplateArg.IsDefaulted = IsDefaulted;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is a template pack expansion.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  ///\n  /// \\param NumExpansions The number of expansions that will be generated by\n  /// instantiating\n  ///\n  /// \\param IsDefaulted If 'true', implies that this TemplateArgument\n  /// corresponds to a default template parameter\n  TemplateArgument(TemplateName Name, std::optional<unsigned> NumExpansions,\n                   bool IsDefaulted = false) {\n    TemplateArg.Kind = TemplateExpansion;\n    TemplateArg.IsDefaulted = IsDefaulted;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    if (NumExpansions)\n      TemplateArg.NumExpansions = *NumExpansions + 1;\n    else\n      TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is an expression.\n  ///\n  /// This form of template argument only occurs in template argument\n  /// lists used for dependent types and for expression; it will not\n  /// occur in a non-dependent, canonical template argument list.\n  TemplateArgument(Expr *E, bool IsDefaulted = false) {\n    TypeOrValue.Kind = Expression;\n    TypeOrValue.IsDefaulted = IsDefaulted;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(E);\n  }\n\n  /// Construct a template argument that is a template argument pack.\n  ///\n  /// We assume that storage for the template arguments provided\n  /// outlives the TemplateArgument itself.\n  explicit TemplateArgument(ArrayRef<TemplateArgument> Args) {\n    this->Args.Kind = Pack;\n    this->Args.IsDefaulted = false;\n    this->Args.Args = Args.data();\n    this->Args.NumArgs = Args.size();\n  }\n\n  static TemplateArgument getEmptyPack() {\n    return TemplateArgument(std::nullopt);\n  }\n\n  /// Create a new template argument pack by copying the given set of\n  /// template arguments.\n  static TemplateArgument CreatePackCopy(ASTContext &Context,\n                                         ArrayRef<TemplateArgument> Args);\n\n  /// Return the kind of stored template argument.\n  ArgKind getKind() const { return (ArgKind)TypeOrValue.Kind; }\n\n  /// Determine whether this template argument has no value.\n  bool isNull() const { return getKind() == Null; }\n\n  TemplateArgumentDependence getDependence() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter such that its result can change from one instantiation to\n  /// another.\n  bool isDependent() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this template argument contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// Determine whether this template argument is a pack expansion.\n  bool isPackExpansion() const;\n\n  /// Retrieve the type for a type template argument.\n  QualType getAsType() const {\n    assert(getKind() == Type && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the declaration for a declaration non-type\n  /// template argument.\n  ValueDecl *getAsDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return DeclArg.D;\n  }\n\n  QualType getParamTypeForDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(DeclArg.QT);\n  }\n\n  /// Retrieve the type for null non-type template argument.\n  QualType getNullPtrType() const {\n    assert(getKind() == NullPtr && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the template name for a template name argument.\n  TemplateName getAsTemplate() const {\n    assert(getKind() == Template && \"Unexpected kind\");\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the template argument as a template name; if the argument\n  /// is a pack expansion, return the pattern as a template name.\n  TemplateName getAsTemplateOrTemplatePattern() const {\n    assert((getKind() == Template || getKind() == TemplateExpansion) &&\n           \"Unexpected kind\");\n\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the number of expansions that a template template argument\n  /// expansion will produce, if known.\n  std::optional<unsigned> getNumTemplateExpansions() const;\n\n  /// Retrieve the template argument as an integral value.\n  // FIXME: Provide a way to read the integral data without copying the value.\n  llvm::APSInt getAsIntegral() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n\n    using namespace llvm;\n\n    if (Integer.BitWidth <= 64)\n      return APSInt(APInt(Integer.BitWidth, Integer.VAL), Integer.IsUnsigned);\n\n    unsigned NumWords = APInt::getNumWords(Integer.BitWidth);\n    return APSInt(APInt(Integer.BitWidth, ArrayRef(Integer.pVal, NumWords)),\n                  Integer.IsUnsigned);\n  }\n\n  /// Retrieve the type of the integral value.\n  QualType getIntegralType() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(Integer.Type);\n  }\n\n  void setIntegralType(QualType T) {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    Integer.Type = T.getAsOpaquePtr();\n  }\n\n  /// Set to 'true' if this TemplateArgument corresponds to a\n  /// default template parameter.\n  void setIsDefaulted(bool v) { TypeOrValue.IsDefaulted = v; }\n\n  /// If returns 'true', this TemplateArgument corresponds to a\n  /// default template parameter.\n  bool getIsDefaulted() const { return (bool)TypeOrValue.IsDefaulted; }\n\n  /// If this is a non-type template argument, get its type. Otherwise,\n  /// returns a null QualType.\n  QualType getNonTypeTemplateArgumentType() const;\n\n  /// Retrieve the template argument as an expression.\n  Expr *getAsExpr() const {\n    assert(getKind() == Expression && \"Unexpected kind\");\n    return reinterpret_cast<Expr *>(TypeOrValue.V);\n  }\n\n  /// Iterator that traverses the elements of a template argument pack.\n  using pack_iterator = const TemplateArgument *;\n\n  /// Iterator referencing the first argument of a template argument\n  /// pack.\n  pack_iterator pack_begin() const {\n    assert(getKind() == Pack);\n    return Args.Args;\n  }\n\n  /// Iterator referencing one past the last argument of a template\n  /// argument pack.\n  pack_iterator pack_end() const {\n    assert(getKind() == Pack);\n    return Args.Args + Args.NumArgs;\n  }\n\n  /// Iterator range referencing all of the elements of a template\n  /// argument pack.\n  ArrayRef<TemplateArgument> pack_elements() const {\n    return llvm::ArrayRef(pack_begin(), pack_end());\n  }\n\n  /// The number of template arguments in the given template argument\n  /// pack.\n  unsigned pack_size() const {\n    assert(getKind() == Pack);\n    return Args.NumArgs;\n  }\n\n  /// Return the array of arguments in this template argument pack.\n  ArrayRef<TemplateArgument> getPackAsArray() const {\n    assert(getKind() == Pack);\n    return llvm::ArrayRef(Args.Args, Args.NumArgs);\n  }\n\n  /// Determines whether two template arguments are superficially the\n  /// same.\n  bool structurallyEquals(const TemplateArgument &Other) const;\n\n  /// When the template argument is a pack expansion, returns\n  /// the pattern of the pack expansion.\n  TemplateArgument getPackExpansionPattern() const;\n\n  /// Print this template argument to the given output stream.\n  void print(const PrintingPolicy &Policy, raw_ostream &Out,\n             bool IncludeType) const;\n\n  /// Debugging aid that dumps the template argument.\n  void dump(raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument to standard error.\n  void dump() const;\n\n  /// Used to insert TemplateArguments into FoldingSets.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) const;\n}",
  "id": "BLOCK-CPP-13454",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TemplateBase.h",
  "source_line": 60,
  "validation_status": "validated"
}