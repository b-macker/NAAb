{
  "code": "{\n\n/// DeclarationFragments is a vector of tagged important parts of a symbol's\n/// declaration.\n///\n/// The fragments sequence can be joined to form spans of declaration text, with\n/// attached information useful for purposes like syntax-highlighting etc.\n/// For example:\n/// \\code\n///   const -> keyword    \"const\"\n///   int   -> type       \"int\"\n///   pi;   -> identifier \"pi\"\n/// \\endcode\nclass DeclarationFragments {\npublic:\n  DeclarationFragments() = default;\n\n  /// The kind of a fragment.\n  enum class FragmentKind {\n    /// Unknown fragment kind.\n    None,\n\n    Keyword,\n    Attribute,\n    NumberLiteral,\n    StringLiteral,\n    Identifier,\n\n    /// Identifier that refers to a type in the context.\n    TypeIdentifier,\n\n    /// Parameter that's used as generics in the context. For example template\n    /// parameters.\n    GenericParameter,\n\n    /// External parameters in Objective-C methods.\n    /// For example, \\c forKey in\n    /// \\code{.m}\n    ///   - (void) setValue:(Value)value forKey(Key)key\n    /// \\endcode\n    ExternalParam,\n\n    /// Internal/local parameters in Objective-C methods.\n    /// For example, \\c key in\n    /// \\code{.m}\n    ///   - (void) setValue:(Value)value forKey(Key)key\n    /// \\endcode\n    InternalParam,\n\n    Text,\n  };\n\n  /// Fragment holds information of a single fragment.\n  struct Fragment {\n    std::string Spelling;\n    FragmentKind Kind;\n\n    /// The USR of the fragment symbol, if applicable.\n    std::string PreciseIdentifier;\n\n    /// The associated declaration, if applicable. This is not intended to be\n    /// used outside of libclang.\n    const Decl *Declaration;\n\n    Fragment(StringRef Spelling, FragmentKind Kind, StringRef PreciseIdentifier,\n             const Decl *Declaration)\n        : Spelling(Spelling), Kind(Kind), PreciseIdentifier(PreciseIdentifier),\n          Declaration(Declaration) {}\n  };\n\n  using FragmentIterator = std::vector<Fragment>::iterator;\n  using ConstFragmentIterator = std::vector<Fragment>::const_iterator;\n\n  const std::vector<Fragment> &getFragments() const { return Fragments; }\n\n  FragmentIterator begin() { return Fragments.begin(); }\n\n  FragmentIterator end() { return Fragments.end(); }\n\n  ConstFragmentIterator cbegin() const { return Fragments.cbegin(); }\n\n  ConstFragmentIterator cend() const { return Fragments.cend(); }\n\n  // Add a new Fragment at an arbitrary offset.\n  DeclarationFragments &insert(FragmentIterator It, StringRef Spelling,\n                               FragmentKind Kind,\n                               StringRef PreciseIdentifier = \"\",\n                               const Decl *Declaration = nullptr) {\n    Fragments.insert(It,\n                     Fragment(Spelling, Kind, PreciseIdentifier, Declaration));\n    return *this;\n  }\n\n  DeclarationFragments &insert(FragmentIterator It,\n                               DeclarationFragments &&Other) {\n    Fragments.insert(It, std::make_move_iterator(Other.Fragments.begin()),\n                     std::make_move_iterator(Other.Fragments.end()));\n    Other.Fragments.clear();\n    return *this;\n  }\n\n  /// Append a new Fragment to the end of the Fragments.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &append(StringRef Spelling, FragmentKind Kind,\n                               StringRef PreciseIdentifier = \"\",\n                               const Decl *Declaration = nullptr) {\n    if (Kind == FragmentKind::Text && !Fragments.empty() &&\n        Fragments.back().Kind == FragmentKind::Text) {\n      // If appending a text fragment, and the last fragment is also text,\n      // merge into the last fragment.\n      Fragments.back().Spelling.append(Spelling.data(), Spelling.size());\n    } else {\n      Fragments.emplace_back(Spelling, Kind, PreciseIdentifier, Declaration);\n    }\n    return *this;\n  }\n\n  /// Append another DeclarationFragments to the end.\n  ///\n  /// Note: \\p Other is moved from and cannot be used after a call to this\n  /// method.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &append(DeclarationFragments &&Other) {\n    Fragments.insert(Fragments.end(),\n                     std::make_move_iterator(Other.Fragments.begin()),\n                     std::make_move_iterator(Other.Fragments.end()));\n    Other.Fragments.clear();\n    return *this;\n  }\n\n  /// Append a text Fragment of a space character.\n  ///\n  /// \\returns a reference to the DeclarationFragments object itself after\n  /// appending to chain up consecutive appends.\n  DeclarationFragments &appendSpace();\n\n  /// Get the string description of a FragmentKind \\p Kind.\n  static StringRef getFragmentKindString(FragmentKind Kind);\n\n  /// Get the corresponding FragmentKind from string \\p S.\n  static FragmentKind parseFragmentKindFromString(StringRef S);\n\nprivate:\n  std::vector<Fragment> Fragments;\n};\n\n/// Store function signature information with DeclarationFragments of the\n/// return type and parameters.\nclass FunctionSignature {\npublic:\n  FunctionSignature() = default;\n\n  /// Parameter holds the name and DeclarationFragments of a single parameter.\n  struct Parameter {\n    std::string Name;\n    DeclarationFragments Fragments;\n\n    Parameter(StringRef Name, DeclarationFragments Fragments)\n        : Name(Name), Fragments(Fragments) {}\n  };\n\n  const std::vector<Parameter> &getParameters() const { return Parameters; }\n  const DeclarationFragments &getReturnType() const { return ReturnType; }\n\n  FunctionSignature &addParameter(StringRef Name,\n                                  DeclarationFragments Fragments) {\n    Parameters.emplace_back(Name, Fragments);\n    return *this;\n  }\n\n  void setReturnType(DeclarationFragments RT) { ReturnType = RT; }\n\n  /// Determine if the FunctionSignature is empty.\n  ///\n  /// \\returns true if the return type DeclarationFragments is empty and there\n  /// is no parameter, otherwise false.\n  bool empty() const {\n    return Parameters.empty() && ReturnType.getFragments().empty();\n  }\n\nprivate:\n  std::vector<Parameter> Parameters;\n  DeclarationFragments ReturnType;\n};\n\n/// A factory class to build DeclarationFragments for different kinds of Decl.\nclass DeclarationFragmentsBuilder {\npublic:\n  /// Build DeclarationFragments for a variable declaration VarDecl.\n  static DeclarationFragments getFragmentsForVar(const VarDecl *);\n\n  /// Build DeclarationFragments for a function declaration FunctionDecl.\n  static DeclarationFragments getFragmentsForFunction(const FunctionDecl *);\n\n  /// Build DeclarationFragments for an enum constant declaration\n  /// EnumConstantDecl.\n  static DeclarationFragments\n  getFragmentsForEnumConstant(const EnumConstantDecl *);\n\n  /// Build DeclarationFragments for an enum declaration EnumDecl.\n  static DeclarationFragments getFragmentsForEnum(const EnumDecl *);\n\n  /// Build DeclarationFragments for a field declaration FieldDecl.\n  static DeclarationFragments getFragmentsForField(const FieldDecl *);\n\n  /// Build DeclarationFragments for a struct record declaration RecordDecl.\n  static DeclarationFragments getFragmentsForStruct(const RecordDecl *);\n\n  /// Build DeclarationFragments for an Objective-C category declaration\n  /// ObjCCategoryDecl.\n  static DeclarationFragments\n  getFragmentsForObjCCategory(const ObjCCategoryDecl *);\n\n  /// Build DeclarationFragments for an Objective-C interface declaration\n  /// ObjCInterfaceDecl.\n  static DeclarationFragments\n  getFragmentsForObjCInterface(const ObjCInterfaceDecl *);\n\n  /// Build DeclarationFragments for an Objective-C method declaration\n  /// ObjCMethodDecl.\n  static DeclarationFragments getFragmentsForObjCMethod(const ObjCMethodDecl *);\n\n  /// Build DeclarationFragments for an Objective-C property declaration\n  /// ObjCPropertyDecl.\n  static DeclarationFragments\n  getFragmentsForObjCProperty(const ObjCPropertyDecl *);\n\n  /// Build DeclarationFragments for an Objective-C protocol declaration\n  /// ObjCProtocolDecl.\n  static DeclarationFragments\n  getFragmentsForObjCProtocol(const ObjCProtocolDecl *);\n\n  /// Build DeclarationFragments for a macro.\n  ///\n  /// \\param Name name of the macro.\n  /// \\param MD the associated MacroDirective.\n  static DeclarationFragments getFragmentsForMacro(StringRef Name,\n                                                   const MacroDirective *MD);\n\n  /// Build DeclarationFragments for a typedef \\p TypedefNameDecl.\n  static DeclarationFragments\n  getFragmentsForTypedef(const TypedefNameDecl *Decl);\n\n  /// Build sub-heading fragments for a NamedDecl.\n  static DeclarationFragments getSubHeading(const NamedDecl *);\n\n  /// Build sub-heading fragments for an Objective-C method.\n  static DeclarationFragments getSubHeading(const ObjCMethodDecl *);\n\n  /// Build a sub-heading for macro \\p Name.\n  static DeclarationFragments getSubHeadingForMacro(StringRef Name);\n\n  /// Build FunctionSignature for a function-like declaration \\c FunctionT like\n  /// FunctionDecl or ObjCMethodDecl.\n  ///\n  /// The logic and implementation of building a signature for a FunctionDecl\n  /// and an ObjCMethodDecl are exactly the same, but they do not share a common\n  /// base. This template helps reuse the code.\n  template <typename FunctionT>\n  static FunctionSignature getFunctionSignature(const FunctionT *);\n\nprivate:\n  DeclarationFragmentsBuilder() = delete;\n\n  /// Build DeclarationFragments for a QualType.\n  static DeclarationFragments getFragmentsForType(const QualType, ASTContext &,\n                                                  DeclarationFragments &);\n\n  /// Build DeclarationFragments for a Type.\n  static DeclarationFragments getFragmentsForType(const Type *, ASTContext &,\n                                                  DeclarationFragments &);\n\n  /// Build DeclarationFragments for a NestedNameSpecifier.\n  static DeclarationFragments getFragmentsForNNS(const NestedNameSpecifier *,\n                                                 ASTContext &,\n                                                 DeclarationFragments &);\n\n  /// Build DeclarationFragments for Qualifiers.\n  static DeclarationFragments getFragmentsForQualifiers(const Qualifiers quals);\n\n  /// Build DeclarationFragments for a parameter variable declaration\n  /// ParmVarDecl.\n  static DeclarationFragments getFragmentsForParam(const ParmVarDecl *);\n};\n\n}",
  "id": "BLOCK-CPP-18024",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ExtractAPI/DeclarationFragments.h",
  "source_line": 30,
  "validation_status": "validated"
}