{
  "code": "{\n\n// StringConstant<T> represents a compile time string constant.\n// It can be accessed via its `absl::string_view value` static member.\n// It is guaranteed that the `string_view` returned has constant `.data()`,\n// constant `.size()` and constant `value[i]` for all `0 <= i < .size()`\n//\n// The `T` is an opaque type. It is guaranteed that different string constants\n// will have different values of `T`. This allows users to associate the string\n// constant with other static state at compile time.\n//\n// Instances should be made using the `MakeStringConstant()` factory function\n// below.\ntemplate <typename T>\nstruct StringConstant {\n private:\n  static constexpr bool TryConstexprEval(absl::string_view view) {\n    return view.empty() || 2 * view[0] != 1;\n  }\n\n public:\n  static constexpr absl::string_view value = T{}();\n  constexpr absl::string_view operator()() const { return value; }\n\n  // Check to be sure `view` points to constant data.\n  // Otherwise, it can't be constant evaluated.\n  static_assert(TryConstexprEval(value),\n                \"The input string_view must point to constant data.\");\n};\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\ntemplate <typename T>\nconstexpr absl::string_view StringConstant<T>::value;\n#endif\n\n// Factory function for `StringConstant` instances.\n// It supports callables that have a constexpr default constructor and a\n// constexpr operator().\n// It must return an `absl::string_view` or `const char*` pointing to constant\n// data. This is validated at compile time.\ntemplate <typename T>\nconstexpr StringConstant<T> MakeStringConstant(T) {\n  return {};\n}\n\n}",
  "id": "BLOCK-CPP-06274",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/string_constant.h",
  "source_line": 23,
  "validation_status": "validated"
}