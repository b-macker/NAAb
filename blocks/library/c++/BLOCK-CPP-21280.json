{
  "code": "#include \"clang/ASTMatchers/Dynamic/Diagnostics.h\"\n#include \"clang/ASTMatchers/Dynamic/VariantValue.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <optional>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace ast_matchers;\nusing namespace dynamic;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21280_execute() {\n    {\n\nnamespace internal {\n\nclass MatcherDescriptor;\n\n/// A smart (owning) pointer for MatcherDescriptor. We can't use unique_ptr\n/// because MatcherDescriptor is forward declared\nclass MatcherDescriptorPtr {\npublic:\n  explicit MatcherDescriptorPtr(MatcherDescriptor *);\n  ~MatcherDescriptorPtr();\n  MatcherDescriptorPtr(MatcherDescriptorPtr &&) = default;\n  MatcherDescriptorPtr &operator=(MatcherDescriptorPtr &&) = default;\n  MatcherDescriptorPtr(const MatcherDescriptorPtr &) = delete;\n  MatcherDescriptorPtr &operator=(const MatcherDescriptorPtr &) = delete;\n\n  MatcherDescriptor *get() { return Ptr; }\n\nprivate:\n  MatcherDescriptor *Ptr;\n};\n\n} // namespace internal\n\nusing MatcherCtor = const internal::MatcherDescriptor *;\n\nstruct MatcherCompletion {\n  MatcherCompletion() = default;\n  MatcherCompletion(StringRef TypedText, StringRef MatcherDecl,\n                    unsigned Specificity)\n      : TypedText(TypedText), MatcherDecl(MatcherDecl),\n        Specificity(Specificity) {}\n\n  bool operator==(const MatcherCompletion &Other) const {\n    return TypedText == Other.TypedText && MatcherDecl == Other.MatcherDecl;\n  }\n\n  /// The text to type to select this matcher.\n  std::string TypedText;\n\n  /// The \"declaration\" of the matcher, with type information.\n  std::string MatcherDecl;\n\n  /// Value corresponding to the \"specificity\" of the converted matcher.\n  ///\n  /// Zero specificity indicates that this conversion would produce a trivial\n  /// matcher that will either always or never match.\n  /// Such matchers are excluded from code completion results.\n  unsigned Specificity;\n};\n\nclass Registry {\npublic:\n  Registry() = delete;\n\n  static ASTNodeKind nodeMatcherType(MatcherCtor);\n\n  static bool isBuilderMatcher(MatcherCtor Ctor);\n\n  static internal::MatcherDescriptorPtr\n  buildMatcherCtor(MatcherCtor, SourceRange NameRange,\n                   ArrayRef<ParserValue> Args, Diagnostics *Error);\n\n  /// Look up a matcher in the registry by name,\n  ///\n  /// \\return An opaque value which may be used to refer to the matcher\n  /// constructor, or std::optional<MatcherCtor>() if not found.\n  static std::optional<MatcherCtor> lookupMatcherCtor(StringRef MatcherName);\n\n  /// Compute the list of completion types for \\p Context.\n  ///\n  /// Each element of \\p Context represents a matcher invocation, going from\n  /// outermost to innermost. Elements are pairs consisting of a reference to\n  /// the matcher constructor and the index of the next element in the\n  /// argument list of that matcher (or for the last element, the index of\n  /// the completion point in the argument list). An empty list requests\n  /// completion for the root matcher.\n  static std::vector<ArgKind> getAcceptedCompletionTypes(\n      llvm::ArrayRef<std::pair<MatcherCtor, unsigned>> Context);\n\n  /// Compute the list of completions that match any of\n  /// \\p AcceptedTypes.\n  ///\n  /// \\param AcceptedTypes All types accepted for this completion.\n  ///\n  /// \\return All completions for the specified types.\n  /// Completions should be valid when used in \\c lookupMatcherCtor().\n  /// The matcher constructed from the return of \\c lookupMatcherCtor()\n  /// should be convertible to some type in \\p AcceptedTypes.\n  static std::vector<MatcherCompletion>\n  getMatcherCompletions(ArrayRef<ArgKind> AcceptedTypes);\n\n  /// Construct a matcher from the registry.\n  ///\n  /// \\param Ctor The matcher constructor to instantiate.\n  ///\n  /// \\param NameRange The location of the name in the matcher source.\n  ///   Useful for error reporting.\n  ///\n  /// \\param Args The argument list for the matcher. The number and types of the\n  ///   values must be valid for the matcher requested. Otherwise, the function\n  ///   will return an error.\n  ///\n  /// \\return The matcher object constructed if no error was found.\n  ///   A null matcher if the number of arguments or argument types do not match\n  ///   the signature.  In that case \\c Error will contain the description of\n  ///   the error.\n  static VariantMatcher constructMatcher(MatcherCtor Ctor,\n                                         SourceRange NameRange,\n                                         ArrayRef<ParserValue> Args,\n                                         Diagnostics *Error);\n\n  /// Construct a matcher from the registry and bind it.\n  ///\n  /// Similar the \\c constructMatcher() above, but it then tries to bind the\n  /// matcher to the specified \\c BindID.\n  /// If the matcher is not bindable, it sets an error in \\c Error and returns\n  /// a null matcher.\n  static VariantMatcher constructBoundMatcher(MatcherCtor Ctor,\n                                              SourceRange NameRange,\n                                              StringRef BindID,\n                                              ArrayRef<ParserValue> Args,\n                                              Diagnostics *Error);\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21280",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/Dynamic/Registry.h",
  "source_line": 30,
  "validation_status": "validated"
}