{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// This class conforms to the C++ Standard \"Seed Sequence\" concept\n// [rand.req.seedseq].\n//\n// A `SaltedSeedSeq` is meant to wrap an existing seed sequence and modify\n// generated sequence by mixing with extra entropy. This entropy may be\n// build-dependent or process-dependent. The implementation may change to be\n// have either or both kinds of entropy. If salt is not available sequence is\n// not modified.\ntemplate <typename SSeq>\nclass SaltedSeedSeq {\n public:\n  using inner_sequence_type = SSeq;\n  using result_type = typename SSeq::result_type;\n\n  SaltedSeedSeq() : seq_(absl::make_unique<SSeq>()) {}\n\n  template <typename Iterator>\n  SaltedSeedSeq(Iterator begin, Iterator end)\n      : seq_(absl::make_unique<SSeq>(begin, end)) {}\n\n  template <typename T>\n  SaltedSeedSeq(std::initializer_list<T> il)\n      : SaltedSeedSeq(il.begin(), il.end()) {}\n\n  SaltedSeedSeq(const SaltedSeedSeq&) = delete;\n  SaltedSeedSeq& operator=(const SaltedSeedSeq&) = delete;\n\n  SaltedSeedSeq(SaltedSeedSeq&&) = default;\n  SaltedSeedSeq& operator=(SaltedSeedSeq&&) = default;\n\n  template <typename RandomAccessIterator>\n  void generate(RandomAccessIterator begin, RandomAccessIterator end) {\n    using U = typename std::iterator_traits<RandomAccessIterator>::value_type;\n\n    // The common case is that generate is called with ContiguousIterators\n    // to uint arrays. Such contiguous memory regions may be optimized,\n    // which we detect here.\n    using TagType = absl::conditional_t<\n        (std::is_same<U, uint32_t>::value &&\n         (std::is_pointer<RandomAccessIterator>::value ||\n          std::is_same<RandomAccessIterator,\n                       typename std::vector<U>::iterator>::value)),\n        ContiguousAndUint32Tag, DefaultTag>;\n    if (begin != end) {\n      generate_impl(TagType{}, begin, end, std::distance(begin, end));\n    }\n  }\n\n  template <typename OutIterator>\n  void param(OutIterator out) const {\n    seq_->param(out);\n  }\n\n  size_t size() const { return seq_->size(); }\n\n private:\n  struct ContiguousAndUint32Tag {};\n  struct DefaultTag {};\n\n  // Generate which requires the iterators are contiguous pointers to uint32_t.\n  // Fills the initial seed buffer the underlying SSeq::generate() call,\n  // then mixes in the salt material.\n  template <typename Contiguous>\n  void generate_impl(ContiguousAndUint32Tag, Contiguous begin, Contiguous end,\n                     size_t n) {\n    seq_->generate(begin, end);\n    const uint32_t salt = absl::random_internal::GetSaltMaterial().value_or(0);\n    auto span = absl::Span<uint32_t>(&*begin, n);\n    MixIntoSeedMaterial(absl::MakeConstSpan(&salt, 1), span);\n  }\n\n  // The uncommon case for generate is that it is called with iterators over\n  // some other buffer type which is assignable from a 32-bit value. In this\n  // case we allocate a temporary 32-bit buffer and then copy-assign back\n  // to the initial inputs.\n  template <typename RandomAccessIterator>\n  void generate_impl(DefaultTag, RandomAccessIterator begin,\n                     RandomAccessIterator, size_t n) {\n    // Allocates a seed buffer of `n` elements, generates the seed, then\n    // copies the result into the `out` iterator.\n    absl::InlinedVector<uint32_t, 8> data(n, 0);\n    generate_impl(ContiguousAndUint32Tag{}, data.begin(), data.end(), n);\n    std::copy(data.begin(), data.end(), begin);\n  }\n\n  // Because [rand.req.seedseq] is not required to be copy-constructible,\n  // copy-assignable nor movable, we wrap it with unique pointer to be able\n  // to move SaltedSeedSeq.\n  std::unique_ptr<SSeq> seq_;\n};\n\n// is_salted_seed_seq indicates whether the type is a SaltedSeedSeq.\ntemplate <typename T, typename = void>\nstruct is_salted_seed_seq : public std::false_type {};\n\ntemplate <typename T>\nstruct is_salted_seed_seq<\n    T, typename std::enable_if<std::is_same<\n           T, SaltedSeedSeq<typename T::inner_sequence_type>>::value>::type>\n    : public std::true_type {};\n\n// MakeSaltedSeedSeq returns a salted variant of the seed sequence.\n// When provided with an existing SaltedSeedSeq, returns the input parameter,\n// otherwise constructs a new SaltedSeedSeq which embodies the original\n// non-salted seed parameters.\ntemplate <\n    typename SSeq,  //\n    typename EnableIf = absl::enable_if_t<is_salted_seed_seq<SSeq>::value>>\nSSeq MakeSaltedSeedSeq(SSeq&& seq) {\n  return SSeq(std::forward<SSeq>(seq));\n}\n\ntemplate <\n    typename SSeq,  //\n    typename EnableIf = absl::enable_if_t<!is_salted_seed_seq<SSeq>::value>>\nSaltedSeedSeq<typename std::decay<SSeq>::type> MakeSaltedSeedSeq(SSeq&& seq) {\n  using sseq_type = typename std::decay<SSeq>::type;\n  using result_type = typename sseq_type::result_type;\n\n  absl::InlinedVector<result_type, 8> data;\n  seq.param(std::back_inserter(data));\n  return SaltedSeedSeq<sseq_type>(data.begin(), data.end());\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05966",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/salted_seed_seq.h",
  "source_line": 33,
  "validation_status": "validated"
}