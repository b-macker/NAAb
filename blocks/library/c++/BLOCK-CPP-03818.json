{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\ntemplate <typename URBG, typename = void, typename = void, typename = void>\nstruct is_urbg : std::false_type {};\n\ntemplate <typename URBG>\nstruct is_urbg<\n    URBG,\n    absl::enable_if_t<std::is_same<\n        typename URBG::result_type,\n        typename std::decay<decltype((URBG::min)())>::type>::value>,\n    absl::enable_if_t<std::is_same<\n        typename URBG::result_type,\n        typename std::decay<decltype((URBG::max)())>::type>::value>,\n    absl::enable_if_t<std::is_same<\n        typename URBG::result_type,\n        typename std::decay<decltype(std::declval<URBG>()())>::type>::value>>\n    : std::true_type {};\n\ntemplate <typename>\nstruct DistributionCaller;\nclass MockHelpers;\n\n}  // namespace random_internal\n\n// -----------------------------------------------------------------------------\n// absl::BitGenRef\n// -----------------------------------------------------------------------------\n//\n// `absl::BitGenRef` is a type-erasing class that provides a generator-agnostic\n// non-owning \"reference\" interface for use in place of any specific uniform\n// random bit generator (URBG). This class may be used for both Abseil\n// (e.g. `absl::BitGen`, `absl::InsecureBitGen`) and Standard library (e.g\n// `std::mt19937`, `std::minstd_rand`) bit generators.\n//\n// Like other reference classes, `absl::BitGenRef` does not own the\n// underlying bit generator, and the underlying instance must outlive the\n// `absl::BitGenRef`.\n//\n// `absl::BitGenRef` is particularly useful when used with an\n// `absl::MockingBitGen` to test specific paths in functions which use random\n// values.\n//\n// Example:\n//    void TakesBitGenRef(absl::BitGenRef gen) {\n//      int x = absl::Uniform<int>(gen, 0, 1000);\n//    }\n//\nclass BitGenRef {\n  // SFINAE to detect whether the URBG type includes a member matching\n  // bool InvokeMock(base_internal::FastTypeIdType, void*, void*).\n  //\n  // These live inside BitGenRef so that they have friend access\n  // to MockingBitGen. (see similar methods in DistributionCaller).\n  template <template <class...> class Trait, class AlwaysVoid, class... Args>\n  struct detector : std::false_type {};\n  template <template <class...> class Trait, class... Args>\n  struct detector<Trait, absl::void_t<Trait<Args...>>, Args...>\n      : std::true_type {};\n\n  template <class T>\n  using invoke_mock_t = decltype(std::declval<T*>()->InvokeMock(\n      std::declval<base_internal::FastTypeIdType>(), std::declval<void*>(),\n      std::declval<void*>()));\n\n  template <typename T>\n  using HasInvokeMock = typename detector<invoke_mock_t, void, T>::type;\n\n public:\n  BitGenRef(const BitGenRef&) = default;\n  BitGenRef(BitGenRef&&) = default;\n  BitGenRef& operator=(const BitGenRef&) = default;\n  BitGenRef& operator=(BitGenRef&&) = default;\n\n  template <typename URBG, typename absl::enable_if_t<\n                               (!std::is_same<URBG, BitGenRef>::value &&\n                                random_internal::is_urbg<URBG>::value &&\n                                !HasInvokeMock<URBG>::value)>* = nullptr>\n  BitGenRef(URBG& gen)  // NOLINT\n      : t_erased_gen_ptr_(reinterpret_cast<uintptr_t>(&gen)),\n        mock_call_(NotAMock),\n        generate_impl_fn_(ImplFn<URBG>) {}\n\n  template <typename URBG,\n            typename absl::enable_if_t<(!std::is_same<URBG, BitGenRef>::value &&\n                                        random_internal::is_urbg<URBG>::value &&\n                                        HasInvokeMock<URBG>::value)>* = nullptr>\n  BitGenRef(URBG& gen)  // NOLINT\n      : t_erased_gen_ptr_(reinterpret_cast<uintptr_t>(&gen)),\n        mock_call_(&MockCall<URBG>),\n        generate_impl_fn_(ImplFn<URBG>) {}\n\n  using result_type = uint64_t;\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  result_type operator()() { return generate_impl_fn_(t_erased_gen_ptr_); }\n\n private:\n  using impl_fn = result_type (*)(uintptr_t);\n  using mock_call_fn = bool (*)(uintptr_t, base_internal::FastTypeIdType, void*,\n                                void*);\n\n  template <typename URBG>\n  static result_type ImplFn(uintptr_t ptr) {\n    // Ensure that the return values from operator() fill the entire\n    // range promised by result_type, min() and max().\n    absl::random_internal::FastUniformBits<result_type> fast_uniform_bits;\n    return fast_uniform_bits(*reinterpret_cast<URBG*>(ptr));\n  }\n\n  // Get a type-erased InvokeMock pointer.\n  template <typename URBG>\n  static bool MockCall(uintptr_t gen_ptr, base_internal::FastTypeIdType type,\n                       void* result, void* arg_tuple) {\n    return reinterpret_cast<URBG*>(gen_ptr)->InvokeMock(type, result,\n                                                        arg_tuple);\n  }\n  static bool NotAMock(uintptr_t, base_internal::FastTypeIdType, void*, void*) {\n    return false;\n  }\n\n  inline bool InvokeMock(base_internal::FastTypeIdType type, void* args_tuple,\n                         void* result) {\n    if (mock_call_ == NotAMock) return false;  // avoids an indirect call.\n    return mock_call_(t_erased_gen_ptr_, type, args_tuple, result);\n  }\n\n  uintptr_t t_erased_gen_ptr_;\n  mock_call_fn mock_call_;\n  impl_fn generate_impl_fn_;\n\n  template <typename>\n  friend struct ::absl::random_internal::DistributionCaller;  // for InvokeMock\n  friend class ::absl::random_internal::MockHelpers;          // for InvokeMock\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03818",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/bit_gen_ref.h",
  "source_line": 37,
  "validation_status": "validated"
}