{
  "code": "{\n\n// Defines how slots are initialized/destroyed/moved.\ntemplate <class Policy, class = void>\nstruct hash_policy_traits : common_policy_traits<Policy> {\n  // The type of the keys stored in the hashtable.\n  using key_type = typename Policy::key_type;\n\n private:\n  struct ReturnKey {\n    // When C++17 is available, we can use std::launder to provide mutable\n    // access to the key for use in node handle.\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n    template <class Key,\n              absl::enable_if_t<std::is_lvalue_reference<Key>::value, int> = 0>\n    static key_type& Impl(Key&& k, int) {\n      return *std::launder(\n          const_cast<key_type*>(std::addressof(std::forward<Key>(k))));\n    }\n#endif\n\n    template <class Key>\n    static Key Impl(Key&& k, char) {\n      return std::forward<Key>(k);\n    }\n\n    // When Key=T&, we forward the lvalue reference.\n    // When Key=T, we return by value to avoid a dangling reference.\n    // eg, for string_hash_map.\n    template <class Key, class... Args>\n    auto operator()(Key&& k, const Args&...) const\n        -> decltype(Impl(std::forward<Key>(k), 0)) {\n      return Impl(std::forward<Key>(k), 0);\n    }\n  };\n\n  template <class P = Policy, class = void>\n  struct ConstantIteratorsImpl : std::false_type {};\n\n  template <class P>\n  struct ConstantIteratorsImpl<P, absl::void_t<typename P::constant_iterators>>\n      : P::constant_iterators {};\n\n public:\n  // The actual object stored in the hash table.\n  using slot_type = typename Policy::slot_type;\n\n  // The argument type for insertions into the hashtable. This is different\n  // from value_type for increased performance. See initializer_list constructor\n  // and insert() member functions for more details.\n  using init_type = typename Policy::init_type;\n\n  using reference = decltype(Policy::element(std::declval<slot_type*>()));\n  using pointer = typename std::remove_reference<reference>::type*;\n  using value_type = typename std::remove_reference<reference>::type;\n\n  // Policies can set this variable to tell raw_hash_set that all iterators\n  // should be constant, even `iterator`. This is useful for set-like\n  // containers.\n  // Defaults to false if not provided by the policy.\n  using constant_iterators = ConstantIteratorsImpl<>;\n\n  // Returns the amount of memory owned by `slot`, exclusive of `sizeof(*slot)`.\n  //\n  // If `slot` is nullptr, returns the constant amount of memory owned by any\n  // full slot or -1 if slots own variable amounts of memory.\n  //\n  // PRECONDITION: `slot` is INITIALIZED or nullptr\n  template <class P = Policy>\n  static size_t space_used(const slot_type* slot) {\n    return P::space_used(slot);\n  }\n\n  // Provides generalized access to the key for elements, both for elements in\n  // the table and for elements that have not yet been inserted (or even\n  // constructed).  We would like an API that allows us to say: `key(args...)`\n  // but we cannot do that for all cases, so we use this more general API that\n  // can be used for many things, including the following:\n  //\n  //   - Given an element in a table, get its key.\n  //   - Given an element initializer, get its key.\n  //   - Given `emplace()` arguments, get the element key.\n  //\n  // Implementations of this must adhere to a very strict technical\n  // specification around aliasing and consuming arguments:\n  //\n  // Let `value_type` be the result type of `element()` without ref- and\n  // cv-qualifiers. The first argument is a functor, the rest are constructor\n  // arguments for `value_type`. Returns `std::forward<F>(f)(k, xs...)`, where\n  // `k` is the element key, and `xs...` are the new constructor arguments for\n  // `value_type`. It's allowed for `k` to alias `xs...`, and for both to alias\n  // `ts...`. The key won't be touched once `xs...` are used to construct an\n  // element; `ts...` won't be touched at all, which allows `apply()` to consume\n  // any rvalues among them.\n  //\n  // If `value_type` is constructible from `Ts&&...`, `Policy::apply()` must not\n  // trigger a hard compile error unless it originates from `f`. In other words,\n  // `Policy::apply()` must be SFINAE-friendly. If `value_type` is not\n  // constructible from `Ts&&...`, either SFINAE or a hard compile error is OK.\n  //\n  // If `Ts...` is `[cv] value_type[&]` or `[cv] init_type[&]`,\n  // `Policy::apply()` must work. A compile error is not allowed, SFINAE or not.\n  template <class F, class... Ts, class P = Policy>\n  static auto apply(F&& f, Ts&&... ts)\n      -> decltype(P::apply(std::forward<F>(f), std::forward<Ts>(ts)...)) {\n    return P::apply(std::forward<F>(f), std::forward<Ts>(ts)...);\n  }\n\n  // Returns the \"key\" portion of the slot.\n  // Used for node handle manipulation.\n  template <class P = Policy>\n  static auto mutable_key(slot_type* slot)\n      -> decltype(P::apply(ReturnKey(), hash_policy_traits::element(slot))) {\n    return P::apply(ReturnKey(), hash_policy_traits::element(slot));\n  }\n\n  // Returns the \"value\" (as opposed to the \"key\") portion of the element. Used\n  // by maps to implement `operator[]`, `at()` and `insert_or_assign()`.\n  template <class T, class P = Policy>\n  static auto value(T* elem) -> decltype(P::value(elem)) {\n    return P::value(elem);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-05002",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/hash_policy_traits.h",
  "source_line": 29,
  "validation_status": "validated"
}