{
  "code": "{\n  friend class ASTStmtReader;\n\n  /// Points to the operator delete overload that is used. Could be a member.\n  FunctionDecl *OperatorDelete = nullptr;\n\n  /// The pointer expression to be deleted.\n  Stmt *Argument = nullptr;\n\npublic:\n  CXXDeleteExpr(QualType Ty, bool GlobalDelete, bool ArrayForm,\n                bool ArrayFormAsWritten, bool UsualArrayDeleteWantsSize,\n                FunctionDecl *OperatorDelete, Expr *Arg, SourceLocation Loc)\n      : Expr(CXXDeleteExprClass, Ty, VK_PRValue, OK_Ordinary),\n        OperatorDelete(OperatorDelete), Argument(Arg) {\n    CXXDeleteExprBits.GlobalDelete = GlobalDelete;\n    CXXDeleteExprBits.ArrayForm = ArrayForm;\n    CXXDeleteExprBits.ArrayFormAsWritten = ArrayFormAsWritten;\n    CXXDeleteExprBits.UsualArrayDeleteWantsSize = UsualArrayDeleteWantsSize;\n    CXXDeleteExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  explicit CXXDeleteExpr(EmptyShell Shell) : Expr(CXXDeleteExprClass, Shell) {}\n\n  bool isGlobalDelete() const { return CXXDeleteExprBits.GlobalDelete; }\n  bool isArrayForm() const { return CXXDeleteExprBits.ArrayForm; }\n  bool isArrayFormAsWritten() const {\n    return CXXDeleteExprBits.ArrayFormAsWritten;\n  }\n\n  /// Answers whether the usual array deallocation function for the\n  /// allocated type expects the size of the allocation as a\n  /// parameter.  This can be true even if the actual deallocation\n  /// function that we're using doesn't want a size.\n  bool doesUsualArrayDeleteWantSize() const {\n    return CXXDeleteExprBits.UsualArrayDeleteWantsSize;\n  }\n\n  FunctionDecl *getOperatorDelete() const { return OperatorDelete; }\n\n  Expr *getArgument() { return cast<Expr>(Argument); }\n  const Expr *getArgument() const { return cast<Expr>(Argument); }\n\n  /// Retrieve the type being destroyed.\n  ///\n  /// If the type being destroyed is a dependent type which may or may not\n  /// be a pointer, return an invalid type.\n  QualType getDestroyedType() const;\n\n  SourceLocation getBeginLoc() const { return CXXDeleteExprBits.Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Argument->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDeleteExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Argument, &Argument + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Argument, &Argument + 1);\n  }\n}",
  "id": "BLOCK-CPP-10790",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 2481,
  "validation_status": "validated"
}