{
  "code": "{\n\n  //===--------------------------------------------------------------------===//\n  // RopeRefCountString Class\n  //===--------------------------------------------------------------------===//\n\n  /// RopeRefCountString - This struct is allocated with 'new char[]' from the\n  /// heap, and represents a reference counted chunk of string data.  When its\n  /// ref count drops to zero, it is delete[]'d.  This is primarily managed\n  /// through the RopePiece class below.\n  struct RopeRefCountString {\n    unsigned RefCount;\n    char Data[1];  //  Variable sized.\n\n    void Retain() { ++RefCount; }\n\n    void Release() {\n      assert(RefCount > 0 && \"Reference count is already zero.\");\n      if (--RefCount == 0)\n        delete [] (char*)this;\n    }\n  };\n\n  //===--------------------------------------------------------------------===//\n  // RopePiece Class\n  //===--------------------------------------------------------------------===//\n\n  /// RopePiece - This class represents a view into a RopeRefCountString object.\n  /// This allows references to string data to be efficiently chopped up and\n  /// moved around without having to push around the string data itself.\n  ///\n  /// For example, we could have a 1M RopePiece and want to insert something\n  /// into the middle of it.  To do this, we split it into two RopePiece objects\n  /// that both refer to the same underlying RopeRefCountString (just with\n  /// different offsets) which is a nice constant time operation.\n  struct RopePiece {\n    llvm::IntrusiveRefCntPtr<RopeRefCountString> StrData;\n    unsigned StartOffs = 0;\n    unsigned EndOffs = 0;\n\n    RopePiece() = default;\n    RopePiece(llvm::IntrusiveRefCntPtr<RopeRefCountString> Str, unsigned Start,\n              unsigned End)\n        : StrData(std::move(Str)), StartOffs(Start), EndOffs(End) {}\n\n    const char &operator[](unsigned Offset) const {\n      return StrData->Data[Offset+StartOffs];\n    }\n    char &operator[](unsigned Offset) {\n      return StrData->Data[Offset+StartOffs];\n    }\n\n    unsigned size() const { return EndOffs-StartOffs; }\n  };\n\n  //===--------------------------------------------------------------------===//\n  // RopePieceBTreeIterator Class\n  //===--------------------------------------------------------------------===//\n\n  /// RopePieceBTreeIterator - This class provides read-only forward iteration\n  /// over bytes that are in a RopePieceBTree.  This first iterates over bytes\n  /// in a RopePiece, then iterates over RopePiece's in a RopePieceBTreeLeaf,\n  /// then iterates over RopePieceBTreeLeaf's in a RopePieceBTree.\n  class RopePieceBTreeIterator {\n    /// CurNode - The current B+Tree node that we are inspecting.\n    const void /*RopePieceBTreeLeaf*/ *CurNode = nullptr;\n\n    /// CurPiece - The current RopePiece in the B+Tree node that we're\n    /// inspecting.\n    const RopePiece *CurPiece = nullptr;\n\n    /// CurChar - The current byte in the RopePiece we are pointing to.\n    unsigned CurChar = 0;\n\n  public:\n    using iterator_category = std::forward_iterator_tag;\n    using value_type = const char;\n    using difference_type = std::ptrdiff_t;\n    using pointer = value_type *;\n    using reference = value_type &;\n\n    RopePieceBTreeIterator() = default;\n    RopePieceBTreeIterator(const void /*RopePieceBTreeNode*/ *N);\n\n    char operator*() const {\n      return (*CurPiece)[CurChar];\n    }\n\n    bool operator==(const RopePieceBTreeIterator &RHS) const {\n      return CurPiece == RHS.CurPiece && CurChar == RHS.CurChar;\n    }\n    bool operator!=(const RopePieceBTreeIterator &RHS) const {\n      return !operator==(RHS);\n    }\n\n    RopePieceBTreeIterator& operator++() {   // Preincrement\n      if (CurChar+1 < CurPiece->size())\n        ++CurChar;\n      else\n        MoveToNextPiece();\n      return *this;\n    }\n\n    RopePieceBTreeIterator operator++(int) { // Postincrement\n      RopePieceBTreeIterator tmp = *this; ++*this; return tmp;\n    }\n\n    llvm::StringRef piece() const {\n      return llvm::StringRef(&(*CurPiece)[0], CurPiece->size());\n    }\n\n    void MoveToNextPiece();\n  };\n\n  //===--------------------------------------------------------------------===//\n  // RopePieceBTree Class\n  //===--------------------------------------------------------------------===//\n\n  class RopePieceBTree {\n    void /*RopePieceBTreeNode*/ *Root;\n\n  public:\n    RopePieceBTree();\n    RopePieceBTree(const RopePieceBTree &RHS);\n    RopePieceBTree &operator=(const RopePieceBTree &) = delete;\n    ~RopePieceBTree();\n\n    using iterator = RopePieceBTreeIterator;\n\n    iterator begin() const { return iterator(Root); }\n    iterator end() const { return iterator(); }\n    unsigned size() const;\n    unsigned empty() const { return size() == 0; }\n\n    void clear();\n\n    void insert(unsigned Offset, const RopePiece &R);\n\n    void erase(unsigned Offset, unsigned NumBytes);\n  };\n\n  //===--------------------------------------------------------------------===//\n  // RewriteRope Class\n  //===--------------------------------------------------------------------===//\n\n/// RewriteRope - A powerful string class.  This class supports extremely\n/// efficient insertions and deletions into the middle of it, even for\n/// ridiculously long strings.\nclass RewriteRope {\n  RopePieceBTree Chunks;\n\n  /// We allocate space for string data out of a buffer of size AllocChunkSize.\n  /// This keeps track of how much space is left.\n  llvm::IntrusiveRefCntPtr<RopeRefCountString> AllocBuffer;\n  enum { AllocChunkSize = 4080 };\n  unsigned AllocOffs = AllocChunkSize;\n\npublic:\n  RewriteRope() = default;\n  RewriteRope(const RewriteRope &RHS) : Chunks(RHS.Chunks) {}\n\n  // The copy assignment operator is defined as deleted pending further\n  // motivation.\n  RewriteRope &operator=(const RewriteRope &) = delete;\n\n  using iterator = RopePieceBTree::iterator;\n  using const_iterator = RopePieceBTree::iterator;\n\n  iterator begin() const { return Chunks.begin(); }\n  iterator end() const { return Chunks.end(); }\n  unsigned size() const { return Chunks.size(); }\n\n  void clear() {\n    Chunks.clear();\n  }\n\n  void assign(const char *Start, const char *End) {\n    clear();\n    if (Start != End)\n      Chunks.insert(0, MakeRopeString(Start, End));\n  }\n\n  void insert(unsigned Offset, const char *Start, const char *End) {\n    assert(Offset <= size() && \"Invalid position to insert!\");\n    if (Start == End) return;\n    Chunks.insert(Offset, MakeRopeString(Start, End));\n  }\n\n  void erase(unsigned Offset, unsigned NumBytes) {\n    assert(Offset+NumBytes <= size() && \"Invalid region to erase!\");\n    if (NumBytes == 0) return;\n    Chunks.erase(Offset, NumBytes);\n  }\n\nprivate:\n  RopePiece MakeRopeString(const char *Start, const char *End);\n};\n\n}",
  "id": "BLOCK-CPP-22148",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Rewrite/Core/RewriteRope.h",
  "source_line": 23,
  "validation_status": "validated"
}