{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\nnamespace {\n\nconst char* StrErrorAdaptor(int errnum, char* buf, size_t buflen) {\n#if defined(_WIN32)\n  int rc = strerror_s(buf, buflen, errnum);\n  buf[buflen - 1] = '\\0';  // guarantee NUL termination\n  if (rc == 0 && strncmp(buf, \"Unknown error\", buflen) == 0) *buf = '\\0';\n  return buf;\n#else\n  // The type of `ret` is platform-specific; both of these branches must compile\n  // either way but only one will execute on any given platform:\n  auto ret = strerror_r(errnum, buf, buflen);\n  if (std::is_same<decltype(ret), int>::value) {\n    // XSI `strerror_r`; `ret` is `int`:\n    if (ret) *buf = '\\0';\n    return buf;\n  } else {\n    // GNU `strerror_r`; `ret` is `char *`:\n    return reinterpret_cast<const char*>(ret);\n  }\n#endif\n}\n\nstd::string StrErrorInternal(int errnum) {\n  char buf[100];\n  const char* str = StrErrorAdaptor(errnum, buf, sizeof buf);\n  if (*str == '\\0') {\n    snprintf(buf, sizeof buf, \"Unknown error %d\", errnum);\n    str = buf;\n  }\n  return str;\n}\n\n// kSysNerr is the number of errors from a recent glibc. `StrError()` falls back\n// to `StrErrorAdaptor()` if the value is larger than this.\nconstexpr int kSysNerr = 135;\n\nstd::array<std::string, kSysNerr>* NewStrErrorTable() {\n  auto* table = new std::array<std::string, kSysNerr>;\n  for (size_t i = 0; i < table->size(); ++i) {\n    (*table)[i] = StrErrorInternal(static_cast<int>(i));\n  }\n  return table;\n}\n\n}  // namespace\n\nstd::string StrError(int errnum) {\n  absl::base_internal::ErrnoSaver errno_saver;\n  static const auto* table = NewStrErrorTable();\n  if (errnum >= 0 && static_cast<size_t>(errnum) < table->size()) {\n    return (*table)[static_cast<size_t>(errnum)];\n  }\n  return StrErrorInternal(errnum);\n}\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02341",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/strerror.cc",
  "source_line": 27,
  "validation_status": "validated"
}