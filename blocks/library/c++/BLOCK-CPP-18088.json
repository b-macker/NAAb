{
  "code": "{                              int f() {\n  ///      int = 1;                                 int i = 1;\n  ///                                               i = foo();\n  ///      i = foo();                               return i;\n  ///                                           }\n  ///      return i;\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned MaxEmptyLinesToKeep;\n\n  /// Different ways to indent namespace contents.\n  enum NamespaceIndentationKind : int8_t {\n    /// Don't indent in namespaces.\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///    int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_None,\n    /// Indent only in inner namespaces (nested in other namespaces).\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///      int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_Inner,\n    /// Indent in all namespaces.\n    /// \\code\n    ///    namespace out {\n    ///      int i;\n    ///      namespace in {\n    ///        int i;\n    ///      }\n    ///    }\n    /// \\endcode\n    NI_All\n  };\n\n  /// The indentation used for namespaces.\n  /// \\version 3.7\n  NamespaceIndentationKind NamespaceIndentation;\n\n  /// A vector of macros which are used to open namespace blocks.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   NAMESPACE(<namespace-name>, ...) {\n  ///     <namespace-content>\n  ///   }\n  /// \\endcode\n  ///\n  /// For example: TESTSUITE\n  /// \\version 9\n  std::vector<std::string> NamespaceMacros;\n\n  /// Controls bin-packing Objective-C protocol conformance list\n  /// items into as few lines as possible when they go over ``ColumnLimit``.\n  ///\n  /// If ``Auto`` (the default), delegates to the value in\n  /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  /// protocol conformance list items into as few lines as possible\n  /// whenever they go over ``ColumnLimit``.\n  ///\n  /// If ``Always``, always bin-packs Objective-C protocol conformance\n  /// list items into as few lines as possible whenever they go over\n  /// ``ColumnLimit``.\n  ///\n  /// If ``Never``, lays out Objective-C protocol conformance list items\n  /// onto individual lines whenever they go over ``ColumnLimit``.\n  ///\n  /// \\code{.objc}\n  ///    Always (or Auto, if BinPackParameters=true):\n  ///    @interface ccccccccccccc () <\n  ///        ccccccccccccc, ccccccccccccc,\n  ///        ccccccccccccc, ccccccccccccc> {\n  ///    }\n  ///\n  ///    Never (or Auto, if BinPackParameters=false):\n  ///    @interface ddddddddddddd () <\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd> {\n  ///    }\n  /// \\endcode\n  /// \\version 7\n  BinPackStyle ObjCBinPackProtocolList;\n\n  /// The number of characters to use for indentation of ObjC blocks.\n  /// \\code{.objc}\n  ///    ObjCBlockIndentWidth: 4\n  ///\n  ///    [operation setCompletionBlock:^{\n  ///        [self onOperationDone];\n  ///    }];\n  /// \\endcode\n  /// \\version 3.7\n  unsigned ObjCBlockIndentWidth;\n\n  /// Break parameters list into lines when there is nested block\n  /// parameters in a function call.\n  /// \\code\n  ///   false:\n  ///    - (void)_aMethod\n  ///    {\n  ///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n  ///        *u, NSNumber *v) {\n  ///            u = c;\n  ///        }]\n  ///    }\n  ///    true:\n  ///    - (void)_aMethod\n  ///    {\n  ///       [self.test1 t:self\n  ///                    w:self\n  ///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n  ///                u = c;\n  ///            }]\n  ///    }\n  /// \\endcode\n  /// \\version 11\n  bool ObjCBreakBeforeNestedBlockParam;\n\n  /// Add a space after ``@property`` in Objective-C, i.e. use\n  /// ``@property (readonly)`` instead of ``@property(readonly)``.\n  /// \\version 3.7\n  bool ObjCSpaceAfterProperty;\n\n  /// Add a space in front of an Objective-C protocol list, i.e. use\n  /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n  /// \\version 3.7\n  bool ObjCSpaceBeforeProtocolList;\n\n  /// Different ways to try to fit all constructor initializers on a line.\n  enum PackConstructorInitializersStyle : int8_t {\n    /// Always put each constructor initializer on its own line.\n    /// \\code\n    ///    Constructor()\n    ///        : a(),\n    ///          b()\n    /// \\endcode\n    PCIS_Never,\n    /// Bin-pack constructor initializers.\n    /// \\code\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_BinPack,\n    /// Put all constructor initializers on the current line if they fit.\n    /// Otherwise, put each one on its own line.\n    /// \\code\n    ///    Constructor() : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          ddddddddddddd()\n    /// \\endcode\n    PCIS_CurrentLine,\n    /// Same as ``PCIS_CurrentLine`` except that if all constructor initializers\n    /// do not fit on the current line, try to fit them on the next line.\n    /// \\code\n    ///    Constructor() : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_NextLine,\n    /// Put all constructor initializers on the next line if they fit.\n    /// Otherwise, put each one on its own line.\n    /// \\code\n    ///    Constructor()\n    ///        : a(), b()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()\n    ///\n    ///    Constructor()\n    ///        : aaaaaaaaaaaaaaaaaaaa(),\n    ///          bbbbbbbbbbbbbbbbbbbb(),\n    ///          cccccccccccccccccccc()\n    /// \\endcode\n    PCIS_NextLineOnly,\n  };\n\n  /// The pack constructor initializers style to use.\n  /// \\version 14\n  PackConstructorInitializersStyle PackConstructorInitializers;\n\n  /// The penalty for breaking around an assignment operator.\n  /// \\version 5\n  unsigned PenaltyBreakAssignment;\n\n  /// The penalty for breaking a function call after ``call(``.\n  /// \\version 3.7\n  unsigned PenaltyBreakBeforeFirstCallParameter;\n\n  /// The penalty for each line break introduced inside a comment.\n  /// \\version 3.7\n  unsigned PenaltyBreakComment;\n\n  /// The penalty for breaking before the first ``<<``.\n  /// \\version 3.7\n  unsigned PenaltyBreakFirstLessLess;\n\n  /// The penalty for breaking after ``(``.\n  /// \\version 14\n  unsigned PenaltyBreakOpenParenthesis;\n\n  /// The penalty for each line break introduced inside a string literal.\n  /// \\version 3.7\n  unsigned PenaltyBreakString;\n\n  /// The penalty for breaking after template declaration.\n  /// \\version 7\n  unsigned PenaltyBreakTemplateDeclaration;\n\n  /// The penalty for each character outside of the column limit.\n  /// \\version 3.7\n  unsigned PenaltyExcessCharacter;\n\n  /// Penalty for each character of whitespace indentation\n  /// (counted relative to leading non-whitespace column).\n  /// \\version 12\n  unsigned PenaltyIndentedWhitespace;\n\n  /// Penalty for putting the return type of a function onto its own line.\n  /// \\version 3.7\n  unsigned PenaltyReturnTypeOnItsOwnLine;\n\n  /// The ``&``, ``&&`` and ``*`` alignment style.\n  enum PointerAlignmentStyle : int8_t {\n    /// Align pointer to the left.\n    /// \\code\n    ///   int* a;\n    /// \\endcode\n    PAS_Left,\n    /// Align pointer to the right.\n    /// \\code\n    ///   int *a;\n    /// \\endcode\n    PAS_Right,\n    /// Align pointer in the middle.\n    /// \\code\n    ///   int * a;\n    /// \\endcode\n    PAS_Middle\n  };\n\n  /// Pointer and reference alignment style.\n  /// \\version 3.7\n  PointerAlignmentStyle PointerAlignment;\n\n  /// The number of columns to use for indentation of preprocessor statements.\n  /// When set to -1 (default) ``IndentWidth`` is used also for preprocessor\n  /// statements.\n  /// \\code\n  ///    PPIndentWidth: 1\n  ///\n  ///    #ifdef __linux__\n  ///    # define FOO\n  ///    #else\n  ///    # define BAR\n  ///    #endif\n  /// \\endcode\n  /// \\version 13\n  int PPIndentWidth;\n\n  /// Different specifiers and qualifiers alignment styles.\n  enum QualifierAlignmentStyle : int8_t {\n    /// Don't change specifiers/qualifiers to either Left or Right alignment\n    /// (default).\n    /// \\code\n    ///    int const a;\n    ///    const int *a;\n    /// \\endcode\n    QAS_Leave,\n    /// Change specifiers/qualifiers to be left-aligned.\n    /// \\code\n    ///    const int a;\n    ///    const int *a;\n    /// \\endcode\n    QAS_Left,\n    /// Change specifiers/qualifiers to be right-aligned.\n    /// \\code\n    ///    int const a;\n    ///    int const *a;\n    /// \\endcode\n    QAS_Right,\n    /// Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.\n    /// With:\n    /// \\code{.yaml}\n    ///   QualifierOrder: ['inline', 'static', 'type', 'const']\n    /// \\endcode\n    ///\n    /// \\code\n    ///\n    ///    int const a;\n    ///    int const *a;\n    /// \\endcode\n    QAS_Custom\n  };\n\n  /// Different ways to arrange specifiers and qualifiers (e.g. const/volatile).\n  /// \\warning\n  ///  Setting ``QualifierAlignment``  to something other than ``Leave``, COULD\n  ///  lead to incorrect code formatting due to incorrect decisions made due to\n  ///  clang-formats lack of complete semantic information.\n  ///  As such extra care should be taken to review code changes made by the use\n  ///  of this option.\n  /// \\endwarning\n  /// \\version 14\n  QualifierAlignmentStyle QualifierAlignment;\n\n  /// The order in which the qualifiers appear.\n  /// Order is an array that can contain any of the following:\n  ///\n  ///   * const\n  ///   * inline\n  ///   * static\n  ///   * friend\n  ///   * constexpr\n  ///   * volatile\n  ///   * restrict\n  ///   * type\n  ///\n  /// \\note\n  ///  it MUST contain 'type'.\n  /// \\endnote\n  ///\n  /// Items to the left of 'type' will be placed to the left of the type and\n  /// aligned in the order supplied. Items to the right of 'type' will be\n  /// placed to the right of the type and aligned in the order supplied.\n  ///\n  /// \\code{.yaml}\n  ///   QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]\n  /// \\endcode\n  /// \\version 14\n  std::vector<std::string> QualifierOrder;\n\n  /// See documentation of ``RawStringFormats``.\n  struct RawStringFormat {\n    /// The language of this raw string.\n    LanguageKind Language;\n    /// A list of raw string delimiters that match this language.\n    std::vector<std::string> Delimiters;\n    /// A list of enclosing function names that match this language.\n    std::vector<std::string> EnclosingFunctions;\n    /// The canonical delimiter for this language.\n    std::string CanonicalDelimiter;\n    /// The style name on which this raw string format is based on.\n    /// If not specified, the raw string format is based on the style that this\n    /// format is based on.\n    std::string BasedOnStyle;\n    bool operator==(const RawStringFormat &Other) const {\n      return Language == Other.Language && Delimiters == Other.Delimiters &&\n             EnclosingFunctions == Other.EnclosingFunctions &&\n             CanonicalDelimiter == Other.CanonicalDelimiter &&\n             BasedOnStyle == Other.BasedOnStyle;\n    }\n  };\n\n  /// Defines hints for detecting supported languages code blocks in raw\n  /// strings.\n  ///\n  /// A raw string with a matching delimiter or a matching enclosing function\n  /// name will be reformatted assuming the specified language based on the\n  /// style for that language defined in the .clang-format file. If no style has\n  /// been defined in the .clang-format file for the specific language, a\n  /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  /// found, the formatting is based on llvm style. A matching delimiter takes\n  /// precedence over a matching enclosing function name for determining the\n  /// language of the raw string contents.\n  ///\n  /// If a canonical delimiter is specified, occurrences of other delimiters for\n  /// the same language will be updated to the canonical if possible.\n  ///\n  /// There should be at most one specification per language and each delimiter\n  /// and enclosing function should not occur in multiple specifications.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   RawStringFormats:\n  ///     - Language: TextProto\n  ///         Delimiters:\n  ///           - 'pb'\n  ///           - 'proto'\n  ///         EnclosingFunctions:\n  ///           - 'PARSE_TEXT_PROTO'\n  ///         BasedOnStyle: google\n  ///     - Language: Cpp\n  ///         Delimiters:\n  ///           - 'cc'\n  ///           - 'cpp'\n  ///         BasedOnStyle: llvm\n  ///         CanonicalDelimiter: 'cc'\n  /// \\endcode\n  /// \\version 6\n  std::vector<RawStringFormat> RawStringFormats;\n\n  /// \\brief The ``&`` and ``&&`` alignment style.\n  enum ReferenceAlignmentStyle : int8_t {\n    /// Align reference like ``PointerAlignment``.\n    RAS_Pointer,\n    /// Align reference to the left.\n    /// \\code\n    ///   int& a;\n    /// \\endcode\n    RAS_Left,\n    /// Align reference to the right.\n    /// \\code\n    ///   int &a;\n    /// \\endcode\n    RAS_Right,\n    /// Align reference in the middle.\n    /// \\code\n    ///   int & a;\n    /// \\endcode\n    RAS_Middle\n  };\n\n  /// \\brief Reference alignment style (overrides ``PointerAlignment`` for\n  /// references).\n  /// \\version 13\n  ReferenceAlignmentStyle ReferenceAlignment;\n\n  // clang-format off\n  /// If ``true``, clang-format will attempt to re-flow comments. That is it\n  /// will touch a comment and *reflow* long comments into new lines, trying to\n  /// obey the ``ColumnLimit``.\n  /// \\code\n  ///    false:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n  ///\n  ///    true:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///    // information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///     * information */\n  /// \\endcode\n  /// \\version 3.8\n  bool ReflowComments;\n  // clang-format on\n\n  /// Remove optional braces of control statements (``if``, ``else``, ``for``,\n  /// and ``while``) in C++ according to the LLVM coding style.\n  /// \\warning\n  ///  This option will be renamed and expanded to support other styles.\n  /// \\endwarning\n  /// \\warning\n  ///  Setting this option to ``true`` could lead to incorrect code formatting\n  ///  due to clang-format's lack of complete semantic information. As such,\n  ///  extra care should be taken to review code changes made by this option.\n  /// \\endwarning\n  /// \\code\n  ///   false:                                     true:\n  ///\n  ///   if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n  ///     handleFunctionDecl(D);                     handleFunctionDecl(D);\n  ///   } else if (isa<VarDecl>(D)) {              else if (isa<VarDecl>(D))\n  ///     handleVarDecl(D);                          handleVarDecl(D);\n  ///   }\n  ///\n  ///   if (isa<VarDecl>(D)) {             vs.     if (isa<VarDecl>(D)) {\n  ///     for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n  ///       if (shouldProcessAttr(A)) {                if (shouldProcessAttr(A))\n  ///         handleAttr(A);                             handleAttr(A);\n  ///       }                                      }\n  ///     }\n  ///   }\n  ///\n  ///   if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n  ///     for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n  ///       handleAttr(A);                             handleAttr(A);\n  ///     }\n  ///   }\n  ///\n  ///   if (auto *D = (T)(D)) {            vs.     if (auto *D = (T)(D)) {\n  ///     if (shouldProcess(D)) {                    if (shouldProcess(D))\n  ///       handleVarDecl(D);                          handleVarDecl(D);\n  ///     } else {                                   else\n  ///       markAsIgnored(D);                          markAsIgnored(D);\n  ///     }                                        }\n  ///   }\n  ///\n  ///   if (a) {                           vs.     if (a)\n  ///     b();                                       b();\n  ///   } else {                                   else if (c)\n  ///     if (c) {                                   d();\n  ///       d();                                   else\n  ///     } else {                                   e();\n  ///       e();\n  ///     }\n  ///   }\n  /// \\endcode\n  /// \\version 14\n  bool RemoveBracesLLVM;\n\n  /// Types of redundant parentheses to remove.\n  enum RemoveParenthesesStyle : int8_t {\n    /// Do not remove parentheses.\n    /// \\code\n    ///   class __declspec((dllimport)) X {};\n    ///   co_return (((0)));\n    ///   return ((a + b) - ((c + d)));\n    /// \\endcode\n    RPS_Leave,\n    /// Replace multiple parentheses with single parentheses.\n    /// \\code\n    ///   class __declspec(dllimport) X {};\n    ///   co_return (0);\n    ///   return ((a + b) - (c + d));\n    /// \\endcode\n    RPS_MultipleParentheses,\n    /// Also remove parentheses enclosing the expression in a\n    /// ``return``/``co_return`` statement.\n    /// \\code\n    ///   class __declspec(dllimport) X {};\n    ///   co_return 0;\n    ///   return (a + b) - (c + d);\n    /// \\endcode\n    RPS_ReturnStatement,\n  };\n\n  /// Remove redundant parentheses.\n  /// \\warning\n  ///  Setting this option to any value other than ``Leave`` could lead to\n  ///  incorrect code formatting due to clang-format's lack of complete semantic\n  ///  information. As such, extra care should be taken to review code changes\n  ///  made by this option.\n  /// \\endwarning\n  /// \\version 17\n  RemoveParenthesesStyle RemoveParentheses;\n\n  /// Remove semicolons after the closing brace of a non-empty function.\n  /// \\warning\n  ///  Setting this option to ``true`` could lead to incorrect code formatting\n  ///  due to clang-format's lack of complete semantic information. As such,\n  ///  extra care should be taken to review code changes made by this option.\n  /// \\endwarning\n  /// \\code\n  ///   false:                                     true:\n  ///\n  ///   int max(int a, int b) {                    int max(int a, int b) {\n  ///     return a > b ? a : b;                      return a > b ? a : b;\n  ///   };                                         }\n  ///\n  /// \\endcode\n  /// \\version 16\n  bool RemoveSemicolon;\n\n  /// \\brief The possible positions for the requires clause. The\n  /// ``IndentRequires`` option is only used if the ``requires`` is put on the\n  /// start of a line.\n  enum RequiresClausePositionStyle : int8_t {\n    /// Always put the ``requires`` clause on its own line.\n    /// \\code\n    ///   template <typename T>\n    ///   requires C<T>\n    ///   struct Foo {...\n    ///\n    ///   template <typename T>\n    ///   requires C<T>\n    ///   void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t)\n    ///   requires C<T>\n    ///   {...\n    /// \\endcode\n    RCPS_OwnLine,\n    /// Try to put the clause together with the preceding part of a declaration.\n    /// For class templates: stick to the template declaration.\n    /// For function templates: stick to the template declaration.\n    /// For function declaration followed by a requires clause: stick to the\n    /// parameter list.\n    /// \\code\n    ///   template <typename T> requires C<T>\n    ///   struct Foo {...\n    ///\n    ///   template <typename T> requires C<T>\n    ///   void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t) requires C<T>\n    ///   {...\n    /// \\endcode\n    RCPS_WithPreceding,\n    /// Try to put the ``requires`` clause together with the class or function\n    /// declaration.\n    /// \\code\n    ///   template <typename T>\n    ///   requires C<T> struct Foo {...\n    ///\n    ///   template <typename T>\n    ///   requires C<T> void bar(T t) {...\n    ///\n    ///   template <typename T>\n    ///   void baz(T t)\n    ///   requires C<T> {...\n    /// \\endcode\n    RCPS_WithFollowing,\n    /// Try to put everything in the same line if possible. Otherwise normal\n    /// line breaking rules take over.\n    /// \\code\n    ///   // Fitting:\n    ///   template <typename T> requires C<T> struct Foo {...\n    ///\n    ///   template <typename T> requires C<T> void bar(T t) {...\n    ///\n    ///   template <typename T> void bar(T t) requires C<T> {...\n    ///\n    ///   // Not fitting, one possible example:\n    ///   template <typename LongName>\n    ///   requires C<LongName>\n    ///   struct Foo {...\n    ///\n    ///   template <typename LongName>\n    ///   requires C<LongName>\n    ///   void bar(LongName ln) {\n    ///\n    ///   template <typename LongName>\n    ///   void bar(LongName ln)\n    ///       requires C<LongName> {\n    /// \\endcode\n    RCPS_SingleLine,\n  };\n\n  /// \\brief The position of the ``requires`` clause.\n  /// \\version 15\n  RequiresClausePositionStyle RequiresClausePosition;\n\n  /// Indentation logic for requires expression bodies.\n  enum RequiresExpressionIndentationKind : int8_t {\n    /// Align requires expression body relative to the indentation level of the\n    /// outer scope the requires expression resides in.\n    /// This is the default.\n    /// \\code\n    ///    template <typename T>\n    ///    concept C = requires(T t) {\n    ///      ...\n    ///    }\n    /// \\endcode\n    REI_OuterScope,\n    /// Align requires expression body relative to the ``requires`` keyword.\n    /// \\code\n    ///    template <typename T>\n    ///    concept C = requires(T t) {\n    ///                  ...\n    ///                }\n    /// \\endcode\n    REI_Keyword,\n  };\n\n  /// The indentation used for requires expression bodies.\n  /// \\version 16\n  RequiresExpressionIndentationKind RequiresExpressionIndentation;\n\n  /// \\brief The style if definition blocks should be separated.\n  enum SeparateDefinitionStyle : int8_t {\n    /// Leave definition blocks as they are.\n    SDS_Leave,\n    /// Insert an empty line between definition blocks.\n    SDS_Always,\n    /// Remove any empty line between definition blocks.\n    SDS_Never\n  };\n\n  /// Specifies the use of empty lines to separate definition blocks, including\n  /// classes, structs, enums, and functions.\n  /// \\code\n  ///    Never                  v.s.     Always\n  ///    #include <cstring>              #include <cstring>\n  ///    struct Foo {\n  ///      int a, b, c;                  struct Foo {\n  ///    };                                int a, b, c;\n  ///    namespace Ns {                  };\n  ///    class Bar {\n  ///    public:                         namespace Ns {\n  ///      struct Foobar {               class Bar {\n  ///        int a;                      public:\n  ///        int b;                        struct Foobar {\n  ///      };                                int a;\n  ///    private:                            int b;\n  ///      int t;                          };\n  ///      int method1() {\n  ///        // ...                      private:\n  ///      }                               int t;\n  ///      enum List {\n  ///        ITEM1,                        int method1() {\n  ///        ITEM2                           // ...\n  ///      };                              }\n  ///      template<typename T>\n  ///      int method2(T x) {              enum List {\n  ///        // ...                          ITEM1,\n  ///      }                                 ITEM2\n  ///      int i, j, k;                    };\n  ///      int method3(int par) {\n  ///        // ...                        template<typename T>\n  ///      }                               int method2(T x) {\n  ///    };                                  // ...\n  ///    class C {};                       }\n  ///    }\n  ///                                      int i, j, k;\n  ///\n  ///                                      int method3(int par) {\n  ///                                        // ...\n  ///                                      }\n  ///                                    };\n  ///\n  ///                                    class C {};\n  ///                                    }\n  /// \\endcode\n  /// \\version 14\n  SeparateDefinitionStyle SeparateDefinitionBlocks;\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  /// \\version 13\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : int8_t {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// \\version 3.8\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : int8_t {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  /// \\version 12\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// Using declaration sorting options.\n  enum SortUsingDeclarationsOptions : int8_t {\n    /// Using declarations are never sorted.\n    /// \\code\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Never,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. Sort\n    /// the lists of names lexicographically, and within those groups, names are\n    /// in case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::chrono::duration_cast;\n    ///    using std::move;\n    ///    using std::string;\n    /// \\endcode\n    SUD_Lexicographic,\n    /// Using declarations are sorted in the order defined as follows:\n    /// Split the strings by \"::\" and discard any initial empty strings. The\n    /// last element of each list is a non-namespace name; all others are\n    /// namespace names. Sort the lists of names lexicographically, where the\n    /// sort order of individual names is that all non-namespace names come\n    /// before all namespace names, and within those groups, names are in\n    /// case-insensitive lexicographic order.\n    /// \\code\n    ///    using boost::regex;\n    ///    using boost::regex_constants::icase;\n    ///    using std::move;\n    ///    using std::string;\n    ///    using std::chrono::duration_cast;\n    /// \\endcode\n    SUD_LexicographicNumeric,\n  };\n\n  /// Controls if and how clang-format will sort using declarations.\n  /// \\version 5\n  SortUsingDeclarationsOptions SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  /// \\version 3.5\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  /// \\version 9\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  /// \\version 4\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : int8_t {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  /// \\version 12\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  /// \\version 3.7\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  /// \\version 12\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeInheritanceColon;\n\n  /// If ``true``, a space will be added before a JSON colon. For other\n  /// languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead.\n  /// \\code\n  ///    true:                                  false:\n  ///    {                                      {\n  ///      \"key\" : \"value\"              vs.       \"key\": \"value\"\n  ///    }                                      }\n  /// \\endcode\n  /// \\version 17\n  bool SpaceBeforeJsonColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensStyle : int8_t {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach and If macros. This is useful in projects where ForEach/If\n    /// macros are treated as function calls instead of control statements.\n    /// ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for\n    /// backward compatibility.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptControlMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always,\n    /// Configure each individual space before parentheses in\n    /// ``SpaceBeforeParensOptions``.\n    SBPO_Custom,\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  /// \\version 3.5\n  SpaceBeforeParensStyle SpaceBeforeParens;\n\n  /// Precise control over the spacing before parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  struct SpaceBeforeParensCustom {\n    /// If ``true``, put space betwee control statement keywords\n    /// (for/if/while...) and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    if (...) {}                     vs.    if(...) {}\n    /// \\endcode\n    bool AfterControlStatements;\n    /// If ``true``, put space between foreach macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    FOREACH (...)                   vs.    FOREACH(...)\n    ///      <loop-body>                            <loop-body>\n    /// \\endcode\n    bool AfterForeachMacros;\n    /// If ``true``, put a space between function declaration name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f ();                      vs.    void f();\n    /// \\endcode\n    bool AfterFunctionDeclarationName;\n    /// If ``true``, put a space between function definition name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f () {}                    vs.    void f() {}\n    /// \\endcode\n    bool AfterFunctionDefinitionName;\n    /// If ``true``, put space between if macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    IF (...)                        vs.    IF(...)\n    ///      <conditional-body>                     <conditional-body>\n    /// \\endcode\n    bool AfterIfMacros;\n    /// If ``true``, put a space between operator overloading and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void operator++ (int a);        vs.    void operator++(int a);\n    ///    object.operator++ (10);                object.operator++(10);\n    /// \\endcode\n    bool AfterOverloadedOperator;\n    /// If ``true``, put space between requires keyword in a requires clause and\n    /// opening parentheses, if there is one.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    requires (A<T> && B<T>)                requires(A<T> && B<T>)\n    ///    ...                                    ...\n    /// \\endcode\n    bool AfterRequiresInClause;\n    /// If ``true``, put space between requires keyword in a requires expression\n    /// and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    concept C = requires (T t) {           concept C = requires(T t) {\n    ///                  ...                                    ...\n    ///                }                                      }\n    /// \\endcode\n    bool AfterRequiresInExpression;\n    /// If ``true``, put a space before opening parentheses only if the\n    /// parentheses are not empty.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f (int a);                 vs.    void f();\n    ///    f (a);                                 f();\n    /// \\endcode\n    bool BeforeNonEmptyParentheses;\n\n    SpaceBeforeParensCustom()\n        : AfterControlStatements(false), AfterForeachMacros(false),\n          AfterFunctionDeclarationName(false),\n          AfterFunctionDefinitionName(false), AfterIfMacros(false),\n          AfterOverloadedOperator(false), AfterRequiresInClause(false),\n          AfterRequiresInExpression(false), BeforeNonEmptyParentheses(false) {}\n\n    bool operator==(const SpaceBeforeParensCustom &Other) const {\n      return AfterControlStatements == Other.AfterControlStatements &&\n             AfterForeachMacros == Other.AfterForeachMacros &&\n             AfterFunctionDeclarationName ==\n                 Other.AfterFunctionDeclarationName &&\n             AfterFunctionDefinitionName == Other.AfterFunctionDefinitionName &&\n             AfterIfMacros == Other.AfterIfMacros &&\n             AfterOverloadedOperator == Other.AfterOverloadedOperator &&\n             AfterRequiresInClause == Other.AfterRequiresInClause &&\n             AfterRequiresInExpression == Other.AfterRequiresInExpression &&\n             BeforeNonEmptyParentheses == Other.BeforeNonEmptyParentheses;\n    }\n  };\n\n  /// Control of individual space before parentheses.\n  ///\n  /// If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify\n  /// how each individual space before parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpaceBeforeParens: Custom\n  ///   SpaceBeforeParensOptions:\n  ///     AfterControlStatements: true\n  ///     AfterFunctionDefinitionName: true\n  /// \\endcode\n  /// \\version 14\n  SpaceBeforeParensCustom SpaceBeforeParensOptions;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  /// \\version 10\n  bool SpaceBeforeSquareBrackets;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  /// \\version 7\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  /// \\version 10\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// This option is **deprecated**. See ``InEmptyParentheses`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as those\n  /// commonly have different usage patterns and a number of special cases.  In\n  /// the case of Verilog, it doesn't affect a comment right after the opening\n  /// parenthesis in the port or parameter list in a module header, because it\n  /// is probably for the port on the following line instead of the parenthesis\n  /// it follows.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  /// \\version 3.7\n  unsigned SpacesBeforeTrailingComments;\n\n  /// Styles for adding spacing after ``<`` and before ``>``\n  ///  in template argument lists.\n  enum SpacesInAnglesStyle : int8_t {\n    /// Remove spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast<int>(arg);\n    ///    std::function<void(int)> fct;\n    /// \\endcode\n    SIAS_Never,\n    /// Add spaces after ``<`` and before ``>``.\n    /// \\code\n    ///    static_cast< int >(arg);\n    ///    std::function< void(int) > fct;\n    /// \\endcode\n    SIAS_Always,\n    /// Keep a single space after ``<`` and before ``>`` if any spaces were\n    /// present. Option ``Standard: Cpp03`` takes precedence.\n    SIAS_Leave\n  };\n  /// The SpacesInAnglesStyle to use for template argument lists.\n  /// \\version 3.4\n  SpacesInAnglesStyle SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// This option is **deprecated**. See ``InConditionalStatements`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 10\n  // bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.  ObjC and\n  /// Javascript array and dict literals). For JSON, use\n  /// ``SpaceBeforeJsonColon`` instead.\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// This option is **deprecated**. See ``InCStyleCasts`` of\n  /// ``SpacesInParensOptions``.\n  /// \\version 3.7\n  // bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment.\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code\n  ///   Minimum = 1\n  ///   Maximum = -1\n  ///   // One space is forced\n  ///\n  ///   //  but more spaces are possible\n  ///\n  ///   Minimum = 0\n  ///   Maximum = 0\n  ///   //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  ///   before:                                   after:\n  ///   Minimum: 1\n  ///   //if (b) {                                // if (b) {\n  ///   //  return true;                          //   return true;\n  ///   //}                                       // }\n  ///\n  ///   Maximum: 0\n  ///   /// List:                                 ///List:\n  ///   ///  - Foo                                /// - Foo\n  ///   ///    - Bar                              ///   - Bar\n  /// \\endcode\n  ///\n  /// This option has only effect if ``ReflowComments`` is set to ``true``.\n  /// \\version 13\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// Different ways to put a space before opening and closing parentheses.\n  enum SpacesInParensStyle : int8_t {\n    /// Never put a space in parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SIPO_Never,\n    /// Configure each individual space in parentheses in\n    /// `SpacesInParensOptions`.\n    SIPO_Custom,\n  };\n\n  /// If ``true'', spaces will be inserted after ``(`` and before ``)``.\n  /// This option is **deprecated**. The previous behavior is preserved by using\n  /// ``SpacesInParens`` with ``Custom`` and by setting all\n  /// ``SpacesInParensOptions`` to ``true`` except for ``InCStyleCasts`` and\n  /// ``InEmptyParentheses``.\n  /// \\version 3.7\n  // bool SpacesInParentheses;\n\n  /// Defines in which cases spaces will be inserted after ``(`` and before\n  /// ``)``.\n  /// \\version 17\n  SpacesInParensStyle SpacesInParens;\n\n  /// Precise control over the spacing in parentheses.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     Other: true\n  /// \\endcode\n  struct SpacesInParensCustom {\n    /// Put a space in parentheses only inside conditional statements\n    /// (``for/if/while/switch...``).\n    /// \\code\n    ///    true:                                  false:\n    ///    if ( a )  { ... }              vs.     if (a) { ... }\n    ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n    /// \\endcode\n    bool InConditionalStatements;\n    /// Put a space in C style casts.\n    /// \\code\n    ///    true:                                  false:\n    ///    x = ( int32 )y                 vs.     x = (int32)y\n    /// \\endcode\n    bool InCStyleCasts;\n    /// Put a space in parentheses only if the parentheses are empty i.e. '()'\n    /// \\code\n    ///    true:                                false:\n    ///    void f( ) {                    vs.   void f() {\n    ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n    ///      if (true) {                          if (true) {\n    ///        f( );                                f();\n    ///      }                                    }\n    ///    }                                    }\n    /// \\endcode\n    bool InEmptyParentheses;\n    /// Put a space in parentheses not covered by preceding options.\n    /// \\code\n    ///    true:                                  false:\n    ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n    /// \\endcode\n    bool Other;\n\n    SpacesInParensCustom()\n        : InConditionalStatements(false), InCStyleCasts(false),\n          InEmptyParentheses(false), Other(false) {}\n\n    SpacesInParensCustom(bool InConditionalStatements, bool InCStyleCasts,\n        bool InEmptyParentheses, bool Other)\n        : InConditionalStatements(InConditionalStatements),\n          InCStyleCasts(InCStyleCasts),\n          InEmptyParentheses(InEmptyParentheses),\n          Other(Other) {}\n\n    bool operator==(const SpacesInParensCustom &R) const {\n      return InConditionalStatements == R.InConditionalStatements &&\n             InCStyleCasts == R.InCStyleCasts &&\n             InEmptyParentheses == R.InEmptyParentheses &&\n             Other == R.Other;\n    }\n    bool operator!=(const SpacesInParensCustom &R) const {\n      return !(*this == R);\n    }\n  };\n\n  /// Control of individual spaces in parentheses.\n  ///\n  /// If ``SpacesInParens`` is set to ``Custom``, use this to specify\n  /// how each individual space in parentheses case should be handled.\n  /// Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   SpacesInParens: Custom\n  ///   SpacesInParensOptions:\n  ///     InConditionalStatements: true\n  ///     InEmptyParentheses: true\n  /// \\endcode\n  /// \\version 17\n  SpacesInParensCustom SpacesInParensOptions;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  /// \\version 3.7\n  bool SpacesInSquareBrackets;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : int8_t {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  /// \\version 3.7\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  /// \\version 12\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  /// \\version 8\n  std::vector<std::string> StatementMacros;\n\n  /// The number of columns used for tab stops.\n  /// \\version 3.7\n  unsigned TabWidth;\n\n  /// A vector of non-keyword identifiers that should be interpreted as type\n  /// names.\n  ///\n  /// A ``*``, ``&``, or ``&&`` between a type name and another non-keyword\n  /// identifier is annotated as a pointer or reference token instead of a\n  /// binary operator.\n  ///\n  /// \\version 17\n  std::vector<std::string> TypeNames;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  /// \\version 9\n  std::vector<std::string> TypenameMacros;\n\n  /// This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``.\n  /// \\version 10\n  // bool UseCRLF;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : int8_t {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// The way to use tab characters in the resulting file.\n  /// \\version 3.7\n  UseTabStyle UseTab;\n\n  /// For Verilog, put each port on its own line in module instantiations.\n  /// \\code\n  ///    true:\n  ///    ffnand ff1(.q(),\n  ///               .qbar(out1),\n  ///               .clear(in1),\n  ///               .preset(in2));\n  ///\n  ///    false:\n  ///    ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));\n  /// \\endcode\n  /// \\version 17\n  bool VerilogBreakBetweenInstancePorts;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  /// \\version 11\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignArrayOfStructures == R.AlignArrayOfStructures &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignConsecutiveShortCaseStatements ==\n               R.AlignConsecutiveShortCaseStatements &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           BracedInitializerIndentWidth == R.BracedInitializerIndentWidth &&\n           BreakAfterAttributes == R.BreakAfterAttributes &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakArrays == R.BreakArrays &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeInlineASMColon == R.BreakBeforeInlineASMColon &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           CompactNamespaces == R.CompactNamespaces &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineAfterAccessModifier == R.EmptyLineAfterAccessModifier &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentRequiresClause == R.IndentRequiresClause &&\n           IndentWidth == R.IndentWidth &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           InsertBraces == R.InsertBraces &&\n           InsertNewlineAtEOF == R.InsertNewlineAtEOF &&\n           IntegerLiteralSeparator == R.IntegerLiteralSeparator &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtEOF == R.KeepEmptyLinesAtEOF &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           Language == R.Language &&\n           LambdaBodyIndentation == R.LambdaBodyIndentation &&\n           LineEnding == R.LineEnding && MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd && Macros == R.Macros &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PackConstructorInitializers == R.PackConstructorInitializers &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakOpenParenthesis == R.PenaltyBreakOpenParenthesis &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PointerAlignment == R.PointerAlignment &&\n           QualifierAlignment == R.QualifierAlignment &&\n           QualifierOrder == R.QualifierOrder &&\n           RawStringFormats == R.RawStringFormats &&\n           ReferenceAlignment == R.ReferenceAlignment &&\n           RemoveBracesLLVM == R.RemoveBracesLLVM &&\n           RemoveParentheses == R.RemoveParentheses &&\n           RemoveSemicolon == R.RemoveSemicolon &&\n           RequiresClausePosition == R.RequiresClausePosition &&\n           RequiresExpressionIndentation == R.RequiresExpressionIndentation &&\n           SeparateDefinitionBlocks == R.SeparateDefinitionBlocks &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeJsonColon == R.SpaceBeforeJsonColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceBeforeParensOptions == R.SpaceBeforeParensOptions &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParens == R.SpacesInParens &&\n           SpacesInParensOptions == R.SpacesInParensOptions &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           TypeNames == R.TypeNames && TypenameMacros == R.TypenameMacros &&\n           UseTab == R.UseTab &&\n           VerilogBreakBetweenInstancePorts ==\n               R.VerilogBreakBetweenInstancePorts &&\n           WhitespaceSensitiveMacros == R.WhitespaceSensitiveMacros;\n  }\n\n  std::optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    std::optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n};\n\n/// Returns a format style complying with the LLVM coding standards:\n/// http://llvm.org/docs/CodingStandards.html.\nFormatStyle getLLVMStyle(\n    FormatStyle::LanguageKind Language = FormatStyle::LanguageKind::LK_Cpp);\n\n/// Returns a format style complying with one of Google's style guides:\n/// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.\n/// http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml.\n/// https://developers.google.com/protocol-buffers/docs/style.\nFormatStyle getGoogleStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Chromium's style guide:\n/// http://www.chromium.org/developers/coding-style.\nFormatStyle getChromiumStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Mozilla's style guide:\n/// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html.\nFormatStyle getMozillaStyle();\n\n/// Returns a format style complying with Webkit's style guide:\n/// http://www.webkit.org/coding/coding-style.html\nFormatStyle getWebKitStyle();\n\n/// Returns a format style complying with GNU Coding Standards:\n/// http://www.gnu.org/prep/standards/standards.html\nFormatStyle getGNUStyle();\n\n/// Returns a format style complying with Microsoft style guide:\n/// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017\nFormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language);\n\n/// Returns style indicating formatting should be not applied at all.\nFormatStyle getNoStyle();\n\n/// Gets a predefined style for the specified language by name.\n///\n/// Currently supported names: LLVM, Google, Chromium, Mozilla. Names are\n/// compared case-insensitively.\n///\n/// Returns ``true`` if the Style has been set.\nbool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,\n                        FormatStyle *Style);\n\n/// Parse configuration from YAML-formatted text.\n///\n/// Style->Language is used to get the base style, if the ``BasedOnStyle``\n/// option is present.\n///\n/// The FormatStyleSet of Style is reset.\n///\n/// When ``BasedOnStyle`` is not present, options not present in the YAML\n/// document, are retained in \\p Style.\n///\n/// If AllowUnknownOptions is true, no errors are emitted if unknown\n/// format options are occurred.\n///\n/// If set all diagnostics are emitted through the DiagHandler.\nstd::error_code\nparseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                   bool AllowUnknownOptions = false,\n                   llvm::SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n                   void *DiagHandlerCtx = nullptr);\n\n/// Like above but accepts an unnamed buffer.\ninline std::error_code parseConfiguration(StringRef Config, FormatStyle *Style,\n                                          bool AllowUnknownOptions = false) {\n  return parseConfiguration(llvm::MemoryBufferRef(Config, \"YAML\"), Style,\n                            AllowUnknownOptions);\n}\n\n/// Gets configuration in a YAML string.\nstd::string configurationAsText(const FormatStyle &Style);\n\n/// Returns the replacements necessary to sort all ``#include`` blocks\n/// that are affected by ``Ranges``.\ntooling::Replacements sortIncludes(const FormatStyle &Style, StringRef Code,\n                                   ArrayRef<tooling::Range> Ranges,\n                                   StringRef FileName,\n                                   unsigned *Cursor = nullptr);\n\n/// Returns the replacements corresponding to applying and formatting\n/// \\p Replaces on success; otheriwse, return an llvm::Error carrying\n/// llvm::StringError.\nllvm::Expected<tooling::Replacements>\nformatReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                   const FormatStyle &Style);\n\n/// Returns the replacements corresponding to applying \\p Replaces and\n/// cleaning up the code after that on success; otherwise, return an llvm::Error\n/// carrying llvm::StringError.\n/// This also supports inserting/deleting C++ #include directives:\n/// - If a replacement has offset UINT_MAX, length 0, and a replacement text\n///   that is an #include directive, this will insert the #include into the\n///   correct block in the \\p Code.\n/// - If a replacement has offset UINT_MAX, length 1, and a replacement text\n///   that is the name of the header to be removed, the header will be removed\n///   from \\p Code if it exists.\n/// The include manipulation is done via ``tooling::HeaderInclude``, see its\n/// documentation for more details on how include insertion points are found and\n/// what edits are produced.\nllvm::Expected<tooling::Replacements>\ncleanupAroundReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                          const FormatStyle &Style);\n\n/// Represents the status of a formatting attempt.\nstruct FormattingAttemptStatus {\n  /// A value of ``false`` means that any of the affected ranges were not\n  /// formatted due to a non-recoverable syntax error.\n  bool FormatComplete = true;\n\n  /// If ``FormatComplete`` is false, ``Line`` records a one-based\n  /// original line number at which a syntax error might have occurred. This is\n  /// based on a best-effort analysis and could be imprecise.\n  unsigned Line = 0;\n};\n\n/// Reformats the given \\p Ranges in \\p Code.\n///\n/// Each range is extended on either end to its next bigger logic unit, i.e.\n/// everything that might influence its formatting or might be influenced by its\n/// formatting.\n///\n/// Returns the ``Replacements`` necessary to make all \\p Ranges comply with\n/// \\p Style.\n///\n/// If ``Status`` is non-null, its value will be populated with the status of\n/// this formatting attempt. See \\c FormattingAttemptStatus.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName = \"<stdin>\",\n                               FormattingAttemptStatus *Status = nullptr);\n\n/// Same as above, except if ``IncompleteFormat`` is non-null, its value\n/// will be set to true if any of the affected ranges were not formatted due to\n/// a non-recoverable syntax error.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName, bool *IncompleteFormat);\n\n/// Clean up any erroneous/redundant code in the given \\p Ranges in \\p\n/// Code.\n///\n/// Returns the ``Replacements`` that clean up all \\p Ranges in \\p Code.\ntooling::Replacements cleanup(const FormatStyle &Style, StringRef Code,\n                              ArrayRef<tooling::Range> Ranges,\n                              StringRef FileName = \"<stdin>\");\n\n/// Fix namespace end comments in the given \\p Ranges in \\p Code.\n///\n/// Returns the ``Replacements`` that fix the namespace comments in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements fixNamespaceEndComments(const FormatStyle &Style,\n                                              StringRef Code,\n                                              ArrayRef<tooling::Range> Ranges,\n                                              StringRef FileName = \"<stdin>\");\n\n/// Inserts or removes empty lines separating definition blocks including\n/// classes, structs, functions, namespaces, and enums in the given \\p Ranges in\n/// \\p Code.\n///\n/// Returns the ``Replacements`` that inserts or removes empty lines separating\n/// definition blocks in all \\p Ranges in \\p Code.\ntooling::Replacements separateDefinitionBlocks(const FormatStyle &Style,\n                                               StringRef Code,\n                                               ArrayRef<tooling::Range> Ranges,\n                                               StringRef FileName = \"<stdin>\");\n\n/// Sort consecutive using declarations in the given \\p Ranges in\n/// \\p Code.\n///\n/// Returns the ``Replacements`` that sort the using declarations in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements sortUsingDeclarations(const FormatStyle &Style,\n                                            StringRef Code,\n                                            ArrayRef<tooling::Range> Ranges,\n                                            StringRef FileName = \"<stdin>\");\n\n/// Returns the ``LangOpts`` that the formatter expects you to set.\n///\n/// \\param Style determines specific settings for lexing mode.\nLangOptions getFormattingLangOpts(const FormatStyle &Style = getLLVMStyle());\n\n/// Description to be used for help text for a ``llvm::cl`` option for\n/// specifying format style. The description is closely related to the operation\n/// of ``getStyle()``.\nextern const char *StyleOptionHelpDescription;\n\n/// The suggested format style to use by default. This allows tools using\n/// ``getStyle`` to have a consistent default style.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFormatStyle;\n\n/// The suggested predefined style to use as the fallback style in ``getStyle``.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFallbackStyle;\n\n/// Construct a FormatStyle based on ``StyleName``.\n///\n/// ``StyleName`` can take several forms:\n/// * \"{<key>: <value>, ...}\" - Set specic style parameters.\n/// * \"<style name>\" - One of the style names supported by\n/// getPredefinedStyle().\n/// * \"file\" - Load style configuration from a file called ``.clang-format``\n/// located in one of the parent directories of ``FileName`` or the current\n/// directory if ``FileName`` is empty.\n/// * \"file:<format_file_path>\" to explicitly specify the configuration file to\n/// use.\n///\n/// \\param[in] StyleName Style name to interpret according to the description\n/// above.\n/// \\param[in] FileName Path to start search for .clang-format if ``StyleName``\n/// == \"file\".\n/// \\param[in] FallbackStyle The name of a predefined style used to fallback to\n/// in case \\p StyleName is \"file\" and no file can be found.\n/// \\param[in] Code The actual code to be formatted. Used to determine the\n/// language if the filename isn't sufficient.\n/// \\param[in] FS The underlying file system, in which the file resides. By\n/// default, the file system is the real file system.\n/// \\param[in] AllowUnknownOptions If true, unknown format options only\n///             emit a warning. If false, errors are emitted on unknown format\n///             options.\n///\n/// \\returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is\n/// \"file\" and no file is found, returns ``FallbackStyle``. If no style could be\n/// determined, returns an Error.\nllvm::Expected<FormatStyle> getStyle(StringRef StyleName, StringRef FileName,\n                                     StringRef FallbackStyle,\n                                     StringRef Code = \"\",\n                                     llvm::vfs::FileSystem *FS = nullptr,\n                                     bool AllowUnknownOptions = false);\n\n// Guesses the language from the ``FileName`` and ``Code`` to be formatted.\n// Defaults to FormatStyle::LK_Cpp.\nFormatStyle::LanguageKind guessLanguage(StringRef FileName, StringRef Code);\n\n// Returns a string representation of ``Language``.\ninline StringRef getLanguageName(FormatStyle::LanguageKind Language) {\n  switch (Language) {\n  case FormatStyle::LK_Cpp:\n    return \"C++\";\n  case FormatStyle::LK_CSharp:\n    return \"CSharp\";\n  case FormatStyle::LK_ObjC:\n    return \"Objective-C\";\n  case FormatStyle::LK_Java:\n    return \"Java\";\n  case FormatStyle::LK_JavaScript:\n    return \"JavaScript\";\n  case FormatStyle::LK_Json:\n    return \"Json\";\n  case FormatStyle::LK_Proto:\n    return \"Proto\";\n  case FormatStyle::LK_TableGen:\n    return \"TableGen\";\n  case FormatStyle::LK_TextProto:\n    return \"TextProto\";\n  case FormatStyle::LK_Verilog:\n    return \"Verilog\";\n  default:\n    return \"Unknown\";\n  }\n}\n\nbool isClangFormatOn(StringRef Comment);\nbool isClangFormatOff(StringRef Comment);\n\n}",
  "id": "BLOCK-CPP-18088",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 2972,
  "validation_status": "validated"
}