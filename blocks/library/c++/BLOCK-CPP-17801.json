{
  "code": "{\nnamespace driver {\n\nclass Action;\nclass InputInfo;\nclass Tool;\n\nstruct CrashReportInfo {\n  StringRef Filename;\n  StringRef VFSPath;\n\n  CrashReportInfo(StringRef Filename, StringRef VFSPath)\n      : Filename(Filename), VFSPath(VFSPath) {}\n};\n\n// Encodes the kind of response file supported for a command invocation.\n// Response files are necessary if the command line gets too large, requiring\n// the arguments to be transferred to a file.\nstruct ResponseFileSupport {\n  enum ResponseFileKind {\n    // Provides full support for response files, which means we can transfer\n    // all tool input arguments to a file.\n    RF_Full,\n    // Input file names can live in a file, but flags can't. This is a special\n    // case for old versions of Apple's ld64.\n    RF_FileList,\n    // Does not support response files: all arguments must be passed via\n    // command line.\n    RF_None\n  };\n  /// The level of support for response files.\n  ResponseFileKind ResponseKind;\n\n  /// The encoding to use when writing response files on Windows. Ignored on\n  /// other host OSes.\n  ///\n  /// Windows use cases: - GCC and Binutils on mingw only accept ANSI response\n  /// files encoded with the system current code page.\n  /// - MSVC's CL.exe and LINK.exe accept UTF16 on Windows.\n  /// - Clang accepts both UTF8 and UTF16.\n  ///\n  /// FIXME: When GNU tools learn how to parse UTF16 on Windows, we should\n  /// always use UTF16 for Windows, which is the Windows official encoding for\n  /// international characters.\n  llvm::sys::WindowsEncodingMethod ResponseEncoding;\n\n  /// What prefix to use for the command-line argument when passing a response\n  /// file.\n  const char *ResponseFlag;\n\n  /// Returns a ResponseFileSupport indicating that response files are not\n  /// supported.\n  static constexpr ResponseFileSupport None() {\n    return {RF_None, llvm::sys::WEM_UTF8, nullptr};\n  }\n\n  /// Returns a ResponseFileSupport indicating that response files are\n  /// supported, using the @file syntax. On windows, the file is written in the\n  /// UTF8 encoding. On other OSes, no re-encoding occurs.\n  static constexpr ResponseFileSupport AtFileUTF8() {\n    return {RF_Full, llvm::sys::WEM_UTF8, \"@\"};\n  }\n\n  /// Returns a ResponseFileSupport indicating that response files are\n  /// supported, using the @file syntax. On windows, the file is written in the\n  /// current ANSI code-page encoding. On other OSes, no re-encoding occurs.\n  static constexpr ResponseFileSupport AtFileCurCP() {\n    return {RF_Full, llvm::sys::WEM_CurrentCodePage, \"@\"};\n  }\n\n  /// Returns a ResponseFileSupport indicating that response files are\n  /// supported, using the @file syntax. On windows, the file is written in the\n  /// UTF-16 encoding. On other OSes, no re-encoding occurs.\n  static constexpr ResponseFileSupport AtFileUTF16() {\n    return {RF_Full, llvm::sys::WEM_UTF16, \"@\"};\n  }\n};\n\n/// Command - An executable path/name and argument vector to\n/// execute.\nclass Command {\n  /// Source - The action which caused the creation of this job.\n  const Action &Source;\n\n  /// Tool - The tool which caused the creation of this job.\n  const Tool &Creator;\n\n  /// Whether and how to generate response files if the arguments are too long.\n  ResponseFileSupport ResponseSupport;\n\n  /// The executable to run.\n  const char *Executable;\n\n  /// Optional argument to prepend.\n  const char *PrependArg;\n\n  /// The list of program arguments (not including the implicit first\n  /// argument, which will be the executable).\n  llvm::opt::ArgStringList Arguments;\n\n  /// The list of program inputs.\n  std::vector<InputInfo> InputInfoList;\n\n  /// The list of program arguments which are outputs. May be empty.\n  std::vector<std::string> OutputFilenames;\n\n  /// Response file name, if this command is set to use one, or nullptr\n  /// otherwise\n  const char *ResponseFile = nullptr;\n\n  /// The input file list in case we need to emit a file list instead of a\n  /// proper response file\n  llvm::opt::ArgStringList InputFileList;\n\n  /// String storage if we need to create a new argument to specify a response\n  /// file\n  std::string ResponseFileFlag;\n\n  /// See Command::setEnvironment\n  std::vector<const char *> Environment;\n\n  /// Optional redirection for stdin, stdout, stderr.\n  std::vector<std::optional<std::string>> RedirectFiles;\n\n  /// Information on executable run provided by OS.\n  mutable std::optional<llvm::sys::ProcessStatistics> ProcStat;\n\n  /// When a response file is needed, we try to put most arguments in an\n  /// exclusive file, while others remains as regular command line arguments.\n  /// This functions fills a vector with the regular command line arguments,\n  /// argv, excluding the ones passed in a response file.\n  void buildArgvForResponseFile(llvm::SmallVectorImpl<const char *> &Out) const;\n\n  /// Encodes an array of C strings into a single string separated by whitespace.\n  /// This function will also put in quotes arguments that have whitespaces and\n  /// will escape the regular backslashes (used in Windows paths) and quotes.\n  /// The results are the contents of a response file, written into a raw_ostream.\n  void writeResponseFile(raw_ostream &OS) const;\n\npublic:\n  /// Whether to print the input filenames when executing.\n  bool PrintInputFilenames = false;\n\n  /// Whether the command will be executed in this process or not.\n  bool InProcess = false;\n\n  Command(const Action &Source, const Tool &Creator,\n          ResponseFileSupport ResponseSupport, const char *Executable,\n          const llvm::opt::ArgStringList &Arguments, ArrayRef<InputInfo> Inputs,\n          ArrayRef<InputInfo> Outputs = std::nullopt,\n          const char *PrependArg = nullptr);\n  // FIXME: This really shouldn't be copyable, but is currently copied in some\n  // error handling in Driver::generateCompilationDiagnostics.\n  Command(const Command &) = default;\n  virtual ~Command() = default;\n\n  virtual void Print(llvm::raw_ostream &OS, const char *Terminator, bool Quote,\n                     CrashReportInfo *CrashInfo = nullptr) const;\n\n  virtual int Execute(ArrayRef<std::optional<StringRef>> Redirects,\n                      std::string *ErrMsg, bool *ExecutionFailed) const;\n\n  /// getSource - Return the Action which caused the creation of this job.\n  const Action &getSource() const { return Source; }\n\n  /// getCreator - Return the Tool which caused the creation of this job.\n  const Tool &getCreator() const { return Creator; }\n\n  /// Returns the kind of response file supported by the current invocation.\n  const ResponseFileSupport &getResponseFileSupport() {\n    return ResponseSupport;\n  }\n\n  /// Set to pass arguments via a response file when launching the command\n  void setResponseFile(const char *FileName);\n\n  /// Set an input file list, necessary if you specified an RF_FileList response\n  /// file support.\n  void setInputFileList(llvm::opt::ArgStringList List) {\n    InputFileList = std::move(List);\n  }\n\n  /// Sets the environment to be used by the new process.\n  /// \\param NewEnvironment An array of environment variables.\n  /// \\remark If the environment remains unset, then the environment\n  ///         from the parent process will be used.\n  virtual void setEnvironment(llvm::ArrayRef<const char *> NewEnvironment);\n\n  void\n  setRedirectFiles(const std::vector<std::optional<std::string>> &Redirects);\n\n  void replaceArguments(llvm::opt::ArgStringList List) {\n    Arguments = std::move(List);\n  }\n\n  void replaceExecutable(const char *Exe) { Executable = Exe; }\n\n  const char *getExecutable() const { return Executable; }\n\n  const llvm::opt::ArgStringList &getArguments() const { return Arguments; }\n\n  const std::vector<InputInfo> &getInputInfos() const { return InputInfoList; }\n\n  const std::vector<std::string> &getOutputFilenames() const {\n    return OutputFilenames;\n  }\n\n  std::optional<llvm::sys::ProcessStatistics> getProcessStatistics() const {\n    return ProcStat;\n  }\n\nprotected:\n  /// Optionally print the filenames to be compiled\n  void PrintFileNames() const;\n};\n\n/// Use the CC1 tool callback when available, to avoid creating a new process\nclass CC1Command : public Command {\npublic:\n  CC1Command(const Action &Source, const Tool &Creator,\n             ResponseFileSupport ResponseSupport, const char *Executable,\n             const llvm::opt::ArgStringList &Arguments,\n             ArrayRef<InputInfo> Inputs,\n             ArrayRef<InputInfo> Outputs = std::nullopt,\n             const char *PrependArg = nullptr);\n\n  void Print(llvm::raw_ostream &OS, const char *Terminator, bool Quote,\n             CrashReportInfo *CrashInfo = nullptr) const override;\n\n  int Execute(ArrayRef<std::optional<StringRef>> Redirects, std::string *ErrMsg,\n              bool *ExecutionFailed) const override;\n\n  void setEnvironment(llvm::ArrayRef<const char *> NewEnvironment) override;\n};\n\n/// JobList - A sequence of jobs to perform.\nclass JobList {\npublic:\n  using list_type = SmallVector<std::unique_ptr<Command>, 4>;\n  using size_type = list_type::size_type;\n  using iterator = llvm::pointee_iterator<list_type::iterator>;\n  using const_iterator = llvm::pointee_iterator<list_type::const_iterator>;\n\nprivate:\n  list_type Jobs;\n\npublic:\n  void Print(llvm::raw_ostream &OS, const char *Terminator,\n             bool Quote, CrashReportInfo *CrashInfo = nullptr) const;\n\n  /// Add a job to the list (taking ownership).\n  void addJob(std::unique_ptr<Command> J) { Jobs.push_back(std::move(J)); }\n\n  /// Clear the job list.\n  void clear();\n\n  const list_type &getJobs() const { return Jobs; }\n\n  bool empty() const { return Jobs.empty(); }\n  size_type size() const { return Jobs.size(); }\n  iterator begin() { return Jobs.begin(); }\n  const_iterator begin() const { return Jobs.begin(); }\n  iterator end() { return Jobs.end(); }\n  const_iterator end() const { return Jobs.end(); }\n};\n\n} // namespace driver\n}",
  "id": "BLOCK-CPP-17801",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Job.h",
  "source_line": 26,
  "validation_status": "validated"
}