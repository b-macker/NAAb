{
  "code": "{\n\n/// Base class template for dataflow analyses built on a single lattice type.\n///\n/// Requirements:\n///\n///  `Derived` must be derived from a specialization of this class template and\n///  must provide the following public members:\n///   * `LatticeT initialElement()` - returns a lattice element that models the\n///     initial state of a basic block;\n///   * `void transfer(const CFGElement &, LatticeT &, Environment &)` - applies\n///     the analysis transfer function for a given CFG element and lattice\n///     element.\n///\n///  `Derived` can optionally provide the following members:\n///  * `void transferBranch(bool Branch, const Stmt *Stmt, TypeErasedLattice &E,\n///                         Environment &Env)` - applies the analysis transfer\n///    function for a given edge from a CFG block of a conditional statement.\n///\n///  `Derived` can optionally override the following members:\n///   * `bool merge(QualType, const Value &, const Value &, Value &,\n///     Environment &)` -  joins distinct values. This could be a strict\n///     lattice join or a more general widening operation.\n///\n///  `LatticeT` is a bounded join-semilattice that is used by `Derived` and must\n///  provide the following public members:\n///   * `LatticeJoinEffect join(const LatticeT &)` - joins the object and the\n///     argument by computing their least upper bound, modifies the object if\n///     necessary, and returns an effect indicating whether any changes were\n///     made to it;\n///     FIXME: make it `static LatticeT join(const LatticeT&, const LatticeT&)`\n///   * `bool operator==(const LatticeT &) const` - returns true if and only if\n///     the object is equal to the argument.\n///\n/// `LatticeT` can optionally provide the following members:\n///  * `LatticeJoinEffect widen(const LatticeT &Previous)` - replaces the\n///    lattice element with an  approximation that can reach a fixed point more\n///    quickly than iterated application of the transfer function alone. The\n///    previous value is provided to inform the choice of widened value. The\n///    function must also serve as a comparison operation, by indicating whether\n///    the widened value is equivalent to the previous value with the returned\n///    `LatticeJoinEffect`.\ntemplate <typename Derived, typename LatticeT>\nclass DataflowAnalysis : public TypeErasedDataflowAnalysis {\npublic:\n  /// Bounded join-semilattice that is used in the analysis.\n  using Lattice = LatticeT;\n\n  explicit DataflowAnalysis(ASTContext &Context) : Context(Context) {}\n\n  /// Deprecated. Use the `DataflowAnalysisOptions` constructor instead.\n  explicit DataflowAnalysis(ASTContext &Context, bool ApplyBuiltinTransfer)\n      : DataflowAnalysis(\n            Context,\n            {ApplyBuiltinTransfer\n                 ? DataflowAnalysisContext::Options{}\n                 : std::optional<DataflowAnalysisContext::Options>()}) {}\n\n  explicit DataflowAnalysis(ASTContext &Context,\n                            DataflowAnalysisOptions Options)\n      : TypeErasedDataflowAnalysis(Options), Context(Context) {}\n\n  ASTContext &getASTContext() final { return Context; }\n\n  TypeErasedLattice typeErasedInitialElement() final {\n    return {static_cast<Derived *>(this)->initialElement()};\n  }\n\n  TypeErasedLattice joinTypeErased(const TypeErasedLattice &E1,\n                                   const TypeErasedLattice &E2) final {\n    // FIXME: change the signature of join() to avoid copying here.\n    Lattice L1 = llvm::any_cast<const Lattice &>(E1.Value);\n    const Lattice &L2 = llvm::any_cast<const Lattice &>(E2.Value);\n    L1.join(L2);\n    return {std::move(L1)};\n  }\n\n  LatticeJoinEffect widenTypeErased(TypeErasedLattice &Current,\n                                    const TypeErasedLattice &Previous) final {\n    Lattice &C = llvm::any_cast<Lattice &>(Current.Value);\n    const Lattice &P = llvm::any_cast<const Lattice &>(Previous.Value);\n    return widenInternal(Rank0{}, C, P);\n  }\n\n  bool isEqualTypeErased(const TypeErasedLattice &E1,\n                         const TypeErasedLattice &E2) final {\n    const Lattice &L1 = llvm::any_cast<const Lattice &>(E1.Value);\n    const Lattice &L2 = llvm::any_cast<const Lattice &>(E2.Value);\n    return L1 == L2;\n  }\n\n  void transferTypeErased(const CFGElement &Element, TypeErasedLattice &E,\n                          Environment &Env) final {\n    Lattice &L = llvm::any_cast<Lattice &>(E.Value);\n    static_cast<Derived *>(this)->transfer(Element, L, Env);\n  }\n\n  void transferBranchTypeErased(bool Branch, const Stmt *Stmt,\n                                TypeErasedLattice &E, Environment &Env) final {\n    transferBranchInternal(Rank0{}, *static_cast<Derived *>(this), Branch, Stmt,\n                           E, Env);\n  }\n\nprivate:\n  // These `Rank` structs are used for template metaprogramming to choose\n  // between overloads.\n  struct Rank1 {};\n  struct Rank0 : Rank1 {};\n\n  // The first-choice implementation: use `widen` when it is available.\n  template <typename T>\n  static auto widenInternal(Rank0, T &Current, const T &Prev)\n      -> decltype(Current.widen(Prev)) {\n    return Current.widen(Prev);\n  }\n\n  // The second-choice implementation: `widen` is unavailable. Widening is\n  // merged with equality checking, so when widening is unimplemented, we\n  // default to equality checking.\n  static LatticeJoinEffect widenInternal(Rank1, const Lattice &Current,\n                                         const Lattice &Prev) {\n    return Prev == Current ? LatticeJoinEffect::Unchanged\n                           : LatticeJoinEffect::Changed;\n  }\n\n  // The first-choice implementation: `transferBranch` is implemented.\n  template <typename Analysis>\n  static auto transferBranchInternal(Rank0, Analysis &A, bool Branch,\n                                     const Stmt *Stmt, TypeErasedLattice &L,\n                                     Environment &Env)\n      -> std::void_t<decltype(A.transferBranch(\n          Branch, Stmt, std::declval<LatticeT &>(), Env))> {\n    A.transferBranch(Branch, Stmt, llvm::any_cast<Lattice &>(L.Value), Env);\n  }\n\n  // The second-choice implementation: `transferBranch` is unimplemented. No-op.\n  template <typename Analysis>\n  static void transferBranchInternal(Rank1, Analysis &A, bool, const Stmt *,\n                                     TypeErasedLattice &, Environment &) {}\n\n  ASTContext &Context;\n};\n\n// Model of the program at a given program point.\ntemplate <typename LatticeT> struct DataflowAnalysisState {\n  // Model of a program property.\n  LatticeT Lattice;\n\n  // Model of the state of the program (store and heap).\n  Environment Env;\n};\n\n/// Performs dataflow analysis and returns a mapping from basic block IDs to\n/// dataflow analysis states that model the respective basic blocks. The\n/// returned vector, if any, will have the same size as the number of CFG\n/// blocks, with indices corresponding to basic block IDs. Returns an error if\n/// the dataflow analysis cannot be performed successfully. Otherwise, calls\n/// `PostVisitCFG` on each CFG element with the final analysis results at that\n/// program point.\ntemplate <typename AnalysisT>\nllvm::Expected<std::vector<\n    std::optional<DataflowAnalysisState<typename AnalysisT::Lattice>>>>\nrunDataflowAnalysis(\n    const ControlFlowContext &CFCtx, AnalysisT &Analysis,\n    const Environment &InitEnv,\n    std::function<void(const CFGElement &, const DataflowAnalysisState<\n                                               typename AnalysisT::Lattice> &)>\n        PostVisitCFG = nullptr) {\n  std::function<void(const CFGElement &,\n                     const TypeErasedDataflowAnalysisState &)>\n      PostVisitCFGClosure = nullptr;\n  if (PostVisitCFG) {\n    PostVisitCFGClosure = [&PostVisitCFG](\n                              const CFGElement &Element,\n                              const TypeErasedDataflowAnalysisState &State) {\n      auto *Lattice =\n          llvm::any_cast<typename AnalysisT::Lattice>(&State.Lattice.Value);\n      // FIXME: we should not be copying the environment here!\n      // Ultimately the PostVisitCFG only gets a const reference anyway.\n      PostVisitCFG(Element, DataflowAnalysisState<typename AnalysisT::Lattice>{\n                                *Lattice, State.Env.fork()});\n    };\n  }\n\n  auto TypeErasedBlockStates = runTypeErasedDataflowAnalysis(\n      CFCtx, Analysis, InitEnv, PostVisitCFGClosure);\n  if (!TypeErasedBlockStates)\n    return TypeErasedBlockStates.takeError();\n\n  std::vector<std::optional<DataflowAnalysisState<typename AnalysisT::Lattice>>>\n      BlockStates;\n  BlockStates.reserve(TypeErasedBlockStates->size());\n\n  llvm::transform(\n      std::move(*TypeErasedBlockStates), std::back_inserter(BlockStates),\n      [](auto &OptState) {\n        return llvm::transformOptional(\n            std::move(OptState), [](TypeErasedDataflowAnalysisState &&State) {\n              return DataflowAnalysisState<typename AnalysisT::Lattice>{\n                  llvm::any_cast<typename AnalysisT::Lattice>(\n                      std::move(State.Lattice.Value)),\n                  std::move(State.Env)};\n            });\n      });\n  return std::move(BlockStates);\n}\n\n/// Abstract base class for dataflow \"models\": reusable analysis components that\n/// model a particular aspect of program semantics in the `Environment`. For\n/// example, a model may capture a type and its related functions.\nclass DataflowModel : public Environment::ValueModel {\npublic:\n  /// Return value indicates whether the model processed the `Element`.\n  virtual bool transfer(const CFGElement &Element, Environment &Env) = 0;\n};\n\n}",
  "id": "BLOCK-CPP-21893",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h",
  "source_line": 34,
  "validation_status": "validated"
}