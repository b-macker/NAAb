{
  "code": "{\n    /// Function - The actual function that this candidate\n    /// represents. When NULL, this is a built-in candidate\n    /// (C++ [over.oper]) or a surrogate for a conversion to a\n    /// function pointer or reference (C++ [over.call.object]).\n    FunctionDecl *Function;\n\n    /// FoundDecl - The original declaration that was looked up /\n    /// invented / otherwise found, together with its access.\n    /// Might be a UsingShadowDecl or a FunctionTemplateDecl.\n    DeclAccessPair FoundDecl;\n\n    /// BuiltinParamTypes - Provides the parameter types of a built-in overload\n    /// candidate. Only valid when Function is NULL.\n    QualType BuiltinParamTypes[3];\n\n    /// Surrogate - The conversion function for which this candidate\n    /// is a surrogate, but only if IsSurrogate is true.\n    CXXConversionDecl *Surrogate;\n\n    /// The conversion sequences used to convert the function arguments\n    /// to the function parameters. Note that these are indexed by argument,\n    /// so may not match the parameter order of Function.\n    ConversionSequenceList Conversions;\n\n    /// The FixIt hints which can be used to fix the Bad candidate.\n    ConversionFixItGenerator Fix;\n\n    /// Viable - True to indicate that this overload candidate is viable.\n    bool Viable : 1;\n\n    /// Whether this candidate is the best viable function, or tied for being\n    /// the best viable function.\n    ///\n    /// For an ambiguous overload resolution, indicates whether this candidate\n    /// was part of the ambiguity kernel: the minimal non-empty set of viable\n    /// candidates such that all elements of the ambiguity kernel are better\n    /// than all viable candidates not in the ambiguity kernel.\n    bool Best : 1;\n\n    /// IsSurrogate - True to indicate that this candidate is a\n    /// surrogate for a conversion to a function pointer or reference\n    /// (C++ [over.call.object]).\n    bool IsSurrogate : 1;\n\n    /// IgnoreObjectArgument - True to indicate that the first\n    /// argument's conversion, which for this function represents the\n    /// implicit object argument, should be ignored. This will be true\n    /// when the candidate is a static member function (where the\n    /// implicit object argument is just a placeholder) or a\n    /// non-static member function when the call doesn't have an\n    /// object argument.\n    bool IgnoreObjectArgument : 1;\n\n    /// True if the candidate was found using ADL.\n    CallExpr::ADLCallKind IsADLCandidate : 1;\n\n    /// Whether this is a rewritten candidate, and if so, of what kind?\n    unsigned RewriteKind : 2;\n\n    /// FailureKind - The reason why this candidate is not viable.\n    /// Actually an OverloadFailureKind.\n    unsigned char FailureKind;\n\n    /// The number of call arguments that were explicitly provided,\n    /// to be used while performing partial ordering of function templates.\n    unsigned ExplicitCallArguments;\n\n    union {\n      DeductionFailureInfo DeductionFailure;\n\n      /// FinalConversion - For a conversion function (where Function is\n      /// a CXXConversionDecl), the standard conversion that occurs\n      /// after the call to the overload candidate to convert the result\n      /// of calling the conversion function to the required type.\n      StandardConversionSequence FinalConversion;\n    };\n\n    /// Get RewriteKind value in OverloadCandidateRewriteKind type (This\n    /// function is to workaround the spurious GCC bitfield enum warning)\n    OverloadCandidateRewriteKind getRewriteKind() const {\n      return static_cast<OverloadCandidateRewriteKind>(RewriteKind);\n    }\n\n    bool isReversed() const { return getRewriteKind() & CRK_Reversed; }\n\n    /// hasAmbiguousConversion - Returns whether this overload\n    /// candidate requires an ambiguous conversion or not.\n    bool hasAmbiguousConversion() const {\n      for (auto &C : Conversions) {\n        if (!C.isInitialized()) return false;\n        if (C.isAmbiguous()) return true;\n      }\n      return false;\n    }\n\n    bool TryToFixBadConversion(unsigned Idx, Sema &S) {\n      bool CanFix = Fix.tryToFixConversion(\n                      Conversions[Idx].Bad.FromExpr,\n                      Conversions[Idx].Bad.getFromType(),\n                      Conversions[Idx].Bad.getToType(), S);\n\n      // If at least one conversion fails, the candidate cannot be fixed.\n      if (!CanFix)\n        Fix.clear();\n\n      return CanFix;\n    }\n\n    unsigned getNumParams() const {\n      if (IsSurrogate) {\n        QualType STy = Surrogate->getConversionType();\n        while (STy->isPointerType() || STy->isReferenceType())\n          STy = STy->getPointeeType();\n        return STy->castAs<FunctionProtoType>()->getNumParams();\n      }\n      if (Function)\n        return Function->getNumParams();\n      return ExplicitCallArguments;\n    }\n\n    bool NotValidBecauseConstraintExprHasError() const;\n\n  private:\n    friend class OverloadCandidateSet;\n    OverloadCandidate()\n        : IsSurrogate(false), IsADLCandidate(CallExpr::NotADL), RewriteKind(CRK_None) {}\n  }",
  "id": "BLOCK-CPP-20051",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Overload.h",
  "source_line": 823,
  "validation_status": "validated"
}