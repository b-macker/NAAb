{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace strings_internal {\n\n// The two strings below provide maps from normal 6-bit characters to their\n// base64-escaped equivalent.\n// For the inverse case, see kUn(WebSafe)Base64 in the external\n// escaping.cc.\nABSL_CONST_INIT const char kBase64Chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nABSL_CONST_INIT const char kWebSafeBase64Chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n\nsize_t CalculateBase64EscapedLenInternal(size_t input_len, bool do_padding) {\n  // Base64 encodes three bytes of input at a time. If the input is not\n  // divisible by three, we pad as appropriate.\n  //\n  // Base64 encodes each three bytes of input into four bytes of output.\n  size_t len = (input_len / 3) * 4;\n\n  // Since all base 64 input is an integral number of octets, only the following\n  // cases can arise:\n  if (input_len % 3 == 0) {\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (1) the final quantum of encoding input is an integral multiple of 24\n    // bits; here, the final unit of encoded output will be an integral\n    // multiple of 4 characters with no \"=\" padding,\n  } else if (input_len % 3 == 1) {\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (2) the final quantum of encoding input is exactly 8 bits; here, the\n    // final unit of encoded output will be two characters followed by two\n    // \"=\" padding characters, or\n    len += 2;\n    if (do_padding) {\n      len += 2;\n    }\n  } else {  // (input_len % 3 == 2)\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (3) the final quantum of encoding input is exactly 16 bits; here, the\n    // final unit of encoded output will be three characters followed by one\n    // \"=\" padding character.\n    len += 3;\n    if (do_padding) {\n      len += 1;\n    }\n  }\n\n  assert(len >= input_len);  // make sure we didn't overflow\n  return len;\n}\n\n// ----------------------------------------------------------------------\n//   Take the input in groups of 4 characters and turn each\n//   character into a code 0 to 63 thus:\n//           A-Z map to 0 to 25\n//           a-z map to 26 to 51\n//           0-9 map to 52 to 61\n//           +(- for WebSafe) maps to 62\n//           /(_ for WebSafe) maps to 63\n//   There will be four numbers, all less than 64 which can be represented\n//   by a 6 digit binary number (aaaaaa, bbbbbb, cccccc, dddddd respectively).\n//   Arrange the 6 digit binary numbers into three bytes as such:\n//   aaaaaabb bbbbcccc ccdddddd\n//   Equals signs (one or two) are used at the end of the encoded block to\n//   indicate that the text was not an integer multiple of three bytes long.\n// ----------------------------------------------------------------------\nsize_t Base64EscapeInternal(const unsigned char* src, size_t szsrc, char* dest,\n                            size_t szdest, const char* base64,\n                            bool do_padding) {\n  static const char kPad64 = '=';\n\n  if (szsrc * 4 > szdest * 3) return 0;\n\n  char* cur_dest = dest;\n  const unsigned char* cur_src = src;\n\n  char* const limit_dest = dest + szdest;\n  const unsigned char* const limit_src = src + szsrc;\n\n  // (from https://tools.ietf.org/html/rfc3548)\n  // Special processing is performed if fewer than 24 bits are available\n  // at the end of the data being encoded.  A full encoding quantum is\n  // always completed at the end of a quantity.  When fewer than 24 input\n  // bits are available in an input group, zero bits are added (on the\n  // right) to form an integral number of 6-bit groups.\n  //\n  // If do_padding is true, padding at the end of the data is performed. This\n  // output padding uses the '=' character.\n\n  // Three bytes of data encodes to four characters of cyphertext.\n  // So we can pump through three-byte chunks atomically.\n  if (szsrc >= 3) {                    // \"limit_src - 3\" is UB if szsrc < 3.\n    while (cur_src < limit_src - 3) {  // While we have >= 32 bits.\n      uint32_t in = absl::big_endian::Load32(cur_src) >> 8;\n\n      cur_dest[0] = base64[in >> 18];\n      in &= 0x3FFFF;\n      cur_dest[1] = base64[in >> 12];\n      in &= 0xFFF;\n      cur_dest[2] = base64[in >> 6];\n      in &= 0x3F;\n      cur_dest[3] = base64[in];\n\n      cur_dest += 4;\n      cur_src += 3;\n    }\n  }\n  // To save time, we didn't update szdest or szsrc in the loop.  So do it now.\n  szdest = static_cast<size_t>(limit_dest - cur_dest);\n  szsrc = static_cast<size_t>(limit_src - cur_src);\n\n  /* now deal with the tail (<=3 bytes) */\n  switch (szsrc) {\n    case 0:\n      // Nothing left; nothing more to do.\n      break;\n    case 1: {\n      // One byte left: this encodes to two characters, and (optionally)\n      // two pad characters to round out the four-character cypherblock.\n      if (szdest < 2) return 0;\n      uint32_t in = cur_src[0];\n      cur_dest[0] = base64[in >> 2];\n      in &= 0x3;\n      cur_dest[1] = base64[in << 4];\n      cur_dest += 2;\n      szdest -= 2;\n      if (do_padding) {\n        if (szdest < 2) return 0;\n        cur_dest[0] = kPad64;\n        cur_dest[1] = kPad64;\n        cur_dest += 2;\n        szdest -= 2;\n      }\n      break;\n    }\n    case 2: {\n      // Two bytes left: this encodes to three characters, and (optionally)\n      // one pad character to round out the four-character cypherblock.\n      if (szdest < 3) return 0;\n      uint32_t in = absl::big_endian::Load16(cur_src);\n      cur_dest[0] = base64[in >> 10];\n      in &= 0x3FF;\n      cur_dest[1] = base64[in >> 4];\n      in &= 0x00F;\n      cur_dest[2] = base64[in << 2];\n      cur_dest += 3;\n      szdest -= 3;\n      if (do_padding) {\n        if (szdest < 1) return 0;\n        cur_dest[0] = kPad64;\n        cur_dest += 1;\n        szdest -= 1;\n      }\n      break;\n    }\n    case 3: {\n      // Three bytes left: same as in the big loop above.  We can't do this in\n      // the loop because the loop above always reads 4 bytes, and the fourth\n      // byte is past the end of the input.\n      if (szdest < 4) return 0;\n      uint32_t in =\n          (uint32_t{cur_src[0]} << 16) + absl::big_endian::Load16(cur_src + 1);\n      cur_dest[0] = base64[in >> 18];\n      in &= 0x3FFFF;\n      cur_dest[1] = base64[in >> 12];\n      in &= 0xFFF;\n      cur_dest[2] = base64[in >> 6];\n      in &= 0x3F;\n      cur_dest[3] = base64[in];\n      cur_dest += 4;\n      szdest -= 4;\n      break;\n    }\n    default:\n      // Should not be reached: blocks of 4 bytes are handled\n      // in the while loop before this switch statement.\n      ABSL_RAW_LOG(FATAL, \"Logic problem? szsrc = %zu\", szsrc);\n      break;\n  }\n  return static_cast<size_t>(cur_dest - dest);\n}\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02941",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/escaping.cc",
  "source_line": 20,
  "validation_status": "validated"
}