{
  "code": "{\nprivate:\n  Lexer(const Lexer &) = delete;\n  void operator=(const Lexer &) = delete;\n\n  /// Allocator for strings that are semantic values of tokens and have to be\n  /// computed (for example, resolved decimal character references).\n  llvm::BumpPtrAllocator &Allocator;\n\n  DiagnosticsEngine &Diags;\n\n  const CommandTraits &Traits;\n\n  const char *const BufferStart;\n  const char *const BufferEnd;\n\n  const char *BufferPtr;\n\n  /// One past end pointer for the current comment.  For BCPL comments points\n  /// to newline or BufferEnd, for C comments points to star in '*/'.\n  const char *CommentEnd;\n\n  SourceLocation FileLoc;\n\n  /// If true, the commands, html tags, etc will be parsed and reported as\n  /// separate tokens inside the comment body. If false, the comment text will\n  /// be parsed into text and newline tokens.\n  bool ParseCommands;\n\n  enum LexerCommentState : uint8_t {\n    LCS_BeforeComment,\n    LCS_InsideBCPLComment,\n    LCS_InsideCComment,\n    LCS_BetweenComments\n  };\n\n  /// Low-level lexer state, track if we are inside or outside of comment.\n  LexerCommentState CommentState;\n\n  enum LexerState : uint8_t {\n    /// Lexing normal comment text\n    LS_Normal,\n\n    /// Finished lexing verbatim block beginning command, will lex first body\n    /// line.\n    LS_VerbatimBlockFirstLine,\n\n    /// Lexing verbatim block body line-by-line, skipping line-starting\n    /// decorations.\n    LS_VerbatimBlockBody,\n\n    /// Finished lexing verbatim line beginning command, will lex text (one\n    /// line).\n    LS_VerbatimLineText,\n\n    /// Finished lexing \\verbatim <TAG \\endverbatim part, lexing tag attributes.\n    LS_HTMLStartTag,\n\n    /// Finished lexing \\verbatim </TAG \\endverbatim part, lexing '>'.\n    LS_HTMLEndTag\n  };\n\n  /// Current lexing mode.\n  LexerState State;\n\n  /// If State is LS_VerbatimBlock, contains the name of verbatim end\n  /// command, including command marker.\n  SmallString<16> VerbatimBlockEndCommandName;\n\n  /// Given a character reference name (e.g., \"lt\"), return the character that\n  /// it stands for (e.g., \"<\").\n  StringRef resolveHTMLNamedCharacterReference(StringRef Name) const;\n\n  /// Given a Unicode codepoint as base-10 integer, return the character.\n  StringRef resolveHTMLDecimalCharacterReference(StringRef Name) const;\n\n  /// Given a Unicode codepoint as base-16 integer, return the character.\n  StringRef resolveHTMLHexCharacterReference(StringRef Name) const;\n\n  void formTokenWithChars(Token &Result, const char *TokEnd,\n                          tok::TokenKind Kind);\n\n  void formTextToken(Token &Result, const char *TokEnd) {\n    StringRef Text(BufferPtr, TokEnd - BufferPtr);\n    formTokenWithChars(Result, TokEnd, tok::text);\n    Result.setText(Text);\n  }\n\n  SourceLocation getSourceLocation(const char *Loc) const {\n    assert(Loc >= BufferStart && Loc <= BufferEnd &&\n           \"Location out of range for this buffer!\");\n\n    const unsigned CharNo = Loc - BufferStart;\n    return FileLoc.getLocWithOffset(CharNo);\n  }\n\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) {\n    return Diags.Report(Loc, DiagID);\n  }\n\n  /// Eat string matching regexp \\code \\s*\\* \\endcode.\n  void skipLineStartingDecorations();\n\n  /// Skip over pure text.\n  const char *skipTextToken();\n\n  /// Lex comment text, including commands if ParseCommands is set to true.\n  void lexCommentText(Token &T);\n\n  void setupAndLexVerbatimBlock(Token &T, const char *TextBegin, char Marker,\n                                const CommandInfo *Info);\n\n  void lexVerbatimBlockFirstLine(Token &T);\n\n  void lexVerbatimBlockBody(Token &T);\n\n  void setupAndLexVerbatimLine(Token &T, const char *TextBegin,\n                               const CommandInfo *Info);\n\n  void lexVerbatimLineText(Token &T);\n\n  void lexHTMLCharacterReference(Token &T);\n\n  void setupAndLexHTMLStartTag(Token &T);\n\n  void lexHTMLStartTag(Token &T);\n\n  void setupAndLexHTMLEndTag(Token &T);\n\n  void lexHTMLEndTag(Token &T);\n\npublic:\n  Lexer(llvm::BumpPtrAllocator &Allocator, DiagnosticsEngine &Diags,\n        const CommandTraits &Traits, SourceLocation FileLoc,\n        const char *BufferStart, const char *BufferEnd,\n        bool ParseCommands = true);\n\n  void lex(Token &T);\n\n  StringRef getSpelling(const Token &Tok, const SourceManager &SourceMgr) const;\n}",
  "id": "BLOCK-CPP-23440",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CommentLexer.h",
  "source_line": 220,
  "validation_status": "validated"
}