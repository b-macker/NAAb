{
  "code": "{\nclass ASTContext;\nclass AttributeCommonInfo;\nclass FunctionDecl;\nclass OMPTraitInfo;\n\n/// Attr - This represents one attribute.\nclass Attr : public AttributeCommonInfo {\nprivate:\n  unsigned AttrKind : 16;\n\nprotected:\n  /// An index into the spelling list of an\n  /// attribute defined in Attr.td file.\n  unsigned Inherited : 1;\n  unsigned IsPackExpansion : 1;\n  unsigned Implicit : 1;\n  // FIXME: These are properties of the attribute kind, not state for this\n  // instance of the attribute.\n  unsigned IsLateParsed : 1;\n  unsigned InheritEvenIfAlreadyPresent : 1;\n\n  void *operator new(size_t bytes) noexcept {\n    llvm_unreachable(\"Attrs cannot be allocated with regular 'new'.\");\n  }\n  void operator delete(void *data) noexcept {\n    llvm_unreachable(\"Attrs cannot be released with regular 'delete'.\");\n  }\n\npublic:\n  // Forward so that the regular new and delete do not hide global ones.\n  void *operator new(size_t Bytes, ASTContext &C,\n                     size_t Alignment = 8) noexcept {\n    return ::operator new(Bytes, C, Alignment);\n  }\n  void operator delete(void *Ptr, ASTContext &C, size_t Alignment) noexcept {\n    return ::operator delete(Ptr, C, Alignment);\n  }\n\nprotected:\n  Attr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n       attr::Kind AK, bool IsLateParsed)\n      : AttributeCommonInfo(CommonInfo), AttrKind(AK), Inherited(false),\n        IsPackExpansion(false), Implicit(false), IsLateParsed(IsLateParsed),\n        InheritEvenIfAlreadyPresent(false) {}\n\npublic:\n  attr::Kind getKind() const { return static_cast<attr::Kind>(AttrKind); }\n\n  unsigned getSpellingListIndex() const {\n    return getAttributeSpellingListIndex();\n  }\n  const char *getSpelling() const;\n\n  SourceLocation getLocation() const { return getRange().getBegin(); }\n\n  bool isInherited() const { return Inherited; }\n\n  /// Returns true if the attribute has been implicitly created instead\n  /// of explicitly written by the user.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I) { Implicit = I; }\n\n  void setPackExpansion(bool PE) { IsPackExpansion = PE; }\n  bool isPackExpansion() const { return IsPackExpansion; }\n\n  // Clone this attribute.\n  Attr *clone(ASTContext &C) const;\n\n  bool isLateParsed() const { return IsLateParsed; }\n\n  // Pretty print this attribute.\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  static StringRef getDocumentation(attr::Kind);\n};\n\nclass TypeAttr : public Attr {\nprotected:\n  TypeAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstTypeAttr &&\n           A->getKind() <= attr::LastTypeAttr;\n  }\n};\n\nclass StmtAttr : public Attr {\nprotected:\n  StmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstStmtAttr &&\n           A->getKind() <= attr::LastStmtAttr;\n  }\n};\n\nclass InheritableAttr : public Attr {\nprotected:\n  InheritableAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                  attr::Kind AK, bool IsLateParsed,\n                  bool InheritEvenIfAlreadyPresent)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {\n    this->InheritEvenIfAlreadyPresent = InheritEvenIfAlreadyPresent;\n  }\n\npublic:\n  void setInherited(bool I) { Inherited = I; }\n\n  /// Should this attribute be inherited from a prior declaration even if it's\n  /// explicitly provided in the current declaration?\n  bool shouldInheritEvenIfAlreadyPresent() const {\n    return InheritEvenIfAlreadyPresent;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableAttr &&\n           A->getKind() <= attr::LastInheritableAttr;\n  }\n};\n\nclass DeclOrStmtAttr : public InheritableAttr {\nprotected:\n  DeclOrStmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                 attr::Kind AK, bool IsLateParsed,\n                 bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstDeclOrStmtAttr &&\n           A->getKind() <= attr::LastDeclOrStmtAttr;\n  }\n};\n\nclass InheritableParamAttr : public InheritableAttr {\nprotected:\n  InheritableParamAttr(ASTContext &Context,\n                       const AttributeCommonInfo &CommonInfo, attr::Kind AK,\n                       bool IsLateParsed, bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableParamAttr &&\n           A->getKind() <= attr::LastInheritableParamAttr;\n  }\n};\n\nclass HLSLAnnotationAttr : public InheritableAttr {\nprotected:\n  HLSLAnnotationAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                     attr::Kind AK, bool IsLateParsed,\n                     bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstHLSLAnnotationAttr &&\n           A->getKind() <= attr::LastHLSLAnnotationAttr;\n  }\n};\n\n/// A parameter attribute which changes the argument-passing ABI rule\n/// for the parameter.\nclass ParameterABIAttr : public InheritableParamAttr {\nprotected:\n  ParameterABIAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                   attr::Kind AK, bool IsLateParsed,\n                   bool InheritEvenIfAlreadyPresent)\n      : InheritableParamAttr(Context, CommonInfo, AK, IsLateParsed,\n                             InheritEvenIfAlreadyPresent) {}\n\npublic:\n  ParameterABI getABI() const {\n    switch (getKind()) {\n    case attr::SwiftContext:\n      return ParameterABI::SwiftContext;\n    case attr::SwiftAsyncContext:\n      return ParameterABI::SwiftAsyncContext;\n    case attr::SwiftErrorResult:\n      return ParameterABI::SwiftErrorResult;\n    case attr::SwiftIndirectResult:\n      return ParameterABI::SwiftIndirectResult;\n    default:\n      llvm_unreachable(\"bad parameter ABI attribute kind\");\n    }\n  }\n\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstParameterABIAttr &&\n           A->getKind() <= attr::LastParameterABIAttr;\n   }\n};\n\n/// A single parameter index whose accessors require each use to make explicit\n/// the parameter index encoding needed.\nclass ParamIdx {\n  // Idx is exposed only via accessors that specify specific encodings.\n  unsigned Idx : 30;\n  unsigned HasThis : 1;\n  unsigned IsValid : 1;\n\n  void assertComparable(const ParamIdx &I) const {\n    assert(isValid() && I.isValid() &&\n           \"ParamIdx must be valid to be compared\");\n    // It's possible to compare indices from separate functions, but so far\n    // it's not proven useful.  Moreover, it might be confusing because a\n    // comparison on the results of getASTIndex might be inconsistent with a\n    // comparison on the ParamIdx objects themselves.\n    assert(HasThis == I.HasThis &&\n           \"ParamIdx must be for the same function to be compared\");\n  }\n\npublic:\n  /// Construct an invalid parameter index (\\c isValid returns false and\n  /// accessors fail an assert).\n  ParamIdx() : Idx(0), HasThis(false), IsValid(false) {}\n\n  /// \\param Idx is the parameter index as it is normally specified in\n  /// attributes in the source: one-origin including any C++ implicit this\n  /// parameter.\n  ///\n  /// \\param D is the declaration containing the parameters.  It is used to\n  /// determine if there is a C++ implicit this parameter.\n  ParamIdx(unsigned Idx, const Decl *D)\n      : Idx(Idx), HasThis(false), IsValid(true) {\n    assert(Idx >= 1 && \"Idx must be one-origin\");\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      HasThis = FD->isCXXInstanceMember();\n  }\n\n  /// A type into which \\c ParamIdx can be serialized.\n  ///\n  /// A static assertion that it's of the correct size follows the \\c ParamIdx\n  /// class definition.\n  typedef uint32_t SerialType;\n\n  /// Produce a representation that can later be passed to \\c deserialize to\n  /// construct an equivalent \\c ParamIdx.\n  SerialType serialize() const {\n    return *reinterpret_cast<const SerialType *>(this);\n  }\n\n  /// Construct from a result from \\c serialize.\n  static ParamIdx deserialize(SerialType S) {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC7 and earlier.\n    void *ParamIdxPtr = static_cast<void *>(&S);\n    ParamIdx P(*static_cast<ParamIdx *>(ParamIdxPtr));\n    assert((!P.IsValid || P.Idx >= 1) && \"valid Idx must be one-origin\");\n    return P;\n  }\n\n  /// Is this parameter index valid?\n  bool isValid() const { return IsValid; }\n\n  /// Get the parameter index as it would normally be encoded for attributes at\n  /// the source level of representation: one-origin including any C++ implicit\n  /// this parameter.\n  ///\n  /// This encoding thus makes sense for diagnostics, pretty printing, and\n  /// constructing new attributes from a source-like specification.\n  unsigned getSourceIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    return Idx;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the AST level\n  /// of representation: zero-origin not including any C++ implicit this\n  /// parameter.\n  ///\n  /// This is the encoding primarily used in Sema.  However, in diagnostics,\n  /// Sema uses \\c getSourceIndex instead.\n  unsigned getASTIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 + HasThis &&\n           \"stored index must be base-1 and not specify C++ implicit this\");\n    return Idx - 1 - HasThis;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the LLVM level\n  /// of representation: zero-origin including any C++ implicit this parameter.\n  ///\n  /// This is the encoding primarily used in CodeGen.\n  unsigned getLLVMIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 && \"stored index must be base-1\");\n    return Idx - 1;\n  }\n\n  bool operator==(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx == I.Idx;\n  }\n  bool operator!=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx != I.Idx;\n  }\n  bool operator<(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx < I.Idx;\n  }\n  bool operator>(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx > I.Idx;\n  }\n  bool operator<=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx <= I.Idx;\n  }\n  bool operator>=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx >= I.Idx;\n  }\n};\n\nstatic_assert(sizeof(ParamIdx) == sizeof(ParamIdx::SerialType),\n              \"ParamIdx does not fit its serialization type\");\n\n#include \"clang/AST/Attrs.inc\"\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const Attr *At) {\n  DB.AddTaggedVal(reinterpret_cast<uint64_t>(At), DiagnosticsEngine::ak_attr);\n  return DB;\n}\n}",
  "id": "BLOCK-CPP-23180",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Attr.h",
  "source_line": 33,
  "validation_status": "validated"
}