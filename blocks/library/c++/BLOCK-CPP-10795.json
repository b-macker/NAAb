{
  "code": "{\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// The common name of these declarations.\n  DeclarationNameInfo NameInfo;\n\n  /// The nested-name-specifier that qualifies the name, if any.\n  NestedNameSpecifierLoc QualifierLoc;\n\nprotected:\n  OverloadExpr(StmtClass SC, const ASTContext &Context,\n               NestedNameSpecifierLoc QualifierLoc,\n               SourceLocation TemplateKWLoc,\n               const DeclarationNameInfo &NameInfo,\n               const TemplateArgumentListInfo *TemplateArgs,\n               UnresolvedSetIterator Begin, UnresolvedSetIterator End,\n               bool KnownDependent, bool KnownInstantiationDependent,\n               bool KnownContainsUnexpandedParameterPack);\n\n  OverloadExpr(StmtClass SC, EmptyShell Empty, unsigned NumResults,\n               bool HasTemplateKWAndArgsInfo);\n\n  /// Return the results. Defined after UnresolvedMemberExpr.\n  inline DeclAccessPair *getTrailingResults();\n  const DeclAccessPair *getTrailingResults() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingResults();\n  }\n\n  /// Return the optional template keyword and arguments info.\n  /// Defined after UnresolvedMemberExpr.\n  inline ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo();\n  const ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo() const {\n    return const_cast<OverloadExpr *>(this)\n        ->getTrailingASTTemplateKWAndArgsInfo();\n  }\n\n  /// Return the optional template arguments. Defined after\n  /// UnresolvedMemberExpr.\n  inline TemplateArgumentLoc *getTrailingTemplateArgumentLoc();\n  const TemplateArgumentLoc *getTrailingTemplateArgumentLoc() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return OverloadExprBits.HasTemplateKWAndArgsInfo;\n  }\n\npublic:\n  struct FindResult {\n    OverloadExpr *Expression;\n    bool IsAddressOfOperand;\n    bool HasFormOfMemberPointer;\n  };\n\n  /// Finds the overloaded expression in the given expression \\p E of\n  /// OverloadTy.\n  ///\n  /// \\return the expression (which must be there) and true if it has\n  /// the particular form of a member pointer expression\n  static FindResult find(Expr *E) {\n    assert(E->getType()->isSpecificBuiltinType(BuiltinType::Overload));\n\n    FindResult Result;\n\n    E = E->IgnoreParens();\n    if (isa<UnaryOperator>(E)) {\n      assert(cast<UnaryOperator>(E)->getOpcode() == UO_AddrOf);\n      E = cast<UnaryOperator>(E)->getSubExpr();\n      auto *Ovl = cast<OverloadExpr>(E->IgnoreParens());\n\n      Result.HasFormOfMemberPointer = (E == Ovl && Ovl->getQualifier());\n      Result.IsAddressOfOperand = true;\n      Result.Expression = Ovl;\n    } else {\n      Result.HasFormOfMemberPointer = false;\n      Result.IsAddressOfOperand = false;\n      Result.Expression = cast<OverloadExpr>(E);\n    }\n\n    return Result;\n  }\n\n  /// Gets the naming class of this lookup, if any.\n  /// Defined after UnresolvedMemberExpr.\n  inline CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<OverloadExpr *>(this)->getNamingClass();\n  }\n\n  using decls_iterator = UnresolvedSetImpl::iterator;\n\n  decls_iterator decls_begin() const {\n    return UnresolvedSetIterator(getTrailingResults());\n  }\n  decls_iterator decls_end() const {\n    return UnresolvedSetIterator(getTrailingResults() + getNumDecls());\n  }\n  llvm::iterator_range<decls_iterator> decls() const {\n    return llvm::make_range(decls_begin(), decls_end());\n  }\n\n  /// Gets the number of declarations in the unresolved set.\n  unsigned getNumDecls() const { return OverloadExprBits.NumResults; }\n\n  /// Gets the full name info.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the name looked up.\n  DeclarationName getName() const { return NameInfo.getName(); }\n\n  /// Gets the location of the name.\n  SourceLocation getNameLoc() const { return NameInfo.getLoc(); }\n\n  /// Fetches the nested-name qualifier, if one was given.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Fetches the nested-name qualifier with source-location\n  /// information, if one was given.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->RAngleLoc;\n  }\n\n  /// Determines whether the name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this expression had explicit template arguments.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  TemplateArgumentLoc const *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingASTTemplateKWAndArgsInfo()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Copies the template arguments into the given structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingASTTemplateKWAndArgsInfo()->copyInto(getTemplateArgs(), List);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedLookupExprClass ||\n           T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n}",
  "id": "BLOCK-CPP-10795",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 2962,
  "validation_status": "validated"
}