{
  "code": "{\n\nclass FileSystemStatCache;\n\n/// Implements support for file system lookup, file system caching,\n/// and directory search management.\n///\n/// This also handles more advanced properties, such as uniquing files based\n/// on \"inode\", so that a file with two names (e.g. symlinked) will be treated\n/// as a single file.\n///\nclass FileManager : public RefCountedBase<FileManager> {\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS;\n  FileSystemOptions FileSystemOpts;\n  llvm::SpecificBumpPtrAllocator<FileEntry> FilesAlloc;\n  llvm::SpecificBumpPtrAllocator<DirectoryEntry> DirsAlloc;\n\n  /// Cache for existing real directories.\n  llvm::DenseMap<llvm::sys::fs::UniqueID, DirectoryEntry *> UniqueRealDirs;\n\n  /// Cache for existing real files.\n  llvm::DenseMap<llvm::sys::fs::UniqueID, FileEntry *> UniqueRealFiles;\n\n  /// The virtual directories that we have allocated.\n  ///\n  /// For each virtual file (e.g. foo/bar/baz.cpp), we add all of its parent\n  /// directories (foo/ and foo/bar/) here.\n  SmallVector<DirectoryEntry *, 4> VirtualDirectoryEntries;\n  /// The virtual files that we have allocated.\n  SmallVector<FileEntry *, 4> VirtualFileEntries;\n\n  /// A set of files that bypass the maps and uniquing.  They can have\n  /// conflicting filenames.\n  SmallVector<FileEntry *, 0> BypassFileEntries;\n\n  /// A cache that maps paths to directory entries (either real or\n  /// virtual) we have looked up, or an error that occurred when we looked up\n  /// the directory.\n  ///\n  /// The actual Entries for real directories/files are\n  /// owned by UniqueRealDirs/UniqueRealFiles above, while the Entries\n  /// for virtual directories/files are owned by\n  /// VirtualDirectoryEntries/VirtualFileEntries above.\n  ///\n  llvm::StringMap<llvm::ErrorOr<DirectoryEntry &>, llvm::BumpPtrAllocator>\n  SeenDirEntries;\n\n  /// A cache that maps paths to file entries (either real or\n  /// virtual) we have looked up, or an error that occurred when we looked up\n  /// the file.\n  ///\n  /// \\see SeenDirEntries\n  llvm::StringMap<llvm::ErrorOr<FileEntryRef::MapValue>, llvm::BumpPtrAllocator>\n      SeenFileEntries;\n\n  /// A mirror of SeenFileEntries to give fake answers for getBypassFile().\n  ///\n  /// Don't bother hooking up a BumpPtrAllocator. This should be rarely used,\n  /// and only on error paths.\n  std::unique_ptr<llvm::StringMap<llvm::ErrorOr<FileEntryRef::MapValue>>>\n      SeenBypassFileEntries;\n\n  /// The file entry for stdin, if it has been accessed through the FileManager.\n  OptionalFileEntryRef STDIN;\n\n  /// The canonical names of files and directories .\n  llvm::DenseMap<const void *, llvm::StringRef> CanonicalNames;\n\n  /// Storage for canonical names that we have computed.\n  llvm::BumpPtrAllocator CanonicalNameStorage;\n\n  /// Each FileEntry we create is assigned a unique ID #.\n  ///\n  unsigned NextFileUID;\n\n  // Caching.\n  std::unique_ptr<FileSystemStatCache> StatCache;\n\n  std::error_code getStatValue(StringRef Path, llvm::vfs::Status &Status,\n                               bool isFile,\n                               std::unique_ptr<llvm::vfs::File> *F);\n\n  /// Add all ancestors of the given path (pointing to either a file\n  /// or a directory) as virtual directories.\n  void addAncestorsAsVirtualDirs(StringRef Path);\n\n  /// Fills the RealPathName in file entry.\n  void fillRealPathName(FileEntry *UFE, llvm::StringRef FileName);\n\npublic:\n  /// Construct a file manager, optionally with a custom VFS.\n  ///\n  /// \\param FS if non-null, the VFS to use.  Otherwise uses\n  /// llvm::vfs::getRealFileSystem().\n  FileManager(const FileSystemOptions &FileSystemOpts,\n              IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS = nullptr);\n  ~FileManager();\n\n  /// Installs the provided FileSystemStatCache object within\n  /// the FileManager.\n  ///\n  /// Ownership of this object is transferred to the FileManager.\n  ///\n  /// \\param statCache the new stat cache to install. Ownership of this\n  /// object is transferred to the FileManager.\n  void setStatCache(std::unique_ptr<FileSystemStatCache> statCache);\n\n  /// Removes the FileSystemStatCache object from the manager.\n  void clearStatCache();\n\n  /// Returns the number of unique real file entries cached by the file manager.\n  size_t getNumUniqueRealFiles() const { return UniqueRealFiles.size(); }\n\n  /// Lookup, cache, and verify the specified directory (real or\n  /// virtual).\n  ///\n  /// This returns a \\c std::error_code if there was an error reading the\n  /// directory. On success, returns the reference to the directory entry\n  /// together with the exact path that was used to access a file by a\n  /// particular call to getDirectoryRef.\n  ///\n  /// \\param CacheFailure If true and the file does not exist, we'll cache\n  /// the failure to find this file.\n  llvm::Expected<DirectoryEntryRef> getDirectoryRef(StringRef DirName,\n                                                    bool CacheFailure = true);\n\n  /// Get a \\c DirectoryEntryRef if it exists, without doing anything on error.\n  OptionalDirectoryEntryRef getOptionalDirectoryRef(StringRef DirName,\n                                                    bool CacheFailure = true) {\n    return llvm::expectedToOptional(getDirectoryRef(DirName, CacheFailure));\n  }\n\n  /// Lookup, cache, and verify the specified directory (real or\n  /// virtual).\n  ///\n  /// This function is deprecated and will be removed at some point in the\n  /// future, new clients should use\n  ///  \\c getDirectoryRef.\n  ///\n  /// This returns a \\c std::error_code if there was an error reading the\n  /// directory. If there is no error, the DirectoryEntry is guaranteed to be\n  /// non-NULL.\n  ///\n  /// \\param CacheFailure If true and the file does not exist, we'll cache\n  /// the failure to find this file.\n  llvm::ErrorOr<const DirectoryEntry *>\n  getDirectory(StringRef DirName, bool CacheFailure = true);\n\n  /// Lookup, cache, and verify the specified file (real or\n  /// virtual).\n  ///\n  /// This function is deprecated and will be removed at some point in the\n  /// future, new clients should use\n  ///  \\c getFileRef.\n  ///\n  /// This returns a \\c std::error_code if there was an error loading the file.\n  /// If there is no error, the FileEntry is guaranteed to be non-NULL.\n  ///\n  /// \\param OpenFile if true and the file exists, it will be opened.\n  ///\n  /// \\param CacheFailure If true and the file does not exist, we'll cache\n  /// the failure to find this file.\n  llvm::ErrorOr<const FileEntry *>\n  getFile(StringRef Filename, bool OpenFile = false, bool CacheFailure = true);\n\n  /// Lookup, cache, and verify the specified file (real or virtual). Return the\n  /// reference to the file entry together with the exact path that was used to\n  /// access a file by a particular call to getFileRef. If the underlying VFS is\n  /// a redirecting VFS that uses external file names, the returned FileEntryRef\n  /// will use the external name instead of the filename that was passed to this\n  /// method.\n  ///\n  /// This returns a \\c std::error_code if there was an error loading the file,\n  /// or a \\c FileEntryRef otherwise.\n  ///\n  /// \\param OpenFile if true and the file exists, it will be opened.\n  ///\n  /// \\param CacheFailure If true and the file does not exist, we'll cache\n  /// the failure to find this file.\n  llvm::Expected<FileEntryRef> getFileRef(StringRef Filename,\n                                          bool OpenFile = false,\n                                          bool CacheFailure = true);\n\n  /// Get the FileEntryRef for stdin, returning an error if stdin cannot be\n  /// read.\n  ///\n  /// This reads and caches stdin before returning. Subsequent calls return the\n  /// same file entry, and a reference to the cached input is returned by calls\n  /// to getBufferForFile.\n  llvm::Expected<FileEntryRef> getSTDIN();\n\n  /// Get a FileEntryRef if it exists, without doing anything on error.\n  OptionalFileEntryRef getOptionalFileRef(StringRef Filename,\n                                          bool OpenFile = false,\n                                          bool CacheFailure = true) {\n    return llvm::expectedToOptional(\n        getFileRef(Filename, OpenFile, CacheFailure));\n  }\n\n  /// Returns the current file system options\n  FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }\n  const FileSystemOptions &getFileSystemOpts() const { return FileSystemOpts; }\n\n  llvm::vfs::FileSystem &getVirtualFileSystem() const { return *FS; }\n  llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>\n  getVirtualFileSystemPtr() const {\n    return FS;\n  }\n\n  void setVirtualFileSystem(IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS) {\n    this->FS = std::move(FS);\n  }\n\n  /// Retrieve a file entry for a \"virtual\" file that acts as\n  /// if there were a file with the given name on disk.\n  ///\n  /// The file itself is not accessed.\n  FileEntryRef getVirtualFileRef(StringRef Filename, off_t Size,\n                                 time_t ModificationTime);\n\n  const FileEntry *getVirtualFile(StringRef Filename, off_t Size,\n                                  time_t ModificationTime);\n\n  /// Retrieve a FileEntry that bypasses VFE, which is expected to be a virtual\n  /// file entry, to access the real file.  The returned FileEntry will have\n  /// the same filename as FE but a different identity and its own stat.\n  ///\n  /// This should be used only for rare error recovery paths because it\n  /// bypasses all mapping and uniquing, blindly creating a new FileEntry.\n  /// There is no attempt to deduplicate these; if you bypass the same file\n  /// twice, you get two new file entries.\n  OptionalFileEntryRef getBypassFile(FileEntryRef VFE);\n\n  /// Open the specified file as a MemoryBuffer, returning a new\n  /// MemoryBuffer if successful, otherwise returning null.\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFile(const FileEntry *Entry, bool isVolatile = false,\n                   bool RequiresNullTerminator = true);\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFile(StringRef Filename, bool isVolatile = false,\n                   bool RequiresNullTerminator = true) {\n    return getBufferForFileImpl(Filename, /*FileSize=*/-1, isVolatile,\n                                RequiresNullTerminator);\n  }\n\nprivate:\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFileImpl(StringRef Filename, int64_t FileSize, bool isVolatile,\n                       bool RequiresNullTerminator);\n\npublic:\n  /// Get the 'stat' information for the given \\p Path.\n  ///\n  /// If the path is relative, it will be resolved against the WorkingDir of the\n  /// FileManager's FileSystemOptions.\n  ///\n  /// \\returns a \\c std::error_code describing an error, if there was one\n  std::error_code getNoncachedStatValue(StringRef Path,\n                                        llvm::vfs::Status &Result);\n\n  /// If path is not absolute and FileSystemOptions set the working\n  /// directory, the path is modified to be relative to the given\n  /// working directory.\n  /// \\returns true if \\c path changed.\n  bool FixupRelativePath(SmallVectorImpl<char> &path) const;\n\n  /// Makes \\c Path absolute taking into account FileSystemOptions and the\n  /// working directory option.\n  /// \\returns true if \\c Path changed to absolute.\n  bool makeAbsolutePath(SmallVectorImpl<char> &Path) const;\n\n  /// Produce an array mapping from the unique IDs assigned to each\n  /// file to the corresponding FileEntry pointer.\n  void GetUniqueIDMapping(\n                    SmallVectorImpl<const FileEntry *> &UIDToFiles) const;\n\n  /// Retrieve the canonical name for a given directory.\n  ///\n  /// This is a very expensive operation, despite its results being cached,\n  /// and should only be used when the physical layout of the file system is\n  /// required, which is (almost) never.\n  StringRef getCanonicalName(DirectoryEntryRef Dir);\n\n  /// Retrieve the canonical name for a given file.\n  ///\n  /// This is a very expensive operation, despite its results being cached,\n  /// and should only be used when the physical layout of the file system is\n  /// required, which is (almost) never.\n  StringRef getCanonicalName(const FileEntry *File);\n\n  void PrintStats() const;\n};\n\n}",
  "id": "BLOCK-CPP-16395",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/FileManager.h",
  "source_line": 42,
  "validation_status": "validated"
}