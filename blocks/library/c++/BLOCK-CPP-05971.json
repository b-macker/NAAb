{
  "code": "{\n\n// Returns the number of 32-bit blocks needed to contain the given number of\n// bits.\nconstexpr size_t SeedBitsToBlocks(size_t seed_size) {\n  return (seed_size + 31) / 32;\n}\n\n// Amount of entropy (measured in bits) used to instantiate a Seed Sequence,\n// with which to create a URBG.\nconstexpr size_t kEntropyBitsNeeded = 256;\n\n// Amount of entropy (measured in 32-bit blocks) used to instantiate a Seed\n// Sequence, with which to create a URBG.\nconstexpr size_t kEntropyBlocksNeeded =\n    random_internal::SeedBitsToBlocks(kEntropyBitsNeeded);\n\nstatic_assert(kEntropyBlocksNeeded > 0,\n              \"Entropy used to seed URBGs must be nonzero.\");\n\n// Attempts to fill a span of uint32_t-values using an OS-provided source of\n// true entropy (eg. /dev/urandom) into an array of uint32_t blocks of data. The\n// resulting array may be used to initialize an instance of a class conforming\n// to the C++ Standard \"Seed Sequence\" concept [rand.req.seedseq].\n//\n// If values.data() == nullptr, the behavior is undefined.\nABSL_MUST_USE_RESULT\nbool ReadSeedMaterialFromOSEntropy(absl::Span<uint32_t> values);\n\n// Attempts to fill a span of uint32_t-values using variates generated by an\n// existing instance of a class conforming to the C++ Standard \"Uniform Random\n// Bit Generator\" concept [rand.req.urng]. The resulting data may be used to\n// initialize an instance of a class conforming to the C++ Standard\n// \"Seed Sequence\" concept [rand.req.seedseq].\n//\n// If urbg == nullptr or values.data() == nullptr, the behavior is undefined.\ntemplate <typename URBG>\nABSL_MUST_USE_RESULT bool ReadSeedMaterialFromURBG(\n    URBG* urbg, absl::Span<uint32_t> values) {\n  random_internal::FastUniformBits<uint32_t> distr;\n\n  assert(urbg != nullptr && values.data() != nullptr);\n  if (urbg == nullptr || values.data() == nullptr) {\n    return false;\n  }\n\n  for (uint32_t& seed_value : values) {\n    seed_value = distr(*urbg);\n  }\n  return true;\n}\n\n// Mixes given sequence of values with into given sequence of seed material.\n// Time complexity of this function is O(sequence.size() *\n// seed_material.size()).\n//\n// Algorithm is based on code available at\n// https://gist.github.com/imneme/540829265469e673d045\n// by Melissa O'Neill.\nvoid MixIntoSeedMaterial(absl::Span<const uint32_t> sequence,\n                         absl::Span<uint32_t> seed_material);\n\n// Returns salt value.\n//\n// Salt is obtained only once and stored in static variable.\n//\n// May return empty value if optaining the salt was not possible.\nabsl::optional<uint32_t> GetSaltMaterial();\n\n}",
  "id": "BLOCK-CPP-05971",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/seed_material.h",
  "source_line": 31,
  "validation_status": "validated"
}