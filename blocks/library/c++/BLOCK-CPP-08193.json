{
  "code": "{\n  ///   // C is implicitly declared here as a synonym for the class name.\n  /// };\n  ///\n  /// C::C c; // same as \"C c;\"\n  /// \\endcode\n  bool isInjectedClassName() const;\n\n  /// Determine whether this record is a class describing a lambda\n  /// function object.\n  bool isLambda() const;\n\n  /// Determine whether this record is a record for captured variables in\n  /// CapturedStmt construct.\n  bool isCapturedRecord() const;\n\n  /// Mark the record as a record for captured variables in CapturedStmt\n  /// construct.\n  void setCapturedRecord();\n\n  /// Returns the RecordDecl that actually defines\n  ///  this struct/union/class.  When determining whether or not a\n  ///  struct/union/class is completely defined, one should use this\n  ///  method as opposed to 'isCompleteDefinition'.\n  ///  'isCompleteDefinition' indicates whether or not a specific\n  ///  RecordDecl is a completed definition, not whether or not the\n  ///  record type is defined.  This method returns NULL if there is\n  ///  no RecordDecl that defines the struct/union/tag.\n  RecordDecl *getDefinition() const {\n    return cast_or_null<RecordDecl>(TagDecl::getDefinition());\n  }\n\n  /// Returns whether this record is a union, or contains (at any nesting level)\n  /// a union member. This is used by CMSE to warn about possible information\n  /// leaks.\n  bool isOrContainsUnion() const;\n\n  // Iterator access to field members. The field iterator only visits\n  // the non-static data members of this class, ignoring any static\n  // data members, functions, constructors, destructors, etc.\n  using field_iterator = specific_decl_iterator<FieldDecl>;\n  using field_range = llvm::iterator_range<specific_decl_iterator<FieldDecl>>;\n\n  field_range fields() const { return field_range(field_begin(), field_end()); }\n  field_iterator field_begin() const;\n\n  field_iterator field_end() const {\n    return field_iterator(decl_iterator());\n  }\n\n  // Whether there are any fields (non-static data members) in this record.\n  bool field_empty() const {\n    return field_begin() == field_end();\n  }\n\n  /// Note that the definition of this type is now complete.\n  virtual void completeDefinition();\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstRecord && K <= lastRecord;\n  }\n\n  /// Get whether or not this is an ms_struct which can\n  /// be turned on with an attribute, pragma, or -mms-bitfields\n  /// commandline option.\n  bool isMsStruct(const ASTContext &C) const;\n\n  /// Whether we are allowed to insert extra padding between fields.\n  /// These padding are added to help AddressSanitizer detect\n  /// intra-object-overflow bugs.\n  bool mayInsertExtraPadding(bool EmitRemark = false) const;\n\n  /// Finds the first data member which has a name.\n  /// nullptr is returned if no named data member exists.\n  const FieldDecl *findFirstNamedDataMember() const;\n\n  /// Get precomputed ODRHash or add a new one.\n  unsigned getODRHash();\n\nprivate:\n  /// Deserialize just the fields.\n  void LoadFieldsFromExternalStorage() const;\n\n  /// True if a valid hash is stored in ODRHash.\n  bool hasODRHash() const { return RecordDeclBits.ODRHash; }\n  void setODRHash(unsigned Hash) { RecordDeclBits.ODRHash = Hash; }\n}",
  "id": "BLOCK-CPP-08193",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Decl.h",
  "source_line": 4212,
  "validation_status": "validated"
}