{
  "code": "{\n  //   ABSL_CONST_INIT absl::Mutex mu(absl::kConstInit);\n  //   }\n  explicit constexpr Mutex(absl::ConstInitType);\n\n  ~Mutex();\n\n  // Mutex::Lock()\n  //\n  // Blocks the calling thread, if necessary, until this `Mutex` is free, and\n  // then acquires it exclusively. (This lock is also known as a \"write lock.\")\n  void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION();\n\n  // Mutex::Unlock()\n  //\n  // Releases this `Mutex` and returns it from the exclusive/write state to the\n  // free state. Calling thread must hold the `Mutex` exclusively.\n  void Unlock() ABSL_UNLOCK_FUNCTION();\n\n  // Mutex::TryLock()\n  //\n  // If the mutex can be acquired without blocking, does so exclusively and\n  // returns `true`. Otherwise, returns `false`. Returns `true` with high\n  // probability if the `Mutex` was free.\n  bool TryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true);\n\n  // Mutex::AssertHeld()\n  //\n  // Require that the mutex be held exclusively (write mode) by this thread.\n  //\n  // If the mutex is not currently held by this thread, this function may report\n  // an error (typically by crashing with a diagnostic) or it may do nothing.\n  // This function is intended only as a tool to assist debugging; it doesn't\n  // guarantee correctness.\n  void AssertHeld() const ABSL_ASSERT_EXCLUSIVE_LOCK();\n\n  // ---------------------------------------------------------------------------\n  // Reader-Writer Locking\n  // ---------------------------------------------------------------------------\n\n  // A Mutex can also be used as a starvation-free reader-writer lock.\n  // Neither read-locks nor write-locks are reentrant/recursive to avoid\n  // potential client programming errors.\n  //\n  // The Mutex API provides `Writer*()` aliases for the existing `Lock()`,\n  // `Unlock()` and `TryLock()` methods for use within applications mixing\n  // reader/writer locks. Using `Reader*()` and `Writer*()` operations in this\n  // manner can make locking behavior clearer when mixing read and write modes.\n  //\n  // Introducing reader locks necessarily complicates the `Mutex` state\n  // machine somewhat. The table below illustrates the allowed state transitions\n  // of a mutex in such cases. Note that ReaderLock() may block even if the lock\n  // is held in shared mode; this occurs when another thread is blocked on a\n  // call to WriterLock().\n  //\n  // ---------------------------------------------------------------------------\n  //     Operation: WriterLock() Unlock()  ReaderLock()           ReaderUnlock()\n  // ---------------------------------------------------------------------------\n  // State\n  // ---------------------------------------------------------------------------\n  // Free           Exclusive    invalid   Shared(1)              invalid\n  // Shared(1)      blocks       invalid   Shared(2) or blocks    Free\n  // Shared(n) n>1  blocks       invalid   Shared(n+1) or blocks  Shared(n-1)\n  // Exclusive      blocks       Free      blocks                 invalid\n  // ---------------------------------------------------------------------------\n  //\n  // In comments below, \"shared\" refers to a state of Shared(n) for any n > 0.\n\n  // Mutex::ReaderLock()\n  //\n  // Blocks the calling thread, if necessary, until this `Mutex` is either free,\n  // or in shared mode, and then acquires a share of it. Note that\n  // `ReaderLock()` will block if some other thread has an exclusive/writer lock\n  // on the mutex.\n\n  void ReaderLock() ABSL_SHARED_LOCK_FUNCTION();\n\n  // Mutex::ReaderUnlock()\n  //\n  // Releases a read share of this `Mutex`. `ReaderUnlock` may return a mutex to\n  // the free state if this thread holds the last reader lock on the mutex. Note\n  // that you cannot call `ReaderUnlock()` on a mutex held in write mode.\n  void ReaderUnlock() ABSL_UNLOCK_FUNCTION();\n\n  // Mutex::ReaderTryLock()\n  //\n  // If the mutex can be acquired without blocking, acquires this mutex for\n  // shared access and returns `true`. Otherwise, returns `false`. Returns\n  // `true` with high probability if the `Mutex` was free or shared.\n  bool ReaderTryLock() ABSL_SHARED_TRYLOCK_FUNCTION(true);\n\n  // Mutex::AssertReaderHeld()\n  //\n  // Require that the mutex be held at least in shared mode (read mode) by this\n  // thread.\n  //\n  // If the mutex is not currently held by this thread, this function may report\n  // an error (typically by crashing with a diagnostic) or it may do nothing.\n  // This function is intended only as a tool to assist debugging; it doesn't\n  // guarantee correctness.\n  void AssertReaderHeld() const ABSL_ASSERT_SHARED_LOCK();\n\n  // Mutex::WriterLock()\n  // Mutex::WriterUnlock()\n  // Mutex::WriterTryLock()\n  //\n  // Aliases for `Mutex::Lock()`, `Mutex::Unlock()`, and `Mutex::TryLock()`.\n  //\n  // These methods may be used (along with the complementary `Reader*()`\n  // methods) to distinguish simple exclusive `Mutex` usage (`Lock()`,\n  // etc.) from reader/writer lock usage.\n  void WriterLock() ABSL_EXCLUSIVE_LOCK_FUNCTION() { this->Lock(); }\n\n  void WriterUnlock() ABSL_UNLOCK_FUNCTION() { this->Unlock(); }\n\n  bool WriterTryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true) {\n    return this->TryLock();\n  }\n\n  // ---------------------------------------------------------------------------\n  // Conditional Critical Regions\n  // ---------------------------------------------------------------------------\n\n  // Conditional usage of a `Mutex` can occur using two distinct paradigms:\n  //\n  //   * Use of `Mutex` member functions with `Condition` objects.\n  //   * Use of the separate `CondVar` abstraction.\n  //\n  // In general, prefer use of `Condition` and the `Mutex` member functions\n  // listed below over `CondVar`. When there are multiple threads waiting on\n  // distinctly different conditions, however, a battery of `CondVar`s may be\n  // more efficient. This section discusses use of `Condition` objects.\n  //\n  // `Mutex` contains member functions for performing lock operations only under\n  // certain conditions, of class `Condition`. For correctness, the `Condition`\n  // must return a boolean that is a pure function, only of state protected by\n  // the `Mutex`. The condition must be invariant w.r.t. environmental state\n  // such as thread, cpu id, or time, and must be `noexcept`. The condition will\n  // always be invoked with the mutex held in at least read mode, so you should\n  // not block it for long periods or sleep it on a timer.\n  //\n  // Since a condition must not depend directly on the current time, use\n  // `*WithTimeout()` member function variants to make your condition\n  // effectively true after a given duration, or `*WithDeadline()` variants to\n  // make your condition effectively true after a given time.\n  //\n  // The condition function should have no side-effects aside from debug\n  // logging; as a special exception, the function may acquire other mutexes\n  // provided it releases all those that it acquires.  (This exception was\n  // required to allow logging.)\n\n  // Mutex::Await()\n  //\n  // Unlocks this `Mutex` and blocks until simultaneously both `cond` is `true`\n  // and this `Mutex` can be reacquired, then reacquires this `Mutex` in the\n  // same mode in which it was previously held. If the condition is initially\n  // `true`, `Await()` *may* skip the release/re-acquire step.\n  //\n  // `Await()` requires that this thread holds this `Mutex` in some mode.\n  void Await(const Condition& cond) {\n    AwaitCommon(cond, synchronization_internal::KernelTimeout::Never());\n  }\n\n  // Mutex::LockWhen()\n  // Mutex::ReaderLockWhen()\n  // Mutex::WriterLockWhen()\n  //\n  // Blocks until simultaneously both `cond` is `true` and this `Mutex` can\n  // be acquired, then atomically acquires this `Mutex`. `LockWhen()` is\n  // logically equivalent to `*Lock(); Await();` though they may have different\n  // performance characteristics.\n  void LockWhen(const Condition& cond) ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    LockWhenCommon(cond, synchronization_internal::KernelTimeout::Never(),\n                   true);\n  }\n\n  void ReaderLockWhen(const Condition& cond) ABSL_SHARED_LOCK_FUNCTION() {\n    LockWhenCommon(cond, synchronization_internal::KernelTimeout::Never(),\n                   false);\n  }\n\n  void WriterLockWhen(const Condition& cond) ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    this->LockWhen(cond);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Mutex Variants with Timeouts/Deadlines\n  // ---------------------------------------------------------------------------\n\n  // Mutex::AwaitWithTimeout()\n  // Mutex::AwaitWithDeadline()\n  //\n  // Unlocks this `Mutex` and blocks until simultaneously:\n  //   - either `cond` is true or the {timeout has expired, deadline has passed}\n  //     and\n  //   - this `Mutex` can be reacquired,\n  // then reacquire this `Mutex` in the same mode in which it was previously\n  // held, returning `true` iff `cond` is `true` on return.\n  //\n  // If the condition is initially `true`, the implementation *may* skip the\n  // release/re-acquire step and return immediately.\n  //\n  // Deadlines in the past are equivalent to an immediate deadline.\n  // Negative timeouts are equivalent to a zero timeout.\n  //\n  // This method requires that this thread holds this `Mutex` in some mode.\n  bool AwaitWithTimeout(const Condition& cond, absl::Duration timeout) {\n    return AwaitCommon(cond, synchronization_internal::KernelTimeout{timeout});\n  }\n\n  bool AwaitWithDeadline(const Condition& cond, absl::Time deadline) {\n    return AwaitCommon(cond, synchronization_internal::KernelTimeout{deadline});\n  }\n\n  // Mutex::LockWhenWithTimeout()\n  // Mutex::ReaderLockWhenWithTimeout()\n  // Mutex::WriterLockWhenWithTimeout()\n  //\n  // Blocks until simultaneously both:\n  //   - either `cond` is `true` or the timeout has expired, and\n  //   - this `Mutex` can be acquired,\n  // then atomically acquires this `Mutex`, returning `true` iff `cond` is\n  // `true` on return.\n  //\n  // Negative timeouts are equivalent to a zero timeout.\n  bool LockWhenWithTimeout(const Condition& cond, absl::Duration timeout)\n      ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    return LockWhenCommon(\n        cond, synchronization_internal::KernelTimeout{timeout}, true);\n  }\n  bool ReaderLockWhenWithTimeout(const Condition& cond, absl::Duration timeout)\n      ABSL_SHARED_LOCK_FUNCTION() {\n    return LockWhenCommon(\n        cond, synchronization_internal::KernelTimeout{timeout}, false);\n  }\n  bool WriterLockWhenWithTimeout(const Condition& cond, absl::Duration timeout)\n      ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    return this->LockWhenWithTimeout(cond, timeout);\n  }\n\n  // Mutex::LockWhenWithDeadline()\n  // Mutex::ReaderLockWhenWithDeadline()\n  // Mutex::WriterLockWhenWithDeadline()\n  //\n  // Blocks until simultaneously both:\n  //   - either `cond` is `true` or the deadline has been passed, and\n  //   - this `Mutex` can be acquired,\n  // then atomically acquires this Mutex, returning `true` iff `cond` is `true`\n  // on return.\n  //\n  // Deadlines in the past are equivalent to an immediate deadline.\n  bool LockWhenWithDeadline(const Condition& cond, absl::Time deadline)\n      ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    return LockWhenCommon(\n        cond, synchronization_internal::KernelTimeout{deadline}, true);\n  }\n  bool ReaderLockWhenWithDeadline(const Condition& cond, absl::Time deadline)\n      ABSL_SHARED_LOCK_FUNCTION() {\n    return LockWhenCommon(\n        cond, synchronization_internal::KernelTimeout{deadline}, false);\n  }\n  bool WriterLockWhenWithDeadline(const Condition& cond, absl::Time deadline)\n      ABSL_EXCLUSIVE_LOCK_FUNCTION() {\n    return this->LockWhenWithDeadline(cond, deadline);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Debug Support: Invariant Checking, Deadlock Detection, Logging.\n  // ---------------------------------------------------------------------------\n\n  // Mutex::EnableInvariantDebugging()\n  //\n  // If `invariant`!=null and if invariant debugging has been enabled globally,\n  // cause `(*invariant)(arg)` to be called at moments when the invariant for\n  // this `Mutex` should hold (for example: just after acquire, just before\n  // release).\n  //\n  // The routine `invariant` should have no side-effects since it is not\n  // guaranteed how many times it will be called; it should check the invariant\n  // and crash if it does not hold. Enabling global invariant debugging may\n  // substantially reduce `Mutex` performance; it should be set only for\n  // non-production runs.  Optimization options may also disable invariant\n  // checks.\n  void EnableInvariantDebugging(void (*invariant)(void*), void* arg);\n\n  // Mutex::EnableDebugLog()\n  //\n  // Cause all subsequent uses of this `Mutex` to be logged via\n  // `ABSL_RAW_LOG(INFO)`. Log entries are tagged with `name` if no previous\n  // call to `EnableInvariantDebugging()` or `EnableDebugLog()` has been made.\n  //\n  // Note: This method substantially reduces `Mutex` performance.\n  void EnableDebugLog(const char* name);\n\n  // Deadlock detection\n\n  // Mutex::ForgetDeadlockInfo()\n  //\n  // Forget any deadlock-detection information previously gathered\n  // about this `Mutex`. Call this method in debug mode when the lock ordering\n  // of a `Mutex` changes.\n  void ForgetDeadlockInfo();\n\n  // Mutex::AssertNotHeld()\n  //\n  // Return immediately if this thread does not hold this `Mutex` in any\n  // mode; otherwise, may report an error (typically by crashing with a\n  // diagnostic), or may return immediately.\n  //\n  // Currently this check is performed only if all of:\n  //    - in debug mode\n  //    - SetMutexDeadlockDetectionMode() has been set to kReport or kAbort\n  //    - number of locks concurrently held by this thread is not large.\n  // are true.\n  void AssertNotHeld() const;\n\n  // Special cases.\n\n  // A `MuHow` is a constant that indicates how a lock should be acquired.\n  // Internal implementation detail.  Clients should ignore.\n  typedef const struct MuHowS* MuHow;\n\n  // Mutex::InternalAttemptToUseMutexInFatalSignalHandler()\n  //\n  // Causes the `Mutex` implementation to prepare itself for re-entry caused by\n  // future use of `Mutex` within a fatal signal handler. This method is\n  // intended for use only for last-ditch attempts to log crash information.\n  // It does not guarantee that attempts to use Mutexes within the handler will\n  // not deadlock; it merely makes other faults less likely.\n  //\n  // WARNING:  This routine must be invoked from a signal handler, and the\n  // signal handler must either loop forever or terminate the process.\n  // Attempts to return from (or `longjmp` out of) the signal handler once this\n  // call has been made may cause arbitrary program behaviour including\n  // crashes and deadlocks.\n  static void InternalAttemptToUseMutexInFatalSignalHandler();\n\n private:\n  std::atomic<intptr_t> mu_;  // The Mutex state.\n\n  // Post()/Wait() versus associated PerThreadSem; in class for required\n  // friendship with PerThreadSem.\n  static void IncrementSynchSem(Mutex* mu, base_internal::PerThreadSynch* w);\n  static bool DecrementSynchSem(Mutex* mu, base_internal::PerThreadSynch* w,\n                                synchronization_internal::KernelTimeout t);\n\n  // slow path acquire\n  void LockSlowLoop(SynchWaitParams* waitp, int flags);\n  // wrappers around LockSlowLoop()\n  bool LockSlowWithDeadline(MuHow how, const Condition* cond,\n                            synchronization_internal::KernelTimeout t,\n                            int flags);\n  void LockSlow(MuHow how, const Condition* cond,\n                int flags) ABSL_ATTRIBUTE_COLD;\n  // slow path release\n  void UnlockSlow(SynchWaitParams* waitp) ABSL_ATTRIBUTE_COLD;\n  // TryLock slow path.\n  bool TryLockSlow();\n  // ReaderTryLock slow path.\n  bool ReaderTryLockSlow();\n  // Common code between Await() and AwaitWithTimeout/Deadline()\n  bool AwaitCommon(const Condition& cond,\n                   synchronization_internal::KernelTimeout t);\n  bool LockWhenCommon(const Condition& cond,\n                      synchronization_internal::KernelTimeout t, bool write);\n  // Attempt to remove thread s from queue.\n  void TryRemove(base_internal::PerThreadSynch* s);\n  // Block a thread on mutex.\n  void Block(base_internal::PerThreadSynch* s);\n  // Wake a thread; return successor.\n  base_internal::PerThreadSynch* Wakeup(base_internal::PerThreadSynch* w);\n  void Dtor();\n\n  friend class CondVar;   // for access to Trans()/Fer().\n  void Trans(MuHow how);  // used for CondVar->Mutex transfer\n  void Fer(\n      base_internal::PerThreadSynch* w);  // used for CondVar->Mutex transfer\n\n  // Catch the error of writing Mutex when intending MutexLock.\n  explicit Mutex(const volatile Mutex* /*ignored*/) {}\n\n  Mutex(const Mutex&) = delete;\n  Mutex& operator=(const Mutex&) = delete;\n}",
  "id": "BLOCK-CPP-04328",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/mutex.h",
  "source_line": 169,
  "validation_status": "validated"
}