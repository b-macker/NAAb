{
  "code": "#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <optional>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\nusing namespace llvm;\nusing namespace clang;\nusing namespace tok;\nusing namespace tok;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16250_execute() {\n    {\n  const DiagnosticsEngine *DiagObj;\n  std::optional<StringRef> StoredDiagMessage;\n\npublic:\n  explicit Diagnostic(const DiagnosticsEngine *DO) : DiagObj(DO) {}\n  Diagnostic(const DiagnosticsEngine *DO, StringRef storedDiagMessage)\n      : DiagObj(DO), StoredDiagMessage(storedDiagMessage) {}\n\n  const DiagnosticsEngine *getDiags() const { return DiagObj; }\n  unsigned getID() const { return DiagObj->CurDiagID; }\n  const SourceLocation &getLocation() const { return DiagObj->CurDiagLoc; }\n  bool hasSourceManager() const { return DiagObj->hasSourceManager(); }\n  SourceManager &getSourceManager() const { return DiagObj->getSourceManager();}\n\n  unsigned getNumArgs() const { return DiagObj->DiagStorage.NumDiagArgs; }\n\n  /// Return the kind of the specified index.\n  ///\n  /// Based on the kind of argument, the accessors below can be used to get\n  /// the value.\n  ///\n  /// \\pre Idx < getNumArgs()\n  DiagnosticsEngine::ArgumentKind getArgKind(unsigned Idx) const {\n    assert(Idx < getNumArgs() && \"Argument index out of range!\");\n    return (DiagnosticsEngine::ArgumentKind)\n        DiagObj->DiagStorage.DiagArgumentsKind[Idx];\n  }\n\n  /// Return the provided argument string specified by \\p Idx.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_std_string\n  const std::string &getArgStdStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsStr[Idx];\n  }\n\n  /// Return the specified C string argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_c_string\n  const char *getArgCStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_c_string &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<const char *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified signed integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_sint\n  int64_t getArgSInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_sint &&\n           \"invalid argument accessor!\");\n    return (int64_t)DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified unsigned integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_uint\n  uint64_t getArgUInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_uint &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified IdentifierInfo argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo\n  const IdentifierInfo *getArgIdentifier(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<IdentifierInfo *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified non-string argument in an opaque form.\n  /// \\pre getArgKind(Idx) != DiagnosticsEngine::ak_std_string\n  uint64_t getRawArg(unsigned Idx) const {\n    assert(getArgKind(Idx) != DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the number of source ranges associated with this diagnostic.\n  unsigned getNumRanges() const {\n    return DiagObj->DiagStorage.DiagRanges.size();\n  }\n\n  /// \\pre Idx < getNumRanges()\n  const CharSourceRange &getRange(unsigned Idx) const {\n    assert(Idx < getNumRanges() && \"Invalid diagnostic range index!\");\n    return DiagObj->DiagStorage.DiagRanges[Idx];\n  }\n\n  /// Return an array reference for this diagnostic's ranges.\n  ArrayRef<CharSourceRange> getRanges() const {\n    return DiagObj->DiagStorage.DiagRanges;\n  }\n\n  unsigned getNumFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints.size();\n  }\n\n  const FixItHint &getFixItHint(unsigned Idx) const {\n    assert(Idx < getNumFixItHints() && \"Invalid index!\");\n    return DiagObj->DiagStorage.FixItHints[Idx];\n  }\n\n  ArrayRef<FixItHint> getFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints;\n  }\n\n  /// Format this diagnostic into a string, substituting the\n  /// formal arguments into the %0 slots.\n  ///\n  /// The result is appended onto the \\p OutStr array.\n  void FormatDiagnostic(SmallVectorImpl<char> &OutStr) const;\n\n  /// Format the given format-string into the output buffer using the\n  /// arguments stored in this diagnostic.\n  void FormatDiagnostic(const char *DiagStr, const char *DiagEnd,\n                        SmallVectorImpl<char> &OutStr) const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16250",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Diagnostic.h",
  "source_line": 1566,
  "validation_status": "validated"
}