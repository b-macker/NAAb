{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\nnamespace {\n\ntemplate <typename T, size_t N>\nvoid FormatArrayContents(std::ostream* os, T (&data)[N]) {\n  if (!std::numeric_limits<T>::is_exact) {\n    // Note: T is either an integer or a float.\n    // float requires higher precision to ensure that values are\n    // reproduced exactly.\n    // Trivia: C99 has hexadecimal floating point literals, but C++11 does not.\n    // Using them would remove all concern of precision loss.\n    os->precision(std::numeric_limits<T>::max_digits10 + 2);\n  }\n  *os << \"    {\";\n  std::string separator = \"\";\n  for (size_t i = 0; i < N; ++i) {\n    *os << separator << data[i];\n    if ((i + 1) % 3 != 0) {\n      separator = \", \";\n    } else {\n      separator = \",\\n     \";\n    }\n  }\n  *os << \"}\";\n}\n\n}  // namespace\n\nclass TableGenerator : public gaussian_distribution_base {\n public:\n  TableGenerator();\n  void Print(std::ostream* os);\n\n  using gaussian_distribution_base::kMask;\n  using gaussian_distribution_base::kR;\n  using gaussian_distribution_base::kV;\n\n private:\n  Tables tables_;\n};\n\n// Ziggurat gaussian initialization.  For an explanation of the algorithm, see\n// the Marsaglia paper, \"The Ziggurat Method for Generating Random Variables\".\n//   http://www.jstatsoft.org/v05/i08/\n//\n// Further details are available in the Doornik paper\n//   https://www.doornik.com/research/ziggurat.pdf\n//\nTableGenerator::TableGenerator() {\n  // The constants here should match the values in gaussian_distribution.h\n  static constexpr int kC = kMask + 1;\n\n  static_assert((ABSL_ARRAYSIZE(tables_.x) == kC + 1),\n                \"xArray must be length kMask + 2\");\n\n  static_assert((ABSL_ARRAYSIZE(tables_.x) == ABSL_ARRAYSIZE(tables_.f)),\n                \"fx and x arrays must be identical length\");\n\n  auto f = [](double x) { return std::exp(-0.5 * x * x); };\n  auto f_inv = [](double x) { return std::sqrt(-2.0 * std::log(x)); };\n\n  tables_.x[0] = kV / f(kR);\n  tables_.f[0] = f(tables_.x[0]);\n\n  tables_.x[1] = kR;\n  tables_.f[1] = f(tables_.x[1]);\n\n  tables_.x[kC] = 0.0;\n  tables_.f[kC] = f(tables_.x[kC]);  // 1.0\n\n  for (int i = 2; i < kC; i++) {\n    double v = (kV / tables_.x[i - 1]) + tables_.f[i - 1];\n    tables_.x[i] = f_inv(v);\n    tables_.f[i] = v;\n  }\n}\n\nvoid TableGenerator::Print(std::ostream* os) {\n  *os << \"// BEGIN GENERATED CODE; DO NOT EDIT\\n\"\n         \"// clang-format off\\n\"\n         \"\\n\"\n         \"#include \\\"absl/random/gaussian_distribution.h\\\"\\n\"\n         \"\\n\"\n         \"namespace absl {\\n\"\n         \"ABSL_NAMESPACE_BEGIN\\n\"\n         \"namespace random_internal {\\n\"\n         \"\\n\"\n         \"const gaussian_distribution_base::Tables\\n\"\n         \"    gaussian_distribution_base::zg_ = {\\n\";\n  FormatArrayContents(os, tables_.x);\n  *os << \",\\n\";\n  FormatArrayContents(os, tables_.f);\n  *os << \"};\\n\"\n         \"\\n\"\n         \"}  // namespace random_internal\\n\"\n         \"ABSL_NAMESPACE_END\\n\"\n         \"}  // namespace absl\\n\"\n         \"\\n\"\n         \"// clang-format on\\n\"\n         \"// END GENERATED CODE\";\n  *os << std::endl;\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02778",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/gaussian_distribution_gentables.cc",
  "source_line": 29,
  "validation_status": "validated"
}