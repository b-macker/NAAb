{
  "code": "{\n\ntemplate <typename Char, typename InputIt>\nFMT_CONSTEXPR inline counting_iterator copy_str(InputIt begin, InputIt end,\n                                                counting_iterator it) {\n  return it + (end - begin);\n}\n\ntemplate <typename OutputIt> class truncating_iterator_base {\n protected:\n  OutputIt out_;\n  size_t limit_;\n  size_t count_ = 0;\n\n  truncating_iterator_base() : out_(), limit_(0) {}\n\n  truncating_iterator_base(OutputIt out, size_t limit)\n      : out_(out), limit_(limit) {}\n\n public:\n  using iterator_category = std::output_iterator_tag;\n  using value_type = typename std::iterator_traits<OutputIt>::value_type;\n  using difference_type = std::ptrdiff_t;\n  using pointer = void;\n  using reference = void;\n  FMT_UNCHECKED_ITERATOR(truncating_iterator_base);\n\n  OutputIt base() const { return out_; }\n  size_t count() const { return count_; }\n};\n\n// An output iterator that truncates the output and counts the number of objects\n// written to it.\ntemplate <typename OutputIt,\n          typename Enable = typename std::is_void<\n              typename std::iterator_traits<OutputIt>::value_type>::type>\nclass truncating_iterator;\n\ntemplate <typename OutputIt>\nclass truncating_iterator<OutputIt, std::false_type>\n    : public truncating_iterator_base<OutputIt> {\n  mutable typename truncating_iterator_base<OutputIt>::value_type blackhole_;\n\n public:\n  using value_type = typename truncating_iterator_base<OutputIt>::value_type;\n\n  truncating_iterator() = default;\n\n  truncating_iterator(OutputIt out, size_t limit)\n      : truncating_iterator_base<OutputIt>(out, limit) {}\n\n  truncating_iterator& operator++() {\n    if (this->count_++ < this->limit_) ++this->out_;\n    return *this;\n  }\n\n  truncating_iterator operator++(int) {\n    auto it = *this;\n    ++*this;\n    return it;\n  }\n\n  value_type& operator*() const {\n    return this->count_ < this->limit_ ? *this->out_ : blackhole_;\n  }\n};\n\ntemplate <typename OutputIt>\nclass truncating_iterator<OutputIt, std::true_type>\n    : public truncating_iterator_base<OutputIt> {\n public:\n  truncating_iterator() = default;\n\n  truncating_iterator(OutputIt out, size_t limit)\n      : truncating_iterator_base<OutputIt>(out, limit) {}\n\n  template <typename T> truncating_iterator& operator=(T val) {\n    if (this->count_++ < this->limit_) *this->out_++ = val;\n    return *this;\n  }\n\n  truncating_iterator& operator++() { return *this; }\n  truncating_iterator& operator++(int) { return *this; }\n  truncating_iterator& operator*() { return *this; }\n};\n\n// A compile-time string which is compiled into fast formatting code.\nclass compiled_string {};\n\ntemplate <typename S>\nstruct is_compiled_string : std::is_base_of<compiled_string, S> {};\n\n/**\n  \\rst\n  Converts a string literal *s* into a format string that will be parsed at\n  compile time and converted into efficient formatting code. Requires C++17\n  ``constexpr if`` compiler support.\n\n  **Example**::\n\n    // Converts 42 into std::string using the most efficient method and no\n    // runtime format string processing.\n    std::string s = fmt::format(FMT_COMPILE(\"{}\"), 42);\n  \\endrst\n */\n#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)\n#  define FMT_COMPILE(s) \\\n    FMT_STRING_IMPL(s, fmt::detail::compiled_string, explicit)\n#else\n#  define FMT_COMPILE(s) FMT_STRING(s)\n#endif\n\n#if FMT_USE_NONTYPE_TEMPLATE_ARGS\ntemplate <typename Char, size_t N,\n          fmt::detail_exported::fixed_string<Char, N> Str>\nstruct udl_compiled_string : compiled_string {\n  using char_type = Char;\n  explicit constexpr operator basic_string_view<char_type>() const {\n    return {Str.data, N - 1};\n  }\n};\n#endif\n\ntemplate <typename T, typename... Tail>\nconst T& first(const T& value, const Tail&...) {\n  return value;\n}\n\n#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)\ntemplate <typename... Args> struct type_list {};\n\n// Returns a reference to the argument at index N from [first, rest...].\ntemplate <int N, typename T, typename... Args>\nconstexpr const auto& get([[maybe_unused]] const T& first,\n                          [[maybe_unused]] const Args&... rest) {\n  static_assert(N < 1 + sizeof...(Args), \"index is out of bounds\");\n  if constexpr (N == 0)\n    return first;\n  else\n    return detail::get<N - 1>(rest...);\n}\n\ntemplate <typename Char, typename... Args>\nconstexpr int get_arg_index_by_name(basic_string_view<Char> name,\n                                    type_list<Args...>) {\n  return get_arg_index_by_name<Args...>(name);\n}\n\ntemplate <int N, typename> struct get_type_impl;\n\ntemplate <int N, typename... Args> struct get_type_impl<N, type_list<Args...>> {\n  using type =\n      remove_cvref_t<decltype(detail::get<N>(std::declval<Args>()...))>;\n};\n\ntemplate <int N, typename T>\nusing get_type = typename get_type_impl<N, T>::type;\n\ntemplate <typename T> struct is_compiled_format : std::false_type {};\n\ntemplate <typename Char> struct text {\n  basic_string_view<Char> data;\n  using char_type = Char;\n\n  template <typename OutputIt, typename... Args>\n  constexpr OutputIt format(OutputIt out, const Args&...) const {\n    return write<Char>(out, data);\n  }\n};\n\ntemplate <typename Char>\nstruct is_compiled_format<text<Char>> : std::true_type {};\n\ntemplate <typename Char>\nconstexpr text<Char> make_text(basic_string_view<Char> s, size_t pos,\n                               size_t size) {\n  return {{&s[pos], size}};\n}\n\ntemplate <typename Char> struct code_unit {\n  Char value;\n  using char_type = Char;\n\n  template <typename OutputIt, typename... Args>\n  constexpr OutputIt format(OutputIt out, const Args&...) const {\n    return write<Char>(out, value);\n  }\n};\n\n// This ensures that the argument type is convertible to `const T&`.\ntemplate <typename T, int N, typename... Args>\nconstexpr const T& get_arg_checked(const Args&... args) {\n  const auto& arg = detail::get<N>(args...);\n  if constexpr (detail::is_named_arg<remove_cvref_t<decltype(arg)>>()) {\n    return arg.value;\n  } else {\n    return arg;\n  }\n}\n\ntemplate <typename Char>\nstruct is_compiled_format<code_unit<Char>> : std::true_type {};\n\n// A replacement field that refers to argument N.\ntemplate <typename Char, typename T, int N> struct field {\n  using char_type = Char;\n\n  template <typename OutputIt, typename... Args>\n  constexpr OutputIt format(OutputIt out, const Args&... args) const {\n    return write<Char>(out, get_arg_checked<T, N>(args...));\n  }\n};\n\ntemplate <typename Char, typename T, int N>\nstruct is_compiled_format<field<Char, T, N>> : std::true_type {};\n\n// A replacement field that refers to argument with name.\ntemplate <typename Char> struct runtime_named_field {\n  using char_type = Char;\n  basic_string_view<Char> name;\n\n  template <typename OutputIt, typename T>\n  constexpr static bool try_format_argument(\n      OutputIt& out,\n      // [[maybe_unused]] due to unused-but-set-parameter warning in GCC 7,8,9\n      [[maybe_unused]] basic_string_view<Char> arg_name, const T& arg) {\n    if constexpr (is_named_arg<typename std::remove_cv<T>::type>::value) {\n      if (arg_name == arg.name) {\n        out = write<Char>(out, arg.value);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  template <typename OutputIt, typename... Args>\n  constexpr OutputIt format(OutputIt out, const Args&... args) const {\n    bool found = (try_format_argument(out, name, args) || ...);\n    if (!found) {\n      FMT_THROW(format_error(\"argument with specified name is not found\"));\n    }\n    return out;\n  }\n};\n\ntemplate <typename Char>\nstruct is_compiled_format<runtime_named_field<Char>> : std::true_type {};\n\n// A replacement field that refers to argument N and has format specifiers.\ntemplate <typename Char, typename T, int N> struct spec_field {\n  using char_type = Char;\n  formatter<T, Char> fmt;\n\n  template <typename OutputIt, typename... Args>\n  constexpr FMT_INLINE OutputIt format(OutputIt out,\n                                       const Args&... args) const {\n    const auto& vargs =\n        fmt::make_format_args<basic_format_context<OutputIt, Char>>(args...);\n    basic_format_context<OutputIt, Char> ctx(out, vargs);\n    return fmt.format(get_arg_checked<T, N>(args...), ctx);\n  }\n};\n\ntemplate <typename Char, typename T, int N>\nstruct is_compiled_format<spec_field<Char, T, N>> : std::true_type {};\n\ntemplate <typename L, typename R> struct concat {\n  L lhs;\n  R rhs;\n  using char_type = typename L::char_type;\n\n  template <typename OutputIt, typename... Args>\n  constexpr OutputIt format(OutputIt out, const Args&... args) const {\n    out = lhs.format(out, args...);\n    return rhs.format(out, args...);\n  }\n};\n\ntemplate <typename L, typename R>\nstruct is_compiled_format<concat<L, R>> : std::true_type {};\n\ntemplate <typename L, typename R>\nconstexpr concat<L, R> make_concat(L lhs, R rhs) {\n  return {lhs, rhs};\n}\n\nstruct unknown_format {};\n\ntemplate <typename Char>\nconstexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {\n  for (size_t size = str.size(); pos != size; ++pos) {\n    if (str[pos] == '{' || str[pos] == '}') break;\n  }\n  return pos;\n}\n\ntemplate <typename Args, size_t POS, int ID, typename S>\nconstexpr auto compile_format_string(S format_str);\n\ntemplate <typename Args, size_t POS, int ID, typename T, typename S>\nconstexpr auto parse_tail(T head, S format_str) {\n  if constexpr (POS !=\n                basic_string_view<typename S::char_type>(format_str).size()) {\n    constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);\n    if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,\n                               unknown_format>())\n      return tail;\n    else\n      return make_concat(head, tail);\n  } else {\n    return head;\n  }\n}\n\ntemplate <typename T, typename Char> struct parse_specs_result {\n  formatter<T, Char> fmt;\n  size_t end;\n  int next_arg_id;\n};\n\nconstexpr int manual_indexing_id = -1;\n\ntemplate <typename T, typename Char>\nconstexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,\n                                                  size_t pos, int next_arg_id) {\n  str.remove_prefix(pos);\n  auto ctx = compile_parse_context<Char>(str, max_value<int>(), nullptr, {},\n                                         next_arg_id);\n  auto f = formatter<T, Char>();\n  auto end = f.parse(ctx);\n  return {f, pos + fmt::detail::to_unsigned(end - str.data()),\n          next_arg_id == 0 ? manual_indexing_id : ctx.next_arg_id()};\n}\n\ntemplate <typename Char> struct arg_id_handler {\n  arg_ref<Char> arg_id;\n\n  constexpr int operator()() {\n    FMT_ASSERT(false, \"handler cannot be used with automatic indexing\");\n    return 0;\n  }\n  constexpr int operator()(int id) {\n    arg_id = arg_ref<Char>(id);\n    return 0;\n  }\n  constexpr int operator()(basic_string_view<Char> id) {\n    arg_id = arg_ref<Char>(id);\n    return 0;\n  }\n\n  constexpr void on_error(const char* message) {\n    FMT_THROW(format_error(message));\n  }\n};\n\ntemplate <typename Char> struct parse_arg_id_result {\n  arg_ref<Char> arg_id;\n  const Char* arg_id_end;\n};\n\ntemplate <int ID, typename Char>\nconstexpr auto parse_arg_id(const Char* begin, const Char* end) {\n  auto handler = arg_id_handler<Char>{arg_ref<Char>{}};\n  auto arg_id_end = parse_arg_id(begin, end, handler);\n  return parse_arg_id_result<Char>{handler.arg_id, arg_id_end};\n}\n\ntemplate <typename T, typename Enable = void> struct field_type {\n  using type = remove_cvref_t<T>;\n};\n\ntemplate <typename T>\nstruct field_type<T, enable_if_t<detail::is_named_arg<T>::value>> {\n  using type = remove_cvref_t<decltype(T::value)>;\n};\n\ntemplate <typename T, typename Args, size_t END_POS, int ARG_INDEX, int NEXT_ID,\n          typename S>\nconstexpr auto parse_replacement_field_then_tail(S format_str) {\n  using char_type = typename S::char_type;\n  constexpr auto str = basic_string_view<char_type>(format_str);\n  constexpr char_type c = END_POS != str.size() ? str[END_POS] : char_type();\n  if constexpr (c == '}') {\n    return parse_tail<Args, END_POS + 1, NEXT_ID>(\n        field<char_type, typename field_type<T>::type, ARG_INDEX>(),\n        format_str);\n  } else if constexpr (c != ':') {\n    FMT_THROW(format_error(\"expected ':'\"));\n  } else {\n    constexpr auto result = parse_specs<typename field_type<T>::type>(\n        str, END_POS + 1, NEXT_ID == manual_indexing_id ? 0 : NEXT_ID);\n    if constexpr (result.end >= str.size() || str[result.end] != '}') {\n      FMT_THROW(format_error(\"expected '}'\"));\n      return 0;\n    } else {\n      return parse_tail<Args, result.end + 1, result.next_arg_id>(\n          spec_field<char_type, typename field_type<T>::type, ARG_INDEX>{\n              result.fmt},\n          format_str);\n    }\n  }\n}\n\n// Compiles a non-empty format string and returns the compiled representation\n// or unknown_format() on unrecognized input.\ntemplate <typename Args, size_t POS, int ID, typename S>\nconstexpr auto compile_format_string(S format_str) {\n  using char_type = typename S::char_type;\n  constexpr auto str = basic_string_view<char_type>(format_str);\n  if constexpr (str[POS] == '{') {\n    if constexpr (POS + 1 == str.size())\n      FMT_THROW(format_error(\"unmatched '{' in format string\"));\n    if constexpr (str[POS + 1] == '{') {\n      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);\n    } else if constexpr (str[POS + 1] == '}' || str[POS + 1] == ':') {\n      static_assert(ID != manual_indexing_id,\n                    \"cannot switch from manual to automatic argument indexing\");\n      constexpr auto next_id =\n          ID != manual_indexing_id ? ID + 1 : manual_indexing_id;\n      return parse_replacement_field_then_tail<get_type<ID, Args>, Args,\n                                               POS + 1, ID, next_id>(\n          format_str);\n    } else {\n      constexpr auto arg_id_result =\n          parse_arg_id<ID>(str.data() + POS + 1, str.data() + str.size());\n      constexpr auto arg_id_end_pos = arg_id_result.arg_id_end - str.data();\n      constexpr char_type c =\n          arg_id_end_pos != str.size() ? str[arg_id_end_pos] : char_type();\n      static_assert(c == '}' || c == ':', \"missing '}' in format string\");\n      if constexpr (arg_id_result.arg_id.kind == arg_id_kind::index) {\n        static_assert(\n            ID == manual_indexing_id || ID == 0,\n            \"cannot switch from automatic to manual argument indexing\");\n        constexpr auto arg_index = arg_id_result.arg_id.val.index;\n        return parse_replacement_field_then_tail<get_type<arg_index, Args>,\n                                                 Args, arg_id_end_pos,\n                                                 arg_index, manual_indexing_id>(\n            format_str);\n      } else if constexpr (arg_id_result.arg_id.kind == arg_id_kind::name) {\n        constexpr auto arg_index =\n            get_arg_index_by_name(arg_id_result.arg_id.val.name, Args{});\n        if constexpr (arg_index != invalid_arg_index) {\n          constexpr auto next_id =\n              ID != manual_indexing_id ? ID + 1 : manual_indexing_id;\n          return parse_replacement_field_then_tail<\n              decltype(get_type<arg_index, Args>::value), Args, arg_id_end_pos,\n              arg_index, next_id>(format_str);\n        } else {\n          if constexpr (c == '}') {\n            return parse_tail<Args, arg_id_end_pos + 1, ID>(\n                runtime_named_field<char_type>{arg_id_result.arg_id.val.name},\n                format_str);\n          } else if constexpr (c == ':') {\n            return unknown_format();  // no type info for specs parsing\n          }\n        }\n      }\n    }\n  } else if constexpr (str[POS] == '}') {\n    if constexpr (POS + 1 == str.size())\n      FMT_THROW(format_error(\"unmatched '}' in format string\"));\n    return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);\n  } else {\n    constexpr auto end = parse_text(str, POS + 1);\n    if constexpr (end - POS > 1) {\n      return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),\n                                       format_str);\n    } else {\n      return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},\n                                       format_str);\n    }\n  }\n}\n\ntemplate <typename... Args, typename S,\n          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\nconstexpr auto compile(S format_str) {\n  constexpr auto str = basic_string_view<typename S::char_type>(format_str);\n  if constexpr (str.size() == 0) {\n    return detail::make_text(str, 0, 0);\n  } else {\n    constexpr auto result =\n        detail::compile_format_string<detail::type_list<Args...>, 0, 0>(\n            format_str);\n    return result;\n  }\n}\n#endif  // defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)\n}",
  "id": "BLOCK-CPP-00906",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/compile.h",
  "source_line": 14,
  "validation_status": "validated"
}