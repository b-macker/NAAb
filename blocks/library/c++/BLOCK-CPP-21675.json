{
  "code": "{\npublic:\n  using BlockArray = SimpleArray<BasicBlock *>;\n  using iterator = BlockArray::iterator;\n  using const_iterator = BlockArray::const_iterator;\n\n  SCFG(MemRegionRef A, unsigned Nblocks)\n      : SExpr(COP_SCFG), Arena(A), Blocks(A, Nblocks) {\n    Entry = new (A) BasicBlock(A);\n    Exit  = new (A) BasicBlock(A);\n    auto *V = new (A) Phi();\n    Exit->addArgument(V);\n    Exit->setTerminator(new (A) Return(V));\n    add(Entry);\n    add(Exit);\n  }\n\n  SCFG(const SCFG &Cfg, BlockArray &&Ba) // steals memory from Ba\n      : SExpr(COP_SCFG), Arena(Cfg.Arena), Blocks(std::move(Ba)) {\n    // TODO: set entry and exit!\n  }\n\n  static bool classof(const SExpr *E) { return E->opcode() == COP_SCFG; }\n\n  /// Return true if this CFG is valid.\n  bool valid() const { return Entry && Exit && Blocks.size() > 0; }\n\n  /// Return true if this CFG has been normalized.\n  /// After normalization, blocks are in topological order, and block and\n  /// instruction IDs have been assigned.\n  bool normal() const { return Normal; }\n\n  iterator begin() { return Blocks.begin(); }\n  iterator end() { return Blocks.end(); }\n\n  const_iterator begin() const { return cbegin(); }\n  const_iterator end() const { return cend(); }\n\n  const_iterator cbegin() const { return Blocks.cbegin(); }\n  const_iterator cend() const { return Blocks.cend(); }\n\n  const BasicBlock *entry() const { return Entry; }\n  BasicBlock *entry() { return Entry; }\n  const BasicBlock *exit() const { return Exit; }\n  BasicBlock *exit() { return Exit; }\n\n  /// Return the number of blocks in the CFG.\n  /// Block::blockID() will return a number less than numBlocks();\n  size_t numBlocks() const { return Blocks.size(); }\n\n  /// Return the total number of instructions in the CFG.\n  /// This is useful for building instruction side-tables;\n  /// A call to SExpr::id() will return a number less than numInstructions().\n  unsigned numInstructions() { return NumInstructions; }\n\n  inline void add(BasicBlock *BB) {\n    assert(BB->CFGPtr == nullptr);\n    BB->CFGPtr = this;\n    Blocks.reserveCheck(1, Arena);\n    Blocks.push_back(BB);\n  }\n\n  void setEntry(BasicBlock *BB) { Entry = BB; }\n  void setExit(BasicBlock *BB)  { Exit = BB;  }\n\n  void computeNormalForm();\n\n  template <class V>\n  typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {\n    Vs.enterCFG(*this);\n    typename V::template Container<BasicBlock *> Bbs(Vs, Blocks.size());\n\n    for (const auto *B : Blocks) {\n      Bbs.push_back( B->traverse(Vs, Vs.subExprCtx(Ctx)) );\n    }\n    Vs.exitCFG(*this);\n    return Vs.reduceSCFG(*this, Bbs);\n  }\n\n  template <class C>\n  typename C::CType compare(const SCFG *E, C &Cmp) const {\n    // TODO: implement CFG comparisons\n    return Cmp.comparePointers(this, E);\n  }\n\nprivate:\n  // assign unique ids to all instructions\n  void renumberInstrs();\n\n  MemRegionRef Arena;\n  BlockArray Blocks;\n  BasicBlock *Entry = nullptr;\n  BasicBlock *Exit = nullptr;\n  unsigned NumInstructions = 0;\n  bool Normal = false;\n}",
  "id": "BLOCK-CPP-21675",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h",
  "source_line": 1695,
  "validation_status": "validated"
}