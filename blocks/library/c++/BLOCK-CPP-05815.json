{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace numeric_internal {\n\nconstexpr bool IsPowerOf2(unsigned int x) noexcept {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\ntemplate <class T>\nABSL_MUST_USE_RESULT ABSL_ATTRIBUTE_ALWAYS_INLINE constexpr T RotateRight(\n    T x, int s) noexcept {\n  static_assert(std::is_unsigned<T>::value, \"T must be unsigned\");\n  static_assert(IsPowerOf2(std::numeric_limits<T>::digits),\n                \"T must have a power-of-2 size\");\n\n  return static_cast<T>(x >> (s & (std::numeric_limits<T>::digits - 1))) |\n         static_cast<T>(x << ((-s) & (std::numeric_limits<T>::digits - 1)));\n}\n\ntemplate <class T>\nABSL_MUST_USE_RESULT ABSL_ATTRIBUTE_ALWAYS_INLINE constexpr T RotateLeft(\n    T x, int s) noexcept {\n  static_assert(std::is_unsigned<T>::value, \"T must be unsigned\");\n  static_assert(IsPowerOf2(std::numeric_limits<T>::digits),\n                \"T must have a power-of-2 size\");\n\n  return static_cast<T>(x << (s & (std::numeric_limits<T>::digits - 1))) |\n         static_cast<T>(x >> ((-s) & (std::numeric_limits<T>::digits - 1)));\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_POPCOUNT inline int\nPopcount32(uint32_t x) noexcept {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_popcount)\n  static_assert(sizeof(unsigned int) == sizeof(x),\n                \"__builtin_popcount does not take 32-bit arg\");\n  return __builtin_popcount(x);\n#else\n  x -= ((x >> 1) & 0x55555555);\n  x = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n  return static_cast<int>((((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24);\n#endif\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_POPCOUNT inline int\nPopcount64(uint64_t x) noexcept {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_popcountll)\n  static_assert(sizeof(unsigned long long) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_popcount does not take 64-bit arg\");\n  return __builtin_popcountll(x);\n#else\n  x -= (x >> 1) & 0x5555555555555555ULL;\n  x = ((x >> 2) & 0x3333333333333333ULL) + (x & 0x3333333333333333ULL);\n  return static_cast<int>(\n      (((x + (x >> 4)) & 0xF0F0F0F0F0F0F0FULL) * 0x101010101010101ULL) >> 56);\n#endif\n}\n\ntemplate <class T>\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_POPCOUNT inline int\nPopcount(T x) noexcept {\n  static_assert(std::is_unsigned<T>::value, \"T must be unsigned\");\n  static_assert(IsPowerOf2(std::numeric_limits<T>::digits),\n                \"T must have a power-of-2 size\");\n  static_assert(sizeof(x) <= sizeof(uint64_t), \"T is too large\");\n  return sizeof(x) <= sizeof(uint32_t) ? Popcount32(x) : Popcount64(x);\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline int\nCountLeadingZeroes32(uint32_t x) {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_clz)\n  // Use __builtin_clz, which uses the following instructions:\n  //  x86: bsr, lzcnt\n  //  ARM64: clz\n  //  PPC: cntlzd\n\n  static_assert(sizeof(unsigned int) == sizeof(x),\n                \"__builtin_clz does not take 32-bit arg\");\n  // Handle 0 as a special case because __builtin_clz(0) is undefined.\n  return x == 0 ? 32 : __builtin_clz(x);\n#elif defined(_MSC_VER) && !defined(__clang__)\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if (_BitScanReverse(&result, x)) {\n    return 31 - result;\n  }\n  return 32;\n#else\n  int zeroes = 28;\n  if (x >> 16) {\n    zeroes -= 16;\n    x >>= 16;\n  }\n  if (x >> 8) {\n    zeroes -= 8;\n    x >>= 8;\n  }\n  if (x >> 4) {\n    zeroes -= 4;\n    x >>= 4;\n  }\n  return \"\\4\\3\\2\\2\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\"[x] + zeroes;\n#endif\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline int\nCountLeadingZeroes16(uint16_t x) {\n#if ABSL_HAVE_BUILTIN(__builtin_clzs)\n  static_assert(sizeof(unsigned short) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_clzs does not take 16-bit arg\");\n  return x == 0 ? 16 : __builtin_clzs(x);\n#else\n  return CountLeadingZeroes32(x) - 16;\n#endif\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline int\nCountLeadingZeroes64(uint64_t x) {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_clzll)\n  // Use __builtin_clzll, which uses the following instructions:\n  //  x86: bsr, lzcnt\n  //  ARM64: clz\n  //  PPC: cntlzd\n  static_assert(sizeof(unsigned long long) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_clzll does not take 64-bit arg\");\n\n  // Handle 0 as a special case because __builtin_clzll(0) is undefined.\n  return x == 0 ? 64 : __builtin_clzll(x);\n#elif defined(_MSC_VER) && !defined(__clang__) && \\\n    (defined(_M_X64) || defined(_M_ARM64))\n  // MSVC does not have __buitin_clzll. Use _BitScanReverse64.\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if (_BitScanReverse64(&result, x)) {\n    return 63 - result;\n  }\n  return 64;\n#elif defined(_MSC_VER) && !defined(__clang__)\n  // MSVC does not have __buitin_clzll. Compose two calls to _BitScanReverse\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if ((x >> 32) &&\n      _BitScanReverse(&result, static_cast<unsigned long>(x >> 32))) {\n    return 31 - result;\n  }\n  if (_BitScanReverse(&result, static_cast<unsigned long>(x))) {\n    return 63 - result;\n  }\n  return 64;\n#else\n  int zeroes = 60;\n  if (x >> 32) {\n    zeroes -= 32;\n    x >>= 32;\n  }\n  if (x >> 16) {\n    zeroes -= 16;\n    x >>= 16;\n  }\n  if (x >> 8) {\n    zeroes -= 8;\n    x >>= 8;\n  }\n  if (x >> 4) {\n    zeroes -= 4;\n    x >>= 4;\n  }\n  return \"\\4\\3\\2\\2\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\"[x] + zeroes;\n#endif\n}\n\ntemplate <typename T>\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline int\nCountLeadingZeroes(T x) {\n  static_assert(std::is_unsigned<T>::value, \"T must be unsigned\");\n  static_assert(IsPowerOf2(std::numeric_limits<T>::digits),\n                \"T must have a power-of-2 size\");\n  static_assert(sizeof(T) <= sizeof(uint64_t), \"T too large\");\n  return sizeof(T) <= sizeof(uint16_t)\n             ? CountLeadingZeroes16(static_cast<uint16_t>(x)) -\n                   (std::numeric_limits<uint16_t>::digits -\n                    std::numeric_limits<T>::digits)\n             : (sizeof(T) <= sizeof(uint32_t)\n                    ? CountLeadingZeroes32(static_cast<uint32_t>(x)) -\n                          (std::numeric_limits<uint32_t>::digits -\n                           std::numeric_limits<T>::digits)\n                    : CountLeadingZeroes64(x));\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CTZ inline int\nCountTrailingZeroesNonzero32(uint32_t x) {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_ctz)\n  static_assert(sizeof(unsigned int) == sizeof(x),\n                \"__builtin_ctz does not take 32-bit arg\");\n  return __builtin_ctz(x);\n#elif defined(_MSC_VER) && !defined(__clang__)\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  _BitScanForward(&result, x);\n  return result;\n#else\n  int c = 31;\n  x &= ~x + 1;\n  if (x & 0x0000FFFF) c -= 16;\n  if (x & 0x00FF00FF) c -= 8;\n  if (x & 0x0F0F0F0F) c -= 4;\n  if (x & 0x33333333) c -= 2;\n  if (x & 0x55555555) c -= 1;\n  return c;\n#endif\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CTZ inline int\nCountTrailingZeroesNonzero64(uint64_t x) {\n#if ABSL_NUMERIC_INTERNAL_HAVE_BUILTIN_OR_GCC(__builtin_ctzll)\n  static_assert(sizeof(unsigned long long) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_ctzll does not take 64-bit arg\");\n  return __builtin_ctzll(x);\n#elif defined(_MSC_VER) && !defined(__clang__) && \\\n    (defined(_M_X64) || defined(_M_ARM64))\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  _BitScanForward64(&result, x);\n  return result;\n#elif defined(_MSC_VER) && !defined(__clang__)\n  unsigned long result = 0;  // NOLINT(runtime/int)\n  if (static_cast<uint32_t>(x) == 0) {\n    _BitScanForward(&result, static_cast<unsigned long>(x >> 32));\n    return result + 32;\n  }\n  _BitScanForward(&result, static_cast<unsigned long>(x));\n  return result;\n#else\n  int c = 63;\n  x &= ~x + 1;\n  if (x & 0x00000000FFFFFFFF) c -= 32;\n  if (x & 0x0000FFFF0000FFFF) c -= 16;\n  if (x & 0x00FF00FF00FF00FF) c -= 8;\n  if (x & 0x0F0F0F0F0F0F0F0F) c -= 4;\n  if (x & 0x3333333333333333) c -= 2;\n  if (x & 0x5555555555555555) c -= 1;\n  return c;\n#endif\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CTZ inline int\nCountTrailingZeroesNonzero16(uint16_t x) {\n#if ABSL_HAVE_BUILTIN(__builtin_ctzs)\n  static_assert(sizeof(unsigned short) == sizeof(x),  // NOLINT(runtime/int)\n                \"__builtin_ctzs does not take 16-bit arg\");\n  return __builtin_ctzs(x);\n#else\n  return CountTrailingZeroesNonzero32(x);\n#endif\n}\n\ntemplate <class T>\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CTZ inline int\nCountTrailingZeroes(T x) noexcept {\n  static_assert(std::is_unsigned<T>::value, \"T must be unsigned\");\n  static_assert(IsPowerOf2(std::numeric_limits<T>::digits),\n                \"T must have a power-of-2 size\");\n  static_assert(sizeof(T) <= sizeof(uint64_t), \"T too large\");\n  return x == 0 ? std::numeric_limits<T>::digits\n                : (sizeof(T) <= sizeof(uint16_t)\n                       ? CountTrailingZeroesNonzero16(static_cast<uint16_t>(x))\n                       : (sizeof(T) <= sizeof(uint32_t)\n                              ? CountTrailingZeroesNonzero32(\n                                    static_cast<uint32_t>(x))\n                              : CountTrailingZeroesNonzero64(x)));\n}\n\n// If T is narrower than unsigned, T{1} << bit_width will be promoted.  We\n// want to force it to wraparound so that bit_ceil of an invalid value are not\n// core constant expressions.\ntemplate <class T>\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    BitCeilPromotionHelper(T x, T promotion) {\n  return (T{1} << (x + promotion)) >> promotion;\n}\n\ntemplate <class T>\nABSL_ATTRIBUTE_ALWAYS_INLINE ABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    BitCeilNonPowerOf2(T x) {\n  // If T is narrower than unsigned, it undergoes promotion to unsigned when we\n  // shift.  We calculate the number of bits added by the wider type.\n  return BitCeilPromotionHelper(\n      static_cast<T>(std::numeric_limits<T>::digits - CountLeadingZeroes(x)),\n      T{sizeof(T) >= sizeof(unsigned) ? 0\n                                      : std::numeric_limits<unsigned>::digits -\n                                            std::numeric_limits<T>::digits});\n}\n\n}  // namespace numeric_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05815",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/internal/bits.h",
  "source_line": 65,
  "validation_status": "validated"
}