{
  "code": "#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/strings/charconv.h\"\n\nusing namespace absl;\nusing namespace strings_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06053_execute() {\n    {\n  // Representation of the parsed mantissa, with the decimal point adjusted to\n  // make it an integer.\n  //\n  // During decimal scanning, this contains 19 significant digits worth of\n  // mantissa value.  If digits beyond this point are found, they\n  // are truncated, and if any of these dropped digits are nonzero, then\n  // `mantissa` is inexact, and the full mantissa is stored in [subrange_begin,\n  // subrange_end).\n  //\n  // During hexadecimal scanning, this contains 15 significant hex digits worth\n  // of mantissa value.  Digits beyond this point are sticky -- they are\n  // truncated, but if any dropped digits are nonzero, the low bit of mantissa\n  // will be set.  (This allows for precise rounding, and avoids the need\n  // to store the full mantissa in [subrange_begin, subrange_end).)\n  uint64_t mantissa = 0;\n\n  // Floating point expontent.  This reflects any decimal point adjustments and\n  // any truncated digits from the mantissa.  The absolute value of the parsed\n  // number is represented by mantissa * (base ** exponent), where base==10 for\n  // decimal floats, and base==2 for hexadecimal floats.\n  int exponent = 0;\n\n  // The literal exponent value scanned from the input, or 0 if none was\n  // present.  This does not reflect any adjustments applied to mantissa.\n  int literal_exponent = 0;\n\n  // The type of number scanned.\n  FloatType type = FloatType::kNumber;\n\n  // When non-null, [subrange_begin, subrange_end) marks a range of characters\n  // that require further processing.  The meaning is dependent on float type.\n  // If type == kNumber and this is set, this is a \"wide input\": the input\n  // mantissa contained more than 19 digits.  The range contains the full\n  // mantissa.  It plus `literal_exponent` need to be examined to find the best\n  // floating point match.\n  // If type == kNan and this is set, the range marks the contents of a\n  // matched parenthesized character region after the NaN.\n  const char* subrange_begin = nullptr;\n  const char* subrange_end = nullptr;\n\n  // One-past-the-end of the successfully parsed region, or nullptr if no\n  // matching pattern was found.\n  const char* end = nullptr;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06053",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/charconv_parse.h",
  "source_line": 31,
  "validation_status": "validated"
}