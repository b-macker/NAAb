{
  "code": "{\n\nclass SwiftAggLowering {\n  CodeGenModule &CGM;\n\n  struct StorageEntry {\n    CharUnits Begin;\n    CharUnits End;\n    llvm::Type *Type;\n\n    CharUnits getWidth() const {\n      return End - Begin;\n    }\n  };\n  SmallVector<StorageEntry, 4> Entries;\n  bool Finished = false;\n\npublic:\n  SwiftAggLowering(CodeGenModule &CGM) : CGM(CGM) {}\n\n  void addOpaqueData(CharUnits begin, CharUnits end) {\n    addEntry(nullptr, begin, end);\n  }\n\n  void addTypedData(QualType type, CharUnits begin);\n  void addTypedData(const RecordDecl *record, CharUnits begin);\n  void addTypedData(const RecordDecl *record, CharUnits begin,\n                    const ASTRecordLayout &layout);\n  void addTypedData(llvm::Type *type, CharUnits begin);\n  void addTypedData(llvm::Type *type, CharUnits begin, CharUnits end);\n\n  void finish();\n\n  /// Does this lowering require passing any data?\n  bool empty() const {\n    assert(Finished && \"didn't finish lowering before calling empty()\");\n    return Entries.empty();\n  }\n\n  /// According to the target Swift ABI, should a value with this lowering\n  /// be passed indirectly?\n  ///\n  /// Note that this decision is based purely on the data layout of the\n  /// value and does not consider whether the type is address-only,\n  /// must be passed indirectly to match a function abstraction pattern, or\n  /// anything else that is expected to be handled by high-level lowering.\n  ///\n  /// \\param asReturnValue - if true, answer whether it should be passed\n  ///   indirectly as a return value; if false, answer whether it should be\n  ///   passed indirectly as an argument\n  bool shouldPassIndirectly(bool asReturnValue) const;\n\n  using EnumerationCallback =\n    llvm::function_ref<void(CharUnits offset, CharUnits end, llvm::Type *type)>;\n\n  /// Enumerate the expanded components of this type.\n  ///\n  /// The component types will always be legal vector, floating-point,\n  /// integer, or pointer types.\n  void enumerateComponents(EnumerationCallback callback) const;\n\n  /// Return the types for a coerce-and-expand operation.\n  ///\n  /// The first type matches the memory layout of the data that's been\n  /// added to this structure, including explicit [N x i8] arrays for any\n  /// internal padding.\n  ///\n  /// The second type removes any internal padding members and, if only\n  /// one element remains, is simply that element type.\n  std::pair<llvm::StructType*, llvm::Type*> getCoerceAndExpandTypes() const;\n\nprivate:\n  void addBitFieldData(const FieldDecl *field, CharUnits begin,\n                       uint64_t bitOffset);\n  void addLegalTypedData(llvm::Type *type, CharUnits begin, CharUnits end);\n  void addEntry(llvm::Type *type, CharUnits begin, CharUnits end);\n  void splitVectorEntry(unsigned index);\n  static bool shouldMergeEntries(const StorageEntry &first,\n                                 const StorageEntry &second,\n                                 CharUnits chunkSize);\n};\n\n/// Should an aggregate which expands to the given type sequence\n/// be passed/returned indirectly under swiftcall?\nbool shouldPassIndirectly(CodeGenModule &CGM,\n                          ArrayRef<llvm::Type*> types,\n                          bool asReturnValue);\n\n/// Return the maximum voluntary integer size for the current target.\nCharUnits getMaximumVoluntaryIntegerSize(CodeGenModule &CGM);\n\n/// Return the Swift CC's notion of the natural alignment of a type.\nCharUnits getNaturalAlignment(CodeGenModule &CGM, llvm::Type *type);\n\n/// Is the given integer type \"legal\" for Swift's perspective on the\n/// current platform?\nbool isLegalIntegerType(CodeGenModule &CGM, llvm::IntegerType *type);\n\n/// Is the given vector type \"legal\" for Swift's perspective on the\n/// current platform?\nbool isLegalVectorType(CodeGenModule &CGM, CharUnits vectorSize,\n                       llvm::VectorType *vectorTy);\nbool isLegalVectorType(CodeGenModule &CGM, CharUnits vectorSize,\n                       llvm::Type *eltTy, unsigned numElts);\n\n/// Minimally split a legal vector type.\nstd::pair<llvm::Type*, unsigned>\nsplitLegalVectorType(CodeGenModule &CGM, CharUnits vectorSize,\n                     llvm::VectorType *vectorTy);\n\n/// Turn a vector type in a sequence of legal component vector types.\n///\n/// The caller may assume that the sum of the data sizes of the resulting\n/// types will equal the data size of the vector type.\nvoid legalizeVectorType(CodeGenModule &CGM, CharUnits vectorSize,\n                        llvm::VectorType *vectorTy,\n                        llvm::SmallVectorImpl<llvm::Type*> &types);\n\n/// Is the given record type required to be passed and returned indirectly\n/// because of language restrictions?\n///\n/// This considers *only* mandatory indirectness due to language restrictions,\n/// such as C++'s non-trivially-copyable types and Objective-C's __weak\n/// references.  A record for which this returns true may still be passed\n/// indirectly for other reasons, such as being too large to fit in a\n/// reasonable number of registers.\nbool mustPassRecordIndirectly(CodeGenModule &CGM, const RecordDecl *record);\n\n/// Classify the rules for how to return a particular type.\nABIArgInfo classifyReturnType(CodeGenModule &CGM, CanQualType type);\n\n/// Classify the rules for how to pass a particular type.\nABIArgInfo classifyArgumentType(CodeGenModule &CGM, CanQualType type);\n\n/// Compute the ABI information of a swiftcall function.  This is a\n/// private interface for Clang.\nvoid computeABIInfo(CodeGenModule &CGM, CGFunctionInfo &FI);\n\n/// Is swifterror lowered to a register by the target ABI?\nbool isSwiftErrorLoweredInRegister(CodeGenModule &CGM);\n\n}",
  "id": "BLOCK-CPP-17612",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/SwiftCallingConv.h",
  "source_line": 39,
  "validation_status": "validated"
}