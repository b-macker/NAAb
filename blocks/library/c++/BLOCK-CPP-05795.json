{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\n\nclass SyntheticBinary;\nclass VLogSite;\n\nint RegisterAndInitialize(VLogSite* v);\nvoid UpdateVLogSites();\nconstexpr int kUseFlag = (std::numeric_limits<int16_t>::min)();\n\n// Represents a unique callsite for a `VLOG()` or `VLOG_IS_ON()` call.\n//\n// Libraries that provide `VLOG`-like functionality should use this to\n// efficiently handle --vmodule.\n//\n// VLogSite objects must not be destroyed until the program exits. Doing so will\n// probably yield nasty segfaults in VLogSiteManager::UpdateLogSites(). The\n// recommendation is to make all such objects function-local statics.\nclass VLogSite final {\n public:\n  // `f` must not be destroyed until the program exits.\n  explicit constexpr VLogSite(const char* f)\n      : file_(f), v_(kUninitialized), next_(nullptr) {}\n  VLogSite(const VLogSite&) = delete;\n  VLogSite& operator=(const VLogSite&) = delete;\n\n  // Inlining the function yields a ~3x performance improvement at the cost of a\n  // 1.5x code size increase at the call site.\n  // Takes locks but does not allocate memory.\n  ABSL_ATTRIBUTE_ALWAYS_INLINE\n  bool IsEnabled(int level) {\n    int stale_v = v_.load(std::memory_order_relaxed);\n    if (ABSL_PREDICT_TRUE(level > stale_v)) {\n      return false;\n    }\n\n    // We put everything other than the fast path, i.e. vlogging is initialized\n    // but not on, behind an out-of-line function to reduce code size.\n    // \"level\" is almost always a call-site constant, so we can save a bit\n    // of code space by special-casing for a few common levels.\n#if ABSL_HAVE_BUILTIN(__builtin_constant_p) || defined(__GNUC__)\n    if (__builtin_constant_p(level)) {\n      if (level == 0) return SlowIsEnabled0(stale_v);\n      if (level == 1) return SlowIsEnabled1(stale_v);\n      if (level == 2) return SlowIsEnabled2(stale_v);\n      if (level == 3) return SlowIsEnabled3(stale_v);\n      if (level == 4) return SlowIsEnabled4(stale_v);\n      if (level == 5) return SlowIsEnabled5(stale_v);\n    }\n#endif\n    return SlowIsEnabled(stale_v, level);\n  }\n\n private:\n  friend int log_internal::RegisterAndInitialize(VLogSite* v);\n  friend void log_internal::UpdateVLogSites();\n  friend class log_internal::SyntheticBinary;\n  static constexpr int kUninitialized = (std::numeric_limits<int>::max)();\n\n  // SlowIsEnabled performs slower checks to determine whether a log site is\n  // enabled. Because it is expected to be called somewhat rarely\n  // (comparatively), it is not inlined to save on code size.\n  //\n  // Prerequisites to calling SlowIsEnabled:\n  //   1) stale_v is uninitialized OR\n  //   2) stale_v is initialized and >= level (meaning we must log).\n  // Takes locks but does not allocate memory.\n  ABSL_ATTRIBUTE_NOINLINE\n  bool SlowIsEnabled(int stale_v, int level);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled0(int stale_v);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled1(int stale_v);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled2(int stale_v);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled3(int stale_v);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled4(int stale_v);\n  ABSL_ATTRIBUTE_NOINLINE bool SlowIsEnabled5(int stale_v);\n\n  // This object is too size-sensitive to use absl::string_view.\n  const char* const file_;\n  std::atomic<int> v_;\n  std::atomic<VLogSite*> next_;\n};\nstatic_assert(std::is_trivially_destructible<VLogSite>::value,\n              \"VLogSite must be trivially destructible\");\n\n// Returns the current verbose log level of `file`.\n// Does not allocate memory.\nint VLogLevel(absl::string_view file);\n\n// Registers a site `v` to get updated as `vmodule` and `v` change.  Also\n// initializes the site based on their current values, and returns that result.\n// Does not allocate memory.\nint RegisterAndInitialize(VLogSite* v);\n\n// Allocates memory.\nvoid UpdateVLogSites();\n\n// Completely overwrites the saved value of `vmodule`.\n// Allocates memory.\nvoid UpdateVModule(absl::string_view vmodule);\n\n// Updates the global verbosity level to `v` and returns the prior value.\n// Allocates memory.\nint UpdateGlobalVLogLevel(int v);\n\n// Atomically prepends `module_pattern=log_level` to the start of vmodule.\n// Returns the prior value for `module_pattern` if there was an exact match and\n// `global_v` otherwise.\n// Allocates memory.\nint PrependVModule(absl::string_view module_pattern, int log_level);\n\n// Registers `on_update` to be called whenever `v` or `vmodule` change.\n// Allocates memory.\nvoid OnVLogVerbosityUpdate(std::function<void()> cb);\n\n// Does not allocate memory.\nVLogSite* SetVModuleListHeadForTestOnly(VLogSite* v);\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05795",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/vlog_config.h",
  "source_line": 41,
  "validation_status": "validated"
}