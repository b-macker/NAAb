{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// Moves data into the L1 cache before it is read, or \"prefetches\" it.\n//\n// The value of `addr` is the address of the memory to prefetch. If\n// the target and compiler support it, data prefetch instructions are\n// generated. If the prefetch is done some time before the memory is\n// read, it may be in the cache by the time the read occurs.\n//\n// This method prefetches data with the highest degree of temporal locality;\n// data is prefetched where possible into all levels of the cache.\n//\n// Incorrect or gratuitous use of this function can degrade performance.\n// Use this function only when representative benchmarks show an improvement.\n//\n// Example:\n//\n//  // Computes incremental checksum for `data`.\n//  int ComputeChecksum(int sum, absl::string_view data);\n//\n//  // Computes cumulative checksum for all values in `data`\n//  int ComputeChecksum(absl::Span<const std::string> data) {\n//    int sum = 0;\n//    auto it = data.begin();\n//    auto pit = data.begin();\n//    auto end = data.end();\n//    for (int dist = 8; dist > 0 && pit != data.end(); --dist, ++pit) {\n//      absl::PrefetchToLocalCache(pit->data());\n//    }\n//    for (; pit != end; ++pit, ++it) {\n//      sum = ComputeChecksum(sum, *it);\n//      absl::PrefetchToLocalCache(pit->data());\n//    }\n//    for (; it != end; ++it) {\n//      sum = ComputeChecksum(sum, *it);\n//    }\n//    return sum;\n//  }\n//\nvoid PrefetchToLocalCache(const void* addr);\n\n// Moves data into the L1 cache before it is read, or \"prefetches\" it.\n//\n// This function is identical to `PrefetchToLocalCache()` except that it has\n// non-temporal locality: the fetched data should not be left in any of the\n// cache tiers. This is useful for cases where the data is used only once /\n// short term, for example, invoking a destructor on an object.\n//\n// Incorrect or gratuitous use of this function can degrade performance.\n// Use this function only when representative benchmarks show an improvement.\n//\n// Example:\n//\n//  template <typename Iterator>\n//  void DestroyPointers(Iterator begin, Iterator end) {\n//    size_t distance = std::min(8U, bars.size());\n//\n//    int dist = 8;\n//    auto prefetch_it = begin;\n//    while (prefetch_it != end && --dist;) {\n//      absl::PrefetchToLocalCacheNta(*prefetch_it++);\n//    }\n//    while (prefetch_it != end) {\n//      delete *begin++;\n//      absl::PrefetchToLocalCacheNta(*prefetch_it++);\n//    }\n//    while (begin != end) {\n//      delete *begin++;\n//    }\n//  }\n//\nvoid PrefetchToLocalCacheNta(const void* addr);\n\n// Moves data into the L1 cache with the intent to modify it.\n//\n// This function is similar to `PrefetchToLocalCache()` except that it\n// prefetches cachelines with an 'intent to modify' This typically includes\n// invalidating cache entries for this address in all other cache tiers, and an\n// exclusive access intent.\n//\n// Incorrect or gratuitous use of this function can degrade performance. As this\n// function can invalidate cached cachelines on other caches and computer cores,\n// incorrect usage of this function can have an even greater negative impact\n// than incorrect regular prefetches.\n// Use this function only when representative benchmarks show an improvement.\n//\n// Example:\n//\n//  void* Arena::Allocate(size_t size) {\n//    void* ptr = AllocateBlock(size);\n//    absl::PrefetchToLocalCacheForWrite(p);\n//    return ptr;\n//  }\n//\nvoid PrefetchToLocalCacheForWrite(const void* addr);\n\n#if ABSL_HAVE_BUILTIN(__builtin_prefetch) || defined(__GNUC__)\n\n#define ABSL_HAVE_PREFETCH 1\n\n// See __builtin_prefetch:\n// https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html.\n//\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCache(\n    const void* addr) {\n  __builtin_prefetch(addr, 0, 3);\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheNta(\n    const void* addr) {\n  __builtin_prefetch(addr, 0, 0);\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheForWrite(\n    const void* addr) {\n  // [x86] gcc/clang don't generate PREFETCHW for __builtin_prefetch(.., 1)\n  // unless -march=broadwell or newer; this is not generally the default, so we\n  // manually emit prefetchw. PREFETCHW is recognized as a no-op on older Intel\n  // processors and has been present on AMD processors since the K6-2.\n#if defined(__x86_64__) && !defined(__PRFCHW__)\n  asm(\"prefetchw %0\" : : \"m\"(*reinterpret_cast<const char*>(addr)));\n#else\n  __builtin_prefetch(addr, 1, 3);\n#endif\n}\n\n#elif defined(ABSL_INTERNAL_HAVE_SSE)\n\n#define ABSL_HAVE_PREFETCH 1\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCache(\n    const void* addr) {\n  _mm_prefetch(reinterpret_cast<const char*>(addr), _MM_HINT_T0);\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheNta(\n    const void* addr) {\n  _mm_prefetch(reinterpret_cast<const char*>(addr), _MM_HINT_NTA);\n}\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheForWrite(\n    const void* addr) {\n#if defined(_MM_HINT_ET0)\n  _mm_prefetch(reinterpret_cast<const char*>(addr), _MM_HINT_ET0);\n#elif !defined(_MSC_VER) && defined(__x86_64__)\n  // _MM_HINT_ET0 is not universally supported. As we commented further\n  // up, PREFETCHW is recognized as a no-op on older Intel processors\n  // and has been present on AMD processors since the K6-2. We have this\n  // disabled for MSVC compilers as this miscompiles on older MSVC compilers.\n  asm(\"prefetchw %0\" : : \"m\"(*reinterpret_cast<const char*>(addr)));\n#endif\n}\n\n#else\n\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCache(\n    const void* addr) {}\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheNta(\n    const void* addr) {}\nABSL_ATTRIBUTE_ALWAYS_INLINE inline void PrefetchToLocalCacheForWrite(\n    const void* addr) {}\n\n#endif\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03457",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/prefetch.h",
  "source_line": 41,
  "validation_status": "validated"
}