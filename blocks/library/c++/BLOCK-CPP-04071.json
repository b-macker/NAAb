{
  "code": "{\n    // Inline SSO size of a CordBuffer\n    static constexpr size_t kInlineCapacity = sizeof(intptr_t) * 2 - 1;\n\n    // Creates a default instance with kInlineCapacity.\n    Rep() : short_rep{} {}\n\n    // Creates an instance managing an allocated non zero CordRep.\n    explicit Rep(cord_internal::CordRepFlat* rep) : long_rep{rep} {\n      assert(rep != nullptr);\n    }\n\n    // Returns true if this instance manages the SSO internal buffer.\n    bool is_short() const {\n      constexpr size_t offset = offsetof(Short, raw_size);\n      return (reinterpret_cast<const char*>(this)[offset] & 1) != 0;\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> short_available() {\n      const size_t length = short_length();\n      return absl::Span<char>(short_rep.data + length,\n                              kInlineCapacity - length);\n    }\n\n    // Returns the available area of the internal SSO data\n    absl::Span<char> long_available() const {\n      assert(!is_short());\n      const size_t length = long_rep.rep->length;\n      return absl::Span<char>(long_rep.rep->Data() + length,\n                              long_rep.rep->Capacity() - length);\n    }\n\n    // Returns the length of the internal SSO data.\n    size_t short_length() const {\n      assert(is_short());\n      return static_cast<size_t>(short_rep.raw_size >> 1);\n    }\n\n    // Sets the length of the internal SSO data.\n    // Disregards any previously set CordRep instance.\n    void set_short_length(size_t length) {\n      short_rep.raw_size = static_cast<char>((length << 1) + 1);\n    }\n\n    // Adds `n` to the current short length.\n    void add_short_length(size_t n) {\n      assert(is_short());\n      short_rep.raw_size += static_cast<char>(n << 1);\n    }\n\n    // Returns reference to the internal SSO data buffer.\n    char* data() {\n      assert(is_short());\n      return short_rep.data;\n    }\n    const char* data() const {\n      assert(is_short());\n      return short_rep.data;\n    }\n\n    // Returns a pointer the external CordRep managed by this instance.\n    cord_internal::CordRepFlat* rep() const {\n      assert(!is_short());\n      return long_rep.rep;\n    }\n\n    // The internal representation takes advantage of the fact that allocated\n    // memory is always on an even address, and uses the least significant bit\n    // of the first or last byte (depending on endianness) as the inline size\n    // indicator overlapping with the least significant byte of the CordRep*.\n#if defined(ABSL_IS_BIG_ENDIAN)\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      void* padding;\n      cord_internal::CordRepFlat* rep;\n    };\n    struct Short {\n      char data[sizeof(Long) - 1];\n      char raw_size = 1;\n    };\n#else\n    struct Long {\n      explicit Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg) {}\n      cord_internal::CordRepFlat* rep;\n      void* padding;\n    };\n    struct Short {\n      char raw_size = 1;\n      char data[sizeof(Long) - 1];\n    };\n#endif\n\n    union {\n      Long long_rep;\n      Short short_rep;\n    };\n  }",
  "id": "BLOCK-CPP-04071",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord_buffer.h",
  "source_line": 312,
  "validation_status": "validated"
}