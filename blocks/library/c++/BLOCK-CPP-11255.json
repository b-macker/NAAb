{
  "code": "{\n\nclass APValue;\n\nclass NodeStreamer {\n  bool FirstChild = true;\n  bool TopLevel = true;\n  llvm::SmallVector<std::function<void(bool IsLastChild)>, 32> Pending;\n\nprotected:\n  llvm::json::OStream JOS;\n\npublic:\n  /// Add a child of the current node.  Calls DoAddChild without arguments\n  template <typename Fn> void AddChild(Fn DoAddChild) {\n    return AddChild(\"\", DoAddChild);\n  }\n\n  /// Add a child of the current node with an optional label.\n  /// Calls DoAddChild without arguments.\n  template <typename Fn> void AddChild(StringRef Label, Fn DoAddChild) {\n    // If we're at the top level, there's nothing interesting to do; just\n    // run the dumper.\n    if (TopLevel) {\n      TopLevel = false;\n      JOS.objectBegin();\n\n      DoAddChild();\n\n      while (!Pending.empty()) {\n        Pending.back()(true);\n        Pending.pop_back();\n      }\n\n      JOS.objectEnd();\n      TopLevel = true;\n      return;\n    }\n\n    // We need to capture an owning-string in the lambda because the lambda\n    // is invoked in a deferred manner.\n    std::string LabelStr(!Label.empty() ? Label : \"inner\");\n    bool WasFirstChild = FirstChild;\n    auto DumpWithIndent = [=](bool IsLastChild) {\n      if (WasFirstChild) {\n        JOS.attributeBegin(LabelStr);\n        JOS.arrayBegin();\n      }\n\n      FirstChild = true;\n      unsigned Depth = Pending.size();\n      JOS.objectBegin();\n\n      DoAddChild();\n\n      // If any children are left, they're the last at their nesting level.\n      // Dump those ones out now.\n      while (Depth < Pending.size()) {\n        Pending.back()(true);\n        this->Pending.pop_back();\n      }\n\n      JOS.objectEnd();\n\n      if (IsLastChild) {\n        JOS.arrayEnd();\n        JOS.attributeEnd();\n      }\n    };\n\n    if (FirstChild) {\n      Pending.push_back(std::move(DumpWithIndent));\n    } else {\n      Pending.back()(false);\n      Pending.back() = std::move(DumpWithIndent);\n    }\n    FirstChild = false;\n  }\n\n  NodeStreamer(raw_ostream &OS) : JOS(OS, 2) {}\n};\n\n// Dumps AST nodes in JSON format. There is no implied stability for the\n// content or format of the dump between major releases of Clang, other than it\n// being valid JSON output. Further, there is no requirement that the\n// information dumped is a complete representation of the AST, only that the\n// information presented is correct.\nclass JSONNodeDumper\n    : public ConstAttrVisitor<JSONNodeDumper>,\n      public comments::ConstCommentVisitor<JSONNodeDumper, void,\n                                           const comments::FullComment *>,\n      public ConstTemplateArgumentVisitor<JSONNodeDumper>,\n      public ConstStmtVisitor<JSONNodeDumper>,\n      public TypeVisitor<JSONNodeDumper>,\n      public ConstDeclVisitor<JSONNodeDumper>,\n      public NodeStreamer {\n  friend class JSONDumper;\n\n  const SourceManager &SM;\n  ASTContext& Ctx;\n  ASTNameGenerator ASTNameGen;\n  PrintingPolicy PrintPolicy;\n  const comments::CommandTraits *Traits;\n  StringRef LastLocFilename, LastLocPresumedFilename;\n  unsigned LastLocLine, LastLocPresumedLine;\n\n  using InnerAttrVisitor = ConstAttrVisitor<JSONNodeDumper>;\n  using InnerCommentVisitor =\n      comments::ConstCommentVisitor<JSONNodeDumper, void,\n                                    const comments::FullComment *>;\n  using InnerTemplateArgVisitor = ConstTemplateArgumentVisitor<JSONNodeDumper>;\n  using InnerStmtVisitor = ConstStmtVisitor<JSONNodeDumper>;\n  using InnerTypeVisitor = TypeVisitor<JSONNodeDumper>;\n  using InnerDeclVisitor = ConstDeclVisitor<JSONNodeDumper>;\n\n  void attributeOnlyIfTrue(StringRef Key, bool Value) {\n    if (Value)\n      JOS.attribute(Key, Value);\n  }\n\n  void writeIncludeStack(PresumedLoc Loc, bool JustFirst = false);\n\n  // Writes the attributes of a SourceLocation object without.\n  void writeBareSourceLocation(SourceLocation Loc, bool IsSpelling);\n\n  // Writes the attributes of a SourceLocation to JSON based on its presumed\n  // spelling location. If the given location represents a macro invocation,\n  // this outputs two sub-objects: one for the spelling and one for the\n  // expansion location.\n  void writeSourceLocation(SourceLocation Loc);\n  void writeSourceRange(SourceRange R);\n  std::string createPointerRepresentation(const void *Ptr);\n  llvm::json::Object createQualType(QualType QT, bool Desugar = true);\n  llvm::json::Object createBareDeclRef(const Decl *D);\n  llvm::json::Object createFPOptions(FPOptionsOverride FPO);\n  void writeBareDeclRef(const Decl *D);\n  llvm::json::Object createCXXRecordDefinitionData(const CXXRecordDecl *RD);\n  llvm::json::Object createCXXBaseSpecifier(const CXXBaseSpecifier &BS);\n  std::string createAccessSpecifier(AccessSpecifier AS);\n  llvm::json::Array createCastPath(const CastExpr *C);\n\n  void writePreviousDeclImpl(...) {}\n\n  template <typename T> void writePreviousDeclImpl(const Mergeable<T> *D) {\n    const T *First = D->getFirstDecl();\n    if (First != D)\n      JOS.attribute(\"firstRedecl\", createPointerRepresentation(First));\n  }\n\n  template <typename T> void writePreviousDeclImpl(const Redeclarable<T> *D) {\n    const T *Prev = D->getPreviousDecl();\n    if (Prev)\n      JOS.attribute(\"previousDecl\", createPointerRepresentation(Prev));\n  }\n  void addPreviousDeclaration(const Decl *D);\n\n  StringRef getCommentCommandName(unsigned CommandID) const;\n\npublic:\n  JSONNodeDumper(raw_ostream &OS, const SourceManager &SrcMgr, ASTContext &Ctx,\n                 const PrintingPolicy &PrintPolicy,\n                 const comments::CommandTraits *Traits)\n      : NodeStreamer(OS), SM(SrcMgr), Ctx(Ctx), ASTNameGen(Ctx),\n        PrintPolicy(PrintPolicy), Traits(Traits), LastLocLine(0),\n        LastLocPresumedLine(0) {}\n\n  void Visit(const Attr *A);\n  void Visit(const Stmt *Node);\n  void Visit(const Type *T);\n  void Visit(QualType T);\n  void Visit(const Decl *D);\n\n  void Visit(const comments::Comment *C, const comments::FullComment *FC);\n  void Visit(const TemplateArgument &TA, SourceRange R = {},\n             const Decl *From = nullptr, StringRef Label = {});\n  void Visit(const CXXCtorInitializer *Init);\n  void Visit(const OMPClause *C);\n  void Visit(const BlockDecl::Capture &C);\n  void Visit(const GenericSelectionExpr::ConstAssociation &A);\n  void Visit(const concepts::Requirement *R);\n  void Visit(const APValue &Value, QualType Ty);\n\n  void VisitTypedefType(const TypedefType *TT);\n  void VisitUsingType(const UsingType *TT);\n  void VisitFunctionType(const FunctionType *T);\n  void VisitFunctionProtoType(const FunctionProtoType *T);\n  void VisitRValueReferenceType(const ReferenceType *RT);\n  void VisitArrayType(const ArrayType *AT);\n  void VisitConstantArrayType(const ConstantArrayType *CAT);\n  void VisitDependentSizedExtVectorType(const DependentSizedExtVectorType *VT);\n  void VisitVectorType(const VectorType *VT);\n  void VisitUnresolvedUsingType(const UnresolvedUsingType *UUT);\n  void VisitUnaryTransformType(const UnaryTransformType *UTT);\n  void VisitTagType(const TagType *TT);\n  void VisitTemplateTypeParmType(const TemplateTypeParmType *TTPT);\n  void VisitSubstTemplateTypeParmType(const SubstTemplateTypeParmType *STTPT);\n  void\n  VisitSubstTemplateTypeParmPackType(const SubstTemplateTypeParmPackType *T);\n  void VisitAutoType(const AutoType *AT);\n  void VisitTemplateSpecializationType(const TemplateSpecializationType *TST);\n  void VisitInjectedClassNameType(const InjectedClassNameType *ICNT);\n  void VisitObjCInterfaceType(const ObjCInterfaceType *OIT);\n  void VisitPackExpansionType(const PackExpansionType *PET);\n  void VisitElaboratedType(const ElaboratedType *ET);\n  void VisitMacroQualifiedType(const MacroQualifiedType *MQT);\n  void VisitMemberPointerType(const MemberPointerType *MPT);\n\n  void VisitNamedDecl(const NamedDecl *ND);\n  void VisitTypedefDecl(const TypedefDecl *TD);\n  void VisitTypeAliasDecl(const TypeAliasDecl *TAD);\n  void VisitNamespaceDecl(const NamespaceDecl *ND);\n  void VisitUsingDirectiveDecl(const UsingDirectiveDecl *UDD);\n  void VisitNamespaceAliasDecl(const NamespaceAliasDecl *NAD);\n  void VisitUsingDecl(const UsingDecl *UD);\n  void VisitUsingEnumDecl(const UsingEnumDecl *UED);\n  void VisitUsingShadowDecl(const UsingShadowDecl *USD);\n  void VisitVarDecl(const VarDecl *VD);\n  void VisitFieldDecl(const FieldDecl *FD);\n  void VisitFunctionDecl(const FunctionDecl *FD);\n  void VisitEnumDecl(const EnumDecl *ED);\n  void VisitEnumConstantDecl(const EnumConstantDecl *ECD);\n  void VisitRecordDecl(const RecordDecl *RD);\n  void VisitCXXRecordDecl(const CXXRecordDecl *RD);\n  void VisitHLSLBufferDecl(const HLSLBufferDecl *D);\n  void VisitTemplateTypeParmDecl(const TemplateTypeParmDecl *D);\n  void VisitNonTypeTemplateParmDecl(const NonTypeTemplateParmDecl *D);\n  void VisitTemplateTemplateParmDecl(const TemplateTemplateParmDecl *D);\n  void VisitLinkageSpecDecl(const LinkageSpecDecl *LSD);\n  void VisitAccessSpecDecl(const AccessSpecDecl *ASD);\n  void VisitFriendDecl(const FriendDecl *FD);\n\n  void VisitObjCIvarDecl(const ObjCIvarDecl *D);\n  void VisitObjCMethodDecl(const ObjCMethodDecl *D);\n  void VisitObjCTypeParamDecl(const ObjCTypeParamDecl *D);\n  void VisitObjCCategoryDecl(const ObjCCategoryDecl *D);\n  void VisitObjCCategoryImplDecl(const ObjCCategoryImplDecl *D);\n  void VisitObjCProtocolDecl(const ObjCProtocolDecl *D);\n  void VisitObjCInterfaceDecl(const ObjCInterfaceDecl *D);\n  void VisitObjCImplementationDecl(const ObjCImplementationDecl *D);\n  void VisitObjCCompatibleAliasDecl(const ObjCCompatibleAliasDecl *D);\n  void VisitObjCPropertyDecl(const ObjCPropertyDecl *D);\n  void VisitObjCPropertyImplDecl(const ObjCPropertyImplDecl *D);\n  void VisitBlockDecl(const BlockDecl *D);\n\n  void VisitDeclRefExpr(const DeclRefExpr *DRE);\n  void VisitSYCLUniqueStableNameExpr(const SYCLUniqueStableNameExpr *E);\n  void VisitPredefinedExpr(const PredefinedExpr *PE);\n  void VisitUnaryOperator(const UnaryOperator *UO);\n  void VisitBinaryOperator(const BinaryOperator *BO);\n  void VisitCompoundAssignOperator(const CompoundAssignOperator *CAO);\n  void VisitMemberExpr(const MemberExpr *ME);\n  void VisitCXXNewExpr(const CXXNewExpr *NE);\n  void VisitCXXDeleteExpr(const CXXDeleteExpr *DE);\n  void VisitCXXThisExpr(const CXXThisExpr *TE);\n  void VisitCastExpr(const CastExpr *CE);\n  void VisitImplicitCastExpr(const ImplicitCastExpr *ICE);\n  void VisitCallExpr(const CallExpr *CE);\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *TTE);\n  void VisitSizeOfPackExpr(const SizeOfPackExpr *SOPE);\n  void VisitUnresolvedLookupExpr(const UnresolvedLookupExpr *ULE);\n  void VisitAddrLabelExpr(const AddrLabelExpr *ALE);\n  void VisitCXXTypeidExpr(const CXXTypeidExpr *CTE);\n  void VisitConstantExpr(const ConstantExpr *CE);\n  void VisitInitListExpr(const InitListExpr *ILE);\n  void VisitGenericSelectionExpr(const GenericSelectionExpr *GSE);\n  void VisitCXXUnresolvedConstructExpr(const CXXUnresolvedConstructExpr *UCE);\n  void VisitCXXConstructExpr(const CXXConstructExpr *CE);\n  void VisitExprWithCleanups(const ExprWithCleanups *EWC);\n  void VisitCXXBindTemporaryExpr(const CXXBindTemporaryExpr *BTE);\n  void VisitMaterializeTemporaryExpr(const MaterializeTemporaryExpr *MTE);\n  void VisitCXXDependentScopeMemberExpr(const CXXDependentScopeMemberExpr *ME);\n  void VisitRequiresExpr(const RequiresExpr *RE);\n\n  void VisitObjCEncodeExpr(const ObjCEncodeExpr *OEE);\n  void VisitObjCMessageExpr(const ObjCMessageExpr *OME);\n  void VisitObjCBoxedExpr(const ObjCBoxedExpr *OBE);\n  void VisitObjCSelectorExpr(const ObjCSelectorExpr *OSE);\n  void VisitObjCProtocolExpr(const ObjCProtocolExpr *OPE);\n  void VisitObjCPropertyRefExpr(const ObjCPropertyRefExpr *OPRE);\n  void VisitObjCSubscriptRefExpr(const ObjCSubscriptRefExpr *OSRE);\n  void VisitObjCIvarRefExpr(const ObjCIvarRefExpr *OIRE);\n  void VisitObjCBoolLiteralExpr(const ObjCBoolLiteralExpr *OBLE);\n\n  void VisitIntegerLiteral(const IntegerLiteral *IL);\n  void VisitCharacterLiteral(const CharacterLiteral *CL);\n  void VisitFixedPointLiteral(const FixedPointLiteral *FPL);\n  void VisitFloatingLiteral(const FloatingLiteral *FL);\n  void VisitStringLiteral(const StringLiteral *SL);\n  void VisitCXXBoolLiteralExpr(const CXXBoolLiteralExpr *BLE);\n\n  void VisitIfStmt(const IfStmt *IS);\n  void VisitSwitchStmt(const SwitchStmt *SS);\n  void VisitCaseStmt(const CaseStmt *CS);\n  void VisitLabelStmt(const LabelStmt *LS);\n  void VisitGotoStmt(const GotoStmt *GS);\n  void VisitWhileStmt(const WhileStmt *WS);\n  void VisitObjCAtCatchStmt(const ObjCAtCatchStmt *OACS);\n  void VisitCompoundStmt(const CompoundStmt *IS);\n\n  void VisitNullTemplateArgument(const TemplateArgument &TA);\n  void VisitTypeTemplateArgument(const TemplateArgument &TA);\n  void VisitDeclarationTemplateArgument(const TemplateArgument &TA);\n  void VisitNullPtrTemplateArgument(const TemplateArgument &TA);\n  void VisitIntegralTemplateArgument(const TemplateArgument &TA);\n  void VisitTemplateTemplateArgument(const TemplateArgument &TA);\n  void VisitTemplateExpansionTemplateArgument(const TemplateArgument &TA);\n  void VisitExpressionTemplateArgument(const TemplateArgument &TA);\n  void VisitPackTemplateArgument(const TemplateArgument &TA);\n\n  void visitTextComment(const comments::TextComment *C,\n                        const comments::FullComment *);\n  void visitInlineCommandComment(const comments::InlineCommandComment *C,\n                                 const comments::FullComment *);\n  void visitHTMLStartTagComment(const comments::HTMLStartTagComment *C,\n                                const comments::FullComment *);\n  void visitHTMLEndTagComment(const comments::HTMLEndTagComment *C,\n                              const comments::FullComment *);\n  void visitBlockCommandComment(const comments::BlockCommandComment *C,\n                                const comments::FullComment *);\n  void visitParamCommandComment(const comments::ParamCommandComment *C,\n                                const comments::FullComment *FC);\n  void visitTParamCommandComment(const comments::TParamCommandComment *C,\n                                 const comments::FullComment *FC);\n  void visitVerbatimBlockComment(const comments::VerbatimBlockComment *C,\n                                 const comments::FullComment *);\n  void\n  visitVerbatimBlockLineComment(const comments::VerbatimBlockLineComment *C,\n                                const comments::FullComment *);\n  void visitVerbatimLineComment(const comments::VerbatimLineComment *C,\n                                const comments::FullComment *);\n};\n\nclass JSONDumper : public ASTNodeTraverser<JSONDumper, JSONNodeDumper> {\n  JSONNodeDumper NodeDumper;\n\n  template <typename SpecializationDecl>\n  void writeTemplateDeclSpecialization(const SpecializationDecl *SD,\n                                       bool DumpExplicitInst,\n                                       bool DumpRefOnly) {\n    bool DumpedAny = false;\n    for (const auto *RedeclWithBadType : SD->redecls()) {\n      // FIXME: The redecls() range sometimes has elements of a less-specific\n      // type. (In particular, ClassTemplateSpecializationDecl::redecls() gives\n      // us TagDecls, and should give CXXRecordDecls).\n      const auto *Redecl = dyn_cast<SpecializationDecl>(RedeclWithBadType);\n      if (!Redecl) {\n        // Found the injected-class-name for a class template. This will be\n        // dumped as part of its surrounding class so we don't need to dump it\n        // here.\n        assert(isa<CXXRecordDecl>(RedeclWithBadType) &&\n               \"expected an injected-class-name\");\n        continue;\n      }\n\n      switch (Redecl->getTemplateSpecializationKind()) {\n      case TSK_ExplicitInstantiationDeclaration:\n      case TSK_ExplicitInstantiationDefinition:\n        if (!DumpExplicitInst)\n          break;\n        [[fallthrough]];\n      case TSK_Undeclared:\n      case TSK_ImplicitInstantiation:\n        if (DumpRefOnly)\n          NodeDumper.AddChild([=] { NodeDumper.writeBareDeclRef(Redecl); });\n        else\n          Visit(Redecl);\n        DumpedAny = true;\n        break;\n      case TSK_ExplicitSpecialization:\n        break;\n      }\n    }\n\n    // Ensure we dump at least one decl for each specialization.\n    if (!DumpedAny)\n      NodeDumper.AddChild([=] { NodeDumper.writeBareDeclRef(SD); });\n  }\n\n  template <typename TemplateDecl>\n  void writeTemplateDecl(const TemplateDecl *TD, bool DumpExplicitInst) {\n    // FIXME: it would be nice to dump template parameters and specializations\n    // to their own named arrays rather than shoving them into the \"inner\"\n    // array. However, template declarations are currently being handled at the\n    // wrong \"level\" of the traversal hierarchy and so it is difficult to\n    // achieve without losing information elsewhere.\n\n    dumpTemplateParameters(TD->getTemplateParameters());\n\n    Visit(TD->getTemplatedDecl());\n\n    for (const auto *Child : TD->specializations())\n      writeTemplateDeclSpecialization(Child, DumpExplicitInst,\n                                      !TD->isCanonicalDecl());\n  }\n\npublic:\n  JSONDumper(raw_ostream &OS, const SourceManager &SrcMgr, ASTContext &Ctx,\n             const PrintingPolicy &PrintPolicy,\n             const comments::CommandTraits *Traits)\n      : NodeDumper(OS, SrcMgr, Ctx, PrintPolicy, Traits) {}\n\n  JSONNodeDumper &doGetNodeDelegate() { return NodeDumper; }\n\n  void VisitFunctionTemplateDecl(const FunctionTemplateDecl *FTD) {\n    writeTemplateDecl(FTD, true);\n  }\n  void VisitClassTemplateDecl(const ClassTemplateDecl *CTD) {\n    writeTemplateDecl(CTD, false);\n  }\n  void VisitVarTemplateDecl(const VarTemplateDecl *VTD) {\n    writeTemplateDecl(VTD, false);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-11255",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/JSONNodeDumper.h",
  "source_line": 29,
  "validation_status": "validated"
}