{
  "code": "#include <atomic>\n#include <string>\n#include \"gmock/gmock.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/log_severity.h\"\n#include \"absl/log/log_entry.h\"\n#include \"absl/log/log_sink.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03686_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// MockLogDefault\n//\n// Controls how ScopedMockLog responds to unexpected calls by default.\nenum class MockLogDefault { kIgnoreUnexpected, kDisallowUnexpected };\n\n// ScopedMockLog\n//\n// ScopedMockLog is a LogSink that intercepts LOG() messages issued during its\n// lifespan.\n//\n// Using this together with GoogleTest, it's easy to test how a piece of code\n// calls LOG(). The typical usage, noting the distinction between\n// \"uninteresting\" and \"unexpected\", looks like this:\n//\n//   using ::testing::_;\n//   using ::testing::AnyNumber;\n//   using ::testing::EndsWith;\n//   using ::testing::kDoNotCaptureLogsYet;\n//   using ::testing::Lt;\n//\n//   TEST(FooTest, LogsCorrectly) {\n//     // Simple robust setup, ignores unexpected logs.\n//     absl::ScopedMockLog log;\n//\n//     // We expect the WARNING \"Something bad!\" exactly twice.\n//     EXPECT_CALL(log, Log(absl::LogSeverity::kWarning, _, \"Something bad!\"))\n//         .Times(2);\n//\n//     // But we want no messages from foo.cc.\n//     EXPECT_CALL(log, Log(_, EndsWith(\"/foo.cc\"), _)).Times(0);\n//\n//     log.StartCapturingLogs();  // Call this after done setting expectations.\n//     Foo();  // Exercises the code under test.\n//   }\n//\n//   TEST(BarTest, LogsExactlyCorrectly) {\n//     // Strict checking, fails for unexpected logs.\n//     absl::ScopedMockLog log(absl::MockLogDefault::kDisallowUnexpected);\n//\n//     // ... but ignore low severity messages\n//     EXPECT_CALL(log, Log(Lt(absl::LogSeverity::kWarning), _, _))\n//         .Times(AnyNumber());\n//\n//     // We expect the ERROR \"Something bad!\" exactly once.\n//     EXPECT_CALL(log, Log(absl::LogSeverity::kError, EndsWith(\"/foo.cc\"),\n//                 \"Something bad!\"))\n//         .Times(1);\n//\n//     log.StartCapturingLogs();  // Call this after done setting expectations.\n//     Bar();  // Exercises the code under test.\n//    }\n//\n// Note that in a multi-threaded environment, all LOG() messages from a single\n// thread will be handled in sequence, but that cannot be guaranteed for\n// messages from different threads. In fact, if the same or multiple\n// expectations are matched on two threads concurrently, their actions will be\n// executed concurrently as well and may interleave.\nclass ScopedMockLog final {\n public:\n  // ScopedMockLog::ScopedMockLog()\n  //\n  // Sets up the log and adds default expectations.\n  explicit ScopedMockLog(\n      MockLogDefault default_exp = MockLogDefault::kIgnoreUnexpected);\n  ScopedMockLog(const ScopedMockLog&) = delete;\n  ScopedMockLog& operator=(const ScopedMockLog&) = delete;\n\n  // ScopedMockLog::~ScopedMockLog()\n  //\n  // Stops intercepting logs and destroys this ScopedMockLog.\n  ~ScopedMockLog();\n\n  // ScopedMockLog::StartCapturingLogs()\n  //\n  // Starts log capturing if the object isn't already doing so. Otherwise\n  // crashes.\n  //\n  // Usually this method is called in the same thread that created this\n  // ScopedMockLog. It is the user's responsibility to not call this method if\n  // another thread may be calling it or StopCapturingLogs() at the same time.\n  // It is undefined behavior to add expectations while capturing logs is\n  // enabled.\n  void StartCapturingLogs();\n\n  // ScopedMockLog::StopCapturingLogs()\n  //\n  // Stops log capturing if the object is capturing logs. Otherwise crashes.\n  //\n  // Usually this method is called in the same thread that created this object.\n  // It is the user's responsibility to not call this method if another thread\n  // may be calling it or StartCapturingLogs() at the same time.\n  //\n  // It is UB to add expectations, while capturing logs is enabled.\n  void StopCapturingLogs();\n\n  // ScopedMockLog::UseAsLocalSink()\n  //\n  // Each `ScopedMockLog` is implemented with an `absl::LogSink`; this method\n  // returns a reference to that sink (e.g. for use with\n  // `LOG(...).ToSinkOnly()`) and marks the `ScopedMockLog` as having been used\n  // even if `StartCapturingLogs` is never called.\n  absl::LogSink& UseAsLocalSink();\n\n  // Implements the mock method:\n  //\n  //   void Log(LogSeverity severity, absl::string_view file_path,\n  //            absl::string_view message);\n  //\n  // The second argument to Log() is the full path of the source file in\n  // which the LOG() was issued.\n  //\n  // This is a shorthand form, which should be used by most users. Use the\n  // `Send` mock only if you want to add expectations for other log message\n  // attributes.\n  MOCK_METHOD(void, Log,\n              (absl::LogSeverity severity, const std::string& file_path,\n               const std::string& message));\n\n  // Implements the mock method:\n  //\n  //   void Send(const absl::LogEntry& entry);\n  //\n  // This is the most generic form of mock that can be specified. Use this mock\n  // only if you want to add expectations for log message attributes different\n  // from the log message text, log message path and log message severity.\n  //\n  // If no expectations are specified for this mock, the default action is to\n  // forward the call to the `Log` mock.\n  MOCK_METHOD(void, Send, (const absl::LogEntry&));\n\n  // Implements the mock method:\n  //\n  //   void Flush();\n  //\n  // Use this mock only if you want to add expectations for log flush calls.\n  MOCK_METHOD(void, Flush, ());\n\n private:\n  class ForwardingSink final : public absl::LogSink {\n   public:\n    explicit ForwardingSink(ScopedMockLog* sml) : sml_(sml) {}\n    ForwardingSink(const ForwardingSink&) = delete;\n    ForwardingSink& operator=(const ForwardingSink&) = delete;\n    void Send(const absl::LogEntry& entry) override { sml_->Send(entry); }\n    void Flush() override { sml_->Flush(); }\n\n   private:\n    ScopedMockLog* sml_;\n  };\n\n  ForwardingSink sink_;\n  bool is_capturing_logs_;\n  // Until C++20, the default constructor leaves the underlying value wrapped in\n  // std::atomic uninitialized, so all constructors should be sure to initialize\n  // is_triggered_.\n  std::atomic<bool> is_triggered_;\n};\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03686",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/scoped_mock_log.h",
  "source_line": 33,
  "validation_status": "validated"
}