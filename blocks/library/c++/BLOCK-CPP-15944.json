{
  "code": "{\n  /// Args - a map of (index, ArgEffect) pairs, where index\n  ///  specifies the argument (starting from 0).  This can be sparsely\n  ///  populated; arguments with no entry in Args use 'DefaultArgEffect'.\n  ArgEffects Args;\n\n  /// DefaultArgEffect - The default ArgEffect to apply to arguments that\n  ///  do not have an entry in Args.\n  ArgEffect DefaultArgEffect;\n\n  /// Receiver - If this summary applies to an Objective-C message expression,\n  ///  this is the effect applied to the state of the receiver.\n  ArgEffect Receiver;\n\n  /// Effect on \"this\" pointer - applicable only to C++ method calls.\n  ArgEffect This;\n\n  /// Ret - The effect on the return value.  Used to indicate if the\n  ///  function/method call returns a new tracked symbol.\n  RetEffect Ret;\n\npublic:\n  RetainSummary(ArgEffects A,\n                RetEffect R,\n                ArgEffect defaultEff,\n                ArgEffect ReceiverEff,\n                ArgEffect ThisEff)\n    : Args(A), DefaultArgEffect(defaultEff), Receiver(ReceiverEff),\n      This(ThisEff), Ret(R) {}\n\n  /// getArg - Return the argument effect on the argument specified by\n  ///  idx (starting from 0).\n  ArgEffect getArg(unsigned idx) const {\n    if (const ArgEffect *AE = Args.lookup(idx))\n      return *AE;\n\n    return DefaultArgEffect;\n  }\n\n  void addArg(ArgEffects::Factory &af, unsigned idx, ArgEffect e) {\n    Args = af.add(Args, idx, e);\n  }\n\n  /// setDefaultArgEffect - Set the default argument effect.\n  void setDefaultArgEffect(ArgEffect E) {\n    DefaultArgEffect = E;\n  }\n\n  /// getRetEffect - Returns the effect on the return value of the call.\n  RetEffect getRetEffect() const { return Ret; }\n\n  /// setRetEffect - Set the effect of the return value of the call.\n  void setRetEffect(RetEffect E) { Ret = E; }\n\n\n  /// Sets the effect on the receiver of the message.\n  void setReceiverEffect(ArgEffect e) { Receiver = e; }\n\n  /// getReceiverEffect - Returns the effect on the receiver of the call.\n  ///  This is only meaningful if the summary applies to an ObjCMessageExpr*.\n  ArgEffect getReceiverEffect() const { return Receiver; }\n\n  /// \\return the effect on the \"this\" receiver of the method call.\n  /// This is only meaningful if the summary applies to CXXMethodDecl*.\n  ArgEffect getThisEffect() const { return This; }\n\n  ArgEffect getDefaultEffect() const { return DefaultArgEffect; }\n\n  /// Set the effect of the method on \"this\".\n  void setThisEffect(ArgEffect e) { This = e; }\n\n  bool isNoop() const {\n    return Ret == RetEffect::MakeNoRet() && Receiver.getKind() == DoNothing\n      && DefaultArgEffect.getKind() == MayEscape && This.getKind() == DoNothing\n      && Args.isEmpty();\n  }\n\n  /// Test if two retain summaries are identical. Note that merely equivalent\n  /// summaries are not necessarily identical (for example, if an explicit\n  /// argument effect matches the default effect).\n  bool operator==(const RetainSummary &Other) const {\n    return Args == Other.Args && DefaultArgEffect == Other.DefaultArgEffect &&\n           Receiver == Other.Receiver && This == Other.This && Ret == Other.Ret;\n  }\n\n  /// Profile this summary for inclusion in a FoldingSet.\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.Add(Args);\n    ID.Add(DefaultArgEffect);\n    ID.Add(Receiver);\n    ID.Add(This);\n    ID.Add(Ret);\n  }\n\n  /// A retain summary is simple if it has no ArgEffects other than the default.\n  bool isSimple() const {\n    return Args.isEmpty();\n  }\n\n  ArgEffects getArgEffects() const { return Args; }\n\nprivate:\n  ArgEffect getDefaultArgEffect() const { return DefaultArgEffect; }\n\n  friend class RetainSummaryManager;\n}",
  "id": "BLOCK-CPP-15944",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/RetainSummaryManager.h",
  "source_line": 283,
  "validation_status": "validated"
}