{
  "code": "{\n\ntemplate <typename... Ts>\nclass CompressedTuple;\n\nnamespace internal_compressed_tuple {\n\ntemplate <typename D, size_t I>\nstruct Elem;\ntemplate <typename... B, size_t I>\nstruct Elem<CompressedTuple<B...>, I>\n    : std::tuple_element<I, std::tuple<B...>> {};\ntemplate <typename D, size_t I>\nusing ElemT = typename Elem<D, I>::type;\n\n// We can't use EBCO on other CompressedTuples because that would mean that we\n// derive from multiple Storage<> instantiations with the same I parameter,\n// and potentially from multiple identical Storage<> instantiations.  So anytime\n// we use type inheritance rather than encapsulation, we mark\n// CompressedTupleImpl, to make this easy to detect.\nstruct uses_inheritance {};\n\ntemplate <typename T>\nconstexpr bool ShouldUseBase() {\n  return std::is_class<T>::value && std::is_empty<T>::value &&\n         !std::is_final<T>::value &&\n         !std::is_base_of<uses_inheritance, T>::value;\n}\n\n// The storage class provides two specializations:\n//  - For empty classes, it stores T as a base class.\n//  - For everything else, it stores T as a member.\ntemplate <typename T, size_t I, bool UseBase = ShouldUseBase<T>()>\nstruct Storage {\n  T value;\n  constexpr Storage() = default;\n  template <typename V>\n  explicit constexpr Storage(absl::in_place_t, V&& v)\n      : value(absl::forward<V>(v)) {}\n  constexpr const T& get() const& { return value; }\n  T& get() & { return value; }\n  constexpr const T&& get() const&& { return absl::move(*this).value; }\n  T&& get() && { return std::move(*this).value; }\n};\n\ntemplate <typename T, size_t I>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC Storage<T, I, true> : T {\n  constexpr Storage() = default;\n\n  template <typename V>\n  explicit constexpr Storage(absl::in_place_t, V&& v)\n      : T(absl::forward<V>(v)) {}\n\n  constexpr const T& get() const& { return *this; }\n  T& get() & { return *this; }\n  constexpr const T&& get() const&& { return absl::move(*this); }\n  T&& get() && { return std::move(*this); }\n};\n\ntemplate <typename D, typename I, bool ShouldAnyUseBase>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl;\n\ntemplate <typename... Ts, size_t... I, bool ShouldAnyUseBase>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl<\n    CompressedTuple<Ts...>, absl::index_sequence<I...>, ShouldAnyUseBase>\n    // We use the dummy identity function through std::integral_constant to\n    // convince MSVC of accepting and expanding I in that context. Without it\n    // you would get:\n    //   error C3548: 'I': parameter pack cannot be used in this context\n    : uses_inheritance,\n      Storage<Ts, std::integral_constant<size_t, I>::value>... {\n  constexpr CompressedTupleImpl() = default;\n  template <typename... Vs>\n  explicit constexpr CompressedTupleImpl(absl::in_place_t, Vs&&... args)\n      : Storage<Ts, I>(absl::in_place, absl::forward<Vs>(args))... {}\n  friend CompressedTuple<Ts...>;\n};\n\ntemplate <typename... Ts, size_t... I>\nstruct ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTupleImpl<\n    CompressedTuple<Ts...>, absl::index_sequence<I...>, false>\n    // We use the dummy identity function as above...\n    : Storage<Ts, std::integral_constant<size_t, I>::value, false>... {\n  constexpr CompressedTupleImpl() = default;\n  template <typename... Vs>\n  explicit constexpr CompressedTupleImpl(absl::in_place_t, Vs&&... args)\n      : Storage<Ts, I, false>(absl::in_place, absl::forward<Vs>(args))... {}\n  friend CompressedTuple<Ts...>;\n};\n\nstd::false_type Or(std::initializer_list<std::false_type>);\nstd::true_type Or(std::initializer_list<bool>);\n\n// MSVC requires this to be done separately rather than within the declaration\n// of CompressedTuple below.\ntemplate <typename... Ts>\nconstexpr bool ShouldAnyUseBase() {\n  return decltype(\n      Or({std::integral_constant<bool, ShouldUseBase<Ts>()>()...})){};\n}\n\ntemplate <typename T, typename V>\nusing TupleElementMoveConstructible =\n    typename std::conditional<std::is_reference<T>::value,\n                              std::is_convertible<V, T>,\n                              std::is_constructible<T, V&&>>::type;\n\ntemplate <bool SizeMatches, class T, class... Vs>\nstruct TupleMoveConstructible : std::false_type {};\n\ntemplate <class... Ts, class... Vs>\nstruct TupleMoveConstructible<true, CompressedTuple<Ts...>, Vs...>\n    : std::integral_constant<\n          bool, absl::conjunction<\n                    TupleElementMoveConstructible<Ts, Vs&&>...>::value> {};\n\ntemplate <typename T>\nstruct compressed_tuple_size;\n\ntemplate <typename... Es>\nstruct compressed_tuple_size<CompressedTuple<Es...>>\n    : public std::integral_constant<std::size_t, sizeof...(Es)> {};\n\ntemplate <class T, class... Vs>\nstruct TupleItemsMoveConstructible\n    : std::integral_constant<\n          bool, TupleMoveConstructible<compressed_tuple_size<T>::value ==\n                                           sizeof...(Vs),\n                                       T, Vs...>::value> {};\n\n}  // namespace internal_compressed_tuple\n\n// Helper class to perform the Empty Base Class Optimization.\n// Ts can contain classes and non-classes, empty or not. For the ones that\n// are empty classes, we perform the CompressedTuple. If all types in Ts are\n// empty classes, then CompressedTuple<Ts...> is itself an empty class.  (This\n// does not apply when one or more of those empty classes is itself an empty\n// CompressedTuple.)\n//\n// To access the members, use member .get<N>() function.\n//\n// Eg:\n//   absl::container_internal::CompressedTuple<int, T1, T2, T3> value(7, t1, t2,\n//                                                                    t3);\n//   assert(value.get<0>() == 7);\n//   T1& t1 = value.get<1>();\n//   const T2& t2 = value.get<2>();\n//   ...\n//\n// https://en.cppreference.com/w/cpp/language/ebo\ntemplate <typename... Ts>\nclass ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTuple\n    : private internal_compressed_tuple::CompressedTupleImpl<\n          CompressedTuple<Ts...>, absl::index_sequence_for<Ts...>,\n          internal_compressed_tuple::ShouldAnyUseBase<Ts...>()> {\n private:\n  template <int I>\n  using ElemT = internal_compressed_tuple::ElemT<CompressedTuple, I>;\n\n  template <int I>\n  using StorageT = internal_compressed_tuple::Storage<ElemT<I>, I>;\n\n public:\n  // There seems to be a bug in MSVC dealing in which using '=default' here will\n  // cause the compiler to ignore the body of other constructors. The work-\n  // around is to explicitly implement the default constructor.\n#if defined(_MSC_VER)\n  constexpr CompressedTuple() : CompressedTuple::CompressedTupleImpl() {}\n#else\n  constexpr CompressedTuple() = default;\n#endif\n  explicit constexpr CompressedTuple(const Ts&... base)\n      : CompressedTuple::CompressedTupleImpl(absl::in_place, base...) {}\n\n  template <typename First, typename... Vs,\n            absl::enable_if_t<\n                absl::conjunction<\n                    // Ensure we are not hiding default copy/move constructors.\n                    absl::negation<std::is_same<void(CompressedTuple),\n                                                void(absl::decay_t<First>)>>,\n                    internal_compressed_tuple::TupleItemsMoveConstructible<\n                        CompressedTuple<Ts...>, First, Vs...>>::value,\n                bool> = true>\n  explicit constexpr CompressedTuple(First&& first, Vs&&... base)\n      : CompressedTuple::CompressedTupleImpl(absl::in_place,\n                                             absl::forward<First>(first),\n                                             absl::forward<Vs>(base)...) {}\n\n  template <int I>\n  ElemT<I>& get() & {\n    return StorageT<I>::get();\n  }\n\n  template <int I>\n  constexpr const ElemT<I>& get() const& {\n    return StorageT<I>::get();\n  }\n\n  template <int I>\n  ElemT<I>&& get() && {\n    return std::move(*this).StorageT<I>::get();\n  }\n\n  template <int I>\n  constexpr const ElemT<I>&& get() const&& {\n    return absl::move(*this).StorageT<I>::get();\n  }\n};\n\n// Explicit specialization for a zero-element tuple\n// (needed to avoid ambiguous overloads for the default constructor).\ntemplate <>\nclass ABSL_INTERNAL_COMPRESSED_TUPLE_DECLSPEC CompressedTuple<> {};\n\n}",
  "id": "BLOCK-CPP-04960",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/compressed_tuple.h",
  "source_line": 52,
  "validation_status": "validated"
}