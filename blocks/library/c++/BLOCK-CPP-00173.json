{
  "code": "{\n\nusing default_factory = synchronous_factory;\n\n// Create and register a logger with a templated sink type\n// The logger's level, formatter and flush level will be set according the\n// global settings.\n//\n// Example:\n//   spdlog::create<daily_file_sink_st>(\"logger_name\", \"dailylog_filename\", 11, 59);\ntemplate <typename Sink, typename... SinkArgs>\ninline std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs &&...sink_args) {\n    return default_factory::create<Sink>(std::move(logger_name),\n                                         std::forward<SinkArgs>(sink_args)...);\n}\n\n// Initialize and register a logger,\n// formatter and flush level will be set according the global settings.\n//\n// Useful for initializing manually created loggers with the global settings.\n//\n// Example:\n//   auto mylogger = std::make_shared<spdlog::logger>(\"mylogger\", ...);\n//   spdlog::initialize_logger(mylogger);\nSPDLOG_API void initialize_logger(std::shared_ptr<logger> logger);\n\n// Return an existing logger or nullptr if a logger with such name doesn't\n// exist.\n// example: spdlog::get(\"my_logger\")->info(\"hello {}\", \"world\");\nSPDLOG_API std::shared_ptr<logger> get(const std::string &name);\n\n// Set global formatter. Each sink in each logger will get a clone of this object\nSPDLOG_API void set_formatter(std::unique_ptr<spdlog::formatter> formatter);\n\n// Set global format string.\n// example: spdlog::set_pattern(\"%Y-%m-%d %H:%M:%S.%e %l : %v\");\nSPDLOG_API void set_pattern(std::string pattern,\n                            pattern_time_type time_type = pattern_time_type::local);\n\n// enable global backtrace support\nSPDLOG_API void enable_backtrace(size_t n_messages);\n\n// disable global backtrace support\nSPDLOG_API void disable_backtrace();\n\n// call dump backtrace on default logger\nSPDLOG_API void dump_backtrace();\n\n// Get global logging level\nSPDLOG_API level::level_enum get_level();\n\n// Set global logging level\nSPDLOG_API void set_level(level::level_enum log_level);\n\n// Determine whether the default logger should log messages with a certain level\nSPDLOG_API bool should_log(level::level_enum lvl);\n\n// Set global flush level\nSPDLOG_API void flush_on(level::level_enum log_level);\n\n// Start/Restart a periodic flusher thread\n// Warning: Use only if all your loggers are thread safe!\ntemplate <typename Rep, typename Period>\ninline void flush_every(std::chrono::duration<Rep, Period> interval) {\n    details::registry::instance().flush_every(interval);\n}\n\n// Set global error handler\nSPDLOG_API void set_error_handler(void (*handler)(const std::string &msg));\n\n// Register the given logger with the given name\nSPDLOG_API void register_logger(std::shared_ptr<logger> logger);\n\n// Apply a user defined function on all registered loggers\n// Example:\n// spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});\nSPDLOG_API void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun);\n\n// Drop the reference to the given logger\nSPDLOG_API void drop(const std::string &name);\n\n// Drop all references from the registry\nSPDLOG_API void drop_all();\n\n// stop any running threads started by spdlog and clean registry loggers\nSPDLOG_API void shutdown();\n\n// Automatic registration of loggers when using spdlog::create() or spdlog::create_async\nSPDLOG_API void set_automatic_registration(bool automatic_registration);\n\n// API for using default logger (stdout_color_mt),\n// e.g: spdlog::info(\"Message {}\", 1);\n//\n// The default logger object can be accessed using the spdlog::default_logger():\n// For example, to add another sink to it:\n// spdlog::default_logger()->sinks().push_back(some_sink);\n//\n// The default logger can replaced using spdlog::set_default_logger(new_logger).\n// For example, to replace it with a file logger.\n//\n// IMPORTANT:\n// The default API is thread safe (for _mt loggers), but:\n// set_default_logger() *should not* be used concurrently with the default API.\n// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.\n\nSPDLOG_API std::shared_ptr<spdlog::logger> default_logger();\n\nSPDLOG_API spdlog::logger *default_logger_raw();\n\nSPDLOG_API void set_default_logger(std::shared_ptr<spdlog::logger> default_logger);\n\n// Initialize logger level based on environment configs.\n//\n// Useful for applying SPDLOG_LEVEL to manually created loggers.\n//\n// Example:\n//   auto mylogger = std::make_shared<spdlog::logger>(\"mylogger\", ...);\n//   spdlog::apply_logger_env_levels(mylogger);\nSPDLOG_API void apply_logger_env_levels(std::shared_ptr<logger> logger);\n\ntemplate <typename... Args>\ninline void log(source_loc source,\n                level::level_enum lvl,\n                format_string_t<Args...> fmt,\n                Args &&...args) {\n    default_logger_raw()->log(source, lvl, fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void log(level::level_enum lvl, format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void trace(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->trace(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void debug(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->debug(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void info(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->info(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void warn(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->warn(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void error(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->error(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void critical(format_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->critical(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename T>\ninline void log(source_loc source, level::level_enum lvl, const T &msg) {\n    default_logger_raw()->log(source, lvl, msg);\n}\n\ntemplate <typename T>\ninline void log(level::level_enum lvl, const T &msg) {\n    default_logger_raw()->log(lvl, msg);\n}\n\n#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\ntemplate <typename... Args>\ninline void log(source_loc source,\n                level::level_enum lvl,\n                wformat_string_t<Args...> fmt,\n                Args &&...args) {\n    default_logger_raw()->log(source, lvl, fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void log(level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void trace(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->trace(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void debug(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->debug(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void info(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->info(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void warn(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->warn(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void error(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->error(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <typename... Args>\ninline void critical(wformat_string_t<Args...> fmt, Args &&...args) {\n    default_logger_raw()->critical(fmt, std::forward<Args>(args)...);\n}\n#endif\n\ntemplate <typename T>\ninline void trace(const T &msg) {\n    default_logger_raw()->trace(msg);\n}\n\ntemplate <typename T>\ninline void debug(const T &msg) {\n    default_logger_raw()->debug(msg);\n}\n\ntemplate <typename T>\ninline void info(const T &msg) {\n    default_logger_raw()->info(msg);\n}\n\ntemplate <typename T>\ninline void warn(const T &msg) {\n    default_logger_raw()->warn(msg);\n}\n\ntemplate <typename T>\ninline void error(const T &msg) {\n    default_logger_raw()->error(msg);\n}\n\ntemplate <typename T>\ninline void critical(const T &msg) {\n    default_logger_raw()->critical(msg);\n}\n\n}",
  "id": "BLOCK-CPP-00173",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/spdlog.h",
  "source_line": 23,
  "validation_status": "validated"
}