{
  "code": "#include <cmath>\n#include <limits>\n#include <type_traits>\n#include \"absl/base/config.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/random/internal/traits.h\"\n\nusing namespace absl;\nusing namespace random_internal;\nusing namespace random_internal;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05987_execute() {\n    {\n\n// In the absence of an explicitly provided return-type, the template\n// \"uniform_inferred_return_t<A, B>\" is used to derive a suitable type, based on\n// the data-types of the endpoint-arguments {A lo, B hi}.\n//\n// Given endpoints {A lo, B hi}, one of {A, B} will be chosen as the\n// return-type, if one type can be implicitly converted into the other, in a\n// lossless way. The template \"is_widening_convertible\" implements the\n// compile-time logic for deciding if such a conversion is possible.\n//\n// If no such conversion between {A, B} exists, then the overload for\n// absl::Uniform() will be discarded, and the call will be ill-formed.\n// Return-type for absl::Uniform() when the return-type is inferred.\ntemplate <typename A, typename B>\nusing uniform_inferred_return_t =\n    absl::enable_if_t<absl::disjunction<is_widening_convertible<A, B>,\n                                        is_widening_convertible<B, A>>::value,\n                      typename std::conditional<\n                          is_widening_convertible<A, B>::value, B, A>::type>;\n\n// The functions\n//    uniform_lower_bound(tag, a, b)\n// and\n//    uniform_upper_bound(tag, a, b)\n// are used as implementation-details for absl::Uniform().\n//\n// Conceptually,\n//    [a, b] == [uniform_lower_bound(IntervalClosedClosed, a, b),\n//               uniform_upper_bound(IntervalClosedClosed, a, b)]\n//    (a, b) == [uniform_lower_bound(IntervalOpenOpen, a, b),\n//               uniform_upper_bound(IntervalOpenOpen, a, b)]\n//    [a, b) == [uniform_lower_bound(IntervalClosedOpen, a, b),\n//               uniform_upper_bound(IntervalClosedOpen, a, b)]\n//    (a, b] == [uniform_lower_bound(IntervalOpenClosed, a, b),\n//               uniform_upper_bound(IntervalOpenClosed, a, b)]\n//\ntemplate <typename IntType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        IsIntegral<IntType>,\n        absl::disjunction<std::is_same<Tag, IntervalOpenClosedTag>,\n                          std::is_same<Tag, IntervalOpenOpenTag>>>::value,\n    IntType>\nuniform_lower_bound(Tag, IntType a, IntType) {\n  return a < (std::numeric_limits<IntType>::max)() ? (a + 1) : a;\n}\n\ntemplate <typename FloatType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        std::is_floating_point<FloatType>,\n        absl::disjunction<std::is_same<Tag, IntervalOpenClosedTag>,\n                          std::is_same<Tag, IntervalOpenOpenTag>>>::value,\n    FloatType>\nuniform_lower_bound(Tag, FloatType a, FloatType b) {\n  return std::nextafter(a, b);\n}\n\ntemplate <typename NumType, typename Tag>\ntypename absl::enable_if_t<\n    absl::disjunction<std::is_same<Tag, IntervalClosedClosedTag>,\n                      std::is_same<Tag, IntervalClosedOpenTag>>::value,\n    NumType>\nuniform_lower_bound(Tag, NumType a, NumType) {\n  return a;\n}\n\ntemplate <typename IntType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        IsIntegral<IntType>,\n        absl::disjunction<std::is_same<Tag, IntervalClosedOpenTag>,\n                          std::is_same<Tag, IntervalOpenOpenTag>>>::value,\n    IntType>\nuniform_upper_bound(Tag, IntType, IntType b) {\n  return b > (std::numeric_limits<IntType>::min)() ? (b - 1) : b;\n}\n\ntemplate <typename FloatType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        std::is_floating_point<FloatType>,\n        absl::disjunction<std::is_same<Tag, IntervalClosedOpenTag>,\n                          std::is_same<Tag, IntervalOpenOpenTag>>>::value,\n    FloatType>\nuniform_upper_bound(Tag, FloatType, FloatType b) {\n  return b;\n}\n\ntemplate <typename IntType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        IsIntegral<IntType>,\n        absl::disjunction<std::is_same<Tag, IntervalClosedClosedTag>,\n                          std::is_same<Tag, IntervalOpenClosedTag>>>::value,\n    IntType>\nuniform_upper_bound(Tag, IntType, IntType b) {\n  return b;\n}\n\ntemplate <typename FloatType, typename Tag>\ntypename absl::enable_if_t<\n    absl::conjunction<\n        std::is_floating_point<FloatType>,\n        absl::disjunction<std::is_same<Tag, IntervalClosedClosedTag>,\n                          std::is_same<Tag, IntervalOpenClosedTag>>>::value,\n    FloatType>\nuniform_upper_bound(Tag, FloatType, FloatType b) {\n  return std::nextafter(b, (std::numeric_limits<FloatType>::max)());\n}\n\n// Returns whether the bounds are valid for the underlying distribution.\n// Inputs must have already been resolved via uniform_*_bound calls.\n//\n// The c++ standard constraints in [rand.dist.uni.int] are listed as:\n//    requires: lo <= hi.\n//\n// In the uniform_int_distrubtion, {lo, hi} are closed, closed. Thus:\n// [0, 0] is legal.\n// [0, 0) is not legal, but [0, 1) is, which translates to [0, 0].\n// (0, 1) is not legal, but (0, 2) is, which translates to [1, 1].\n// (0, 0] is not legal, but (0, 1] is, which translates to [1, 1].\n//\n// The c++ standard constraints in [rand.dist.uni.real] are listed as:\n//    requires: lo <= hi.\n//    requires: (hi - lo) <= numeric_limits<T>::max()\n//\n// In the uniform_real_distribution, {lo, hi} are closed, open, Thus:\n// [0, 0] is legal, which is [0, 0+epsilon).\n// [0, 0) is legal.\n// (0, 0) is not legal, but (0-epsilon, 0+epsilon) is.\n// (0, 0] is not legal, but (0, 0+epsilon] is.\n//\ntemplate <typename FloatType>\nabsl::enable_if_t<std::is_floating_point<FloatType>::value, bool>\nis_uniform_range_valid(FloatType a, FloatType b) {\n  return a <= b && std::isfinite(b - a);\n}\n\ntemplate <typename IntType>\nabsl::enable_if_t<IsIntegral<IntType>::value, bool>\nis_uniform_range_valid(IntType a, IntType b) {\n  return a <= b;\n}\n\n// UniformDistribution selects either absl::uniform_int_distribution\n// or absl::uniform_real_distribution depending on the NumType parameter.\ntemplate <typename NumType>\nusing UniformDistribution =\n    typename std::conditional<IsIntegral<NumType>::value,\n                              absl::uniform_int_distribution<NumType>,\n                              absl::uniform_real_distribution<NumType>>::type;\n\n// UniformDistributionWrapper is used as the underlying distribution type\n// by the absl::Uniform template function. It selects the proper Abseil\n// uniform distribution and provides constructor overloads that match the\n// expected parameter order as well as adjusting distribution bounds based\n// on the tag.\ntemplate <typename NumType>\nstruct UniformDistributionWrapper : public UniformDistribution<NumType> {\n  template <typename TagType>\n  explicit UniformDistributionWrapper(TagType, NumType lo, NumType hi)\n      : UniformDistribution<NumType>(\n            uniform_lower_bound<NumType>(TagType{}, lo, hi),\n            uniform_upper_bound<NumType>(TagType{}, lo, hi)) {}\n\n  explicit UniformDistributionWrapper(NumType lo, NumType hi)\n      : UniformDistribution<NumType>(\n            uniform_lower_bound<NumType>(IntervalClosedOpenTag(), lo, hi),\n            uniform_upper_bound<NumType>(IntervalClosedOpenTag(), lo, hi)) {}\n\n  explicit UniformDistributionWrapper()\n      : UniformDistribution<NumType>(std::numeric_limits<NumType>::lowest(),\n                                     (std::numeric_limits<NumType>::max)()) {}\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05987",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/uniform_helper.h",
  "source_line": 63,
  "validation_status": "validated"
}