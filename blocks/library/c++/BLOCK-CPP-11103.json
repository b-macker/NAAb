{
  "code": "{\n  enum { BASE, LOWER_BOUND, LENGTH, STRIDE, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n  SourceLocation ColonLocFirst;\n  SourceLocation ColonLocSecond;\n  SourceLocation RBracketLoc;\n\npublic:\n  OMPArraySectionExpr(Expr *Base, Expr *LowerBound, Expr *Length, Expr *Stride,\n                      QualType Type, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation ColonLocFirst,\n                      SourceLocation ColonLocSecond, SourceLocation RBracketLoc)\n      : Expr(OMPArraySectionExprClass, Type, VK, OK),\n        ColonLocFirst(ColonLocFirst), ColonLocSecond(ColonLocSecond),\n        RBracketLoc(RBracketLoc) {\n    SubExprs[BASE] = Base;\n    SubExprs[LOWER_BOUND] = LowerBound;\n    SubExprs[LENGTH] = Length;\n    SubExprs[STRIDE] = Stride;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array section expression.\n  explicit OMPArraySectionExpr(EmptyShell Shell)\n      : Expr(OMPArraySectionExprClass, Shell) {}\n\n  /// An array section can be written only as Base[LowerBound:Length].\n\n  /// Get base of the array section.\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  /// Set base of the array section.\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  /// Return original type of the base expression for array section.\n  static QualType getBaseOriginalType(const Expr *Base);\n\n  /// Get lower bound of array section.\n  Expr *getLowerBound() { return cast_or_null<Expr>(SubExprs[LOWER_BOUND]); }\n  const Expr *getLowerBound() const {\n    return cast_or_null<Expr>(SubExprs[LOWER_BOUND]);\n  }\n  /// Set lower bound of the array section.\n  void setLowerBound(Expr *E) { SubExprs[LOWER_BOUND] = E; }\n\n  /// Get length of array section.\n  Expr *getLength() { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  const Expr *getLength() const { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  /// Set length of the array section.\n  void setLength(Expr *E) { SubExprs[LENGTH] = E; }\n\n  /// Get stride of array section.\n  Expr *getStride() { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  const Expr *getStride() const { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  /// Set length of the array section.\n  void setStride(Expr *E) { SubExprs[STRIDE] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracketLoc; }\n\n  SourceLocation getColonLocFirst() const { return ColonLocFirst; }\n  void setColonLocFirst(SourceLocation L) { ColonLocFirst = L; }\n\n  SourceLocation getColonLocSecond() const { return ColonLocSecond; }\n  void setColonLocSecond(SourceLocation L) { ColonLocSecond = L; }\n\n  SourceLocation getRBracketLoc() const { return RBracketLoc; }\n  void setRBracketLoc(SourceLocation L) { RBracketLoc = L; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPArraySectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n}",
  "id": "BLOCK-CPP-11103",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprOpenMP.h",
  "source_line": 56,
  "validation_status": "validated"
}