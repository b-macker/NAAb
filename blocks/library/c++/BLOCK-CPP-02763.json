{
  "code": "#include \"absl/profiling/internal/exponential_biased.h\"\n#include <stdint.h>\n#include <algorithm>\n#include <atomic>\n#include <cmath>\n#include <limits>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/optimization.h\"\n\nusing namespace absl;\nusing namespace profiling_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02763_execute() {\n    {\n\n// The algorithm generates a random number between 0 and 1 and applies the\n// inverse cumulative distribution function for an exponential. Specifically:\n// Let m be the inverse of the sample period, then the probability\n// distribution function is m*exp(-mx) so the CDF is\n// p = 1 - exp(-mx), so\n// q = 1 - p = exp(-mx)\n// log_e(q) = -mx\n// -log_e(q)/m = x\n// log_2(q) * (-log_e(2) * 1/m) = x\n// In the code, q is actually in the range 1 to 2**26, hence the -26 below\nint64_t ExponentialBiased::GetSkipCount(int64_t mean) {\n  if (ABSL_PREDICT_FALSE(!initialized_)) {\n    Initialize();\n  }\n\n  uint64_t rng = NextRandom(rng_);\n  rng_ = rng;\n\n  // Take the top 26 bits as the random number\n  // (This plus the 1<<58 sampling bound give a max possible step of\n  // 5194297183973780480 bytes.)\n  // The uint32_t cast is to prevent a (hard-to-reproduce) NAN\n  // under piii debug for some binaries.\n  double q = static_cast<uint32_t>(rng >> (kPrngNumBits - 26)) + 1.0;\n  // Put the computed p-value through the CDF of a geometric.\n  double interval = bias_ + (std::log2(q) - 26) * (-std::log(2.0) * mean);\n  // Very large values of interval overflow int64_t. To avoid that, we will\n  // cheat and clamp any huge values to (int64_t max)/2. This is a potential\n  // source of bias, but the mean would need to be such a large value that it's\n  // not likely to come up. For example, with a mean of 1e18, the probability of\n  // hitting this condition is about 1/1000. For a mean of 1e17, standard\n  // calculators claim that this event won't happen.\n  if (interval > static_cast<double>(std::numeric_limits<int64_t>::max() / 2)) {\n    // Assume huge values are bias neutral, retain bias for next call.\n    return std::numeric_limits<int64_t>::max() / 2;\n  }\n  double value = std::rint(interval);\n  bias_ = interval - value;\n  return value;\n}\n\nint64_t ExponentialBiased::GetStride(int64_t mean) {\n  return GetSkipCount(mean - 1) + 1;\n}\n\nvoid ExponentialBiased::Initialize() {\n  // We don't get well distributed numbers from `this` so we call NextRandom() a\n  // bunch to mush the bits around. We use a global_rand to handle the case\n  // where the same thread (by memory address) gets created and destroyed\n  // repeatedly.\n  ABSL_CONST_INIT static std::atomic<uint32_t> global_rand(0);\n  uint64_t r = reinterpret_cast<uint64_t>(this) +\n               global_rand.fetch_add(1, std::memory_order_relaxed);\n  for (int i = 0; i < 20; ++i) {\n    r = NextRandom(r);\n  }\n  rng_ = r;\n  initialized_ = true;\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02763",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/profiling/internal/exponential_biased.cc",
  "source_line": 29,
  "validation_status": "validated"
}