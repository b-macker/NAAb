{
  "code": "{\n\n// RawSink implementation that writes into a char* buffer.\n// It will not overflow the buffer, but will keep the total count of chars\n// that would have been written.\nclass BufferRawSink {\n public:\n  BufferRawSink(char* buffer, size_t size) : buffer_(buffer), size_(size) {}\n\n  size_t total_written() const { return total_written_; }\n  void Write(string_view v);\n\n private:\n  char* buffer_;\n  size_t size_;\n  size_t total_written_ = 0;\n};\n\n// RawSink implementation that writes into a FILE*.\n// It keeps track of the total number of bytes written and any error encountered\n// during the writes.\nclass FILERawSink {\n public:\n  explicit FILERawSink(std::FILE* output) : output_(output) {}\n\n  void Write(string_view v);\n\n  size_t count() const { return count_; }\n  int error() const { return error_; }\n\n private:\n  std::FILE* output_;\n  int error_ = 0;\n  size_t count_ = 0;\n};\n\n// Provide RawSink integration with common types from the STL.\ninline void AbslFormatFlush(std::string* out, string_view s) {\n  out->append(s.data(), s.size());\n}\ninline void AbslFormatFlush(std::ostream* out, string_view s) {\n  out->write(s.data(), static_cast<std::streamsize>(s.size()));\n}\n\ninline void AbslFormatFlush(FILERawSink* sink, string_view v) {\n  sink->Write(v);\n}\n\ninline void AbslFormatFlush(BufferRawSink* sink, string_view v) {\n  sink->Write(v);\n}\n\n// This is a SFINAE to get a better compiler error message when the type\n// is not supported.\ntemplate <typename T>\nauto InvokeFlush(T* out, string_view s) -> decltype(AbslFormatFlush(out, s)) {\n  AbslFormatFlush(out, s);\n}\n\n}",
  "id": "BLOCK-CPP-06423",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/output.h",
  "source_line": 34,
  "validation_status": "validated"
}