{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// Notification\n// -----------------------------------------------------------------------------\nclass Notification {\n public:\n  // Initializes the \"notified\" state to unnotified.\n  Notification() : notified_yet_(false) {}\n  explicit Notification(bool prenotify) : notified_yet_(prenotify) {}\n  Notification(const Notification&) = delete;\n  Notification& operator=(const Notification&) = delete;\n  ~Notification();\n\n  // Notification::HasBeenNotified()\n  //\n  // Returns the value of the notification's internal \"notified\" state.\n  ABSL_MUST_USE_RESULT bool HasBeenNotified() const {\n    return HasBeenNotifiedInternal(&this->notified_yet_);\n  }\n\n  // Notification::WaitForNotification()\n  //\n  // Blocks the calling thread until the notification's \"notified\" state is\n  // `true`. Note that if `Notify()` has been previously called on this\n  // notification, this function will immediately return.\n  void WaitForNotification() const;\n\n  // Notification::WaitForNotificationWithTimeout()\n  //\n  // Blocks until either the notification's \"notified\" state is `true` (which\n  // may occur immediately) or the timeout has elapsed, returning the value of\n  // its \"notified\" state in either case.\n  bool WaitForNotificationWithTimeout(absl::Duration timeout) const;\n\n  // Notification::WaitForNotificationWithDeadline()\n  //\n  // Blocks until either the notification's \"notified\" state is `true` (which\n  // may occur immediately) or the deadline has expired, returning the value of\n  // its \"notified\" state in either case.\n  bool WaitForNotificationWithDeadline(absl::Time deadline) const;\n\n  // Notification::Notify()\n  //\n  // Sets the \"notified\" state of this notification to `true` and wakes waiting\n  // threads. Note: do not call `Notify()` multiple times on the same\n  // `Notification`; calling `Notify()` more than once on the same notification\n  // results in undefined behavior.\n  void Notify();\n\n private:\n  static inline bool HasBeenNotifiedInternal(\n      const std::atomic<bool>* notified_yet) {\n    return notified_yet->load(std::memory_order_acquire);\n  }\n\n  mutable Mutex mutex_;\n  std::atomic<bool> notified_yet_;  // written under mutex_\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04334",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/notification.h",
  "source_line": 59,
  "validation_status": "validated"
}