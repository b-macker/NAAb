{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"clang/Tooling/FileMatchTrie.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/YAMLParser.h\"\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace tooling;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21189_execute() {\n    {\npublic:\n  /// Loads a JSON compilation database from the specified file.\n  ///\n  /// Returns NULL and sets ErrorMessage if the database could not be\n  /// loaded from the given file.\n  static std::unique_ptr<JSONCompilationDatabase>\n  loadFromFile(StringRef FilePath, std::string &ErrorMessage,\n               JSONCommandLineSyntax Syntax);\n\n  /// Loads a JSON compilation database from a data buffer.\n  ///\n  /// Returns NULL and sets ErrorMessage if the database could not be loaded.\n  static std::unique_ptr<JSONCompilationDatabase>\n  loadFromBuffer(StringRef DatabaseString, std::string &ErrorMessage,\n                 JSONCommandLineSyntax Syntax);\n\n  /// Returns all compile commands in which the specified file was\n  /// compiled.\n  ///\n  /// FIXME: Currently FilePath must be an absolute path inside the\n  /// source directory which does not have symlinks resolved.\n  std::vector<CompileCommand>\n  getCompileCommands(StringRef FilePath) const override;\n\n  /// Returns the list of all files available in the compilation database.\n  ///\n  /// These are the 'file' entries of the JSON objects.\n  std::vector<std::string> getAllFiles() const override;\n\n  /// Returns all compile commands for all the files in the compilation\n  /// database.\n  std::vector<CompileCommand> getAllCompileCommands() const override;\n\nprivate:\n  /// Constructs a JSON compilation database on a memory buffer.\n  JSONCompilationDatabase(std::unique_ptr<llvm::MemoryBuffer> Database,\n                          JSONCommandLineSyntax Syntax)\n      : Database(std::move(Database)), Syntax(Syntax),\n        YAMLStream(this->Database->getBuffer(), SM) {}\n\n  /// Parses the database file and creates the index.\n  ///\n  /// Returns whether parsing succeeded. Sets ErrorMessage if parsing\n  /// failed.\n  bool parse(std::string &ErrorMessage);\n\n  // Tuple (directory, filename, commandline, output) where 'commandline'\n  // points to the corresponding scalar nodes in the YAML stream.\n  // If the command line contains a single argument, it is a shell-escaped\n  // command line.\n  // Otherwise, each entry in the command line vector is a literal\n  // argument to the compiler.\n  // The output field may be a nullptr.\n  using CompileCommandRef =\n      std::tuple<llvm::yaml::ScalarNode *, llvm::yaml::ScalarNode *,\n                 std::vector<llvm::yaml::ScalarNode *>,\n                 llvm::yaml::ScalarNode *>;\n\n  /// Converts the given array of CompileCommandRefs to CompileCommands.\n  void getCommands(ArrayRef<CompileCommandRef> CommandsRef,\n                   std::vector<CompileCommand> &Commands) const;\n\n  // Maps file paths to the compile command lines for that file.\n  llvm::StringMap<std::vector<CompileCommandRef>> IndexByFile;\n\n  /// All the compile commands in the order that they were provided in the\n  /// JSON stream.\n  std::vector<CompileCommandRef> AllCommands;\n\n  FileMatchTrie MatchTrie;\n\n  std::unique_ptr<llvm::MemoryBuffer> Database;\n  JSONCommandLineSyntax Syntax;\n  llvm::SourceMgr SM;\n  llvm::yaml::Stream YAMLStream;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21189",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/JSONCompilationDatabase.h",
  "source_line": 61,
  "validation_status": "validated"
}