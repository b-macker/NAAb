{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// absl::beta_distribution:\n// Generate a floating-point variate conforming to a Beta distribution:\n//   pdf(x) \\propto x^(alpha-1) * (1-x)^(beta-1),\n// where the params alpha and beta are both strictly positive real values.\n//\n// The support is the open interval (0, 1), but the return value might be equal\n// to 0 or 1, due to numerical errors when alpha and beta are very different.\n//\n// Usage note: One usage is that alpha and beta are counts of number of\n// successes and failures. When the total number of trials are large, consider\n// approximating a beta distribution with a Gaussian distribution with the same\n// mean and variance. One could use the skewness, which depends only on the\n// smaller of alpha and beta when the number of trials are sufficiently large,\n// to quantify how far a beta distribution is from the normal distribution.\ntemplate <typename RealType = double>\nclass beta_distribution {\n public:\n  using result_type = RealType;\n\n  class param_type {\n   public:\n    using distribution_type = beta_distribution;\n\n    explicit param_type(result_type alpha, result_type beta)\n        : alpha_(alpha), beta_(beta) {\n      assert(alpha >= 0);\n      assert(beta >= 0);\n      assert(alpha <= (std::numeric_limits<result_type>::max)());\n      assert(beta <= (std::numeric_limits<result_type>::max)());\n      if (alpha == 0 || beta == 0) {\n        method_ = DEGENERATE_SMALL;\n        x_ = (alpha >= beta) ? 1 : 0;\n        return;\n      }\n      // a_ = min(beta, alpha), b_ = max(beta, alpha).\n      if (beta < alpha) {\n        inverted_ = true;\n        a_ = beta;\n        b_ = alpha;\n      } else {\n        inverted_ = false;\n        a_ = alpha;\n        b_ = beta;\n      }\n      if (a_ <= 1 && b_ >= ThresholdForLargeA()) {\n        method_ = DEGENERATE_SMALL;\n        x_ = inverted_ ? result_type(1) : result_type(0);\n        return;\n      }\n      // For threshold values, see also:\n      // Evaluation of Beta Generation Algorithms, Ying-Chao Hung, et. al.\n      // February, 2009.\n      if ((b_ < 1.0 && a_ + b_ <= 1.2) || a_ <= ThresholdForSmallA()) {\n        // Choose Joehnk over Cheng when it's faster or when Cheng encounters\n        // numerical issues.\n        method_ = JOEHNK;\n        a_ = result_type(1) / alpha_;\n        b_ = result_type(1) / beta_;\n        if (std::isinf(a_) || std::isinf(b_)) {\n          method_ = DEGENERATE_SMALL;\n          x_ = inverted_ ? result_type(1) : result_type(0);\n        }\n        return;\n      }\n      if (a_ >= ThresholdForLargeA()) {\n        method_ = DEGENERATE_LARGE;\n        // Note: on PPC for long double, evaluating\n        // `std::numeric_limits::max() / ThresholdForLargeA` results in NaN.\n        result_type r = a_ / b_;\n        x_ = (inverted_ ? result_type(1) : r) / (1 + r);\n        return;\n      }\n      x_ = a_ + b_;\n      log_x_ = std::log(x_);\n      if (a_ <= 1) {\n        method_ = CHENG_BA;\n        y_ = result_type(1) / a_;\n        gamma_ = a_ + a_;\n        return;\n      }\n      method_ = CHENG_BB;\n      result_type r = (a_ - 1) / (b_ - 1);\n      y_ = std::sqrt((1 + r) / (b_ * r * 2 - r + 1));\n      gamma_ = a_ + result_type(1) / y_;\n    }\n\n    result_type alpha() const { return alpha_; }\n    result_type beta() const { return beta_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.alpha_ == b.alpha_ && a.beta_ == b.beta_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class beta_distribution;\n\n#ifdef _MSC_VER\n    // MSVC does not have constexpr implementations for std::log and std::exp\n    // so they are computed at runtime.\n#define ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR\n#else\n#define ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR constexpr\n#endif\n\n    // The threshold for whether std::exp(1/a) is finite.\n    // Note that this value is quite large, and a smaller a_ is NOT abnormal.\n    static ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR result_type\n    ThresholdForSmallA() {\n      return result_type(1) /\n             std::log((std::numeric_limits<result_type>::max)());\n    }\n\n    // The threshold for whether a * std::log(a) is finite.\n    static ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR result_type\n    ThresholdForLargeA() {\n      return std::exp(\n          std::log((std::numeric_limits<result_type>::max)()) -\n          std::log(std::log((std::numeric_limits<result_type>::max)())) -\n          ThresholdPadding());\n    }\n\n#undef ABSL_RANDOM_INTERNAL_LOG_EXP_CONSTEXPR\n\n    // Pad the threshold for large A for long double on PPC. This is done via a\n    // template specialization below.\n    static constexpr result_type ThresholdPadding() { return 0; }\n\n    enum Method {\n      JOEHNK,    // Uses algorithm Joehnk\n      CHENG_BA,  // Uses algorithm BA in Cheng\n      CHENG_BB,  // Uses algorithm BB in Cheng\n\n      // Note: See also:\n      //   Hung et al. Evaluation of beta generation algorithms. Communications\n      //   in Statistics-Simulation and Computation 38.4 (2009): 750-770.\n      // especially:\n      //   Zechner, Heinz, and Ernst Stadlober. Generating beta variates via\n      //   patchwork rejection. Computing 50.1 (1993): 1-18.\n\n      DEGENERATE_SMALL,  // a_ is abnormally small.\n      DEGENERATE_LARGE,  // a_ is abnormally large.\n    };\n\n    result_type alpha_;\n    result_type beta_;\n\n    result_type a_;  // the smaller of {alpha, beta}, or 1.0/alpha_ in JOEHNK\n    result_type b_;  // the larger of {alpha, beta}, or 1.0/beta_ in JOEHNK\n    result_type x_;  // alpha + beta, or the result in degenerate cases\n    result_type log_x_;  // log(x_)\n    result_type y_;      // \"beta\" in Cheng\n    result_type gamma_;  // \"gamma\" in Cheng\n\n    Method method_;\n\n    // Placing this last for optimal alignment.\n    // Whether alpha_ != a_, i.e. true iff alpha_ > beta_.\n    bool inverted_;\n\n    static_assert(std::is_floating_point<RealType>::value,\n                  \"Class-template absl::beta_distribution<> must be \"\n                  \"parameterized using a floating-point type.\");\n  };\n\n  beta_distribution() : beta_distribution(1) {}\n\n  explicit beta_distribution(result_type alpha, result_type beta = 1)\n      : param_(alpha, beta) {}\n\n  explicit beta_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // Generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const { return 1; }\n\n  result_type alpha() const { return param_.alpha(); }\n  result_type beta() const { return param_.beta(); }\n\n  friend bool operator==(const beta_distribution& a,\n                         const beta_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const beta_distribution& a,\n                         const beta_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  template <typename URBG>\n  result_type AlgorithmJoehnk(URBG& g,  // NOLINT(runtime/references)\n                              const param_type& p);\n\n  template <typename URBG>\n  result_type AlgorithmCheng(URBG& g,  // NOLINT(runtime/references)\n                             const param_type& p);\n\n  template <typename URBG>\n  result_type DegenerateCase(URBG& g,  // NOLINT(runtime/references)\n                             const param_type& p) {\n    if (p.method_ == param_type::DEGENERATE_SMALL && p.alpha_ == p.beta_) {\n      // Returns 0 or 1 with equal probability.\n      random_internal::FastUniformBits<uint8_t> fast_u8;\n      return static_cast<result_type>((fast_u8(g) & 0x10) !=\n                                      0);  // pick any single bit.\n    }\n    return p.x_;\n  }\n\n  param_type param_;\n  random_internal::FastUniformBits<uint64_t> fast_u64_;\n};\n\n#if defined(__powerpc64__) || defined(__PPC64__) || defined(__powerpc__) || \\\n    defined(__ppc__) || defined(__PPC__)\n// PPC needs a more stringent boundary for long double.\ntemplate <>\nconstexpr long double\nbeta_distribution<long double>::param_type::ThresholdPadding() {\n  return 10;\n}\n#endif\n\ntemplate <typename RealType>\ntemplate <typename URBG>\ntypename beta_distribution<RealType>::result_type\nbeta_distribution<RealType>::AlgorithmJoehnk(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n  using real_type =\n      absl::conditional_t<std::is_same<RealType, float>::value, float, double>;\n\n  // Based on Joehnk, M. D. Erzeugung von betaverteilten und gammaverteilten\n  // Zufallszahlen. Metrika 8.1 (1964): 5-15.\n  // This method is described in Knuth, Vol 2 (Third Edition), pp 134.\n\n  result_type u, v, x, y, z;\n  for (;;) {\n    u = GenerateRealFromBits<real_type, GeneratePositiveTag, false>(\n        fast_u64_(g));\n    v = GenerateRealFromBits<real_type, GeneratePositiveTag, false>(\n        fast_u64_(g));\n\n    // Direct method. std::pow is slow for float, so rely on the optimizer to\n    // remove the std::pow() path for that case.\n    if (!std::is_same<float, result_type>::value) {\n      x = std::pow(u, p.a_);\n      y = std::pow(v, p.b_);\n      z = x + y;\n      if (z > 1) {\n        // Reject if and only if `x + y > 1.0`\n        continue;\n      }\n      if (z > 0) {\n        // When both alpha and beta are small, x and y are both close to 0, so\n        // divide by (x+y) directly may result in nan.\n        return x / z;\n      }\n    }\n\n    // Log transform.\n    // x = log( pow(u, p.a_) ), y = log( pow(v, p.b_) )\n    // since u, v <= 1.0,  x, y < 0.\n    x = std::log(u) * p.a_;\n    y = std::log(v) * p.b_;\n    if (!std::isfinite(x) || !std::isfinite(y)) {\n      continue;\n    }\n    // z = log( pow(u, a) + pow(v, b) )\n    z = x > y ? (x + std::log(1 + std::exp(y - x)))\n              : (y + std::log(1 + std::exp(x - y)));\n    // Reject iff log(x+y) > 0.\n    if (z > 0) {\n      continue;\n    }\n    return std::exp(x - z);\n  }\n}\n\ntemplate <typename RealType>\ntemplate <typename URBG>\ntypename beta_distribution<RealType>::result_type\nbeta_distribution<RealType>::AlgorithmCheng(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n  using real_type =\n      absl::conditional_t<std::is_same<RealType, float>::value, float, double>;\n\n  // Based on Cheng, Russell CH. Generating beta variates with nonintegral\n  // shape parameters. Communications of the ACM 21.4 (1978): 317-322.\n  // (https://dl.acm.org/citation.cfm?id=359482).\n  static constexpr result_type kLogFour =\n      result_type(1.3862943611198906188344642429163531361);  // log(4)\n  static constexpr result_type kS =\n      result_type(2.6094379124341003746007593332261876);  // 1+log(5)\n\n  const bool use_algorithm_ba = (p.method_ == param_type::CHENG_BA);\n  result_type u1, u2, v, w, z, r, s, t, bw_inv, lhs;\n  for (;;) {\n    u1 = GenerateRealFromBits<real_type, GeneratePositiveTag, false>(\n        fast_u64_(g));\n    u2 = GenerateRealFromBits<real_type, GeneratePositiveTag, false>(\n        fast_u64_(g));\n    v = p.y_ * std::log(u1 / (1 - u1));\n    w = p.a_ * std::exp(v);\n    bw_inv = result_type(1) / (p.b_ + w);\n    r = p.gamma_ * v - kLogFour;\n    s = p.a_ + r - w;\n    z = u1 * u1 * u2;\n    if (!use_algorithm_ba && s + kS >= 5 * z) {\n      break;\n    }\n    t = std::log(z);\n    if (!use_algorithm_ba && s >= t) {\n      break;\n    }\n    lhs = p.x_ * (p.log_x_ + std::log(bw_inv)) + r;\n    if (lhs >= t) {\n      break;\n    }\n  }\n  return p.inverted_ ? (1 - w * bw_inv) : w * bw_inv;\n}\n\ntemplate <typename RealType>\ntemplate <typename URBG>\ntypename beta_distribution<RealType>::result_type\nbeta_distribution<RealType>::operator()(URBG& g,  // NOLINT(runtime/references)\n                                        const param_type& p) {\n  switch (p.method_) {\n    case param_type::JOEHNK:\n      return AlgorithmJoehnk(g, p);\n    case param_type::CHENG_BA:\n      ABSL_FALLTHROUGH_INTENDED;\n    case param_type::CHENG_BB:\n      return AlgorithmCheng(g, p);\n    default:\n      return DegenerateCase(g, p);\n  }\n}\n\ntemplate <typename CharT, typename Traits, typename RealType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const beta_distribution<RealType>& x) {\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os.precision(random_internal::stream_precision_helper<RealType>::kPrecision);\n  os << x.alpha() << os.fill() << x.beta();\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename RealType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    beta_distribution<RealType>& x) {       // NOLINT(runtime/references)\n  using result_type = typename beta_distribution<RealType>::result_type;\n  using param_type = typename beta_distribution<RealType>::param_type;\n  result_type alpha, beta;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  alpha = random_internal::read_floating_point<result_type>(is);\n  if (is.fail()) return is;\n  beta = random_internal::read_floating_point<result_type>(is);\n  if (!is.fail()) {\n    x.param(param_type(alpha, beta));\n  }\n  return is;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03811",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/beta_distribution.h",
  "source_line": 31,
  "validation_status": "validated"
}