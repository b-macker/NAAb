{
  "code": "{\npublic:\n  struct Entry {\n    std::string Path;\n    frontend::IncludeDirGroup Group;\n    unsigned IsFramework : 1;\n\n    /// IgnoreSysRoot - This is false if an absolute path should be treated\n    /// relative to the sysroot, or true if it should always be the absolute\n    /// path.\n    unsigned IgnoreSysRoot : 1;\n\n    Entry(StringRef path, frontend::IncludeDirGroup group, bool isFramework,\n          bool ignoreSysRoot)\n        : Path(path), Group(group), IsFramework(isFramework),\n          IgnoreSysRoot(ignoreSysRoot) {}\n  };\n\n  struct SystemHeaderPrefix {\n    /// A prefix to be matched against paths in \\#include directives.\n    std::string Prefix;\n\n    /// True if paths beginning with this prefix should be treated as system\n    /// headers.\n    bool IsSystemHeader;\n\n    SystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader)\n        : Prefix(Prefix), IsSystemHeader(IsSystemHeader) {}\n  };\n\n  /// If non-empty, the directory to use as a \"virtual system root\" for include\n  /// paths.\n  std::string Sysroot;\n\n  /// User specified include entries.\n  std::vector<Entry> UserEntries;\n\n  /// User-specified system header prefixes.\n  std::vector<SystemHeaderPrefix> SystemHeaderPrefixes;\n\n  /// The directory which holds the compiler resource files (builtin includes,\n  /// etc.).\n  std::string ResourceDir;\n\n  /// The directory used for the module cache.\n  std::string ModuleCachePath;\n\n  /// The directory used for a user build.\n  std::string ModuleUserBuildPath;\n\n  /// The mapping of module names to prebuilt module files.\n  std::map<std::string, std::string, std::less<>> PrebuiltModuleFiles;\n\n  /// The directories used to load prebuilt module files.\n  std::vector<std::string> PrebuiltModulePaths;\n\n  /// The module/pch container format.\n  std::string ModuleFormat;\n\n  /// Whether we should disable the use of the hash string within the\n  /// module cache.\n  ///\n  /// Note: Only used for testing!\n  unsigned DisableModuleHash : 1;\n\n  /// Implicit module maps.  This option is enabld by default when\n  /// modules is enabled.\n  unsigned ImplicitModuleMaps : 1;\n\n  /// Set the 'home directory' of a module map file to the current\n  /// working directory (or the home directory of the module map file that\n  /// contained the 'extern module' directive importing this module map file\n  /// if any) rather than the directory containing the module map file.\n  //\n  /// The home directory is where we look for files named in the module map\n  /// file.\n  unsigned ModuleMapFileHomeIsCwd : 1;\n\n  /// Set the base path of a built module file to be the current working\n  /// directory. This is useful for sharing module files across machines\n  /// that build with different paths without having to rewrite all\n  /// modulemap files to have working directory relative paths.\n  unsigned ModuleFileHomeIsCwd : 1;\n\n  /// Also search for prebuilt implicit modules in the prebuilt module cache\n  /// path.\n  unsigned EnablePrebuiltImplicitModules : 1;\n\n  /// The interval (in seconds) between pruning operations.\n  ///\n  /// This operation is expensive, because it requires Clang to walk through\n  /// the directory structure of the module cache, stat()'ing and removing\n  /// files.\n  ///\n  /// The default value is large, e.g., the operation runs once a week.\n  unsigned ModuleCachePruneInterval = 7 * 24 * 60 * 60;\n\n  /// The time (in seconds) after which an unused module file will be\n  /// considered unused and will, therefore, be pruned.\n  ///\n  /// When the module cache is pruned, any module file that has not been\n  /// accessed in this many seconds will be removed. The default value is\n  /// large, e.g., a month, to avoid forcing infrequently-used modules to be\n  /// regenerated often.\n  unsigned ModuleCachePruneAfter = 31 * 24 * 60 * 60;\n\n  /// The time in seconds when the build session started.\n  ///\n  /// This time is used by other optimizations in header search and module\n  /// loading.\n  uint64_t BuildSessionTimestamp = 0;\n\n  /// The set of macro names that should be ignored for the purposes\n  /// of computing the module hash.\n  llvm::SmallSetVector<llvm::CachedHashString, 16> ModulesIgnoreMacros;\n\n  /// The set of user-provided virtual filesystem overlay files.\n  std::vector<std::string> VFSOverlayFiles;\n\n  /// Include the compiler builtin includes.\n  unsigned UseBuiltinIncludes : 1;\n\n  /// Include the system standard include search directories.\n  unsigned UseStandardSystemIncludes : 1;\n\n  /// Include the system standard C++ library include search directories.\n  unsigned UseStandardCXXIncludes : 1;\n\n  /// Use libc++ instead of the default libstdc++.\n  unsigned UseLibcxx : 1;\n\n  /// Whether header search information should be output as for -v.\n  unsigned Verbose : 1;\n\n  /// If true, skip verifying input files used by modules if the\n  /// module was already verified during this build session (see\n  /// \\c BuildSessionTimestamp).\n  unsigned ModulesValidateOncePerBuildSession : 1;\n\n  /// Whether to validate system input files when a module is loaded.\n  unsigned ModulesValidateSystemHeaders : 1;\n\n  // Whether the content of input files should be hashed and used to\n  // validate consistency.\n  unsigned ValidateASTInputFilesContent : 1;\n\n  /// Whether the module includes debug information (-gmodules).\n  unsigned UseDebugInfo : 1;\n\n  unsigned ModulesValidateDiagnosticOptions : 1;\n\n  unsigned ModulesHashContent : 1;\n\n  /// Whether we should include all things that could impact the module in the\n  /// hash.\n  ///\n  /// This includes things like the full header search path, and enabled\n  /// diagnostics.\n  unsigned ModulesStrictContextHash : 1;\n\n  HeaderSearchOptions(StringRef _Sysroot = \"/\")\n      : Sysroot(_Sysroot), ModuleFormat(\"raw\"), DisableModuleHash(false),\n        ImplicitModuleMaps(false), ModuleMapFileHomeIsCwd(false),\n        ModuleFileHomeIsCwd(false), EnablePrebuiltImplicitModules(false),\n        UseBuiltinIncludes(true), UseStandardSystemIncludes(true),\n        UseStandardCXXIncludes(true), UseLibcxx(false), Verbose(false),\n        ModulesValidateOncePerBuildSession(false),\n        ModulesValidateSystemHeaders(false),\n        ValidateASTInputFilesContent(false), UseDebugInfo(false),\n        ModulesValidateDiagnosticOptions(true), ModulesHashContent(false),\n        ModulesStrictContextHash(false) {}\n\n  /// AddPath - Add the \\p Path path to the specified \\p Group list.\n  void AddPath(StringRef Path, frontend::IncludeDirGroup Group,\n               bool IsFramework, bool IgnoreSysRoot) {\n    UserEntries.emplace_back(Path, Group, IsFramework, IgnoreSysRoot);\n  }\n\n  /// AddSystemHeaderPrefix - Override whether \\#include directives naming a\n  /// path starting with \\p Prefix should be considered as naming a system\n  /// header.\n  void AddSystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader) {\n    SystemHeaderPrefixes.emplace_back(Prefix, IsSystemHeader);\n  }\n\n  void AddVFSOverlayFile(StringRef Name) {\n    VFSOverlayFiles.push_back(std::string(Name));\n  }\n\n  void AddPrebuiltModulePath(StringRef Name) {\n    PrebuiltModulePaths.push_back(std::string(Name));\n  }\n}",
  "id": "BLOCK-CPP-18617",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/HeaderSearchOptions.h",
  "source_line": 68,
  "validation_status": "validated"
}