{
  "code": "#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <optional>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include \"clang/AST/TypeNodes.inc\"\n#include \"clang/AST/TypeNodes.inc\"\n\nusing namespace clang;\nusing namespace serialization;\nusing namespace clang;\nusing namespace llvm;\nusing namespace llvm;\nusing namespace clang;\nusing namespace clang;\nusing namespace llvm;\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-14159_execute() {\n    {\n  ///   typedef T* pointer_types; // ill-formed; T is a parameter pack.\n  /// };\n  /// \\endcode\n  ///\n  /// Note that this routine does not specify which\n  bool containsUnexpandedParameterPack() const {\n    return getDependence() & TypeDependence::UnexpandedPack;\n  }\n\n  /// Determines if this type would be canonical if it had no further\n  /// qualification.\n  bool isCanonicalUnqualified() const {\n    return CanonicalType == QualType(this, 0);\n  }\n\n  /// Pull a single level of sugar off of this locally-unqualified type.\n  /// Users should generally prefer SplitQualType::getSingleStepDesugaredType()\n  /// or QualType::getSingleStepDesugaredType(const ASTContext&).\n  QualType getLocallyUnqualifiedSingleStepDesugaredType() const;\n\n  /// As an extension, we classify types as one of \"sized\" or \"sizeless\";\n  /// every type is one or the other.  Standard types are all sized;\n  /// sizeless types are purely an extension.\n  ///\n  /// Sizeless types contain data with no specified size, alignment,\n  /// or layout.\n  bool isSizelessType() const;\n  bool isSizelessBuiltinType() const;\n\n  /// Returns true for SVE scalable vector types.\n  bool isSVESizelessBuiltinType() const;\n\n  /// Returns true for RVV scalable vector types.\n  bool isRVVSizelessBuiltinType() const;\n\n  /// Check if this is a WebAssembly Externref Type.\n  bool isWebAssemblyExternrefType() const;\n\n  /// Returns true if this is a WebAssembly table type: either an array of\n  /// reference types, or a pointer to a reference type (which can only be\n  /// created by array to pointer decay).\n  bool isWebAssemblyTableType() const;\n\n  /// Determines if this is a sizeless type supported by the\n  /// 'arm_sve_vector_bits' type attribute, which can be applied to a single\n  /// SVE vector or predicate, excluding tuple types such as svint32x4_t.\n  bool isVLSTBuiltinType() const;\n\n  /// Returns the representative type for the element of an SVE builtin type.\n  /// This is used to represent fixed-length SVE vectors created with the\n  /// 'arm_sve_vector_bits' type attribute as VectorType.\n  QualType getSveEltType(const ASTContext &Ctx) const;\n\n  /// Determines if this is a sizeless type supported by the\n  /// 'riscv_rvv_vector_bits' type attribute, which can be applied to a single\n  /// RVV vector or mask.\n  bool isRVVVLSBuiltinType() const;\n\n  /// Returns the representative type for the element of an RVV builtin type.\n  /// This is used to represent fixed-length RVV vectors created with the\n  /// 'riscv_rvv_vector_bits' type attribute as VectorType.\n  QualType getRVVEltType(const ASTContext &Ctx) const;\n\n  /// Types are partitioned into 3 broad categories (C99 6.2.5p1):\n  /// object types, function types, and incomplete types.\n\n  /// Return true if this is an incomplete type.\n  /// A type that can describe objects, but which lacks information needed to\n  /// determine its size (e.g. void, or a fwd declared struct). Clients of this\n  /// routine will need to determine if the size is actually required.\n  ///\n  /// Def If non-null, and the type refers to some kind of declaration\n  /// that can be completed (such as a C struct, C++ class, or Objective-C\n  /// class), will be set to the declaration.\n  bool isIncompleteType(NamedDecl **Def = nullptr) const;\n\n  /// Return true if this is an incomplete or object\n  /// type, in other words, not a function type.\n  bool isIncompleteOrObjectType() const {\n    return !isFunctionType();\n  }\n\n  /// Determine whether this type is an object type.\n  bool isObjectType() const {\n    // C++ [basic.types]p8:\n    //   An object type is a (possibly cv-qualified) type that is not a\n    //   function type, not a reference type, and not a void type.\n    return !isReferenceType() && !isFunctionType() && !isVoidType();\n  }\n\n  /// Return true if this is a literal type\n  /// (C++11 [basic.types]p10)\n  bool isLiteralType(const ASTContext &Ctx) const;\n\n  /// Determine if this type is a structural type, per C++20 [temp.param]p7.\n  bool isStructuralType() const;\n\n  /// Test if this type is a standard-layout type.\n  /// (C++0x [basic.type]p9)\n  bool isStandardLayoutType() const;\n\n  /// Helper methods to distinguish type categories. All type predicates\n  /// operate on the canonical type, ignoring typedefs and qualifiers.\n\n  /// Returns true if the type is a builtin type.\n  bool isBuiltinType() const;\n\n  /// Test for a particular builtin type.\n  bool isSpecificBuiltinType(unsigned K) const;\n\n  /// Test for a type which does not represent an actual type-system type but\n  /// is instead used as a placeholder for various convenient purposes within\n  /// Clang.  All such types are BuiltinTypes.\n  bool isPlaceholderType() const;\n  const BuiltinType *getAsPlaceholderType() const;\n\n  /// Test for a specific placeholder type.\n  bool isSpecificPlaceholderType(unsigned K) const;\n\n  /// Test for a placeholder type other than Overload; see\n  /// BuiltinType::isNonOverloadPlaceholderType.\n  bool isNonOverloadPlaceholderType() const;\n\n  /// isIntegerType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)\n  bool isEnumeralType() const;\n\n  /// Determine whether this type is a scoped enumeration type.\n  bool isScopedEnumeralType() const;\n  bool isBooleanType() const;\n  bool isCharType() const;\n  bool isWideCharType() const;\n  bool isChar8Type() const;\n  bool isChar16Type() const;\n  bool isChar32Type() const;\n  bool isAnyCharacterType() const;\n  bool isIntegralType(const ASTContext &Ctx) const;\n\n  /// Determine whether this type is an integral or enumeration type.\n  bool isIntegralOrEnumerationType() const;\n\n  /// Determine whether this type is an integral or unscoped enumeration type.\n  bool isIntegralOrUnscopedEnumerationType() const;\n  bool isUnscopedEnumerationType() const;\n\n  /// Floating point categories.\n  bool isRealFloatingType() const; // C99 6.2.5p10 (float, double, long double)\n  /// isComplexType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isComplexType() const;      // C99 6.2.5p11 (complex)\n  bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.\n  bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)\n  bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)\n  bool isFloat16Type() const;      // C11 extension ISO/IEC TS 18661\n  bool isBFloat16Type() const;\n  bool isFloat128Type() const;\n  bool isIbm128Type() const;\n  bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)\n  bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)\n  bool isVoidType() const;         // C99 6.2.5p19\n  bool isScalarType() const;       // C99 6.2.5p21 (arithmetic + pointers)\n  bool isAggregateType() const;\n  bool isFundamentalType() const;\n  bool isCompoundType() const;\n\n  // Type Predicates: Check to see if this type is structurally the specified\n  // type, ignoring typedefs and qualifiers.\n  bool isFunctionType() const;\n  bool isFunctionNoProtoType() const { return getAs<FunctionNoProtoType>(); }\n  bool isFunctionProtoType() const { return getAs<FunctionProtoType>(); }\n  bool isPointerType() const;\n  bool isAnyPointerType() const;   // Any C pointer or ObjC object pointer\n  bool isBlockPointerType() const;\n  bool isVoidPointerType() const;\n  bool isReferenceType() const;\n  bool isLValueReferenceType() const;\n  bool isRValueReferenceType() const;\n  bool isObjectPointerType() const;\n  bool isFunctionPointerType() const;\n  bool isFunctionReferenceType() const;\n  bool isMemberPointerType() const;\n  bool isMemberFunctionPointerType() const;\n  bool isMemberDataPointerType() const;\n  bool isArrayType() const;\n  bool isConstantArrayType() const;\n  bool isIncompleteArrayType() const;\n  bool isVariableArrayType() const;\n  bool isDependentSizedArrayType() const;\n  bool isRecordType() const;\n  bool isClassType() const;\n  bool isStructureType() const;\n  bool isObjCBoxableRecordType() const;\n  bool isInterfaceType() const;\n  bool isStructureOrClassType() const;\n  bool isUnionType() const;\n  bool isComplexIntegerType() const;            // GCC _Complex integer type.\n  bool isVectorType() const;                    // GCC vector type.\n  bool isExtVectorType() const;                 // Extended vector type.\n  bool isExtVectorBoolType() const;             // Extended vector type with bool element.\n  bool isMatrixType() const;                    // Matrix type.\n  bool isConstantMatrixType() const;            // Constant matrix type.\n  bool isDependentAddressSpaceType() const;     // value-dependent address space qualifier\n  bool isObjCObjectPointerType() const;         // pointer to ObjC object\n  bool isObjCRetainableType() const;            // ObjC object or block pointer\n  bool isObjCLifetimeType() const;              // (array of)* retainable type\n  bool isObjCIndirectLifetimeType() const;      // (pointer to)* lifetime type\n  bool isObjCNSObjectType() const;              // __attribute__((NSObject))\n  bool isObjCIndependentClassType() const;      // __attribute__((objc_independent_class))\n  // FIXME: change this to 'raw' interface type, so we can used 'interface' type\n  // for the common case.\n  bool isObjCObjectType() const;                // NSString or typeof(*(id)0)\n  bool isObjCQualifiedInterfaceType() const;    // NSString<foo>\n  bool isObjCQualifiedIdType() const;           // id<foo>\n  bool isObjCQualifiedClassType() const;        // Class<foo>\n  bool isObjCObjectOrInterfaceType() const;\n  bool isObjCIdType() const;                    // id\n  bool isDecltypeType() const;\n  /// Was this type written with the special inert-in-ARC __unsafe_unretained\n  /// qualifier?\n  ///\n  /// This approximates the answer to the following question: if this\n  /// translation unit were compiled in ARC, would this type be qualified\n  /// with __unsafe_unretained?\n  bool isObjCInertUnsafeUnretainedType() const {\n    return hasAttr(attr::ObjCInertUnsafeUnretained);\n  }\n\n  /// Whether the type is Objective-C 'id' or a __kindof type of an\n  /// object type, e.g., __kindof NSView * or __kindof id\n  /// <NSCopying>.\n  ///\n  /// \\param bound Will be set to the bound on non-id subtype types,\n  /// which will be (possibly specialized) Objective-C class type, or\n  /// null for 'id.\n  bool isObjCIdOrObjectKindOfType(const ASTContext &ctx,\n                                  const ObjCObjectType *&bound) const;\n\n  bool isObjCClassType() const;                 // Class\n\n  /// Whether the type is Objective-C 'Class' or a __kindof type of an\n  /// Class type, e.g., __kindof Class <NSCopying>.\n  ///\n  /// Unlike \\c isObjCIdOrObjectKindOfType, there is no relevant bound\n  /// here because Objective-C's type system cannot express \"a class\n  /// object for a subclass of NSFoo\".\n  bool isObjCClassOrClassKindOfType() const;\n\n  bool isBlockCompatibleObjCPointerType(ASTContext &ctx) const;\n  bool isObjCSelType() const;                 // Class\n  bool isObjCBuiltinType() const;               // 'id' or 'Class'\n  bool isObjCARCBridgableType() const;\n  bool isCARCBridgableType() const;\n  bool isTemplateTypeParmType() const;          // C++ template type parameter\n  bool isNullPtrType() const;                   // C++11 std::nullptr_t or\n                                                // C2x nullptr_t\n  bool isNothrowT() const;                      // C++   std::nothrow_t\n  bool isAlignValT() const;                     // C++17 std::align_val_t\n  bool isStdByteType() const;                   // C++17 std::byte\n  bool isAtomicType() const;                    // C11 _Atomic()\n  bool isUndeducedAutoType() const;             // C++11 auto or\n                                                // C++14 decltype(auto)\n  bool isTypedefNameType() const;               // typedef or alias template\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\n  bool isImageType() const;                     // Any OpenCL image type\n\n  bool isSamplerT() const;                      // OpenCL sampler_t\n  bool isEventT() const;                        // OpenCL event_t\n  bool isClkEventT() const;                     // OpenCL clk_event_t\n  bool isQueueT() const;                        // OpenCL queue_t\n  bool isReserveIDT() const;                    // OpenCL reserve_id_t\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // Type defined in cl_intel_device_side_avc_motion_estimation OpenCL extension\n  bool isOCLIntelSubgroupAVCType() const;\n  bool isOCLExtOpaqueType() const;              // Any OpenCL extension type\n\n  bool isPipeType() const;                      // OpenCL pipe type\n  bool isBitIntType() const;                    // Bit-precise integer type\n  bool isOpenCLSpecificType() const;            // Any OpenCL specific type\n\n  /// Determines if this type, which must satisfy\n  /// isObjCLifetimeType(), is implicitly __unsafe_unretained rather\n  /// than implicitly __strong.\n  bool isObjCARCImplicitlyUnretainedType() const;\n\n  /// Check if the type is the CUDA device builtin surface type.\n  bool isCUDADeviceBuiltinSurfaceType() const;\n  /// Check if the type is the CUDA device builtin texture type.\n  bool isCUDADeviceBuiltinTextureType() const;\n\n  bool isRVVType(unsigned ElementCount) const;\n\n  bool isRVVType() const;\n\n  bool isRVVType(unsigned Bitwidth, bool IsFloat) const;\n\n  /// Return the implicit lifetime for this type, which must not be dependent.\n  Qualifiers::ObjCLifetime getObjCARCImplicitLifetime() const;\n\n  enum ScalarTypeKind {\n    STK_CPointer,\n    STK_BlockPointer,\n    STK_ObjCObjectPointer,\n    STK_MemberPointer,\n    STK_Bool,\n    STK_Integral,\n    STK_Floating,\n    STK_IntegralComplex,\n    STK_FloatingComplex,\n    STK_FixedPoint\n  };\n\n  /// Given that this is a scalar type, classify it.\n  ScalarTypeKind getScalarTypeKind() const;\n\n  TypeDependence getDependence() const {\n    return static_cast<TypeDependence>(TypeBits.Dependence);\n  }\n\n  /// Whether this type is an error type.\n  bool containsErrors() const {\n    return getDependence() & TypeDependence::Error;\n  }\n\n  /// Whether this type is a dependent type, meaning that its definition\n  /// somehow depends on a template parameter (C++ [temp.dep.type]).\n  bool isDependentType() const {\n    return getDependence() & TypeDependence::Dependent;\n  }\n\n  /// Determine whether this type is an instantiation-dependent type,\n  /// meaning that the type involves a template parameter (even if the\n  /// definition does not actually depend on the type substituted for that\n  /// template parameter).\n  bool isInstantiationDependentType() const {\n    return getDependence() & TypeDependence::Instantiation;\n  }\n\n  /// Determine whether this type is an undeduced type, meaning that\n  /// it somehow involves a C++11 'auto' type or similar which has not yet been\n  /// deduced.\n  bool isUndeducedType() const;\n\n  /// Whether this type is a variably-modified type (C99 6.7.5).\n  bool isVariablyModifiedType() const {\n    return getDependence() & TypeDependence::VariablyModified;\n  }\n\n  /// Whether this type involves a variable-length array type\n  /// with a definite size.\n  bool hasSizedVLAType() const;\n\n  /// Whether this type is or contains a local or unnamed type.\n  bool hasUnnamedOrLocalType() const;\n\n  bool isOverloadableType() const;\n\n  /// Determine wither this type is a C++ elaborated-type-specifier.\n  bool isElaboratedTypeSpecifier() const;\n\n  bool canDecayToPointerType() const;\n\n  /// Whether this type is represented natively as a pointer.  This includes\n  /// pointers, references, block pointers, and Objective-C interface,\n  /// qualified id, and qualified interface types, as well as nullptr_t.\n  bool hasPointerRepresentation() const;\n\n  /// Whether this type can represent an objective pointer type for the\n  /// purpose of GC'ability\n  bool hasObjCPointerRepresentation() const;\n\n  /// Determine whether this type has an integer representation\n  /// of some sort, e.g., it is an integer type or a vector.\n  bool hasIntegerRepresentation() const;\n\n  /// Determine whether this type has an signed integer representation\n  /// of some sort, e.g., it is an signed integer type or a vector.\n  bool hasSignedIntegerRepresentation() const;\n\n  /// Determine whether this type has an unsigned integer representation\n  /// of some sort, e.g., it is an unsigned integer type or a vector.\n  bool hasUnsignedIntegerRepresentation() const;\n\n  /// Determine whether this type has a floating-point representation\n  /// of some sort, e.g., it is a floating-point type or a vector thereof.\n  bool hasFloatingRepresentation() const;\n\n  // Type Checking Functions: Check to see if this type is structurally the\n  // specified type, ignoring typedefs and qualifiers, and return a pointer to\n  // the best type we can.\n  const RecordType *getAsStructureType() const;\n  /// NOTE: getAs*ArrayType are methods on ASTContext.\n  const RecordType *getAsUnionType() const;\n  const ComplexType *getAsComplexIntegerType() const; // GCC complex int type.\n  const ObjCObjectType *getAsObjCInterfaceType() const;\n\n  // The following is a convenience method that returns an ObjCObjectPointerType\n  // for object declared using an interface.\n  const ObjCObjectPointerType *getAsObjCInterfacePointerType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedIdType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedClassType() const;\n  const ObjCObjectType *getAsObjCQualifiedInterfaceType() const;\n\n  /// Retrieves the CXXRecordDecl that this type refers to, either\n  /// because the type is a RecordType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  CXXRecordDecl *getAsCXXRecordDecl() const;\n\n  /// Retrieves the RecordDecl this type refers to.\n  RecordDecl *getAsRecordDecl() const;\n\n  /// Retrieves the TagDecl that this type refers to, either\n  /// because the type is a TagType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  TagDecl *getAsTagDecl() const;\n\n  /// If this is a pointer or reference to a RecordType, return the\n  /// CXXRecordDecl that the type refers to.\n  ///\n  /// If this is not a pointer or reference, or the type being pointed to does\n  /// not refer to a CXXRecordDecl, returns NULL.\n  const CXXRecordDecl *getPointeeCXXRecordDecl() const;\n\n  /// Get the DeducedType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  DeducedType *getContainedDeducedType() const;\n\n  /// Get the AutoType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  AutoType *getContainedAutoType() const {\n    return dyn_cast_or_null<AutoType>(getContainedDeducedType());\n  }\n\n  /// Determine whether this type was written with a leading 'auto'\n  /// corresponding to a trailing return type (possibly for a nested\n  /// function type within a pointer to function type or similar).\n  bool hasAutoForTrailingReturnType() const;\n\n  /// Member-template getAs<specific type>'.  Look through sugar for\n  /// an instance of \\<specific type>.   This scheme will eventually\n  /// replace the specific getAsXXXX methods above.\n  ///\n  /// There are some specializations of this member template listed\n  /// immediately following this class.\n  template <typename T> const T *getAs() const;\n\n  /// Member-template getAsAdjusted<specific type>. Look through specific kinds\n  /// of sugar (parens, attributes, etc) for an instance of \\<specific type>.\n  /// This is used when you need to walk over sugar nodes that represent some\n  /// kind of type adjustment from a type that was written as a \\<specific type>\n  /// to another type that is still canonically a \\<specific type>.\n  template <typename T> const T *getAsAdjusted() const;\n\n  /// A variant of getAs<> for array types which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *getAsArrayTypeUnsafe() const;\n\n  /// Member-template castAs<specific type>.  Look through sugar for\n  /// the underlying instance of \\<specific type>.\n  ///\n  /// This method has the same relationship to getAs<T> as cast<T> has\n  /// to dyn_cast<T>; which is to say, the underlying type *must*\n  /// have the intended type, and this method will never return null.\n  template <typename T> const T *castAs() const;\n\n  /// A variant of castAs<> for array type which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *castAsArrayTypeUnsafe() const;\n\n  /// Determine whether this type had the specified attribute applied to it\n  /// (looking through top-level type sugar).\n  bool hasAttr(attr::Kind AK) const;\n\n  /// Get the base element type of this type, potentially discarding type\n  /// qualifiers.  This should never be used when type qualifiers\n  /// are meaningful.\n  const Type *getBaseElementTypeUnsafe() const;\n\n  /// If this is an array type, return the element type of the array,\n  /// potentially with type qualifiers missing.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getArrayElementTypeNoTypeQual() const;\n\n  /// If this is a pointer type, return the pointee type.\n  /// If this is an array type, return the array element type.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getPointeeOrArrayElementType() const;\n\n  /// If this is a pointer, ObjC object pointer, or block\n  /// pointer, this returns the respective pointee.\n  QualType getPointeeType() const;\n\n  /// Return the specified type with any \"sugar\" removed from the type,\n  /// removing any typedefs, typeofs, etc., as well as any qualifiers.\n  const Type *getUnqualifiedDesugaredType() const;\n\n  /// Return true if this is an integer type that is\n  /// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],\n  /// or an enum decl which has a signed representation.\n  bool isSignedIntegerType() const;\n\n  /// Return true if this is an integer type that is\n  /// unsigned, according to C99 6.2.5p6 [which returns true for _Bool],\n  /// or an enum decl which has an unsigned representation.\n  bool isUnsignedIntegerType() const;\n\n  /// Determines whether this is an integer type that is signed or an\n  /// enumeration types whose underlying type is a signed integer type.\n  bool isSignedIntegerOrEnumerationType() const;\n\n  /// Determines whether this is an integer type that is unsigned or an\n  /// enumeration types whose underlying type is a unsigned integer type.\n  bool isUnsignedIntegerOrEnumerationType() const;\n\n  /// Return true if this is a fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169.\n  bool isFixedPointType() const;\n\n  /// Return true if this is a fixed point or integer type.\n  bool isFixedPointOrIntegerType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isSaturatedFixedPointType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isUnsaturatedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is signed according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isSignedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is unsigned according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isUnsignedFixedPointType() const;\n\n  /// Return true if this is not a variable sized type,\n  /// according to the rules of C99 6.7.5p3.  It is not legal to call this on\n  /// incomplete types.\n  bool isConstantSizeType() const;\n\n  /// Returns true if this type can be represented by some\n  /// set of type specifiers.\n  bool isSpecifierType() const;\n\n  /// Determine the linkage of this type.\n  Linkage getLinkage() const;\n\n  /// Determine the visibility of this type.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Return true if the visibility was explicitly set is the code.\n  bool isVisibilityExplicit() const {\n    return getLinkageAndVisibility().isVisibilityExplicit();\n  }\n\n  /// Determine the linkage and visibility of this type.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// Determine the nullability of the given type.\n  ///\n  /// Note that nullability is only captured as sugar within the type\n  /// system, not as part of the canonical type, so nullability will\n  /// be lost by canonicalization and desugaring.\n  std::optional<NullabilityKind> getNullability() const;\n\n  /// Determine whether the given type can have a nullability\n  /// specifier applied to it, i.e., if it is any kind of pointer type.\n  ///\n  /// \\param ResultIfUnknown The value to return if we don't yet know whether\n  ///        this type can have nullability because it is dependent.\n  bool canHaveNullability(bool ResultIfUnknown = true) const;\n\n  /// Retrieve the set of substitutions required when accessing a member\n  /// of the Objective-C receiver type that is declared in the given context.\n  ///\n  /// \\c *this is the type of the object we're operating on, e.g., the\n  /// receiver for a message send or the base of a property access, and is\n  /// expected to be of some object or object pointer type.\n  ///\n  /// \\param dc The declaration context for which we are building up a\n  /// substitution mapping, which should be an Objective-C class, extension,\n  /// category, or method within.\n  ///\n  /// \\returns an array of type arguments that can be substituted for\n  /// the type parameters of the given declaration context in any type described\n  /// within that context, or an empty optional to indicate that no\n  /// substitution is required.\n  std::optional<ArrayRef<QualType>>\n  getObjCSubstitutions(const DeclContext *dc) const;\n\n  /// Determines if this is an ObjC interface type that may accept type\n  /// parameters.\n  bool acceptsObjCTypeParams() const;\n\n  const char *getTypeClassName() const;\n\n  QualType getCanonicalTypeInternal() const {\n    return CanonicalType;\n  }\n\n  CanQualType getCanonicalTypeUnqualified() const; // in CanonicalType.h\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-14159",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Type.h",
  "source_line": 2011,
  "validation_status": "validated"
}