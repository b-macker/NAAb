{
  "code": "#include \"absl/debugging/internal/address_is_readable.h\"\n#include <stdint.h>\n#include <syscall.h>\n#include <unistd.h>\n#include \"absl/base/internal/errno_saver.h\"\n#include \"absl/base/internal/raw_logging.h\"\n\nusing namespace absl;\nusing namespace debugging_internal;\nusing namespace debugging_internal;\nusing namespace absl;\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02497_execute() {\n    {\n  // rt_sigprocmask below checks 8 contiguous bytes. If addr resides in the\n  // last 7 bytes of a page (unaligned), rt_sigprocmask would additionally\n  // check the readability of the next page, which is not desired. Align\n  // address on 8-byte boundary to check only the current page.\n  const uintptr_t u_addr = reinterpret_cast<uintptr_t>(addr) & ~uintptr_t{7};\n  addr = reinterpret_cast<const void *>(u_addr);\n\n  // rt_sigprocmask below will succeed for this input.\n  if (addr == nullptr) return false;\n\n  absl::base_internal::ErrnoSaver errno_saver;\n\n  // Here we probe with some syscall which\n  // - accepts an 8-byte region of user memory as input\n  // - tests for EFAULT before other validation\n  // - has no problematic side-effects\n  //\n  // rt_sigprocmask(2) works for this.  It copies sizeof(kernel_sigset_t)==8\n  // bytes from the address into the kernel memory before any validation.\n  //\n  // The call can never succeed, since the `how` parameter is not one of\n  // SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK.\n  //\n  // This strategy depends on Linux implementation details,\n  // so we rely on the test to alert us if it stops working.\n  //\n  // Some discarded past approaches:\n  // - msync() doesn't reject PROT_NONE regions\n  // - write() on /dev/null doesn't return EFAULT\n  // - write() on a pipe requires creating it and draining the writes\n  // - connect() works but is problematic for sandboxes and needs a valid\n  //   file descriptor\n  //\n  // This can never succeed (invalid first argument to sigprocmask).\n  ABSL_RAW_CHECK(syscall(SYS_rt_sigprocmask, ~0, addr, nullptr,\n                         /*sizeof(kernel_sigset_t)*/ 8) == -1,\n                 \"unexpected success\");\n  ABSL_RAW_CHECK(errno == EFAULT || errno == EINVAL, \"unexpected errno\");\n  return errno != EFAULT;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02497",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/address_is_readable.cc",
  "source_line": 52,
  "validation_status": "validated"
}