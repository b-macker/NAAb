{
  "code": "{\n  // The template-like entity that 'owns' the constraint checked here (can be a\n  // constrained entity or a concept).\n  const NamedDecl *ConstraintOwner = nullptr;\n  llvm::SmallVector<TemplateArgument, 4> TemplateArgs;\n\npublic:\n\n  ConstraintSatisfaction() = default;\n\n  ConstraintSatisfaction(const NamedDecl *ConstraintOwner,\n                         ArrayRef<TemplateArgument> TemplateArgs) :\n      ConstraintOwner(ConstraintOwner), TemplateArgs(TemplateArgs.begin(),\n                                                     TemplateArgs.end()) { }\n\n  using SubstitutionDiagnostic = std::pair<SourceLocation, StringRef>;\n  using Detail = llvm::PointerUnion<Expr *, SubstitutionDiagnostic *>;\n\n  bool IsSatisfied = false;\n  bool ContainsErrors = false;\n\n  /// \\brief Pairs of unsatisfied atomic constraint expressions along with the\n  /// substituted constraint expr, if the template arguments could be\n  /// substituted into them, or a diagnostic if substitution resulted in an\n  /// invalid expression.\n  llvm::SmallVector<std::pair<const Expr *, Detail>, 4> Details;\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n    Profile(ID, C, ConstraintOwner, TemplateArgs);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C,\n                      const NamedDecl *ConstraintOwner,\n                      ArrayRef<TemplateArgument> TemplateArgs);\n\n  bool HasSubstitutionFailure() {\n    for (const auto &Detail : Details)\n      if (Detail.second.dyn_cast<SubstitutionDiagnostic *>())\n        return true;\n    return false;\n  }\n}",
  "id": "BLOCK-CPP-22670",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTConcept.h",
  "source_line": 28,
  "validation_status": "validated"
}