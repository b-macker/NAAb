{
  "code": "#include \"spdlog/async.h\"\n#include \"spdlog/details/log_msg.h\"\n#include \"spdlog/details/null_mutex.h\"\n#include \"spdlog/details/synchronous_factory.h\"\n#include \"spdlog/sinks/base_sink.h\"\n#include <mutex>\n#include <spdlog/common.h>\n#include <librdkafka/rdkafkacpp.h>\n\nusing namespace spdlog;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-00421_execute() {\n    {\nnamespace sinks {\n\nstruct kafka_sink_config {\n    std::string server_addr;\n    std::string produce_topic;\n    int32_t flush_timeout_ms = 1000;\n\n    kafka_sink_config(std::string addr, std::string topic, int flush_timeout_ms = 1000)\n        : server_addr{std::move(addr)},\n          produce_topic{std::move(topic)},\n          flush_timeout_ms(flush_timeout_ms) {}\n};\n\ntemplate <typename Mutex>\nclass kafka_sink : public base_sink<Mutex> {\npublic:\n    kafka_sink(kafka_sink_config config)\n        : config_{std::move(config)} {\n        try {\n            std::string errstr;\n            conf_.reset(RdKafka::Conf::create(RdKafka::Conf::CONF_GLOBAL));\n            RdKafka::Conf::ConfResult confRes =\n                conf_->set(\"bootstrap.servers\", config_.server_addr, errstr);\n            if (confRes != RdKafka::Conf::CONF_OK) {\n                throw_spdlog_ex(\n                    fmt_lib::format(\"conf set bootstrap.servers failed err:{}\", errstr));\n            }\n\n            tconf_.reset(RdKafka::Conf::create(RdKafka::Conf::CONF_TOPIC));\n            if (tconf_ == nullptr) {\n                throw_spdlog_ex(fmt_lib::format(\"create topic config failed\"));\n            }\n\n            producer_.reset(RdKafka::Producer::create(conf_.get(), errstr));\n            if (producer_ == nullptr) {\n                throw_spdlog_ex(fmt_lib::format(\"create producer failed err:{}\", errstr));\n            }\n            topic_.reset(RdKafka::Topic::create(producer_.get(), config_.produce_topic,\n                                                tconf_.get(), errstr));\n            if (topic_ == nullptr) {\n                throw_spdlog_ex(fmt_lib::format(\"create topic failed err:{}\", errstr));\n            }\n        } catch (const std::exception &e) {\n            throw_spdlog_ex(fmt_lib::format(\"error create kafka instance: {}\", e.what()));\n        }\n    }\n\n    ~kafka_sink() { producer_->flush(config_.flush_timeout_ms); }\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        producer_->produce(topic_.get(), 0, RdKafka::Producer::RK_MSG_COPY,\n                           (void *)msg.payload.data(), msg.payload.size(), NULL, NULL);\n    }\n\n    void flush_() override { producer_->flush(config_.flush_timeout_ms); }\n\nprivate:\n    kafka_sink_config config_;\n    std::unique_ptr<RdKafka::Producer> producer_ = nullptr;\n    std::unique_ptr<RdKafka::Conf> conf_ = nullptr;\n    std::unique_ptr<RdKafka::Conf> tconf_ = nullptr;\n    std::unique_ptr<RdKafka::Topic> topic_ = nullptr;\n};\n\nusing kafka_sink_mt = kafka_sink<std::mutex>;\nusing kafka_sink_st = kafka_sink<spdlog::details::null_mutex>;\n\n}  // namespace sinks\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> kafka_logger_mt(const std::string &logger_name,\n                                               spdlog::sinks::kafka_sink_config config) {\n    return Factory::template create<sinks::kafka_sink_mt>(logger_name, config);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> kafka_logger_st(const std::string &logger_name,\n                                               spdlog::sinks::kafka_sink_config config) {\n    return Factory::template create<sinks::kafka_sink_st>(logger_name, config);\n}\n\ntemplate <typename Factory = spdlog::async_factory>\ninline std::shared_ptr<spdlog::logger> kafka_logger_async_mt(\n    std::string logger_name, spdlog::sinks::kafka_sink_config config) {\n    return Factory::template create<sinks::kafka_sink_mt>(logger_name, config);\n}\n\ntemplate <typename Factory = spdlog::async_factory>\ninline std::shared_ptr<spdlog::logger> kafka_logger_async_st(\n    std::string logger_name, spdlog::sinks::kafka_sink_config config) {\n    return Factory::template create<sinks::kafka_sink_st>(logger_name, config);\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-00421",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/kafka_sink.h",
  "source_line": 24,
  "validation_status": "validated"
}