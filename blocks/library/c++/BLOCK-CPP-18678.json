{
  "code": "{\n  const SourceManager &SM;\n  const LangOptions &LangOpts;\n  DiagnosticsEngine &Diags;\n\n  const char *const ThisTokBegin;\n  const char *const ThisTokEnd;\n  const char *DigitsBegin, *SuffixBegin; // markers\n  const char *s; // cursor\n\n  unsigned radix;\n\n  bool saw_exponent, saw_period, saw_ud_suffix, saw_fixed_point_suffix;\n\n  SmallString<32> UDSuffixBuf;\n\npublic:\n  NumericLiteralParser(StringRef TokSpelling, SourceLocation TokLoc,\n                       const SourceManager &SM, const LangOptions &LangOpts,\n                       const TargetInfo &Target, DiagnosticsEngine &Diags);\n  bool hadError : 1;\n  bool isUnsigned : 1;\n  bool isLong : 1;          // This is *not* set for long long.\n  bool isLongLong : 1;\n  bool isSizeT : 1;         // 1z, 1uz (C++23)\n  bool isHalf : 1;          // 1.0h\n  bool isFloat : 1;         // 1.0f\n  bool isImaginary : 1;     // 1.0i\n  bool isFloat16 : 1;       // 1.0f16\n  bool isFloat128 : 1;      // 1.0q\n  bool isFract : 1;         // 1.0hr/r/lr/uhr/ur/ulr\n  bool isAccum : 1;         // 1.0hk/k/lk/uhk/uk/ulk\n  bool isBitInt : 1;        // 1wb, 1uwb (C2x)\n  uint8_t MicrosoftInteger; // Microsoft suffix extension i8, i16, i32, or i64.\n\n\n  bool isFixedPointLiteral() const {\n    return (saw_period || saw_exponent) && saw_fixed_point_suffix;\n  }\n\n  bool isIntegerLiteral() const {\n    return !saw_period && !saw_exponent && !isFixedPointLiteral();\n  }\n  bool isFloatingLiteral() const {\n    return (saw_period || saw_exponent) && !isFixedPointLiteral();\n  }\n\n  bool hasUDSuffix() const {\n    return saw_ud_suffix;\n  }\n  StringRef getUDSuffix() const {\n    assert(saw_ud_suffix);\n    return UDSuffixBuf;\n  }\n  unsigned getUDSuffixOffset() const {\n    assert(saw_ud_suffix);\n    return SuffixBegin - ThisTokBegin;\n  }\n\n  static bool isValidUDSuffix(const LangOptions &LangOpts, StringRef Suffix);\n\n  unsigned getRadix() const { return radix; }\n\n  /// GetIntegerValue - Convert this numeric literal value to an APInt that\n  /// matches Val's input width.  If there is an overflow (i.e., if the unsigned\n  /// value read is larger than the APInt's bits will hold), set Val to the low\n  /// bits of the result and return true.  Otherwise, return false.\n  bool GetIntegerValue(llvm::APInt &Val);\n\n  /// GetFloatValue - Convert this numeric literal to a floating value, using\n  /// the specified APFloat fltSemantics (specifying float, double, etc).\n  /// The optional bool isExact (passed-by-reference) has its value\n  /// set to true if the returned APFloat can represent the number in the\n  /// literal exactly, and false otherwise.\n  llvm::APFloat::opStatus GetFloatValue(llvm::APFloat &Result);\n\n  /// GetFixedPointValue - Convert this numeric literal value into a\n  /// scaled integer that represents this value. Returns true if an overflow\n  /// occurred when calculating the integral part of the scaled integer or\n  /// calculating the digit sequence of the exponent.\n  bool GetFixedPointValue(llvm::APInt &StoreVal, unsigned Scale);\n\n  /// Get the digits that comprise the literal. This excludes any prefix or\n  /// suffix associated with the literal.\n  StringRef getLiteralDigits() const {\n    assert(!hadError && \"cannot reliably get the literal digits with an error\");\n    return StringRef(DigitsBegin, SuffixBegin - DigitsBegin);\n  }\n\nprivate:\n\n  void ParseNumberStartingWithZero(SourceLocation TokLoc);\n  void ParseDecimalOrOctalCommon(SourceLocation TokLoc);\n\n  static bool isDigitSeparator(char C) { return C == '\\''; }\n\n  /// Determine whether the sequence of characters [Start, End) contains\n  /// any real digits (not digit separators).\n  bool containsDigits(const char *Start, const char *End) {\n    return Start != End && (Start + 1 != End || !isDigitSeparator(Start[0]));\n  }\n\n  enum CheckSeparatorKind { CSK_BeforeDigits, CSK_AfterDigits };\n\n  /// Ensure that we don't have a digit separator here.\n  void checkSeparator(SourceLocation TokLoc, const char *Pos,\n                      CheckSeparatorKind IsAfterDigits);\n\n  /// SkipHexDigits - Read and skip over any hex digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipHexDigits(const char *ptr) {\n    while (ptr != ThisTokEnd && (isHexDigit(*ptr) || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipOctalDigits - Read and skip over any octal digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipOctalDigits(const char *ptr) {\n    while (ptr != ThisTokEnd &&\n           ((*ptr >= '0' && *ptr <= '7') || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipDigits - Read and skip over any digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipDigits(const char *ptr) {\n    while (ptr != ThisTokEnd && (isDigit(*ptr) || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipBinaryDigits - Read and skip over any binary digits, up to End.\n  /// Return a pointer to the first non-binary digit or End.\n  const char *SkipBinaryDigits(const char *ptr) {\n    while (ptr != ThisTokEnd &&\n           (*ptr == '0' || *ptr == '1' || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n}",
  "id": "BLOCK-CPP-18678",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/LiteralSupport.h",
  "source_line": 42,
  "validation_status": "validated"
}