{
  "code": "{\npublic:\n  using InstrArray = SimpleArray<SExpr *>;\n  using BlockArray = SimpleArray<BasicBlock *>;\n\n  // TopologyNodes are used to overlay tree structures on top of the CFG,\n  // such as dominator and postdominator trees.  Each block is assigned an\n  // ID in the tree according to a depth-first search.  Tree traversals are\n  // always up, towards the parents.\n  struct TopologyNode {\n    int NodeID = 0;\n\n    // Includes this node, so must be > 1.\n    int SizeOfSubTree = 0;\n\n    // Pointer to parent.\n    BasicBlock *Parent = nullptr;\n\n    TopologyNode() = default;\n\n    bool isParentOf(const TopologyNode& OtherNode) {\n      return OtherNode.NodeID > NodeID &&\n             OtherNode.NodeID < NodeID + SizeOfSubTree;\n    }\n\n    bool isParentOfOrEqual(const TopologyNode& OtherNode) {\n      return OtherNode.NodeID >= NodeID &&\n             OtherNode.NodeID < NodeID + SizeOfSubTree;\n    }\n  };\n\n  explicit BasicBlock(MemRegionRef A)\n      : SExpr(COP_BasicBlock), Arena(A), BlockID(0), Visited(false) {}\n  BasicBlock(BasicBlock &B, MemRegionRef A, InstrArray &&As, InstrArray &&Is,\n             Terminator *T)\n      : SExpr(COP_BasicBlock), Arena(A), BlockID(0), Visited(false),\n        Args(std::move(As)), Instrs(std::move(Is)), TermInstr(T) {}\n\n  static bool classof(const SExpr *E) { return E->opcode() == COP_BasicBlock; }\n\n  /// Returns the block ID.  Every block has a unique ID in the CFG.\n  int blockID() const { return BlockID; }\n\n  /// Returns the number of predecessors.\n  size_t numPredecessors() const { return Predecessors.size(); }\n  size_t numSuccessors() const { return successors().size(); }\n\n  const SCFG* cfg() const { return CFGPtr; }\n  SCFG* cfg() { return CFGPtr; }\n\n  const BasicBlock *parent() const { return DominatorNode.Parent; }\n  BasicBlock *parent() { return DominatorNode.Parent; }\n\n  const InstrArray &arguments() const { return Args; }\n  InstrArray &arguments() { return Args; }\n\n  InstrArray &instructions() { return Instrs; }\n  const InstrArray &instructions() const { return Instrs; }\n\n  /// Returns a list of predecessors.\n  /// The order of predecessors in the list is important; each phi node has\n  /// exactly one argument for each precessor, in the same order.\n  BlockArray &predecessors() { return Predecessors; }\n  const BlockArray &predecessors() const { return Predecessors; }\n\n  ArrayRef<BasicBlock*> successors() { return TermInstr->successors(); }\n  ArrayRef<BasicBlock*> successors() const { return TermInstr->successors(); }\n\n  const Terminator *terminator() const { return TermInstr; }\n  Terminator *terminator() { return TermInstr; }\n\n  void setTerminator(Terminator *E) { TermInstr = E; }\n\n  bool Dominates(const BasicBlock &Other) {\n    return DominatorNode.isParentOfOrEqual(Other.DominatorNode);\n  }\n\n  bool PostDominates(const BasicBlock &Other) {\n    return PostDominatorNode.isParentOfOrEqual(Other.PostDominatorNode);\n  }\n\n  /// Add a new argument.\n  void addArgument(Phi *V) {\n    Args.reserveCheck(1, Arena);\n    Args.push_back(V);\n  }\n\n  /// Add a new instruction.\n  void addInstruction(SExpr *V) {\n    Instrs.reserveCheck(1, Arena);\n    Instrs.push_back(V);\n  }\n\n  // Add a new predecessor, and return the phi-node index for it.\n  // Will add an argument to all phi-nodes, initialized to nullptr.\n  unsigned addPredecessor(BasicBlock *Pred);\n\n  // Reserve space for Nargs arguments.\n  void reserveArguments(unsigned Nargs)   { Args.reserve(Nargs, Arena); }\n\n  // Reserve space for Nins instructions.\n  void reserveInstructions(unsigned Nins) { Instrs.reserve(Nins, Arena); }\n\n  // Reserve space for NumPreds predecessors, including space in phi nodes.\n  void reservePredecessors(unsigned NumPreds);\n\n  /// Return the index of BB, or Predecessors.size if BB is not a predecessor.\n  unsigned findPredecessorIndex(const BasicBlock *BB) const {\n    auto I = llvm::find(Predecessors, BB);\n    return std::distance(Predecessors.cbegin(), I);\n  }\n\n  template <class V>\n  typename V::R_BasicBlock traverse(V &Vs, typename V::R_Ctx Ctx) {\n    typename V::template Container<SExpr*> Nas(Vs, Args.size());\n    typename V::template Container<SExpr*> Nis(Vs, Instrs.size());\n\n    // Entering the basic block should do any scope initialization.\n    Vs.enterBasicBlock(*this);\n\n    for (const auto *E : Args) {\n      auto Ne = Vs.traverse(E, Vs.subExprCtx(Ctx));\n      Nas.push_back(Ne);\n    }\n    for (const auto *E : Instrs) {\n      auto Ne = Vs.traverse(E, Vs.subExprCtx(Ctx));\n      Nis.push_back(Ne);\n    }\n    auto Nt = Vs.traverse(TermInstr, Ctx);\n\n    // Exiting the basic block should handle any scope cleanup.\n    Vs.exitBasicBlock(*this);\n\n    return Vs.reduceBasicBlock(*this, Nas, Nis, Nt);\n  }\n\n  template <class C>\n  typename C::CType compare(const BasicBlock *E, C &Cmp) const {\n    // TODO: implement CFG comparisons\n    return Cmp.comparePointers(this, E);\n  }\n\nprivate:\n  friend class SCFG;\n\n  // assign unique ids to all instructions\n  unsigned renumberInstrs(unsigned id);\n\n  unsigned topologicalSort(SimpleArray<BasicBlock *> &Blocks, unsigned ID);\n  unsigned topologicalFinalSort(SimpleArray<BasicBlock *> &Blocks, unsigned ID);\n  void computeDominator();\n  void computePostDominator();\n\n  // The arena used to allocate this block.\n  MemRegionRef Arena;\n\n  // The CFG that contains this block.\n  SCFG *CFGPtr = nullptr;\n\n  // Unique ID for this BB in the containing CFG. IDs are in topological order.\n  unsigned BlockID : 31;\n\n  // Bit to determine if a block has been visited during a traversal.\n  bool Visited : 1;\n\n  // Predecessor blocks in the CFG.\n  BlockArray Predecessors;\n\n  // Phi nodes. One argument per predecessor.\n  InstrArray Args;\n\n  // Instructions.\n  InstrArray Instrs;\n\n  // Terminating instruction.\n  Terminator *TermInstr = nullptr;\n\n  // The dominator tree.\n  TopologyNode DominatorNode;\n\n  // The post-dominator tree.\n  TopologyNode PostDominatorNode;\n}",
  "id": "BLOCK-CPP-21674",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h",
  "source_line": 1508,
  "validation_status": "validated"
}