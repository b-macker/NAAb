{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// https://github.com/llvm/llvm-project/issues/64544\n// libc++ had the wrong signature for std::rotl and std::rotr\n// prior to libc++ 18.0.\n//\n#if (defined(__cpp_lib_bitops) && __cpp_lib_bitops >= 201907L) &&     \\\n    (!defined(_LIBCPP_VERSION) || _LIBCPP_VERSION >= 180000)\nusing std::rotl;\nusing std::rotr;\n\n#else\n\n// Rotating functions\ntemplate <class T>\nABSL_MUST_USE_RESULT constexpr\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    rotl(T x, int s) noexcept {\n  return numeric_internal::RotateLeft(x, s);\n}\n\ntemplate <class T>\nABSL_MUST_USE_RESULT constexpr\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    rotr(T x, int s) noexcept {\n  return numeric_internal::RotateRight(x, s);\n}\n\n#endif\n\n// https://github.com/llvm/llvm-project/issues/64544\n// libc++ had the wrong signature for std::rotl and std::rotr\n// prior to libc++ 18.0.\n//\n#if (defined(__cpp_lib_bitops) && __cpp_lib_bitops >= 201907L)\n\nusing std::countl_one;\nusing std::countl_zero;\nusing std::countr_one;\nusing std::countr_zero;\nusing std::popcount;\n\n#else\n\n// Counting functions\n//\n// While these functions are typically constexpr, on some platforms, they may\n// not be marked as constexpr due to constraints of the compiler/available\n// intrinsics.\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    countl_zero(T x) noexcept {\n  return numeric_internal::CountLeadingZeroes(x);\n}\n\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    countl_one(T x) noexcept {\n  // Avoid integer promotion to a wider type\n  return countl_zero(static_cast<T>(~x));\n}\n\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CTZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    countr_zero(T x) noexcept {\n  return numeric_internal::CountTrailingZeroes(x);\n}\n\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CTZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    countr_one(T x) noexcept {\n  // Avoid integer promotion to a wider type\n  return countr_zero(static_cast<T>(~x));\n}\n\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_POPCOUNT inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    popcount(T x) noexcept {\n  return numeric_internal::Popcount(x);\n}\n\n#endif\n\n#if (defined(__cpp_lib_int_pow2) && __cpp_lib_int_pow2 >= 202002L)\n\nusing std::bit_ceil;\nusing std::bit_floor;\nusing std::bit_width;\nusing std::has_single_bit;\n\n#else\n\n// Returns: true if x is an integral power of two; false otherwise.\ntemplate <class T>\nconstexpr inline typename std::enable_if<std::is_unsigned<T>::value, bool>::type\nhas_single_bit(T x) noexcept {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\n// Returns: If x == 0, 0; otherwise one plus the base-2 logarithm of x, with any\n// fractional part discarded.\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, int>::type\n    bit_width(T x) noexcept {\n  return std::numeric_limits<T>::digits - countl_zero(x);\n}\n\n// Returns: If x == 0, 0; otherwise the maximal value y such that\n// has_single_bit(y) is true and y <= x.\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    bit_floor(T x) noexcept {\n  return x == 0 ? 0 : T{1} << (bit_width(x) - 1);\n}\n\n// Returns: N, where N is the smallest power of 2 greater than or equal to x.\n//\n// Preconditions: N is representable as a value of type T.\ntemplate <class T>\nABSL_INTERNAL_CONSTEXPR_CLZ inline\n    typename std::enable_if<std::is_unsigned<T>::value, T>::type\n    bit_ceil(T x) {\n  // If T is narrower than unsigned, T{1} << bit_width will be promoted.  We\n  // want to force it to wraparound so that bit_ceil of an invalid value are not\n  // core constant expressions.\n  //\n  // BitCeilNonPowerOf2 triggers an overflow in constexpr contexts if we would\n  // undergo promotion to unsigned but not fit the result into T without\n  // truncation.\n  return has_single_bit(x) ? T{1} << (bit_width(x) - 1)\n                           : numeric_internal::BitCeilNonPowerOf2(x);\n}\n\n#endif\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03727",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/bits.h",
  "source_line": 50,
  "validation_status": "validated"
}