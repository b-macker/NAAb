{
  "code": "{\npublic:\n  /// An allocator for DiagnosticStorage objects, which uses a small cache to\n  /// objects, used to reduce malloc()/free() traffic for partial diagnostics.\n  class DiagStorageAllocator {\n    static const unsigned NumCached = 16;\n    DiagnosticStorage Cached[NumCached];\n    DiagnosticStorage *FreeList[NumCached];\n    unsigned NumFreeListEntries;\n\n  public:\n    DiagStorageAllocator();\n    ~DiagStorageAllocator();\n\n    /// Allocate new storage.\n    DiagnosticStorage *Allocate() {\n      if (NumFreeListEntries == 0)\n        return new DiagnosticStorage;\n\n      DiagnosticStorage *Result = FreeList[--NumFreeListEntries];\n      Result->NumDiagArgs = 0;\n      Result->DiagRanges.clear();\n      Result->FixItHints.clear();\n      return Result;\n    }\n\n    /// Free the given storage object.\n    void Deallocate(DiagnosticStorage *S) {\n      if (S >= Cached && S <= Cached + NumCached) {\n        FreeList[NumFreeListEntries++] = S;\n        return;\n      }\n\n      delete S;\n    }\n  };\n\nprotected:\n  mutable DiagnosticStorage *DiagStorage = nullptr;\n\n  /// Allocator used to allocate storage for this diagnostic.\n  DiagStorageAllocator *Allocator = nullptr;\n\npublic:\n  /// Retrieve storage for this particular diagnostic.\n  DiagnosticStorage *getStorage() const {\n    if (DiagStorage)\n      return DiagStorage;\n\n    assert(Allocator);\n    DiagStorage = Allocator->Allocate();\n    return DiagStorage;\n  }\n\n  void freeStorage() {\n    if (!DiagStorage)\n      return;\n\n    // The hot path for PartialDiagnostic is when we just used it to wrap an ID\n    // (typically so we have the flexibility of passing a more complex\n    // diagnostic into the callee, but that does not commonly occur).\n    //\n    // Split this out into a slow function for silly compilers (*cough*) which\n    // can't do decent partial inlining.\n    freeStorageSlow();\n  }\n\n  void freeStorageSlow() {\n    if (!Allocator)\n      return;\n    Allocator->Deallocate(DiagStorage);\n    DiagStorage = nullptr;\n  }\n\n  void AddTaggedVal(uint64_t V, DiagnosticsEngine::ArgumentKind Kind) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] = Kind;\n    DiagStorage->DiagArgumentsVal[DiagStorage->NumDiagArgs++] = V;\n  }\n\n  void AddString(StringRef V) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] =\n        DiagnosticsEngine::ak_std_string;\n    DiagStorage->DiagArgumentsStr[DiagStorage->NumDiagArgs++] = std::string(V);\n  }\n\n  void AddSourceRange(const CharSourceRange &R) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->DiagRanges.push_back(R);\n  }\n\n  void AddFixItHint(const FixItHint &Hint) const {\n    if (Hint.isNull())\n      return;\n\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->FixItHints.push_back(Hint);\n  }\n\n  /// Conversion of StreamingDiagnostic to bool always returns \\c true.\n  ///\n  /// This allows is to be used in boolean error contexts (where \\c true is\n  /// used to indicate that an error has occurred), like:\n  /// \\code\n  /// return Diag(...);\n  /// \\endcode\n  operator bool() const { return true; }\n\nprotected:\n  StreamingDiagnostic() = default;\n\n  /// Construct with an external storage not owned by itself. The allocator\n  /// is a null pointer in this case.\n  explicit StreamingDiagnostic(DiagnosticStorage *Storage)\n      : DiagStorage(Storage) {}\n\n  /// Construct with a storage allocator which will manage the storage. The\n  /// allocator is not a null pointer in this case.\n  explicit StreamingDiagnostic(DiagStorageAllocator &Alloc)\n      : Allocator(&Alloc) {}\n\n  StreamingDiagnostic(const StreamingDiagnostic &Diag) = default;\n  StreamingDiagnostic(StreamingDiagnostic &&Diag) = default;\n\n  ~StreamingDiagnostic() { freeStorage(); }\n}",
  "id": "BLOCK-CPP-16247",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Diagnostic.h",
  "source_line": 1110,
  "validation_status": "validated"
}