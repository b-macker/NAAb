{
  "code": "#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/ADT/STLExtras.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-09504_execute() {\n    {\n\nclass ASTContext;\n\n/// Given a potentially-evaluated expression, this visitor visits all\n/// of its potentially-evaluated subexpressions, recursively.\ntemplate<template <typename> class Ptr, typename ImplClass>\nclass EvaluatedExprVisitorBase : public StmtVisitorBase<Ptr, ImplClass, void> {\nprotected:\n  const ASTContext &Context;\n\npublic:\n  // Return whether this visitor should recurse into discarded statements for a\n  // 'constexpr-if'.\n  bool shouldVisitDiscardedStmt() const { return true; }\n#define PTR(CLASS) typename Ptr<CLASS>::type\n\n  explicit EvaluatedExprVisitorBase(const ASTContext &Context) : Context(Context) { }\n\n  // Expressions that have no potentially-evaluated subexpressions (but may have\n  // other sub-expressions).\n  void VisitDeclRefExpr(PTR(DeclRefExpr) E) { }\n  void VisitOffsetOfExpr(PTR(OffsetOfExpr) E) { }\n  void VisitUnaryExprOrTypeTraitExpr(PTR(UnaryExprOrTypeTraitExpr) E) { }\n  void VisitExpressionTraitExpr(PTR(ExpressionTraitExpr) E) { }\n  void VisitBlockExpr(PTR(BlockExpr) E) { }\n  void VisitCXXUuidofExpr(PTR(CXXUuidofExpr) E) { }\n  void VisitCXXNoexceptExpr(PTR(CXXNoexceptExpr) E) { }\n\n  void VisitMemberExpr(PTR(MemberExpr) E) {\n    // Only the base matters.\n    return this->Visit(E->getBase());\n  }\n\n  void VisitChooseExpr(PTR(ChooseExpr) E) {\n    // Don't visit either child expression if the condition is dependent.\n    if (E->getCond()->isValueDependent())\n      return;\n    // Only the selected subexpression matters; the other one is not evaluated.\n    return this->Visit(E->getChosenSubExpr());\n  }\n\n  void VisitGenericSelectionExpr(PTR(GenericSelectionExpr) E) {\n    // The controlling expression of a generic selection is not evaluated.\n\n    // Don't visit either child expression if the condition is type-dependent.\n    if (E->isResultDependent())\n      return;\n    // Only the selected subexpression matters; the other subexpressions and the\n    // controlling expression are not evaluated.\n    return this->Visit(E->getResultExpr());\n  }\n\n  void VisitDesignatedInitExpr(PTR(DesignatedInitExpr) E) {\n    // Only the actual initializer matters; the designators are all constant\n    // expressions.\n    return this->Visit(E->getInit());\n  }\n\n  void VisitCXXTypeidExpr(PTR(CXXTypeidExpr) E) {\n    if (E->isPotentiallyEvaluated())\n      return this->Visit(E->getExprOperand());\n  }\n\n  void VisitCallExpr(PTR(CallExpr) CE) {\n    if (!CE->isUnevaluatedBuiltinCall(Context))\n      return getDerived().VisitExpr(CE);\n  }\n\n  void VisitLambdaExpr(PTR(LambdaExpr) LE) {\n    // Only visit the capture initializers, and not the body.\n    for (LambdaExpr::const_capture_init_iterator I = LE->capture_init_begin(),\n                                                 E = LE->capture_init_end();\n         I != E; ++I)\n      if (*I)\n        this->Visit(*I);\n  }\n\n  /// The basis case walks all of the children of the statement or\n  /// expression, assuming they are all potentially evaluated.\n  void VisitStmt(PTR(Stmt) S) {\n    for (auto *SubStmt : S->children())\n      if (SubStmt)\n        this->Visit(SubStmt);\n  }\n\n  void VisitIfStmt(PTR(IfStmt) If) {\n    if (!getDerived().shouldVisitDiscardedStmt()) {\n      if (auto SubStmt = If->getNondiscardedCase(Context)) {\n        if (*SubStmt)\n          this->Visit(*SubStmt);\n        return;\n      }\n    }\n\n    getDerived().VisitStmt(If);\n  }\n\n  ImplClass &getDerived() { return *static_cast<ImplClass *>(this); }\n\n#undef PTR\n};\n\n/// EvaluatedExprVisitor - This class visits 'Expr *'s\ntemplate <typename ImplClass>\nclass EvaluatedExprVisitor\n    : public EvaluatedExprVisitorBase<std::add_pointer, ImplClass> {\npublic:\n  explicit EvaluatedExprVisitor(const ASTContext &Context)\n      : EvaluatedExprVisitorBase<std::add_pointer, ImplClass>(Context) {}\n};\n\n/// ConstEvaluatedExprVisitor - This class visits 'const Expr *'s.\ntemplate <typename ImplClass>\nclass ConstEvaluatedExprVisitor\n    : public EvaluatedExprVisitorBase<llvm::make_const_ptr, ImplClass> {\npublic:\n  explicit ConstEvaluatedExprVisitor(const ASTContext &Context)\n      : EvaluatedExprVisitorBase<llvm::make_const_ptr, ImplClass>(Context) {}\n};\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-09504",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/EvaluatedExprVisitor.h",
  "source_line": 23,
  "validation_status": "validated"
}