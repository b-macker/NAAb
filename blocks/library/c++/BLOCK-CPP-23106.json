{
  "code": "{\n//   template <class BasicReader, class... BufferTypes>\n//   static ValueType read(BasicReader &R, BufferTypes &&...);\n// };\n\n// BasicReaderBase provides convenience implementations of the read methods\n// for EnumPropertyType and SubclassPropertyType types that just defer to\n// the \"underlying\" implementations (for UInt32 and the base class,\n// respectively).\n//\n// template <class Impl>\n// class BasicReaderBase {\n// protected:\n//   BasicReaderBase(ASTContext &ctx);\n//   Impl &asImpl();\n// public:\n//   ASTContext &getASTContext();\n//   ...\n// };\n\n// The actual classes are auto-generated; see ClangASTPropertiesEmitter.cpp.\n#include \"clang/AST/AbstractBasicReader.inc\"\n\n/// DataStreamBasicReader provides convenience implementations for many\n/// BasicReader methods based on the assumption that the\n/// ultimate reader implementation is based on a variable-length stream\n/// of unstructured data (like Clang's module files).  It is designed\n/// to pair with DataStreamBasicWriter.\n///\n/// This class can also act as a PropertyReader, implementing find(\"...\")\n/// by simply forwarding to itself.\n///\n/// Unimplemented methods:\n///   readBool\n///   readUInt32\n///   readUInt64\n///   readIdentifier\n///   readSelector\n///   readSourceLocation\n///   readQualType\n///   readStmtRef\n///   readDeclRef\ntemplate <class Impl>\nclass DataStreamBasicReader : public BasicReaderBase<Impl> {\nprotected:\n  using BasicReaderBase<Impl>::asImpl;\n  DataStreamBasicReader(ASTContext &ctx) : BasicReaderBase<Impl>(ctx) {}\n\npublic:\n  using BasicReaderBase<Impl>::getASTContext;\n\n  /// Implement property-find by ignoring it.  We rely on properties being\n  /// serialized and deserialized in a reliable order instead.\n  Impl &find(const char *propertyName) {\n    return asImpl();\n  }\n\n  template <class T>\n  T readEnum() {\n    return T(asImpl().readUInt32());\n  }\n\n  // Implement object reading by forwarding to this, collapsing the\n  // structure into a single data stream.\n  Impl &readObject() { return asImpl(); }\n\n  template <class T>\n  llvm::ArrayRef<T> readArray(llvm::SmallVectorImpl<T> &buffer) {\n    assert(buffer.empty());\n\n    uint32_t size = asImpl().readUInt32();\n    buffer.reserve(size);\n\n    for (uint32_t i = 0; i != size; ++i) {\n      buffer.push_back(ReadDispatcher<T>::read(asImpl()));\n    }\n    return buffer;\n  }\n\n  template <class T, class... Args>\n  std::optional<T> readOptional(Args &&...args) {\n    return UnpackOptionalValue<T>::unpack(\n             ReadDispatcher<T>::read(asImpl(), std::forward<Args>(args)...));\n  }\n\n  llvm::APSInt readAPSInt() {\n    bool isUnsigned = asImpl().readBool();\n    llvm::APInt value = asImpl().readAPInt();\n    return llvm::APSInt(std::move(value), isUnsigned);\n  }\n\n  llvm::APInt readAPInt() {\n    unsigned bitWidth = asImpl().readUInt32();\n    unsigned numWords = llvm::APInt::getNumWords(bitWidth);\n    llvm::SmallVector<uint64_t, 4> data;\n    for (uint32_t i = 0; i != numWords; ++i)\n      data.push_back(asImpl().readUInt64());\n    return llvm::APInt(bitWidth, numWords, &data[0]);\n  }\n\n  llvm::FixedPointSemantics readFixedPointSemantics() {\n    unsigned width = asImpl().readUInt32();\n    unsigned scale = asImpl().readUInt32();\n    unsigned tmp = asImpl().readUInt32();\n    bool isSigned = tmp & 0x1;\n    bool isSaturated = tmp & 0x2;\n    bool hasUnsignedPadding = tmp & 0x4;\n    return llvm::FixedPointSemantics(width, scale, isSigned, isSaturated,\n                                     hasUnsignedPadding);\n  }\n\n  APValue::LValuePathSerializationHelper readLValuePathSerializationHelper(\n      SmallVectorImpl<APValue::LValuePathEntry> &path) {\n    auto origTy = asImpl().readQualType();\n    auto elemTy = origTy;\n    unsigned pathLength = asImpl().readUInt32();\n    for (unsigned i = 0; i < pathLength; ++i) {\n      if (elemTy->template getAs<RecordType>()) {\n        unsigned int_ = asImpl().readUInt32();\n        Decl *decl = asImpl().template readDeclAs<Decl>();\n        if (auto *recordDecl = dyn_cast<CXXRecordDecl>(decl))\n          elemTy = getASTContext().getRecordType(recordDecl);\n        else\n          elemTy = cast<ValueDecl>(decl)->getType();\n        path.push_back(\n            APValue::LValuePathEntry(APValue::BaseOrMemberType(decl, int_)));\n      } else {\n        elemTy = getASTContext().getAsArrayType(elemTy)->getElementType();\n        path.push_back(\n            APValue::LValuePathEntry::ArrayIndex(asImpl().readUInt32()));\n      }\n    }\n    return APValue::LValuePathSerializationHelper(path, origTy);\n  }\n\n  Qualifiers readQualifiers() {\n    static_assert(sizeof(Qualifiers().getAsOpaqueValue()) <= sizeof(uint32_t),\n                  \"update this if the value size changes\");\n    uint32_t value = asImpl().readUInt32();\n    return Qualifiers::fromOpaqueValue(value);\n  }\n\n  FunctionProtoType::ExceptionSpecInfo\n  readExceptionSpecInfo(llvm::SmallVectorImpl<QualType> &buffer) {\n    FunctionProtoType::ExceptionSpecInfo esi;\n    esi.Type = ExceptionSpecificationType(asImpl().readUInt32());\n    if (esi.Type == EST_Dynamic) {\n      esi.Exceptions = asImpl().template readArray<QualType>(buffer);\n    } else if (isComputedNoexcept(esi.Type)) {\n      esi.NoexceptExpr = asImpl().readExprRef();\n    } else if (esi.Type == EST_Uninstantiated) {\n      esi.SourceDecl = asImpl().readFunctionDeclRef();\n      esi.SourceTemplate = asImpl().readFunctionDeclRef();\n    } else if (esi.Type == EST_Unevaluated) {\n      esi.SourceDecl = asImpl().readFunctionDeclRef();\n    }\n    return esi;\n  }\n\n  FunctionProtoType::ExtParameterInfo readExtParameterInfo() {\n    static_assert(sizeof(FunctionProtoType::ExtParameterInfo().getOpaqueValue())\n                    <= sizeof(uint32_t),\n                  \"opaque value doesn't fit into uint32_t\");\n    uint32_t value = asImpl().readUInt32();\n    return FunctionProtoType::ExtParameterInfo::getFromOpaqueValue(value);\n  }\n\n  NestedNameSpecifier *readNestedNameSpecifier() {\n    auto &ctx = getASTContext();\n\n    // We build this up iteratively.\n    NestedNameSpecifier *cur = nullptr;\n\n    uint32_t depth = asImpl().readUInt32();\n    for (uint32_t i = 0; i != depth; ++i) {\n      auto kind = asImpl().readNestedNameSpecifierKind();\n      switch (kind) {\n      case NestedNameSpecifier::Identifier:\n        cur = NestedNameSpecifier::Create(ctx, cur,\n                                          asImpl().readIdentifier());\n        continue;\n\n      case NestedNameSpecifier::Namespace:\n        cur = NestedNameSpecifier::Create(ctx, cur,\n                                          asImpl().readNamespaceDeclRef());\n        continue;\n\n      case NestedNameSpecifier::NamespaceAlias:\n        cur = NestedNameSpecifier::Create(ctx, cur,\n                                     asImpl().readNamespaceAliasDeclRef());\n        continue;\n\n      case NestedNameSpecifier::TypeSpec:\n      case NestedNameSpecifier::TypeSpecWithTemplate:\n        cur = NestedNameSpecifier::Create(ctx, cur,\n                          kind == NestedNameSpecifier::TypeSpecWithTemplate,\n                          asImpl().readQualType().getTypePtr());\n        continue;\n\n      case NestedNameSpecifier::Global:\n        cur = NestedNameSpecifier::GlobalSpecifier(ctx);\n        continue;\n\n      case NestedNameSpecifier::Super:\n        cur = NestedNameSpecifier::SuperSpecifier(ctx,\n                                            asImpl().readCXXRecordDeclRef());\n        continue;\n      }\n      llvm_unreachable(\"bad nested name specifier kind\");\n    }\n\n    return cur;\n  }\n};\n\n}",
  "id": "BLOCK-CPP-23106",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/AbstractBasicReader.h",
  "source_line": 80,
  "validation_status": "validated"
}