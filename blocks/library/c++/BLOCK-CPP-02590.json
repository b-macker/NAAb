{
  "code": "#include \"absl/debugging/internal/elf_mem_image.h\"\n#include <string.h>\n#include <cassert>\n#include <cstddef>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/raw_logging.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02590_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace debugging_internal {\n\nnamespace {\n\n#if __SIZEOF_POINTER__ == 4\nconst int kElfClass = ELFCLASS32;\nint ElfBind(const ElfW(Sym) *symbol) { return ELF32_ST_BIND(symbol->st_info); }\nint ElfType(const ElfW(Sym) *symbol) { return ELF32_ST_TYPE(symbol->st_info); }\n#elif __SIZEOF_POINTER__ == 8\nconst int kElfClass = ELFCLASS64;\nint ElfBind(const ElfW(Sym) *symbol) { return ELF64_ST_BIND(symbol->st_info); }\nint ElfType(const ElfW(Sym) *symbol) { return ELF64_ST_TYPE(symbol->st_info); }\n#else\nconst int kElfClass = -1;\nint ElfBind(const ElfW(Sym) *) {\n  ABSL_RAW_LOG(FATAL, \"Unexpected word size\");\n  return 0;\n}\nint ElfType(const ElfW(Sym) *) {\n  ABSL_RAW_LOG(FATAL, \"Unexpected word size\");\n  return 0;\n}\n#endif\n\n// Extract an element from one of the ELF tables, cast it to desired type.\n// This is just a simple arithmetic and a glorified cast.\n// Callers are responsible for bounds checking.\ntemplate <typename T>\nconst T *GetTableElement(const ElfW(Ehdr) * ehdr, ElfW(Off) table_offset,\n                         ElfW(Word) element_size, size_t index) {\n  return reinterpret_cast<const T*>(reinterpret_cast<const char *>(ehdr)\n                                    + table_offset\n                                    + index * element_size);\n}\n\n}  // namespace\n\n// The value of this variable doesn't matter; it's used only for its\n// unique address.\nconst int ElfMemImage::kInvalidBaseSentinel = 0;\n\nElfMemImage::ElfMemImage(const void *base) {\n  ABSL_RAW_CHECK(base != kInvalidBase, \"bad pointer\");\n  Init(base);\n}\n\nint ElfMemImage::GetNumSymbols() const {\n  if (!hash_) {\n    return 0;\n  }\n  // See http://www.caldera.com/developers/gabi/latest/ch5.dynamic.html#hash\n  return static_cast<int>(hash_[1]);\n}\n\nconst ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {\n  ABSL_RAW_CHECK(index < GetNumSymbols(), \"index out of range\");\n  return dynsym_ + index;\n}\n\nconst ElfW(Versym) *ElfMemImage::GetVersym(int index) const {\n  ABSL_RAW_CHECK(index < GetNumSymbols(), \"index out of range\");\n  return versym_ + index;\n}\n\nconst ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {\n  ABSL_RAW_CHECK(index >= 0 && index < ehdr_->e_phnum, \"index out of range\");\n  return GetTableElement<ElfW(Phdr)>(ehdr_, ehdr_->e_phoff, ehdr_->e_phentsize,\n                                     static_cast<size_t>(index));\n}\n\nconst char *ElfMemImage::GetDynstr(ElfW(Word) offset) const {\n  ABSL_RAW_CHECK(offset < strsize_, \"offset out of range\");\n  return dynstr_ + offset;\n}\n\nconst void *ElfMemImage::GetSymAddr(const ElfW(Sym) *sym) const {\n  if (sym->st_shndx == SHN_UNDEF || sym->st_shndx >= SHN_LORESERVE) {\n    // Symbol corresponds to \"special\" (e.g. SHN_ABS) section.\n    return reinterpret_cast<const void *>(sym->st_value);\n  }\n  ABSL_RAW_CHECK(link_base_ < sym->st_value, \"symbol out of range\");\n  return GetTableElement<char>(ehdr_, 0, 1, sym->st_value - link_base_);\n}\n\nconst ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {\n  ABSL_RAW_CHECK(0 <= index && static_cast<size_t>(index) <= verdefnum_,\n                 \"index out of range\");\n  const ElfW(Verdef) *version_definition = verdef_;\n  while (version_definition->vd_ndx < index && version_definition->vd_next) {\n    const char *const version_definition_as_char =\n        reinterpret_cast<const char *>(version_definition);\n    version_definition =\n        reinterpret_cast<const ElfW(Verdef) *>(version_definition_as_char +\n                                               version_definition->vd_next);\n  }\n  return version_definition->vd_ndx == index ? version_definition : nullptr;\n}\n\nconst ElfW(Verdaux) *ElfMemImage::GetVerdefAux(\n    const ElfW(Verdef) *verdef) const {\n  return reinterpret_cast<const ElfW(Verdaux) *>(verdef+1);\n}\n\nconst char *ElfMemImage::GetVerstr(ElfW(Word) offset) const {\n  ABSL_RAW_CHECK(offset < strsize_, \"offset out of range\");\n  return dynstr_ + offset;\n}\n\nvoid ElfMemImage::Init(const void *base) {\n  ehdr_      = nullptr;\n  dynsym_    = nullptr;\n  dynstr_    = nullptr;\n  versym_    = nullptr;\n  verdef_    = nullptr;\n  hash_      = nullptr;\n  strsize_   = 0;\n  verdefnum_ = 0;\n  // Sentinel: PT_LOAD .p_vaddr can't possibly be this.\n  link_base_ = ~ElfW(Addr){0};  // NOLINT(readability/braces)\n  if (!base) {\n    return;\n  }\n  const char *const base_as_char = reinterpret_cast<const char *>(base);\n  if (base_as_char[EI_MAG0] != ELFMAG0 || base_as_char[EI_MAG1] != ELFMAG1 ||\n      base_as_char[EI_MAG2] != ELFMAG2 || base_as_char[EI_MAG3] != ELFMAG3) {\n    assert(false);\n    return;\n  }\n  int elf_class = base_as_char[EI_CLASS];\n  if (elf_class != kElfClass) {\n    assert(false);\n    return;\n  }\n  switch (base_as_char[EI_DATA]) {\n    case ELFDATA2LSB: {\n#ifndef ABSL_IS_LITTLE_ENDIAN\n      assert(false);\n      return;\n#endif\n      break;\n    }\n    case ELFDATA2MSB: {\n#ifndef ABSL_IS_BIG_ENDIAN\n      assert(false);\n      return;\n#endif\n      break;\n    }\n    default: {\n      assert(false);\n      return;\n    }\n  }\n\n  ehdr_ = reinterpret_cast<const ElfW(Ehdr) *>(base);\n  const ElfW(Phdr) *dynamic_program_header = nullptr;\n  for (int i = 0; i < ehdr_->e_phnum; ++i) {\n    const ElfW(Phdr) *const program_header = GetPhdr(i);\n    switch (program_header->p_type) {\n      case PT_LOAD:\n        if (!~link_base_) {\n          link_base_ = program_header->p_vaddr;\n        }\n        break;\n      case PT_DYNAMIC:\n        dynamic_program_header = program_header;\n        break;\n    }\n  }\n  if (!~link_base_ || !dynamic_program_header) {\n    assert(false);\n    // Mark this image as not present. Can not recur infinitely.\n    Init(nullptr);\n    return;\n  }\n  ptrdiff_t relocation =\n      base_as_char - reinterpret_cast<const char *>(link_base_);\n  ElfW(Dyn)* dynamic_entry = reinterpret_cast<ElfW(Dyn)*>(\n      static_cast<intptr_t>(dynamic_program_header->p_vaddr) + relocation);\n  for (; dynamic_entry->d_tag != DT_NULL; ++dynamic_entry) {\n    const auto value =\n        static_cast<intptr_t>(dynamic_entry->d_un.d_val) + relocation;\n    switch (dynamic_entry->d_tag) {\n      case DT_HASH:\n        hash_ = reinterpret_cast<ElfW(Word) *>(value);\n        break;\n      case DT_SYMTAB:\n        dynsym_ = reinterpret_cast<ElfW(Sym) *>(value);\n        break;\n      case DT_STRTAB:\n        dynstr_ = reinterpret_cast<const char *>(value);\n        break;\n      case DT_VERSYM:\n        versym_ = reinterpret_cast<ElfW(Versym) *>(value);\n        break;\n      case DT_VERDEF:\n        verdef_ = reinterpret_cast<ElfW(Verdef) *>(value);\n        break;\n      case DT_VERDEFNUM:\n        verdefnum_ = static_cast<size_t>(dynamic_entry->d_un.d_val);\n        break;\n      case DT_STRSZ:\n        strsize_ = static_cast<size_t>(dynamic_entry->d_un.d_val);\n        break;\n      default:\n        // Unrecognized entries explicitly ignored.\n        break;\n    }\n  }\n  if (!hash_ || !dynsym_ || !dynstr_ || !versym_ ||\n      !verdef_ || !verdefnum_ || !strsize_) {\n    assert(false);  // invalid VDSO\n    // Mark this image as not present. Can not recur infinitely.\n    Init(nullptr);\n    return;\n  }\n}\n\nbool ElfMemImage::LookupSymbol(const char *name,\n                               const char *version,\n                               int type,\n                               SymbolInfo *info_out) const {\n  for (const SymbolInfo& info : *this) {\n    if (strcmp(info.name, name) == 0 && strcmp(info.version, version) == 0 &&\n        ElfType(info.symbol) == type) {\n      if (info_out) {\n        *info_out = info;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nbool ElfMemImage::LookupSymbolByAddress(const void *address,\n                                        SymbolInfo *info_out) const {\n  for (const SymbolInfo& info : *this) {\n    const char *const symbol_start =\n        reinterpret_cast<const char *>(info.address);\n    const char *const symbol_end = symbol_start + info.symbol->st_size;\n    if (symbol_start <= address && address < symbol_end) {\n      if (info_out) {\n        // Client wants to know details for that symbol (the usual case).\n        if (ElfBind(info.symbol) == STB_GLOBAL) {\n          // Strong symbol; just return it.\n          *info_out = info;\n          return true;\n        } else {\n          // Weak or local. Record it, but keep looking for a strong one.\n          *info_out = info;\n        }\n      } else {\n        // Client only cares if there is an overlapping symbol.\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)\n    : index_(index), image_(image) {\n}\n\nconst ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {\n  return &info_;\n}\n\nconst ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {\n  return info_;\n}\n\nbool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {\n  return this->image_ == rhs.image_ && this->index_ == rhs.index_;\n}\n\nbool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {\n  return !(*this == rhs);\n}\n\nElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {\n  this->Update(1);\n  return *this;\n}\n\nElfMemImage::SymbolIterator ElfMemImage::begin() const {\n  SymbolIterator it(this, 0);\n  it.Update(0);\n  return it;\n}\n\nElfMemImage::SymbolIterator ElfMemImage::end() const {\n  return SymbolIterator(this, GetNumSymbols());\n}\n\nvoid ElfMemImage::SymbolIterator::Update(int increment) {\n  const ElfMemImage *image = reinterpret_cast<const ElfMemImage *>(image_);\n  ABSL_RAW_CHECK(image->IsPresent() || increment == 0, \"\");\n  if (!image->IsPresent()) {\n    return;\n  }\n  index_ += increment;\n  if (index_ >= image->GetNumSymbols()) {\n    index_ = image->GetNumSymbols();\n    return;\n  }\n  const ElfW(Sym)    *symbol = image->GetDynsym(index_);\n  const ElfW(Versym) *version_symbol = image->GetVersym(index_);\n  ABSL_RAW_CHECK(symbol && version_symbol, \"\");\n  const char *const symbol_name = image->GetDynstr(symbol->st_name);\n#if defined(__NetBSD__)\n  const int version_index = version_symbol->vs_vers & VERSYM_VERSION;\n#else\n  const ElfW(Versym) version_index = version_symbol[0] & VERSYM_VERSION;\n#endif\n  const ElfW(Verdef) *version_definition = nullptr;\n  const char *version_name = \"\";\n  if (symbol->st_shndx == SHN_UNDEF) {\n    // Undefined symbols reference DT_VERNEED, not DT_VERDEF, and\n    // version_index could well be greater than verdefnum_, so calling\n    // GetVerdef(version_index) may trigger assertion.\n  } else {\n    version_definition = image->GetVerdef(version_index);\n  }\n  if (version_definition) {\n    // I am expecting 1 or 2 auxiliary entries: 1 for the version itself,\n    // optional 2nd if the version has a parent.\n    ABSL_RAW_CHECK(\n        version_definition->vd_cnt == 1 || version_definition->vd_cnt == 2,\n        \"wrong number of entries\");\n    const ElfW(Verdaux) *version_aux = image->GetVerdefAux(version_definition);\n    version_name = image->GetVerstr(version_aux->vda_name);\n  }\n  info_.name    = symbol_name;\n  info_.version = version_name;\n  info_.address = image->GetSymAddr(symbol);\n  info_.symbol  = symbol;\n}\n\n}  // namespace debugging_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02590",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/elf_mem_image.cc",
  "source_line": 41,
  "validation_status": "validated"
}