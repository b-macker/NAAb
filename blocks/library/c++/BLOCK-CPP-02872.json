{
  "code": "{\n\ntemplate <int base>\nstrings_internal::ParsedFloat ParseFloat(const char* begin, const char* end,\n                                         chars_format format_flags) {\n  strings_internal::ParsedFloat result;\n\n  // Exit early if we're given an empty range.\n  if (begin == end) return result;\n\n  // Handle the infinity and NaN cases.\n  if (ParseInfinityOrNan(begin, end, &result)) {\n    return result;\n  }\n\n  const char* const mantissa_begin = begin;\n  while (begin < end && *begin == '0') {\n    ++begin;  // skip leading zeros\n  }\n  uint64_t mantissa = 0;\n\n  int exponent_adjustment = 0;\n  bool mantissa_is_inexact = false;\n  int pre_decimal_digits = ConsumeDigits<base>(\n      begin, end, MantissaDigitsMax<base>(), &mantissa, &mantissa_is_inexact);\n  begin += pre_decimal_digits;\n  int digits_left;\n  if (pre_decimal_digits >= DigitLimit<base>()) {\n    // refuse to parse pathological inputs\n    return result;\n  } else if (pre_decimal_digits > MantissaDigitsMax<base>()) {\n    // We dropped some non-fraction digits on the floor.  Adjust our exponent\n    // to compensate.\n    exponent_adjustment =\n        static_cast<int>(pre_decimal_digits - MantissaDigitsMax<base>());\n    digits_left = 0;\n  } else {\n    digits_left =\n        static_cast<int>(MantissaDigitsMax<base>() - pre_decimal_digits);\n  }\n  if (begin < end && *begin == '.') {\n    ++begin;\n    if (mantissa == 0) {\n      // If we haven't seen any nonzero digits yet, keep skipping zeros.  We\n      // have to adjust the exponent to reflect the changed place value.\n      const char* begin_zeros = begin;\n      while (begin < end && *begin == '0') {\n        ++begin;\n      }\n      int zeros_skipped = static_cast<int>(begin - begin_zeros);\n      if (zeros_skipped >= DigitLimit<base>()) {\n        // refuse to parse pathological inputs\n        return result;\n      }\n      exponent_adjustment -= static_cast<int>(zeros_skipped);\n    }\n    int post_decimal_digits = ConsumeDigits<base>(\n        begin, end, digits_left, &mantissa, &mantissa_is_inexact);\n    begin += post_decimal_digits;\n\n    // Since `mantissa` is an integer, each significant digit we read after\n    // the decimal point requires an adjustment to the exponent. \"1.23e0\" will\n    // be stored as `mantissa` == 123 and `exponent` == -2 (that is,\n    // \"123e-2\").\n    if (post_decimal_digits >= DigitLimit<base>()) {\n      // refuse to parse pathological inputs\n      return result;\n    } else if (post_decimal_digits > digits_left) {\n      exponent_adjustment -= digits_left;\n    } else {\n      exponent_adjustment -= post_decimal_digits;\n    }\n  }\n  // If we've found no mantissa whatsoever, this isn't a number.\n  if (mantissa_begin == begin) {\n    return result;\n  }\n  // A bare \".\" doesn't count as a mantissa either.\n  if (begin - mantissa_begin == 1 && *mantissa_begin == '.') {\n    return result;\n  }\n\n  if (mantissa_is_inexact) {\n    // We dropped significant digits on the floor.  Handle this appropriately.\n    if (base == 10) {\n      // If we truncated significant decimal digits, store the full range of the\n      // mantissa for future big integer math for exact rounding.\n      result.subrange_begin = mantissa_begin;\n      result.subrange_end = begin;\n    } else if (base == 16) {\n      // If we truncated hex digits, reflect this fact by setting the low\n      // (\"sticky\") bit.  This allows for correct rounding in all cases.\n      mantissa |= 1;\n    }\n  }\n  result.mantissa = mantissa;\n\n  const char* const exponent_begin = begin;\n  result.literal_exponent = 0;\n  bool found_exponent = false;\n  if (AllowExponent(format_flags) && begin < end &&\n      IsExponentCharacter<base>(*begin)) {\n    bool negative_exponent = false;\n    ++begin;\n    if (begin < end && *begin == '-') {\n      negative_exponent = true;\n      ++begin;\n    } else if (begin < end && *begin == '+') {\n      ++begin;\n    }\n    const char* const exponent_digits_begin = begin;\n    // Exponent is always expressed in decimal, even for hexadecimal floats.\n    begin += ConsumeDigits<10>(begin, end, kDecimalExponentDigitsMax,\n                               &result.literal_exponent, nullptr);\n    if (begin == exponent_digits_begin) {\n      // there were no digits where we expected an exponent.  We failed to read\n      // an exponent and should not consume the 'e' after all.  Rewind 'begin'.\n      found_exponent = false;\n      begin = exponent_begin;\n    } else {\n      found_exponent = true;\n      if (negative_exponent) {\n        result.literal_exponent = -result.literal_exponent;\n      }\n    }\n  }\n\n  if (!found_exponent && RequireExponent(format_flags)) {\n    // Provided flags required an exponent, but none was found.  This results\n    // in a failure to scan.\n    return result;\n  }\n\n  // Success!\n  result.type = strings_internal::FloatType::kNumber;\n  if (result.mantissa > 0) {\n    result.exponent = result.literal_exponent +\n                      (DigitMagnitude<base>() * exponent_adjustment);\n  } else {\n    result.exponent = 0;\n  }\n  result.end = begin;\n  return result;\n}\n\ntemplate ParsedFloat ParseFloat<10>(const char* begin, const char* end,\n                                    chars_format format_flags);\ntemplate ParsedFloat ParseFloat<16>(const char* begin, const char* end,\n                                    chars_format format_flags);\n\n}",
  "id": "BLOCK-CPP-02872",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/charconv_parse.cc",
  "source_line": 352,
  "validation_status": "validated"
}