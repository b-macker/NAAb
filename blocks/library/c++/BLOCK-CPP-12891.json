{
  "code": "{\n  friend class ASTStmtReader;\n\n  SourceLocation LBraceLoc, EndLoc;\n  StringRef AsmStr;\n\n  unsigned NumAsmToks = 0;\n\n  Token *AsmToks = nullptr;\n  StringRef *Constraints = nullptr;\n  StringRef *Clobbers = nullptr;\n\npublic:\n  MSAsmStmt(const ASTContext &C, SourceLocation asmloc,\n            SourceLocation lbraceloc, bool issimple, bool isvolatile,\n            ArrayRef<Token> asmtoks, unsigned numoutputs, unsigned numinputs,\n            ArrayRef<StringRef> constraints,\n            ArrayRef<Expr*> exprs, StringRef asmstr,\n            ArrayRef<StringRef> clobbers, SourceLocation endloc);\n\n  /// Build an empty MS-style inline-assembly statement.\n  explicit MSAsmStmt(EmptyShell Empty) : AsmStmt(MSAsmStmtClass, Empty) {}\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation L) { LBraceLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  bool hasBraces() const { return LBraceLoc.isValid(); }\n\n  unsigned getNumAsmToks() { return NumAsmToks; }\n  Token *getAsmToks() { return AsmToks; }\n\n  //===--- Asm String Analysis ---===//\n  StringRef getAsmString() const { return AsmStr; }\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  StringRef getOutputConstraint(unsigned i) const {\n    assert(i < NumOutputs);\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  StringRef getInputConstraint(unsigned i) const {\n    assert(i < NumInputs);\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Other ---===//\n\n  ArrayRef<StringRef> getAllConstraints() const {\n    return llvm::ArrayRef(Constraints, NumInputs + NumOutputs);\n  }\n\n  ArrayRef<StringRef> getClobbers() const {\n    return llvm::ArrayRef(Clobbers, NumClobbers);\n  }\n\n  ArrayRef<Expr*> getAllExprs() const {\n    return llvm::ArrayRef(reinterpret_cast<Expr **>(Exprs),\n                          NumInputs + NumOutputs);\n  }\n\n  StringRef getClobber(unsigned i) const { return getClobbers()[i]; }\n\nprivate:\n  void initialize(const ASTContext &C, StringRef AsmString,\n                  ArrayRef<Token> AsmToks, ArrayRef<StringRef> Constraints,\n                  ArrayRef<Expr*> Exprs, ArrayRef<StringRef> Clobbers);\n\npublic:\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSAsmStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n}",
  "id": "BLOCK-CPP-12891",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Stmt.h",
  "source_line": 3303,
  "validation_status": "validated"
}