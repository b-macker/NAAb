{
  "code": "#include <cstdint>\n#include <memory>\n#include \"absl/base/config.h\"\n#include \"absl/crc/crc32c.h\"\n#include \"absl/crc/internal/crc_memcpy.h\"\n\nusing namespace absl;\nusing namespace crc_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02474_execute() {\n    {\n\nabsl::crc32c_t FallbackCrcMemcpyEngine::Compute(void* __restrict dst,\n                                                const void* __restrict src,\n                                                std::size_t length,\n                                                crc32c_t initial_crc) const {\n  constexpr size_t kBlockSize = 8192;\n  absl::crc32c_t crc = initial_crc;\n\n  const char* src_bytes = reinterpret_cast<const char*>(src);\n  char* dst_bytes = reinterpret_cast<char*>(dst);\n\n  // Copy + CRC loop - run 8k chunks until we are out of full chunks.  CRC\n  // then copy was found to be slightly more efficient in our test cases.\n  std::size_t offset = 0;\n  for (; offset + kBlockSize < length; offset += kBlockSize) {\n    crc = absl::ExtendCrc32c(crc,\n                             absl::string_view(src_bytes + offset, kBlockSize));\n    memcpy(dst_bytes + offset, src_bytes + offset, kBlockSize);\n  }\n\n  // Save some work if length is 0.\n  if (offset < length) {\n    std::size_t final_copy_size = length - offset;\n    crc = absl::ExtendCrc32c(\n        crc, absl::string_view(src_bytes + offset, final_copy_size));\n    memcpy(dst_bytes + offset, src_bytes + offset, final_copy_size);\n  }\n\n  return crc;\n}\n\n// Compile the following only if we don't have\n#if !defined(ABSL_INTERNAL_HAVE_X86_64_ACCELERATED_CRC_MEMCPY_ENGINE) && \\\n    !defined(ABSL_INTERNAL_HAVE_ARM_ACCELERATED_CRC_MEMCPY_ENGINE)\n\nCrcMemcpy::ArchSpecificEngines CrcMemcpy::GetArchSpecificEngines() {\n  CrcMemcpy::ArchSpecificEngines engines;\n  engines.temporal = new FallbackCrcMemcpyEngine();\n  engines.non_temporal = new FallbackCrcMemcpyEngine();\n  return engines;\n}\n\nstd::unique_ptr<CrcMemcpyEngine> CrcMemcpy::GetTestEngine(int /*vector*/,\n                                                          int /*integer*/) {\n  return std::make_unique<FallbackCrcMemcpyEngine>();\n}\n\n#endif  // !ABSL_INTERNAL_HAVE_X86_64_ACCELERATED_CRC_MEMCPY_ENGINE &&\n        // !ABSL_INTERNAL_HAVE_ARM_ACCELERATED_CRC_MEMCPY_ENGINE\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02474",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc_memcpy_fallback.cc",
  "source_line": 24,
  "validation_status": "validated"
}