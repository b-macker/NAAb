{
  "code": "#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-19200_execute() {\n    {\n  friend class Preprocessor;\n\n  /// The macro we are expanding from. This is null if expanding a token stream.\n  MacroInfo *Macro = nullptr;\n\n  /// The actual arguments specified for a function-like macro, or null. The\n  /// TokenLexer owns the pointed-to object.\n  MacroArgs *ActualArgs = nullptr;\n\n  /// The current preprocessor object we are expanding for.\n  Preprocessor &PP;\n\n  /// This is the pointer to an array of tokens that the macro is\n  /// defined to, with arguments expanded for function-like macros.  If this is\n  /// a token stream, these are the tokens we are returning.  This points into\n  /// the macro definition we are lexing from, a cache buffer that is owned by\n  /// the preprocessor, or some other buffer that we may or may not own\n  /// (depending on OwnsTokens).\n  /// Note that if it points into Preprocessor's cache buffer, the Preprocessor\n  /// may update the pointer as needed.\n  const Token *Tokens;\n\n  /// This is the length of the Tokens array.\n  unsigned NumTokens;\n\n  /// This is the index of the next token that Lex will return.\n  unsigned CurTokenIdx;\n\n  /// The source location range where this macro was expanded.\n  SourceLocation ExpandLocStart, ExpandLocEnd;\n\n  /// Source location pointing at the source location entry chunk that\n  /// was reserved for the current macro expansion.\n  SourceLocation MacroExpansionStart;\n\n  /// The offset of the macro expansion in the\n  /// \"source location address space\".\n  unsigned MacroStartSLocOffset;\n\n  /// Location of the macro definition.\n  SourceLocation MacroDefStart;\n\n  /// Length of the macro definition.\n  unsigned MacroDefLength;\n\n  /// Lexical information about the expansion point of the macro: the identifier\n  /// that the macro expanded from had these properties.\n  bool AtStartOfLine : 1;\n  bool HasLeadingSpace : 1;\n\n  // When this is true, the next token appended to the\n  // output list during function argument expansion will get a leading space,\n  // regardless of whether it had one to begin with or not. This is used for\n  // placemarker support. If still true after function argument expansion, the\n  // leading space will be applied to the first token following the macro\n  // expansion.\n  bool NextTokGetsSpace : 1;\n\n  /// This is true if this TokenLexer allocated the Tokens\n  /// array, and thus needs to free it when destroyed.  For simple object-like\n  /// macros (for example) we just point into the token buffer of the macro\n  /// definition, we don't make a copy of it.\n  bool OwnsTokens : 1;\n\n  /// This is true when tokens lexed from the TokenLexer\n  /// should not be subject to further macro expansion.\n  bool DisableMacroExpansion : 1;\n\n  /// When true, the produced tokens have Token::IsReinjected flag set.\n  /// See the flag documentation for details.\n  bool IsReinject : 1;\n\npublic:\n  /// Create a TokenLexer for the specified macro with the specified actual\n  /// arguments.  Note that this ctor takes ownership of the ActualArgs pointer.\n  /// ILEnd specifies the location of the ')' for a function-like macro or the\n  /// identifier for an object-like macro.\n  TokenLexer(Token &Tok, SourceLocation ILEnd, MacroInfo *MI,\n             MacroArgs *ActualArgs, Preprocessor &pp)\n      : PP(pp), OwnsTokens(false) {\n    Init(Tok, ILEnd, MI, ActualArgs);\n  }\n\n  /// Create a TokenLexer for the specified token stream.  If 'OwnsTokens' is\n  /// specified, this takes ownership of the tokens and delete[]'s them when\n  /// the token lexer is empty.\n  TokenLexer(const Token *TokArray, unsigned NumToks, bool DisableExpansion,\n             bool ownsTokens, bool isReinject, Preprocessor &pp)\n      : PP(pp), OwnsTokens(false) {\n    Init(TokArray, NumToks, DisableExpansion, ownsTokens, isReinject);\n  }\n\n  TokenLexer(const TokenLexer &) = delete;\n  TokenLexer &operator=(const TokenLexer &) = delete;\n  ~TokenLexer() { destroy(); }\n\n  /// Initialize this TokenLexer to expand from the specified macro\n  /// with the specified argument information.  Note that this ctor takes\n  /// ownership of the ActualArgs pointer.  ILEnd specifies the location of the\n  /// ')' for a function-like macro or the identifier for an object-like macro.\n  void Init(Token &Tok, SourceLocation ELEnd, MacroInfo *MI,\n            MacroArgs *Actuals);\n\n  /// Initialize this TokenLexer with the specified token stream.\n  /// This does not take ownership of the specified token vector.\n  ///\n  /// DisableExpansion is true when macro expansion of tokens lexed from this\n  /// stream should be disabled.\n  void Init(const Token *TokArray, unsigned NumToks, bool DisableMacroExpansion,\n            bool OwnsTokens, bool IsReinject);\n\n  /// If the next token lexed will pop this macro off the\n  /// expansion stack, return 2.  If the next unexpanded token is a '(', return\n  /// 1, otherwise return 0.\n  unsigned isNextTokenLParen() const;\n\n  /// Lex and return a token from this macro stream.\n  bool Lex(Token &Tok);\n\n  /// isParsingPreprocessorDirective - Return true if we are in the middle of a\n  /// preprocessor directive.\n  bool isParsingPreprocessorDirective() const;\n\nprivate:\n  void destroy();\n\n  /// Return true if the next lex call will pop this macro off the include\n  /// stack.\n  bool isAtEnd() const {\n    return CurTokenIdx == NumTokens;\n  }\n\n  /// Concatenates the next (sub-)sequence of \\p Tokens separated by '##'\n  /// starting with LHSTok - stopping when we encounter a token that is neither\n  /// '##' nor preceded by '##'.  Places the result back into \\p LHSTok and sets\n  /// \\p CurIdx to point to the token following the last one that was pasted.\n  ///\n  /// Also performs the MSVC extension wide-literal token pasting involved with:\n  ///       \\code L #macro-arg. \\endcode\n  ///\n  /// \\param[in,out] LHSTok - Contains the token to the left of '##' in \\p\n  /// Tokens upon entry and will contain the resulting concatenated Token upon\n  /// exit.\n  ///\n  /// \\param[in] TokenStream - The stream of Tokens we are lexing from.\n  ///\n  /// \\param[in,out] CurIdx - Upon entry, \\pTokens[\\pCurIdx] must equal '##'\n  /// (with the exception of the MSVC extension mentioned above).  Upon exit, it\n  /// is set to the index of the token following the last token that was\n  /// concatenated together.\n  ///\n  /// \\returns If this returns true, the caller should immediately return the\n  /// token.\n  bool pasteTokens(Token &LHSTok, ArrayRef<Token> TokenStream,\n                   unsigned int &CurIdx);\n\n  /// Calls pasteTokens above, passing in the '*this' object's Tokens and\n  /// CurTokenIdx data members.\n  bool pasteTokens(Token &Tok);\n\n\n  /// Takes the tail sequence of tokens within ReplacementToks that represent\n  /// the just expanded __VA_OPT__ tokens (possibly zero tokens) and transforms\n  /// them into a string.  \\p VCtx is used to determine which token represents\n  /// the first __VA_OPT__ replacement token.\n  ///\n  /// \\param[in,out] ResultToks - Contains the current Replacement Tokens\n  /// (prior to rescanning and token pasting), the tail end of which represents\n  /// the tokens just expanded through __VA_OPT__ processing.  These (sub)\n  /// sequence of tokens are folded into one stringified token.\n  ///\n  /// \\param[in] VCtx - contains relevant contextual information about the\n  /// state of the tokens around and including the __VA_OPT__ token, necessary\n  /// for stringification.\n  void stringifyVAOPTContents(SmallVectorImpl<Token> &ResultToks,\n                              const VAOptExpansionContext &VCtx,\n                              SourceLocation VAOPTClosingParenLoc);\n\n  /// Expand the arguments of a function-like macro so that we can quickly\n  /// return preexpanded tokens from Tokens.\n  void ExpandFunctionArguments();\n\n  /// In microsoft compatibility mode, /##/ pastes\n  /// together to form a comment that comments out everything in the current\n  /// macro, other active macros, and anything left on the current physical\n  /// source line of the expanded buffer.  Handle this by returning the\n  /// first token on the next line.\n  void HandleMicrosoftCommentPaste(Token &Tok, SourceLocation OpLoc);\n\n  /// If \\p loc is a FileID and points inside the current macro\n  /// definition, returns the appropriate source location pointing at the\n  /// macro expansion source location entry.\n  SourceLocation getExpansionLocForMacroDefLoc(SourceLocation loc) const;\n\n  /// Creates SLocEntries and updates the locations of macro argument\n  /// tokens to their new expanded locations.\n  ///\n  /// \\param ArgIdSpellLoc the location of the macro argument id inside the\n  /// macro definition.\n  void updateLocForMacroArgTokens(SourceLocation ArgIdSpellLoc,\n                                  Token *begin_tokens, Token *end_tokens);\n\n  /// Remove comma ahead of __VA_ARGS__, if present, according to compiler\n  /// dialect settings.  Returns true if the comma is removed.\n  bool MaybeRemoveCommaBeforeVaArgs(SmallVectorImpl<Token> &ResultToks,\n                                    bool HasPasteOperator,\n                                    MacroInfo *Macro, unsigned MacroArgNo,\n                                    Preprocessor &PP);\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-19200",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/TokenLexer.h",
  "source_line": 30,
  "validation_status": "validated"
}