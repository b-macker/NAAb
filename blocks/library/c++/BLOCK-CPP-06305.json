{
  "code": "{\n private:\n  enum { kInlinedSpace = 8 };\n\n  using VoidPtr = str_format_internal::VoidPtr;\n\n  union Data {\n    const void* ptr;\n    const volatile void* volatile_ptr;\n    char buf[kInlinedSpace];\n  };\n\n  using Dispatcher = bool (*)(Data, FormatConversionSpecImpl, void* out);\n\n  template <typename T>\n  struct store_by_value\n      : std::integral_constant<bool, (sizeof(T) <= kInlinedSpace) &&\n                                         (std::is_integral<T>::value ||\n                                          std::is_floating_point<T>::value ||\n                                          std::is_pointer<T>::value ||\n                                          std::is_same<VoidPtr, T>::value)> {};\n\n  enum StoragePolicy { ByPointer, ByVolatilePointer, ByValue };\n  template <typename T>\n  struct storage_policy\n      : std::integral_constant<StoragePolicy,\n                               (std::is_volatile<T>::value\n                                    ? ByVolatilePointer\n                                    : (store_by_value<T>::value ? ByValue\n                                                                : ByPointer))> {\n  };\n\n  // To reduce the number of vtables we will decay values before hand.\n  // Anything with a user-defined Convert will get its own vtable.\n  // For everything else:\n  //   - Decay char* and char arrays into `const char*`\n  //   - Decay wchar_t* and wchar_t arrays into `const wchar_t*`\n  //   - Decay any other pointer to `const void*`\n  //   - Decay all enums to the integral promotion of their underlying type.\n  //   - Decay function pointers to void*.\n  template <typename T, typename = void>\n  struct DecayType {\n    static constexpr bool kHasUserDefined =\n        str_format_internal::HasUserDefinedConvert<T>::value ||\n        HasAbslStringify<T>::value;\n    using type = typename std::conditional<\n        !kHasUserDefined && std::is_convertible<T, const char*>::value,\n        const char*,\n        typename std::conditional<\n            !kHasUserDefined && std::is_convertible<T, const wchar_t*>::value,\n            const wchar_t*,\n            typename std::conditional<\n                !kHasUserDefined && std::is_convertible<T, VoidPtr>::value,\n                VoidPtr,\n                const T&>::type>::type>::type;\n  };\n  template <typename T>\n  struct DecayType<\n      T, typename std::enable_if<\n             !str_format_internal::HasUserDefinedConvert<T>::value &&\n             !HasAbslStringify<T>::value && std::is_enum<T>::value>::type> {\n    using type = decltype(+typename std::underlying_type<T>::type());\n  };\n\n public:\n  template <typename T>\n  explicit FormatArgImpl(const T& value) {\n    using D = typename DecayType<T>::type;\n    static_assert(\n        std::is_same<D, const T&>::value || storage_policy<D>::value == ByValue,\n        \"Decayed types must be stored by value\");\n    Init(static_cast<D>(value));\n  }\n\n private:\n  friend struct str_format_internal::FormatArgImplFriend;\n  template <typename T, StoragePolicy = storage_policy<T>::value>\n  struct Manager;\n\n  template <typename T>\n  struct Manager<T, ByPointer> {\n    static Data SetValue(const T& value) {\n      Data data;\n      data.ptr = std::addressof(value);\n      return data;\n    }\n\n    static const T& Value(Data arg) { return *static_cast<const T*>(arg.ptr); }\n  };\n\n  template <typename T>\n  struct Manager<T, ByVolatilePointer> {\n    static Data SetValue(const T& value) {\n      Data data;\n      data.volatile_ptr = &value;\n      return data;\n    }\n\n    static const T& Value(Data arg) {\n      return *static_cast<const T*>(arg.volatile_ptr);\n    }\n  };\n\n  template <typename T>\n  struct Manager<T, ByValue> {\n    static Data SetValue(const T& value) {\n      Data data;\n      memcpy(data.buf, &value, sizeof(value));\n      return data;\n    }\n\n    static T Value(Data arg) {\n      T value;\n      memcpy(&value, arg.buf, sizeof(T));\n      return value;\n    }\n  };\n\n  template <typename T>\n  void Init(const T& value) {\n    data_ = Manager<T>::SetValue(value);\n    dispatcher_ = &Dispatch<T>;\n  }\n\n  template <typename T>\n  static int ToIntVal(const T& val) {\n    using CommonType = typename std::conditional<std::is_signed<T>::value,\n                                                 int64_t, uint64_t>::type;\n    if (static_cast<CommonType>(val) >\n        static_cast<CommonType>((std::numeric_limits<int>::max)())) {\n      return (std::numeric_limits<int>::max)();\n    } else if (std::is_signed<T>::value &&\n               static_cast<CommonType>(val) <\n                   static_cast<CommonType>((std::numeric_limits<int>::min)())) {\n      return (std::numeric_limits<int>::min)();\n    }\n    return static_cast<int>(val);\n  }\n\n  template <typename T>\n  static bool ToInt(Data arg, int* out, std::true_type /* is_integral */,\n                    std::false_type) {\n    *out = ToIntVal(Manager<T>::Value(arg));\n    return true;\n  }\n\n  template <typename T>\n  static bool ToInt(Data arg, int* out, std::false_type,\n                    std::true_type /* is_enum */) {\n    *out = ToIntVal(static_cast<typename std::underlying_type<T>::type>(\n        Manager<T>::Value(arg)));\n    return true;\n  }\n\n  template <typename T>\n  static bool ToInt(Data, int*, std::false_type, std::false_type) {\n    return false;\n  }\n\n  template <typename T>\n  static bool Dispatch(Data arg, FormatConversionSpecImpl spec, void* out) {\n    // A `none` conv indicates that we want the `int` conversion.\n    if (ABSL_PREDICT_FALSE(spec.conversion_char() ==\n                           FormatConversionCharInternal::kNone)) {\n      return ToInt<T>(arg, static_cast<int*>(out), std::is_integral<T>(),\n                      std::is_enum<T>());\n    }\n    if (ABSL_PREDICT_FALSE(!Contains(ArgumentToConv<T>(),\n                                     spec.conversion_char()))) {\n      return false;\n    }\n    return str_format_internal::FormatConvertImpl(\n               Manager<T>::Value(arg), spec,\n               static_cast<FormatSinkImpl*>(out))\n        .value;\n  }\n\n  Data data_;\n  Dispatcher dispatcher_;\n}",
  "id": "BLOCK-CPP-06305",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/arg.h",
  "source_line": 439,
  "validation_status": "validated"
}