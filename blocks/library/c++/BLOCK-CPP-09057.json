{
  "code": "{\n  /// Interface belonging to this category\n  ObjCInterfaceDecl *ClassInterface;\n\n  /// The type parameters associated with this category, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// referenced protocols in this category.\n  ObjCProtocolList ReferencedProtocols;\n\n  /// Next category belonging to this class.\n  /// FIXME: this should not be a singly-linked list.  Move storage elsewhere.\n  ObjCCategoryDecl *NextClassCategory = nullptr;\n\n  /// The location of the category name in this declaration.\n  SourceLocation CategoryNameLoc;\n\n  /// class extension may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  ObjCCategoryDecl(DeclContext *DC, SourceLocation AtLoc,\n                   SourceLocation ClassNameLoc, SourceLocation CategoryNameLoc,\n                   IdentifierInfo *Id, ObjCInterfaceDecl *IDecl,\n                   ObjCTypeParamList *typeParamList,\n                   SourceLocation IvarLBraceLoc = SourceLocation(),\n                   SourceLocation IvarRBraceLoc = SourceLocation());\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation AtLoc,\n                                  SourceLocation ClassNameLoc,\n                                  SourceLocation CategoryNameLoc,\n                                  IdentifierInfo *Id,\n                                  ObjCInterfaceDecl *IDecl,\n                                  ObjCTypeParamList *typeParamList,\n                                  SourceLocation IvarLBraceLoc=SourceLocation(),\n                                  SourceLocation IvarRBraceLoc=SourceLocation());\n  static ObjCCategoryDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n\n  /// Retrieve the type parameter list associated with this category or\n  /// extension.\n  ObjCTypeParamList *getTypeParamList() const { return TypeParamList; }\n\n  /// Set the type parameters of this category.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n\n  ObjCCategoryImplDecl *getImplementation() const;\n  void setImplementation(ObjCCategoryImplDecl *ImplD);\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    return ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    return ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const { return ReferencedProtocols.end(); }\n  unsigned protocol_size() const { return ReferencedProtocols.size(); }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    return ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    return ReferencedProtocols.loc_end();\n  }\n\n  ObjCCategoryDecl *getNextClassCategory() const { return NextClassCategory; }\n\n  /// Retrieve the pointer to the next stored category (or extension),\n  /// which may be hidden.\n  ObjCCategoryDecl *getNextClassCategoryRaw() const {\n    return NextClassCategory;\n  }\n\n  bool IsClassExtension() const { return getIdentifier() == nullptr; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n  void setCategoryNameLoc(SourceLocation Loc) { CategoryNameLoc = Loc; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategory; }\n}",
  "id": "BLOCK-CPP-09057",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclObjC.h",
  "source_line": 2312,
  "validation_status": "validated"
}