{
  "code": "{\n\ntemplate <typename RangeT, typename OutputIterator>\nOutputIterator copy(const RangeT& range, OutputIterator out) {\n  for (auto it = range.begin(), end = range.end(); it != end; ++it)\n    *out++ = *it;\n  return out;\n}\n\ntemplate <typename OutputIterator>\nOutputIterator copy(const char* str, OutputIterator out) {\n  while (*str) *out++ = *str++;\n  return out;\n}\n\ntemplate <typename OutputIterator>\nOutputIterator copy(char ch, OutputIterator out) {\n  *out++ = ch;\n  return out;\n}\n\ntemplate <typename OutputIterator>\nOutputIterator copy(wchar_t ch, OutputIterator out) {\n  *out++ = ch;\n  return out;\n}\n\n// Returns true if T has a std::string-like interface, like std::string_view.\ntemplate <typename T> class is_std_string_like {\n  template <typename U>\n  static auto check(U* p)\n      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());\n  template <typename> static void check(...);\n\n public:\n  static constexpr const bool value =\n      is_string<T>::value ||\n      std::is_convertible<T, std_string_view<char>>::value ||\n      !std::is_void<decltype(check<T>(nullptr))>::value;\n};\n\ntemplate <typename Char>\nstruct is_std_string_like<fmt::basic_string_view<Char>> : std::true_type {};\n\ntemplate <typename T> class is_map {\n  template <typename U> static auto check(U*) -> typename U::mapped_type;\n  template <typename> static void check(...);\n\n public:\n#ifdef FMT_FORMAT_MAP_AS_LIST\n  static constexpr const bool value = false;\n#else\n  static constexpr const bool value =\n      !std::is_void<decltype(check<T>(nullptr))>::value;\n#endif\n};\n\ntemplate <typename T> class is_set {\n  template <typename U> static auto check(U*) -> typename U::key_type;\n  template <typename> static void check(...);\n\n public:\n#ifdef FMT_FORMAT_SET_AS_LIST\n  static constexpr const bool value = false;\n#else\n  static constexpr const bool value =\n      !std::is_void<decltype(check<T>(nullptr))>::value && !is_map<T>::value;\n#endif\n};\n\ntemplate <typename... Ts> struct conditional_helper {};\n\ntemplate <typename T, typename _ = void> struct is_range_ : std::false_type {};\n\n#if !FMT_MSC_VERSION || FMT_MSC_VERSION > 1800\n\n#  define FMT_DECLTYPE_RETURN(val)  \\\n    ->decltype(val) { return val; } \\\n    static_assert(                  \\\n        true, \"\")  // This makes it so that a semicolon is required after the\n                   // macro, which helps clang-format handle the formatting.\n\n// C array overload\ntemplate <typename T, std::size_t N>\nauto range_begin(const T (&arr)[N]) -> const T* {\n  return arr;\n}\ntemplate <typename T, std::size_t N>\nauto range_end(const T (&arr)[N]) -> const T* {\n  return arr + N;\n}\n\ntemplate <typename T, typename Enable = void>\nstruct has_member_fn_begin_end_t : std::false_type {};\n\ntemplate <typename T>\nstruct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),\n                                           decltype(std::declval<T>().end())>>\n    : std::true_type {};\n\n// Member function overload\ntemplate <typename T>\nauto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());\ntemplate <typename T>\nauto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());\n\n// ADL overload. Only participates in overload resolution if member functions\n// are not found.\ntemplate <typename T>\nauto range_begin(T&& rng)\n    -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,\n                   decltype(begin(static_cast<T&&>(rng)))> {\n  return begin(static_cast<T&&>(rng));\n}\ntemplate <typename T>\nauto range_end(T&& rng) -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,\n                                       decltype(end(static_cast<T&&>(rng)))> {\n  return end(static_cast<T&&>(rng));\n}\n\ntemplate <typename T, typename Enable = void>\nstruct has_const_begin_end : std::false_type {};\ntemplate <typename T, typename Enable = void>\nstruct has_mutable_begin_end : std::false_type {};\n\ntemplate <typename T>\nstruct has_const_begin_end<\n    T,\n    void_t<\n        decltype(detail::range_begin(std::declval<const remove_cvref_t<T>&>())),\n        decltype(detail::range_end(std::declval<const remove_cvref_t<T>&>()))>>\n    : std::true_type {};\n\ntemplate <typename T>\nstruct has_mutable_begin_end<\n    T, void_t<decltype(detail::range_begin(std::declval<T>())),\n              decltype(detail::range_end(std::declval<T>())),\n              enable_if_t<std::is_copy_constructible<T>::value>>>\n    : std::true_type {};\n\ntemplate <typename T>\nstruct is_range_<T, void>\n    : std::integral_constant<bool, (has_const_begin_end<T>::value ||\n                                    has_mutable_begin_end<T>::value)> {};\n#  undef FMT_DECLTYPE_RETURN\n#endif\n\n// tuple_size and tuple_element check.\ntemplate <typename T> class is_tuple_like_ {\n  template <typename U>\n  static auto check(U* p) -> decltype(std::tuple_size<U>::value, int());\n  template <typename> static void check(...);\n\n public:\n  static constexpr const bool value =\n      !std::is_void<decltype(check<T>(nullptr))>::value;\n};\n\n// Check for integer_sequence\n#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VERSION >= 1900\ntemplate <typename T, T... N>\nusing integer_sequence = std::integer_sequence<T, N...>;\ntemplate <size_t... N> using index_sequence = std::index_sequence<N...>;\ntemplate <size_t N> using make_index_sequence = std::make_index_sequence<N>;\n#else\ntemplate <typename T, T... N> struct integer_sequence {\n  using value_type = T;\n\n  static FMT_CONSTEXPR size_t size() { return sizeof...(N); }\n};\n\ntemplate <size_t... N> using index_sequence = integer_sequence<size_t, N...>;\n\ntemplate <typename T, size_t N, T... Ns>\nstruct make_integer_sequence : make_integer_sequence<T, N - 1, N - 1, Ns...> {};\ntemplate <typename T, T... Ns>\nstruct make_integer_sequence<T, 0, Ns...> : integer_sequence<T, Ns...> {};\n\ntemplate <size_t N>\nusing make_index_sequence = make_integer_sequence<size_t, N>;\n#endif\n\ntemplate <typename T>\nusing tuple_index_sequence = make_index_sequence<std::tuple_size<T>::value>;\n\ntemplate <typename T, typename C, bool = is_tuple_like_<T>::value>\nclass is_tuple_formattable_ {\n public:\n  static constexpr const bool value = false;\n};\ntemplate <typename T, typename C> class is_tuple_formattable_<T, C, true> {\n  template <std::size_t... I>\n  static std::true_type check2(index_sequence<I...>,\n                               integer_sequence<bool, (I == I)...>);\n  static std::false_type check2(...);\n  template <std::size_t... I>\n  static decltype(check2(\n      index_sequence<I...>{},\n      integer_sequence<\n          bool, (is_formattable<typename std::tuple_element<I, T>::type,\n                                C>::value)...>{})) check(index_sequence<I...>);\n\n public:\n  static constexpr const bool value =\n      decltype(check(tuple_index_sequence<T>{}))::value;\n};\n\ntemplate <class Tuple, class F, size_t... Is>\nvoid for_each(index_sequence<Is...>, Tuple&& tup, F&& f) noexcept {\n  using std::get;\n  // using free function get<I>(T) now.\n  const int _[] = {0, ((void)f(get<Is>(tup)), 0)...};\n  (void)_;  // blocks warnings\n}\n\ntemplate <class T>\nFMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(\n    T const&) {\n  return {};\n}\n\ntemplate <class Tuple, class F> void for_each(Tuple&& tup, F&& f) {\n  const auto indexes = get_indexes(tup);\n  for_each(indexes, std::forward<Tuple>(tup), std::forward<F>(f));\n}\n\n#if FMT_MSC_VERSION && FMT_MSC_VERSION < 1920\n// Older MSVC doesn't get the reference type correctly for arrays.\ntemplate <typename R> struct range_reference_type_impl {\n  using type = decltype(*detail::range_begin(std::declval<R&>()));\n};\n\ntemplate <typename T, std::size_t N> struct range_reference_type_impl<T[N]> {\n  using type = T&;\n};\n\ntemplate <typename T>\nusing range_reference_type = typename range_reference_type_impl<T>::type;\n#else\ntemplate <typename Range>\nusing range_reference_type =\n    decltype(*detail::range_begin(std::declval<Range&>()));\n#endif\n\n// We don't use the Range's value_type for anything, but we do need the Range's\n// reference type, with cv-ref stripped.\ntemplate <typename Range>\nusing uncvref_type = remove_cvref_t<range_reference_type<Range>>;\n\ntemplate <typename Range>\nusing uncvref_first_type =\n    remove_cvref_t<decltype(std::declval<range_reference_type<Range>>().first)>;\n\ntemplate <typename Range>\nusing uncvref_second_type = remove_cvref_t<\n    decltype(std::declval<range_reference_type<Range>>().second)>;\n\ntemplate <typename OutputIt> OutputIt write_delimiter(OutputIt out) {\n  *out++ = ',';\n  *out++ = ' ';\n  return out;\n}\n\ntemplate <typename Char, typename OutputIt>\nauto write_range_entry(OutputIt out, basic_string_view<Char> str) -> OutputIt {\n  return write_escaped_string(out, str);\n}\n\ntemplate <typename Char, typename OutputIt, typename T,\n          FMT_ENABLE_IF(std::is_convertible<T, std_string_view<char>>::value)>\ninline auto write_range_entry(OutputIt out, const T& str) -> OutputIt {\n  auto sv = std_string_view<Char>(str);\n  return write_range_entry<Char>(out, basic_string_view<Char>(sv));\n}\n\ntemplate <typename Char, typename OutputIt, typename Arg,\n          FMT_ENABLE_IF(std::is_same<Arg, Char>::value)>\nOutputIt write_range_entry(OutputIt out, const Arg v) {\n  return write_escaped_char(out, v);\n}\n\ntemplate <\n    typename Char, typename OutputIt, typename Arg,\n    FMT_ENABLE_IF(!is_std_string_like<typename std::decay<Arg>::type>::value &&\n                  !std::is_same<Arg, Char>::value)>\nOutputIt write_range_entry(OutputIt out, const Arg& v) {\n  return write<Char>(out, v);\n}\n\n}",
  "id": "BLOCK-CPP-01586",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/ranges.h",
  "source_line": 23,
  "validation_status": "validated"
}