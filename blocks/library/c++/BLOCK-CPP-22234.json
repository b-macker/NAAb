{
  "code": "{\n\nnamespace ento {\n\nclass CheckerBase;\n\n} // namespace ento\n\n/// AnalysisConstraints - Set of available constraint models.\nenum AnalysisConstraints {\n#define ANALYSIS_CONSTRAINTS(NAME, CMDFLAG, DESC, CREATFN) NAME##Model,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumConstraints\n};\n\n/// AnalysisDiagClients - Set of available diagnostic clients for rendering\n///  analysis results.\nenum AnalysisDiagClients {\n#define ANALYSIS_DIAGNOSTICS(NAME, CMDFLAG, DESC, CREATFN) PD_##NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nPD_NONE,\nNUM_ANALYSIS_DIAG_CLIENTS\n};\n\n/// AnalysisPurgeModes - Set of available strategies for dead symbol removal.\nenum AnalysisPurgeMode {\n#define ANALYSIS_PURGE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumPurgeModes\n};\n\n/// AnalysisInlineFunctionSelection - Set of inlining function selection heuristics.\nenum AnalysisInliningMode {\n#define ANALYSIS_INLINING_MODE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumInliningModes\n};\n\n/// Describes the different kinds of C++ member functions which can be\n/// considered for inlining by the analyzer.\n///\n/// These options are cumulative; enabling one kind of member function will\n/// enable all kinds with lower enum values.\nenum CXXInlineableMemberKind {\n  // Uninitialized = 0,\n\n  /// A dummy mode in which no C++ inlining is enabled.\n  CIMK_None,\n\n  /// Refers to regular member function and operator calls.\n  CIMK_MemberFunctions,\n\n  /// Refers to constructors (implicit or explicit).\n  ///\n  /// Note that a constructor will not be inlined if the corresponding\n  /// destructor is non-trivial.\n  CIMK_Constructors,\n\n  /// Refers to destructors (implicit or explicit).\n  CIMK_Destructors\n};\n\n/// Describes the different modes of inter-procedural analysis.\nenum IPAKind {\n  /// Perform only intra-procedural analysis.\n  IPAK_None = 1,\n\n  /// Inline C functions and blocks when their definitions are available.\n  IPAK_BasicInlining = 2,\n\n  /// Inline callees(C, C++, ObjC) when their definitions are available.\n  IPAK_Inlining = 3,\n\n  /// Enable inlining of dynamically dispatched methods.\n  IPAK_DynamicDispatch = 4,\n\n  /// Enable inlining of dynamically dispatched methods, bifurcate paths when\n  /// exact type info is unavailable.\n  IPAK_DynamicDispatchBifurcate = 5\n};\n\nenum class ExplorationStrategyKind {\n  DFS,\n  BFS,\n  UnexploredFirst,\n  UnexploredFirstQueue,\n  UnexploredFirstLocationQueue,\n  BFSBlockDFSContents,\n};\n\n/// Describes the kinds for high-level analyzer mode.\nenum UserModeKind {\n  /// Perform shallow but fast analyzes.\n  UMK_Shallow = 1,\n\n  /// Perform deep analyzes.\n  UMK_Deep = 2\n};\n\nenum class CTUPhase1InliningKind { None, Small, All };\n\n/// Stores options for the analyzer from the command line.\n///\n/// Some options are frontend flags (e.g.: -analyzer-output), but some are\n/// analyzer configuration options, which are preceded by -analyzer-config\n/// (e.g.: -analyzer-config notes-as-events=true).\n///\n/// If you'd like to add a new frontend flag, add it to\n/// include/clang/Driver/CC1Options.td, add a new field to store the value of\n/// that flag in this class, and initialize it in\n/// lib/Frontend/CompilerInvocation.cpp.\n///\n/// If you'd like to add a new non-checker configuration, register it in\n/// include/clang/StaticAnalyzer/Core/AnalyzerOptions.def, and refer to the\n/// top of the file for documentation.\n///\n/// If you'd like to add a new checker option, call getChecker*Option()\n/// whenever.\n///\n/// Some of the options are controlled by raw frontend flags for no good reason,\n/// and should be eventually converted into -analyzer-config flags. New analyzer\n/// options should not be implemented as frontend flags. Frontend flags still\n/// make sense for things that do not affect the actual analysis.\nclass AnalyzerOptions : public RefCountedBase<AnalyzerOptions> {\npublic:\n  using ConfigTable = llvm::StringMap<std::string>;\n\n  /// Retrieves the list of checkers generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated checkers and plugin checkers!\n  static std::vector<StringRef>\n  getRegisteredCheckers(bool IncludeExperimental = false);\n\n  /// Retrieves the list of packages generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated packages and plugin packages!\n  static std::vector<StringRef>\n  getRegisteredPackages(bool IncludeExperimental = false);\n\n  /// Convenience function for printing options or checkers and their\n  /// description in a formatted manner. If \\p MinLineWidth is set to 0, no line\n  /// breaks are introduced for the description.\n  ///\n  /// Format, depending whether the option name's length is less than\n  /// \\p EntryWidth:\n  ///\n  ///   <padding>EntryName<padding>Description\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///\n  ///   <padding>VeryVeryLongEntryName\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///   ^~~~~~~~~InitialPad\n  ///            ^~~~~~~~~~~~~~~~~~EntryWidth\n  ///   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MinLineWidth\n  static void printFormattedEntry(llvm::raw_ostream &Out,\n                                  std::pair<StringRef, StringRef> EntryDescPair,\n                                  size_t InitialPad, size_t EntryWidth,\n                                  size_t MinLineWidth = 0);\n\n  /// Pairs of checker/package name and enable/disable.\n  std::vector<std::pair<std::string, bool>> CheckersAndPackages;\n\n  /// Vector of checker/package names which will not emit warnings.\n  std::vector<std::string> SilencedCheckersAndPackages;\n\n  /// A key-value table of use-specified configuration values.\n  // TODO: This shouldn't be public.\n  ConfigTable Config;\n  AnalysisConstraints AnalysisConstraintsOpt = RangeConstraintsModel;\n  AnalysisDiagClients AnalysisDiagOpt = PD_HTML;\n  AnalysisPurgeMode AnalysisPurgeOpt = PurgeStmt;\n\n  std::string AnalyzeSpecificFunction;\n\n  /// File path to which the exploded graph should be dumped.\n  std::string DumpExplodedGraphTo;\n\n  /// Store full compiler invocation for reproducible instructions in the\n  /// generated report.\n  std::string FullCompilerInvocation;\n\n  /// The maximum number of times the analyzer visits a block.\n  unsigned maxBlockVisitOnPath;\n\n  /// Disable all analyzer checkers.\n  ///\n  /// This flag allows one to disable analyzer checkers on the code processed by\n  /// the given analysis consumer. Note, the code will get parsed and the\n  /// command-line options will get checked.\n  unsigned DisableAllCheckers : 1;\n\n  unsigned ShowCheckerHelp : 1;\n  unsigned ShowCheckerHelpAlpha : 1;\n  unsigned ShowCheckerHelpDeveloper : 1;\n\n  unsigned ShowCheckerOptionList : 1;\n  unsigned ShowCheckerOptionAlphaList : 1;\n  unsigned ShowCheckerOptionDeveloperList : 1;\n\n  unsigned ShowEnabledCheckerList : 1;\n  unsigned ShowConfigOptionsList : 1;\n  unsigned ShouldEmitErrorsOnInvalidConfigValue : 1;\n  unsigned AnalyzeAll : 1;\n  unsigned AnalyzerDisplayProgress : 1;\n\n  unsigned eagerlyAssumeBinOpBifurcation : 1;\n\n  unsigned TrimGraph : 1;\n  unsigned visualizeExplodedGraphWithGraphViz : 1;\n  unsigned UnoptimizedCFG : 1;\n  unsigned PrintStats : 1;\n\n  /// Do not re-analyze paths leading to exhausted nodes with a different\n  /// strategy. We get better code coverage when retry is enabled.\n  unsigned NoRetryExhausted : 1;\n\n  /// Emit analyzer warnings as errors.\n  bool AnalyzerWerror : 1;\n\n  /// The inlining stack depth limit.\n  unsigned InlineMaxStackDepth;\n\n  /// The mode of function selection used during inlining.\n  AnalysisInliningMode InliningMode = NoRedundancy;\n\n  // Create a field for each -analyzer-config option.\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  TYPE NAME;\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n\n  bool isUnknownAnalyzerConfig(llvm::StringRef Name) {\n    static std::vector<llvm::StringLiteral> AnalyzerConfigCmdFlags = []() {\n      // Create an array of all -analyzer-config command line options.\n      std::vector<llvm::StringLiteral> AnalyzerConfigCmdFlags = {\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  llvm::StringLiteral(CMDFLAG),\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n      };\n      // FIXME: Sort this at compile-time when we get constexpr sort (C++20).\n      llvm::sort(AnalyzerConfigCmdFlags);\n      return AnalyzerConfigCmdFlags;\n    }();\n\n    return !std::binary_search(AnalyzerConfigCmdFlags.begin(),\n                               AnalyzerConfigCmdFlags.end(), Name);\n  }\n\n  AnalyzerOptions()\n      : DisableAllCheckers(false), ShowCheckerHelp(false),\n        ShowCheckerHelpAlpha(false), ShowCheckerHelpDeveloper(false),\n        ShowCheckerOptionList(false), ShowCheckerOptionAlphaList(false),\n        ShowCheckerOptionDeveloperList(false), ShowEnabledCheckerList(false),\n        ShowConfigOptionsList(false),\n        ShouldEmitErrorsOnInvalidConfigValue(false), AnalyzeAll(false),\n        AnalyzerDisplayProgress(false), eagerlyAssumeBinOpBifurcation(false),\n        TrimGraph(false), visualizeExplodedGraphWithGraphViz(false),\n        UnoptimizedCFG(false), PrintStats(false), NoRetryExhausted(false),\n        AnalyzerWerror(false) {}\n\n  /// Interprets an option's string value as a boolean. The \"true\" string is\n  /// interpreted as true and the \"false\" string is interpreted as false.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  bool getCheckerBooleanOption(StringRef CheckerName, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  bool getCheckerBooleanOption(const ento::CheckerBase *C, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  /// Interprets an option's string value as an integer value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  int getCheckerIntegerOption(StringRef CheckerName, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  int getCheckerIntegerOption(const ento::CheckerBase *C, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  /// Query an option's string value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  StringRef getCheckerStringOption(StringRef CheckerName, StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  StringRef getCheckerStringOption(const ento::CheckerBase *C,\n                                   StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  ExplorationStrategyKind getExplorationStrategy() const;\n  CTUPhase1InliningKind getCTUPhase1Inlining() const;\n\n  /// Returns the inter-procedural analysis mode.\n  IPAKind getIPAMode() const;\n\n  /// Returns the option controlling which C++ member functions will be\n  /// considered for inlining.\n  ///\n  /// This is controlled by the 'c++-inlining' config option.\n  ///\n  /// \\sa CXXMemberInliningMode\n  bool mayInlineCXXMemberFunction(CXXInlineableMemberKind K) const;\n\n  ento::PathDiagnosticConsumerOptions getDiagOpts() const {\n    return {FullCompilerInvocation,\n            ShouldDisplayMacroExpansions,\n            ShouldSerializeStats,\n            // The stable report filename option is deprecated because\n            // file names are now always stable. Now the old option acts as\n            // an alias to the new verbose filename option because this\n            // closely mimics the behavior under the old option.\n            ShouldWriteStableReportFilename || ShouldWriteVerboseReportFilename,\n            AnalyzerWerror,\n            ShouldApplyFixIts,\n            ShouldDisplayCheckerNameForText};\n  }\n};\n\nusing AnalyzerOptionsRef = IntrusiveRefCntPtr<AnalyzerOptions>;\n\n//===----------------------------------------------------------------------===//\n// We'll use AnalyzerOptions in the frontend, but we can't link the frontend\n// with clangStaticAnalyzerCore, because clangStaticAnalyzerCore depends on\n// clangFrontend.\n//\n// For this reason, implement some methods in this header file.\n//===----------------------------------------------------------------------===//\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredCheckers(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerCheckerNames[] = {\n#define GET_CHECKERS\n#define CHECKER(FULLNAME, CLASS, HELPTEXT, DOC_URI, IS_HIDDEN)                 \\\n  llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef CHECKER\n#undef GET_CHECKERS\n  };\n  std::vector<StringRef> Checkers;\n  for (StringRef CheckerName : StaticAnalyzerCheckerNames) {\n    if (!CheckerName.startswith(\"debug.\") &&\n        (IncludeExperimental || !CheckerName.startswith(\"alpha.\")))\n      Checkers.push_back(CheckerName);\n  }\n  return Checkers;\n}\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredPackages(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerPackageNames[] = {\n#define GET_PACKAGES\n#define PACKAGE(FULLNAME) llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef PACKAGE\n#undef GET_PACKAGES\n  };\n  std::vector<StringRef> Packages;\n  for (StringRef PackageName : StaticAnalyzerPackageNames) {\n    if (PackageName != \"debug\" &&\n        (IncludeExperimental || PackageName != \"alpha\"))\n      Packages.push_back(PackageName);\n  }\n  return Packages;\n}\n\n}",
  "id": "BLOCK-CPP-22234",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h",
  "source_line": 26,
  "validation_status": "validated"
}