{
  "code": "{\n\nclass AnalysisDeclContext;\nclass CFG;\nclass DeclContext;\nclass Expr;\nclass Stmt;\nclass VarDecl;\n\n/// A use of a variable, which might be uninitialized.\nclass UninitUse {\npublic:\n  struct Branch {\n    const Stmt *Terminator;\n    unsigned Output;\n  };\n\nprivate:\n  /// The expression which uses this variable.\n  const Expr *User;\n\n  /// Is this use uninitialized whenever the function is called?\n  bool UninitAfterCall = false;\n\n  /// Is this use uninitialized whenever the variable declaration is reached?\n  bool UninitAfterDecl = false;\n\n  /// Does this use always see an uninitialized value?\n  bool AlwaysUninit;\n\n  /// This use is always uninitialized if it occurs after any of these branches\n  /// is taken.\n  SmallVector<Branch, 2> UninitBranches;\n\npublic:\n  UninitUse(const Expr *User, bool AlwaysUninit)\n      : User(User), AlwaysUninit(AlwaysUninit) {}\n\n  void addUninitBranch(Branch B) {\n    UninitBranches.push_back(B);\n  }\n\n  void setUninitAfterCall() { UninitAfterCall = true; }\n  void setUninitAfterDecl() { UninitAfterDecl = true; }\n\n  /// Get the expression containing the uninitialized use.\n  const Expr *getUser() const { return User; }\n\n  /// The kind of uninitialized use.\n  enum Kind {\n    /// The use might be uninitialized.\n    Maybe,\n\n    /// The use is uninitialized whenever a certain branch is taken.\n    Sometimes,\n\n    /// The use is uninitialized the first time it is reached after we reach\n    /// the variable's declaration.\n    AfterDecl,\n\n    /// The use is uninitialized the first time it is reached after the function\n    /// is called.\n    AfterCall,\n\n    /// The use is always uninitialized.\n    Always\n  };\n\n  /// Get the kind of uninitialized use.\n  Kind getKind() const {\n    return AlwaysUninit ? Always :\n           UninitAfterCall ? AfterCall :\n           UninitAfterDecl ? AfterDecl :\n           !branch_empty() ? Sometimes : Maybe;\n  }\n\n  using branch_iterator = SmallVectorImpl<Branch>::const_iterator;\n\n  /// Branches which inevitably result in the variable being used uninitialized.\n  branch_iterator branch_begin() const { return UninitBranches.begin(); }\n  branch_iterator branch_end() const { return UninitBranches.end(); }\n  bool branch_empty() const { return UninitBranches.empty(); }\n};\n\nclass UninitVariablesHandler {\npublic:\n  UninitVariablesHandler() = default;\n  virtual ~UninitVariablesHandler();\n\n  /// Called when the uninitialized variable is used at the given expression.\n  virtual void handleUseOfUninitVariable(const VarDecl *vd,\n                                         const UninitUse &use) {}\n\n  /// Called when the uninitialized variable is used as const refernce argument.\n  virtual void handleConstRefUseOfUninitVariable(const VarDecl *vd,\n                                                 const UninitUse &use) {}\n\n  /// Called when the uninitialized variable analysis detects the\n  /// idiom 'int x = x'.  All other uses of 'x' within the initializer\n  /// are handled by handleUseOfUninitVariable.\n  virtual void handleSelfInit(const VarDecl *vd) {}\n};\n\nstruct UninitVariablesAnalysisStats {\n  unsigned NumVariablesAnalyzed;\n  unsigned NumBlockVisits;\n};\n\nvoid runUninitializedVariablesAnalysis(const DeclContext &dc, const CFG &cfg,\n                                       AnalysisDeclContext &ac,\n                                       UninitVariablesHandler &handler,\n                                       UninitVariablesAnalysisStats &stats);\n\n}",
  "id": "BLOCK-CPP-21865",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/UninitializedValues.h",
  "source_line": 20,
  "validation_status": "validated"
}