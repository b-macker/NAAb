{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// Tristate tag types controlling the output of GenerateRealFromBits.\nstruct GeneratePositiveTag {};\nstruct GenerateNegativeTag {};\nstruct GenerateSignedTag {};\n\n// GenerateRealFromBits generates a single real value from a single 64-bit\n// `bits` with template fields controlling the output.\n//\n// The `SignedTag` parameter controls whether positive, negative,\n// or either signed/unsigned may be returned.\n//   When SignedTag == GeneratePositiveTag, range is U(0, 1)\n//   When SignedTag == GenerateNegativeTag, range is U(-1, 0)\n//   When SignedTag == GenerateSignedTag, range is U(-1, 1)\n//\n// When the `IncludeZero` parameter is true, the function may return 0 for some\n// inputs, otherwise it never returns 0.\n//\n// When a value in U(0,1) is required, use:\n//   GenerateRealFromBits<double, PositiveValueT, true>;\n//\n// When a value in U(-1,1) is required, use:\n//   GenerateRealFromBits<double, SignedValueT, false>;\n//\n//   This generates more distinct values than the mathematical equivalent\n//   `U(0, 1) * 2.0 - 1.0`.\n//\n// Scaling the result by powers of 2 (and avoiding a multiply) is also possible:\n//   GenerateRealFromBits<double>(..., -1);  => U(0, 0.5)\n//   GenerateRealFromBits<double>(..., 1);   => U(0, 2)\n//\ntemplate <typename RealType,  // Real type, either float or double.\n          typename SignedTag = GeneratePositiveTag,  // Whether a positive,\n                                                     // negative, or signed\n                                                     // value is generated.\n          bool IncludeZero = true>\ninline RealType GenerateRealFromBits(uint64_t bits, int exp_bias = 0) {\n  using real_type = RealType;\n  using uint_type = absl::conditional_t<std::is_same<real_type, float>::value,\n                                        uint32_t, uint64_t>;\n\n  static_assert(\n      (std::is_same<double, real_type>::value ||\n       std::is_same<float, real_type>::value),\n      \"GenerateRealFromBits must be parameterized by either float or double.\");\n\n  static_assert(sizeof(uint_type) == sizeof(real_type),\n                \"Mismatched unsigned and real types.\");\n\n  static_assert((std::numeric_limits<real_type>::is_iec559 &&\n                 std::numeric_limits<real_type>::radix == 2),\n                \"RealType representation is not IEEE 754 binary.\");\n\n  static_assert((std::is_same<SignedTag, GeneratePositiveTag>::value ||\n                 std::is_same<SignedTag, GenerateNegativeTag>::value ||\n                 std::is_same<SignedTag, GenerateSignedTag>::value),\n                \"\");\n\n  static constexpr int kExp = std::numeric_limits<real_type>::digits - 1;\n  static constexpr uint_type kMask = (static_cast<uint_type>(1) << kExp) - 1u;\n  static constexpr int kUintBits = sizeof(uint_type) * 8;\n\n  int exp = exp_bias + int{std::numeric_limits<real_type>::max_exponent - 2};\n\n  // Determine the sign bit.\n  // Depending on the SignedTag, this may use the left-most bit\n  // or it may be a constant value.\n  uint_type sign = std::is_same<SignedTag, GenerateNegativeTag>::value\n                       ? (static_cast<uint_type>(1) << (kUintBits - 1))\n                       : 0;\n  if (std::is_same<SignedTag, GenerateSignedTag>::value) {\n    if (std::is_same<uint_type, uint64_t>::value) {\n      sign = bits & uint64_t{0x8000000000000000};\n    }\n    if (std::is_same<uint_type, uint32_t>::value) {\n      const uint64_t tmp = bits & uint64_t{0x8000000000000000};\n      sign = static_cast<uint32_t>(tmp >> 32);\n    }\n    // adjust the bits and the exponent to account for removing\n    // the leading bit.\n    bits = bits & uint64_t{0x7FFFFFFFFFFFFFFF};\n    exp++;\n  }\n  if (IncludeZero) {\n    if (bits == 0u) return 0;\n  }\n\n  // Number of leading zeros is mapped to the exponent: 2^-clz\n  // bits is 0..01xxxxxx. After shifting, we're left with 1xxx...0..0\n  int clz = countl_zero(bits);\n  bits <<= (IncludeZero ? clz : (clz & 63));  // remove 0-bits.\n  exp -= clz;                                 // set the exponent.\n  bits >>= (63 - kExp);\n\n  // Construct the 32-bit or 64-bit IEEE 754 floating-point value from\n  // the individual fields: sign, exp, mantissa(bits).\n  uint_type val = sign | (static_cast<uint_type>(exp) << kExp) |\n                  (static_cast<uint_type>(bits) & kMask);\n\n  // bit_cast to the output-type\n  real_type result;\n  memcpy(static_cast<void*>(&result), static_cast<const void*>(&val),\n         sizeof(result));\n  return result;\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05873",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/generate_real.h",
  "source_line": 31,
  "validation_status": "validated"
}