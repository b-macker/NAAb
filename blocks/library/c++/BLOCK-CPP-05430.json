{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace crc_internal {\n\n// Prefetch constants used in some Extend() implementations\nconstexpr int kPrefetchHorizon = ABSL_CACHELINE_SIZE * 4;  // Prefetch this far\n// Shorter prefetch distance for smaller buffers\nconstexpr int kPrefetchHorizonMedium = ABSL_CACHELINE_SIZE * 1;\nstatic_assert(kPrefetchHorizon >= 64, \"CRCPrefetchHorizon less than loop len\");\n\n// We require the Scramble() function:\n//  - to be reversible (Unscramble() must exist)\n//  - to be non-linear in the polynomial's Galois field (so the CRC of a\n//    scrambled CRC is not linearly affected by the scrambled CRC, even if\n//    using the same polynomial)\n//  - not to be its own inverse.  Preferably, if X=Scramble^N(X) and N!=0, then\n//    N is large.\n//  - to be fast.\n//  - not to change once defined.\n// We introduce non-linearity in two ways:\n//     Addition of a constant.\n//         - The carries introduce non-linearity; we use bits of an irrational\n//           (phi) to make it unlikely that we introduce no carries.\n//     Rotate by a constant number of bits.\n//         - We use floor(degree/2)+1, which does not divide the degree, and\n//           splits the bits nearly evenly, which makes it less likely the\n//           halves will be the same or one will be all zeroes.\n// We do both things to improve the chances of non-linearity in the face of\n// bit patterns with low numbers of bits set, while still being fast.\n// Below is the constant that we add.  The bits are the first 128 bits of the\n// fractional part of phi, with a 1 ored into the bottom bit to maximize the\n// cycle length of repeated adds.\nconstexpr uint64_t kScrambleHi = (static_cast<uint64_t>(0x4f1bbcdcU) << 32) |\n                                 static_cast<uint64_t>(0xbfa53e0aU);\nconstexpr uint64_t kScrambleLo = (static_cast<uint64_t>(0xf9ce6030U) << 32) |\n                                 static_cast<uint64_t>(0x2e76e41bU);\n\nclass CRCImpl : public CRC {  // Implementation of the abstract class CRC\n public:\n  using Uint32By256 = uint32_t[256];\n\n  CRCImpl() = default;\n  ~CRCImpl() override = default;\n\n  // The internal version of CRC::New().\n  static CRCImpl* NewInternal();\n\n  // Fill in a table for updating a CRC by one word of 'word_size' bytes\n  // [last_lo, last_hi] contains the answer if the last bit in the word\n  // is set.\n  static void FillWordTable(uint32_t poly, uint32_t last, int word_size,\n                            Uint32By256* t);\n\n  // Build the table for extending by zeroes, returning the number of entries.\n  // For a in {1, 2, ..., ZEROES_BASE-1}, b in {0, 1, 2, 3, ...},\n  // entry j=a-1+(ZEROES_BASE-1)*b\n  // contains a polynomial Pi such that multiplying\n  // a CRC by Pi mod P, where P is the CRC polynomial, is equivalent to\n  // appending a*2**(ZEROES_BASE_LG*b) zero bytes to the original string.\n  static int FillZeroesTable(uint32_t poly, Uint32By256* t);\n\n  virtual void InitTables() = 0;\n\n private:\n  CRCImpl(const CRCImpl&) = delete;\n  CRCImpl& operator=(const CRCImpl&) = delete;\n};\n\n// This is the 32-bit implementation.  It handles all sizes from 8 to 32.\nclass CRC32 : public CRCImpl {\n public:\n  CRC32() = default;\n  ~CRC32() override = default;\n\n  void Extend(uint32_t* crc, const void* bytes, size_t length) const override;\n  void ExtendByZeroes(uint32_t* crc, size_t length) const override;\n  void Scramble(uint32_t* crc) const override;\n  void Unscramble(uint32_t* crc) const override;\n  void UnextendByZeroes(uint32_t* crc, size_t length) const override;\n\n  void InitTables() override;\n\n private:\n  // Common implementation guts for ExtendByZeroes and UnextendByZeroes().\n  //\n  // zeroes_table is a table as returned by FillZeroesTable(), containing\n  // polynomials representing CRCs of strings-of-zeros of various lengths,\n  // and which can be combined by polynomial multiplication.  poly_table is\n  // a table of CRC byte extension values.  These tables are determined by\n  // the generator polynomial.\n  //\n  // These will be set to reverse_zeroes_ and reverse_table0_ for Unextend, and\n  // CRC32::zeroes_ and CRC32::table0_ for Extend.\n  static void ExtendByZeroesImpl(uint32_t* crc, size_t length,\n                                 const uint32_t zeroes_table[256],\n                                 const uint32_t poly_table[256]);\n\n  uint32_t table0_[256];  // table of byte extensions\n  uint32_t zeroes_[256];  // table of zero extensions\n\n  // table of 4-byte extensions shifted by 12 bytes of zeroes\n  uint32_t table_[4][256];\n\n  // Reverse lookup tables, using the alternate polynomial used by\n  // UnextendByZeroes().\n  uint32_t reverse_table0_[256];  // table of reverse byte extensions\n  uint32_t reverse_zeroes_[256];  // table of reverse zero extensions\n\n  CRC32(const CRC32&) = delete;\n  CRC32& operator=(const CRC32&) = delete;\n};\n\n// Helpers\n\n// Return a bit mask containing len 1-bits.\n// Requires 0 < len <= sizeof(T)\ntemplate <typename T>\nT MaskOfLength(int len) {\n  // shift 2 by len-1 rather than 1 by len because shifts of wordsize\n  // are undefined.\n  return (T(2) << (len - 1)) - 1;\n}\n\n// Rotate low-order \"width\" bits of \"in\" right by \"r\" bits,\n// setting other bits in word to arbitrary values.\ntemplate <typename T>\nT RotateRight(T in, int width, int r) {\n  return (in << (width - r)) | ((in >> r) & MaskOfLength<T>(width - r));\n}\n\n// RoundUp<N>(p) returns the lowest address >= p aligned to an N-byte\n// boundary.  Requires that N is a power of 2.\ntemplate <int alignment>\nconst uint8_t* RoundUp(const uint8_t* p) {\n  static_assert((alignment & (alignment - 1)) == 0, \"alignment is not 2^n\");\n  constexpr uintptr_t mask = alignment - 1;\n  const uintptr_t as_uintptr = reinterpret_cast<uintptr_t>(p);\n  return reinterpret_cast<const uint8_t*>((as_uintptr + mask) & ~mask);\n}\n\n// Return a newly created CRC32AcceleratedX86ARMCombined if we can use Intel's\n// or ARM's CRC acceleration for a given polynomial.  Return nullptr otherwise.\nCRCImpl* TryNewCRC32AcceleratedX86ARMCombined();\n\n// Return all possible hardware accelerated implementations. For testing only.\nstd::vector<std::unique_ptr<CRCImpl>> NewCRC32AcceleratedX86ARMCombinedAll();\n\n}  // namespace crc_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05430",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc_internal.h",
  "source_line": 25,
  "validation_status": "validated"
}