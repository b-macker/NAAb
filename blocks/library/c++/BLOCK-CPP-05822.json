{
  "code": "#include <stdint.h>\n#include \"absl/base/config.h\"\n#include \"absl/base/macros.h\"\n\nusing namespace absl;\nusing namespace profiling_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05822_execute() {\n    {\n\n// ExponentialBiased provides a small and fast random number generator for a\n// rounded exponential distribution. This generator manages very little state,\n// and imposes no synchronization overhead. This makes it useful in specialized\n// scenarios requiring minimum overhead, such as stride based periodic sampling.\n//\n// ExponentialBiased provides two closely related functions, GetSkipCount() and\n// GetStride(), both returning a rounded integer defining a number of events\n// required before some event with a given mean probability occurs.\n//\n// The distribution is useful to generate a random wait time or some periodic\n// event with a given mean probability. For example, if an action is supposed to\n// happen on average once every 'N' events, then we can get a random 'stride'\n// counting down how long before the event to happen. For example, if we'd want\n// to sample one in every 1000 'Frobber' calls, our code could look like this:\n//\n//   Frobber::Frobber() {\n//     stride_ = exponential_biased_.GetStride(1000);\n//   }\n//\n//   void Frobber::Frob(int arg) {\n//     if (--stride == 0) {\n//       SampleFrob(arg);\n//       stride_ = exponential_biased_.GetStride(1000);\n//     }\n//     ...\n//   }\n//\n// The rounding of the return value creates a bias, especially for smaller means\n// where the distribution of the fraction is not evenly distributed. We correct\n// this bias by tracking the fraction we rounded up or down on each iteration,\n// effectively tracking the distance between the cumulative value, and the\n// rounded cumulative value. For example, given a mean of 2:\n//\n//   raw = 1.63076, cumulative = 1.63076, rounded = 2, bias = -0.36923\n//   raw = 0.14624, cumulative = 1.77701, rounded = 2, bias =  0.14624\n//   raw = 4.93194, cumulative = 6.70895, rounded = 7, bias = -0.06805\n//   raw = 0.24206, cumulative = 6.95101, rounded = 7, bias =  0.24206\n//   etc...\n//\n// Adjusting with rounding bias is relatively trivial:\n//\n//    double value = bias_ + exponential_distribution(mean)();\n//    double rounded_value = std::rint(value);\n//    bias_ = value - rounded_value;\n//    return rounded_value;\n//\n// This class is thread-compatible.\nclass ExponentialBiased {\n public:\n  // The number of bits set by NextRandom.\n  static constexpr int kPrngNumBits = 48;\n\n  // `GetSkipCount()` returns the number of events to skip before some chosen\n  // event happens. For example, randomly tossing a coin, we will on average\n  // throw heads once before we get tails. We can simulate random coin tosses\n  // using GetSkipCount() as:\n  //\n  //   ExponentialBiased eb;\n  //   for (...) {\n  //     int number_of_heads_before_tail = eb.GetSkipCount(1);\n  //     for (int flips = 0; flips < number_of_heads_before_tail; ++flips) {\n  //       printf(\"head...\");\n  //     }\n  //     printf(\"tail\\n\");\n  //   }\n  //\n  int64_t GetSkipCount(int64_t mean);\n\n  // GetStride() returns the number of events required for a specific event to\n  // happen. See the class comments for a usage example. `GetStride()` is\n  // equivalent to `GetSkipCount(mean - 1) + 1`. When to use `GetStride()` or\n  // `GetSkipCount()` depends mostly on what best fits the use case.\n  int64_t GetStride(int64_t mean);\n\n  // Computes a random number in the range [0, 1<<(kPrngNumBits+1) - 1]\n  //\n  // This is public to enable testing.\n  static uint64_t NextRandom(uint64_t rnd);\n\n private:\n  void Initialize();\n\n  uint64_t rng_{0};\n  double bias_{0};\n  bool initialized_{false};\n};\n\n// Returns the next prng value.\n// pRNG is: aX+b mod c with a = 0x5DEECE66D, b =  0xB, c = 1<<48\n// This is the lrand64 generator.\ninline uint64_t ExponentialBiased::NextRandom(uint64_t rnd) {\n  const uint64_t prng_mult = uint64_t{0x5DEECE66D};\n  const uint64_t prng_add = 0xB;\n  const uint64_t prng_mod_power = 48;\n  const uint64_t prng_mod_mask =\n      ~((~static_cast<uint64_t>(0)) << prng_mod_power);\n  return (prng_mult * rnd + prng_add) & prng_mod_mask;\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05822",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/profiling/internal/exponential_biased.h",
  "source_line": 25,
  "validation_status": "validated"
}