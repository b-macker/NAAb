{
  "code": "{\nclass Decl;\nclass SourceMgr;\nclass Preprocessor;\n\nnamespace comments {\nclass CommandTraits;\n\nclass Sema {\n  Sema(const Sema &) = delete;\n  void operator=(const Sema &) = delete;\n\n  /// Allocator for AST nodes.\n  llvm::BumpPtrAllocator &Allocator;\n\n  /// Source manager for the comment being parsed.\n  const SourceManager &SourceMgr;\n\n  DiagnosticsEngine &Diags;\n\n  CommandTraits &Traits;\n\n  const Preprocessor *PP;\n\n  /// Information about the declaration this comment is attached to.\n  DeclInfo *ThisDeclInfo;\n\n  /// Comment AST nodes that correspond to parameter names in\n  /// \\c TemplateParameters.\n  ///\n  /// Contains a valid value if \\c DeclInfo->IsFilled is true.\n  llvm::StringMap<TParamCommandComment *> TemplateParameterDocs;\n\n  /// AST node for the \\command and its aliases.\n  const BlockCommandComment *BriefCommand;\n\n  /// AST node for the \\\\headerfile command.\n  const BlockCommandComment *HeaderfileCommand;\n\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) {\n    return Diags.Report(Loc, DiagID);\n  }\n\n  /// A stack of HTML tags that are currently open (not matched with closing\n  /// tags).\n  SmallVector<HTMLStartTagComment *, 8> HTMLOpenTags;\n\npublic:\n  Sema(llvm::BumpPtrAllocator &Allocator, const SourceManager &SourceMgr,\n       DiagnosticsEngine &Diags, CommandTraits &Traits,\n       const Preprocessor *PP);\n\n  void setDecl(const Decl *D);\n\n  /// Returns a copy of array, owned by Sema's allocator.\n  template<typename T>\n  ArrayRef<T> copyArray(ArrayRef<T> Source) {\n    if (!Source.empty())\n      return Source.copy(Allocator);\n    return std::nullopt;\n  }\n\n  ParagraphComment *actOnParagraphComment(\n      ArrayRef<InlineContentComment *> Content);\n\n  BlockCommandComment *actOnBlockCommandStart(SourceLocation LocBegin,\n                                              SourceLocation LocEnd,\n                                              unsigned CommandID,\n                                              CommandMarkerKind CommandMarker);\n\n  void actOnBlockCommandArgs(BlockCommandComment *Command,\n                             ArrayRef<BlockCommandComment::Argument> Args);\n\n  void actOnBlockCommandFinish(BlockCommandComment *Command,\n                               ParagraphComment *Paragraph);\n\n  ParamCommandComment *actOnParamCommandStart(SourceLocation LocBegin,\n                                              SourceLocation LocEnd,\n                                              unsigned CommandID,\n                                              CommandMarkerKind CommandMarker);\n\n  void actOnParamCommandDirectionArg(ParamCommandComment *Command,\n                                     SourceLocation ArgLocBegin,\n                                     SourceLocation ArgLocEnd,\n                                     StringRef Arg);\n\n  void actOnParamCommandParamNameArg(ParamCommandComment *Command,\n                                     SourceLocation ArgLocBegin,\n                                     SourceLocation ArgLocEnd,\n                                     StringRef Arg);\n\n  void actOnParamCommandFinish(ParamCommandComment *Command,\n                               ParagraphComment *Paragraph);\n\n  TParamCommandComment *actOnTParamCommandStart(SourceLocation LocBegin,\n                                                SourceLocation LocEnd,\n                                                unsigned CommandID,\n                                                CommandMarkerKind CommandMarker);\n\n  void actOnTParamCommandParamNameArg(TParamCommandComment *Command,\n                                      SourceLocation ArgLocBegin,\n                                      SourceLocation ArgLocEnd,\n                                      StringRef Arg);\n\n  void actOnTParamCommandFinish(TParamCommandComment *Command,\n                                ParagraphComment *Paragraph);\n\n  InlineCommandComment *actOnInlineCommand(SourceLocation CommandLocBegin,\n                                           SourceLocation CommandLocEnd,\n                                           unsigned CommandID,\n                                           ArrayRef<Comment::Argument> Args);\n\n  InlineContentComment *actOnUnknownCommand(SourceLocation LocBegin,\n                                            SourceLocation LocEnd,\n                                            StringRef CommandName);\n\n  InlineContentComment *actOnUnknownCommand(SourceLocation LocBegin,\n                                            SourceLocation LocEnd,\n                                            unsigned CommandID);\n\n  TextComment *actOnText(SourceLocation LocBegin,\n                         SourceLocation LocEnd,\n                         StringRef Text);\n\n  VerbatimBlockComment *actOnVerbatimBlockStart(SourceLocation Loc,\n                                                unsigned CommandID);\n\n  VerbatimBlockLineComment *actOnVerbatimBlockLine(SourceLocation Loc,\n                                                   StringRef Text);\n\n  void actOnVerbatimBlockFinish(VerbatimBlockComment *Block,\n                                SourceLocation CloseNameLocBegin,\n                                StringRef CloseName,\n                                ArrayRef<VerbatimBlockLineComment *> Lines);\n\n  VerbatimLineComment *actOnVerbatimLine(SourceLocation LocBegin,\n                                         unsigned CommandID,\n                                         SourceLocation TextBegin,\n                                         StringRef Text);\n\n  HTMLStartTagComment *actOnHTMLStartTagStart(SourceLocation LocBegin,\n                                              StringRef TagName);\n\n  void actOnHTMLStartTagFinish(HTMLStartTagComment *Tag,\n                               ArrayRef<HTMLStartTagComment::Attribute> Attrs,\n                               SourceLocation GreaterLoc,\n                               bool IsSelfClosing);\n\n  HTMLEndTagComment *actOnHTMLEndTag(SourceLocation LocBegin,\n                                     SourceLocation LocEnd,\n                                     StringRef TagName);\n\n  FullComment *actOnFullComment(ArrayRef<BlockContentComment *> Blocks);\n\nprivate:\n  void checkBlockCommandEmptyParagraph(BlockCommandComment *Command);\n\n  void checkReturnsCommand(const BlockCommandComment *Command);\n\n  /// Emit diagnostics about duplicate block commands that should be\n  /// used only once per comment, e.g., \\and \\\\returns.\n  void checkBlockCommandDuplicate(const BlockCommandComment *Command);\n\n  void checkDeprecatedCommand(const BlockCommandComment *Comment);\n\n  void checkFunctionDeclVerbatimLine(const BlockCommandComment *Comment);\n\n  void checkContainerDeclVerbatimLine(const BlockCommandComment *Comment);\n\n  void checkContainerDecl(const BlockCommandComment *Comment);\n\n  /// Resolve parameter names to parameter indexes in function declaration.\n  /// Emit diagnostics about unknown parameters.\n  void resolveParamCommandIndexes(const FullComment *FC);\n\n  /// \\returns \\c true if the declaration that this comment is attached to\n  /// is a pointer to function/method/block type or has such a type.\n  bool involvesFunctionType();\n\n  bool isFunctionDecl();\n  bool isAnyFunctionDecl();\n\n  /// \\returns \\c true if declaration that this comment is attached to declares\n  /// a function pointer.\n  bool isFunctionPointerVarDecl();\n  bool isFunctionOrMethodVariadic();\n  bool isObjCMethodDecl();\n  bool isObjCPropertyDecl();\n  bool isTemplateOrSpecialization();\n  bool isRecordLikeDecl();\n  bool isClassOrStructDecl();\n  /// \\return \\c true if the declaration that this comment is attached to\n  /// declares either struct, class or tag typedef.\n  bool isClassOrStructOrTagTypedefDecl();\n  bool isUnionDecl();\n  bool isObjCInterfaceDecl();\n  bool isObjCProtocolDecl();\n  bool isClassTemplateDecl();\n  bool isFunctionTemplateDecl();\n\n  ArrayRef<const ParmVarDecl *> getParamVars();\n\n  /// Extract all important semantic information from\n  /// \\c ThisDeclInfo->ThisDecl into \\c ThisDeclInfo members.\n  void inspectThisDecl();\n\n  /// Returns index of a function parameter with a given name.\n  unsigned resolveParmVarReference(StringRef Name,\n                                   ArrayRef<const ParmVarDecl *> ParamVars);\n\n  /// Returns index of a function parameter with the name closest to a given\n  /// typo.\n  unsigned correctTypoInParmVarReference(StringRef Typo,\n                                         ArrayRef<const ParmVarDecl *> ParamVars);\n\n  bool resolveTParamReference(StringRef Name,\n                              const TemplateParameterList *TemplateParameters,\n                              SmallVectorImpl<unsigned> *Position);\n\n  StringRef correctTypoInTParamReference(\n                              StringRef Typo,\n                              const TemplateParameterList *TemplateParameters);\n\n  InlineCommandComment::RenderKind\n  getInlineCommandRenderKind(StringRef Name) const;\n};\n\n} // end namespace comments\n}",
  "id": "BLOCK-CPP-07715",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CommentSema.h",
  "source_line": 24,
  "validation_status": "validated"
}