{
  "code": "#include \"clang/AST/Decl.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-11265_execute() {\n    {\n\n/// Describes the capture of a variable or of \\c this, or of a\n/// C++1y init-capture.\nclass LambdaCapture {\n  enum {\n    /// Flag used by the Capture class to indicate that the given\n    /// capture was implicit.\n    Capture_Implicit = 0x01,\n\n    /// Flag used by the Capture class to indicate that the\n    /// given capture was by-copy.\n    ///\n    /// This includes the case of a non-reference init-capture.\n    Capture_ByCopy = 0x02,\n\n    /// Flag used by the Capture class to distinguish between a capture\n    /// of '*this' and a capture of a VLA type.\n    Capture_This = 0x04\n  };\n\n  // Decl could represent:\n  // - a VarDecl* that represents the variable that was captured or the\n  //   init-capture.\n  // - or, is a nullptr and Capture_This is set in Bits if this represents a\n  //   capture of '*this' by value or reference.\n  // - or, is a nullptr and Capture_This is not set in Bits if this represents\n  //   a capture of a VLA type.\n  llvm::PointerIntPair<Decl*, 3> DeclAndBits;\n\n  SourceLocation Loc;\n  SourceLocation EllipsisLoc;\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Create a new capture of a variable or of \\c this.\n  ///\n  /// \\param Loc The source location associated with this capture.\n  ///\n  /// \\param Kind The kind of capture (this, byref, bycopy), which must\n  /// not be init-capture.\n  ///\n  /// \\param Implicit Whether the capture was implicit or explicit.\n  ///\n  /// \\param Var The local variable being captured, or null if capturing\n  /// \\c this.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis (...) for a\n  /// capture that is a pack expansion, or an invalid source\n  /// location to indicate that this is not a pack expansion.\n  LambdaCapture(SourceLocation Loc, bool Implicit, LambdaCaptureKind Kind,\n                ValueDecl *Var = nullptr,\n                SourceLocation EllipsisLoc = SourceLocation());\n\n  /// Determine the kind of capture.\n  LambdaCaptureKind getCaptureKind() const;\n\n  /// Determine whether this capture handles the C++ \\c this\n  /// pointer.\n  bool capturesThis() const {\n    return DeclAndBits.getPointer() == nullptr &&\n          (DeclAndBits.getInt() & Capture_This);\n  }\n\n  /// Determine whether this capture handles a variable.\n  bool capturesVariable() const {\n    return isa_and_nonnull<ValueDecl>(DeclAndBits.getPointer());\n  }\n\n  /// Determine whether this captures a variable length array bound\n  /// expression.\n  bool capturesVLAType() const {\n    return DeclAndBits.getPointer() == nullptr &&\n           !(DeclAndBits.getInt() & Capture_This);\n  }\n\n  /// Retrieve the declaration of the local variable being\n  /// captured.\n  ///\n  /// This operation is only valid if this capture is a variable capture\n  /// (other than a capture of \\c this).\n  ValueDecl *getCapturedVar() const {\n    assert(capturesVariable() && \"No variable available for capture\");\n    return static_cast<ValueDecl *>(DeclAndBits.getPointer());\n  }\n\n  /// Determine whether this was an implicit capture (not\n  /// written between the square brackets introducing the lambda).\n  bool isImplicit() const {\n    return DeclAndBits.getInt() & Capture_Implicit;\n  }\n\n  /// Determine whether this was an explicit capture (written\n  /// between the square brackets introducing the lambda).\n  bool isExplicit() const { return !isImplicit(); }\n\n  /// Retrieve the source location of the capture.\n  ///\n  /// For an explicit capture, this returns the location of the\n  /// explicit capture in the source. For an implicit capture, this\n  /// returns the location at which the variable or \\c this was first\n  /// used.\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Determine whether this capture is a pack expansion,\n  /// which captures a function parameter pack.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Retrieve the location of the ellipsis for a capture\n  /// that is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    assert(isPackExpansion() && \"No ellipsis location for a non-expansion\");\n    return EllipsisLoc;\n  }\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-11265",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/LambdaCapture.h",
  "source_line": 21,
  "validation_status": "validated"
}