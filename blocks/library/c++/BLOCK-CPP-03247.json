{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace time_internal {\nnamespace cctz {\n\nnamespace {\n\n#if defined(_WIN32) || defined(_WIN64)\n// Uses the globals: '_timezone', '_dstbias' and '_tzname'.\nauto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + _dstbias) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return _timezone + (is_dst ? _dstbias : 0);\n}\nauto tm_zone(const std::tm& tm) -> decltype(_tzname[0]) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return _tzname[is_dst];\n}\n#elif defined(__sun) || defined(_AIX)\n// Uses the globals: 'timezone', 'altzone' and 'tzname'.\nauto tm_gmtoff(const std::tm& tm) -> decltype(timezone) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return is_dst ? altzone : timezone;\n}\nauto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return tzname[is_dst];\n}\n#elif defined(__native_client__) || defined(__myriad2__) || \\\n    defined(__EMSCRIPTEN__)\n// Uses the globals: '_timezone' and 'tzname'.\nauto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + 0) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return _timezone + (is_dst ? 60 * 60 : 0);\n}\nauto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return tzname[is_dst];\n}\n#elif defined(__VXWORKS__)\n// Uses the globals: 'timezone' and 'tzname'.\nauto tm_gmtoff(const std::tm& tm) -> decltype(timezone + 0) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return timezone + (is_dst ? 60 * 60 : 0);\n}\nauto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {\n  const bool is_dst = tm.tm_isdst > 0;\n  return tzname[is_dst];\n}\n#else\n// Adapt to different spellings of the struct std::tm extension fields.\n#if defined(tm_gmtoff)\nauto tm_gmtoff(const std::tm& tm) -> decltype(tm.tm_gmtoff) {\n  return tm.tm_gmtoff;\n}\n#elif defined(__tm_gmtoff)\nauto tm_gmtoff(const std::tm& tm) -> decltype(tm.__tm_gmtoff) {\n  return tm.__tm_gmtoff;\n}\n#else\ntemplate <typename T>\nauto tm_gmtoff(const T& tm) -> decltype(tm.tm_gmtoff) {\n  return tm.tm_gmtoff;\n}\ntemplate <typename T>\nauto tm_gmtoff(const T& tm) -> decltype(tm.__tm_gmtoff) {\n  return tm.__tm_gmtoff;\n}\n#endif  // tm_gmtoff\n#if defined(tm_zone)\nauto tm_zone(const std::tm& tm) -> decltype(tm.tm_zone) { return tm.tm_zone; }\n#elif defined(__tm_zone)\nauto tm_zone(const std::tm& tm) -> decltype(tm.__tm_zone) {\n  return tm.__tm_zone;\n}\n#else\ntemplate <typename T>\nauto tm_zone(const T& tm) -> decltype(tm.tm_zone) {\n  return tm.tm_zone;\n}\ntemplate <typename T>\nauto tm_zone(const T& tm) -> decltype(tm.__tm_zone) {\n  return tm.__tm_zone;\n}\n#endif  // tm_zone\n#endif\nusing tm_gmtoff_t = decltype(tm_gmtoff(std::tm{}));\n\ninline std::tm* gm_time(const std::time_t* timep, std::tm* result) {\n#if defined(_WIN32) || defined(_WIN64)\n  return gmtime_s(result, timep) ? nullptr : result;\n#else\n  return gmtime_r(timep, result);\n#endif\n}\n\ninline std::tm* local_time(const std::time_t* timep, std::tm* result) {\n#if defined(_WIN32) || defined(_WIN64)\n  return localtime_s(result, timep) ? nullptr : result;\n#else\n  return localtime_r(timep, result);\n#endif\n}\n\n// Converts a civil second and \"dst\" flag into a time_t and a struct tm.\n// Returns false if time_t cannot represent the requested civil second.\n// Caller must have already checked that cs.year() will fit into a tm_year.\nbool make_time(const civil_second& cs, int is_dst, std::time_t* t,\n               std::tm* tm) {\n  tm->tm_year = static_cast<int>(cs.year() - year_t{1900});\n  tm->tm_mon = cs.month() - 1;\n  tm->tm_mday = cs.day();\n  tm->tm_hour = cs.hour();\n  tm->tm_min = cs.minute();\n  tm->tm_sec = cs.second();\n  tm->tm_isdst = is_dst;\n  *t = std::mktime(tm);\n  if (*t == std::time_t{-1}) {\n    std::tm tm2;\n    const std::tm* tmp = local_time(t, &tm2);\n    if (tmp == nullptr || tmp->tm_year != tm->tm_year ||\n        tmp->tm_mon != tm->tm_mon || tmp->tm_mday != tm->tm_mday ||\n        tmp->tm_hour != tm->tm_hour || tmp->tm_min != tm->tm_min ||\n        tmp->tm_sec != tm->tm_sec) {\n      // A true error (not just one second before the epoch).\n      return false;\n    }\n  }\n  return true;\n}\n\n// Find the least time_t in [lo:hi] where local time matches offset, given:\n// (1) lo doesn't match, (2) hi does, and (3) there is only one transition.\nstd::time_t find_trans(std::time_t lo, std::time_t hi, tm_gmtoff_t offset) {\n  std::tm tm;\n  while (lo + 1 != hi) {\n    const std::time_t mid = lo + (hi - lo) / 2;\n    std::tm* tmp = local_time(&mid, &tm);\n    if (tmp != nullptr) {\n      if (tm_gmtoff(*tmp) == offset) {\n        hi = mid;\n      } else {\n        lo = mid;\n      }\n    } else {\n      // If std::tm cannot hold some result we resort to a linear search,\n      // ignoring all failed conversions.  Slow, but never really happens.\n      while (++lo != hi) {\n        tmp = local_time(&lo, &tm);\n        if (tmp != nullptr) {\n          if (tm_gmtoff(*tmp) == offset) break;\n        }\n      }\n      return lo;\n    }\n  }\n  return hi;\n}\n\n}  // namespace\n\nstd::unique_ptr<TimeZoneLibC> TimeZoneLibC::Make(const std::string& name) {\n  return std::unique_ptr<TimeZoneLibC>(new TimeZoneLibC(name));\n}\n\ntime_zone::absolute_lookup TimeZoneLibC::BreakTime(\n    const time_point<seconds>& tp) const {\n  time_zone::absolute_lookup al;\n  al.offset = 0;\n  al.is_dst = false;\n  al.abbr = \"-00\";\n\n  const std::int_fast64_t s = ToUnixSeconds(tp);\n\n  // If std::time_t cannot hold the input we saturate the output.\n  if (s < std::numeric_limits<std::time_t>::min()) {\n    al.cs = civil_second::min();\n    return al;\n  }\n  if (s > std::numeric_limits<std::time_t>::max()) {\n    al.cs = civil_second::max();\n    return al;\n  }\n\n  const std::time_t t = static_cast<std::time_t>(s);\n  std::tm tm;\n  std::tm* tmp = local_ ? local_time(&t, &tm) : gm_time(&t, &tm);\n\n  // If std::tm cannot hold the result we saturate the output.\n  if (tmp == nullptr) {\n    al.cs = (s < 0) ? civil_second::min() : civil_second::max();\n    return al;\n  }\n\n  const year_t year = tmp->tm_year + year_t{1900};\n  al.cs = civil_second(year, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour,\n                       tmp->tm_min, tmp->tm_sec);\n  al.offset = static_cast<int>(tm_gmtoff(*tmp));\n  al.abbr = local_ ? tm_zone(*tmp) : \"UTC\";  // as expected by cctz\n  al.is_dst = tmp->tm_isdst > 0;\n  return al;\n}\n\ntime_zone::civil_lookup TimeZoneLibC::MakeTime(const civil_second& cs) const {\n  if (!local_) {\n    // If time_point<seconds> cannot hold the result we saturate.\n    static const civil_second min_tp_cs =\n        civil_second() + ToUnixSeconds(time_point<seconds>::min());\n    static const civil_second max_tp_cs =\n        civil_second() + ToUnixSeconds(time_point<seconds>::max());\n    const time_point<seconds> tp = (cs < min_tp_cs) ? time_point<seconds>::min()\n                                   : (cs > max_tp_cs)\n                                       ? time_point<seconds>::max()\n                                       : FromUnixSeconds(cs - civil_second());\n    return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};\n  }\n\n  // If tm_year cannot hold the requested year we saturate the result.\n  if (cs.year() < 0) {\n    if (cs.year() < std::numeric_limits<int>::min() + year_t{1900}) {\n      const time_point<seconds> tp = time_point<seconds>::min();\n      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};\n    }\n  } else {\n    if (cs.year() - year_t{1900} > std::numeric_limits<int>::max()) {\n      const time_point<seconds> tp = time_point<seconds>::max();\n      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};\n    }\n  }\n\n  // We probe with \"is_dst\" values of 0 and 1 to try to distinguish unique\n  // civil seconds from skipped or repeated ones.  This is not always possible\n  // however, as the \"dst\" flag does not change over some offset transitions.\n  // We are also subject to the vagaries of mktime() implementations. For\n  // example, some implementations treat \"tm_isdst\" as a demand (useless),\n  // and some as a disambiguator (useful).\n  std::time_t t0, t1;\n  std::tm tm0, tm1;\n  if (make_time(cs, 0, &t0, &tm0) && make_time(cs, 1, &t1, &tm1)) {\n    if (tm0.tm_isdst == tm1.tm_isdst) {\n      // The civil time was singular (pre == trans == post).\n      const time_point<seconds> tp = FromUnixSeconds(tm0.tm_isdst ? t1 : t0);\n      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};\n    }\n\n    tm_gmtoff_t offset = tm_gmtoff(tm0);\n    if (t0 < t1) {  // negative DST\n      std::swap(t0, t1);\n      offset = tm_gmtoff(tm1);\n    }\n\n    const std::time_t tt = find_trans(t1, t0, offset);\n    const time_point<seconds> trans = FromUnixSeconds(tt);\n\n    if (tm0.tm_isdst) {\n      // The civil time did not exist (pre >= trans > post).\n      const time_point<seconds> pre = FromUnixSeconds(t0);\n      const time_point<seconds> post = FromUnixSeconds(t1);\n      return {time_zone::civil_lookup::SKIPPED, pre, trans, post};\n    }\n\n    // The civil time was ambiguous (pre < trans <= post).\n    const time_point<seconds> pre = FromUnixSeconds(t1);\n    const time_point<seconds> post = FromUnixSeconds(t0);\n    return {time_zone::civil_lookup::REPEATED, pre, trans, post};\n  }\n\n  // make_time() failed somehow so we saturate the result.\n  const time_point<seconds> tp = (cs < civil_second())\n                                     ? time_point<seconds>::min()\n                                     : time_point<seconds>::max();\n  return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};\n}\n\nbool TimeZoneLibC::NextTransition(const time_point<seconds>&,\n                                  time_zone::civil_transition*) const {\n  return false;\n}\n\nbool TimeZoneLibC::PrevTransition(const time_point<seconds>&,\n                                  time_zone::civil_transition*) const {\n  return false;\n}\n\nstd::string TimeZoneLibC::Version() const {\n  return std::string();  // unknown\n}\n\nstd::string TimeZoneLibC::Description() const {\n  return local_ ? \"localtime\" : \"UTC\";\n}\n\nTimeZoneLibC::TimeZoneLibC(const std::string& name)\n    : local_(name == \"localtime\") {}\n\n}  // namespace cctz\n}  // namespace time_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03247",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_libc.cc",
  "source_line": 36,
  "validation_status": "validated"
}