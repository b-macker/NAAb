{
  "code": "#include <atomic>\n#include \"absl/base/attributes.h\"\n#include \"absl/debugging/internal/elf_mem_image.h\"\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05470_execute() {\n    {\n public:\n  VDSOSupport();\n\n  typedef ElfMemImage::SymbolInfo SymbolInfo;\n  typedef ElfMemImage::SymbolIterator SymbolIterator;\n\n  // On PowerPC64 VDSO symbols can either be of type STT_FUNC or STT_NOTYPE\n  // depending on how the kernel is built.  The kernel is normally built with\n  // STT_NOTYPE type VDSO symbols.  Let's make things simpler first by using a\n  // compile-time constant.\n#ifdef __powerpc64__\n  enum { kVDSOSymbolType = STT_NOTYPE };\n#else\n  enum { kVDSOSymbolType = STT_FUNC };\n#endif\n\n  // Answers whether we have a vdso at all.\n  bool IsPresent() const { return image_.IsPresent(); }\n\n  // Allow to iterate over all VDSO symbols.\n  SymbolIterator begin() const { return image_.begin(); }\n  SymbolIterator end() const { return image_.end(); }\n\n  // Look up versioned dynamic symbol in the kernel VDSO.\n  // Returns false if VDSO is not present, or doesn't contain given\n  // symbol/version/type combination.\n  // If info_out != nullptr, additional details are filled in.\n  bool LookupSymbol(const char *name, const char *version,\n                    int symbol_type, SymbolInfo *info_out) const;\n\n  // Find info about symbol (if any) which overlaps given address.\n  // Returns true if symbol was found; false if VDSO isn't present\n  // or doesn't have a symbol overlapping given address.\n  // If info_out != nullptr, additional details are filled in.\n  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;\n\n  // Used only for testing. Replace real VDSO base with a mock.\n  // Returns previous value of vdso_base_. After you are done testing,\n  // you are expected to call SetBase() with previous value, in order to\n  // reset state to the way it was.\n  const void *SetBase(const void *s);\n\n  // Computes vdso_base_ and returns it. Should be called as early as\n  // possible; before any thread creation, chroot or setuid.\n  static const void *Init();\n\n private:\n  // image_ represents VDSO ELF image in memory.\n  // image_.ehdr_ == nullptr implies there is no VDSO.\n  ElfMemImage image_;\n\n  // Cached value of auxv AT_SYSINFO_EHDR, computed once.\n  // This is a tri-state:\n  //   kInvalidBase   => value hasn't been determined yet.\n  //              0   => there is no VDSO.\n  //           else   => vma of VDSO Elf{32,64}_Ehdr.\n  //\n  // When testing with mock VDSO, low bit is set.\n  // The low bit is always available because vdso_base_ is\n  // page-aligned.\n  static std::atomic<const void *> vdso_base_;\n\n  // NOLINT on 'long' because these routines mimic kernel api.\n  // The 'cache' parameter may be used by some versions of the kernel,\n  // and should be nullptr or point to a static buffer containing at\n  // least two 'long's.\n  static long InitAndGetCPU(unsigned *cpu, void *cache,     // NOLINT 'long'.\n                            void *unused);\n  static long GetCPUViaSyscall(unsigned *cpu, void *cache,  // NOLINT 'long'.\n                               void *unused);\n  typedef long (*GetCpuFn)(unsigned *cpu, void *cache,      // NOLINT 'long'.\n                           void *unused);\n\n  // This function pointer may point to InitAndGetCPU,\n  // GetCPUViaSyscall, or __vdso_getcpu at different stages of initialization.\n  ABSL_CONST_INIT static std::atomic<GetCpuFn> getcpu_fn_;\n\n  friend int GetCPU(void);  // Needs access to getcpu_fn_.\n\n  VDSOSupport(const VDSOSupport&) = delete;\n  VDSOSupport& operator=(const VDSOSupport&) = delete;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05470",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/vdso_support.h",
  "source_line": 61,
  "validation_status": "validated"
}