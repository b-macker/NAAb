{
  "code": "{\n\n/// A RecursiveASTVisitor subclass that guarantees that AST traversal is\n/// performed in a lexical order (i.e. the order in which declarations are\n/// written in the source).\n///\n/// RecursiveASTVisitor doesn't guarantee lexical ordering because there are\n/// some declarations, like Objective-C @implementation declarations\n/// that might be represented in the AST differently to how they were written\n/// in the source.\n/// In particular, Objective-C @implementation declarations may contain\n/// non-Objective-C declarations, like functions:\n///\n///   @implementation MyClass\n///\n///   - (void) method { }\n///   void normalFunction() { }\n///\n///   @end\n///\n/// Clang's AST stores these declarations outside of the @implementation\n/// declaration, so the example above would be represented using the following\n/// AST:\n///   |-ObjCImplementationDecl ... MyClass\n///   | `-ObjCMethodDecl ... method\n///   |    ...\n///   `-FunctionDecl ... normalFunction\n///       ...\n///\n/// This class ensures that these declarations are traversed before the\n/// corresponding TraverseDecl for the @implementation returns. This ensures\n/// that the lexical parent relationship between these declarations and the\n/// @implementation is preserved while traversing the AST. Note that the\n/// current implementation doesn't mix these declarations with the declarations\n/// contained in the @implementation, so the traversal of all of the\n/// declarations in the @implementation still doesn't follow the lexical order.\ntemplate <typename Derived>\nclass LexicallyOrderedRecursiveASTVisitor\n    : public RecursiveASTVisitor<Derived> {\n  using BaseType = RecursiveASTVisitor<Derived>;\n\npublic:\n  LexicallyOrderedRecursiveASTVisitor(const SourceManager &SM) : SM(SM) {}\n\n  bool TraverseObjCImplementationDecl(ObjCImplementationDecl *D) {\n    // Objective-C @implementation declarations should not trigger early exit\n    // until the additional decls are traversed as their children are not\n    // lexically ordered.\n    bool Result = BaseType::TraverseObjCImplementationDecl(D);\n    return TraverseAdditionalLexicallyNestedDeclarations() ? Result : false;\n  }\n\n  bool TraverseObjCCategoryImplDecl(ObjCCategoryImplDecl *D) {\n    bool Result = BaseType::TraverseObjCCategoryImplDecl(D);\n    return TraverseAdditionalLexicallyNestedDeclarations() ? Result : false;\n  }\n\n  bool TraverseDeclContextHelper(DeclContext *DC) {\n    if (!DC)\n      return true;\n\n    for (auto I = DC->decls_begin(), E = DC->decls_end(); I != E;) {\n      Decl *Child = *I;\n      if (BaseType::canIgnoreChildDeclWhileTraversingDeclContext(Child)) {\n        ++I;\n        continue;\n      }\n      if (!isa<ObjCImplementationDecl>(Child) &&\n          !isa<ObjCCategoryImplDecl>(Child)) {\n        if (!BaseType::getDerived().TraverseDecl(Child))\n          return false;\n        ++I;\n        continue;\n      }\n      // Gather declarations that follow the Objective-C implementation\n      // declarations but are lexically contained in the implementation.\n      LexicallyNestedDeclarations.clear();\n      for (++I; I != E; ++I) {\n        Decl *Sibling = *I;\n        if (!SM.isBeforeInTranslationUnit(Sibling->getBeginLoc(),\n                                          Child->getEndLoc()))\n          break;\n        if (!BaseType::canIgnoreChildDeclWhileTraversingDeclContext(Sibling))\n          LexicallyNestedDeclarations.push_back(Sibling);\n      }\n      if (!BaseType::getDerived().TraverseDecl(Child))\n        return false;\n    }\n    return true;\n  }\n\n  Stmt::child_range getStmtChildren(Stmt *S) { return S->children(); }\n\n  SmallVector<Stmt *, 8> getStmtChildren(CXXOperatorCallExpr *CE) {\n    SmallVector<Stmt *, 8> Children(CE->children());\n    bool Swap;\n    // Switch the operator and the first operand for all infix and postfix\n    // operations.\n    switch (CE->getOperator()) {\n    case OO_Arrow:\n    case OO_Call:\n    case OO_Subscript:\n      Swap = true;\n      break;\n    case OO_PlusPlus:\n    case OO_MinusMinus:\n      // These are postfix unless there is exactly one argument.\n      Swap = Children.size() != 2;\n      break;\n    default:\n      Swap = CE->isInfixBinaryOp();\n      break;\n    }\n    if (Swap && Children.size() > 1)\n      std::swap(Children[0], Children[1]);\n    return Children;\n  }\n\nprivate:\n  bool TraverseAdditionalLexicallyNestedDeclarations() {\n    // FIXME: Ideally the gathered declarations and the declarations in the\n    // @implementation should be mixed and sorted to get a true lexical order,\n    // but right now we only care about getting the correct lexical parent, so\n    // we can traverse the gathered nested declarations after the declarations\n    // in the decl context.\n    assert(!BaseType::getDerived().shouldTraversePostOrder() &&\n           \"post-order traversal is not supported for lexically ordered \"\n           \"recursive ast visitor\");\n    for (Decl *D : LexicallyNestedDeclarations) {\n      if (!BaseType::getDerived().TraverseDecl(D))\n        return false;\n    }\n    return true;\n  }\n\n  const SourceManager &SM;\n  llvm::SmallVector<Decl *, 8> LexicallyNestedDeclarations;\n};\n\n}",
  "id": "BLOCK-CPP-11274",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/LexicallyOrderedRecursiveASTVisitor.h",
  "source_line": 22,
  "validation_status": "validated"
}