{
  "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/port.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/strings/has_absl_stringify.h\"\n#include \"absl/strings/internal/resize_uninitialized.h\"\n#include \"absl/strings/internal/stringify_sink.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace of;\nusing namespace as;\nusing namespace absl;\nusing namespace strings_internal;\nusing namespace strings_internal;\nusing namespace strings_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04123_execute() {\n    {\n\n// Do not call directly - this is not part of the public API.\nstd::string CatPieces(std::initializer_list<absl::string_view> pieces);\nvoid AppendPieces(absl::Nonnull<std::string*> dest,\n                  std::initializer_list<absl::string_view> pieces);\n\nvoid STLStringAppendUninitializedAmortized(std::string* dest, size_t to_append);\n\n// `SingleArgStrCat` overloads take built-in `int`, `long` and `long long` types\n// (signed / unsigned) to avoid ambiguity on the call side. If we used int32_t\n// and int64_t, then at least one of the three (`int` / `long` / `long long`)\n// would have been ambiguous when passed to `SingleArgStrCat`.\nstd::string SingleArgStrCat(int x);\nstd::string SingleArgStrCat(unsigned int x);\nstd::string SingleArgStrCat(long x);                // NOLINT\nstd::string SingleArgStrCat(unsigned long x);       // NOLINT\nstd::string SingleArgStrCat(long long x);           // NOLINT\nstd::string SingleArgStrCat(unsigned long long x);  // NOLINT\nstd::string SingleArgStrCat(float x);\nstd::string SingleArgStrCat(double x);\n\n// `SingleArgStrAppend` overloads are defined here for the same reasons as with\n// `SingleArgStrCat` above.\nvoid SingleArgStrAppend(std::string& str, int x);\nvoid SingleArgStrAppend(std::string& str, unsigned int x);\nvoid SingleArgStrAppend(std::string& str, long x);                // NOLINT\nvoid SingleArgStrAppend(std::string& str, unsigned long x);       // NOLINT\nvoid SingleArgStrAppend(std::string& str, long long x);           // NOLINT\nvoid SingleArgStrAppend(std::string& str, unsigned long long x);  // NOLINT\n\ntemplate <typename T,\n          typename = std::enable_if_t<std::is_arithmetic<T>::value &&\n                                      !std::is_same<T, char>::value &&\n                                      !std::is_same<T, bool>::value>>\nusing EnableIfFastCase = T;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04123",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_cat.h",
  "source_line": 444,
  "validation_status": "validated"
}