{
  "code": "{\n    enum {\n      CI_None = 0x00,\n      CI_AllowsMemory = 0x01,\n      CI_AllowsRegister = 0x02,\n      CI_ReadWrite = 0x04,         // \"+r\" output constraint (read and write).\n      CI_HasMatchingInput = 0x08,  // This output operand has a matching input.\n      CI_ImmediateConstant = 0x10, // This operand must be an immediate constant\n      CI_EarlyClobber = 0x20,      // \"&\" output constraint (early clobber).\n    };\n    unsigned Flags;\n    int TiedOperand;\n    struct {\n      int Min;\n      int Max;\n      bool isConstrained;\n    } ImmRange;\n    llvm::SmallSet<int, 4> ImmSet;\n\n    std::string ConstraintStr;  // constraint: \"=rm\"\n    std::string Name;           // Operand name: [foo] with no []'s.\n  public:\n    ConstraintInfo(StringRef ConstraintStr, StringRef Name)\n        : Flags(0), TiedOperand(-1), ConstraintStr(ConstraintStr.str()),\n          Name(Name.str()) {\n      ImmRange.Min = ImmRange.Max = 0;\n      ImmRange.isConstrained = false;\n    }\n\n    const std::string &getConstraintStr() const { return ConstraintStr; }\n    const std::string &getName() const { return Name; }\n    bool isReadWrite() const { return (Flags & CI_ReadWrite) != 0; }\n    bool earlyClobber() { return (Flags & CI_EarlyClobber) != 0; }\n    bool allowsRegister() const { return (Flags & CI_AllowsRegister) != 0; }\n    bool allowsMemory() const { return (Flags & CI_AllowsMemory) != 0; }\n\n    /// Return true if this output operand has a matching\n    /// (tied) input operand.\n    bool hasMatchingInput() const { return (Flags & CI_HasMatchingInput) != 0; }\n\n    /// Return true if this input operand is a matching\n    /// constraint that ties it to an output operand.\n    ///\n    /// If this returns true then getTiedOperand will indicate which output\n    /// operand this is tied to.\n    bool hasTiedOperand() const { return TiedOperand != -1; }\n    unsigned getTiedOperand() const {\n      assert(hasTiedOperand() && \"Has no tied operand!\");\n      return (unsigned)TiedOperand;\n    }\n\n    bool requiresImmediateConstant() const {\n      return (Flags & CI_ImmediateConstant) != 0;\n    }\n    bool isValidAsmImmediate(const llvm::APInt &Value) const {\n      if (!ImmSet.empty())\n        return Value.isSignedIntN(32) && ImmSet.contains(Value.getZExtValue());\n      return !ImmRange.isConstrained ||\n             (Value.sge(ImmRange.Min) && Value.sle(ImmRange.Max));\n    }\n\n    void setIsReadWrite() { Flags |= CI_ReadWrite; }\n    void setEarlyClobber() { Flags |= CI_EarlyClobber; }\n    void setAllowsMemory() { Flags |= CI_AllowsMemory; }\n    void setAllowsRegister() { Flags |= CI_AllowsRegister; }\n    void setHasMatchingInput() { Flags |= CI_HasMatchingInput; }\n    void setRequiresImmediate(int Min, int Max) {\n      Flags |= CI_ImmediateConstant;\n      ImmRange.Min = Min;\n      ImmRange.Max = Max;\n      ImmRange.isConstrained = true;\n    }\n    void setRequiresImmediate(llvm::ArrayRef<int> Exacts) {\n      Flags |= CI_ImmediateConstant;\n      for (int Exact : Exacts)\n        ImmSet.insert(Exact);\n    }\n    void setRequiresImmediate(int Exact) {\n      Flags |= CI_ImmediateConstant;\n      ImmSet.insert(Exact);\n    }\n    void setRequiresImmediate() {\n      Flags |= CI_ImmediateConstant;\n    }\n\n    /// Indicate that this is an input operand that is tied to\n    /// the specified output operand.\n    ///\n    /// Copy over the various constraint information from the output.\n    void setTiedOperand(unsigned N, ConstraintInfo &Output) {\n      Output.setHasMatchingInput();\n      Flags = Output.Flags;\n      TiedOperand = N;\n      // Don't copy Name or constraint string.\n    }\n  }",
  "id": "BLOCK-CPP-17341",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/TargetInfo.h",
  "source_line": 1035,
  "validation_status": "validated"
}