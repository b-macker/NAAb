{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace status_internal {\n\nvoid StatusRep::Unref() const {\n  // Fast path: if ref==1, there is no need for a RefCountDec (since\n  // this is the only reference and therefore no other thread is\n  // allowed to be mucking with r).\n  if (ref_.load(std::memory_order_acquire) == 1 ||\n      ref_.fetch_sub(1, std::memory_order_acq_rel) - 1 == 0) {\n    delete this;\n  }\n}\n\nstatic absl::optional<size_t> FindPayloadIndexByUrl(\n    const Payloads* payloads, absl::string_view type_url) {\n  if (payloads == nullptr) return absl::nullopt;\n\n  for (size_t i = 0; i < payloads->size(); ++i) {\n    if ((*payloads)[i].type_url == type_url) return i;\n  }\n\n  return absl::nullopt;\n}\n\nabsl::optional<absl::Cord> StatusRep::GetPayload(\n    absl::string_view type_url) const {\n  absl::optional<size_t> index =\n      status_internal::FindPayloadIndexByUrl(payloads_.get(), type_url);\n  if (index.has_value()) return (*payloads_)[index.value()].payload;\n\n  return absl::nullopt;\n}\n\nvoid StatusRep::SetPayload(absl::string_view type_url, absl::Cord payload) {\n  if (payloads_ == nullptr) {\n    payloads_ = absl::make_unique<status_internal::Payloads>();\n  }\n\n  absl::optional<size_t> index =\n      status_internal::FindPayloadIndexByUrl(payloads_.get(), type_url);\n  if (index.has_value()) {\n    (*payloads_)[index.value()].payload = std::move(payload);\n    return;\n  }\n\n  payloads_->push_back({std::string(type_url), std::move(payload)});\n}\n\nStatusRep::EraseResult StatusRep::ErasePayload(absl::string_view type_url) {\n  absl::optional<size_t> index =\n      status_internal::FindPayloadIndexByUrl(payloads_.get(), type_url);\n  if (!index.has_value()) return {false, Status::PointerToRep(this)};\n  payloads_->erase(payloads_->begin() + index.value());\n  if (payloads_->empty() && message_.empty()) {\n    // Special case: If this can be represented inlined, it MUST be inlined\n    // (== depends on this behavior).\n    EraseResult result = {true, Status::CodeToInlinedRep(code_)};\n    Unref();\n    return result;\n  }\n  return {true, Status::PointerToRep(this)};\n}\n\nvoid StatusRep::ForEachPayload(\n    absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)\n    const {\n  if (auto* payloads = payloads_.get()) {\n    bool in_reverse =\n        payloads->size() > 1 && reinterpret_cast<uintptr_t>(payloads) % 13 > 6;\n\n    for (size_t index = 0; index < payloads->size(); ++index) {\n      const auto& elem =\n          (*payloads)[in_reverse ? payloads->size() - 1 - index : index];\n\n#ifdef NDEBUG\n      visitor(elem.type_url, elem.payload);\n#else\n      // In debug mode invalidate the type url to prevent users from relying on\n      // this string lifetime.\n\n      // NOLINTNEXTLINE intentional extra conversion to force temporary.\n      visitor(std::string(elem.type_url), elem.payload);\n#endif  // NDEBUG\n    }\n  }\n}\n\nstd::string StatusRep::ToString(StatusToStringMode mode) const {\n  std::string text;\n  absl::StrAppend(&text, absl::StatusCodeToString(code()), \": \", message());\n\n  const bool with_payload = (mode & StatusToStringMode::kWithPayload) ==\n                            StatusToStringMode::kWithPayload;\n\n  if (with_payload) {\n    status_internal::StatusPayloadPrinter printer =\n        status_internal::GetStatusPayloadPrinter();\n    this->ForEachPayload([&](absl::string_view type_url,\n                             const absl::Cord& payload) {\n      absl::optional<std::string> result;\n      if (printer) result = printer(type_url, payload);\n      absl::StrAppend(\n          &text, \" [\", type_url, \"='\",\n          result.has_value() ? *result : absl::CHexEscape(std::string(payload)),\n          \"']\");\n    });\n  }\n\n  return text;\n}\n\nbool StatusRep::operator==(const StatusRep& other) const {\n  assert(this != &other);\n  if (code_ != other.code_) return false;\n  if (message_ != other.message_) return false;\n  const status_internal::Payloads* this_payloads = payloads_.get();\n  const status_internal::Payloads* other_payloads = other.payloads_.get();\n\n  const status_internal::Payloads no_payloads;\n  const status_internal::Payloads* larger_payloads =\n      this_payloads ? this_payloads : &no_payloads;\n  const status_internal::Payloads* smaller_payloads =\n      other_payloads ? other_payloads : &no_payloads;\n  if (larger_payloads->size() < smaller_payloads->size()) {\n    std::swap(larger_payloads, smaller_payloads);\n  }\n  if ((larger_payloads->size() - smaller_payloads->size()) > 1) return false;\n  // Payloads can be ordered differently, so we can't just compare payload\n  // vectors.\n  for (const auto& payload : *larger_payloads) {\n\n    bool found = false;\n    for (const auto& other_payload : *smaller_payloads) {\n      if (payload.type_url == other_payload.type_url) {\n        if (payload.payload != other_payload.payload) {\n          return false;\n        }\n        found = true;\n        break;\n      }\n    }\n    if (!found) return false;\n  }\n  return true;\n}\n\nabsl::Nonnull<StatusRep*> StatusRep::CloneAndUnref() const {\n  // Optimization: no need to create a clone if we already have a refcount of 1.\n  if (ref_.load(std::memory_order_acquire) == 1) {\n    // All StatusRep instances are heap allocated and mutable, therefore this\n    // const_cast will never cast away const from a stack instance.\n    //\n    // CloneAndUnref is the only method that doesn't involve an external cast to\n    // get a mutable StatusRep* from the uintptr_t rep stored in Status.\n    return const_cast<StatusRep*>(this);\n  }\n  std::unique_ptr<status_internal::Payloads> payloads;\n  if (payloads_) {\n    payloads = absl::make_unique<status_internal::Payloads>(*payloads_);\n  }\n  auto* new_rep = new StatusRep(code_, message_, std::move(payloads));\n  Unref();\n  return new_rep;\n}\n\n// Convert canonical code to a value known to this binary.\nabsl::StatusCode MapToLocalCode(int value) {\n  absl::StatusCode code = static_cast<absl::StatusCode>(value);\n  switch (code) {\n    case absl::StatusCode::kOk:\n    case absl::StatusCode::kCancelled:\n    case absl::StatusCode::kUnknown:\n    case absl::StatusCode::kInvalidArgument:\n    case absl::StatusCode::kDeadlineExceeded:\n    case absl::StatusCode::kNotFound:\n    case absl::StatusCode::kAlreadyExists:\n    case absl::StatusCode::kPermissionDenied:\n    case absl::StatusCode::kResourceExhausted:\n    case absl::StatusCode::kFailedPrecondition:\n    case absl::StatusCode::kAborted:\n    case absl::StatusCode::kOutOfRange:\n    case absl::StatusCode::kUnimplemented:\n    case absl::StatusCode::kInternal:\n    case absl::StatusCode::kUnavailable:\n    case absl::StatusCode::kDataLoss:\n    case absl::StatusCode::kUnauthenticated:\n      return code;\n    default:\n      return absl::StatusCode::kUnknown;\n  }\n}\n\nabsl::Nonnull<std::string*> MakeCheckFailString(\n    absl::Nonnull<const absl::Status*> status,\n    absl::Nonnull<const char*> prefix) {\n  return new std::string(\n      absl::StrCat(prefix, \" (\",\n                   status->ToString(StatusToStringMode::kWithEverything), \")\"));\n}\n\n}  // namespace status_internal\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02853",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/internal/status_internal.cc",
  "source_line": 44,
  "validation_status": "validated"
}