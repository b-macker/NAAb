{
  "code": "{\nclass DynTypedNodeList;\n\nclass ParentMapContext {\npublic:\n  ParentMapContext(ASTContext &Ctx);\n\n  ~ParentMapContext();\n\n  /// Returns the parents of the given node (within the traversal scope).\n  ///\n  /// Note that this will lazily compute the parents of all nodes\n  /// and store them for later retrieval. Thus, the first call is O(n)\n  /// in the number of AST nodes.\n  ///\n  /// Caveats and FIXMEs:\n  /// Calculating the parent map over all AST nodes will need to load the\n  /// full AST. This can be undesirable in the case where the full AST is\n  /// expensive to create (for example, when using precompiled header\n  /// preambles). Thus, there are good opportunities for optimization here.\n  /// One idea is to walk the given node downwards, looking for references\n  /// to declaration contexts - once a declaration context is found, compute\n  /// the parent map for the declaration context; if that can satisfy the\n  /// request, loading the whole AST can be avoided. Note that this is made\n  /// more complex by statements in templates having multiple parents - those\n  /// problems can be solved by building closure over the templated parts of\n  /// the AST, which also avoids touching large parts of the AST.\n  /// Additionally, we will want to add an interface to already give a hint\n  /// where to search for the parents, for example when looking at a statement\n  /// inside a certain function.\n  ///\n  /// 'NodeT' can be one of Decl, Stmt, Type, TypeLoc,\n  /// NestedNameSpecifier or NestedNameSpecifierLoc.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  DynTypedNodeList getParents(const DynTypedNode &Node);\n\n  /// Clear parent maps.\n  void clear();\n\n  TraversalKind getTraversalKind() const { return Traversal; }\n  void setTraversalKind(TraversalKind TK) { Traversal = TK; }\n\n  const Expr *traverseIgnored(const Expr *E) const;\n  Expr *traverseIgnored(Expr *E) const;\n  DynTypedNode traverseIgnored(const DynTypedNode &N) const;\n\n  class ParentMap;\n\nprivate:\n  ASTContext &ASTCtx;\n  TraversalKind Traversal = TK_AsIs;\n  std::unique_ptr<ParentMap> Parents;\n};\n\nclass TraversalKindScope {\n  ParentMapContext &Ctx;\n  TraversalKind TK = TK_AsIs;\n\npublic:\n  TraversalKindScope(ASTContext &ASTCtx, std::optional<TraversalKind> ScopeTK)\n      : Ctx(ASTCtx.getParentMapContext()) {\n    TK = Ctx.getTraversalKind();\n    if (ScopeTK)\n      Ctx.setTraversalKind(*ScopeTK);\n  }\n\n  ~TraversalKindScope() { Ctx.setTraversalKind(TK); }\n};\n\n/// Container for either a single DynTypedNode or for an ArrayRef to\n/// DynTypedNode. For use with ParentMap.\nclass DynTypedNodeList {\n  union {\n    DynTypedNode SingleNode;\n    ArrayRef<DynTypedNode> Nodes;\n  };\n  bool IsSingleNode;\n\npublic:\n  DynTypedNodeList(const DynTypedNode &N) : IsSingleNode(true) {\n    new (&SingleNode) DynTypedNode(N);\n  }\n\n  DynTypedNodeList(ArrayRef<DynTypedNode> A) : IsSingleNode(false) {\n    new (&Nodes) ArrayRef<DynTypedNode>(A);\n  }\n\n  const DynTypedNode *begin() const {\n    return !IsSingleNode ? Nodes.begin() : &SingleNode;\n  }\n\n  const DynTypedNode *end() const {\n    return !IsSingleNode ? Nodes.end() : &SingleNode + 1;\n  }\n\n  size_t size() const { return end() - begin(); }\n  bool empty() const { return begin() == end(); }\n\n  const DynTypedNode &operator[](size_t N) const {\n    assert(N < size() && \"Out of bounds!\");\n    return *(begin() + N);\n  }\n};\n\ntemplate <typename NodeT>\ninline DynTypedNodeList ParentMapContext::getParents(const NodeT &Node) {\n  return getParents(DynTypedNode::create(Node));\n}\n\ntemplate <typename NodeT>\ninline DynTypedNodeList ASTContext::getParents(const NodeT &Node) {\n  return getParentMapContext().getParents(Node);\n}\n\ntemplate <>\ninline DynTypedNodeList ASTContext::getParents(const DynTypedNode &Node) {\n  return getParentMapContext().getParents(Node);\n}\n\n}",
  "id": "BLOCK-CPP-12321",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ParentMapContext.h",
  "source_line": 20,
  "validation_status": "validated"
}