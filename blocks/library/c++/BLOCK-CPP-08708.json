{
  "code": "{\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n}",
  "id": "BLOCK-CPP-08708",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 2664,
  "validation_status": "validated"
}