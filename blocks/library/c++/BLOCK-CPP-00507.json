{
  "code": "{\n    std::vector<char> buffer_;\n\npublic:\n    sid_t() {}\n\n    /** creates a wrapped SID copy */\n    static sid_t duplicate_sid(PSID psid) {\n        if (!::IsValidSid(psid)) {\n            throw_spdlog_ex(\"sid_t::sid_t(): invalid SID received\");\n        }\n\n        auto const sid_length{::GetLengthSid(psid)};\n\n        sid_t result;\n        result.buffer_.resize(sid_length);\n        if (!::CopySid(sid_length, (PSID)result.as_sid(), psid)) {\n            SPDLOG_THROW(win32_error(\"CopySid\"));\n        }\n\n        return result;\n    }\n\n    /** Retrieves pointer to the internal buffer contents as SID* */\n    SID *as_sid() const { return buffer_.empty() ? nullptr : (SID *)buffer_.data(); }\n\n    /** Get SID for the current user */\n    static sid_t get_current_user_sid() {\n        /* create and init RAII holder for process token */\n        struct process_token_t {\n            HANDLE token_handle_ = INVALID_HANDLE_VALUE;\n            explicit process_token_t(HANDLE process) {\n                if (!::OpenProcessToken(process, TOKEN_QUERY, &token_handle_)) {\n                    SPDLOG_THROW(win32_error(\"OpenProcessToken\"));\n                }\n            }\n\n            ~process_token_t() { ::CloseHandle(token_handle_); }\n\n        } current_process_token(\n            ::GetCurrentProcess());  // GetCurrentProcess returns pseudohandle, no leak here!\n\n        // Get the required size, this is expected to fail with ERROR_INSUFFICIENT_BUFFER and return\n        // the token size\n        DWORD tusize = 0;\n        if (::GetTokenInformation(current_process_token.token_handle_, TokenUser, NULL, 0,\n                                  &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation should fail\"));\n        }\n\n        // get user token\n        std::vector<unsigned char> buffer(static_cast<size_t>(tusize));\n        if (!::GetTokenInformation(current_process_token.token_handle_, TokenUser,\n                                   (LPVOID)buffer.data(), tusize, &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation\"));\n        }\n\n        // create a wrapper of the SID data as stored in the user token\n        return sid_t::duplicate_sid(((TOKEN_USER *)buffer.data())->User.Sid);\n    }\n}",
  "id": "BLOCK-CPP-00507",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/win_eventlog_sink.h",
  "source_line": 93,
  "validation_status": "validated"
}