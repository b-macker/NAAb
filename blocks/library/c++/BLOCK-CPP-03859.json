{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// absl::gaussian_distribution_base implements the underlying ziggurat algorithm\n// using the ziggurat tables generated by the gaussian_distribution_gentables\n// binary.\n//\n// The specific algorithm has some of the improvements suggested by the\n// 2005 paper, \"An Improved Ziggurat Method to Generate Normal Random Samples\",\n// Jurgen A Doornik.  (https://www.doornik.com/research/ziggurat.pdf)\nclass ABSL_DLL gaussian_distribution_base {\n public:\n  template <typename URBG>\n  inline double zignor(URBG& g);  // NOLINT(runtime/references)\n\n private:\n  friend class TableGenerator;\n\n  template <typename URBG>\n  inline double zignor_fallback(URBG& g,  // NOLINT(runtime/references)\n                                bool neg);\n\n  // Constants used for the gaussian distribution.\n  static constexpr double kR = 3.442619855899;  // Start of the tail.\n  static constexpr double kRInv = 0.29047645161474317;  // ~= (1.0 / kR) .\n  static constexpr double kV = 9.91256303526217e-3;\n  static constexpr uint64_t kMask = 0x07f;\n\n  // The ziggurat tables store the pdf(f) and inverse-pdf(x) for equal-area\n  // points on one-half of the normal distribution, where the pdf function,\n  // pdf = e ^ (-1/2 *x^2), assumes that the mean = 0 & stddev = 1.\n  //\n  // These tables are just over 2kb in size; larger tables might improve the\n  // distributions, but also lead to more cache pollution.\n  //\n  // x = {3.71308, 3.44261, 3.22308, ..., 0}\n  // f = {0.00101, 0.00266, 0.00554, ..., 1}\n  struct Tables {\n    double x[kMask + 2];\n    double f[kMask + 2];\n  };\n  static const Tables zg_;\n  random_internal::FastUniformBits<uint64_t> fast_u64_;\n};\n\n}  // namespace random_internal\n\n// absl::gaussian_distribution:\n// Generates a number conforming to a Gaussian distribution.\ntemplate <typename RealType = double>\nclass gaussian_distribution : random_internal::gaussian_distribution_base {\n public:\n  using result_type = RealType;\n\n  class param_type {\n   public:\n    using distribution_type = gaussian_distribution;\n\n    explicit param_type(result_type mean = 0, result_type stddev = 1)\n        : mean_(mean), stddev_(stddev) {}\n\n    // Returns the mean distribution parameter.  The mean specifies the location\n    // of the peak.  The default value is 0.0.\n    result_type mean() const { return mean_; }\n\n    // Returns the deviation distribution parameter.  The default value is 1.0.\n    result_type stddev() const { return stddev_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.mean_ == b.mean_ && a.stddev_ == b.stddev_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    result_type mean_;\n    result_type stddev_;\n\n    static_assert(\n        std::is_floating_point<RealType>::value,\n        \"Class-template absl::gaussian_distribution<> must be parameterized \"\n        \"using a floating-point type.\");\n  };\n\n  gaussian_distribution() : gaussian_distribution(0) {}\n\n  explicit gaussian_distribution(result_type mean, result_type stddev = 1)\n      : param_(mean, stddev) {}\n\n  explicit gaussian_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // Generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const {\n    return -std::numeric_limits<result_type>::infinity();\n  }\n  result_type(max)() const {\n    return std::numeric_limits<result_type>::infinity();\n  }\n\n  result_type mean() const { return param_.mean(); }\n  result_type stddev() const { return param_.stddev(); }\n\n  friend bool operator==(const gaussian_distribution& a,\n                         const gaussian_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const gaussian_distribution& a,\n                         const gaussian_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n};\n\n// --------------------------------------------------------------------------\n// Implementation details only below\n// --------------------------------------------------------------------------\n\ntemplate <typename RealType>\ntemplate <typename URBG>\ntypename gaussian_distribution<RealType>::result_type\ngaussian_distribution<RealType>::operator()(\n    URBG& g,  // NOLINT(runtime/references)\n    const param_type& p) {\n  return p.mean() + p.stddev() * static_cast<result_type>(zignor(g));\n}\n\ntemplate <typename CharT, typename Traits, typename RealType>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n    const gaussian_distribution<RealType>& x) {\n  auto saver = random_internal::make_ostream_state_saver(os);\n  os.precision(random_internal::stream_precision_helper<RealType>::kPrecision);\n  os << x.mean() << os.fill() << x.stddev();\n  return os;\n}\n\ntemplate <typename CharT, typename Traits, typename RealType>\nstd::basic_istream<CharT, Traits>& operator>>(\n    std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n    gaussian_distribution<RealType>& x) {   // NOLINT(runtime/references)\n  using result_type = typename gaussian_distribution<RealType>::result_type;\n  using param_type = typename gaussian_distribution<RealType>::param_type;\n\n  auto saver = random_internal::make_istream_state_saver(is);\n  auto mean = random_internal::read_floating_point<result_type>(is);\n  if (is.fail()) return is;\n  auto stddev = random_internal::read_floating_point<result_type>(is);\n  if (!is.fail()) {\n    x.param(param_type(mean, stddev));\n  }\n  return is;\n}\n\nnamespace random_internal {\n\ntemplate <typename URBG>\ninline double gaussian_distribution_base::zignor_fallback(URBG& g, bool neg) {\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n\n  // This fallback path happens approximately 0.05% of the time.\n  double x, y;\n  do {\n    // kRInv = 1/r, U(0, 1)\n    x = kRInv *\n        std::log(GenerateRealFromBits<double, GeneratePositiveTag, false>(\n            fast_u64_(g)));\n    y = -std::log(\n        GenerateRealFromBits<double, GeneratePositiveTag, false>(fast_u64_(g)));\n  } while ((y + y) < (x * x));\n  return neg ? (x - kR) : (kR - x);\n}\n\ntemplate <typename URBG>\ninline double gaussian_distribution_base::zignor(\n    URBG& g) {  // NOLINT(runtime/references)\n  using random_internal::GeneratePositiveTag;\n  using random_internal::GenerateRealFromBits;\n  using random_internal::GenerateSignedTag;\n\n  while (true) {\n    // We use a single uint64_t to generate both a double and a strip.\n    // These bits are unused when the generated double is > 1/2^5.\n    // This may introduce some bias from the duplicated low bits of small\n    // values (those smaller than 1/2^5, which all end up on the left tail).\n    uint64_t bits = fast_u64_(g);\n    int i = static_cast<int>(bits & kMask);  // pick a random strip\n    double j = GenerateRealFromBits<double, GenerateSignedTag, false>(\n        bits);  // U(-1, 1)\n    const double x = j * zg_.x[i];\n\n    // Retangular box. Handles >97% of all cases.\n    // For any given box, this handles between 75% and 99% of values.\n    // Equivalent to U(01) < (x[i+1] / x[i]), and when i == 0, ~93.5%\n    if (std::abs(x) < zg_.x[i + 1]) {\n      return x;\n    }\n\n    // i == 0: Base box. Sample using a ratio of uniforms.\n    if (i == 0) {\n      // This path happens about 0.05% of the time.\n      return zignor_fallback(g, j < 0);\n    }\n\n    // i > 0: Wedge samples using precomputed values.\n    double v = GenerateRealFromBits<double, GeneratePositiveTag, false>(\n        fast_u64_(g));  // U(0, 1)\n    if ((zg_.f[i + 1] + v * (zg_.f[i] - zg_.f[i + 1])) <\n        std::exp(-0.5 * x * x)) {\n      return x;\n    }\n\n    // The wedge was missed; reject the value and try again.\n  }\n}\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03859",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/gaussian_distribution.h",
  "source_line": 36,
  "validation_status": "validated"
}