{
  "code": "#include \"absl/strings/internal/str_format/float_conversion.h\"\n#include <string.h>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <limits>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/functional/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/numeric/internal/representation.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03063_execute() {\n    {\n  const size_t total_digits =\n      /* 0 */ 1 + (state.ShouldPrintDot() ? state.precision + 1 : 0);\n  auto padding =\n      ExtraWidthToPadding(total_digits + (state.sign_char ? 1 : 0), state);\n  padding.zeros += 1;\n  state.sink->Append(padding.left_spaces, ' ');\n  if (state.sign_char != '\\0') state.sink->Append(1, state.sign_char);\n  state.sink->Append(padding.zeros, '0');\n\n  if (state.ShouldPrintDot()) state.sink->Append(1, '.');\n\n  // Print digits\n  size_t digits_to_go = state.precision;\n\n  FractionalDigitGenerator::RunConversion(\n      v, exp, [&](FractionalDigitGenerator digit_gen) {\n        // There are no digits to print here.\n        if (state.precision == 0) return;\n\n        // We go one digit at a time, while keeping track of runs of nines.\n        // The runs of nines are used to perform rounding when necessary.\n\n        while (digits_to_go > 0 && digit_gen.HasMoreDigits()) {\n          auto digits = digit_gen.GetDigits();\n\n          // Now we have a digit and a run of nines.\n          // See if we can print them all.\n          if (digits.num_nines + 1 < digits_to_go) {\n            // We don't have to round yet, so print them.\n            state.sink->Append(1, digits.digit_before_nine + '0');\n            state.sink->Append(digits.num_nines, '9');\n            digits_to_go -= digits.num_nines + 1;\n\n          } else {\n            // We can't print all the nines, see where we have to truncate.\n\n            bool round_up = false;\n            if (digits.num_nines + 1 > digits_to_go) {\n              // We round up at a nine. No need to print them.\n              round_up = true;\n            } else {\n              // We can fit all the nines, but truncate just after it.\n              if (digit_gen.IsGreaterThanHalf()) {\n                round_up = true;\n              } else if (digit_gen.IsExactlyHalf()) {\n                // Round to even\n                round_up =\n                    digits.num_nines != 0 || digits.digit_before_nine % 2 == 1;\n              }\n            }\n\n            if (round_up) {\n              state.sink->Append(1, digits.digit_before_nine + '1');\n              --digits_to_go;\n              // The rest will be zeros.\n            } else {\n              state.sink->Append(1, digits.digit_before_nine + '0');\n              state.sink->Append(digits_to_go - 1, '9');\n              digits_to_go = 0;\n            }\n            return;\n          }\n        }\n      });\n\n  state.sink->Append(digits_to_go, '0');\n  state.sink->Append(padding.right_spaces, ' ');\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03063",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 606,
  "validation_status": "validated"
}