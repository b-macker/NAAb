{
  "code": "{\n  FPOptions Options = FPOptions::getFromOpaqueInt(0);\n  FPOptions::storage_type OverrideMask = 0;\n\npublic:\n  using RoundingMode = llvm::RoundingMode;\n\n  /// The type suitable for storing values of FPOptionsOverride. Must be twice\n  /// as wide as bit size of FPOption.\n  using storage_type = uint64_t;\n  static_assert(sizeof(storage_type) >= 2 * sizeof(FPOptions::storage_type),\n                \"Too short type for FPOptionsOverride\");\n\n  /// Bit mask selecting bits of OverrideMask in serialized representation of\n  /// FPOptionsOverride.\n  static constexpr storage_type OverrideMaskBits =\n      (static_cast<storage_type>(1) << FPOptions::StorageBitSize) - 1;\n\n  FPOptionsOverride() {}\n  FPOptionsOverride(const LangOptions &LO)\n      : Options(LO), OverrideMask(OverrideMaskBits) {}\n  FPOptionsOverride(FPOptions FPO)\n      : Options(FPO), OverrideMask(OverrideMaskBits) {}\n  FPOptionsOverride(FPOptions FPO, FPOptions::storage_type Mask)\n      : Options(FPO), OverrideMask(Mask) {}\n\n  bool requiresTrailingStorage() const { return OverrideMask != 0; }\n\n  void setAllowFPContractWithinStatement() {\n    setFPContractModeOverride(LangOptions::FPM_On);\n  }\n\n  void setAllowFPContractAcrossStatement() {\n    setFPContractModeOverride(LangOptions::FPM_Fast);\n  }\n\n  void setDisallowFPContract() {\n    setFPContractModeOverride(LangOptions::FPM_Off);\n  }\n\n  void setFPPreciseEnabled(bool Value) {\n    setAllowFPReassociateOverride(!Value);\n    setNoHonorNaNsOverride(!Value);\n    setNoHonorInfsOverride(!Value);\n    setNoSignedZeroOverride(!Value);\n    setAllowReciprocalOverride(!Value);\n    setAllowApproxFuncOverride(!Value);\n    if (Value)\n      /* Precise mode implies fp_contract=on and disables ffast-math */\n      setAllowFPContractWithinStatement();\n    else\n      /* Precise mode disabled sets fp_contract=fast and enables ffast-math */\n      setAllowFPContractAcrossStatement();\n  }\n\n  storage_type getAsOpaqueInt() const {\n    return (static_cast<storage_type>(Options.getAsOpaqueInt())\n            << FPOptions::StorageBitSize) |\n           OverrideMask;\n  }\n  static FPOptionsOverride getFromOpaqueInt(storage_type I) {\n    FPOptionsOverride Opts;\n    Opts.OverrideMask = I & OverrideMaskBits;\n    Opts.Options = FPOptions::getFromOpaqueInt(I >> FPOptions::StorageBitSize);\n    return Opts;\n  }\n\n  FPOptions applyOverrides(FPOptions Base) {\n    FPOptions Result =\n        FPOptions::getFromOpaqueInt((Base.getAsOpaqueInt() & ~OverrideMask) |\n                                     (Options.getAsOpaqueInt() & OverrideMask));\n    return Result;\n  }\n\n  FPOptions applyOverrides(const LangOptions &LO) {\n    return applyOverrides(FPOptions(LO));\n  }\n\n  bool operator==(FPOptionsOverride other) const {\n    return Options == other.Options && OverrideMask == other.OverrideMask;\n  }\n  bool operator!=(FPOptionsOverride other) const { return !(*this == other); }\n\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  bool has##NAME##Override() const {                                           \\\n    return OverrideMask & FPOptions::NAME##Mask;                               \\\n  }                                                                            \\\n  TYPE get##NAME##Override() const {                                           \\\n    assert(has##NAME##Override());                                             \\\n    return Options.get##NAME();                                                \\\n  }                                                                            \\\n  void clear##NAME##Override() {                                               \\\n    /* Clear the actual value so that we don't have spurious differences when  \\\n     * testing equality. */                                                    \\\n    Options.set##NAME(TYPE(0));                                                \\\n    OverrideMask &= ~FPOptions::NAME##Mask;                                    \\\n  }                                                                            \\\n  void set##NAME##Override(TYPE value) {                                       \\\n    Options.set##NAME(value);                                                  \\\n    OverrideMask |= FPOptions::NAME##Mask;                                     \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n}",
  "id": "BLOCK-CPP-16564",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/LangOptions.h",
  "source_line": 810,
  "validation_status": "validated"
}