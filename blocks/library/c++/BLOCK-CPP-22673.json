{
  "code": "{\nclass ConceptDecl;\n\n/// The result of a constraint satisfaction check, containing the necessary\n/// information to diagnose an unsatisfied constraint.\nclass ConstraintSatisfaction : public llvm::FoldingSetNode {\n  // The template-like entity that 'owns' the constraint checked here (can be a\n  // constrained entity or a concept).\n  const NamedDecl *ConstraintOwner = nullptr;\n  llvm::SmallVector<TemplateArgument, 4> TemplateArgs;\n\npublic:\n\n  ConstraintSatisfaction() = default;\n\n  ConstraintSatisfaction(const NamedDecl *ConstraintOwner,\n                         ArrayRef<TemplateArgument> TemplateArgs) :\n      ConstraintOwner(ConstraintOwner), TemplateArgs(TemplateArgs.begin(),\n                                                     TemplateArgs.end()) { }\n\n  using SubstitutionDiagnostic = std::pair<SourceLocation, StringRef>;\n  using Detail = llvm::PointerUnion<Expr *, SubstitutionDiagnostic *>;\n\n  bool IsSatisfied = false;\n  bool ContainsErrors = false;\n\n  /// \\brief Pairs of unsatisfied atomic constraint expressions along with the\n  /// substituted constraint expr, if the template arguments could be\n  /// substituted into them, or a diagnostic if substitution resulted in an\n  /// invalid expression.\n  llvm::SmallVector<std::pair<const Expr *, Detail>, 4> Details;\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n    Profile(ID, C, ConstraintOwner, TemplateArgs);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C,\n                      const NamedDecl *ConstraintOwner,\n                      ArrayRef<TemplateArgument> TemplateArgs);\n\n  bool HasSubstitutionFailure() {\n    for (const auto &Detail : Details)\n      if (Detail.second.dyn_cast<SubstitutionDiagnostic *>())\n        return true;\n    return false;\n  }\n};\n\n/// Pairs of unsatisfied atomic constraint expressions along with the\n/// substituted constraint expr, if the template arguments could be\n/// substituted into them, or a diagnostic if substitution resulted in\n/// an invalid expression.\nusing UnsatisfiedConstraintRecord =\n    std::pair<const Expr *,\n              llvm::PointerUnion<Expr *,\n                                 std::pair<SourceLocation, StringRef> *>>;\n\n/// \\brief The result of a constraint satisfaction check, containing the\n/// necessary information to diagnose an unsatisfied constraint.\n///\n/// This is safe to store in an AST node, as opposed to ConstraintSatisfaction.\nstruct ASTConstraintSatisfaction final :\n    llvm::TrailingObjects<ASTConstraintSatisfaction,\n                          UnsatisfiedConstraintRecord> {\n  std::size_t NumRecords;\n  bool IsSatisfied : 1;\n  bool ContainsErrors : 1;\n\n  const UnsatisfiedConstraintRecord *begin() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>();\n  }\n\n  const UnsatisfiedConstraintRecord *end() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>() + NumRecords;\n  }\n\n  ASTConstraintSatisfaction(const ASTContext &C,\n                            const ConstraintSatisfaction &Satisfaction);\n  ASTConstraintSatisfaction(const ASTContext &C,\n                            const ASTConstraintSatisfaction &Satisfaction);\n\n  static ASTConstraintSatisfaction *\n  Create(const ASTContext &C, const ConstraintSatisfaction &Satisfaction);\n  static ASTConstraintSatisfaction *\n  Rebuild(const ASTContext &C, const ASTConstraintSatisfaction &Satisfaction);\n};\n\n/// \\brief Common data class for constructs that reference concepts with\n/// template arguments.\nclass ConceptReference {\nprotected:\n  // \\brief The optional nested name specifier used when naming the concept.\n  NestedNameSpecifierLoc NestedNameSpec;\n\n  /// \\brief The location of the template keyword, if specified when naming the\n  /// concept.\n  SourceLocation TemplateKWLoc;\n\n  /// \\brief The concept name used.\n  DeclarationNameInfo ConceptName;\n\n  /// \\brief The declaration found by name lookup when the expression was\n  /// created.\n  /// Can differ from NamedConcept when, for example, the concept was found\n  /// through a UsingShadowDecl.\n  NamedDecl *FoundDecl;\n\n  /// \\brief The concept named.\n  ConceptDecl *NamedConcept;\n\n  /// \\brief The template argument list source info used to specialize the\n  /// concept.\n  const ASTTemplateArgumentListInfo *ArgsAsWritten;\n\npublic:\n  ConceptReference(NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                   DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                   ConceptDecl *NamedConcept,\n                   const ASTTemplateArgumentListInfo *ArgsAsWritten)\n      : NestedNameSpec(NNS), TemplateKWLoc(TemplateKWLoc),\n        ConceptName(ConceptNameInfo), FoundDecl(FoundDecl),\n        NamedConcept(NamedConcept), ArgsAsWritten(ArgsAsWritten) {}\n\n  ConceptReference()\n      : FoundDecl(nullptr), NamedConcept(nullptr), ArgsAsWritten(nullptr) {}\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return NestedNameSpec;\n  }\n\n  const DeclarationNameInfo &getConceptNameInfo() const { return ConceptName; }\n\n  SourceLocation getConceptNameLoc() const {\n    return getConceptNameInfo().getLoc();\n  }\n\n  SourceLocation getTemplateKWLoc() const { return TemplateKWLoc; }\n\n  NamedDecl *getFoundDecl() const {\n    return FoundDecl;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return NamedConcept;\n  }\n\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief Whether or not template arguments were explicitly specified in the\n  /// concept reference (they might not be in type constraints, for example)\n  bool hasExplicitTemplateArgs() const {\n    return ArgsAsWritten != nullptr;\n  }\n};\n\nclass TypeConstraint : public ConceptReference {\n  /// \\brief The immediately-declared constraint expression introduced by this\n  /// type-constraint.\n  Expr *ImmediatelyDeclaredConstraint = nullptr;\n\npublic:\n  TypeConstraint(NestedNameSpecifierLoc NNS,\n                 DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                 ConceptDecl *NamedConcept,\n                 const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                 Expr *ImmediatelyDeclaredConstraint) :\n      ConceptReference(NNS, /*TemplateKWLoc=*/SourceLocation(), ConceptNameInfo,\n                       FoundDecl, NamedConcept, ArgsAsWritten),\n      ImmediatelyDeclaredConstraint(ImmediatelyDeclaredConstraint) {}\n\n  /// \\brief Get the immediately-declared constraint expression introduced by\n  /// this type-constraint, that is - the constraint expression that is added to\n  /// the associated constraints of the enclosing declaration in practice.\n  Expr *getImmediatelyDeclaredConstraint() const {\n    return ImmediatelyDeclaredConstraint;\n  }\n\n  void print(llvm::raw_ostream &OS, PrintingPolicy Policy) const;\n};\n\n}",
  "id": "BLOCK-CPP-22673",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTConcept.h",
  "source_line": 23,
  "validation_status": "validated"
}