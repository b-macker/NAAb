{
  "code": "#include \"clang/AST/BaseSubobject.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/Thunk.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <memory>\n#include <utility>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-14657_execute() {\n    {\npublic:\n  typedef SmallVector<ThunkInfo, 1> ThunkInfoVectorTy;\n\n  bool isMicrosoft() const { return IsMicrosoftABI; }\n\n  virtual ~VTableContextBase() {}\n\nprotected:\n  typedef llvm::DenseMap<const CXXMethodDecl *, ThunkInfoVectorTy> ThunksMapTy;\n\n  /// Contains all thunks that a given method decl will need.\n  ThunksMapTy Thunks;\n\n  /// Compute and store all vtable related information (vtable layout, vbase\n  /// offset offsets, thunks etc) for the given record decl.\n  virtual void computeVTableRelatedInformation(const CXXRecordDecl *RD) = 0;\n\n  VTableContextBase(bool MS) : IsMicrosoftABI(MS) {}\n\npublic:\n  virtual const ThunkInfoVectorTy *getThunkInfo(GlobalDecl GD) {\n    const CXXMethodDecl *MD = cast<CXXMethodDecl>(GD.getDecl()->getCanonicalDecl());\n    computeVTableRelatedInformation(MD->getParent());\n\n    // This assumes that all the destructors present in the vtable\n    // use exactly the same set of thunks.\n    ThunksMapTy::const_iterator I = Thunks.find(MD);\n    if (I == Thunks.end()) {\n      // We did not find a thunk for this method.\n      return nullptr;\n    }\n\n    return &I->second;\n  }\n\n  bool IsMicrosoftABI;\n\n  /// Determine whether this function should be assigned a vtable slot.\n  static bool hasVtableSlot(const CXXMethodDecl *MD);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-14657",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/VTableBuilder.h",
  "source_line": 321,
  "validation_status": "validated"
}