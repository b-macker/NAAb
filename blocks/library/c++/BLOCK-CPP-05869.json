{
  "code": "#include <cstdint>\n#include <cstring>\n#include <limits>\n#include <type_traits>\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/random/internal/fastmath.h\"\n#include \"absl/random/internal/traits.h\"\n\nusing namespace absl;\nusing namespace random_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05869_execute() {\n    {\n  using real_type = RealType;\n  using uint_type = absl::conditional_t<std::is_same<real_type, float>::value,\n                                        uint32_t, uint64_t>;\n\n  static_assert(\n      (std::is_same<double, real_type>::value ||\n       std::is_same<float, real_type>::value),\n      \"GenerateRealFromBits must be parameterized by either float or double.\");\n\n  static_assert(sizeof(uint_type) == sizeof(real_type),\n                \"Mismatched unsigned and real types.\");\n\n  static_assert((std::numeric_limits<real_type>::is_iec559 &&\n                 std::numeric_limits<real_type>::radix == 2),\n                \"RealType representation is not IEEE 754 binary.\");\n\n  static_assert((std::is_same<SignedTag, GeneratePositiveTag>::value ||\n                 std::is_same<SignedTag, GenerateNegativeTag>::value ||\n                 std::is_same<SignedTag, GenerateSignedTag>::value),\n                \"\");\n\n  static constexpr int kExp = std::numeric_limits<real_type>::digits - 1;\n  static constexpr uint_type kMask = (static_cast<uint_type>(1) << kExp) - 1u;\n  static constexpr int kUintBits = sizeof(uint_type) * 8;\n\n  int exp = exp_bias + int{std::numeric_limits<real_type>::max_exponent - 2};\n\n  // Determine the sign bit.\n  // Depending on the SignedTag, this may use the left-most bit\n  // or it may be a constant value.\n  uint_type sign = std::is_same<SignedTag, GenerateNegativeTag>::value\n                       ? (static_cast<uint_type>(1) << (kUintBits - 1))\n                       : 0;\n  if (std::is_same<SignedTag, GenerateSignedTag>::value) {\n    if (std::is_same<uint_type, uint64_t>::value) {\n      sign = bits & uint64_t{0x8000000000000000};\n    }\n    if (std::is_same<uint_type, uint32_t>::value) {\n      const uint64_t tmp = bits & uint64_t{0x8000000000000000};\n      sign = static_cast<uint32_t>(tmp >> 32);\n    }\n    // adjust the bits and the exponent to account for removing\n    // the leading bit.\n    bits = bits & uint64_t{0x7FFFFFFFFFFFFFFF};\n    exp++;\n  }\n  if (IncludeZero) {\n    if (bits == 0u) return 0;\n  }\n\n  // Number of leading zeros is mapped to the exponent: 2^-clz\n  // bits is 0..01xxxxxx. After shifting, we're left with 1xxx...0..0\n  int clz = countl_zero(bits);\n  bits <<= (IncludeZero ? clz : (clz & 63));  // remove 0-bits.\n  exp -= clz;                                 // set the exponent.\n  bits >>= (63 - kExp);\n\n  // Construct the 32-bit or 64-bit IEEE 754 floating-point value from\n  // the individual fields: sign, exp, mantissa(bits).\n  uint_type val = sign | (static_cast<uint_type>(exp) << kExp) |\n                  (static_cast<uint_type>(bits) & kMask);\n\n  // bit_cast to the output-type\n  real_type result;\n  memcpy(static_cast<void*>(&result), static_cast<const void*>(&val),\n         sizeof(result));\n  return result;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05869",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/generate_real.h",
  "source_line": 65,
  "validation_status": "validated"
}