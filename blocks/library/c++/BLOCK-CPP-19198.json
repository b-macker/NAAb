{
  "code": "#include \"clang/Basic/TokenKinds.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-19198_execute() {\n    {\n  class Preprocessor;\n  class Token;\n\n  /// TokenConcatenation class, which answers the question of\n  ///   \"Is it safe to emit two tokens without a whitespace between them, or\n  ///    would that cause implicit concatenation of the tokens?\"\n  ///\n  /// For example, it emitting two identifiers \"foo\" and \"bar\" next to each\n  /// other would cause the lexer to produce one \"foobar\" token.  Emitting \"1\"\n  /// and \")\" next to each other is safe.\n  ///\n  class TokenConcatenation {\n    const Preprocessor &PP;\n\n    enum AvoidConcatInfo {\n      /// By default, a token never needs to avoid concatenation.  Most tokens\n      /// (e.g. ',', ')', etc) don't cause a problem when concatenated.\n      aci_never_avoid_concat = 0,\n\n      /// aci_custom_firstchar - AvoidConcat contains custom code to handle this\n      /// token's requirements, and it needs to know the first character of the\n      /// token.\n      aci_custom_firstchar = 1,\n\n      /// aci_custom - AvoidConcat contains custom code to handle this token's\n      /// requirements, but it doesn't need to know the first character of the\n      /// token.\n      aci_custom = 2,\n\n      /// aci_avoid_equal - Many tokens cannot be safely followed by an '='\n      /// character.  For example, \"<<\" turns into \"<<=\" when followed by an =.\n      aci_avoid_equal = 4\n    };\n\n    /// TokenInfo - This array contains information for each token on what\n    /// action to take when avoiding concatenation of tokens in the AvoidConcat\n    /// method.\n    char TokenInfo[tok::NUM_TOKENS];\n  public:\n    TokenConcatenation(const Preprocessor &PP);\n\n    bool AvoidConcat(const Token &PrevPrevTok,\n                     const Token &PrevTok,\n                     const Token &Tok) const;\n\n  private:\n    /// IsIdentifierStringPrefix - Return true if the spelling of the token\n    /// is literally 'L', 'u', 'U', or 'u8'.\n    bool IsIdentifierStringPrefix(const Token &Tok) const;\n  };\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-19198",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/TokenConcatenation.h",
  "source_line": 18,
  "validation_status": "validated"
}