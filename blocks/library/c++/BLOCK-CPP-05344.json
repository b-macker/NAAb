{
  "code": "{\n    friend class raw_hash_set;\n    template <class Container, typename Enabler>\n    friend struct absl::container_internal::hashtable_debug_internal::\n        HashtableDebugAccess;\n\n   public:\n    using iterator_category = typename iterator::iterator_category;\n    using value_type = typename raw_hash_set::value_type;\n    using reference = typename raw_hash_set::const_reference;\n    using pointer = typename raw_hash_set::const_pointer;\n    using difference_type = typename raw_hash_set::difference_type;\n\n    const_iterator() = default;\n    // Implicit construction from iterator.\n    const_iterator(iterator i) : inner_(std::move(i)) {}  // NOLINT\n\n    reference operator*() const { return *inner_; }\n    pointer operator->() const { return inner_.operator->(); }\n\n    const_iterator& operator++() {\n      ++inner_;\n      return *this;\n    }\n    const_iterator operator++(int) { return inner_++; }\n\n    friend bool operator==(const const_iterator& a, const const_iterator& b) {\n      return a.inner_ == b.inner_;\n    }\n    friend bool operator!=(const const_iterator& a, const const_iterator& b) {\n      return !(a == b);\n    }\n\n   private:\n    const_iterator(const ctrl_t* ctrl, const slot_type* slot,\n                   const GenerationType* gen)\n        : inner_(const_cast<ctrl_t*>(ctrl), const_cast<slot_type*>(slot), gen) {\n    }\n    ctrl_t* control() const { return inner_.control(); }\n    slot_type* slot() const { return inner_.slot(); }\n\n    iterator inner_;\n\n    bool unchecked_equals(const const_iterator& b) {\n      return inner_.unchecked_equals(b.inner_);\n    }\n  }",
  "id": "BLOCK-CPP-05344",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 2032,
  "validation_status": "validated"
}