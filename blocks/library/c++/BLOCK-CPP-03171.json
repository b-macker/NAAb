{
  "code": "{\n public:\n  NodeSet() { Init(); }\n\n  void clear() { Init(); }\n  bool contains(int32_t v) const { return table_[FindIndex(v)] == v; }\n\n  bool insert(int32_t v) {\n    uint32_t i = FindIndex(v);\n    if (table_[i] == v) {\n      return false;\n    }\n    if (table_[i] == kEmpty) {\n      // Only inserting over an empty cell increases the number of occupied\n      // slots.\n      occupied_++;\n    }\n    table_[i] = v;\n    // Double when 75% full.\n    if (occupied_ >= table_.size() - table_.size()/4) Grow();\n    return true;\n  }\n\n  void erase(int32_t v) {\n    uint32_t i = FindIndex(v);\n    if (table_[i] == v) {\n      table_[i] = kDel;\n    }\n  }\n\n  // Iteration: is done via HASH_FOR_EACH\n  // Example:\n  //    HASH_FOR_EACH(elem, node->out) { ... }\n#define HASH_FOR_EACH(elem, eset) \\\n  for (int32_t elem, _cursor = 0; (eset).Next(&_cursor, &elem); )\n  bool Next(int32_t* cursor, int32_t* elem) {\n    while (static_cast<uint32_t>(*cursor) < table_.size()) {\n      int32_t v = table_[static_cast<uint32_t>(*cursor)];\n      (*cursor)++;\n      if (v >= 0) {\n        *elem = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n private:\n  enum : int32_t { kEmpty = -1, kDel = -2 };\n  Vec<int32_t> table_;\n  uint32_t occupied_;     // Count of non-empty slots (includes deleted slots)\n\n  static uint32_t Hash(int32_t a) { return static_cast<uint32_t>(a * 41); }\n\n  // Return index for storing v.  May return an empty index or deleted index\n  uint32_t FindIndex(int32_t v) const {\n    // Search starting at hash index.\n    const uint32_t mask = table_.size() - 1;\n    uint32_t i = Hash(v) & mask;\n    uint32_t deleted_index = 0;  // index of first deleted element we see\n    bool seen_deleted_element = false;\n    while (true) {\n      int32_t e = table_[i];\n      if (v == e) {\n        return i;\n      } else if (e == kEmpty) {\n        // Return any previously encountered deleted slot.\n        return seen_deleted_element ? deleted_index : i;\n      } else if (e == kDel && !seen_deleted_element) {\n        // Keep searching since v might be present later.\n        deleted_index = i;\n        seen_deleted_element = true;\n      }\n      i = (i + 1) & mask;  // Linear probing; quadratic is slightly slower.\n    }\n  }\n\n  void Init() {\n    table_.clear();\n    table_.resize(kInline);\n    table_.fill(kEmpty);\n    occupied_ = 0;\n  }\n\n  void Grow() {\n    Vec<int32_t> copy;\n    copy.MoveFrom(&table_);\n    occupied_ = 0;\n    table_.resize(copy.size() * 2);\n    table_.fill(kEmpty);\n\n    for (const auto& e : copy) {\n      if (e >= 0) insert(e);\n    }\n  }\n\n  NodeSet(const NodeSet&) = delete;\n  NodeSet& operator=(const NodeSet&) = delete;\n}",
  "id": "BLOCK-CPP-03171",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/graphcycles.cc",
  "source_line": 162,
  "validation_status": "validated"
}