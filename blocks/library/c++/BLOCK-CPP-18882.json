{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <string>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18882_execute() {\n    {\n\nclass PragmaNamespace;\nclass Preprocessor;\nclass Token;\n\n  /**\n   * Describes how the pragma was introduced, e.g., with \\#pragma,\n   * _Pragma, or __pragma.\n   */\n  enum PragmaIntroducerKind {\n    /**\n     * The pragma was introduced via \\#pragma.\n     */\n    PIK_HashPragma,\n\n    /**\n     * The pragma was introduced via the C99 _Pragma(string-literal).\n     */\n    PIK__Pragma,\n\n    /**\n     * The pragma was introduced via the Microsoft\n     * __pragma(token-string).\n     */\n    PIK___pragma\n  };\n\n  /// Describes how and where the pragma was introduced.\n  struct PragmaIntroducer {\n    PragmaIntroducerKind Kind;\n    SourceLocation Loc;\n  };\n\n/// PragmaHandler - Instances of this interface defined to handle the various\n/// pragmas that the language front-end uses.  Each handler optionally has a\n/// name (e.g. \"pack\") and the HandlePragma method is invoked when a pragma with\n/// that identifier is found.  If a handler does not match any of the declared\n/// pragmas the handler with a null identifier is invoked, if it exists.\n///\n/// Note that the PragmaNamespace class can be used to subdivide pragmas, e.g.\n/// we treat \"\\#pragma STDC\" and \"\\#pragma GCC\" as namespaces that contain other\n/// pragmas.\nclass PragmaHandler {\n  std::string Name;\n\npublic:\n  PragmaHandler() = default;\n  explicit PragmaHandler(StringRef name) : Name(name) {}\n  virtual ~PragmaHandler();\n\n  StringRef getName() const { return Name; }\n  virtual void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                            Token &FirstToken) = 0;\n\n  /// getIfNamespace - If this is a namespace, return it.  This is equivalent to\n  /// using a dynamic_cast, but doesn't require RTTI.\n  virtual PragmaNamespace *getIfNamespace() { return nullptr; }\n};\n\n/// EmptyPragmaHandler - A pragma handler which takes no action, which can be\n/// used to ignore particular pragmas.\nclass EmptyPragmaHandler : public PragmaHandler {\npublic:\n  explicit EmptyPragmaHandler(StringRef Name = StringRef());\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &FirstToken) override;\n};\n\n/// PragmaNamespace - This PragmaHandler subdivides the namespace of pragmas,\n/// allowing hierarchical pragmas to be defined.  Common examples of namespaces\n/// are \"\\#pragma GCC\", \"\\#pragma STDC\", and \"\\#pragma omp\", but any namespaces\n/// may be (potentially recursively) defined.\nclass PragmaNamespace : public PragmaHandler {\n  /// Handlers - This is a map of the handlers in this namespace with their name\n  /// as key.\n  llvm::StringMap<std::unique_ptr<PragmaHandler>> Handlers;\n\npublic:\n  explicit PragmaNamespace(StringRef Name) : PragmaHandler(Name) {}\n\n  /// FindHandler - Check to see if there is already a handler for the\n  /// specified name.  If not, return the handler for the null name if it\n  /// exists, otherwise return null.  If IgnoreNull is true (the default) then\n  /// the null handler isn't returned on failure to match.\n  PragmaHandler *FindHandler(StringRef Name,\n                             bool IgnoreNull = true) const;\n\n  /// AddPragma - Add a pragma to this namespace.\n  void AddPragma(PragmaHandler *Handler);\n\n  /// RemovePragmaHandler - Remove the given handler from the\n  /// namespace.\n  void RemovePragmaHandler(PragmaHandler *Handler);\n\n  bool IsEmpty() const { return Handlers.empty(); }\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &Tok) override;\n\n  PragmaNamespace *getIfNamespace() override { return this; }\n};\n\n/// Destringize a \\c _Pragma(\"\") string according to C11 6.10.9.1:\n/// \"The string literal is destringized by deleting any encoding prefix,\n/// deleting the leading and trailing double-quotes, replacing each escape\n/// sequence \\\" by a double-quote, and replacing each escape sequence \\\\ by a\n/// single backslash.\"\nvoid prepare_PragmaString(SmallVectorImpl<char> &StrVal);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18882",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/Pragma.h",
  "source_line": 22,
  "validation_status": "validated"
}