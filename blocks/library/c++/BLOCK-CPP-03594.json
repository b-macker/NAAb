{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// Flag\n//\n// An `absl::Flag` holds a command-line flag value, providing a runtime\n// parameter to a binary. Such flags should be defined in the global namespace\n// and (preferably) in the module containing the binary's `main()` function.\n//\n// You should not construct and cannot use the `absl::Flag` type directly;\n// instead, you should declare flags using the `ABSL_DECLARE_FLAG()` macro\n// within a header file, and define your flag using `ABSL_FLAG()` within your\n// header's associated `.cc` file. Such flags will be named `FLAGS_name`.\n//\n// Example:\n//\n//    .h file\n//\n//      // Declares usage of a flag named \"FLAGS_count\"\n//      ABSL_DECLARE_FLAG(int, count);\n//\n//    .cc file\n//\n//      // Defines a flag named \"FLAGS_count\" with a default `int` value of 0.\n//      ABSL_FLAG(int, count, 0, \"Count of items to process\");\n//\n// No public methods of `absl::Flag<T>` are part of the Abseil Flags API.\n//\n// For type support of Abseil Flags, see the marshalling.h header file, which\n// discusses supported standard types, optional flags, and additional Abseil\n// type support.\n\ntemplate <typename T>\nusing Flag = flags_internal::Flag<T>;\n\n// GetFlag()\n//\n// Returns the value (of type `T`) of an `absl::Flag<T>` instance, by value. Do\n// not construct an `absl::Flag<T>` directly and call `absl::GetFlag()`;\n// instead, refer to flag's constructed variable name (e.g. `FLAGS_name`).\n// Because this function returns by value and not by reference, it is\n// thread-safe, but note that the operation may be expensive; as a result, avoid\n// `absl::GetFlag()` within any tight loops.\n//\n// Example:\n//\n//   // FLAGS_count is a Flag of type `int`\n//   int my_count = absl::GetFlag(FLAGS_count);\n//\n//   // FLAGS_firstname is a Flag of type `std::string`\n//   std::string first_name = absl::GetFlag(FLAGS_firstname);\ntemplate <typename T>\nABSL_MUST_USE_RESULT T GetFlag(const absl::Flag<T>& flag) {\n  return flags_internal::FlagImplPeer::InvokeGet<T>(flag);\n}\n\n// SetFlag()\n//\n// Sets the value of an `absl::Flag` to the value `v`. Do not construct an\n// `absl::Flag<T>` directly and call `absl::SetFlag()`; instead, use the\n// flag's variable name (e.g. `FLAGS_name`). This function is\n// thread-safe, but is potentially expensive. Avoid setting flags in general,\n// but especially within performance-critical code.\ntemplate <typename T>\nvoid SetFlag(absl::Flag<T>* flag, const T& v) {\n  flags_internal::FlagImplPeer::InvokeSet(*flag, v);\n}\n\n// Overload of `SetFlag()` to allow callers to pass in a value that is\n// convertible to `T`. E.g., use this overload to pass a \"const char*\" when `T`\n// is `std::string`.\ntemplate <typename T, typename V>\nvoid SetFlag(absl::Flag<T>* flag, const V& v) {\n  T value(v);\n  flags_internal::FlagImplPeer::InvokeSet(*flag, value);\n}\n\n// GetFlagReflectionHandle()\n//\n// Returns the reflection handle corresponding to specified Abseil Flag\n// instance. Use this handle to access flag's reflection information, like name,\n// location, default value etc.\n//\n// Example:\n//\n//   std::string = absl::GetFlagReflectionHandle(FLAGS_count).DefaultValue();\n\ntemplate <typename T>\nconst CommandLineFlag& GetFlagReflectionHandle(const absl::Flag<T>& f) {\n  return flags_internal::FlagImplPeer::InvokeReflect(f);\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03594",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/flag.h",
  "source_line": 43,
  "validation_status": "validated"
}