{
  "code": "#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18681_execute() {\n    {\n  const SourceManager &SM;\n  const LangOptions &Features;\n  const TargetInfo &Target;\n  DiagnosticsEngine *Diags;\n\n  unsigned MaxTokenLength;\n  unsigned SizeBound;\n  unsigned CharByteWidth;\n  tok::TokenKind Kind;\n  SmallString<512> ResultBuf;\n  char *ResultPtr; // cursor\n  SmallString<32> UDSuffixBuf;\n  unsigned UDSuffixToken;\n  unsigned UDSuffixOffset;\n  StringLiteralEvalMethod EvalMethod;\n\npublic:\n  StringLiteralParser(ArrayRef<Token> StringToks, Preprocessor &PP,\n                      StringLiteralEvalMethod StringMethod =\n                          StringLiteralEvalMethod::Evaluated);\n  StringLiteralParser(ArrayRef<Token> StringToks, const SourceManager &sm,\n                      const LangOptions &features, const TargetInfo &target,\n                      DiagnosticsEngine *diags = nullptr)\n      : SM(sm), Features(features), Target(target), Diags(diags),\n        MaxTokenLength(0), SizeBound(0), CharByteWidth(0), Kind(tok::unknown),\n        ResultPtr(ResultBuf.data()),\n        EvalMethod(StringLiteralEvalMethod::Evaluated), hadError(false),\n        Pascal(false) {\n    init(StringToks);\n  }\n\n  bool hadError;\n  bool Pascal;\n\n  StringRef GetString() const {\n    return StringRef(ResultBuf.data(), GetStringLength());\n  }\n  unsigned GetStringLength() const { return ResultPtr-ResultBuf.data(); }\n\n  unsigned GetNumStringChars() const {\n    return GetStringLength() / CharByteWidth;\n  }\n  /// getOffsetOfStringByte - This function returns the offset of the\n  /// specified byte of the string data represented by Token.  This handles\n  /// advancing over escape sequences in the string.\n  ///\n  /// If the Diagnostics pointer is non-null, then this will do semantic\n  /// checking of the string literal and emit errors and warnings.\n  unsigned getOffsetOfStringByte(const Token &TheTok, unsigned ByteNo) const;\n\n  bool isOrdinary() const { return Kind == tok::string_literal; }\n  bool isWide() const { return Kind == tok::wide_string_literal; }\n  bool isUTF8() const { return Kind == tok::utf8_string_literal; }\n  bool isUTF16() const { return Kind == tok::utf16_string_literal; }\n  bool isUTF32() const { return Kind == tok::utf32_string_literal; }\n  bool isPascal() const { return Pascal; }\n  bool isUnevaluated() const {\n    return EvalMethod == StringLiteralEvalMethod::Unevaluated;\n  }\n\n  StringRef getUDSuffix() const { return UDSuffixBuf; }\n\n  /// Get the index of a token containing a ud-suffix.\n  unsigned getUDSuffixToken() const {\n    assert(!UDSuffixBuf.empty() && \"no ud-suffix\");\n    return UDSuffixToken;\n  }\n  /// Get the spelling offset of the first byte of the ud-suffix.\n  unsigned getUDSuffixOffset() const {\n    assert(!UDSuffixBuf.empty() && \"no ud-suffix\");\n    return UDSuffixOffset;\n  }\n\n  static bool isValidUDSuffix(const LangOptions &LangOpts, StringRef Suffix);\n\nprivate:\n  void init(ArrayRef<Token> StringToks);\n  bool CopyStringFragment(const Token &Tok, const char *TokBegin,\n                          StringRef Fragment);\n  void DiagnoseLexingError(SourceLocation Loc);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18681",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/LiteralSupport.h",
  "source_line": 223,
  "validation_status": "validated"
}