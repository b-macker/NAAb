{
  "code": "{\n/// The format in which header information is emitted.\nenum HeaderIncludeFormatKind { HIFMT_None, HIFMT_Textual, HIFMT_JSON };\n\n/// Whether header information is filtered or not. If HIFIL_Only_Direct_System\n/// is used, only information on system headers directly included from\n/// non-system headers is emitted.\nenum HeaderIncludeFilteringKind { HIFIL_None, HIFIL_Only_Direct_System };\n\ninline HeaderIncludeFormatKind\nstringToHeaderIncludeFormatKind(const char *Str) {\n  return llvm::StringSwitch<HeaderIncludeFormatKind>(Str)\n      .Case(\"textual\", HIFMT_Textual)\n      .Case(\"json\", HIFMT_JSON)\n      .Default(HIFMT_None);\n}\n\ninline bool stringToHeaderIncludeFiltering(const char *Str,\n                                           HeaderIncludeFilteringKind &Kind) {\n  std::pair<bool, HeaderIncludeFilteringKind> P =\n      llvm::StringSwitch<std::pair<bool, HeaderIncludeFilteringKind>>(Str)\n          .Case(\"none\", {true, HIFIL_None})\n          .Case(\"only-direct-system\", {true, HIFIL_Only_Direct_System})\n          .Default({false, HIFIL_None});\n  Kind = P.second;\n  return P.first;\n}\n\ninline const char *headerIncludeFormatKindToString(HeaderIncludeFormatKind K) {\n  switch (K) {\n  case HIFMT_None:\n    llvm_unreachable(\"unexpected format kind\");\n  case HIFMT_Textual:\n    return \"textual\";\n  case HIFMT_JSON:\n    return \"json\";\n  }\n  llvm_unreachable(\"Unknown HeaderIncludeFormatKind enum\");\n}\n\ninline const char *\nheaderIncludeFilteringKindToString(HeaderIncludeFilteringKind K) {\n  switch (K) {\n  case HIFIL_None:\n    return \"none\";\n  case HIFIL_Only_Direct_System:\n    return \"only-direct-system\";\n  }\n  llvm_unreachable(\"Unknown HeaderIncludeFilteringKind enum\");\n}\n\n}",
  "id": "BLOCK-CPP-16408",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/HeaderInclude.h",
  "source_line": 20,
  "validation_status": "validated"
}