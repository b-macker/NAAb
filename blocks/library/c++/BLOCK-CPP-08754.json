{
  "code": "{\n///   friend int foo(T);\n///   friend class B;\n///   friend T; // only in C++0x\n///   template <typename U> friend class C;\n///   template <typename U> friend A& operator+=(A&, const U&) { ... }\n/// };\n/// @endcode\n///\n/// The semantic context of a friend decl is its declaring class.\nclass FriendDecl final\n    : public Decl,\n      private llvm::TrailingObjects<FriendDecl, TemplateParameterList *> {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *, TypeSourceInfo *>;\n\nprivate:\n  friend class CXXRecordDecl;\n  friend class CXXRecordDecl::friend_iterator;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // A pointer to the next friend in the sequence.\n  LazyDeclPtr NextFriend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  /// True if this 'friend' declaration is unsupported.  Eventually we\n  /// will support every possible friend declaration, but for now we\n  /// silently ignore some and set this flag to authorize all access.\n  unsigned UnsupportedFriend : 1;\n\n  // The number of \"outer\" template parameter lists in non-templatic\n  // (currently unsupported) friend type declarations, such as\n  //     template <class T> friend class A<T>::B;\n  unsigned NumTPLists : 31;\n\n  FriendDecl(DeclContext *DC, SourceLocation L, FriendUnion Friend,\n             SourceLocation FriendL,\n             ArrayRef<TemplateParameterList *> FriendTypeTPLists)\n      : Decl(Decl::Friend, DC, L), Friend(Friend), FriendLoc(FriendL),\n        UnsupportedFriend(false), NumTPLists(FriendTypeTPLists.size()) {\n    for (unsigned i = 0; i < NumTPLists; ++i)\n      getTrailingObjects<TemplateParameterList *>()[i] = FriendTypeTPLists[i];\n  }\n\n  FriendDecl(EmptyShell Empty, unsigned NumFriendTypeTPLists)\n      : Decl(Decl::Friend, Empty), UnsupportedFriend(false),\n        NumTPLists(NumFriendTypeTPLists) {}\n\n  FriendDecl *getNextFriend() {\n    if (!NextFriend.isOffset())\n      return cast_or_null<FriendDecl>(NextFriend.get(nullptr));\n    return getNextFriendSlowCase();\n  }\n\n  FriendDecl *getNextFriendSlowCase();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend TrailingObjects;\n\n  static FriendDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation L, FriendUnion Friend_,\n         SourceLocation FriendL,\n         ArrayRef<TemplateParameterList *> FriendTypeTPLists = std::nullopt);\n  static FriendDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned FriendTypeNumTPLists);\n\n  /// If this friend declaration names an (untemplated but possibly\n  /// dependent) type, return the type; otherwise return null.  This\n  /// is used for elaborated-type-specifiers and, in C++0x, for\n  /// arbitrary friend type declarations.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  unsigned getFriendTypeNumTemplateParameterLists() const {\n    return NumTPLists;\n  }\n\n  TemplateParameterList *getFriendTypeTemplateParameterList(unsigned N) const {\n    assert(N < NumTPLists);\n    return getTrailingObjects<TemplateParameterList *>()[N];\n  }\n\n  /// If this friend declaration doesn't name a type, return the inner\n  /// declaration.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl *>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  /// Retrieves the source range for the friend declaration.\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (NamedDecl *ND = getFriendDecl()) {\n      if (const auto *FD = dyn_cast<FunctionDecl>(ND))\n        return FD->getSourceRange();\n      if (const auto *FTD = dyn_cast<FunctionTemplateDecl>(ND))\n        return FTD->getSourceRange();\n      if (const auto *CTD = dyn_cast<ClassTemplateDecl>(ND))\n        return CTD->getSourceRange();\n      if (const auto *DD = dyn_cast<DeclaratorDecl>(ND)) {\n        if (DD->getOuterLocStart() != DD->getInnerLocStart())\n          return DD->getSourceRange();\n      }\n      return SourceRange(getFriendLoc(), ND->getEndLoc());\n    }\n    else if (TypeSourceInfo *TInfo = getFriendType()) {\n      SourceLocation StartL =\n          (NumTPLists == 0) ? getFriendLoc()\n                            : getTrailingObjects<TemplateParameterList *>()[0]\n                                  ->getTemplateLoc();\n      return SourceRange(StartL, TInfo->getTypeLoc().getEndLoc());\n    }\n    else\n      return SourceRange(getFriendLoc(), getLocation());\n  }\n\n  /// Determines if this friend kind is unsupported.\n  bool isUnsupportedFriend() const {\n    return UnsupportedFriend;\n  }\n  void setUnsupportedFriend(bool Unsupported) {\n    UnsupportedFriend = Unsupported;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Friend; }\n};\n\n/// An iterator over the friend declarations of a class.\nclass CXXRecordDecl::friend_iterator {\n  friend class CXXRecordDecl;\n\n  FriendDecl *Ptr;\n\n  explicit friend_iterator(FriendDecl *Ptr) : Ptr(Ptr) {}\n\npublic:\n  friend_iterator() = default;\n\n  using value_type = FriendDecl *;\n  using reference = FriendDecl *;\n  using pointer = FriendDecl *;\n  using difference_type = int;\n  using iterator_category = std::forward_iterator_tag;\n\n  reference operator*() const { return Ptr; }\n\n  friend_iterator &operator++() {\n    assert(Ptr && \"attempt to increment past end of friend list\");\n    Ptr = Ptr->getNextFriend();\n    return *this;\n  }\n\n  friend_iterator operator++(int) {\n    friend_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  bool operator==(const friend_iterator &Other) const {\n    return Ptr == Other.Ptr;\n  }\n\n  bool operator!=(const friend_iterator &Other) const {\n    return Ptr != Other.Ptr;\n  }\n\n  friend_iterator &operator+=(difference_type N) {\n    assert(N >= 0 && \"cannot rewind a CXXRecordDecl::friend_iterator\");\n    while (N--)\n      ++*this;\n    return *this;\n  }\n\n  friend_iterator operator+(difference_type N) const {\n    friend_iterator tmp = *this;\n    tmp += N;\n    return tmp;\n  }\n};\n\ninline CXXRecordDecl::friend_iterator CXXRecordDecl::friend_begin() const {\n  return friend_iterator(getFirstFriend());\n}\n\ninline CXXRecordDecl::friend_iterator CXXRecordDecl::friend_end() const {\n  return friend_iterator(nullptr);\n}\n\ninline CXXRecordDecl::friend_range CXXRecordDecl::friends() const {\n  return friend_range(friend_begin(), friend_end());\n}\n\ninline void CXXRecordDecl::pushFriendDecl(FriendDecl *FD) {\n  assert(!FD->NextFriend && \"friend already has next friend?\");\n  FD->NextFriend = data().FirstFriend;\n  data().FirstFriend = FD;\n}\n\n}",
  "id": "BLOCK-CPP-08754",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclFriend.h",
  "source_line": 42,
  "validation_status": "validated"
}