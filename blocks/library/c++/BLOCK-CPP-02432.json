{
  "code": "#include \"absl/container/internal/raw_hash_set.h\"\n#include <atomic>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/dynamic_annotations.h\"\n#include \"absl/container/internal/container_memory.h\"\n#include \"absl/hash/hash.h\"\n\nusing namespace absl;\nusing namespace container_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02432_execute() {\n    {\n  void* set = &common;\n  void* slot_array = common.slot_array();\n  const size_t capacity = common.capacity();\n  assert(IsValidCapacity(capacity));\n  assert(!is_small(capacity));\n  // Algorithm:\n  // - mark all DELETED slots as EMPTY\n  // - mark all FULL slots as DELETED\n  // - for each slot marked as DELETED\n  //     hash = Hash(element)\n  //     target = find_first_non_full(hash)\n  //     if target is in the same group\n  //       mark slot as FULL\n  //     else if target is EMPTY\n  //       transfer element to target\n  //       mark slot as EMPTY\n  //       mark target as FULL\n  //     else if target is DELETED\n  //       swap current element with target element\n  //       mark target as FULL\n  //       repeat procedure for current slot with moved from element (target)\n  ctrl_t* ctrl = common.control();\n  ConvertDeletedToEmptyAndFullToDeleted(ctrl, capacity);\n  auto hasher = policy.hash_slot;\n  auto transfer = policy.transfer;\n  const size_t slot_size = policy.slot_size;\n\n  size_t total_probe_length = 0;\n  void* slot_ptr = SlotAddress(slot_array, 0, slot_size);\n  for (size_t i = 0; i != capacity;\n       ++i, slot_ptr = NextSlot(slot_ptr, slot_size)) {\n    assert(slot_ptr == SlotAddress(slot_array, i, slot_size));\n    if (!IsDeleted(ctrl[i])) continue;\n    const size_t hash = (*hasher)(set, slot_ptr);\n    const FindInfo target = find_first_non_full(common, hash);\n    const size_t new_i = target.offset;\n    total_probe_length += target.probe_length;\n\n    // Verify if the old and new i fall within the same group wrt the hash.\n    // If they do, we don't need to move the object as it falls already in the\n    // best probe we can.\n    const size_t probe_offset = probe(common, hash).offset();\n    const auto probe_index = [probe_offset, capacity](size_t pos) {\n      return ((pos - probe_offset) & capacity) / Group::kWidth;\n    };\n\n    // Element doesn't move.\n    if (ABSL_PREDICT_TRUE(probe_index(new_i) == probe_index(i))) {\n      SetCtrl(common, i, H2(hash), slot_size);\n      continue;\n    }\n\n    void* new_slot_ptr = SlotAddress(slot_array, new_i, slot_size);\n    if (IsEmpty(ctrl[new_i])) {\n      // Transfer element to the empty spot.\n      // SetCtrl poisons/unpoisons the slots so we have to call it at the\n      // right time.\n      SetCtrl(common, new_i, H2(hash), slot_size);\n      (*transfer)(set, new_slot_ptr, slot_ptr);\n      SetCtrl(common, i, ctrl_t::kEmpty, slot_size);\n    } else {\n      assert(IsDeleted(ctrl[new_i]));\n      SetCtrl(common, new_i, H2(hash), slot_size);\n      // Until we are done rehashing, DELETED marks previously FULL slots.\n\n      // Swap i and new_i elements.\n      (*transfer)(set, tmp_space, new_slot_ptr);\n      (*transfer)(set, new_slot_ptr, slot_ptr);\n      (*transfer)(set, slot_ptr, tmp_space);\n\n      // repeat the processing of the ith slot\n      --i;\n      slot_ptr = PrevSlot(slot_ptr, slot_size);\n    }\n  }\n  ResetGrowthLeft(common);\n  common.infoz().RecordRehash(total_probe_length);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02432",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.cc",
  "source_line": 143,
  "validation_status": "validated"
}