{
  "code": "{\n\nclass DeclContext;\nclass IdentifierInfo;\nclass LangOptions;\nclass MemberExpr;\nclass NestedNameSpecifier;\nclass Sema;\n\n/// Simple class containing the result of Sema::CorrectTypo\nclass TypoCorrection {\npublic:\n  // \"Distance\" for unusable corrections\n  static const unsigned InvalidDistance = std::numeric_limits<unsigned>::max();\n\n  // The largest distance still considered valid (larger edit distances are\n  // mapped to InvalidDistance by getEditDistance).\n  static const unsigned MaximumDistance = 10000U;\n\n  // Relative weightings of the \"edit distance\" components. The higher the\n  // weight, the more of a penalty to fitness the component will give (higher\n  // weights mean greater contribution to the total edit distance, with the\n  // best correction candidates having the lowest edit distance).\n  static const unsigned CharDistanceWeight = 100U;\n  static const unsigned QualifierDistanceWeight = 110U;\n  static const unsigned CallbackDistanceWeight = 150U;\n\n  TypoCorrection(const DeclarationName &Name, NamedDecl *NameDecl,\n                 NestedNameSpecifier *NNS = nullptr, unsigned CharDistance = 0,\n                 unsigned QualifierDistance = 0)\n      : CorrectionName(Name), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance), QualifierDistance(QualifierDistance) {\n    if (NameDecl)\n      CorrectionDecls.push_back(NameDecl);\n  }\n\n  TypoCorrection(NamedDecl *Name, NestedNameSpecifier *NNS = nullptr,\n                 unsigned CharDistance = 0)\n      : CorrectionName(Name->getDeclName()), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance) {\n    if (Name)\n      CorrectionDecls.push_back(Name);\n  }\n\n  TypoCorrection(DeclarationName Name, NestedNameSpecifier *NNS = nullptr,\n                 unsigned CharDistance = 0)\n      : CorrectionName(Name), CorrectionNameSpec(NNS),\n        CharDistance(CharDistance) {}\n\n  TypoCorrection() = default;\n\n  /// Gets the DeclarationName of the typo correction\n  DeclarationName getCorrection() const { return CorrectionName; }\n\n  IdentifierInfo *getCorrectionAsIdentifierInfo() const {\n    return CorrectionName.getAsIdentifierInfo();\n  }\n\n  /// Gets the NestedNameSpecifier needed to use the typo correction\n  NestedNameSpecifier *getCorrectionSpecifier() const {\n    return CorrectionNameSpec;\n  }\n\n  void setCorrectionSpecifier(NestedNameSpecifier *NNS) {\n    CorrectionNameSpec = NNS;\n    ForceSpecifierReplacement = (NNS != nullptr);\n  }\n\n  void WillReplaceSpecifier(bool ForceReplacement) {\n    ForceSpecifierReplacement = ForceReplacement;\n  }\n\n  bool WillReplaceSpecifier() const {\n    return ForceSpecifierReplacement;\n  }\n\n  void setQualifierDistance(unsigned ED) {\n    QualifierDistance = ED;\n  }\n\n  void setCallbackDistance(unsigned ED) {\n    CallbackDistance = ED;\n  }\n\n  // Convert the given weighted edit distance to a roughly equivalent number of\n  // single-character edits (typically for comparison to the length of the\n  // string being edited).\n  static unsigned NormalizeEditDistance(unsigned ED) {\n    if (ED > MaximumDistance)\n      return InvalidDistance;\n    return (ED + CharDistanceWeight / 2) / CharDistanceWeight;\n  }\n\n  /// Gets the \"edit distance\" of the typo correction from the typo.\n  /// If Normalized is true, scale the distance down by the CharDistanceWeight\n  /// to return the edit distance in terms of single-character edits.\n  unsigned getEditDistance(bool Normalized = true) const {\n    if (CharDistance > MaximumDistance || QualifierDistance > MaximumDistance ||\n        CallbackDistance > MaximumDistance)\n      return InvalidDistance;\n    unsigned ED =\n        CharDistance * CharDistanceWeight +\n        QualifierDistance * QualifierDistanceWeight +\n        CallbackDistance * CallbackDistanceWeight;\n    if (ED > MaximumDistance)\n      return InvalidDistance;\n    // Half the CharDistanceWeight is added to ED to simulate rounding since\n    // integer division truncates the value (i.e. round-to-nearest-int instead\n    // of round-to-zero).\n    return Normalized ? NormalizeEditDistance(ED) : ED;\n  }\n\n  /// Get the correction declaration found by name lookup (before we\n  /// looked through using shadow declarations and the like).\n  NamedDecl *getFoundDecl() const {\n    return hasCorrectionDecl() ? *(CorrectionDecls.begin()) : nullptr;\n  }\n\n  /// Gets the pointer to the declaration of the typo correction\n  NamedDecl *getCorrectionDecl() const {\n    auto *D = getFoundDecl();\n    return D ? D->getUnderlyingDecl() : nullptr;\n  }\n  template <class DeclClass>\n  DeclClass *getCorrectionDeclAs() const {\n    return dyn_cast_or_null<DeclClass>(getCorrectionDecl());\n  }\n\n  /// Clears the list of NamedDecls.\n  void ClearCorrectionDecls() {\n    CorrectionDecls.clear();\n  }\n\n  /// Clears the list of NamedDecls before adding the new one.\n  void setCorrectionDecl(NamedDecl *CDecl) {\n    CorrectionDecls.clear();\n    addCorrectionDecl(CDecl);\n  }\n\n  /// Clears the list of NamedDecls and adds the given set.\n  void setCorrectionDecls(ArrayRef<NamedDecl*> Decls) {\n    CorrectionDecls.clear();\n    CorrectionDecls.insert(CorrectionDecls.begin(), Decls.begin(), Decls.end());\n  }\n\n  /// Add the given NamedDecl to the list of NamedDecls that are the\n  /// declarations associated with the DeclarationName of this TypoCorrection\n  void addCorrectionDecl(NamedDecl *CDecl);\n\n  std::string getAsString(const LangOptions &LO) const;\n\n  std::string getQuoted(const LangOptions &LO) const {\n    return \"'\" + getAsString(LO) + \"'\";\n  }\n\n  /// Returns whether this TypoCorrection has a non-empty DeclarationName\n  explicit operator bool() const { return bool(CorrectionName); }\n\n  /// Mark this TypoCorrection as being a keyword.\n  /// Since addCorrectionDeclsand setCorrectionDecl don't allow NULL to be\n  /// added to the list of the correction's NamedDecl pointers, NULL is added\n  /// as the only element in the list to mark this TypoCorrection as a keyword.\n  void makeKeyword() {\n    CorrectionDecls.clear();\n    CorrectionDecls.push_back(nullptr);\n    ForceSpecifierReplacement = true;\n  }\n\n  // Check if this TypoCorrection is a keyword by checking if the first\n  // item in CorrectionDecls is NULL.\n  bool isKeyword() const {\n    return !CorrectionDecls.empty() && CorrectionDecls.front() == nullptr;\n  }\n\n  // Check if this TypoCorrection is the given keyword.\n  template<std::size_t StrLen>\n  bool isKeyword(const char (&Str)[StrLen]) const {\n    return isKeyword() && getCorrectionAsIdentifierInfo()->isStr(Str);\n  }\n\n  // Returns true if the correction either is a keyword or has a known decl.\n  bool isResolved() const { return !CorrectionDecls.empty(); }\n\n  bool isOverloaded() const {\n    return CorrectionDecls.size() > 1;\n  }\n\n  void setCorrectionRange(CXXScopeSpec *SS,\n                          const DeclarationNameInfo &TypoName) {\n    CorrectionRange = TypoName.getSourceRange();\n    if (ForceSpecifierReplacement && SS && !SS->isEmpty())\n      CorrectionRange.setBegin(SS->getBeginLoc());\n  }\n\n  SourceRange getCorrectionRange() const {\n    return CorrectionRange;\n  }\n\n  using decl_iterator = SmallVectorImpl<NamedDecl *>::iterator;\n\n  decl_iterator begin() {\n    return isKeyword() ? CorrectionDecls.end() : CorrectionDecls.begin();\n  }\n\n  decl_iterator end() { return CorrectionDecls.end(); }\n\n  using const_decl_iterator = SmallVectorImpl<NamedDecl *>::const_iterator;\n\n  const_decl_iterator begin() const {\n    return isKeyword() ? CorrectionDecls.end() : CorrectionDecls.begin();\n  }\n\n  const_decl_iterator end() const { return CorrectionDecls.end(); }\n\n  /// Returns whether this typo correction is correcting to a\n  /// declaration that was declared in a module that has not been imported.\n  bool requiresImport() const { return RequiresImport; }\n  void setRequiresImport(bool Req) { RequiresImport = Req; }\n\n  /// Extra diagnostics are printed after the first diagnostic for the typo.\n  /// This can be used to attach external notes to the diag.\n  void addExtraDiagnostic(PartialDiagnostic PD) {\n    ExtraDiagnostics.push_back(std::move(PD));\n  }\n  ArrayRef<PartialDiagnostic> getExtraDiagnostics() const {\n    return ExtraDiagnostics;\n  }\n\nprivate:\n  bool hasCorrectionDecl() const {\n    return (!isKeyword() && !CorrectionDecls.empty());\n  }\n\n  // Results.\n  DeclarationName CorrectionName;\n  NestedNameSpecifier *CorrectionNameSpec = nullptr;\n  SmallVector<NamedDecl *, 1> CorrectionDecls;\n  unsigned CharDistance = 0;\n  unsigned QualifierDistance = 0;\n  unsigned CallbackDistance = 0;\n  SourceRange CorrectionRange;\n  bool ForceSpecifierReplacement = false;\n  bool RequiresImport = false;\n\n  std::vector<PartialDiagnostic> ExtraDiagnostics;\n};\n\n/// Base class for callback objects used by Sema::CorrectTypo to check\n/// the validity of a potential typo correction.\nclass CorrectionCandidateCallback {\npublic:\n  static const unsigned InvalidDistance = TypoCorrection::InvalidDistance;\n\n  explicit CorrectionCandidateCallback(IdentifierInfo *Typo = nullptr,\n                                       NestedNameSpecifier *TypoNNS = nullptr)\n      : Typo(Typo), TypoNNS(TypoNNS) {}\n\n  virtual ~CorrectionCandidateCallback() = default;\n\n  /// Simple predicate used by the default RankCandidate to\n  /// determine whether to return an edit distance of 0 or InvalidDistance.\n  /// This can be overridden by validators that only need to determine if a\n  /// candidate is viable, without ranking potentially viable candidates.\n  /// Only ValidateCandidate or RankCandidate need to be overridden by a\n  /// callback wishing to check the viability of correction candidates.\n  /// The default predicate always returns true if the candidate is not a type\n  /// name or keyword, true for types if WantTypeSpecifiers is true, and true\n  /// for keywords if WantTypeSpecifiers, WantExpressionKeywords,\n  /// WantCXXNamedCasts, WantRemainingKeywords, or WantObjCSuper is true.\n  virtual bool ValidateCandidate(const TypoCorrection &candidate);\n\n  /// Method used by Sema::CorrectTypo to assign an \"edit distance\" rank\n  /// to a candidate (where a lower value represents a better candidate), or\n  /// returning InvalidDistance if the candidate is not at all viable. For\n  /// validation callbacks that only need to determine if a candidate is viable,\n  /// the default RankCandidate returns either 0 or InvalidDistance depending\n  /// whether ValidateCandidate returns true or false.\n  virtual unsigned RankCandidate(const TypoCorrection &candidate) {\n    return (!MatchesTypo(candidate) && ValidateCandidate(candidate))\n               ? 0\n               : InvalidDistance;\n  }\n\n  /// Clone this CorrectionCandidateCallback. CorrectionCandidateCallbacks are\n  /// initially stack-allocated. However in case where delayed typo-correction\n  /// is done we need to move the callback to storage with a longer lifetime.\n  /// Every class deriving from CorrectionCandidateCallback must implement\n  /// this method.\n  virtual std::unique_ptr<CorrectionCandidateCallback> clone() = 0;\n\n  void setTypoName(IdentifierInfo *II) { Typo = II; }\n  void setTypoNNS(NestedNameSpecifier *NNS) { TypoNNS = NNS; }\n\n  // Flags for context-dependent keywords. WantFunctionLikeCasts is only\n  // used/meaningful when WantCXXNamedCasts is false.\n  // TODO: Expand these to apply to non-keywords or possibly remove them.\n  bool WantTypeSpecifiers = true;\n  bool WantExpressionKeywords = true;\n  bool WantCXXNamedCasts = true;\n  bool WantFunctionLikeCasts = true;\n  bool WantRemainingKeywords = true;\n  bool WantObjCSuper = false;\n  // Temporary hack for the one case where a CorrectTypoContext enum is used\n  // when looking up results.\n  bool IsObjCIvarLookup = false;\n  bool IsAddressOfOperand = false;\n\nprotected:\n  bool MatchesTypo(const TypoCorrection &candidate) {\n    return Typo && candidate.isResolved() && !candidate.requiresImport() &&\n           candidate.getCorrectionAsIdentifierInfo() == Typo &&\n           // FIXME: This probably does not return true when both\n           // NestedNameSpecifiers have the same textual representation.\n           candidate.getCorrectionSpecifier() == TypoNNS;\n  }\n\n  IdentifierInfo *Typo;\n  NestedNameSpecifier *TypoNNS;\n};\n\nclass DefaultFilterCCC final : public CorrectionCandidateCallback {\npublic:\n  explicit DefaultFilterCCC(IdentifierInfo *Typo = nullptr,\n                            NestedNameSpecifier *TypoNNS = nullptr)\n      : CorrectionCandidateCallback(Typo, TypoNNS) {}\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<DefaultFilterCCC>(*this);\n  }\n};\n\n/// Simple template class for restricting typo correction candidates\n/// to ones having a single Decl* of the given type.\ntemplate <class C>\nclass DeclFilterCCC final : public CorrectionCandidateCallback {\npublic:\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    return candidate.getCorrectionDeclAs<C>();\n  }\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<DeclFilterCCC>(*this);\n  }\n};\n\n// Callback class to limit the allowed keywords and to only accept typo\n// corrections that are keywords or whose decls refer to functions (or template\n// functions) that accept the given number of arguments.\nclass FunctionCallFilterCCC : public CorrectionCandidateCallback {\npublic:\n  FunctionCallFilterCCC(Sema &SemaRef, unsigned NumArgs,\n                        bool HasExplicitTemplateArgs,\n                        MemberExpr *ME = nullptr);\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override;\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<FunctionCallFilterCCC>(*this);\n  }\n\nprivate:\n  unsigned NumArgs;\n  bool HasExplicitTemplateArgs;\n  DeclContext *CurContext;\n  MemberExpr *MemberFn;\n};\n\n// Callback class that effectively disabled typo correction\nclass NoTypoCorrectionCCC final : public CorrectionCandidateCallback {\npublic:\n  NoTypoCorrectionCCC() {\n    WantTypeSpecifiers = false;\n    WantExpressionKeywords = false;\n    WantCXXNamedCasts = false;\n    WantFunctionLikeCasts = false;\n    WantRemainingKeywords = false;\n  }\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    return false;\n  }\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<NoTypoCorrectionCCC>(*this);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-20769",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/TypoCorrection.h",
  "source_line": 32,
  "validation_status": "validated"
}