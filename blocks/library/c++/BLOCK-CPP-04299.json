{
  "code": "#include <atomic>\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/synchronization/mutex.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04299_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// BlockingCounter\n//\n// This class allows a thread to block for a pre-specified number of actions.\n// `BlockingCounter` maintains a single non-negative abstract integer \"count\"\n// with an initial value `initial_count`. A thread can then call `Wait()` on\n// this blocking counter to block until the specified number of events occur;\n// worker threads then call 'DecrementCount()` on the counter upon completion of\n// their work. Once the counter's internal \"count\" reaches zero, the blocked\n// thread unblocks.\n//\n// A `BlockingCounter` requires the following:\n//     - its `initial_count` is non-negative.\n//     - the number of calls to `DecrementCount()` on it is at most\n//       `initial_count`.\n//     - `Wait()` is called at most once on it.\n//\n// Given the above requirements, a `BlockingCounter` provides the following\n// guarantees:\n//     - Once its internal \"count\" reaches zero, no legal action on the object\n//       can further change the value of \"count\".\n//     - When `Wait()` returns, it is legal to destroy the `BlockingCounter`.\n//     - When `Wait()` returns, the number of calls to `DecrementCount()` on\n//       this blocking counter exactly equals `initial_count`.\n//\n// Example:\n//     BlockingCounter bcount(N);         // there are N items of work\n//     ... Allow worker threads to start.\n//     ... On completing each work item, workers do:\n//     ... bcount.DecrementCount();      // an item of work has been completed\n//\n//     bcount.Wait();                    // wait for all work to be complete\n//\nclass BlockingCounter {\n public:\n  explicit BlockingCounter(int initial_count);\n\n  BlockingCounter(const BlockingCounter&) = delete;\n  BlockingCounter& operator=(const BlockingCounter&) = delete;\n\n  // BlockingCounter::DecrementCount()\n  //\n  // Decrements the counter's \"count\" by one, and return \"count == 0\". This\n  // function requires that \"count != 0\" when it is called.\n  //\n  // Memory ordering: For any threads X and Y, any action taken by X\n  // before it calls `DecrementCount()` is visible to thread Y after\n  // Y's call to `DecrementCount()`, provided Y's call returns `true`.\n  bool DecrementCount();\n\n  // BlockingCounter::Wait()\n  //\n  // Blocks until the counter reaches zero. This function may be called at most\n  // once. On return, `DecrementCount()` will have been called \"initial_count\"\n  // times and the blocking counter may be destroyed.\n  //\n  // Memory ordering: For any threads X and Y, any action taken by X\n  // before X calls `DecrementCount()` is visible to Y after Y returns\n  // from `Wait()`.\n  void Wait();\n\n private:\n  Mutex lock_;\n  std::atomic<int> count_;\n  int num_waiting_ ABSL_GUARDED_BY(lock_);\n  bool done_ ABSL_GUARDED_BY(lock_);\n};\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04299",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/blocking_counter.h",
  "source_line": 28,
  "validation_status": "validated"
}