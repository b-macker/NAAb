{
  "code": "{\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n}",
  "id": "BLOCK-CPP-15785",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/PathDiagnostic.h",
  "source_line": 195,
  "validation_status": "validated"
}