{
  "code": "{\n  /// The actual, canonical type.\n  QualType Stored;\n\npublic:\n  /// Constructs a NULL canonical type.\n  CanQual() = default;\n\n  /// Converting constructor that permits implicit upcasting of\n  /// canonical type pointers.\n  template <typename U>\n  CanQual(const CanQual<U> &Other,\n          std::enable_if_t<std::is_base_of<T, U>::value, int> = 0);\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type.\n  ///\n  /// The underlying pointer must not be nullptr.\n  const T *getTypePtr() const { return cast<T>(Stored.getTypePtr()); }\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type, or nullptr.\n  const T *getTypePtrOrNull() const {\n    return cast_or_null<T>(Stored.getTypePtrOrNull());\n  }\n\n  /// Implicit conversion to a qualified type.\n  operator QualType() const { return Stored; }\n\n  /// Implicit conversion to bool.\n  explicit operator bool() const { return !isNull(); }\n\n  bool isNull() const {\n    return Stored.isNull();\n  }\n\n  SplitQualType split() const { return Stored.split(); }\n\n  /// Retrieve a canonical type pointer with a different static type,\n  /// upcasting or downcasting as needed.\n  ///\n  /// The getAs() function is typically used to try to downcast to a\n  /// more specific (canonical) type in the type system. For example:\n  ///\n  /// @code\n  /// void f(CanQual<Type> T) {\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {\n  ///     // look at Ptr's pointee type\n  ///   }\n  /// }\n  /// @endcode\n  ///\n  /// \\returns A proxy pointer to the same type, but with the specified\n  /// static type (@p U). If the dynamic type is not the specified static type\n  /// or a derived class thereof, a NULL canonical type.\n  template<typename U> CanProxy<U> getAs() const;\n\n  template<typename U> CanProxy<U> castAs() const;\n\n  /// Overloaded arrow operator that produces a canonical type\n  /// proxy.\n  CanProxy<T> operator->() const;\n\n  /// Retrieve all qualifiers.\n  Qualifiers getQualifiers() const { return Stored.getLocalQualifiers(); }\n\n  /// Retrieve the const/volatile/restrict qualifiers.\n  unsigned getCVRQualifiers() const { return Stored.getLocalCVRQualifiers(); }\n\n  /// Determines whether this type has any qualifiers\n  bool hasQualifiers() const { return Stored.hasLocalQualifiers(); }\n\n  bool isConstQualified() const {\n    return Stored.isLocalConstQualified();\n  }\n\n  bool isVolatileQualified() const {\n    return Stored.isLocalVolatileQualified();\n  }\n\n  bool isRestrictQualified() const {\n    return Stored.isLocalRestrictQualified();\n  }\n\n  /// Determines if this canonical type is furthermore\n  /// canonical as a parameter.  The parameter-canonicalization\n  /// process decays arrays to pointers and drops top-level qualifiers.\n  bool isCanonicalAsParam() const {\n    return Stored.isCanonicalAsParam();\n  }\n\n  /// Retrieve the unqualified form of this type.\n  CanQual<T> getUnqualifiedType() const;\n\n  /// Retrieves a version of this type with const applied.\n  /// Note that this does not always yield a canonical type.\n  QualType withConst() const {\n    return Stored.withConst();\n  }\n\n  /// Determines whether this canonical type is more qualified than\n  /// the @p Other canonical type.\n  bool isMoreQualifiedThan(CanQual<T> Other) const {\n    return Stored.isMoreQualifiedThan(Other.Stored);\n  }\n\n  /// Determines whether this canonical type is at least as qualified as\n  /// the @p Other canonical type.\n  bool isAtLeastAsQualifiedAs(CanQual<T> Other) const {\n    return Stored.isAtLeastAsQualifiedAs(Other.Stored);\n  }\n\n  /// If the canonical type is a reference type, returns the type that\n  /// it refers to; otherwise, returns the type itself.\n  CanQual<Type> getNonReferenceType() const;\n\n  /// Retrieve the internal representation of this canonical type.\n  void *getAsOpaquePtr() const { return Stored.getAsOpaquePtr(); }\n\n  /// Construct a canonical type from its internal representation.\n  static CanQual<T> getFromOpaquePtr(void *Ptr);\n\n  /// Builds a canonical type from a QualType.\n  ///\n  /// This routine is inherently unsafe, because it requires the user to\n  /// ensure that the given type is a canonical type with the correct\n  // (dynamic) type.\n  static CanQual<T> CreateUnsafe(QualType Other);\n\n  void dump() const { Stored.dump(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n}",
  "id": "BLOCK-CPP-23263",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CanonicalType.h",
  "source_line": 64,
  "validation_status": "validated"
}