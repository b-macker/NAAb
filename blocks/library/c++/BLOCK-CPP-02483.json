{
  "code": "#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/crc/crc32c.h\"\n#include \"absl/crc/internal/crc_memcpy.h\"\n#include \"absl/crc/internal/non_temporal_memcpy.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02483_execute() {\n    {\nABSL_NAMESPACE_BEGIN\nnamespace crc_internal {\n\ncrc32c_t CrcNonTemporalMemcpyEngine::Compute(void* __restrict dst,\n                                             const void* __restrict src,\n                                             std::size_t length,\n                                             crc32c_t initial_crc) const {\n  constexpr size_t kBlockSize = 8192;\n  crc32c_t crc = initial_crc;\n\n  const char* src_bytes = reinterpret_cast<const char*>(src);\n  char* dst_bytes = reinterpret_cast<char*>(dst);\n\n  // Copy + CRC loop - run 8k chunks until we are out of full chunks.\n  std::size_t offset = 0;\n  for (; offset + kBlockSize < length; offset += kBlockSize) {\n    crc = absl::ExtendCrc32c(crc,\n                             absl::string_view(src_bytes + offset, kBlockSize));\n    non_temporal_store_memcpy(dst_bytes + offset, src_bytes + offset,\n                              kBlockSize);\n  }\n\n  // Save some work if length is 0.\n  if (offset < length) {\n    std::size_t final_copy_size = length - offset;\n    crc = ExtendCrc32c(crc,\n                       absl::string_view(src_bytes + offset, final_copy_size));\n\n    non_temporal_store_memcpy(dst_bytes + offset, src_bytes + offset,\n                              final_copy_size);\n  }\n\n  return crc;\n}\n\ncrc32c_t CrcNonTemporalMemcpyAVXEngine::Compute(void* __restrict dst,\n                                                const void* __restrict src,\n                                                std::size_t length,\n                                                crc32c_t initial_crc) const {\n  constexpr size_t kBlockSize = 8192;\n  crc32c_t crc = initial_crc;\n\n  const char* src_bytes = reinterpret_cast<const char*>(src);\n  char* dst_bytes = reinterpret_cast<char*>(dst);\n\n  // Copy + CRC loop - run 8k chunks until we are out of full chunks.\n  std::size_t offset = 0;\n  for (; offset + kBlockSize < length; offset += kBlockSize) {\n    crc = ExtendCrc32c(crc, absl::string_view(src_bytes + offset, kBlockSize));\n\n    non_temporal_store_memcpy_avx(dst_bytes + offset, src_bytes + offset,\n                                  kBlockSize);\n  }\n\n  // Save some work if length is 0.\n  if (offset < length) {\n    std::size_t final_copy_size = length - offset;\n    crc = ExtendCrc32c(crc,\n                       absl::string_view(src_bytes + offset, final_copy_size));\n\n    non_temporal_store_memcpy_avx(dst_bytes + offset, src_bytes + offset,\n                                  final_copy_size);\n  }\n\n  return crc;\n}\n\n}  // namespace crc_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02483",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc_non_temporal_memcpy.cc",
  "source_line": 23,
  "validation_status": "validated"
}