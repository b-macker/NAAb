{
  "code": "{\n  ///   template<Types ...Values>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Values has a \\c PackExpansionType as its type,\n  /// which expands \\c Types. When \\c Types is supplied with template arguments\n  /// by instantiating \\c X, the instantiation of \\c Values becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Values being an expanded parameter\n  /// pack with expansion types \\c int and \\c unsigned int.\n  ///\n  /// The \\c getExpansionType() and \\c getExpansionTypeSourceInfo() functions\n  /// return the expansion types.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion types in an expanded parameter\n  /// pack.\n  unsigned getNumExpansionTypes() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedTypes;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  QualType getExpansionType(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].first;\n  }\n\n  /// Retrieve a particular expansion type source info within an\n  /// expanded parameter pack.\n  TypeSourceInfo *getExpansionTypeSourceInfo(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].second;\n  }\n\n  /// Return the constraint introduced by the placeholder type of this non-type\n  /// template parameter (if any).\n  Expr *getPlaceholderTypeConstraint() const {\n    return hasPlaceholderTypeConstraint() ? *getTrailingObjects<Expr *>() :\n        nullptr;\n  }\n\n  void setPlaceholderTypeConstraint(Expr *E) {\n    *getTrailingObjects<Expr *>() = E;\n  }\n\n  /// Determine whether this non-type template parameter's type has a\n  /// placeholder with a type-constraint.\n  bool hasPlaceholderTypeConstraint() const {\n    auto *AT = getType()->getContainedAutoType();\n    return AT && AT->isConstrained();\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be a vector of size 1 containing the immediately-declared\n  /// constraint introduced by the placeholder type, or an empty vector.\n  ///\n  /// Use this instead of getPlaceholderImmediatelyDeclaredConstraint for\n  /// concepts APIs that accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (Expr *E = getPlaceholderTypeConstraint())\n      AC.push_back(E);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }\n}",
  "id": "BLOCK-CPP-09382",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 1543,
  "validation_status": "validated"
}