{
  "code": "#include <cstring>\n#include <string>\n#include <type_traits>\n#include <vector>\n#include \"absl/base/macros.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/port.h\"\n#include \"absl/strings/ascii.h\"\n#include \"absl/strings/escaping.h\"\n#include \"absl/strings/internal/stringify_sink.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_split.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/strings/strip.h\"\n\nusing namespace absl;\nusing namespace substitute_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04294_execute() {\n    {\n public:\n  // Overloads for string-y things\n  //\n  // Explicitly overload `const char*` so the compiler doesn't cast to `bool`.\n  Arg(absl::Nullable<const char*> value)  // NOLINT(google-explicit-constructor)\n      : piece_(absl::NullSafeStringView(value)) {}\n  template <typename Allocator>\n  Arg(  // NOLINT\n      const std::basic_string<char, std::char_traits<char>, Allocator>&\n          value) noexcept\n      : piece_(value) {}\n  Arg(absl::string_view value)  // NOLINT(google-explicit-constructor)\n      : piece_(value) {}\n\n  // Overloads for primitives\n  //\n  // No overloads are available for signed and unsigned char because if people\n  // are explicitly declaring their chars as signed or unsigned then they are\n  // probably using them as 8-bit integers and would probably prefer an integer\n  // representation. However, we can't really know, so we make the caller decide\n  // what to do.\n  Arg(char value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, 1) {\n    scratch_[0] = value;\n  }\n  Arg(short value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned short value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(int value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned int value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(long long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(unsigned long long value)  // NOLINT(*)\n      : piece_(scratch_,\n               static_cast<size_t>(\n                   numbers_internal::FastIntToBuffer(value, scratch_) -\n                   scratch_)) {}\n  Arg(float value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {\n  }\n  Arg(double value)  // NOLINT(google-explicit-constructor)\n      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {\n  }\n  Arg(bool value)  // NOLINT(google-explicit-constructor)\n      : piece_(value ? \"true\" : \"false\") {}\n\n  template <typename T, typename = typename std::enable_if<\n                            HasAbslStringify<T>::value>::type>\n  Arg(  // NOLINT(google-explicit-constructor)\n      const T& v, strings_internal::StringifySink&& sink = {})\n      : piece_(strings_internal::ExtractStringification(sink, v)) {}\n\n  Arg(Hex hex);  // NOLINT(google-explicit-constructor)\n  Arg(Dec dec);  // NOLINT(google-explicit-constructor)\n\n  // vector<bool>::reference and const_reference require special help to convert\n  // to `Arg` because it requires two user defined conversions.\n  template <typename T,\n            absl::enable_if_t<\n                std::is_class<T>::value &&\n                (std::is_same<T, std::vector<bool>::reference>::value ||\n                 std::is_same<T, std::vector<bool>::const_reference>::value)>* =\n                nullptr>\n  Arg(T value)  // NOLINT(google-explicit-constructor)\n      : Arg(static_cast<bool>(value)) {}\n\n  // `void*` values, with the exception of `char*`, are printed as\n  // \"0x<hex value>\". However, in the case of `nullptr`, \"NULL\" is printed.\n  Arg(  // NOLINT(google-explicit-constructor)\n      absl::Nullable<const void*> value);\n\n  // Normal enums are already handled by the integer formatters.\n  // This overload matches only scoped enums.\n  template <typename T,\n            typename = typename std::enable_if<\n                std::is_enum<T>{} && !std::is_convertible<T, int>{} &&\n                !HasAbslStringify<T>::value>::type>\n  Arg(T value)  // NOLINT(google-explicit-constructor)\n      : Arg(static_cast<typename std::underlying_type<T>::type>(value)) {}\n\n  Arg(const Arg&) = delete;\n  Arg& operator=(const Arg&) = delete;\n\n  absl::string_view piece() const { return piece_; }\n\n private:\n  absl::string_view piece_;\n  char scratch_[numbers_internal::kFastToBufferSize];\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04294",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/substitute.h",
  "source_line": 104,
  "validation_status": "validated"
}