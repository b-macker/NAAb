{
  "code": "{\n  // Really these are all SourceLocations.\n\n  /// Where the spelling for the token can be found.\n  SourceLocation SpellingLoc;\n\n  /// In a macro expansion, ExpansionLocStart and ExpansionLocEnd\n  /// indicate the start and end of the expansion. In object-like macros,\n  /// they will be the same. In a function-like macro expansion, the start\n  /// will be the identifier and the end will be the ')'. Finally, in\n  /// macro-argument instantiations, the end will be 'SourceLocation()', an\n  /// invalid location.\n  SourceLocation ExpansionLocStart, ExpansionLocEnd;\n\n  /// Whether the expansion range is a token range.\n  bool ExpansionIsTokenRange;\n\npublic:\n  SourceLocation getSpellingLoc() const {\n    return SpellingLoc.isInvalid() ? getExpansionLocStart() : SpellingLoc;\n  }\n\n  SourceLocation getExpansionLocStart() const {\n    return ExpansionLocStart;\n  }\n\n  SourceLocation getExpansionLocEnd() const {\n    return ExpansionLocEnd.isInvalid() ? getExpansionLocStart()\n                                       : ExpansionLocEnd;\n  }\n\n  bool isExpansionTokenRange() const { return ExpansionIsTokenRange; }\n\n  CharSourceRange getExpansionLocRange() const {\n    return CharSourceRange(\n        SourceRange(getExpansionLocStart(), getExpansionLocEnd()),\n        isExpansionTokenRange());\n  }\n\n  bool isMacroArgExpansion() const {\n    // Note that this needs to return false for default constructed objects.\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isInvalid();\n  }\n\n  bool isMacroBodyExpansion() const {\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isValid();\n  }\n\n  bool isFunctionMacroExpansion() const {\n    return getExpansionLocStart().isValid() &&\n           getExpansionLocStart() != getExpansionLocEnd();\n  }\n\n  /// Return a ExpansionInfo for an expansion.\n  ///\n  /// Start and End specify the expansion range (where the macro is\n  /// expanded), and SpellingLoc specifies the spelling location (where\n  /// the characters from the token come from). All three can refer to\n  /// normal File SLocs or expansion locations.\n  static ExpansionInfo create(SourceLocation SpellingLoc, SourceLocation Start,\n                              SourceLocation End,\n                              bool ExpansionIsTokenRange = true) {\n    ExpansionInfo X;\n    X.SpellingLoc = SpellingLoc;\n    X.ExpansionLocStart = Start;\n    X.ExpansionLocEnd = End;\n    X.ExpansionIsTokenRange = ExpansionIsTokenRange;\n    return X;\n  }\n\n  /// Return a special ExpansionInfo for the expansion of\n  /// a macro argument into a function-like macro's body.\n  ///\n  /// ExpansionLoc specifies the expansion location (where the macro is\n  /// expanded). This doesn't need to be a range because a macro is always\n  /// expanded at a macro parameter reference, and macro parameters are\n  /// always exactly one token. SpellingLoc specifies the spelling location\n  /// (where the characters from the token come from). ExpansionLoc and\n  /// SpellingLoc can both refer to normal File SLocs or expansion locations.\n  ///\n  /// Given the code:\n  /// \\code\n  ///   #define F(x) f(x)\n  ///   F(42);\n  /// \\endcode\n  ///\n  /// When expanding '\\c F(42)', the '\\c x' would call this with an\n  /// SpellingLoc pointing at '\\c 42' and an ExpansionLoc pointing at its\n  /// location in the definition of '\\c F'.\n  static ExpansionInfo createForMacroArg(SourceLocation SpellingLoc,\n                                         SourceLocation ExpansionLoc) {\n    // We store an intentionally invalid source location for the end of the\n    // expansion range to mark that this is a macro argument location rather\n    // than a normal one.\n    return create(SpellingLoc, ExpansionLoc, SourceLocation());\n  }\n\n  /// Return a special ExpansionInfo representing a token that ends\n  /// prematurely. This is used to model a '>>' token that has been split\n  /// into '>' tokens and similar cases. Unlike for the other forms of\n  /// expansion, the expansion range in this case is a character range, not\n  /// a token range.\n  static ExpansionInfo createForTokenSplit(SourceLocation SpellingLoc,\n                                           SourceLocation Start,\n                                           SourceLocation End) {\n    return create(SpellingLoc, Start, End, false);\n  }\n}",
  "id": "BLOCK-CPP-16982",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceManager.h",
  "source_line": 355,
  "validation_status": "validated"
}