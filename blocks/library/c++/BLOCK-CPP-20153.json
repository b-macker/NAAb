{
  "code": "#include \"clang/Basic/AttrSubjectMatchRules.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/ParsedAttrInfo.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <utility>\n\nusing namespace clang;\nusing namespace detail;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-20153_execute() {\n    {\npublic:\n  enum {\n    AvailabilityAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 1, 0, 0, 0),\n    TypeTagForDatatypeAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 0, 1, 0, 0),\n    PropertyAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 0, 1),\n  };\n\nprivate:\n  enum {\n    /// The number of free lists we want to be sure to support\n    /// inline.  This is just enough that availability attributes\n    /// don't surpass it.  It's actually very unlikely we'll see an\n    /// attribute that needs more than that; on x86-64 you'd need 10\n    /// expression arguments, and on i386 you'd need 19.\n    InlineFreeListsCapacity =\n        1 + (AvailabilityAllocSize - sizeof(ParsedAttr)) / sizeof(void *)\n  };\n\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Free lists.  The index is determined by the following formula:\n  ///   (size - sizeof(ParsedAttr)) / sizeof(void*)\n  SmallVector<SmallVector<ParsedAttr *, 8>, InlineFreeListsCapacity> FreeLists;\n\n  // The following are the private interface used by AttributePool.\n  friend class AttributePool;\n\n  /// Allocate an attribute of the given size.\n  void *allocate(size_t size);\n\n  void deallocate(ParsedAttr *AL);\n\n  /// Reclaim all the attributes in the given pool chain, which is\n  /// non-empty.  Note that the current implementation is safe\n  /// against reclaiming things which were not actually allocated\n  /// with the allocator, although of course it's important to make\n  /// sure that their allocator lives at least as long as this one.\n  void reclaimPool(AttributePool &head);\n\npublic:\n  AttributeFactory();\n  ~AttributeFactory();\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-20153",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ParsedAttr.h",
  "source_line": 618,
  "validation_status": "validated"
}