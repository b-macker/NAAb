{
  "code": "#include <cstddef>\n#include <functional>\n#include <type_traits>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace that;\nusing namespace swap_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03714_execute() {\n    {\n\n// Necessary for the traits.\nusing std::swap;\n\n// This declaration prevents global `swap` and `absl::swap` overloads from being\n// considered unless ADL picks them up.\nvoid swap();\n\ntemplate <class T>\nusing IsSwappableImpl = decltype(swap(std::declval<T&>(), std::declval<T&>()));\n\n// NOTE: This dance with the default template parameter is for MSVC.\ntemplate <class T,\n          class IsNoexcept = std::integral_constant<\n              bool, noexcept(swap(std::declval<T&>(), std::declval<T&>()))>>\nusing IsNothrowSwappableImpl = typename std::enable_if<IsNoexcept::value>::type;\n\n// IsSwappable\n//\n// Determines whether the standard swap idiom is a valid expression for\n// arguments of type `T`.\ntemplate <class T>\nstruct IsSwappable\n    : absl::type_traits_internal::is_detected<IsSwappableImpl, T> {};\n\n// IsNothrowSwappable\n//\n// Determines whether the standard swap idiom is a valid expression for\n// arguments of type `T` and is noexcept.\ntemplate <class T>\nstruct IsNothrowSwappable\n    : absl::type_traits_internal::is_detected<IsNothrowSwappableImpl, T> {};\n\n// Swap()\n//\n// Performs the swap idiom from a namespace where valid candidates may only be\n// found in `std` or via ADL.\ntemplate <class T, absl::enable_if_t<IsSwappable<T>::value, int> = 0>\nvoid Swap(T& lhs, T& rhs) noexcept(IsNothrowSwappable<T>::value) {\n  swap(lhs, rhs);\n}\n\n// StdSwapIsUnconstrained\n//\n// Some standard library implementations are broken in that they do not\n// constrain `std::swap`. This will effectively tell us if we are dealing with\n// one of those implementations.\nusing StdSwapIsUnconstrained = IsSwappable<void()>;\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03714",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/meta/type_traits.h",
  "source_line": 409,
  "validation_status": "validated"
}