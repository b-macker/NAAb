{
  "code": "{\n\nclass SourceManager;\n\n/// An opaque identifier used by SourceManager which refers to a\n/// source file (MemoryBuffer) along with its \\#include path and \\#line data.\n///\nclass FileID {\n  /// A mostly-opaque identifier, where 0 is \"invalid\", >0 is\n  /// this module, and <-1 is something loaded from another module.\n  int ID = 0;\n\npublic:\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\n  bool operator==(const FileID &RHS) const { return ID == RHS.ID; }\n  bool operator<(const FileID &RHS) const { return ID < RHS.ID; }\n  bool operator<=(const FileID &RHS) const { return ID <= RHS.ID; }\n  bool operator!=(const FileID &RHS) const { return !(*this == RHS); }\n  bool operator>(const FileID &RHS) const { return RHS < *this; }\n  bool operator>=(const FileID &RHS) const { return RHS <= *this; }\n\n  static FileID getSentinel() { return get(-1); }\n  unsigned getHashValue() const { return static_cast<unsigned>(ID); }\n\nprivate:\n  friend class ASTWriter;\n  friend class ASTReader;\n  friend class SourceManager;\n\n  static FileID get(int V) {\n    FileID F;\n    F.ID = V;\n    return F;\n  }\n\n  int getOpaqueValue() const { return ID; }\n};\n\n/// Encodes a location in the source. The SourceManager can decode this\n/// to get at the full include stack, line and column information.\n///\n/// Technically, a source location is simply an offset into the manager's view\n/// of the input source, which is all input buffers (including macro\n/// expansions) concatenated in an effectively arbitrary order. The manager\n/// actually maintains two blocks of input buffers. One, starting at offset\n/// 0 and growing upwards, contains all buffers from this module. The other,\n/// starting at the highest possible offset and growing downwards, contains\n/// buffers of loaded modules.\n///\n/// In addition, one bit of SourceLocation is used for quick access to the\n/// information whether the location is in a file or a macro expansion.\n///\n/// It is important that this type remains small. It is currently 32 bits wide.\nclass SourceLocation {\n  friend class ASTReader;\n  friend class ASTWriter;\n  friend class SourceManager;\n  friend struct llvm::FoldingSetTrait<SourceLocation, void>;\n\npublic:\n  using UIntTy = uint32_t;\n  using IntTy = int32_t;\n\nprivate:\n  UIntTy ID = 0;\n\n  enum : UIntTy { MacroIDBit = 1ULL << (8 * sizeof(UIntTy) - 1) };\n\npublic:\n  bool isFileID() const  { return (ID & MacroIDBit) == 0; }\n  bool isMacroID() const { return (ID & MacroIDBit) != 0; }\n\n  /// Return true if this is a valid SourceLocation object.\n  ///\n  /// Invalid SourceLocations are often used when events have no corresponding\n  /// location in the source (e.g. a diagnostic is required for a command line\n  /// option).\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\nprivate:\n  /// Return the offset into the manager's global input view.\n  UIntTy getOffset() const { return ID & ~MacroIDBit; }\n\n  static SourceLocation getFileLoc(UIntTy ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = ID;\n    return L;\n  }\n\n  static SourceLocation getMacroLoc(UIntTy ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = MacroIDBit | ID;\n    return L;\n  }\n\npublic:\n  /// Return a source location with the specified offset from this\n  /// SourceLocation.\n  SourceLocation getLocWithOffset(IntTy Offset) const {\n    assert(((getOffset()+Offset) & MacroIDBit) == 0 && \"offset overflow\");\n    SourceLocation L;\n    L.ID = ID+Offset;\n    return L;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) 32-bit integer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromRawEncoding, it\n  /// should not be inspected directly.\n  UIntTy getRawEncoding() const { return ID; }\n\n  /// Turn a raw encoding of a SourceLocation object into\n  /// a real SourceLocation.\n  ///\n  /// \\see getRawEncoding.\n  static SourceLocation getFromRawEncoding(UIntTy Encoding) {\n    SourceLocation X;\n    X.ID = Encoding;\n    return X;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) pointer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromPtrEncoding, it\n  /// should not be inspected directly.\n  void* getPtrEncoding() const {\n    // Double cast to avoid a warning \"cast to pointer from integer of different\n    // size\".\n    return (void*)(uintptr_t)getRawEncoding();\n  }\n\n  /// Turn a pointer encoding of a SourceLocation object back\n  /// into a real SourceLocation.\n  static SourceLocation getFromPtrEncoding(const void *Encoding) {\n    return getFromRawEncoding((SourceLocation::UIntTy)(uintptr_t)Encoding);\n  }\n\n  static bool isPairOfFileLocations(SourceLocation Start, SourceLocation End) {\n    return Start.isValid() && Start.isFileID() && End.isValid() &&\n           End.isFileID();\n  }\n\n  unsigned getHashValue() const;\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\ninline bool operator==(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() == RHS.getRawEncoding();\n}\n\ninline bool operator!=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return !(LHS == RHS);\n}\n\n// Ordering is meaningful only if LHS and RHS have the same FileID!\n// Otherwise use SourceManager::isBeforeInTranslationUnit().\ninline bool operator<(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() < RHS.getRawEncoding();\n}\ninline bool operator>(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() > RHS.getRawEncoding();\n}\ninline bool operator<=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() <= RHS.getRawEncoding();\n}\ninline bool operator>=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() >= RHS.getRawEncoding();\n}\n\n/// A trivial tuple used to represent a source range.\nclass SourceRange {\n  SourceLocation B;\n  SourceLocation E;\n\npublic:\n  SourceRange() = default;\n  SourceRange(SourceLocation loc) : B(loc), E(loc) {}\n  SourceRange(SourceLocation begin, SourceLocation end) : B(begin), E(end) {}\n\n  SourceLocation getBegin() const { return B; }\n  SourceLocation getEnd() const { return E; }\n\n  void setBegin(SourceLocation b) { B = b; }\n  void setEnd(SourceLocation e) { E = e; }\n\n  bool isValid() const { return B.isValid() && E.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n\n  bool operator==(const SourceRange &X) const {\n    return B == X.B && E == X.E;\n  }\n\n  bool operator!=(const SourceRange &X) const {\n    return B != X.B || E != X.E;\n  }\n\n  // Returns true iff other is wholly contained within this range.\n  bool fullyContains(const SourceRange &other) const {\n    return B <= other.B && E >= other.E;\n  }\n\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\n/// Represents a character-granular source range.\n///\n/// The underlying SourceRange can either specify the starting/ending character\n/// of the range, or it can specify the start of the range and the start of the\n/// last token of the range (a \"token range\").  In the token range case, the\n/// size of the last token must be measured to determine the actual end of the\n/// range.\nclass CharSourceRange {\n  SourceRange Range;\n  bool IsTokenRange = false;\n\npublic:\n  CharSourceRange() = default;\n  CharSourceRange(SourceRange R, bool ITR) : Range(R), IsTokenRange(ITR) {}\n\n  static CharSourceRange getTokenRange(SourceRange R) {\n    return CharSourceRange(R, true);\n  }\n\n  static CharSourceRange getCharRange(SourceRange R) {\n    return CharSourceRange(R, false);\n  }\n\n  static CharSourceRange getTokenRange(SourceLocation B, SourceLocation E) {\n    return getTokenRange(SourceRange(B, E));\n  }\n\n  static CharSourceRange getCharRange(SourceLocation B, SourceLocation E) {\n    return getCharRange(SourceRange(B, E));\n  }\n\n  /// Return true if the end of this range specifies the start of\n  /// the last token.  Return false if the end of this range specifies the last\n  /// character in the range.\n  bool isTokenRange() const { return IsTokenRange; }\n  bool isCharRange() const { return !IsTokenRange; }\n\n  SourceLocation getBegin() const { return Range.getBegin(); }\n  SourceLocation getEnd() const { return Range.getEnd(); }\n  SourceRange getAsRange() const { return Range; }\n\n  void setBegin(SourceLocation b) { Range.setBegin(b); }\n  void setEnd(SourceLocation e) { Range.setEnd(e); }\n  void setTokenRange(bool TR) { IsTokenRange = TR; }\n\n  bool isValid() const { return Range.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n};\n\n/// Represents an unpacked \"presumed\" location which can be presented\n/// to the user.\n///\n/// A 'presumed' location can be modified by \\#line and GNU line marker\n/// directives and is always the expansion point of a normal location.\n///\n/// You can get a PresumedLoc from a SourceLocation with SourceManager.\nclass PresumedLoc {\n  const char *Filename = nullptr;\n  FileID ID;\n  unsigned Line, Col;\n  SourceLocation IncludeLoc;\n\npublic:\n  PresumedLoc() = default;\n  PresumedLoc(const char *FN, FileID FID, unsigned Ln, unsigned Co,\n              SourceLocation IL)\n      : Filename(FN), ID(FID), Line(Ln), Col(Co), IncludeLoc(IL) {}\n\n  /// Return true if this object is invalid or uninitialized.\n  ///\n  /// This occurs when created with invalid source locations or when walking\n  /// off the top of a \\#include stack.\n  bool isInvalid() const { return Filename == nullptr; }\n  bool isValid() const { return Filename != nullptr; }\n\n  /// Return the presumed filename of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  const char *getFilename() const {\n    assert(isValid());\n    return Filename;\n  }\n\n  FileID getFileID() const {\n    assert(isValid());\n    return ID;\n  }\n\n  /// Return the presumed line number of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  unsigned getLine() const {\n    assert(isValid());\n    return Line;\n  }\n\n  /// Return the presumed column number of this location.\n  ///\n  /// This cannot be affected by \\#line, but is packaged here for convenience.\n  unsigned getColumn() const {\n    assert(isValid());\n    return Col;\n  }\n\n  /// Return the presumed include location of this location.\n  ///\n  /// This can be affected by GNU linemarker directives.\n  SourceLocation getIncludeLoc() const {\n    assert(isValid());\n    return IncludeLoc;\n  }\n};\n\nclass FileEntry;\n\n/// A SourceLocation and its associated SourceManager.\n///\n/// This is useful for argument passing to functions that expect both objects.\n///\n/// This class does not guarantee the presence of either the SourceManager or\n/// a valid SourceLocation. Clients should use `isValid()` and `hasManager()`\n/// before calling the member functions.\nclass FullSourceLoc : public SourceLocation {\n  const SourceManager *SrcMgr = nullptr;\n\npublic:\n  /// Creates a FullSourceLoc where isValid() returns \\c false.\n  FullSourceLoc() = default;\n\n  explicit FullSourceLoc(SourceLocation Loc, const SourceManager &SM)\n      : SourceLocation(Loc), SrcMgr(&SM) {}\n\n  /// Checks whether the SourceManager is present.\n  bool hasManager() const { return SrcMgr != nullptr; }\n\n  /// \\pre hasManager()\n  const SourceManager &getManager() const {\n    assert(SrcMgr && \"SourceManager is NULL.\");\n    return *SrcMgr;\n  }\n\n  FileID getFileID() const;\n\n  FullSourceLoc getExpansionLoc() const;\n  FullSourceLoc getSpellingLoc() const;\n  FullSourceLoc getFileLoc() const;\n  PresumedLoc getPresumedLoc(bool UseLineDirectives = true) const;\n  bool isMacroArgExpansion(FullSourceLoc *StartLoc = nullptr) const;\n  FullSourceLoc getImmediateMacroCallerLoc() const;\n  std::pair<FullSourceLoc, StringRef> getModuleImportLoc() const;\n  unsigned getFileOffset() const;\n\n  unsigned getExpansionLineNumber(bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(bool *Invalid = nullptr) const;\n\n  /// Decompose the underlying \\c SourceLocation into a raw (FileID + Offset)\n  /// pair, after walking through all expansion records.\n  ///\n  /// \\see SourceManager::getDecomposedExpansionLoc\n  std::pair<FileID, unsigned> getDecomposedExpansionLoc() const;\n\n  unsigned getSpellingLineNumber(bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(bool *Invalid = nullptr) const;\n\n  const char *getCharacterData(bool *Invalid = nullptr) const;\n\n  unsigned getLineNumber(bool *Invalid = nullptr) const;\n  unsigned getColumnNumber(bool *Invalid = nullptr) const;\n\n  const FileEntry *getFileEntry() const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  StringRef getBufferData(bool *Invalid = nullptr) const;\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc() const;\n\n  bool isInSystemHeader() const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(FullSourceLoc Loc) const {\n    assert(Loc.isValid());\n    assert(SrcMgr == Loc.SrcMgr && \"Loc comes from another SourceManager!\");\n    return isBeforeInTranslationUnitThan((SourceLocation)Loc);\n  }\n\n  /// Comparison function class, useful for sorting FullSourceLocs.\n  struct BeforeThanCompare {\n    bool operator()(const FullSourceLoc& lhs, const FullSourceLoc& rhs) const {\n      return lhs.isBeforeInTranslationUnitThan(rhs);\n    }\n  };\n\n  /// Prints information about this FullSourceLoc to stderr.\n  ///\n  /// This is useful for debugging.\n  void dump() const;\n\n  friend bool\n  operator==(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return LHS.getRawEncoding() == RHS.getRawEncoding() &&\n          LHS.SrcMgr == RHS.SrcMgr;\n  }\n\n  friend bool\n  operator!=(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n}",
  "id": "BLOCK-CPP-16875",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceLocation.h",
  "source_line": 31,
  "validation_status": "validated"
}