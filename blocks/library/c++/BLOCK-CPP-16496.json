{
  "code": "{\n\ninline raw_ostream &Indent(raw_ostream &Out, const unsigned int Space,\n                           bool IsDot) {\n  for (unsigned int I = 0; I < Space * 2; ++I)\n    Out << (IsDot ? \"&nbsp;\" : \" \");\n  return Out;\n}\n\ninline std::string JsonFormat(StringRef RawSR, bool AddQuotes) {\n  if (RawSR.empty())\n    return \"null\";\n\n  // Trim special characters.\n  std::string Str = RawSR.trim().str();\n  size_t Pos = 0;\n\n  // Escape backslashes.\n  while (true) {\n    Pos = Str.find('\\\\', Pos);\n    if (Pos == std::string::npos)\n      break;\n\n    // Prevent bad conversions.\n    size_t TempPos = (Pos != 0) ? Pos - 1 : 0;\n\n    // See whether the current backslash is not escaped.\n    if (TempPos != Str.find(\"\\\\\\\\\", Pos)) {\n      Str.insert(Pos, \"\\\\\");\n      ++Pos; // As we insert the backslash move plus one.\n    }\n\n    ++Pos;\n  }\n\n  // Escape double quotes.\n  Pos = 0;\n  while (true) {\n    Pos = Str.find('\\\"', Pos);\n    if (Pos == std::string::npos)\n      break;\n\n    // Prevent bad conversions.\n    size_t TempPos = (Pos != 0) ? Pos - 1 : 0;\n\n    // See whether the current double quote is not escaped.\n    if (TempPos != Str.find(\"\\\\\\\"\", Pos)) {\n      Str.insert(Pos, \"\\\\\");\n      ++Pos; // As we insert the escape-character move plus one.\n    }\n\n    ++Pos;\n  }\n\n  // Remove new-lines.\n  llvm::erase_value(Str, '\\n');\n\n  if (!AddQuotes)\n    return Str;\n\n  return '\\\"' + Str + '\\\"';\n}\n\ninline void printSourceLocationAsJson(raw_ostream &Out, SourceLocation Loc,\n                                      const SourceManager &SM,\n                                      bool AddBraces = true) {\n  // Mostly copy-pasted from SourceLocation::print.\n  if (!Loc.isValid()) {\n    Out << \"null\";\n    return;\n  }\n\n  if (Loc.isFileID()) {\n    PresumedLoc PLoc = SM.getPresumedLoc(Loc);\n\n    if (PLoc.isInvalid()) {\n      Out << \"null\";\n      return;\n    }\n    // The macro expansion and spelling pos is identical for file locs.\n    if (AddBraces)\n      Out << \"{ \";\n    std::string filename(PLoc.getFilename());\n    if (is_style_windows(llvm::sys::path::Style::native)) {\n      // Remove forbidden Windows path characters\n      llvm::erase_if(filename, [](auto Char) {\n        static const char ForbiddenChars[] = \"<>*?\\\"|\";\n        return llvm::is_contained(ForbiddenChars, Char);\n      });\n      // Handle windows-specific path delimiters.\n      std::replace(filename.begin(), filename.end(), '\\\\', '/');\n    }\n    Out << \"\\\"line\\\": \" << PLoc.getLine()\n        << \", \\\"column\\\": \" << PLoc.getColumn()\n        << \", \\\"file\\\": \\\"\" << filename << \"\\\"\";\n    if (AddBraces)\n      Out << \" }\";\n    return;\n  }\n\n  // We want 'location: { ..., spelling: { ... }}' but not\n  // 'location: { ... }, spelling: { ... }', hence the dance\n  // with braces.\n  Out << \"{ \";\n  printSourceLocationAsJson(Out, SM.getExpansionLoc(Loc), SM, false);\n  Out << \", \\\"spelling\\\": \";\n  printSourceLocationAsJson(Out, SM.getSpellingLoc(Loc), SM, true);\n  Out << \" }\";\n}\n}",
  "id": "BLOCK-CPP-16496",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/JsonSupport.h",
  "source_line": 19,
  "validation_status": "validated"
}