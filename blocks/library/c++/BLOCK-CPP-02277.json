{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace {\n\ninline cctz::time_point<cctz::seconds> unix_epoch() {\n  return std::chrono::time_point_cast<cctz::seconds>(\n      std::chrono::system_clock::from_time_t(0));\n}\n\n// Floors d to the next unit boundary closer to negative infinity.\ninline int64_t FloorToUnit(absl::Duration d, absl::Duration unit) {\n  absl::Duration rem;\n  int64_t q = absl::IDivDuration(d, unit, &rem);\n  return (q > 0 || rem >= ZeroDuration() ||\n          q == std::numeric_limits<int64_t>::min())\n             ? q\n             : q - 1;\n}\n\nABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING\ninline absl::Time::Breakdown InfiniteFutureBreakdown() {\n  absl::Time::Breakdown bd;\n  bd.year = std::numeric_limits<int64_t>::max();\n  bd.month = 12;\n  bd.day = 31;\n  bd.hour = 23;\n  bd.minute = 59;\n  bd.second = 59;\n  bd.subsecond = absl::InfiniteDuration();\n  bd.weekday = 4;\n  bd.yearday = 365;\n  bd.offset = 0;\n  bd.is_dst = false;\n  bd.zone_abbr = \"-00\";\n  return bd;\n}\n\ninline absl::Time::Breakdown InfinitePastBreakdown() {\n  Time::Breakdown bd;\n  bd.year = std::numeric_limits<int64_t>::min();\n  bd.month = 1;\n  bd.day = 1;\n  bd.hour = 0;\n  bd.minute = 0;\n  bd.second = 0;\n  bd.subsecond = -absl::InfiniteDuration();\n  bd.weekday = 7;\n  bd.yearday = 1;\n  bd.offset = 0;\n  bd.is_dst = false;\n  bd.zone_abbr = \"-00\";\n  return bd;\n}\nABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING\n\ninline absl::TimeZone::CivilInfo InfiniteFutureCivilInfo() {\n  TimeZone::CivilInfo ci;\n  ci.cs = CivilSecond::max();\n  ci.subsecond = InfiniteDuration();\n  ci.offset = 0;\n  ci.is_dst = false;\n  ci.zone_abbr = \"-00\";\n  return ci;\n}\n\ninline absl::TimeZone::CivilInfo InfinitePastCivilInfo() {\n  TimeZone::CivilInfo ci;\n  ci.cs = CivilSecond::min();\n  ci.subsecond = -InfiniteDuration();\n  ci.offset = 0;\n  ci.is_dst = false;\n  ci.zone_abbr = \"-00\";\n  return ci;\n}\n\nABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING\ninline absl::TimeConversion InfiniteFutureTimeConversion() {\n  absl::TimeConversion tc;\n  tc.pre = tc.trans = tc.post = absl::InfiniteFuture();\n  tc.kind = absl::TimeConversion::UNIQUE;\n  tc.normalized = true;\n  return tc;\n}\n\ninline TimeConversion InfinitePastTimeConversion() {\n  absl::TimeConversion tc;\n  tc.pre = tc.trans = tc.post = absl::InfinitePast();\n  tc.kind = absl::TimeConversion::UNIQUE;\n  tc.normalized = true;\n  return tc;\n}\nABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING\n\n// Makes a Time from sec, overflowing to InfiniteFuture/InfinitePast as\n// necessary. If sec is min/max, then consult cs+tz to check for overflow.\nTime MakeTimeWithOverflow(const cctz::time_point<cctz::seconds>& sec,\n                          const cctz::civil_second& cs,\n                          const cctz::time_zone& tz,\n                          bool* normalized = nullptr) {\n  const auto max = cctz::time_point<cctz::seconds>::max();\n  const auto min = cctz::time_point<cctz::seconds>::min();\n  if (sec == max) {\n    const auto al = tz.lookup(max);\n    if (cs > al.cs) {\n      if (normalized) *normalized = true;\n      return absl::InfiniteFuture();\n    }\n  }\n  if (sec == min) {\n    const auto al = tz.lookup(min);\n    if (cs < al.cs) {\n      if (normalized) *normalized = true;\n      return absl::InfinitePast();\n    }\n  }\n  const auto hi = (sec - unix_epoch()).count();\n  return time_internal::FromUnixDuration(time_internal::MakeDuration(hi));\n}\n\n// Returns Mon=1..Sun=7.\ninline int MapWeekday(const cctz::weekday& wd) {\n  switch (wd) {\n    case cctz::weekday::monday:\n      return 1;\n    case cctz::weekday::tuesday:\n      return 2;\n    case cctz::weekday::wednesday:\n      return 3;\n    case cctz::weekday::thursday:\n      return 4;\n    case cctz::weekday::friday:\n      return 5;\n    case cctz::weekday::saturday:\n      return 6;\n    case cctz::weekday::sunday:\n      return 7;\n  }\n  return 1;\n}\n\nbool FindTransition(const cctz::time_zone& tz,\n                    bool (cctz::time_zone::*find_transition)(\n                        const cctz::time_point<cctz::seconds>& tp,\n                        cctz::time_zone::civil_transition* trans) const,\n                    Time t, TimeZone::CivilTransition* trans) {\n  // Transitions are second-aligned, so we can discard any fractional part.\n  const auto tp = unix_epoch() + cctz::seconds(ToUnixSeconds(t));\n  cctz::time_zone::civil_transition tr;\n  if (!(tz.*find_transition)(tp, &tr)) return false;\n  trans->from = CivilSecond(tr.from);\n  trans->to = CivilSecond(tr.to);\n  return true;\n}\n\n}  // namespace\n\n//\n// Time\n//\n\nABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING\nabsl::Time::Breakdown Time::In(absl::TimeZone tz) const {\n  if (*this == absl::InfiniteFuture()) return InfiniteFutureBreakdown();\n  if (*this == absl::InfinitePast()) return InfinitePastBreakdown();\n\n  const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(rep_));\n  const auto al = cctz::time_zone(tz).lookup(tp);\n  const auto cs = al.cs;\n  const auto cd = cctz::civil_day(cs);\n\n  absl::Time::Breakdown bd;\n  bd.year = cs.year();\n  bd.month = cs.month();\n  bd.day = cs.day();\n  bd.hour = cs.hour();\n  bd.minute = cs.minute();\n  bd.second = cs.second();\n  bd.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(rep_));\n  bd.weekday = MapWeekday(cctz::get_weekday(cd));\n  bd.yearday = cctz::get_yearday(cd);\n  bd.offset = al.offset;\n  bd.is_dst = al.is_dst;\n  bd.zone_abbr = al.abbr;\n  return bd;\n}\nABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING\n\n//\n// Conversions from/to other time types.\n//\n\nabsl::Time FromUDate(double udate) {\n  return time_internal::FromUnixDuration(absl::Milliseconds(udate));\n}\n\nabsl::Time FromUniversal(int64_t universal) {\n  return absl::UniversalEpoch() + 100 * absl::Nanoseconds(universal);\n}\n\nint64_t ToUnixNanos(Time t) {\n  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&\n      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 33 == 0) {\n    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *\n            1000 * 1000 * 1000) +\n           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4);\n  }\n  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Nanoseconds(1));\n}\n\nint64_t ToUnixMicros(Time t) {\n  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&\n      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 43 == 0) {\n    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *\n            1000 * 1000) +\n           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4000);\n  }\n  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Microseconds(1));\n}\n\nint64_t ToUnixMillis(Time t) {\n  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&\n      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 53 == 0) {\n    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) * 1000) +\n           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) /\n            (4000 * 1000));\n  }\n  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Milliseconds(1));\n}\n\nint64_t ToUnixSeconds(Time t) {\n  return time_internal::GetRepHi(time_internal::ToUnixDuration(t));\n}\n\ntime_t ToTimeT(Time t) { return absl::ToTimespec(t).tv_sec; }\n\ndouble ToUDate(Time t) {\n  return absl::FDivDuration(time_internal::ToUnixDuration(t),\n                            absl::Milliseconds(1));\n}\n\nint64_t ToUniversal(absl::Time t) {\n  return absl::FloorToUnit(t - absl::UniversalEpoch(), absl::Nanoseconds(100));\n}\n\nabsl::Time TimeFromTimespec(timespec ts) {\n  return time_internal::FromUnixDuration(absl::DurationFromTimespec(ts));\n}\n\nabsl::Time TimeFromTimeval(timeval tv) {\n  return time_internal::FromUnixDuration(absl::DurationFromTimeval(tv));\n}\n\ntimespec ToTimespec(Time t) {\n  timespec ts;\n  absl::Duration d = time_internal::ToUnixDuration(t);\n  if (!time_internal::IsInfiniteDuration(d)) {\n    ts.tv_sec = static_cast<decltype(ts.tv_sec)>(time_internal::GetRepHi(d));\n    if (ts.tv_sec == time_internal::GetRepHi(d)) {  // no time_t narrowing\n      ts.tv_nsec = time_internal::GetRepLo(d) / 4;  // floor\n      return ts;\n    }\n  }\n  if (d >= absl::ZeroDuration()) {\n    ts.tv_sec = std::numeric_limits<time_t>::max();\n    ts.tv_nsec = 1000 * 1000 * 1000 - 1;\n  } else {\n    ts.tv_sec = std::numeric_limits<time_t>::min();\n    ts.tv_nsec = 0;\n  }\n  return ts;\n}\n\ntimeval ToTimeval(Time t) {\n  timeval tv;\n  timespec ts = absl::ToTimespec(t);\n  tv.tv_sec = static_cast<decltype(tv.tv_sec)>(ts.tv_sec);\n  if (tv.tv_sec != ts.tv_sec) {  // narrowing\n    if (ts.tv_sec < 0) {\n      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();\n      tv.tv_usec = 0;\n    } else {\n      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();\n      tv.tv_usec = 1000 * 1000 - 1;\n    }\n    return tv;\n  }\n  tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  // suseconds_t\n  return tv;\n}\n\nTime FromChrono(const std::chrono::system_clock::time_point& tp) {\n  return time_internal::FromUnixDuration(time_internal::FromChrono(\n      tp - std::chrono::system_clock::from_time_t(0)));\n}\n\nstd::chrono::system_clock::time_point ToChronoTime(absl::Time t) {\n  using D = std::chrono::system_clock::duration;\n  auto d = time_internal::ToUnixDuration(t);\n  if (d < ZeroDuration()) d = Floor(d, FromChrono(D{1}));\n  return std::chrono::system_clock::from_time_t(0) +\n         time_internal::ToChronoDuration<D>(d);\n}\n\n//\n// TimeZone\n//\n\nabsl::TimeZone::CivilInfo TimeZone::At(Time t) const {\n  if (t == absl::InfiniteFuture()) return InfiniteFutureCivilInfo();\n  if (t == absl::InfinitePast()) return InfinitePastCivilInfo();\n\n  const auto ud = time_internal::ToUnixDuration(t);\n  const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(ud));\n  const auto al = cz_.lookup(tp);\n\n  TimeZone::CivilInfo ci;\n  ci.cs = CivilSecond(al.cs);\n  ci.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(ud));\n  ci.offset = al.offset;\n  ci.is_dst = al.is_dst;\n  ci.zone_abbr = al.abbr;\n  return ci;\n}\n\nabsl::TimeZone::TimeInfo TimeZone::At(CivilSecond ct) const {\n  const cctz::civil_second cs(ct);\n  const auto cl = cz_.lookup(cs);\n\n  TimeZone::TimeInfo ti;\n  switch (cl.kind) {\n    case cctz::time_zone::civil_lookup::UNIQUE:\n      ti.kind = TimeZone::TimeInfo::UNIQUE;\n      break;\n    case cctz::time_zone::civil_lookup::SKIPPED:\n      ti.kind = TimeZone::TimeInfo::SKIPPED;\n      break;\n    case cctz::time_zone::civil_lookup::REPEATED:\n      ti.kind = TimeZone::TimeInfo::REPEATED;\n      break;\n  }\n  ti.pre = MakeTimeWithOverflow(cl.pre, cs, cz_);\n  ti.trans = MakeTimeWithOverflow(cl.trans, cs, cz_);\n  ti.post = MakeTimeWithOverflow(cl.post, cs, cz_);\n  return ti;\n}\n\nbool TimeZone::NextTransition(Time t, CivilTransition* trans) const {\n  return FindTransition(cz_, &cctz::time_zone::next_transition, t, trans);\n}\n\nbool TimeZone::PrevTransition(Time t, CivilTransition* trans) const {\n  return FindTransition(cz_, &cctz::time_zone::prev_transition, t, trans);\n}\n\n//\n// Conversions involving time zones.\n//\nABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING\nabsl::TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,\n                                     int min, int sec, TimeZone tz) {\n  // Avoids years that are too extreme for CivilSecond to normalize.\n  if (year > 300000000000) return InfiniteFutureTimeConversion();\n  if (year < -300000000000) return InfinitePastTimeConversion();\n\n  const CivilSecond cs(year, mon, day, hour, min, sec);\n  const auto ti = tz.At(cs);\n\n  TimeConversion tc;\n  tc.pre = ti.pre;\n  tc.trans = ti.trans;\n  tc.post = ti.post;\n  switch (ti.kind) {\n    case TimeZone::TimeInfo::UNIQUE:\n      tc.kind = TimeConversion::UNIQUE;\n      break;\n    case TimeZone::TimeInfo::SKIPPED:\n      tc.kind = TimeConversion::SKIPPED;\n      break;\n    case TimeZone::TimeInfo::REPEATED:\n      tc.kind = TimeConversion::REPEATED;\n      break;\n  }\n  tc.normalized = false;\n  if (year != cs.year() || mon != cs.month() || day != cs.day() ||\n      hour != cs.hour() || min != cs.minute() || sec != cs.second()) {\n    tc.normalized = true;\n  }\n  return tc;\n}\nABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING\n\nabsl::Time FromTM(const struct tm& tm, absl::TimeZone tz) {\n  civil_year_t tm_year = tm.tm_year;\n  // Avoids years that are too extreme for CivilSecond to normalize.\n  if (tm_year > 300000000000ll) return InfiniteFuture();\n  if (tm_year < -300000000000ll) return InfinitePast();\n  int tm_mon = tm.tm_mon;\n  if (tm_mon == std::numeric_limits<int>::max()) {\n    tm_mon -= 12;\n    tm_year += 1;\n  }\n  const auto ti = tz.At(CivilSecond(tm_year + 1900, tm_mon + 1, tm.tm_mday,\n                                    tm.tm_hour, tm.tm_min, tm.tm_sec));\n  return tm.tm_isdst == 0 ? ti.post : ti.pre;\n}\n\nstruct tm ToTM(absl::Time t, absl::TimeZone tz) {\n  struct tm tm = {};\n\n  const auto ci = tz.At(t);\n  const auto& cs = ci.cs;\n  tm.tm_sec = cs.second();\n  tm.tm_min = cs.minute();\n  tm.tm_hour = cs.hour();\n  tm.tm_mday = cs.day();\n  tm.tm_mon = cs.month() - 1;\n\n  // Saturates tm.tm_year in cases of over/underflow, accounting for the fact\n  // that tm.tm_year is years since 1900.\n  if (cs.year() < std::numeric_limits<int>::min() + 1900) {\n    tm.tm_year = std::numeric_limits<int>::min();\n  } else if (cs.year() > std::numeric_limits<int>::max()) {\n    tm.tm_year = std::numeric_limits<int>::max() - 1900;\n  } else {\n    tm.tm_year = static_cast<int>(cs.year() - 1900);\n  }\n\n  switch (GetWeekday(cs)) {\n    case Weekday::sunday:\n      tm.tm_wday = 0;\n      break;\n    case Weekday::monday:\n      tm.tm_wday = 1;\n      break;\n    case Weekday::tuesday:\n      tm.tm_wday = 2;\n      break;\n    case Weekday::wednesday:\n      tm.tm_wday = 3;\n      break;\n    case Weekday::thursday:\n      tm.tm_wday = 4;\n      break;\n    case Weekday::friday:\n      tm.tm_wday = 5;\n      break;\n    case Weekday::saturday:\n      tm.tm_wday = 6;\n      break;\n  }\n  tm.tm_yday = GetYearDay(cs) - 1;\n  tm.tm_isdst = ci.is_dst ? 1 : 0;\n\n  return tm;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02277",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.cc",
  "source_line": 49,
  "validation_status": "validated"
}