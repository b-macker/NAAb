{
  "code": "{\n\nstruct local_alloc_t {\n    HLOCAL hlocal_;\n\n    SPDLOG_CONSTEXPR local_alloc_t() SPDLOG_NOEXCEPT : hlocal_(nullptr) {}\n\n    local_alloc_t(local_alloc_t const &) = delete;\n    local_alloc_t &operator=(local_alloc_t const &) = delete;\n\n    ~local_alloc_t() SPDLOG_NOEXCEPT {\n        if (hlocal_) {\n            LocalFree(hlocal_);\n        }\n    }\n};\n\n/** Windows error */\nstruct win32_error : public spdlog_ex {\n    /** Formats an error report line: \"user-message: error-code (system message)\" */\n    static std::string format(std::string const &user_message, DWORD error_code = GetLastError()) {\n        std::string system_message;\n\n        local_alloc_t format_message_result{};\n        auto format_message_succeeded =\n            ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n                                 FORMAT_MESSAGE_IGNORE_INSERTS,\n                             nullptr, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                             (LPSTR)&format_message_result.hlocal_, 0, nullptr);\n\n        if (format_message_succeeded && format_message_result.hlocal_) {\n            system_message = fmt_lib::format(\" ({})\", (LPSTR)format_message_result.hlocal_);\n        }\n\n        return fmt_lib::format(\"{}: {}{}\", user_message, error_code, system_message);\n    }\n\n    explicit win32_error(std::string const &func_name, DWORD error = GetLastError())\n        : spdlog_ex(format(func_name, error)) {}\n};\n\n/** Wrapper for security identifiers (SID) on Windows */\nstruct sid_t {\n    std::vector<char> buffer_;\n\npublic:\n    sid_t() {}\n\n    /** creates a wrapped SID copy */\n    static sid_t duplicate_sid(PSID psid) {\n        if (!::IsValidSid(psid)) {\n            throw_spdlog_ex(\"sid_t::sid_t(): invalid SID received\");\n        }\n\n        auto const sid_length{::GetLengthSid(psid)};\n\n        sid_t result;\n        result.buffer_.resize(sid_length);\n        if (!::CopySid(sid_length, (PSID)result.as_sid(), psid)) {\n            SPDLOG_THROW(win32_error(\"CopySid\"));\n        }\n\n        return result;\n    }\n\n    /** Retrieves pointer to the internal buffer contents as SID* */\n    SID *as_sid() const { return buffer_.empty() ? nullptr : (SID *)buffer_.data(); }\n\n    /** Get SID for the current user */\n    static sid_t get_current_user_sid() {\n        /* create and init RAII holder for process token */\n        struct process_token_t {\n            HANDLE token_handle_ = INVALID_HANDLE_VALUE;\n            explicit process_token_t(HANDLE process) {\n                if (!::OpenProcessToken(process, TOKEN_QUERY, &token_handle_)) {\n                    SPDLOG_THROW(win32_error(\"OpenProcessToken\"));\n                }\n            }\n\n            ~process_token_t() { ::CloseHandle(token_handle_); }\n\n        } current_process_token(\n            ::GetCurrentProcess());  // GetCurrentProcess returns pseudohandle, no leak here!\n\n        // Get the required size, this is expected to fail with ERROR_INSUFFICIENT_BUFFER and return\n        // the token size\n        DWORD tusize = 0;\n        if (::GetTokenInformation(current_process_token.token_handle_, TokenUser, NULL, 0,\n                                  &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation should fail\"));\n        }\n\n        // get user token\n        std::vector<unsigned char> buffer(static_cast<size_t>(tusize));\n        if (!::GetTokenInformation(current_process_token.token_handle_, TokenUser,\n                                   (LPVOID)buffer.data(), tusize, &tusize)) {\n            SPDLOG_THROW(win32_error(\"GetTokenInformation\"));\n        }\n\n        // create a wrapper of the SID data as stored in the user token\n        return sid_t::duplicate_sid(((TOKEN_USER *)buffer.data())->User.Sid);\n    }\n};\n\nstruct eventlog {\n    static WORD get_event_type(details::log_msg const &msg) {\n        switch (msg.level) {\n            case level::trace:\n            case level::debug:\n                return EVENTLOG_SUCCESS;\n\n            case level::info:\n                return EVENTLOG_INFORMATION_TYPE;\n\n            case level::warn:\n                return EVENTLOG_WARNING_TYPE;\n\n            case level::err:\n            case level::critical:\n            case level::off:\n                return EVENTLOG_ERROR_TYPE;\n\n            default:\n                return EVENTLOG_INFORMATION_TYPE;\n        }\n    }\n\n    static WORD get_event_category(details::log_msg const &msg) { return (WORD)msg.level; }\n};\n\n}",
  "id": "BLOCK-CPP-00513",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/win_eventlog_sink.h",
  "source_line": 51,
  "validation_status": "validated"
}