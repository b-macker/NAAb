{
  "code": "{\n//   ...\n//   // encounter error\n//   if (error condition) {\n//     // Construct an absl::StatusCode::kInvalidArgument error\n//     return absl::InvalidArgumentError(\"bad mode\");\n//   }\n//   // else, return OK\n//   return absl::OkStatus();\n// }\n//\n// Users handling status error codes should prefer checking for an OK status\n// using the `ok()` member function. Handling multiple error codes may justify\n// use of switch statement, but only check for error codes you know how to\n// handle; do not try to exhaustively match against all canonical error codes.\n// Errors that cannot be handled should be logged and/or propagated for higher\n// levels to deal with. If you do use a switch statement, make sure that you\n// also provide a `default:` switch case, so that code does not break as other\n// canonical codes are added to the API.\n//\n// Example:\n//\n//   absl::Status result = DoSomething();\n//   if (!result.ok()) {\n//     LOG(ERROR) << result;\n//   }\n//\n//   // Provide a default if switching on multiple error codes\n//   switch (result.code()) {\n//     // The user hasn't authenticated. Ask them to reauth\n//     case absl::StatusCode::kUnauthenticated:\n//       DoReAuth();\n//       break;\n//     // The user does not have permission. Log an error.\n//     case absl::StatusCode::kPermissionDenied:\n//       LOG(ERROR) << result;\n//       break;\n//     // Propagate the error otherwise.\n//     default:\n//       return true;\n//   }\n//\n// An `absl::Status` can optionally include a payload with more information\n// about the error. Typically, this payload serves one of several purposes:\n//\n//   * It may provide more fine-grained semantic information about the error to\n//     facilitate actionable remedies.\n//   * It may provide human-readable contextual information that is more\n//     appropriate to display to an end user.\n//\n// Example:\n//\n//   absl::Status result = DoSomething();\n//   // Inform user to retry after 30 seconds\n//   // See more error details in googleapis/google/rpc/error_details.proto\n//   if (absl::IsResourceExhausted(result)) {\n//     google::rpc::RetryInfo info;\n//     info.retry_delay().seconds() = 30;\n//     // Payloads require a unique key (a URL to ensure no collisions with\n//     // other payloads), and an `absl::Cord` to hold the encoded data.\n//     absl::string_view url = \"type.googleapis.com/google.rpc.RetryInfo\";\n//     result.SetPayload(url, info.SerializeAsCord());\n//     return result;\n//   }\n//\n// For documentation see https://abseil.io/docs/cpp/guides/status.\n//\n// Returned Status objects may not be ignored. status_internal.h has a forward\n// declaration of the form\n// class ABSL_MUST_USE_RESULT Status;\nclass ABSL_ATTRIBUTE_TRIVIAL_ABI Status final {\n public:\n  // Constructors\n\n  // This default constructor creates an OK status with no message or payload.\n  // Avoid this constructor and prefer explicit construction of an OK status\n  // with `absl::OkStatus()`.\n  Status();\n\n  // Creates a status in the canonical error space with the specified\n  // `absl::StatusCode` and error message.  If `code == absl::StatusCode::kOk`,  // NOLINT\n  // `msg` is ignored and an object identical to an OK status is constructed.\n  //\n  // The `msg` string must be in UTF-8. The implementation may complain (e.g.,  // NOLINT\n  // by printing a warning) if it is not.\n  Status(absl::StatusCode code, absl::string_view msg);\n\n  Status(const Status&);\n  Status& operator=(const Status& x);\n\n  // Move operators\n\n  // The moved-from state is valid but unspecified.\n  Status(Status&&) noexcept;\n  Status& operator=(Status&&);\n\n  ~Status();\n\n  // Status::Update()\n  //\n  // Updates the existing status with `new_status` provided that `this->ok()`.\n  // If the existing status already contains a non-OK error, this update has no\n  // effect and preserves the current data. Note that this behavior may change\n  // in the future to augment a current non-ok status with additional\n  // information about `new_status`.\n  //\n  // `Update()` provides a convenient way of keeping track of the first error\n  // encountered.\n  //\n  // Example:\n  //   // Instead of \"if (overall_status.ok()) overall_status = new_status\"\n  //   overall_status.Update(new_status);\n  //\n  void Update(const Status& new_status);\n  void Update(Status&& new_status);\n\n  // Status::ok()\n  //\n  // Returns `true` if `this->code()` == `absl::StatusCode::kOk`,\n  // indicating the absence of an error.\n  // Prefer checking for an OK status using this member function.\n  ABSL_MUST_USE_RESULT bool ok() const;\n\n  // Status::code()\n  //\n  // Returns the canonical error code of type `absl::StatusCode` of this status.\n  absl::StatusCode code() const;\n\n  // Status::raw_code()\n  //\n  // Returns a raw (canonical) error code corresponding to the enum value of\n  // `google.rpc.Code` definitions within\n  // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto.\n  // These values could be out of the range of canonical `absl::StatusCode`\n  // enum values.\n  //\n  // NOTE: This function should only be called when converting to an associated\n  // wire format. Use `Status::code()` for error handling.\n  int raw_code() const;\n\n  // Status::message()\n  //\n  // Returns the error message associated with this error code, if available.\n  // Note that this message rarely describes the error code.  It is not unusual\n  // for the error message to be the empty string. As a result, prefer\n  // `operator<<` or `Status::ToString()` for debug logging.\n  absl::string_view message() const;\n\n  friend bool operator==(const Status&, const Status&);\n  friend bool operator!=(const Status&, const Status&);\n\n  // Status::ToString()\n  //\n  // Returns a string based on the `mode`. By default, it returns combination of\n  // the error code name, the message and any associated payload messages. This\n  // string is designed simply to be human readable and its exact format should\n  // not be load bearing. Do not depend on the exact format of the result of\n  // `ToString()` which is subject to change.\n  //\n  // The printed code name and the message are generally substrings of the\n  // result, and the payloads to be printed use the status payload printer\n  // mechanism (which is internal).\n  std::string ToString(\n      StatusToStringMode mode = StatusToStringMode::kDefault) const;\n\n  // Support `absl::StrCat`, `absl::StrFormat`, etc.\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, const Status& status) {\n    sink.Append(status.ToString(StatusToStringMode::kWithEverything));\n  }\n\n  // Status::IgnoreError()\n  //\n  // Ignores any errors. This method does nothing except potentially suppress\n  // complaints from any tools that are checking that errors are not dropped on\n  // the floor.\n  void IgnoreError() const;\n\n  // swap()\n  //\n  // Swap the contents of one status with another.\n  friend void swap(Status& a, Status& b);\n\n  //----------------------------------------------------------------------------\n  // Payload Management APIs\n  //----------------------------------------------------------------------------\n\n  // A payload may be attached to a status to provide additional context to an\n  // error that may not be satisfied by an existing `absl::StatusCode`.\n  // Typically, this payload serves one of several purposes:\n  //\n  //   * It may provide more fine-grained semantic information about the error\n  //     to facilitate actionable remedies.\n  //   * It may provide human-readable contextual information that is more\n  //     appropriate to display to an end user.\n  //\n  // A payload consists of a [key,value] pair, where the key is a string\n  // referring to a unique \"type URL\" and the value is an object of type\n  // `absl::Cord` to hold the contextual data.\n  //\n  // The \"type URL\" should be unique and follow the format of a URL\n  // (https://en.wikipedia.org/wiki/URL) and, ideally, provide some\n  // documentation or schema on how to interpret its associated data. For\n  // example, the default type URL for a protobuf message type is\n  // \"type.googleapis.com/packagename.messagename\". Other custom wire formats\n  // should define the format of type URL in a similar practice so as to\n  // minimize the chance of conflict between type URLs.\n  // Users should ensure that the type URL can be mapped to a concrete\n  // C++ type if they want to deserialize the payload and read it effectively.\n  //\n  // To attach a payload to a status object, call `Status::SetPayload()`,\n  // passing it the type URL and an `absl::Cord` of associated data. Similarly,\n  // to extract the payload from a status, call `Status::GetPayload()`. You\n  // may attach multiple payloads (with differing type URLs) to any given\n  // status object, provided that the status is currently exhibiting an error\n  // code (i.e. is not OK).\n\n  // Status::GetPayload()\n  //\n  // Gets the payload of a status given its unique `type_url` key, if present.\n  absl::optional<absl::Cord> GetPayload(absl::string_view type_url) const;\n\n  // Status::SetPayload()\n  //\n  // Sets the payload for a non-ok status using a `type_url` key, overwriting\n  // any existing payload for that `type_url`.\n  //\n  // NOTE: This function does nothing if the Status is ok.\n  void SetPayload(absl::string_view type_url, absl::Cord payload);\n\n  // Status::ErasePayload()\n  //\n  // Erases the payload corresponding to the `type_url` key.  Returns `true` if\n  // the payload was present.\n  bool ErasePayload(absl::string_view type_url);\n\n  // Status::ForEachPayload()\n  //\n  // Iterates over the stored payloads and calls the\n  // `visitor(type_key, payload)` callable for each one.\n  //\n  // NOTE: The order of calls to `visitor()` is not specified and may change at\n  // any time.\n  //\n  // NOTE: Any mutation on the same 'absl::Status' object during visitation is\n  // forbidden and could result in undefined behavior.\n  void ForEachPayload(\n      absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)\n      const;\n\n private:\n  friend Status CancelledError();\n\n  // Creates a status in the canonical error space with the specified\n  // code, and an empty error message.\n  explicit Status(absl::StatusCode code);\n\n  // Underlying constructor for status from a rep_.\n  explicit Status(uintptr_t rep) : rep_(rep) {}\n\n  static void Ref(uintptr_t rep);\n  static void Unref(uintptr_t rep);\n\n  // REQUIRES: !ok()\n  // Ensures rep is not inlined or shared with any other Status.\n  static absl::Nonnull<status_internal::StatusRep*> PrepareToModify(\n      uintptr_t rep);\n\n  // MSVC 14.0 limitation requires the const.\n  static constexpr const char kMovedFromString[] =\n      \"Status accessed after move.\";\n\n  static absl::Nonnull<const std::string*> EmptyString();\n  static absl::Nonnull<const std::string*> MovedFromString();\n\n  // Returns whether rep contains an inlined representation.\n  // See rep_ for details.\n  static constexpr bool IsInlined(uintptr_t rep);\n\n  // Indicates whether this Status was the rhs of a move operation. See rep_\n  // for details.\n  static constexpr bool IsMovedFrom(uintptr_t rep);\n  static constexpr uintptr_t MovedFromRep();\n\n  // Convert between error::Code and the inlined uintptr_t representation used\n  // by rep_. See rep_ for details.\n  static constexpr uintptr_t CodeToInlinedRep(absl::StatusCode code);\n  static constexpr absl::StatusCode InlinedRepToCode(uintptr_t rep);\n\n  // Converts between StatusRep* and the external uintptr_t representation used\n  // by rep_. See rep_ for details.\n  static uintptr_t PointerToRep(status_internal::StatusRep* r);\n  static absl::Nonnull<const status_internal::StatusRep*> RepToPointer(\n      uintptr_t r);\n\n  static std::string ToStringSlow(uintptr_t rep, StatusToStringMode mode);\n\n  // Status supports two different representations.\n  //  - When the low bit is set it is an inlined representation.\n  //    It uses the canonical error space, no message or payload.\n  //    The error code is (rep_ >> 2).\n  //    The (rep_ & 2) bit is the \"moved from\" indicator, used in IsMovedFrom().\n  //  - When the low bit is off it is an external representation.\n  //    In this case all the data comes from a heap allocated Rep object.\n  //    rep_ is a status_internal::StatusRep* pointer to that structure.\n  uintptr_t rep_;\n\n  friend class status_internal::StatusRep;\n};\n\n// OkStatus()\n//\n// Returns an OK status, equivalent to a default constructed instance. Prefer\n// usage of `absl::OkStatus()` when constructing such an OK status.\nStatus OkStatus();\n\n// operator<<()\n//\n// Prints a human-readable representation of `x` to `os`.\nstd::ostream& operator<<(std::ostream& os, const Status& x);\n\n// IsAborted()\n// IsAlreadyExists()\n// IsCancelled()\n// IsDataLoss()\n// IsDeadlineExceeded()\n// IsFailedPrecondition()\n// IsInternal()\n// IsInvalidArgument()\n// IsNotFound()\n// IsOutOfRange()\n// IsPermissionDenied()\n// IsResourceExhausted()\n// IsUnauthenticated()\n// IsUnavailable()\n// IsUnimplemented()\n// IsUnknown()\n//\n// These convenience functions return `true` if a given status matches the\n// `absl::StatusCode` error code of its associated function.\nABSL_MUST_USE_RESULT bool IsAborted(const Status& status);\nABSL_MUST_USE_RESULT bool IsAlreadyExists(const Status& status);\nABSL_MUST_USE_RESULT bool IsCancelled(const Status& status);\nABSL_MUST_USE_RESULT bool IsDataLoss(const Status& status);\nABSL_MUST_USE_RESULT bool IsDeadlineExceeded(const Status& status);\nABSL_MUST_USE_RESULT bool IsFailedPrecondition(const Status& status);\nABSL_MUST_USE_RESULT bool IsInternal(const Status& status);\nABSL_MUST_USE_RESULT bool IsInvalidArgument(const Status& status);\nABSL_MUST_USE_RESULT bool IsNotFound(const Status& status);\nABSL_MUST_USE_RESULT bool IsOutOfRange(const Status& status);\nABSL_MUST_USE_RESULT bool IsPermissionDenied(const Status& status);\nABSL_MUST_USE_RESULT bool IsResourceExhausted(const Status& status);\nABSL_MUST_USE_RESULT bool IsUnauthenticated(const Status& status);\nABSL_MUST_USE_RESULT bool IsUnavailable(const Status& status);\nABSL_MUST_USE_RESULT bool IsUnimplemented(const Status& status);\nABSL_MUST_USE_RESULT bool IsUnknown(const Status& status);\n\n// AbortedError()\n// AlreadyExistsError()\n// CancelledError()\n// DataLossError()\n// DeadlineExceededError()\n// FailedPreconditionError()\n// InternalError()\n// InvalidArgumentError()\n// NotFoundError()\n// OutOfRangeError()\n// PermissionDeniedError()\n// ResourceExhaustedError()\n// UnauthenticatedError()\n// UnavailableError()\n// UnimplementedError()\n// UnknownError()\n//\n// These convenience functions create an `absl::Status` object with an error\n// code as indicated by the associated function name, using the error message\n// passed in `message`.\nStatus AbortedError(absl::string_view message);\nStatus AlreadyExistsError(absl::string_view message);\nStatus CancelledError(absl::string_view message);\nStatus DataLossError(absl::string_view message);\nStatus DeadlineExceededError(absl::string_view message);\nStatus FailedPreconditionError(absl::string_view message);\nStatus InternalError(absl::string_view message);\nStatus InvalidArgumentError(absl::string_view message);\nStatus NotFoundError(absl::string_view message);\nStatus OutOfRangeError(absl::string_view message);\nStatus PermissionDeniedError(absl::string_view message);\nStatus ResourceExhaustedError(absl::string_view message);\nStatus UnauthenticatedError(absl::string_view message);\nStatus UnavailableError(absl::string_view message);\nStatus UnimplementedError(absl::string_view message);\nStatus UnknownError(absl::string_view message);\n\n// ErrnoToStatusCode()\n//\n// Returns the StatusCode for `error_number`, which should be an `errno` value.\n// See https://en.cppreference.com/w/cpp/error/errno_macros and similar\n// references.\nabsl::StatusCode ErrnoToStatusCode(int error_number);\n\n// ErrnoToStatus()\n//\n// Convenience function that creates a `absl::Status` using an `error_number`,\n// which should be an `errno` value.\nStatus ErrnoToStatus(int error_number, absl::string_view message);\n\n//------------------------------------------------------------------------------\n// Implementation details follow\n//------------------------------------------------------------------------------\n\ninline Status::Status() : Status(absl::StatusCode::kOk) {}\n\ninline Status::Status(absl::StatusCode code) : Status(CodeToInlinedRep(code)) {}\n\ninline Status::Status(const Status& x) : Status(x.rep_) { Ref(rep_); }\n\ninline Status& Status::operator=(const Status& x) {\n  uintptr_t old_rep = rep_;\n  if (x.rep_ != old_rep) {\n    Ref(x.rep_);\n    rep_ = x.rep_;\n    Unref(old_rep);\n  }\n  return *this;\n}\n\ninline Status::Status(Status&& x) noexcept : Status(x.rep_) {\n  x.rep_ = MovedFromRep();\n}\n\ninline Status& Status::operator=(Status&& x) {\n  uintptr_t old_rep = rep_;\n  if (x.rep_ != old_rep) {\n    rep_ = x.rep_;\n    x.rep_ = MovedFromRep();\n    Unref(old_rep);\n  }\n  return *this;\n}\n\ninline void Status::Update(const Status& new_status) {\n  if (ok()) {\n    *this = new_status;\n  }\n}\n\ninline void Status::Update(Status&& new_status) {\n  if (ok()) {\n    *this = std::move(new_status);\n  }\n}\n\ninline Status::~Status() { Unref(rep_); }\n\ninline bool Status::ok() const {\n  return rep_ == CodeToInlinedRep(absl::StatusCode::kOk);\n}\n\ninline absl::StatusCode Status::code() const {\n  return status_internal::MapToLocalCode(raw_code());\n}\n\ninline int Status::raw_code() const {\n  if (IsInlined(rep_)) return static_cast<int>(InlinedRepToCode(rep_));\n  return static_cast<int>(RepToPointer(rep_)->code());\n}\n\ninline absl::string_view Status::message() const {\n  return !IsInlined(rep_)\n             ? RepToPointer(rep_)->message()\n             : (IsMovedFrom(rep_) ? absl::string_view(kMovedFromString)\n                                  : absl::string_view());\n}\n\ninline bool operator==(const Status& lhs, const Status& rhs) {\n  if (lhs.rep_ == rhs.rep_) return true;\n  if (Status::IsInlined(lhs.rep_)) return false;\n  if (Status::IsInlined(rhs.rep_)) return false;\n  return *Status::RepToPointer(lhs.rep_) == *Status::RepToPointer(rhs.rep_);\n}\n\ninline bool operator!=(const Status& lhs, const Status& rhs) {\n  return !(lhs == rhs);\n}\n\ninline std::string Status::ToString(StatusToStringMode mode) const {\n  return ok() ? \"OK\" : ToStringSlow(rep_, mode);\n}\n\ninline void Status::IgnoreError() const {\n  // no-op\n}\n\ninline void swap(absl::Status& a, absl::Status& b) {\n  using std::swap;\n  swap(a.rep_, b.rep_);\n}\n\ninline absl::optional<absl::Cord> Status::GetPayload(\n    absl::string_view type_url) const {\n  if (IsInlined(rep_)) return absl::nullopt;\n  return RepToPointer(rep_)->GetPayload(type_url);\n}\n\ninline void Status::SetPayload(absl::string_view type_url, absl::Cord payload) {\n  if (ok()) return;\n  status_internal::StatusRep* rep = PrepareToModify(rep_);\n  rep->SetPayload(type_url, std::move(payload));\n  rep_ = PointerToRep(rep);\n}\n\ninline bool Status::ErasePayload(absl::string_view type_url) {\n  if (IsInlined(rep_)) return false;\n  status_internal::StatusRep* rep = PrepareToModify(rep_);\n  auto res = rep->ErasePayload(type_url);\n  rep_ = res.new_rep;\n  return res.erased;\n}\n\ninline void Status::ForEachPayload(\n    absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)\n    const {\n  if (IsInlined(rep_)) return;\n  RepToPointer(rep_)->ForEachPayload(visitor);\n}\n\nconstexpr bool Status::IsInlined(uintptr_t rep) { return (rep & 1) != 0; }\n\nconstexpr bool Status::IsMovedFrom(uintptr_t rep) { return (rep & 2) != 0; }\n\nconstexpr uintptr_t Status::CodeToInlinedRep(absl::StatusCode code) {\n  return (static_cast<uintptr_t>(code) << 2) + 1;\n}\n\nconstexpr absl::StatusCode Status::InlinedRepToCode(uintptr_t rep) {\n  ABSL_ASSERT(IsInlined(rep));\n  return static_cast<absl::StatusCode>(rep >> 2);\n}\n\nconstexpr uintptr_t Status::MovedFromRep() {\n  return CodeToInlinedRep(absl::StatusCode::kInternal) | 2;\n}\n\ninline absl::Nonnull<const status_internal::StatusRep*> Status::RepToPointer(\n    uintptr_t rep) {\n  assert(!IsInlined(rep));\n  return reinterpret_cast<const status_internal::StatusRep*>(rep);\n}\n\ninline uintptr_t Status::PointerToRep(\n    absl::Nonnull<status_internal::StatusRep*> rep) {\n  return reinterpret_cast<uintptr_t>(rep);\n}\n\ninline void Status::Ref(uintptr_t rep) {\n  if (!IsInlined(rep)) RepToPointer(rep)->Ref();\n}\n\ninline void Status::Unref(uintptr_t rep) {\n  if (!IsInlined(rep)) RepToPointer(rep)->Unref();\n}\n\ninline Status OkStatus() { return Status(); }\n\n// Creates a `Status` object with the `absl::StatusCode::kCancelled` error code\n// and an empty message. It is provided only for efficiency, given that\n// message-less kCancelled errors are common in the infrastructure.\ninline Status CancelledError() { return Status(absl::StatusCode::kCancelled); }\n\n// Retrieves a message's status as a null terminated C string. The lifetime of\n// this string is tied to the lifetime of the status object itself.\n//\n// If the status's message is empty, the empty string is returned.\n//\n// StatusMessageAsCStr exists for C support. Use `status.message()` in C++.\nabsl::Nonnull<const char*> StatusMessageAsCStr(\n    const Status& status ABSL_ATTRIBUTE_LIFETIME_BOUND);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03941",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/status/status.h",
  "source_line": 361,
  "validation_status": "validated"
}