{
  "code": "#include <cstddef>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/log_severity.h\"\n#include \"absl/log/internal/config.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/time/time.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03669_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\nnamespace log_internal {\n// Test only friend.\nclass LogEntryTestPeer;\nclass LogMessage;\n}  // namespace log_internal\n\n// LogEntry\n//\n// Represents a single entry in a log, i.e., one `LOG` statement or failed\n// `CHECK`.\n//\n// `LogEntry` is thread-compatible.\nclass LogEntry final {\n public:\n  using tid_t = log_internal::Tid;\n\n  // For non-verbose log entries, `verbosity()` returns `kNoVerbosityLevel`.\n  static constexpr int kNoVerbosityLevel = -1;\n  static constexpr int kNoVerboseLevel = -1;  // TO BE removed\n\n  // Pass `LogEntry` by reference, and do not store it as its state does not\n  // outlive the call to `LogSink::Send()`.\n  LogEntry(const LogEntry&) = delete;\n  LogEntry& operator=(const LogEntry&) = delete;\n\n  // Source file and line where the log message occurred.  Taken from `__FILE__`\n  // and `__LINE__` unless overridden by `LOG(...).AtLocation(...)`.\n  //\n  // Take special care not to use the values returned by `source_filename()` and\n  // `source_basename()` after the lifetime of the entry.  This is always\n  // incorrect, but it will often work in practice because they usually point\n  // into a statically allocated character array obtained from `__FILE__`.\n  // Statements like `LOG(INFO).AtLocation(std::string(...), ...)` will expose\n  // the bug.  If you need the data later, you must copy them.\n  absl::string_view source_filename() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return full_filename_;\n  }\n  absl::string_view source_basename() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return base_filename_;\n  }\n  int source_line() const { return line_; }\n\n  // LogEntry::prefix()\n  //\n  // True unless the metadata prefix was suppressed once by\n  // `LOG(...).NoPrefix()` or globally by `absl::EnableLogPrefix(false)`.\n  // Implies `text_message_with_prefix() == text_message()`.\n  bool prefix() const { return prefix_; }\n\n  // LogEntry::log_severity()\n  //\n  // Returns this entry's severity.  For `LOG`, taken from the first argument;\n  // for `CHECK`, always `absl::LogSeverity::kFatal`.\n  absl::LogSeverity log_severity() const { return severity_; }\n\n  // LogEntry::verbosity()\n  //\n  // Returns this entry's verbosity, or `kNoVerbosityLevel` for a non-verbose\n  // entry. Taken from the argument to `VLOG` or from\n  // `LOG(...).WithVerbosity(...)`.\n  int verbosity() const { return verbose_level_; }\n\n  // LogEntry::timestamp()\n  //\n  // Returns the time at which this entry was written.  Captured during\n  // evaluation of `LOG`, but can be overridden by\n  // `LOG(...).WithTimestamp(...)`.\n  //\n  // Take care not to rely on timestamps increasing monotonically, or even to\n  // rely on timestamps having any particular relationship with reality (since\n  // they can be overridden).\n  absl::Time timestamp() const { return timestamp_; }\n\n  // LogEntry::tid()\n  //\n  // Returns the ID of the thread that wrote this entry.  Captured during\n  // evaluation of `LOG`, but can be overridden by `LOG(...).WithThreadID(...)`.\n  //\n  // Take care not to *rely* on reported thread IDs as they can be overridden as\n  // specified above.\n  tid_t tid() const { return tid_; }\n\n  // Text-formatted version of the log message.  An underlying buffer holds\n  // these contiguous data:\n  //\n  // * A prefix formed by formatting metadata (timestamp, filename, line number,\n  //   etc.)\n  //   The prefix may be empty - see `LogEntry::prefix()` - and may rarely be\n  //   truncated if the metadata are very long.\n  // * The streamed data\n  //   The data may be empty if nothing was streamed, or may be truncated to fit\n  //   the buffer.\n  // * A newline\n  // * A nul terminator\n  //\n  // The newline and nul terminator will be present even if the prefix and/or\n  // data are truncated.\n  //\n  // These methods give access to the most commonly useful substrings of the\n  // buffer's contents.  Other combinations can be obtained with substring\n  // arithmetic.\n  //\n  // The buffer does not outlive the entry; if you need the data later, you must\n  // copy them.\n  absl::string_view text_message_with_prefix_and_newline() const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return absl::string_view(\n        text_message_with_prefix_and_newline_and_nul_.data(),\n        text_message_with_prefix_and_newline_and_nul_.size() - 1);\n  }\n  absl::string_view text_message_with_prefix() const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return absl::string_view(\n        text_message_with_prefix_and_newline_and_nul_.data(),\n        text_message_with_prefix_and_newline_and_nul_.size() - 2);\n  }\n  absl::string_view text_message_with_newline() const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return absl::string_view(\n        text_message_with_prefix_and_newline_and_nul_.data() + prefix_len_,\n        text_message_with_prefix_and_newline_and_nul_.size() - prefix_len_ - 1);\n  }\n  absl::string_view text_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return absl::string_view(\n        text_message_with_prefix_and_newline_and_nul_.data() + prefix_len_,\n        text_message_with_prefix_and_newline_and_nul_.size() - prefix_len_ - 2);\n  }\n  const char* text_message_with_prefix_and_newline_c_str() const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return text_message_with_prefix_and_newline_and_nul_.data();\n  }\n\n  // Returns a serialized protobuf holding the operands streamed into this\n  // log message.  The message definition is not yet published.\n  //\n  // The buffer does not outlive the entry; if you need the data later, you must\n  // copy them.\n  absl::string_view encoded_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return encoding_;\n  }\n\n  // LogEntry::stacktrace()\n  //\n  // Optional stacktrace, e.g. for `FATAL` logs and failed `CHECK`s.\n  //\n  // Fatal entries are dispatched to each sink twice: first with all data and\n  // metadata but no stacktrace, and then with the stacktrace.  This is done\n  // because stacktrace collection is sometimes slow and fallible, and it's\n  // critical to log enough information to diagnose the failure even if the\n  // stacktrace collection hangs.\n  //\n  // The buffer does not outlive the entry; if you need the data later, you must\n  // copy them.\n  absl::string_view stacktrace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return stacktrace_;\n  }\n\n private:\n  LogEntry() = default;\n\n  absl::string_view full_filename_;\n  absl::string_view base_filename_;\n  int line_;\n  bool prefix_;\n  absl::LogSeverity severity_;\n  int verbose_level_;  // >=0 for `VLOG`, etc.; otherwise `kNoVerbosityLevel`.\n  absl::Time timestamp_;\n  tid_t tid_;\n  absl::Span<const char> text_message_with_prefix_and_newline_and_nul_;\n  size_t prefix_len_;\n  absl::string_view encoding_;\n  std::string stacktrace_;\n\n  friend class log_internal::LogEntryTestPeer;\n  friend class log_internal::LogMessage;\n};\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03669",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/log_entry.h",
  "source_line": 38,
  "validation_status": "validated"
}