{
  "code": "{\npublic:\n  /// The basic Objective-C runtimes that we know about.\n  enum Kind {\n    /// 'macosx' is the Apple-provided NeXT-derived runtime on Mac OS\n    /// X platforms that use the non-fragile ABI; the version is a\n    /// release of that OS.\n    MacOSX,\n\n    /// 'macosx-fragile' is the Apple-provided NeXT-derived runtime on\n    /// Mac OS X platforms that use the fragile ABI; the version is a\n    /// release of that OS.\n    FragileMacOSX,\n\n    /// 'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS\n    /// simulator;  it is always non-fragile.  The version is a release\n    /// version of iOS.\n    iOS,\n\n    /// 'watchos' is a variant of iOS for Apple's watchOS. The version\n    /// is a release version of watchOS.\n    WatchOS,\n\n    /// 'gcc' is the Objective-C runtime shipped with GCC, implementing a\n    /// fragile Objective-C ABI\n    GCC,\n\n    /// 'gnustep' is the modern non-fragile GNUstep runtime.\n    GNUstep,\n\n    /// 'objfw' is the Objective-C runtime included in ObjFW\n    ObjFW\n  };\n\nprivate:\n  Kind TheKind = MacOSX;\n  VersionTuple Version;\n\npublic:\n  /// A bogus initialization of the runtime.\n  ObjCRuntime() = default;\n  ObjCRuntime(Kind kind, const VersionTuple &version)\n      : TheKind(kind), Version(version) {}\n\n  void set(Kind kind, VersionTuple version) {\n    TheKind = kind;\n    Version = version;\n  }\n\n  Kind getKind() const { return TheKind; }\n  const VersionTuple &getVersion() const { return Version; }\n\n  /// Does this runtime follow the set of implied behaviors for a\n  /// \"non-fragile\" ABI?\n  bool isNonFragile() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case GCC: return false;\n    case MacOSX: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// The inverse of isNonFragile():  does this runtime follow the set of\n  /// implied behaviors for a \"fragile\" ABI?\n  bool isFragile() const { return !isNonFragile(); }\n\n  /// The default dispatch mechanism to use for the specified architecture\n  bool isLegacyDispatchDefaultForArch(llvm::Triple::ArchType Arch) {\n    // The GNUstep runtime uses a newer dispatch method by default from\n    // version 1.6 onwards\n    if (getKind() == GNUstep && getVersion() >= VersionTuple(1, 6)) {\n      if (Arch == llvm::Triple::arm ||\n          Arch == llvm::Triple::x86 ||\n          Arch == llvm::Triple::x86_64)\n        return false;\n    }\n    else if ((getKind() ==  MacOSX) && isNonFragile() &&\n             (getVersion() >= VersionTuple(10, 0)) &&\n             (getVersion() < VersionTuple(10, 6)))\n        return Arch != llvm::Triple::x86_64;\n    // Except for deployment target of 10.5 or less,\n    // Mac runtimes use legacy dispatch everywhere now.\n    return true;\n  }\n\n  /// Is this runtime basically of the GNU family of runtimes?\n  bool isGNUFamily() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return false;\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is this runtime basically of the NeXT family of runtimes?\n  bool isNeXTFamily() const {\n    // For now, this is just the inverse of isGNUFamily(), but that's\n    // not inherently true.\n    return !isGNUFamily();\n  }\n\n  /// Does this runtime allow ARC at all?\n  bool allowsARC() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      // No stub library for the fragile runtime.\n      return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime natively provide the ARC entrypoints?\n  ///\n  /// ARC cannot be directly supported on a platform that does not provide\n  /// these entrypoints, although it may be supportable via a stub\n  /// library.\n  bool hasNativeARC() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return getVersion() >= VersionTuple(10, 7);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n\n    case GCC: return false;\n    case GNUstep: return getVersion() >= VersionTuple(1, 6);\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide ARC entrypoints that are likely to be faster\n  /// than an ordinary message send of the appropriate selector?\n  ///\n  /// The ARC entrypoints are guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// retain/release behavior; if that's dynamically a large proportion of all\n  /// retained objects, using the entrypoint will also be faster than using a\n  /// message send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the correspond entrypoint:\n  ///   retain => objc_retain\n  ///   release => objc_release\n  ///   autorelease => objc_autorelease\n  bool shouldUseARCFunctionsForRetainRelease() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide entrypoints that are likely to be faster\n  /// than an ordinary message send of the \"alloc\" selector?\n  ///\n  /// The \"alloc\" entrypoint is guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// alloc behavior; if that's dynamically a large proportion of all\n  /// objects, using the entrypoint will also be faster than using a message\n  /// send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the corresponding entrypoint:\n  ///   alloc => objc_alloc\n  ///   allocWithZone:nil => objc_allocWithZone\n  bool shouldUseRuntimeFunctionsForAlloc() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide the objc_alloc_init entrypoint? This can apply\n  /// the same optimization as objc_alloc, but also sends an -init message,\n  /// reducing code size on the caller.\n  bool shouldUseRuntimeFunctionForCombinedAllocInit() const {\n    switch (getKind()) {\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 14, 4);\n    case iOS:\n      return getVersion() >= VersionTuple(12, 2);\n    case WatchOS:\n      return getVersion() >= VersionTuple(5, 2);\n    default:\n      return false;\n    }\n  }\n\n  /// Does this runtime supports optimized setter entrypoints?\n  bool hasOptimizedSetter() const {\n    switch (getKind()) {\n      case MacOSX:\n        return getVersion() >= VersionTuple(10, 8);\n      case iOS:\n        return (getVersion() >= VersionTuple(6));\n      case WatchOS:\n        return true;\n      case GNUstep:\n        return getVersion() >= VersionTuple(1, 7);\n      default:\n        return false;\n    }\n  }\n\n  /// Does this runtime allow the use of __weak?\n  bool allowsWeak() const {\n    return hasNativeWeak();\n  }\n\n  /// Does this runtime natively provide ARC-compliant 'weak'\n  /// entrypoints?\n  bool hasNativeWeak() const {\n    // Right now, this is always equivalent to whether the runtime\n    // natively supports ARC decision.\n    return hasNativeARC();\n  }\n\n  /// Does this runtime directly support the subscripting methods?\n  ///\n  /// This is really a property of the library, not the runtime.\n  bool hasSubscripting() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return getVersion() >= VersionTuple(10, 11);\n    case iOS: return getVersion() >= VersionTuple(9);\n    case WatchOS: return true;\n\n    // This is really a lie, because some implementations and versions\n    // of the runtime do not support ARC.  Probably -fgnu-runtime\n    // should imply a \"maximal\" runtime or something?\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime allow sizeof or alignof on object types?\n  bool allowsSizeofAlignof() const {\n    return isFragile();\n  }\n\n  /// Does this runtime allow pointer arithmetic on objects?\n  ///\n  /// This covers +, -, ++, --, and (if isSubscriptPointerArithmetic()\n  /// yields true) [].\n  bool allowsPointerArithmetic() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n      return true;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is subscripting pointer arithmetic?\n  bool isSubscriptPointerArithmetic() const {\n    return allowsPointerArithmetic();\n  }\n\n  /// Does this runtime provide an objc_terminate function?\n  ///\n  /// This is used in handlers for exceptions during the unwind process;\n  /// without it, abort() must be used in pure ObjC files.\n  bool hasTerminate() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 8);\n    case MacOSX: return getVersion() >= VersionTuple(10, 8);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime support weakly importing classes?\n  bool hasWeakClassImport() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime use zero-cost exceptions?\n  bool hasUnwindExceptions() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  bool hasAtomicCopyHelper() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    case GNUstep:\n      return getVersion() >= VersionTuple(1, 7);\n    default: return false;\n    }\n  }\n\n  /// Is objc_unsafeClaimAutoreleasedReturnValue available?\n  bool hasARCUnsafeClaimAutoreleasedReturnValue() const {\n    switch (getKind()) {\n    case MacOSX:\n    case FragileMacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    case GNUstep:\n      return false;\n    default:\n      return false;\n    }\n  }\n\n  /// Are the empty collection symbols available?\n  bool hasEmptyCollections() const {\n    switch (getKind()) {\n    default:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    }\n  }\n\n  /// Returns true if this Objective-C runtime supports Objective-C class\n  /// stubs.\n  bool allowsClassStubs() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime supports direct dispatch\n  bool allowsDirectDispatch() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Try to parse an Objective-C runtime specification from the given\n  /// string.\n  ///\n  /// \\return true on error.\n  bool tryParse(StringRef input);\n\n  std::string getAsString() const;\n\n  friend bool operator==(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return left.getKind() == right.getKind() &&\n           left.getVersion() == right.getVersion();\n  }\n\n  friend bool operator!=(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return !(left == right);\n  }\n\n  friend llvm::hash_code hash_value(const ObjCRuntime &OCR) {\n    return llvm::hash_combine(OCR.getKind(), OCR.getVersion());\n  }\n\n  template <typename HasherT, llvm::support::endianness Endianness>\n  friend void addHash(llvm::HashBuilderImpl<HasherT, Endianness> &HBuilder,\n                      const ObjCRuntime &OCR) {\n    HBuilder.add(OCR.getKind(), OCR.getVersion());\n  }\n}",
  "id": "BLOCK-CPP-16683",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/ObjCRuntime.h",
  "source_line": 28,
  "validation_status": "validated"
}