{
  "code": "{\npublic:\n  Self *self() { return static_cast<Self *>(this); }\n\n  // Traverse an expression -- returning a result of type R_SExpr.\n  // Override this method to do something for every expression, regardless\n  // of which kind it is.\n  // E is a reference, so this can be use for in-place updates.\n  // The type T must be a subclass of SExpr.\n  template <class T>\n  typename R::R_SExpr traverse(T* &E, typename R::R_Ctx Ctx) {\n    return traverseSExpr(E, Ctx);\n  }\n\n  // Override this method to do something for every expression.\n  // Does not allow in-place updates.\n  typename R::R_SExpr traverseSExpr(SExpr *E, typename R::R_Ctx Ctx) {\n    return traverseByCase(E, Ctx);\n  }\n\n  // Helper method to call traverseX(e) on the appropriate type.\n  typename R::R_SExpr traverseByCase(SExpr *E, typename R::R_Ctx Ctx) {\n    switch (E->opcode()) {\n#define TIL_OPCODE_DEF(X)                                                   \\\n    case COP_##X:                                                           \\\n      return self()->traverse##X(cast<X>(E), Ctx);\n#include \"ThreadSafetyOps.def\"\n#undef TIL_OPCODE_DEF\n    }\n    return self()->reduceNull();\n  }\n\n// Traverse e, by static dispatch on the type \"X\" of e.\n// Override these methods to do something for a particular kind of term.\n#define TIL_OPCODE_DEF(X)                                                   \\\n  typename R::R_SExpr traverse##X(X *e, typename R::R_Ctx Ctx) {            \\\n    return e->traverse(*self(), Ctx);                                       \\\n  }\n#include \"ThreadSafetyOps.def\"\n#undef TIL_OPCODE_DEF\n}",
  "id": "BLOCK-CPP-21794",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h",
  "source_line": 57,
  "validation_status": "validated"
}