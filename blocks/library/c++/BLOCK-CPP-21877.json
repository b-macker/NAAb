{
  "code": "{\npublic:\n  Arena() : True(makeAtom()), False(makeAtom()) {}\n  Arena(const Arena &) = delete;\n  Arena &operator=(const Arena &) = delete;\n\n  /// Creates a `T` (some subclass of `StorageLocation`), forwarding `args` to\n  /// the constructor, and returns a reference to it.\n  ///\n  /// The `DataflowAnalysisContext` takes ownership of the created object. The\n  /// object will be destroyed when the `DataflowAnalysisContext` is destroyed.\n  template <typename T, typename... Args>\n  std::enable_if_t<std::is_base_of<StorageLocation, T>::value, T &>\n  create(Args &&...args) {\n    // Note: If allocation of individual `StorageLocation`s turns out to be\n    // costly, consider creating specializations of `create<T>` for commonly\n    // used `StorageLocation` subclasses and make them use a `BumpPtrAllocator`.\n    return *cast<T>(\n        Locs.emplace_back(std::make_unique<T>(std::forward<Args>(args)...))\n            .get());\n  }\n\n  /// Creates a `T` (some subclass of `Value`), forwarding `args` to the\n  /// constructor, and returns a reference to it.\n  ///\n  /// The `DataflowAnalysisContext` takes ownership of the created object. The\n  /// object will be destroyed when the `DataflowAnalysisContext` is destroyed.\n  template <typename T, typename... Args>\n  std::enable_if_t<std::is_base_of<Value, T>::value, T &>\n  create(Args &&...args) {\n    // Note: If allocation of individual `Value`s turns out to be costly,\n    // consider creating specializations of `create<T>` for commonly used\n    // `Value` subclasses and make them use a `BumpPtrAllocator`.\n    return *cast<T>(\n        Vals.emplace_back(std::make_unique<T>(std::forward<Args>(args)...))\n            .get());\n  }\n\n  /// Creates a BoolValue wrapping a particular formula.\n  ///\n  /// Passing in the same formula will result in the same BoolValue.\n  /// FIXME: Interning BoolValues but not other Values is inconsistent.\n  ///        Decide whether we want Value interning or not.\n  BoolValue &makeBoolValue(const Formula &);\n\n  /// Creates a fresh atom and wraps in in an AtomicBoolValue.\n  /// FIXME: For now, identical-address AtomicBoolValue <=> identical atom.\n  ///        Stop relying on pointer identity and remove this guarantee.\n  AtomicBoolValue &makeAtomValue() {\n    return cast<AtomicBoolValue>(makeBoolValue(makeAtomRef(makeAtom())));\n  }\n\n  /// Creates a fresh Top boolean value.\n  TopBoolValue &makeTopValue() {\n    // No need for deduplicating: there's no way to create aliasing Tops.\n    return create<TopBoolValue>(makeAtomRef(makeAtom()));\n  }\n\n  /// Returns a symbolic integer value that models an integer literal equal to\n  /// `Value`. These literals are the same every time.\n  /// Integer literals are not typed; the type is determined by the `Expr` that\n  /// an integer literal is associated with.\n  IntegerValue &makeIntLiteral(llvm::APInt Value);\n\n  // Factories for boolean formulas.\n  // Formulas are interned: passing the same arguments return the same result.\n  // For commutative operations like And/Or, interning ignores order.\n  // Simplifications are applied: makeOr(X, X) => X, etc.\n\n  /// Returns a formula for the conjunction of `LHS` and `RHS`.\n  const Formula &makeAnd(const Formula &LHS, const Formula &RHS);\n\n  /// Returns a formula for the disjunction of `LHS` and `RHS`.\n  const Formula &makeOr(const Formula &LHS, const Formula &RHS);\n\n  /// Returns a formula for the negation of `Val`.\n  const Formula &makeNot(const Formula &Val);\n\n  /// Returns a formula for `LHS => RHS`.\n  const Formula &makeImplies(const Formula &LHS, const Formula &RHS);\n\n  /// Returns a formula for `LHS <=> RHS`.\n  const Formula &makeEquals(const Formula &LHS, const Formula &RHS);\n\n  /// Returns a formula for the variable A.\n  const Formula &makeAtomRef(Atom A);\n\n  /// Returns a formula for a literal true/false.\n  const Formula &makeLiteral(bool Value) {\n    return makeAtomRef(Value ? True : False);\n  }\n\n  /// Returns a new atomic boolean variable, distinct from any other.\n  Atom makeAtom() { return static_cast<Atom>(NextAtom++); };\n\n  /// Creates a fresh flow condition and returns a token that identifies it. The\n  /// token can be used to perform various operations on the flow condition such\n  /// as adding constraints to it, forking it, joining it with another flow\n  /// condition, or checking implications.\n  Atom makeFlowConditionToken() { return makeAtom(); }\n\nprivate:\n  llvm::BumpPtrAllocator Alloc;\n\n  // Storage for the state of a program.\n  std::vector<std::unique_ptr<StorageLocation>> Locs;\n  std::vector<std::unique_ptr<Value>> Vals;\n\n  // Indices that are used to avoid recreating the same integer literals and\n  // composite boolean values.\n  llvm::DenseMap<llvm::APInt, IntegerValue *> IntegerLiterals;\n  using FormulaPair = std::pair<const Formula *, const Formula *>;\n  llvm::DenseMap<FormulaPair, const Formula *> Ands;\n  llvm::DenseMap<FormulaPair, const Formula *> Ors;\n  llvm::DenseMap<const Formula *, const Formula *> Nots;\n  llvm::DenseMap<FormulaPair, const Formula *> Implies;\n  llvm::DenseMap<FormulaPair, const Formula *> Equals;\n  llvm::DenseMap<Atom, const Formula *> AtomRefs;\n\n  llvm::DenseMap<const Formula *, BoolValue *> FormulaValues;\n  unsigned NextAtom = 0;\n\n  Atom True, False;\n}",
  "id": "BLOCK-CPP-21877",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/Arena.h",
  "source_line": 20,
  "validation_status": "validated"
}