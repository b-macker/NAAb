{
  "code": "{\n  static constexpr size_t kWidth = 16;  // the number of slots per group\n\n  explicit GroupSse2Impl(const ctrl_t* pos) {\n    ctrl = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pos));\n  }\n\n  // Returns a bitmask representing the positions of slots that match hash.\n  BitMask<uint16_t, kWidth> Match(h2_t hash) const {\n    auto match = _mm_set1_epi8(static_cast<char>(hash));\n    BitMask<uint16_t, kWidth> result = BitMask<uint16_t, kWidth>(0);\n    result = BitMask<uint16_t, kWidth>(\n        static_cast<uint16_t>(_mm_movemask_epi8(_mm_cmpeq_epi8(match, ctrl))));\n    return result;\n  }\n\n  // Returns a bitmask representing the positions of empty slots.\n  NonIterableBitMask<uint16_t, kWidth> MaskEmpty() const {\n#ifdef ABSL_INTERNAL_HAVE_SSSE3\n    // This only works because ctrl_t::kEmpty is -128.\n    return NonIterableBitMask<uint16_t, kWidth>(\n        static_cast<uint16_t>(_mm_movemask_epi8(_mm_sign_epi8(ctrl, ctrl))));\n#else\n    auto match = _mm_set1_epi8(static_cast<char>(ctrl_t::kEmpty));\n    return NonIterableBitMask<uint16_t, kWidth>(\n        static_cast<uint16_t>(_mm_movemask_epi8(_mm_cmpeq_epi8(match, ctrl))));\n#endif\n  }\n\n  // Returns a bitmask representing the positions of full slots.\n  // Note: for `is_small()` tables group may contain the \"same\" slot twice:\n  // original and mirrored.\n  BitMask<uint16_t, kWidth> MaskFull() const {\n    return BitMask<uint16_t, kWidth>(\n        static_cast<uint16_t>(_mm_movemask_epi8(ctrl) ^ 0xffff));\n  }\n\n  // Returns a bitmask representing the positions of empty or deleted slots.\n  NonIterableBitMask<uint16_t, kWidth> MaskEmptyOrDeleted() const {\n    auto special = _mm_set1_epi8(static_cast<char>(ctrl_t::kSentinel));\n    return NonIterableBitMask<uint16_t, kWidth>(static_cast<uint16_t>(\n        _mm_movemask_epi8(_mm_cmpgt_epi8_fixed(special, ctrl))));\n  }\n\n  // Returns the number of trailing empty or deleted elements in the group.\n  uint32_t CountLeadingEmptyOrDeleted() const {\n    auto special = _mm_set1_epi8(static_cast<char>(ctrl_t::kSentinel));\n    return TrailingZeros(static_cast<uint32_t>(\n        _mm_movemask_epi8(_mm_cmpgt_epi8_fixed(special, ctrl)) + 1));\n  }\n\n  void ConvertSpecialToEmptyAndFullToDeleted(ctrl_t* dst) const {\n    auto msbs = _mm_set1_epi8(static_cast<char>(-128));\n    auto x126 = _mm_set1_epi8(126);\n#ifdef ABSL_INTERNAL_HAVE_SSSE3\n    auto res = _mm_or_si128(_mm_shuffle_epi8(x126, ctrl), msbs);\n#else\n    auto zero = _mm_setzero_si128();\n    auto special_mask = _mm_cmpgt_epi8_fixed(zero, ctrl);\n    auto res = _mm_or_si128(msbs, _mm_andnot_si128(special_mask, x126));\n#endif\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(dst), res);\n  }\n\n  __m128i ctrl;\n}",
  "id": "BLOCK-CPP-05347",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 612,
  "validation_status": "validated"
}