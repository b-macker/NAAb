{
  "code": "{\n   public:\n    using distribution_type = discrete_distribution;\n\n    param_type() { init(); }\n\n    template <typename InputIterator>\n    explicit param_type(InputIterator begin, InputIterator end)\n        : p_(begin, end) {\n      init();\n    }\n\n    explicit param_type(std::initializer_list<double> weights) : p_(weights) {\n      init();\n    }\n\n    template <class UnaryOperation>\n    explicit param_type(size_t nw, double xmin, double xmax,\n                        UnaryOperation fw) {\n      if (nw > 0) {\n        p_.reserve(nw);\n        double delta = (xmax - xmin) / static_cast<double>(nw);\n        assert(delta > 0);\n        double t = delta * 0.5;\n        for (size_t i = 0; i < nw; ++i) {\n          p_.push_back(fw(xmin + i * delta + t));\n        }\n      }\n      init();\n    }\n\n    const std::vector<double>& probabilities() const { return p_; }\n    size_t n() const { return p_.size() - 1; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.probabilities() == b.probabilities();\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class discrete_distribution;\n\n    void init();\n\n    std::vector<double> p_;                     // normalized probabilities\n    std::vector<std::pair<double, size_t>> q_;  // (acceptance, alternate) pairs\n\n    static_assert(std::is_integral<result_type>::value,\n                  \"Class-template absl::discrete_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  }",
  "id": "BLOCK-CPP-03831",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/discrete_distribution.h",
  "source_line": 56,
  "validation_status": "validated"
}