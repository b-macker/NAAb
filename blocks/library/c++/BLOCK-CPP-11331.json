{
  "code": "#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <utility>\n\nusing namespace clang;\nusing namespace alias;\nusing namespace alias;\nusing namespace stored;\nusing namespace alias;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-11331_execute() {\n    {\n  NestedNameSpecifier *Qualifier = nullptr;\n  void *Data = nullptr;\n\n  /// Determines the data length for the last component in the\n  /// given nested-name-specifier.\n  static unsigned getLocalDataLength(NestedNameSpecifier *Qualifier);\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  static unsigned getDataLength(NestedNameSpecifier *Qualifier);\n\npublic:\n  /// Construct an empty nested-name-specifier.\n  NestedNameSpecifierLoc() = default;\n\n  /// Construct a nested-name-specifier with source location information\n  /// from\n  NestedNameSpecifierLoc(NestedNameSpecifier *Qualifier, void *Data)\n      : Qualifier(Qualifier), Data(Data) {}\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// non-empty.\n  explicit operator bool() const { return Qualifier; }\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// empty.\n  bool hasQualifier() const { return Qualifier; }\n\n  /// Retrieve the nested-name-specifier to which this instance\n  /// refers.\n  NestedNameSpecifier *getNestedNameSpecifier() const {\n    return Qualifier;\n  }\n\n  /// Retrieve the opaque pointer that refers to source-location data.\n  void *getOpaqueData() const { return Data; }\n\n  /// Retrieve the source range covering the entirety of this\n  /// nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from the initial '::' to the last '::'.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Retrieve the source range covering just the last part of\n  /// this nested-name-specifier, not including the prefix.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from \"vector\" to the last '::'.\n  SourceRange getLocalSourceRange() const;\n\n  /// Retrieve the location of the beginning of this\n  /// nested-name-specifier.\n  SourceLocation getBeginLoc() const {\n    return getSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this\n  /// nested-name-specifier.\n  SourceLocation getEndLoc() const {\n    return getSourceRange().getEnd();\n  }\n\n  /// Retrieve the location of the beginning of this\n  /// component of the nested-name-specifier.\n  SourceLocation getLocalBeginLoc() const {\n    return getLocalSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this component of the\n  /// nested-name-specifier.\n  SourceLocation getLocalEndLoc() const {\n    return getLocalSourceRange().getEnd();\n  }\n\n  /// Return the prefix of this nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the prefix is \\c \\::std::. Note that the\n  /// returned prefix may be empty, if this is the first component of\n  /// the nested-name-specifier.\n  NestedNameSpecifierLoc getPrefix() const {\n    if (!Qualifier)\n      return *this;\n\n    return NestedNameSpecifierLoc(Qualifier->getPrefix(), Data);\n  }\n\n  /// For a nested-name-specifier that refers to a type,\n  /// retrieve the type with source-location information.\n  TypeLoc getTypeLoc() const;\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  unsigned getDataLength() const { return getDataLength(Qualifier); }\n\n  friend bool operator==(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return X.Qualifier == Y.Qualifier && X.Data == Y.Data;\n  }\n\n  friend bool operator!=(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return !(X == Y);\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-11331",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/NestedNameSpecifier.h",
  "source_line": 243,
  "validation_status": "validated"
}