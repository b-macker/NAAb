{
  "code": "{\n  SourceLocation CoreturnLoc;\n\n  enum SubStmt { Operand, PromiseCall, Count };\n  Stmt *SubStmts[SubStmt::Count];\n\n  bool IsImplicit : 1;\n\n  friend class ASTStmtReader;\npublic:\n  CoreturnStmt(SourceLocation CoreturnLoc, Stmt *Operand, Stmt *PromiseCall,\n               bool IsImplicit = false)\n      : Stmt(CoreturnStmtClass), CoreturnLoc(CoreturnLoc),\n        IsImplicit(IsImplicit) {\n    SubStmts[SubStmt::Operand] = Operand;\n    SubStmts[SubStmt::PromiseCall] = PromiseCall;\n  }\n\n  CoreturnStmt(EmptyShell) : CoreturnStmt({}, {}, {}) {}\n\n  SourceLocation getKeywordLoc() const { return CoreturnLoc; }\n\n  /// Retrieve the operand of the 'co_return' statement. Will be nullptr\n  /// if none was specified.\n  Expr *getOperand() const { return static_cast<Expr*>(SubStmts[Operand]); }\n\n  /// Retrieve the promise call that results from this 'co_return'\n  /// statement. Will be nullptr if either the coroutine has not yet been\n  /// finalized or the coroutine has no eventual return type.\n  Expr *getPromiseCall() const {\n    return static_cast<Expr*>(SubStmts[PromiseCall]);\n  }\n\n  bool isImplicit() const { return IsImplicit; }\n  void setIsImplicit(bool value = true) { IsImplicit = value; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return CoreturnLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand() ? getOperand()->getEndLoc() : getBeginLoc();\n  }\n\n  child_range children() {\n    return child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoreturnStmtClass;\n  }\n}",
  "id": "BLOCK-CPP-12954",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtCXX.h",
  "source_line": 473,
  "validation_status": "validated"
}