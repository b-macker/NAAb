{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\ntemplate <typename T>\nclass Span;\n\nnamespace span_internal {\n// Wrappers for access to container data pointers.\ntemplate <typename C>\nconstexpr auto GetDataImpl(C& c, char) noexcept  // NOLINT(runtime/references)\n    -> decltype(c.data()) {\n  return c.data();\n}\n\n// Before C++17, std::string::data returns a const char* in all cases.\ninline char* GetDataImpl(std::string& s,  // NOLINT(runtime/references)\n                         int) noexcept {\n  return &s[0];\n}\n\ntemplate <typename C>\nconstexpr auto GetData(C& c) noexcept  // NOLINT(runtime/references)\n    -> decltype(GetDataImpl(c, 0)) {\n  return GetDataImpl(c, 0);\n}\n\n// Detection idioms for size() and data().\ntemplate <typename C>\nusing HasSize =\n    std::is_integral<absl::decay_t<decltype(std::declval<C&>().size())>>;\n\n// We want to enable conversion from vector<T*> to Span<const T* const> but\n// disable conversion from vector<Derived> to Span<Base>. Here we use\n// the fact that U** is convertible to Q* const* if and only if Q is the same\n// type or a more cv-qualified version of U.  We also decay the result type of\n// data() to avoid problems with classes which have a member function data()\n// which returns a reference.\ntemplate <typename T, typename C>\nusing HasData =\n    std::is_convertible<absl::decay_t<decltype(GetData(std::declval<C&>()))>*,\n                        T* const*>;\n\n// Extracts value type from a Container\ntemplate <typename C>\nstruct ElementType {\n  using type = typename absl::remove_reference_t<C>::value_type;\n};\n\ntemplate <typename T, size_t N>\nstruct ElementType<T (&)[N]> {\n  using type = T;\n};\n\ntemplate <typename C>\nusing ElementT = typename ElementType<C>::type;\n\ntemplate <typename T>\nusing EnableIfMutable =\n    typename std::enable_if<!std::is_const<T>::value, int>::type;\n\ntemplate <template <typename> class SpanT, typename T>\nbool EqualImpl(SpanT<T> a, SpanT<T> b) {\n  static_assert(std::is_const<T>::value, \"\");\n  return std::equal(a.begin(), a.end(), b.begin(), b.end());\n}\n\ntemplate <template <typename> class SpanT, typename T>\nbool LessThanImpl(SpanT<T> a, SpanT<T> b) {\n  // We can't use value_type since that is remove_cv_t<T>, so we go the long way\n  // around.\n  static_assert(std::is_const<T>::value, \"\");\n  return std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());\n}\n\ntemplate <typename From, typename To>\nusing EnableIfConvertibleTo =\n    typename std::enable_if<std::is_convertible<From, To>::value>::type;\n\n// IsView is true for types where the return type of .data() is the same for\n// mutable and const instances. This isn't foolproof, but it's only used to\n// enable a compiler warning.\ntemplate <typename T, typename = void, typename = void>\nstruct IsView {\n  static constexpr bool value = false;\n};\n\ntemplate <typename T>\nstruct IsView<\n    T, absl::void_t<decltype(span_internal::GetData(std::declval<const T&>()))>,\n    absl::void_t<decltype(span_internal::GetData(std::declval<T&>()))>> {\n private:\n  using Container = std::remove_const_t<T>;\n  using ConstData =\n      decltype(span_internal::GetData(std::declval<const Container&>()));\n  using MutData = decltype(span_internal::GetData(std::declval<Container&>()));\n public:\n  static constexpr bool value = std::is_same<ConstData, MutData>::value;\n};\n\n// These enablers result in 'int' so they can be used as typenames or defaults\n// in template parameters lists.\ntemplate <typename T>\nusing EnableIfIsView = std::enable_if_t<IsView<T>::value, int>;\n\ntemplate <typename T>\nusing EnableIfNotIsView = std::enable_if_t<!IsView<T>::value, int>;\n\n}  // namespace span_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06646",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/internal/span.h",
  "source_line": 28,
  "validation_status": "validated"
}