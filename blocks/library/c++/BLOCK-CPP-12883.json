{
  "code": "{\n  friend class ASTStmtReader;\n\n  enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.\n  SourceLocation LParenLoc, RParenLoc;\n\npublic:\n  ForStmt(const ASTContext &C, Stmt *Init, Expr *Cond, VarDecl *condVar,\n          Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,\n          SourceLocation RP);\n\n  /// Build an empty for statement.\n  explicit ForStmt(EmptyShell Empty) : Stmt(ForStmtClass, Empty) {}\n\n  Stmt *getInit() { return SubExprs[INIT]; }\n\n  /// Retrieve the variable declared in this \"for\" statement, if any.\n  ///\n  /// In the following example, \"y\" is the condition variable.\n  /// \\code\n  /// for (int x = random(); int y = mangle(x); ++x) {\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable() const;\n  void setConditionVariable(const ASTContext &C, VarDecl *V);\n\n  /// If this ForStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return reinterpret_cast<DeclStmt*>(SubExprs[CONDVAR]);\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return reinterpret_cast<DeclStmt*>(SubExprs[CONDVAR]);\n  }\n\n  void setConditionVariableDeclStmt(DeclStmt *CondVar) {\n    SubExprs[CONDVAR] = CondVar;\n  }\n\n  Expr *getCond() { return reinterpret_cast<Expr*>(SubExprs[COND]); }\n  Expr *getInc()  { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const Stmt *getInit() const { return SubExprs[INIT]; }\n  const Expr *getCond() const { return reinterpret_cast<Expr*>(SubExprs[COND]);}\n  const Expr *getInc()  const { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setInit(Stmt *S) { SubExprs[INIT] = S; }\n  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt*>(E); }\n  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt*>(E); }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForStmtBits.ForLoc; }\n  void setForLoc(SourceLocation L) { ForStmtBits.ForLoc = L; }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getForLoc(); }\n  SourceLocation getEndLoc() const { return getBody()->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ForStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n}",
  "id": "BLOCK-CPP-12883",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Stmt.h",
  "source_line": 2602,
  "validation_status": "validated"
}