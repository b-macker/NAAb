{
  "code": "{\n private:\n  static constexpr int days_per_week = 7;\n\n  const std::locale& loc_;\n  const bool is_classic_;\n  OutputIt out_;\n  const std::tm& tm_;\n\n  auto tm_sec() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_sec >= 0 && tm_.tm_sec <= 61, \"\");\n    return tm_.tm_sec;\n  }\n  auto tm_min() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_min >= 0 && tm_.tm_min <= 59, \"\");\n    return tm_.tm_min;\n  }\n  auto tm_hour() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_hour >= 0 && tm_.tm_hour <= 23, \"\");\n    return tm_.tm_hour;\n  }\n  auto tm_mday() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_mday >= 1 && tm_.tm_mday <= 31, \"\");\n    return tm_.tm_mday;\n  }\n  auto tm_mon() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_mon >= 0 && tm_.tm_mon <= 11, \"\");\n    return tm_.tm_mon;\n  }\n  auto tm_year() const noexcept -> long long { return 1900ll + tm_.tm_year; }\n  auto tm_wday() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_wday >= 0 && tm_.tm_wday <= 6, \"\");\n    return tm_.tm_wday;\n  }\n  auto tm_yday() const noexcept -> int {\n    FMT_ASSERT(tm_.tm_yday >= 0 && tm_.tm_yday <= 365, \"\");\n    return tm_.tm_yday;\n  }\n\n  auto tm_hour12() const noexcept -> int {\n    const auto h = tm_hour();\n    const auto z = h < 12 ? h : h - 12;\n    return z == 0 ? 12 : z;\n  }\n\n  // POSIX and the C Standard are unclear or inconsistent about what %C and %y\n  // do if the year is negative or exceeds 9999. Use the convention that %C\n  // concatenated with %y yields the same output as %Y, and that %Y contains at\n  // least 4 characters, with more only if necessary.\n  auto split_year_lower(long long year) const noexcept -> int {\n    auto l = year % 100;\n    if (l < 0) l = -l;  // l in [0, 99]\n    return static_cast<int>(l);\n  }\n\n  // Algorithm:\n  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_from_a_month_and_day_of_the_month_or_ordinal_date\n  auto iso_year_weeks(long long curr_year) const noexcept -> int {\n    const auto prev_year = curr_year - 1;\n    const auto curr_p =\n        (curr_year + curr_year / 4 - curr_year / 100 + curr_year / 400) %\n        days_per_week;\n    const auto prev_p =\n        (prev_year + prev_year / 4 - prev_year / 100 + prev_year / 400) %\n        days_per_week;\n    return 52 + ((curr_p == 4 || prev_p == 3) ? 1 : 0);\n  }\n  auto iso_week_num(int tm_yday, int tm_wday) const noexcept -> int {\n    return (tm_yday + 11 - (tm_wday == 0 ? days_per_week : tm_wday)) /\n           days_per_week;\n  }\n  auto tm_iso_week_year() const noexcept -> long long {\n    const auto year = tm_year();\n    const auto w = iso_week_num(tm_yday(), tm_wday());\n    if (w < 1) return year - 1;\n    if (w > iso_year_weeks(year)) return year + 1;\n    return year;\n  }\n  auto tm_iso_week_of_year() const noexcept -> int {\n    const auto year = tm_year();\n    const auto w = iso_week_num(tm_yday(), tm_wday());\n    if (w < 1) return iso_year_weeks(year - 1);\n    if (w > iso_year_weeks(year)) return 1;\n    return w;\n  }\n\n  void write1(int value) {\n    *out_++ = static_cast<char>('0' + to_unsigned(value) % 10);\n  }\n  void write2(int value) {\n    const char* d = digits2(to_unsigned(value) % 100);\n    *out_++ = *d++;\n    *out_++ = *d;\n  }\n\n  void write_year_extended(long long year) {\n    // At least 4 characters.\n    int width = 4;\n    if (year < 0) {\n      *out_++ = '-';\n      year = 0 - year;\n      --width;\n    }\n    uint32_or_64_or_128_t<long long> n = to_unsigned(year);\n    const int num_digits = count_digits(n);\n    if (width > num_digits) out_ = std::fill_n(out_, width - num_digits, '0');\n    out_ = format_decimal<Char>(out_, n, num_digits).end;\n  }\n  void write_year(long long year) {\n    if (year >= 0 && year < 10000) {\n      write2(static_cast<int>(year / 100));\n      write2(static_cast<int>(year % 100));\n    } else {\n      write_year_extended(year);\n    }\n  }\n\n  void write_utc_offset(long offset) {\n    if (offset < 0) {\n      *out_++ = '-';\n      offset = -offset;\n    } else {\n      *out_++ = '+';\n    }\n    offset /= 60;\n    write2(static_cast<int>(offset / 60));\n    write2(static_cast<int>(offset % 60));\n  }\n  template <typename T, FMT_ENABLE_IF(has_member_data_tm_gmtoff<T>::value)>\n  void format_utc_offset_impl(const T& tm) {\n    write_utc_offset(tm.tm_gmtoff);\n  }\n  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_gmtoff<T>::value)>\n  void format_utc_offset_impl(const T& tm) {\n#if defined(_WIN32) && defined(_UCRT)\n#  if FMT_USE_TZSET\n    tzset_once();\n#  endif\n    long offset = 0;\n    _get_timezone(&offset);\n    if (tm.tm_isdst) {\n      long dstbias = 0;\n      _get_dstbias(&dstbias);\n      offset += dstbias;\n    }\n    write_utc_offset(-offset);\n#else\n    ignore_unused(tm);\n    format_localized('z');\n#endif\n  }\n\n  template <typename T, FMT_ENABLE_IF(has_member_data_tm_zone<T>::value)>\n  void format_tz_name_impl(const T& tm) {\n    if (is_classic_)\n      out_ = write_tm_str<Char>(out_, tm.tm_zone, loc_);\n    else\n      format_localized('Z');\n  }\n  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_zone<T>::value)>\n  void format_tz_name_impl(const T&) {\n    format_localized('Z');\n  }\n\n  void format_localized(char format, char modifier = 0) {\n    out_ = write<Char>(out_, tm_, loc_, format, modifier);\n  }\n\n public:\n  tm_writer(const std::locale& loc, OutputIt out, const std::tm& tm)\n      : loc_(loc),\n        is_classic_(loc_ == get_classic_locale()),\n        out_(out),\n        tm_(tm) {}\n\n  OutputIt out() const { return out_; }\n\n  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {\n    out_ = copy_str<Char>(begin, end, out_);\n  }\n\n  void on_abbr_weekday() {\n    if (is_classic_)\n      out_ = write(out_, tm_wday_short_name(tm_wday()));\n    else\n      format_localized('a');\n  }\n  void on_full_weekday() {\n    if (is_classic_)\n      out_ = write(out_, tm_wday_full_name(tm_wday()));\n    else\n      format_localized('A');\n  }\n  void on_dec0_weekday(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) return write1(tm_wday());\n    format_localized('w', 'O');\n  }\n  void on_dec1_weekday(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) {\n      auto wday = tm_wday();\n      write1(wday == 0 ? days_per_week : wday);\n    } else {\n      format_localized('u', 'O');\n    }\n  }\n\n  void on_abbr_month() {\n    if (is_classic_)\n      out_ = write(out_, tm_mon_short_name(tm_mon()));\n    else\n      format_localized('b');\n  }\n  void on_full_month() {\n    if (is_classic_)\n      out_ = write(out_, tm_mon_full_name(tm_mon()));\n    else\n      format_localized('B');\n  }\n\n  void on_datetime(numeric_system ns) {\n    if (is_classic_) {\n      on_abbr_weekday();\n      *out_++ = ' ';\n      on_abbr_month();\n      *out_++ = ' ';\n      on_day_of_month_space(numeric_system::standard);\n      *out_++ = ' ';\n      on_iso_time();\n      *out_++ = ' ';\n      on_year(numeric_system::standard);\n    } else {\n      format_localized('c', ns == numeric_system::standard ? '\\0' : 'E');\n    }\n  }\n  void on_loc_date(numeric_system ns) {\n    if (is_classic_)\n      on_us_date();\n    else\n      format_localized('x', ns == numeric_system::standard ? '\\0' : 'E');\n  }\n  void on_loc_time(numeric_system ns) {\n    if (is_classic_)\n      on_iso_time();\n    else\n      format_localized('X', ns == numeric_system::standard ? '\\0' : 'E');\n  }\n  void on_us_date() {\n    char buf[8];\n    write_digit2_separated(buf, to_unsigned(tm_mon() + 1),\n                           to_unsigned(tm_mday()),\n                           to_unsigned(split_year_lower(tm_year())), '/');\n    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);\n  }\n  void on_iso_date() {\n    auto year = tm_year();\n    char buf[10];\n    size_t offset = 0;\n    if (year >= 0 && year < 10000) {\n      copy2(buf, digits2(static_cast<size_t>(year / 100)));\n    } else {\n      offset = 4;\n      write_year_extended(year);\n      year = 0;\n    }\n    write_digit2_separated(buf + 2, static_cast<unsigned>(year % 100),\n                           to_unsigned(tm_mon() + 1), to_unsigned(tm_mday()),\n                           '-');\n    out_ = copy_str<Char>(std::begin(buf) + offset, std::end(buf), out_);\n  }\n\n  void on_utc_offset() { format_utc_offset_impl(tm_); }\n  void on_tz_name() { format_tz_name_impl(tm_); }\n\n  void on_year(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write_year(tm_year());\n    format_localized('Y', 'E');\n  }\n  void on_short_year(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write2(split_year_lower(tm_year()));\n    format_localized('y', 'O');\n  }\n  void on_offset_year() {\n    if (is_classic_) return write2(split_year_lower(tm_year()));\n    format_localized('y', 'E');\n  }\n\n  void on_century(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) {\n      auto year = tm_year();\n      auto upper = year / 100;\n      if (year >= -99 && year < 0) {\n        // Zero upper on negative year.\n        *out_++ = '-';\n        *out_++ = '0';\n      } else if (upper >= 0 && upper < 100) {\n        write2(static_cast<int>(upper));\n      } else {\n        out_ = write<Char>(out_, upper);\n      }\n    } else {\n      format_localized('C', 'E');\n    }\n  }\n\n  void on_dec_month(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write2(tm_mon() + 1);\n    format_localized('m', 'O');\n  }\n\n  void on_dec0_week_of_year(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week);\n    format_localized('U', 'O');\n  }\n  void on_dec1_week_of_year(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) {\n      auto wday = tm_wday();\n      write2((tm_yday() + days_per_week -\n              (wday == 0 ? (days_per_week - 1) : (wday - 1))) /\n             days_per_week);\n    } else {\n      format_localized('W', 'O');\n    }\n  }\n  void on_iso_week_of_year(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write2(tm_iso_week_of_year());\n    format_localized('V', 'O');\n  }\n\n  void on_iso_week_based_year() { write_year(tm_iso_week_year()); }\n  void on_iso_week_based_short_year() {\n    write2(split_year_lower(tm_iso_week_year()));\n  }\n\n  void on_day_of_year() {\n    auto yday = tm_yday() + 1;\n    write1(yday / 100);\n    write2(yday % 100);\n  }\n  void on_day_of_month(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) return write2(tm_mday());\n    format_localized('d', 'O');\n  }\n  void on_day_of_month_space(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) {\n      auto mday = to_unsigned(tm_mday()) % 100;\n      const char* d2 = digits2(mday);\n      *out_++ = mday < 10 ? ' ' : d2[0];\n      *out_++ = d2[1];\n    } else {\n      format_localized('e', 'O');\n    }\n  }\n\n  void on_24_hour(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) return write2(tm_hour());\n    format_localized('H', 'O');\n  }\n  void on_12_hour(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard)\n      return write2(tm_hour12());\n    format_localized('I', 'O');\n  }\n  void on_minute(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) return write2(tm_min());\n    format_localized('M', 'O');\n  }\n  void on_second(numeric_system ns) {\n    if (is_classic_ || ns == numeric_system::standard) return write2(tm_sec());\n    format_localized('S', 'O');\n  }\n\n  void on_12_hour_time() {\n    if (is_classic_) {\n      char buf[8];\n      write_digit2_separated(buf, to_unsigned(tm_hour12()),\n                             to_unsigned(tm_min()), to_unsigned(tm_sec()), ':');\n      out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);\n      *out_++ = ' ';\n      on_am_pm();\n    } else {\n      format_localized('r');\n    }\n  }\n  void on_24_hour_time() {\n    write2(tm_hour());\n    *out_++ = ':';\n    write2(tm_min());\n  }\n  void on_iso_time() {\n    char buf[8];\n    write_digit2_separated(buf, to_unsigned(tm_hour()), to_unsigned(tm_min()),\n                           to_unsigned(tm_sec()), ':');\n    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);\n  }\n\n  void on_am_pm() {\n    if (is_classic_) {\n      *out_++ = tm_hour() < 12 ? 'A' : 'P';\n      *out_++ = 'M';\n    } else {\n      format_localized('p');\n    }\n  }\n\n  // These apply to chrono durations but not tm.\n  void on_duration_value() {}\n  void on_duration_unit() {}\n}",
  "id": "BLOCK-CPP-00800",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/chrono.h",
  "source_line": 960,
  "validation_status": "validated"
}