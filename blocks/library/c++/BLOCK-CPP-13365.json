{
  "code": "{\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                  unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPForDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc, unsigned CollapsedNum,\n                                 ArrayRef<OMPClause *> Clauses,\n                                 Stmt *AssociatedStmt, const HelperExprs &Exprs,\n                                 Expr *TaskRedRef, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                      unsigned CollapsedNum, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPForDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForDirectiveClass;\n  }\n}",
  "id": "BLOCK-CPP-13365",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 1633,
  "validation_status": "validated"
}