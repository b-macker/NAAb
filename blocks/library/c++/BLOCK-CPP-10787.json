{
  "code": "{\n  friend class ASTStmtReader;\n\npublic:\n  enum ConstructionKind {\n    CK_Complete,\n    CK_NonVirtualBase,\n    CK_VirtualBase,\n    CK_Delegating\n  };\n\nprivate:\n  /// A pointer to the constructor which will be ultimately called.\n  CXXConstructorDecl *Constructor;\n\n  SourceRange ParenOrBraceRange;\n\n  /// The number of arguments.\n  unsigned NumArgs;\n\n  // We would like to stash the arguments of the constructor call after\n  // CXXConstructExpr. However CXXConstructExpr is used as a base class of\n  // CXXTemporaryObjectExpr which makes the use of llvm::TrailingObjects\n  // impossible.\n  //\n  // Instead we manually stash the trailing object after the full object\n  // containing CXXConstructExpr (that is either CXXConstructExpr or\n  // CXXTemporaryObjectExpr).\n  //\n  // The trailing objects are:\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the arguments of the\n  //   constructor call.\n\n  /// Return a pointer to the start of the trailing arguments.\n  /// Defined just after CXXTemporaryObjectExpr.\n  inline Stmt **getTrailingArgs();\n  const Stmt *const *getTrailingArgs() const {\n    return const_cast<CXXConstructExpr *>(this)->getTrailingArgs();\n  }\n\nprotected:\n  /// Build a C++ construction expression.\n  CXXConstructExpr(StmtClass SC, QualType Ty, SourceLocation Loc,\n                   CXXConstructorDecl *Ctor, bool Elidable,\n                   ArrayRef<Expr *> Args, bool HadMultipleCandidates,\n                   bool ListInitialization, bool StdInitListInitialization,\n                   bool ZeroInitialization, ConstructionKind ConstructKind,\n                   SourceRange ParenOrBraceRange);\n\n  /// Build an empty C++ construction expression.\n  CXXConstructExpr(StmtClass SC, EmptyShell Empty, unsigned NumArgs);\n\n  /// Return the size in bytes of the trailing objects. Used by\n  /// CXXTemporaryObjectExpr to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumArgs) {\n    return NumArgs * sizeof(Stmt *);\n  }\n\npublic:\n  /// Create a C++ construction expression.\n  static CXXConstructExpr *\n  Create(const ASTContext &Ctx, QualType Ty, SourceLocation Loc,\n         CXXConstructorDecl *Ctor, bool Elidable, ArrayRef<Expr *> Args,\n         bool HadMultipleCandidates, bool ListInitialization,\n         bool StdInitListInitialization, bool ZeroInitialization,\n         ConstructionKind ConstructKind, SourceRange ParenOrBraceRange);\n\n  /// Create an empty C++ construction expression.\n  static CXXConstructExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs);\n\n  /// Get the constructor that this expression will (ultimately) call.\n  CXXConstructorDecl *getConstructor() const { return Constructor; }\n\n  SourceLocation getLocation() const { return CXXConstructExprBits.Loc; }\n  void setLocation(SourceLocation Loc) { CXXConstructExprBits.Loc = Loc; }\n\n  /// Whether this construction is elidable.\n  bool isElidable() const { return CXXConstructExprBits.Elidable; }\n  void setElidable(bool E) { CXXConstructExprBits.Elidable = E; }\n\n  /// Whether the referred constructor was resolved from\n  /// an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return CXXConstructExprBits.HadMultipleCandidates;\n  }\n  void setHadMultipleCandidates(bool V) {\n    CXXConstructExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization.\n  bool isListInitialization() const {\n    return CXXConstructExprBits.ListInitialization;\n  }\n  void setListInitialization(bool V) {\n    CXXConstructExprBits.ListInitialization = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization,\n  /// but was interpreted as forming a std::initializer_list<T> from the list\n  /// and passing that as a single constructor argument.\n  /// See C++11 [over.match.list]p1 bullet 1.\n  bool isStdInitListInitialization() const {\n    return CXXConstructExprBits.StdInitListInitialization;\n  }\n  void setStdInitListInitialization(bool V) {\n    CXXConstructExprBits.StdInitListInitialization = V;\n  }\n\n  /// Whether this construction first requires\n  /// zero-initialization before the initializer is called.\n  bool requiresZeroInitialization() const {\n    return CXXConstructExprBits.ZeroInitialization;\n  }\n  void setRequiresZeroInitialization(bool ZeroInit) {\n    CXXConstructExprBits.ZeroInitialization = ZeroInit;\n  }\n\n  /// Determine whether this constructor is actually constructing\n  /// a base class (rather than a complete object).\n  ConstructionKind getConstructionKind() const {\n    return static_cast<ConstructionKind>(CXXConstructExprBits.ConstructionKind);\n  }\n  void setConstructionKind(ConstructionKind CK) {\n    CXXConstructExprBits.ConstructionKind = CK;\n  }\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() { return getTrailingArgs(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  const_arg_iterator arg_begin() const { return getTrailingArgs(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  Expr **getArgs() { return reinterpret_cast<Expr **>(getTrailingArgs()); }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(getTrailingArgs());\n  }\n\n  /// Return the number of arguments to the constructor call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  bool isImmediateEscalating() const {\n    return CXXConstructExprBits.IsImmediateEscalating;\n  }\n\n  void setIsImmediateEscalating(bool Set) {\n    CXXConstructExprBits.IsImmediateEscalating = Set;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getParenOrBraceRange() const { return ParenOrBraceRange; }\n  void setParenOrBraceRange(SourceRange Range) { ParenOrBraceRange = Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXConstructExprClass ||\n           T->getStmtClass() == CXXTemporaryObjectExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingArgs(), getTrailingArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<CXXConstructExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n}",
  "id": "BLOCK-CPP-10787",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprCXX.h",
  "source_line": 1518,
  "validation_status": "validated"
}