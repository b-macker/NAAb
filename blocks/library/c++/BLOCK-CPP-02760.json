{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\n\nnamespace {\nbool ModuleIsPath(absl::string_view module_pattern) {\n#ifdef _WIN32\n  return module_pattern.find_first_of(\"/\\\\\") != module_pattern.npos;\n#else\n  return module_pattern.find('/') != module_pattern.npos;\n#endif\n}\n}  // namespace\n\nbool VLogSite::SlowIsEnabled(int stale_v, int level) {\n  if (ABSL_PREDICT_TRUE(stale_v != kUninitialized)) {\n    // Because of the prerequisites to this function, we know that stale_v is\n    // either uninitialized or >= level. If it's not uninitialized, that means\n    // it must be >= level, thus we should log.\n    return true;\n  }\n  stale_v = log_internal::RegisterAndInitialize(this);\n  return ABSL_PREDICT_FALSE(stale_v >= level);\n}\n\nbool VLogSite::SlowIsEnabled0(int stale_v) { return SlowIsEnabled(stale_v, 0); }\nbool VLogSite::SlowIsEnabled1(int stale_v) { return SlowIsEnabled(stale_v, 1); }\nbool VLogSite::SlowIsEnabled2(int stale_v) { return SlowIsEnabled(stale_v, 2); }\nbool VLogSite::SlowIsEnabled3(int stale_v) { return SlowIsEnabled(stale_v, 3); }\nbool VLogSite::SlowIsEnabled4(int stale_v) { return SlowIsEnabled(stale_v, 4); }\nbool VLogSite::SlowIsEnabled5(int stale_v) { return SlowIsEnabled(stale_v, 5); }\n\nnamespace {\nstruct VModuleInfo final {\n  std::string module_pattern;\n  bool module_is_path;  // i.e. it contains a path separator.\n  int vlog_level;\n\n  // Allocates memory.\n  VModuleInfo(absl::string_view module_pattern_arg, bool module_is_path_arg,\n              int vlog_level_arg)\n      : module_pattern(std::string(module_pattern_arg)),\n        module_is_path(module_is_path_arg),\n        vlog_level(vlog_level_arg) {}\n};\n\n// `mutex` guards all of the data structures that aren't lock-free.\n// To avoid problems with the heap checker which calls into `VLOG`, `mutex` must\n// be a `SpinLock` that prevents fiber scheduling instead of a `Mutex`.\nABSL_CONST_INIT absl::base_internal::SpinLock mutex(\n    absl::kConstInit, absl::base_internal::SCHEDULE_KERNEL_ONLY);\n\n// `GetUpdateSitesMutex()` serializes updates to all of the sites (i.e. those in\n// `site_list_head`) themselves.\nabsl::Mutex* GetUpdateSitesMutex() {\n  // Chromium requires no global destructors, so we can't use the\n  // absl::kConstInit idiom since absl::Mutex as a non-trivial destructor.\n  static absl::NoDestructor<absl::Mutex> update_sites_mutex ABSL_ACQUIRED_AFTER(\n      mutex);\n  return update_sites_mutex.get();\n}\n\nABSL_CONST_INIT int global_v ABSL_GUARDED_BY(mutex) = 0;\n// `site_list_head` is the head of a singly-linked list.  Traversal, insertion,\n// and reads are atomic, so no locks are required, but updates to existing\n// elements are guarded by `GetUpdateSitesMutex()`.\nABSL_CONST_INIT std::atomic<VLogSite*> site_list_head{nullptr};\nABSL_CONST_INIT std::vector<VModuleInfo>* vmodule_info ABSL_GUARDED_BY(mutex)\n    ABSL_PT_GUARDED_BY(mutex){nullptr};\n\n// Only used for lisp.\nABSL_CONST_INIT std::vector<std::function<void()>>* update_callbacks\n    ABSL_GUARDED_BY(GetUpdateSitesMutex())\n        ABSL_PT_GUARDED_BY(GetUpdateSitesMutex()){nullptr};\n\n// Allocates memory.\nstd::vector<VModuleInfo>& get_vmodule_info()\n    ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex) {\n  if (!vmodule_info) vmodule_info = new std::vector<VModuleInfo>;\n  return *vmodule_info;\n}\n\n// Does not allocate or take locks.\nint VLogLevel(absl::string_view file, const std::vector<VModuleInfo>* infos,\n              int current_global_v) {\n  // `infos` is null during a call to `VLOG` prior to setting `vmodule` (e.g. by\n  // parsing flags).  We can't allocate in `VLOG`, so we treat null as empty\n  // here and press on.\n  if (!infos || infos->empty()) return current_global_v;\n  // Get basename for file\n  absl::string_view basename = file;\n  {\n    const size_t sep = basename.rfind('/');\n    if (sep != basename.npos) {\n      basename.remove_prefix(sep + 1);\n#ifdef _WIN32\n    } else {\n      const size_t sep = basename.rfind('\\\\');\n      if (sep != basename.npos) basename.remove_prefix(sep + 1);\n#endif\n    }\n  }\n\n  absl::string_view stem = file, stem_basename = basename;\n  {\n    const size_t sep = stem_basename.find('.');\n    if (sep != stem_basename.npos) {\n      stem.remove_suffix(stem_basename.size() - sep);\n      stem_basename.remove_suffix(stem_basename.size() - sep);\n    }\n    if (absl::ConsumeSuffix(&stem_basename, \"-inl\")) {\n      stem.remove_suffix(absl::string_view(\"-inl\").size());\n    }\n  }\n  for (const auto& info : *infos) {\n    if (info.module_is_path) {\n      // If there are any slashes in the pattern, try to match the full\n      // name.\n      if (FNMatch(info.module_pattern, stem)) {\n        return info.vlog_level == kUseFlag ? current_global_v : info.vlog_level;\n      }\n    } else if (FNMatch(info.module_pattern, stem_basename)) {\n      return info.vlog_level == kUseFlag ? current_global_v : info.vlog_level;\n    }\n  }\n\n  return current_global_v;\n}\n\n// Allocates memory.\nint AppendVModuleLocked(absl::string_view module_pattern, int log_level)\n    ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex) {\n  for (const auto& info : get_vmodule_info()) {\n    if (FNMatch(info.module_pattern, module_pattern)) {\n      // This is a memory optimization to avoid storing patterns that will never\n      // match due to exit early semantics. Primarily optimized for our own unit\n      // tests.\n      return info.vlog_level;\n    }\n  }\n  bool module_is_path = ModuleIsPath(module_pattern);\n  get_vmodule_info().emplace_back(std::string(module_pattern), module_is_path,\n                                  log_level);\n  return global_v;\n}\n\n// Allocates memory.\nint PrependVModuleLocked(absl::string_view module_pattern, int log_level)\n    ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex) {\n  absl::optional<int> old_log_level;\n  for (const auto& info : get_vmodule_info()) {\n    if (FNMatch(info.module_pattern, module_pattern)) {\n      old_log_level = info.vlog_level;\n      break;\n    }\n  }\n  bool module_is_path = ModuleIsPath(module_pattern);\n  auto iter = get_vmodule_info().emplace(get_vmodule_info().cbegin(),\n                                         std::string(module_pattern),\n                                         module_is_path, log_level);\n\n  // This is a memory optimization to avoid storing patterns that will never\n  // match due to exit early semantics. Primarily optimized for our own unit\n  // tests.\n  get_vmodule_info().erase(\n      std::remove_if(++iter, get_vmodule_info().end(),\n                     [module_pattern](const VModuleInfo& info) {\n                       return FNMatch(info.module_pattern, module_pattern);\n                     }),\n      get_vmodule_info().cend());\n  return old_log_level.value_or(global_v);\n}\n}  // namespace\n\nint VLogLevel(absl::string_view file) ABSL_LOCKS_EXCLUDED(mutex) {\n  absl::base_internal::SpinLockHolder l(&mutex);\n  return VLogLevel(file, vmodule_info, global_v);\n}\n\nint RegisterAndInitialize(VLogSite* v) ABSL_LOCKS_EXCLUDED(mutex) {\n  // std::memory_order_seq_cst is overkill in this function, but given that this\n  // path is intended to be slow, it's not worth the brain power to relax that.\n  VLogSite* h = site_list_head.load(std::memory_order_seq_cst);\n\n  VLogSite* old = nullptr;\n  if (v->next_.compare_exchange_strong(old, h, std::memory_order_seq_cst,\n                                       std::memory_order_seq_cst)) {\n    // Multiple threads may attempt to register this site concurrently.\n    // By successfully setting `v->next` this thread commits to being *the*\n    // thread that installs `v` in the list.\n    while (!site_list_head.compare_exchange_weak(\n        h, v, std::memory_order_seq_cst, std::memory_order_seq_cst)) {\n      v->next_.store(h, std::memory_order_seq_cst);\n    }\n  }\n\n  int old_v = VLogSite::kUninitialized;\n  int new_v = VLogLevel(v->file_);\n  // No loop, if someone else set this, we should respect their evaluation of\n  // `VLogLevel`. This may mean we return a stale `v`, but `v` itself will\n  // always arrive at the freshest value.  Otherwise, we could be writing a\n  // stale value and clobbering the fresher one.\n  if (v->v_.compare_exchange_strong(old_v, new_v, std::memory_order_seq_cst,\n                                    std::memory_order_seq_cst)) {\n    return new_v;\n  }\n  return old_v;\n}\n\nvoid UpdateVLogSites() ABSL_UNLOCK_FUNCTION(mutex)\n    ABSL_LOCKS_EXCLUDED(GetUpdateSitesMutex()) {\n  std::vector<VModuleInfo> infos = get_vmodule_info();\n  int current_global_v = global_v;\n  // We need to grab `GetUpdateSitesMutex()` before we release `mutex` to ensure\n  // that updates are not interleaved (resulting in an inconsistent final state)\n  // and to ensure that the final state in the sites matches the final state of\n  // `vmodule_info`. We unlock `mutex` to ensure that uninitialized sites don't\n  // have to wait on all updates in order to acquire `mutex` and initialize\n  // themselves.\n  absl::MutexLock ul(GetUpdateSitesMutex());\n  mutex.Unlock();\n  VLogSite* n = site_list_head.load(std::memory_order_seq_cst);\n  // Because sites are added to the list in the order they are executed, there\n  // tend to be clusters of entries with the same file.\n  const char* last_file = nullptr;\n  int last_file_level = 0;\n  while (n != nullptr) {\n    if (n->file_ != last_file) {\n      last_file = n->file_;\n      last_file_level = VLogLevel(n->file_, &infos, current_global_v);\n    }\n    n->v_.store(last_file_level, std::memory_order_seq_cst);\n    n = n->next_.load(std::memory_order_seq_cst);\n  }\n  if (update_callbacks) {\n    for (auto& cb : *update_callbacks) {\n      cb();\n    }\n  }\n}\n\nvoid UpdateVModule(absl::string_view vmodule)\n    ABSL_LOCKS_EXCLUDED(mutex, GetUpdateSitesMutex()) {\n  std::vector<std::pair<absl::string_view, int>> glob_levels;\n  for (absl::string_view glob_level : absl::StrSplit(vmodule, ',')) {\n    const size_t eq = glob_level.rfind('=');\n    if (eq == glob_level.npos) continue;\n    const absl::string_view glob = glob_level.substr(0, eq);\n    int level;\n    if (!absl::SimpleAtoi(glob_level.substr(eq + 1), &level)) continue;\n    glob_levels.emplace_back(glob, level);\n  }\n  mutex.Lock();  // Unlocked by UpdateVLogSites().\n  get_vmodule_info().clear();\n  for (const auto& it : glob_levels) {\n    const absl::string_view glob = it.first;\n    const int level = it.second;\n    AppendVModuleLocked(glob, level);\n  }\n  UpdateVLogSites();\n}\n\nint UpdateGlobalVLogLevel(int v)\n    ABSL_LOCKS_EXCLUDED(mutex, GetUpdateSitesMutex()) {\n  mutex.Lock();  // Unlocked by UpdateVLogSites().\n  const int old_global_v = global_v;\n  if (v == global_v) {\n    mutex.Unlock();\n    return old_global_v;\n  }\n  global_v = v;\n  UpdateVLogSites();\n  return old_global_v;\n}\n\nint PrependVModule(absl::string_view module_pattern, int log_level)\n    ABSL_LOCKS_EXCLUDED(mutex, GetUpdateSitesMutex()) {\n  mutex.Lock();  // Unlocked by UpdateVLogSites().\n  int old_v = PrependVModuleLocked(module_pattern, log_level);\n  UpdateVLogSites();\n  return old_v;\n}\n\nvoid OnVLogVerbosityUpdate(std::function<void()> cb)\n    ABSL_LOCKS_EXCLUDED(GetUpdateSitesMutex()) {\n  absl::MutexLock ul(GetUpdateSitesMutex());\n  if (!update_callbacks)\n    update_callbacks = new std::vector<std::function<void()>>;\n  update_callbacks->push_back(std::move(cb));\n}\n\nVLogSite* SetVModuleListHeadForTestOnly(VLogSite* v) {\n  return site_list_head.exchange(v, std::memory_order_seq_cst);\n}\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02760",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/vlog_config.cc",
  "source_line": 43,
  "validation_status": "validated"
}