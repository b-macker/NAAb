{
  "code": "{\npublic:\n  CheckerRegistry(CheckerRegistryData &Data, ArrayRef<std::string> Plugins,\n                  DiagnosticsEngine &Diags, AnalyzerOptions &AnOpts,\n                  ArrayRef<std::function<void(CheckerRegistry &)>>\n                      CheckerRegistrationFns = {});\n\n  /// Collects all enabled checkers in the field EnabledCheckers. It preserves\n  /// the order of insertion, as dependencies have to be enabled before the\n  /// checkers that depend on them.\n  void initializeRegistry(const CheckerManager &Mgr);\n\n\nprivate:\n  /// Default initialization function for checkers -- since CheckerManager\n  /// includes this header, we need to make it a template parameter, and since\n  /// the checker must be a template parameter as well, we can't put this in the\n  /// cpp file.\n  template <typename MGR, typename T> static void initializeManager(MGR &mgr) {\n    mgr.template registerChecker<T>();\n  }\n\n  template <typename T> static bool returnTrue(const CheckerManager &mgr) {\n    return true;\n  }\n\npublic:\n  /// Adds a checker to the registry. Use this non-templated overload when your\n  /// checker requires custom initialization.\n  void addChecker(RegisterCheckerFn Fn, ShouldRegisterFunction sfn,\n                  StringRef FullName, StringRef Desc, StringRef DocsUri,\n                  bool IsHidden);\n\n  /// Adds a checker to the registry. Use this templated overload when your\n  /// checker does not require any custom initialization.\n  /// This function isn't really needed and probably causes more headaches than\n  /// the tiny convenience that it provides, but external plugins might use it,\n  /// and there isn't a strong incentive to remove it.\n  template <class T>\n  void addChecker(StringRef FullName, StringRef Desc, StringRef DocsUri,\n                  bool IsHidden = false) {\n    // Avoid MSVC's Compiler Error C2276:\n    // http://msdn.microsoft.com/en-us/library/850cstw1(v=VS.80).aspx\n    addChecker(&CheckerRegistry::initializeManager<CheckerManager, T>,\n               &CheckerRegistry::returnTrue<T>, FullName, Desc, DocsUri,\n               IsHidden);\n  }\n\n  /// Makes the checker with the full name \\p fullName depend on the checker\n  /// called \\p dependency.\n  void addDependency(StringRef FullName, StringRef Dependency);\n\n  /// Makes the checker with the full name \\p fullName weak depend on the\n  /// checker called \\p dependency.\n  void addWeakDependency(StringRef FullName, StringRef Dependency);\n\n  /// Registers an option to a given checker. A checker option will always have\n  /// the following format:\n  ///   CheckerFullName:OptionName=Value\n  /// And can be specified from the command line like this:\n  ///   -analyzer-config CheckerFullName:OptionName=Value\n  ///\n  /// Options for unknown checkers, or unknown options for a given checker, or\n  /// invalid value types for that given option are reported as an error in\n  /// non-compatibility mode.\n  void addCheckerOption(StringRef OptionType, StringRef CheckerFullName,\n                        StringRef OptionName, StringRef DefaultValStr,\n                        StringRef Description, StringRef DevelopmentStatus,\n                        bool IsHidden = false);\n\n  /// Adds a package to the registry.\n  void addPackage(StringRef FullName);\n\n  /// Registers an option to a given package. A package option will always have\n  /// the following format:\n  ///   PackageFullName:OptionName=Value\n  /// And can be specified from the command line like this:\n  ///   -analyzer-config PackageFullName:OptionName=Value\n  ///\n  /// Options for unknown packages, or unknown options for a given package, or\n  /// invalid value types for that given option are reported as an error in\n  /// non-compatibility mode.\n  void addPackageOption(StringRef OptionType, StringRef PackageFullName,\n                        StringRef OptionName, StringRef DefaultValStr,\n                        StringRef Description, StringRef DevelopmentStatus,\n                        bool IsHidden = false);\n\n  // FIXME: This *really* should be added to the frontend flag descriptions.\n  /// Initializes a CheckerManager by calling the initialization functions for\n  /// all checkers specified by the given CheckerOptInfo list. The order of this\n  /// list is significant; later options can be used to reverse earlier ones.\n  /// This can be used to exclude certain checkers in an included package.\n  void initializeManager(CheckerManager &CheckerMgr) const;\n\n  /// Check if every option corresponds to a specific checker or package.\n  void validateCheckerOptions() const;\n\nprivate:\n  template <bool IsWeak> void resolveDependencies();\n  void resolveCheckerAndPackageOptions();\n\n  CheckerRegistryData &Data;\n\n  DiagnosticsEngine &Diags;\n  AnalyzerOptions &AnOpts;\n}",
  "id": "BLOCK-CPP-22374",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h",
  "source_line": 89,
  "validation_status": "validated"
}