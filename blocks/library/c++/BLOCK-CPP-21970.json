{
  "code": "{\n///   return ASTMatchSwitchBuilder<TransferState<MyLattice>>()\n///     .CaseOf(callExpr(callee(functionDecl(hasName(\"foo\")))), TransferFooCall)\n///     .CaseOf(callExpr(argumentCountIs(2),\n///                      callee(functionDecl(hasName(\"bar\")))),\n///             TransferBarCall)\n///     .Build();\n/// }\n/// \\endcode\ntemplate <typename BaseT, typename State, typename Result = void>\nclass ASTMatchSwitchBuilder {\npublic:\n  /// Registers an action that will be triggered by the match of a pattern\n  /// against the input statement.\n  ///\n  /// Requirements:\n  ///\n  ///  `NodeT` should be derived from `BaseT`.\n  template <typename NodeT>\n  ASTMatchSwitchBuilder &&CaseOf(MatchSwitchMatcher<BaseT> M,\n                                 MatchSwitchAction<NodeT, State, Result> A) && {\n    static_assert(std::is_base_of<BaseT, NodeT>::value,\n                  \"NodeT must be derived from BaseT.\");\n    Matchers.push_back(std::move(M));\n    Actions.push_back(\n        [A = std::move(A)](const BaseT *Node,\n                           const ast_matchers::MatchFinder::MatchResult &R,\n                           State &S) { return A(cast<NodeT>(Node), R, S); });\n    return std::move(*this);\n  }\n\n  ASTMatchSwitch<BaseT, State, Result> Build() && {\n    return [Matcher = BuildMatcher(), Actions = std::move(Actions)](\n               const BaseT &Node, ASTContext &Context, State &S) -> Result {\n      auto Results = ast_matchers::matchDynamic(Matcher, Node, Context);\n      if (Results.empty()) {\n        return Result();\n      }\n      // Look through the map for the first binding of the form \"TagN...\" use\n      // that to select the action.\n      for (const auto &Element : Results[0].getMap()) {\n        llvm::StringRef ID(Element.first);\n        size_t Index = 0;\n        if (ID.consume_front(\"Tag\") && !ID.getAsInteger(10, Index) &&\n            Index < Actions.size()) {\n          return Actions[Index](\n              &Node,\n              ast_matchers::MatchFinder::MatchResult(Results[0], &Context), S);\n        }\n      }\n      return Result();\n    };\n  }\n\nprivate:\n  ast_matchers::internal::DynTypedMatcher BuildMatcher() {\n    using ast_matchers::anything;\n    using ast_matchers::stmt;\n    using ast_matchers::unless;\n    using ast_matchers::internal::DynTypedMatcher;\n    if (Matchers.empty())\n      return stmt(unless(anything()));\n    for (int I = 0, N = Matchers.size(); I < N; ++I) {\n      std::string Tag = (\"Tag\" + llvm::Twine(I)).str();\n      // Many matchers are not bindable, so ensure that tryBind will work.\n      Matchers[I].setAllowBind(true);\n      auto M = *Matchers[I].tryBind(Tag);\n      // Each anyOf explicitly controls the traversal kind. The anyOf itself is\n      // set to `TK_AsIs` to ensure no nodes are skipped, thereby deferring to\n      // the kind of the branches. Then, each branch is either left as is, if\n      // the kind is already set, or explicitly set to `TK_AsIs`. We choose this\n      // setting because it is the default interpretation of matchers.\n      Matchers[I] =\n          !M.getTraversalKind() ? M.withTraversalKind(TK_AsIs) : std::move(M);\n    }\n    // The matcher type on the cases ensures that `Expr` kind is compatible with\n    // all of the matchers.\n    return DynTypedMatcher::constructVariadic(\n        DynTypedMatcher::VO_AnyOf, ASTNodeKind::getFromNodeKind<BaseT>(),\n        std::move(Matchers));\n  }\n\n  std::vector<ast_matchers::internal::DynTypedMatcher> Matchers;\n  std::vector<MatchSwitchAction<BaseT, State, Result>> Actions;\n};\n\n}",
  "id": "BLOCK-CPP-21970",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/MatchSwitch.h",
  "source_line": 82,
  "validation_status": "validated"
}