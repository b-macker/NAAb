{
  "code": "{\n public:\n  explicit HashtablezInfoHandle() : info_(nullptr) {}\n  explicit HashtablezInfoHandle(HashtablezInfo* info) : info_(info) {}\n\n  // We do not have a destructor. Caller is responsible for calling Unregister\n  // before destroying the handle.\n  void Unregister() {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    UnsampleSlow(info_);\n  }\n\n  inline bool IsSampled() const { return ABSL_PREDICT_FALSE(info_ != nullptr); }\n\n  inline void RecordStorageChanged(size_t size, size_t capacity) {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordStorageChangedSlow(info_, size, capacity);\n  }\n\n  inline void RecordRehash(size_t total_probe_length) {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordRehashSlow(info_, total_probe_length);\n  }\n\n  inline void RecordReservation(size_t target_capacity) {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordReservationSlow(info_, target_capacity);\n  }\n\n  inline void RecordClearedReservation() {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordClearedReservationSlow(info_);\n  }\n\n  inline void RecordInsert(size_t hash, size_t distance_from_desired) {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordInsertSlow(info_, hash, distance_from_desired);\n  }\n\n  inline void RecordErase() {\n    if (ABSL_PREDICT_TRUE(info_ == nullptr)) return;\n    RecordEraseSlow(info_);\n  }\n\n  friend inline void swap(HashtablezInfoHandle& lhs,\n                          HashtablezInfoHandle& rhs) {\n    std::swap(lhs.info_, rhs.info_);\n  }\n\n private:\n  friend class HashtablezInfoHandlePeer;\n  HashtablezInfo* info_;\n}",
  "id": "BLOCK-CPP-05037",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/hashtablez_sampler.h",
  "source_line": 128,
  "validation_status": "validated"
}