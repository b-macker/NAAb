{
  "code": "{\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_ExprSubstitutionFailure,\n      SS_NoexceptNotMet,\n      SS_TypeRequirementSubstitutionFailure,\n      SS_ConstraintsNotSatisfied,\n      SS_Satisfied\n  };\n  class ReturnTypeRequirement {\n      llvm::PointerIntPair<\n          llvm::PointerUnion<TemplateParameterList *, SubstitutionDiagnostic *>,\n          1, bool>\n          TypeConstraintInfo;\n  public:\n      friend ASTStmtReader;\n      friend ASTStmtWriter;\n\n      /// \\brief No return type requirement was specified.\n      ReturnTypeRequirement() : TypeConstraintInfo(nullptr, false) {}\n\n      /// \\brief A return type requirement was specified but it was a\n      /// substitution failure.\n      ReturnTypeRequirement(SubstitutionDiagnostic *SubstDiag) :\n          TypeConstraintInfo(SubstDiag, false) {}\n\n      /// \\brief A 'type constraint' style return type requirement.\n      /// \\param TPL an invented template parameter list containing a single\n      /// type parameter with a type-constraint.\n      // TODO: Can we maybe not save the whole template parameter list and just\n      //  the type constraint? Saving the whole TPL makes it easier to handle in\n      //  serialization but is less elegant.\n      ReturnTypeRequirement(TemplateParameterList *TPL);\n\n      bool isDependent() const {\n        return TypeConstraintInfo.getInt();\n      }\n\n      bool containsUnexpandedParameterPack() const {\n        if (!isTypeConstraint())\n          return false;\n        return getTypeConstraintTemplateParameterList()\n                ->containsUnexpandedParameterPack();\n      }\n\n      bool isEmpty() const {\n        return TypeConstraintInfo.getPointer().isNull();\n      }\n\n      bool isSubstitutionFailure() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<SubstitutionDiagnostic *>();\n      }\n\n      bool isTypeConstraint() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<TemplateParameterList *>();\n      }\n\n      SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n        assert(isSubstitutionFailure());\n        return TypeConstraintInfo.getPointer().get<SubstitutionDiagnostic *>();\n      }\n\n      const TypeConstraint *getTypeConstraint() const;\n\n      TemplateParameterList *getTypeConstraintTemplateParameterList() const {\n        assert(isTypeConstraint());\n        return TypeConstraintInfo.getPointer().get<TemplateParameterList *>();\n      }\n  };\nprivate:\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  SourceLocation NoexceptLoc; // May be empty if noexcept wasn't specified.\n  ReturnTypeRequirement TypeReq;\n  ConceptSpecializationExpr *SubstitutedConstraintExpr;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a compound requirement.\n  /// \\param E the expression which is checked by this requirement.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression.\n  /// \\param Status the satisfaction status of this requirement.\n  ExprRequirement(\n      Expr *E, bool IsSimple, SourceLocation NoexceptLoc,\n      ReturnTypeRequirement Req, SatisfactionStatus Status,\n      ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr);\n\n  /// \\brief Construct a compound requirement whose expression was a\n  /// substitution failure. The requirement is not satisfied.\n  /// \\param E the diagnostic emitted while instantiating the original\n  /// expression.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression (omit\n  /// if no requirement was specified).\n  ExprRequirement(SubstitutionDiagnostic *E, bool IsSimple,\n                  SourceLocation NoexceptLoc, ReturnTypeRequirement Req = {});\n\n  bool isSimple() const { return getKind() == RK_Simple; }\n  bool isCompound() const { return getKind() == RK_Compound; }\n\n  bool hasNoexceptRequirement() const { return NoexceptLoc.isValid(); }\n  SourceLocation getNoexceptLoc() const { return NoexceptLoc; }\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n\n  bool isExprSubstitutionFailure() const {\n    return Status == SS_ExprSubstitutionFailure;\n  }\n\n  const ReturnTypeRequirement &getReturnTypeRequirement() const {\n    return TypeReq;\n  }\n\n  ConceptSpecializationExpr *\n  getReturnTypeRequirementSubstitutedConstraintExpr() const {\n    assert(Status >= SS_TypeRequirementSubstitutionFailure);\n    return SubstitutedConstraintExpr;\n  }\n\n  SubstitutionDiagnostic *getExprSubstitutionDiagnostic() const {\n    assert(isExprSubstitutionFailure() &&\n           \"Attempted to get expression substitution diagnostic when there has \"\n           \"been no expression substitution failure\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getExpr() const {\n    assert(!isExprSubstitutionFailure() &&\n           \"ExprRequirement has no expression because there has been a \"\n           \"substitution failure.\");\n    return Value.get<Expr *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Compound || R->getKind() == RK_Simple;\n  }\n}",
  "id": "BLOCK-CPP-10861",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprConcepts.h",
  "source_line": 258,
  "validation_status": "validated"
}