{
  "code": "{\npublic:\n  using path_list = SmallVector<std::string, 16>;\n\n  enum CXXStdlibType {\n    CST_Libcxx,\n    CST_Libstdcxx\n  };\n\n  enum RuntimeLibType {\n    RLT_CompilerRT,\n    RLT_Libgcc\n  };\n\n  enum UnwindLibType {\n    UNW_None,\n    UNW_CompilerRT,\n    UNW_Libgcc\n  };\n\n  enum class UnwindTableLevel {\n    None,\n    Synchronous,\n    Asynchronous,\n  };\n\n  enum RTTIMode {\n    RM_Enabled,\n    RM_Disabled,\n  };\n\n  struct BitCodeLibraryInfo {\n    std::string Path;\n    bool ShouldInternalize;\n    BitCodeLibraryInfo(StringRef Path, bool ShouldInternalize = true)\n        : Path(Path), ShouldInternalize(ShouldInternalize) {}\n  };\n\n  enum FileType { FT_Object, FT_Static, FT_Shared };\n\nprivate:\n  friend class RegisterEffectiveTriple;\n\n  const Driver &D;\n  llvm::Triple Triple;\n  const llvm::opt::ArgList &Args;\n\n  // We need to initialize CachedRTTIArg before CachedRTTIMode\n  const llvm::opt::Arg *const CachedRTTIArg;\n\n  const RTTIMode CachedRTTIMode;\n\n  /// The list of toolchain specific path prefixes to search for libraries.\n  path_list LibraryPaths;\n\n  /// The list of toolchain specific path prefixes to search for files.\n  path_list FilePaths;\n\n  /// The list of toolchain specific path prefixes to search for programs.\n  path_list ProgramPaths;\n\n  mutable std::unique_ptr<Tool> Clang;\n  mutable std::unique_ptr<Tool> Flang;\n  mutable std::unique_ptr<Tool> Assemble;\n  mutable std::unique_ptr<Tool> Link;\n  mutable std::unique_ptr<Tool> StaticLibTool;\n  mutable std::unique_ptr<Tool> IfsMerge;\n  mutable std::unique_ptr<Tool> OffloadBundler;\n  mutable std::unique_ptr<Tool> OffloadPackager;\n  mutable std::unique_ptr<Tool> LinkerWrapper;\n\n  Tool *getClang() const;\n  Tool *getFlang() const;\n  Tool *getAssemble() const;\n  Tool *getLink() const;\n  Tool *getStaticLibTool() const;\n  Tool *getIfsMerge() const;\n  Tool *getClangAs() const;\n  Tool *getOffloadBundler() const;\n  Tool *getOffloadPackager() const;\n  Tool *getLinkerWrapper() const;\n\n  mutable bool SanitizerArgsChecked = false;\n  mutable std::unique_ptr<XRayArgs> XRayArguments;\n\n  /// The effective clang triple for the current Job.\n  mutable llvm::Triple EffectiveTriple;\n\n  /// Set the toolchain's effective clang triple.\n  void setEffectiveTriple(llvm::Triple ET) const {\n    EffectiveTriple = std::move(ET);\n  }\n\n  mutable std::optional<CXXStdlibType> cxxStdlibType;\n  mutable std::optional<RuntimeLibType> runtimeLibType;\n  mutable std::optional<UnwindLibType> unwindLibType;\n\nprotected:\n  MultilibSet Multilibs;\n  llvm::SmallVector<Multilib> SelectedMultilibs;\n\n  ToolChain(const Driver &D, const llvm::Triple &T,\n            const llvm::opt::ArgList &Args);\n\n  /// Executes the given \\p Executable and returns the stdout.\n  llvm::Expected<std::unique_ptr<llvm::MemoryBuffer>>\n  executeToolChainProgram(StringRef Executable) const;\n\n  void setTripleEnvironment(llvm::Triple::EnvironmentType Env);\n\n  virtual Tool *buildAssembler() const;\n  virtual Tool *buildLinker() const;\n  virtual Tool *buildStaticLibTool() const;\n  virtual Tool *getTool(Action::ActionClass AC) const;\n\n  virtual std::string buildCompilerRTBasename(const llvm::opt::ArgList &Args,\n                                              StringRef Component,\n                                              FileType Type,\n                                              bool AddArch) const;\n\n  /// \\name Utilities for implementing subclasses.\n  ///@{\n  static void addSystemInclude(const llvm::opt::ArgList &DriverArgs,\n                               llvm::opt::ArgStringList &CC1Args,\n                               const Twine &Path);\n  static void addExternCSystemInclude(const llvm::opt::ArgList &DriverArgs,\n                                      llvm::opt::ArgStringList &CC1Args,\n                                      const Twine &Path);\n  static void\n      addExternCSystemIncludeIfExists(const llvm::opt::ArgList &DriverArgs,\n                                      llvm::opt::ArgStringList &CC1Args,\n                                      const Twine &Path);\n  static void addSystemIncludes(const llvm::opt::ArgList &DriverArgs,\n                                llvm::opt::ArgStringList &CC1Args,\n                                ArrayRef<StringRef> Paths);\n\n  static std::string concat(StringRef Path, const Twine &A, const Twine &B = \"\",\n                            const Twine &C = \"\", const Twine &D = \"\");\n  ///@}\n\npublic:\n  virtual ~ToolChain();\n\n  // Accessors\n\n  const Driver &getDriver() const { return D; }\n  llvm::vfs::FileSystem &getVFS() const;\n  const llvm::Triple &getTriple() const { return Triple; }\n\n  /// Get the toolchain's aux triple, if it has one.\n  ///\n  /// Exactly what the aux triple represents depends on the toolchain, but for\n  /// example when compiling CUDA code for the GPU, the triple might be NVPTX,\n  /// while the aux triple is the host (CPU) toolchain, e.g. x86-linux-gnu.\n  virtual const llvm::Triple *getAuxTriple() const { return nullptr; }\n\n  /// Some toolchains need to modify the file name, for example to replace the\n  /// extension for object files with .cubin for OpenMP offloading to Nvidia\n  /// GPUs.\n  virtual std::string getInputFilename(const InputInfo &Input) const;\n\n  llvm::Triple::ArchType getArch() const { return Triple.getArch(); }\n  StringRef getArchName() const { return Triple.getArchName(); }\n  StringRef getPlatform() const { return Triple.getVendorName(); }\n  StringRef getOS() const { return Triple.getOSName(); }\n\n  /// Provide the default architecture name (as expected by -arch) for\n  /// this toolchain.\n  StringRef getDefaultUniversalArchName() const;\n\n  std::string getTripleString() const {\n    return Triple.getTriple();\n  }\n\n  /// Get the toolchain's effective clang triple.\n  const llvm::Triple &getEffectiveTriple() const {\n    assert(!EffectiveTriple.getTriple().empty() && \"No effective triple\");\n    return EffectiveTriple;\n  }\n\n  bool hasEffectiveTriple() const {\n    return !EffectiveTriple.getTriple().empty();\n  }\n\n  path_list &getLibraryPaths() { return LibraryPaths; }\n  const path_list &getLibraryPaths() const { return LibraryPaths; }\n\n  path_list &getFilePaths() { return FilePaths; }\n  const path_list &getFilePaths() const { return FilePaths; }\n\n  path_list &getProgramPaths() { return ProgramPaths; }\n  const path_list &getProgramPaths() const { return ProgramPaths; }\n\n  const MultilibSet &getMultilibs() const { return Multilibs; }\n\n  const llvm::SmallVector<Multilib> &getSelectedMultilibs() const {\n    return SelectedMultilibs;\n  }\n\n  /// Get flags suitable for multilib selection, based on the provided clang\n  /// command line arguments. The command line arguments aren't suitable to be\n  /// used directly for multilib selection because they are not normalized and\n  /// normalization is a complex process. The result of this function is similar\n  /// to clang command line arguments except that the list of arguments is\n  /// incomplete. Only certain command line arguments are processed. If more\n  /// command line arguments are needed for multilib selection then this\n  /// function should be extended.\n  /// To allow users to find out what flags are returned, clang accepts a\n  /// -print-multi-flags-experimental argument.\n  Multilib::flags_list getMultilibFlags(const llvm::opt::ArgList &) const;\n\n  SanitizerArgs getSanitizerArgs(const llvm::opt::ArgList &JobArgs) const;\n\n  const XRayArgs& getXRayArgs() const;\n\n  // Returns the Arg * that explicitly turned on/off rtti, or nullptr.\n  const llvm::opt::Arg *getRTTIArg() const { return CachedRTTIArg; }\n\n  // Returns the RTTIMode for the toolchain with the current arguments.\n  RTTIMode getRTTIMode() const { return CachedRTTIMode; }\n\n  /// Return any implicit target and/or mode flag for an invocation of\n  /// the compiler driver as `ProgName`.\n  ///\n  /// For example, when called with i686-linux-android-g++, the first element\n  /// of the return value will be set to `\"i686-linux-android\"` and the second\n  /// will be set to \"--driver-mode=g++\"`.\n  /// It is OK if the target name is not registered. In this case the return\n  /// value contains false in the field TargetIsValid.\n  ///\n  /// \\pre `llvm::InitializeAllTargets()` has been called.\n  /// \\param ProgName The name the Clang driver was invoked with (from,\n  /// e.g., argv[0]).\n  /// \\return A structure of type ParsedClangName that contains the executable\n  /// name parts.\n  static ParsedClangName getTargetAndModeFromProgramName(StringRef ProgName);\n\n  // Tool access.\n\n  /// TranslateArgs - Create a new derived argument list for any argument\n  /// translations this ToolChain may wish to perform, or 0 if no tool chain\n  /// specific translations are needed. If \\p DeviceOffloadKind is specified\n  /// the translation specific for that offload kind is performed.\n  ///\n  /// \\param BoundArch - The bound architecture name, or 0.\n  /// \\param DeviceOffloadKind - The device offload kind used for the\n  /// translation.\n  virtual llvm::opt::DerivedArgList *\n  TranslateArgs(const llvm::opt::DerivedArgList &Args, StringRef BoundArch,\n                Action::OffloadKind DeviceOffloadKind) const {\n    return nullptr;\n  }\n\n  /// TranslateOpenMPTargetArgs - Create a new derived argument list for\n  /// that contains the OpenMP target specific flags passed via\n  /// -Xopenmp-target -opt=val OR -Xopenmp-target=<triple> -opt=val\n  virtual llvm::opt::DerivedArgList *TranslateOpenMPTargetArgs(\n      const llvm::opt::DerivedArgList &Args, bool SameTripleAsHost,\n      SmallVectorImpl<llvm::opt::Arg *> &AllocatedArgs) const;\n\n  /// Append the argument following \\p A to \\p DAL assuming \\p A is an Xarch\n  /// argument. If \\p AllocatedArgs is null pointer, synthesized arguments are\n  /// added to \\p DAL, otherwise they are appended to \\p AllocatedArgs.\n  virtual void TranslateXarchArgs(\n      const llvm::opt::DerivedArgList &Args, llvm::opt::Arg *&A,\n      llvm::opt::DerivedArgList *DAL,\n      SmallVectorImpl<llvm::opt::Arg *> *AllocatedArgs = nullptr) const;\n\n  /// Translate -Xarch_ arguments. If there are no such arguments, return\n  /// a null pointer, otherwise return a DerivedArgList containing the\n  /// translated arguments.\n  virtual llvm::opt::DerivedArgList *\n  TranslateXarchArgs(const llvm::opt::DerivedArgList &Args, StringRef BoundArch,\n                     Action::OffloadKind DeviceOffloadKind,\n                     SmallVectorImpl<llvm::opt::Arg *> *AllocatedArgs) const;\n\n  /// Choose a tool to use to handle the action \\p JA.\n  ///\n  /// This can be overridden when a particular ToolChain needs to use\n  /// a compiler other than Clang.\n  virtual Tool *SelectTool(const JobAction &JA) const;\n\n  // Helper methods\n\n  std::string GetFilePath(const char *Name) const;\n  std::string GetProgramPath(const char *Name) const;\n\n  /// Returns the linker path, respecting the -fuse-ld= argument to determine\n  /// the linker suffix or name.\n  /// If LinkerIsLLD is non-nullptr, it is set to true if the returned linker\n  /// is LLD. If it's set, it can be assumed that the linker is LLD built\n  /// at the same revision as clang, and clang can make assumptions about\n  /// LLD's supported flags, error output, etc.\n  std::string GetLinkerPath(bool *LinkerIsLLD = nullptr) const;\n\n  /// Returns the linker path for emitting a static library.\n  std::string GetStaticLibToolPath() const;\n\n  /// Dispatch to the specific toolchain for verbose printing.\n  ///\n  /// This is used when handling the verbose option to print detailed,\n  /// toolchain-specific information useful for understanding the behavior of\n  /// the driver on a specific platform.\n  virtual void printVerboseInfo(raw_ostream &OS) const {}\n\n  // Platform defaults information\n\n  /// Returns true if the toolchain is targeting a non-native\n  /// architecture.\n  virtual bool isCrossCompiling() const;\n\n  /// HasNativeLTOLinker - Check whether the linker and related tools have\n  /// native LLVM support.\n  virtual bool HasNativeLLVMSupport() const;\n\n  /// LookupTypeForExtension - Return the default language type to use for the\n  /// given extension.\n  virtual types::ID LookupTypeForExtension(StringRef Ext) const;\n\n  /// IsBlocksDefault - Does this tool chain enable -fblocks by default.\n  virtual bool IsBlocksDefault() const { return false; }\n\n  /// IsIntegratedAssemblerDefault - Does this tool chain enable -integrated-as\n  /// by default.\n  virtual bool IsIntegratedAssemblerDefault() const { return true; }\n\n  /// IsIntegratedBackendDefault - Does this tool chain enable\n  /// -fintegrated-objemitter by default.\n  virtual bool IsIntegratedBackendDefault() const { return true; }\n\n  /// IsIntegratedBackendSupported - Does this tool chain support\n  /// -fintegrated-objemitter.\n  virtual bool IsIntegratedBackendSupported() const { return true; }\n\n  /// IsNonIntegratedBackendSupported - Does this tool chain support\n  /// -fno-integrated-objemitter.\n  virtual bool IsNonIntegratedBackendSupported() const { return false; }\n\n  /// Check if the toolchain should use the integrated assembler.\n  virtual bool useIntegratedAs() const;\n\n  /// Check if the toolchain should use the integrated backend.\n  virtual bool useIntegratedBackend() const;\n\n  /// Check if the toolchain should use AsmParser to parse inlineAsm when\n  /// integrated assembler is not default.\n  virtual bool parseInlineAsmUsingAsmParser() const { return false; }\n\n  /// IsMathErrnoDefault - Does this tool chain use -fmath-errno by default.\n  virtual bool IsMathErrnoDefault() const { return true; }\n\n  /// IsEncodeExtendedBlockSignatureDefault - Does this tool chain enable\n  /// -fencode-extended-block-signature by default.\n  virtual bool IsEncodeExtendedBlockSignatureDefault() const { return false; }\n\n  /// IsObjCNonFragileABIDefault - Does this tool chain set\n  /// -fobjc-nonfragile-abi by default.\n  virtual bool IsObjCNonFragileABIDefault() const { return false; }\n\n  /// UseObjCMixedDispatchDefault - When using non-legacy dispatch, should the\n  /// mixed dispatch method be used?\n  virtual bool UseObjCMixedDispatch() const { return false; }\n\n  /// Check whether to enable x86 relax relocations by default.\n  virtual bool useRelaxRelocations() const;\n\n  /// Check whether use IEEE binary128 as long double format by default.\n  bool defaultToIEEELongDouble() const;\n\n  /// GetDefaultStackProtectorLevel - Get the default stack protector level for\n  /// this tool chain.\n  virtual LangOptions::StackProtectorMode\n  GetDefaultStackProtectorLevel(bool KernelOrKext) const {\n    return LangOptions::SSPOff;\n  }\n\n  /// Get the default trivial automatic variable initialization.\n  virtual LangOptions::TrivialAutoVarInitKind\n  GetDefaultTrivialAutoVarInit() const {\n    return LangOptions::TrivialAutoVarInitKind::Uninitialized;\n  }\n\n  /// GetDefaultLinker - Get the default linker to use.\n  virtual const char *getDefaultLinker() const { return \"ld\"; }\n\n  /// GetDefaultRuntimeLibType - Get the default runtime library variant to use.\n  virtual RuntimeLibType GetDefaultRuntimeLibType() const {\n    return ToolChain::RLT_Libgcc;\n  }\n\n  virtual CXXStdlibType GetDefaultCXXStdlibType() const {\n    return ToolChain::CST_Libstdcxx;\n  }\n\n  virtual UnwindLibType GetDefaultUnwindLibType() const {\n    return ToolChain::UNW_None;\n  }\n\n  virtual std::string getCompilerRTPath() const;\n\n  virtual std::string getCompilerRT(const llvm::opt::ArgList &Args,\n                                    StringRef Component,\n                                    FileType Type = ToolChain::FT_Static) const;\n\n  const char *\n  getCompilerRTArgString(const llvm::opt::ArgList &Args, StringRef Component,\n                         FileType Type = ToolChain::FT_Static) const;\n\n  std::string getCompilerRTBasename(const llvm::opt::ArgList &Args,\n                                    StringRef Component,\n                                    FileType Type = ToolChain::FT_Static) const;\n\n  // Returns target specific runtime paths.\n  path_list getRuntimePaths() const;\n\n  // Returns target specific standard library paths.\n  path_list getStdlibPaths() const;\n\n  // Returns <ResourceDir>/lib/<OSName>/<arch> or <ResourceDir>/lib/<triple>.\n  // This is used by runtimes (such as OpenMP) to find arch-specific libraries.\n  virtual path_list getArchSpecificLibPaths() const;\n\n  // Returns <OSname> part of above.\n  virtual StringRef getOSLibName() const;\n\n  /// needsProfileRT - returns true if instrumentation profile is on.\n  static bool needsProfileRT(const llvm::opt::ArgList &Args);\n\n  /// Returns true if gcov instrumentation (-fprofile-arcs or --coverage) is on.\n  static bool needsGCovInstrumentation(const llvm::opt::ArgList &Args);\n\n  /// How detailed should the unwind tables be by default.\n  virtual UnwindTableLevel\n  getDefaultUnwindTableLevel(const llvm::opt::ArgList &Args) const;\n\n  /// Test whether this toolchain supports outline atomics by default.\n  virtual bool\n  IsAArch64OutlineAtomicsDefault(const llvm::opt::ArgList &Args) const {\n    return false;\n  }\n\n  /// Test whether this toolchain defaults to PIC.\n  virtual bool isPICDefault() const = 0;\n\n  /// Test whether this toolchain defaults to PIE.\n  virtual bool isPIEDefault(const llvm::opt::ArgList &Args) const = 0;\n\n  /// Tests whether this toolchain forces its default for PIC, PIE or\n  /// non-PIC.  If this returns true, any PIC related flags should be ignored\n  /// and instead the results of \\c isPICDefault() and \\c isPIEDefault(const\n  /// llvm::opt::ArgList &Args) are used exclusively.\n  virtual bool isPICDefaultForced() const = 0;\n\n  /// SupportsProfiling - Does this tool chain support -pg.\n  virtual bool SupportsProfiling() const { return true; }\n\n  /// Complain if this tool chain doesn't support Objective-C ARC.\n  virtual void CheckObjCARC() const {}\n\n  /// Get the default debug info format. Typically, this is DWARF.\n  virtual llvm::codegenoptions::DebugInfoFormat getDefaultDebugFormat() const {\n    return llvm::codegenoptions::DIF_DWARF;\n  }\n\n  /// UseDwarfDebugFlags - Embed the compile options to clang into the Dwarf\n  /// compile unit information.\n  virtual bool UseDwarfDebugFlags() const { return false; }\n\n  /// Add an additional -fdebug-prefix-map entry.\n  virtual std::string GetGlobalDebugPathRemapping() const { return {}; }\n\n  // Return the DWARF version to emit, in the absence of arguments\n  // to the contrary.\n  virtual unsigned GetDefaultDwarfVersion() const;\n\n  // Some toolchains may have different restrictions on the DWARF version and\n  // may need to adjust it. E.g. NVPTX may need to enforce DWARF2 even when host\n  // compilation uses DWARF5.\n  virtual unsigned getMaxDwarfVersion() const { return UINT_MAX; }\n\n  // True if the driver should assume \"-fstandalone-debug\"\n  // in the absence of an option specifying otherwise,\n  // provided that debugging was requested in the first place.\n  // i.e. a value of 'true' does not imply that debugging is wanted.\n  virtual bool GetDefaultStandaloneDebug() const { return false; }\n\n  // Return the default debugger \"tuning.\"\n  virtual llvm::DebuggerKind getDefaultDebuggerTuning() const {\n    return llvm::DebuggerKind::GDB;\n  }\n\n  /// Does this toolchain supports given debug info option or not.\n  virtual bool supportsDebugInfoOption(const llvm::opt::Arg *) const {\n    return true;\n  }\n\n  /// Adjust debug information kind considering all passed options.\n  virtual void\n  adjustDebugInfoKind(llvm::codegenoptions::DebugInfoKind &DebugInfoKind,\n                      const llvm::opt::ArgList &Args) const {}\n\n  /// GetExceptionModel - Return the tool chain exception model.\n  virtual llvm::ExceptionHandling\n  GetExceptionModel(const llvm::opt::ArgList &Args) const;\n\n  /// SupportsEmbeddedBitcode - Does this tool chain support embedded bitcode.\n  virtual bool SupportsEmbeddedBitcode() const { return false; }\n\n  /// getThreadModel() - Which thread model does this target use?\n  virtual std::string getThreadModel() const { return \"posix\"; }\n\n  /// isThreadModelSupported() - Does this target support a thread model?\n  virtual bool isThreadModelSupported(const StringRef Model) const;\n\n  /// isBareMetal - Is this a bare metal target.\n  virtual bool isBareMetal() const { return false; }\n\n  virtual std::string getMultiarchTriple(const Driver &D,\n                                         const llvm::Triple &TargetTriple,\n                                         StringRef SysRoot) const {\n    return TargetTriple.str();\n  }\n\n  /// ComputeLLVMTriple - Return the LLVM target triple to use, after taking\n  /// command line arguments into account.\n  virtual std::string\n  ComputeLLVMTriple(const llvm::opt::ArgList &Args,\n                    types::ID InputType = types::TY_INVALID) const;\n\n  /// ComputeEffectiveClangTriple - Return the Clang triple to use for this\n  /// target, which may take into account the command line arguments. For\n  /// example, on Darwin the -mmacosx-version-min= command line argument (which\n  /// sets the deployment target) determines the version in the triple passed to\n  /// Clang.\n  virtual std::string ComputeEffectiveClangTriple(\n      const llvm::opt::ArgList &Args,\n      types::ID InputType = types::TY_INVALID) const;\n\n  /// getDefaultObjCRuntime - Return the default Objective-C runtime\n  /// for this platform.\n  ///\n  /// FIXME: this really belongs on some sort of DeploymentTarget abstraction\n  virtual ObjCRuntime getDefaultObjCRuntime(bool isNonFragile) const;\n\n  /// hasBlocksRuntime - Given that the user is compiling with\n  /// -fblocks, does this tool chain guarantee the existence of a\n  /// blocks runtime?\n  ///\n  /// FIXME: this really belongs on some sort of DeploymentTarget abstraction\n  virtual bool hasBlocksRuntime() const { return true; }\n\n  /// Return the sysroot, possibly searching for a default sysroot using\n  /// target-specific logic.\n  virtual std::string computeSysRoot() const;\n\n  /// Add the clang cc1 arguments for system include paths.\n  ///\n  /// This routine is responsible for adding the necessary cc1 arguments to\n  /// include headers from standard system header directories.\n  virtual void\n  AddClangSystemIncludeArgs(const llvm::opt::ArgList &DriverArgs,\n                            llvm::opt::ArgStringList &CC1Args) const;\n\n  /// Add options that need to be passed to cc1 for this target.\n  virtual void addClangTargetOptions(const llvm::opt::ArgList &DriverArgs,\n                                     llvm::opt::ArgStringList &CC1Args,\n                                     Action::OffloadKind DeviceOffloadKind) const;\n\n  /// Add options that need to be passed to cc1as for this target.\n  virtual void\n  addClangCC1ASTargetOptions(const llvm::opt::ArgList &Args,\n                             llvm::opt::ArgStringList &CC1ASArgs) const;\n\n  /// Add warning options that need to be passed to cc1 for this target.\n  virtual void addClangWarningOptions(llvm::opt::ArgStringList &CC1Args) const;\n\n  // GetRuntimeLibType - Determine the runtime library type to use with the\n  // given compilation arguments.\n  virtual RuntimeLibType\n  GetRuntimeLibType(const llvm::opt::ArgList &Args) const;\n\n  // GetCXXStdlibType - Determine the C++ standard library type to use with the\n  // given compilation arguments.\n  virtual CXXStdlibType GetCXXStdlibType(const llvm::opt::ArgList &Args) const;\n\n  // GetUnwindLibType - Determine the unwind library type to use with the\n  // given compilation arguments.\n  virtual UnwindLibType GetUnwindLibType(const llvm::opt::ArgList &Args) const;\n\n  // Detect the highest available version of libc++ in include path.\n  virtual std::string detectLibcxxVersion(StringRef IncludePath) const;\n\n  /// AddClangCXXStdlibIncludeArgs - Add the clang -cc1 level arguments to set\n  /// the include paths to use for the given C++ standard library type.\n  virtual void\n  AddClangCXXStdlibIncludeArgs(const llvm::opt::ArgList &DriverArgs,\n                               llvm::opt::ArgStringList &CC1Args) const;\n\n  /// AddClangCXXStdlibIsystemArgs - Add the clang -cc1 level arguments to set\n  /// the specified include paths for the C++ standard library.\n  void AddClangCXXStdlibIsystemArgs(const llvm::opt::ArgList &DriverArgs,\n                                    llvm::opt::ArgStringList &CC1Args) const;\n\n  /// Returns if the C++ standard library should be linked in.\n  /// Note that e.g. -lm should still be linked even if this returns false.\n  bool ShouldLinkCXXStdlib(const llvm::opt::ArgList &Args) const;\n\n  /// AddCXXStdlibLibArgs - Add the system specific linker arguments to use\n  /// for the given C++ standard library type.\n  virtual void AddCXXStdlibLibArgs(const llvm::opt::ArgList &Args,\n                                   llvm::opt::ArgStringList &CmdArgs) const;\n\n  /// AddFilePathLibArgs - Add each thing in getFilePaths() as a \"-L\" option.\n  void AddFilePathLibArgs(const llvm::opt::ArgList &Args,\n                          llvm::opt::ArgStringList &CmdArgs) const;\n\n  /// AddCCKextLibArgs - Add the system specific linker arguments to use\n  /// for kernel extensions (Darwin-specific).\n  virtual void AddCCKextLibArgs(const llvm::opt::ArgList &Args,\n                                llvm::opt::ArgStringList &CmdArgs) const;\n\n  /// If a runtime library exists that sets global flags for unsafe floating\n  /// point math, return true.\n  ///\n  /// This checks for presence of the -Ofast, -ffast-math or -funsafe-math flags.\n  virtual bool isFastMathRuntimeAvailable(\n    const llvm::opt::ArgList &Args, std::string &Path) const;\n\n  /// AddFastMathRuntimeIfAvailable - If a runtime library exists that sets\n  /// global flags for unsafe floating point math, add it and return true.\n  ///\n  /// This checks for presence of the -Ofast, -ffast-math or -funsafe-math flags.\n  bool addFastMathRuntimeIfAvailable(\n    const llvm::opt::ArgList &Args, llvm::opt::ArgStringList &CmdArgs) const;\n\n  /// getSystemGPUArchs - Use a tool to detect the user's availible GPUs.\n  virtual Expected<SmallVector<std::string>>\n  getSystemGPUArchs(const llvm::opt::ArgList &Args) const;\n\n  /// addProfileRTLibs - When -fprofile-instr-profile is specified, try to pass\n  /// a suitable profile runtime library to the linker.\n  virtual void addProfileRTLibs(const llvm::opt::ArgList &Args,\n                                llvm::opt::ArgStringList &CmdArgs) const;\n\n  /// Add arguments to use system-specific CUDA includes.\n  virtual void AddCudaIncludeArgs(const llvm::opt::ArgList &DriverArgs,\n                                  llvm::opt::ArgStringList &CC1Args) const;\n\n  /// Add arguments to use system-specific HIP includes.\n  virtual void AddHIPIncludeArgs(const llvm::opt::ArgList &DriverArgs,\n                                 llvm::opt::ArgStringList &CC1Args) const;\n\n  /// Add arguments to use MCU GCC toolchain includes.\n  virtual void AddIAMCUIncludeArgs(const llvm::opt::ArgList &DriverArgs,\n                                   llvm::opt::ArgStringList &CC1Args) const;\n\n  /// On Windows, returns the MSVC compatibility version.\n  virtual VersionTuple computeMSVCVersion(const Driver *D,\n                                          const llvm::opt::ArgList &Args) const;\n\n  /// Get paths for device libraries.\n  virtual llvm::SmallVector<BitCodeLibraryInfo, 12>\n  getDeviceLibs(const llvm::opt::ArgList &Args) const;\n\n  /// Add the system specific linker arguments to use\n  /// for the given HIP runtime library type.\n  virtual void AddHIPRuntimeLibArgs(const llvm::opt::ArgList &Args,\n                                    llvm::opt::ArgStringList &CmdArgs) const {}\n\n  /// Return sanitizers which are available in this toolchain.\n  virtual SanitizerMask getSupportedSanitizers() const;\n\n  /// Return sanitizers which are enabled by default.\n  virtual SanitizerMask getDefaultSanitizers() const {\n    return SanitizerMask();\n  }\n\n  /// Returns true when it's possible to split LTO unit to use whole\n  /// program devirtualization and CFI santiizers.\n  virtual bool canSplitThinLTOUnit() const { return true; }\n\n  /// Returns the output denormal handling type in the default floating point\n  /// environment for the given \\p FPType if given. Otherwise, the default\n  /// assumed mode for any floating point type.\n  virtual llvm::DenormalMode getDefaultDenormalModeForType(\n      const llvm::opt::ArgList &DriverArgs, const JobAction &JA,\n      const llvm::fltSemantics *FPType = nullptr) const {\n    return llvm::DenormalMode::getIEEE();\n  }\n\n  // We want to expand the shortened versions of the triples passed in to\n  // the values used for the bitcode libraries.\n  static llvm::Triple getOpenMPTriple(StringRef TripleStr) {\n    llvm::Triple TT(TripleStr);\n    if (TT.getVendor() == llvm::Triple::UnknownVendor ||\n        TT.getOS() == llvm::Triple::UnknownOS) {\n      if (TT.getArch() == llvm::Triple::nvptx)\n        return llvm::Triple(\"nvptx-nvidia-cuda\");\n      if (TT.getArch() == llvm::Triple::nvptx64)\n        return llvm::Triple(\"nvptx64-nvidia-cuda\");\n      if (TT.getArch() == llvm::Triple::amdgcn)\n        return llvm::Triple(\"amdgcn-amd-amdhsa\");\n    }\n    return TT;\n  }\n}",
  "id": "BLOCK-CPP-17919",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/ToolChain.h",
  "source_line": 91,
  "validation_status": "validated"
}