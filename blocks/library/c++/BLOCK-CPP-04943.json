{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace container_internal {\n\ntemplate <class, class = void>\nstruct IsTransparent : std::false_type {};\ntemplate <class T>\nstruct IsTransparent<T, absl::void_t<typename T::is_transparent>>\n    : std::true_type {};\n\ntemplate <bool is_transparent>\nstruct KeyArg {\n  // Transparent. Forward `K`.\n  template <typename K, typename key_type>\n  using type = K;\n};\n\ntemplate <>\nstruct KeyArg<false> {\n  // Not transparent. Always use `key_type`.\n  template <typename K, typename key_type>\n  using type = key_type;\n};\n\n// The node_handle concept from C++17.\n// We specialize node_handle for sets and maps. node_handle_base holds the\n// common API of both.\ntemplate <typename PolicyTraits, typename Alloc>\nclass node_handle_base {\n protected:\n  using slot_type = typename PolicyTraits::slot_type;\n\n public:\n  using allocator_type = Alloc;\n\n  constexpr node_handle_base() = default;\n  node_handle_base(node_handle_base&& other) noexcept {\n    *this = std::move(other);\n  }\n  ~node_handle_base() { destroy(); }\n  node_handle_base& operator=(node_handle_base&& other) noexcept {\n    destroy();\n    if (!other.empty()) {\n      alloc_ = other.alloc_;\n      PolicyTraits::transfer(alloc(), slot(), other.slot());\n      other.reset();\n    }\n    return *this;\n  }\n\n  bool empty() const noexcept { return !alloc_; }\n  explicit operator bool() const noexcept { return !empty(); }\n  allocator_type get_allocator() const { return *alloc_; }\n\n protected:\n  friend struct CommonAccess;\n\n  struct transfer_tag_t {};\n  node_handle_base(transfer_tag_t, const allocator_type& a, slot_type* s)\n      : alloc_(a) {\n    PolicyTraits::transfer(alloc(), slot(), s);\n  }\n\n  struct construct_tag_t {};\n  template <typename... Args>\n  node_handle_base(construct_tag_t, const allocator_type& a, Args&&... args)\n      : alloc_(a) {\n    PolicyTraits::construct(alloc(), slot(), std::forward<Args>(args)...);\n  }\n\n  void destroy() {\n    if (!empty()) {\n      PolicyTraits::destroy(alloc(), slot());\n      reset();\n    }\n  }\n\n  void reset() {\n    assert(alloc_.has_value());\n    alloc_ = absl::nullopt;\n  }\n\n  slot_type* slot() const {\n    assert(!empty());\n    return reinterpret_cast<slot_type*>(std::addressof(slot_space_));\n  }\n  allocator_type* alloc() { return std::addressof(*alloc_); }\n\n private:\n  absl::optional<allocator_type> alloc_ = {};\n  alignas(slot_type) mutable unsigned char slot_space_[sizeof(slot_type)] = {};\n};\n\n// For sets.\ntemplate <typename Policy, typename PolicyTraits, typename Alloc,\n          typename = void>\nclass node_handle : public node_handle_base<PolicyTraits, Alloc> {\n  using Base = node_handle_base<PolicyTraits, Alloc>;\n\n public:\n  using value_type = typename PolicyTraits::value_type;\n\n  constexpr node_handle() {}\n\n  value_type& value() const { return PolicyTraits::element(this->slot()); }\n\n private:\n  friend struct CommonAccess;\n\n  using Base::Base;\n};\n\n// For maps.\ntemplate <typename Policy, typename PolicyTraits, typename Alloc>\nclass node_handle<Policy, PolicyTraits, Alloc,\n                  absl::void_t<typename Policy::mapped_type>>\n    : public node_handle_base<PolicyTraits, Alloc> {\n  using Base = node_handle_base<PolicyTraits, Alloc>;\n  using slot_type = typename PolicyTraits::slot_type;\n\n public:\n  using key_type = typename Policy::key_type;\n  using mapped_type = typename Policy::mapped_type;\n\n  constexpr node_handle() {}\n\n  // When C++17 is available, we can use std::launder to provide mutable\n  // access to the key. Otherwise, we provide const access.\n  auto key() const\n      -> decltype(PolicyTraits::mutable_key(std::declval<slot_type*>())) {\n    return PolicyTraits::mutable_key(this->slot());\n  }\n\n  mapped_type& mapped() const {\n    return PolicyTraits::value(&PolicyTraits::element(this->slot()));\n  }\n\n private:\n  friend struct CommonAccess;\n\n  using Base::Base;\n};\n\n// Provide access to non-public node-handle functions.\nstruct CommonAccess {\n  template <typename Node>\n  static auto GetSlot(const Node& node) -> decltype(node.slot()) {\n    return node.slot();\n  }\n\n  template <typename Node>\n  static void Destroy(Node* node) {\n    node->destroy();\n  }\n\n  template <typename Node>\n  static void Reset(Node* node) {\n    node->reset();\n  }\n\n  template <typename T, typename... Args>\n  static T Transfer(Args&&... args) {\n    return T(typename T::transfer_tag_t{}, std::forward<Args>(args)...);\n  }\n\n  template <typename T, typename... Args>\n  static T Construct(Args&&... args) {\n    return T(typename T::construct_tag_t{}, std::forward<Args>(args)...);\n  }\n};\n\n// Implement the insert_return_type<> concept of C++17.\ntemplate <class Iterator, class NodeType>\nstruct InsertReturnType {\n  Iterator position;\n  bool inserted;\n  NodeType node;\n};\n\n}  // namespace container_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04943",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/common.h",
  "source_line": 24,
  "validation_status": "validated",
  "description": "C++ block with 182 lines of code implementing BLOCK-CPP-04943",
  "short_desc": "C++ block with 182 lines of code implementing BLOCK-CPP-04943",
  "input_types": "any",
  "output_type": "void",
  "keywords": [
    "api",
    "c++",
    "map"
  ],
  "use_cases": [
    "General c++ programming tasks"
  ],
  "related_blocks": [],
  "avg_execution_ms": 100.0,
  "max_memory_mb": 32,
  "performance_tier": "slow",
  "success_rate_percent": 100,
  "avg_tokens_saved": 50,
  "test_coverage_percent": 0,
  "security_audited": false,
  "stability": "stable"
}