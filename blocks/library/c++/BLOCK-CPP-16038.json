{
  "code": "#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstring>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16038_execute() {\n    {\nclass TargetInfo;\nclass IdentifierTable;\nclass LangOptions;\n\nenum LanguageID : uint16_t {\n  GNU_LANG = 0x1,            // builtin requires GNU mode.\n  C_LANG = 0x2,              // builtin for c only.\n  CXX_LANG = 0x4,            // builtin for cplusplus only.\n  OBJC_LANG = 0x8,           // builtin for objective-c and objective-c++\n  MS_LANG = 0x10,            // builtin requires MS mode.\n  OMP_LANG = 0x20,           // builtin requires OpenMP.\n  CUDA_LANG = 0x40,          // builtin requires CUDA.\n  COR_LANG = 0x80,           // builtin requires use of 'fcoroutine-ts' option.\n  OCL_GAS = 0x100,           // builtin requires OpenCL generic address space.\n  OCL_PIPE = 0x200,          // builtin requires OpenCL pipe.\n  OCL_DSE = 0x400,           // builtin requires OpenCL device side enqueue.\n  ALL_OCL_LANGUAGES = 0x800, // builtin for OCL languages.\n  HLSL_LANG = 0x1000,        // builtin requires HLSL.\n  ALL_LANGUAGES = C_LANG | CXX_LANG | OBJC_LANG, // builtin for all languages.\n  ALL_GNU_LANGUAGES = ALL_LANGUAGES | GNU_LANG,  // builtin requires GNU mode.\n  ALL_MS_LANGUAGES = ALL_LANGUAGES | MS_LANG     // builtin requires MS mode.\n};\n\nstruct HeaderDesc {\n  enum HeaderID : uint16_t {\n#define HEADER(ID, NAME) ID,\n#include \"clang/Basic/BuiltinHeaders.def\"\n#undef HEADER\n  } ID;\n\n  constexpr HeaderDesc(HeaderID ID) : ID(ID) {}\n\n  const char *getName() const;\n};\n\nnamespace Builtin {\nenum ID {\n  NotBuiltin  = 0,      // This is not a builtin function.\n#define BUILTIN(ID, TYPE, ATTRS) BI##ID,\n#include \"clang/Basic/Builtins.def\"\n  FirstTSBuiltin\n};\n\nstruct Info {\n  llvm::StringLiteral Name;\n  const char *Type, *Attributes;\n  const char *Features;\n  HeaderDesc Header;\n  LanguageID Langs;\n};\n\n/// Holds information about both target-independent and\n/// target-specific builtins, allowing easy queries by clients.\n///\n/// Builtins from an optional auxiliary target are stored in\n/// AuxTSRecords. Their IDs are shifted up by TSRecords.size() and need to\n/// be translated back with getAuxBuiltinID() before use.\nclass Context {\n  llvm::ArrayRef<Info> TSRecords;\n  llvm::ArrayRef<Info> AuxTSRecords;\n\npublic:\n  Context() = default;\n\n  /// Perform target-specific initialization\n  /// \\param AuxTarget Target info to incorporate builtins from. May be nullptr.\n  void InitializeTarget(const TargetInfo &Target, const TargetInfo *AuxTarget);\n\n  /// Mark the identifiers for all the builtins with their\n  /// appropriate builtin ID # and mark any non-portable builtin identifiers as\n  /// such.\n  void initializeBuiltins(IdentifierTable &Table, const LangOptions& LangOpts);\n\n  /// Return the identifier name for the specified builtin,\n  /// e.g. \"__builtin_abs\".\n  llvm::StringRef getName(unsigned ID) const { return getRecord(ID).Name; }\n\n  /// Get the type descriptor string for the specified builtin.\n  const char *getTypeString(unsigned ID) const {\n    return getRecord(ID).Type;\n  }\n\n  /// Return true if this function is a target-specific builtin.\n  bool isTSBuiltin(unsigned ID) const {\n    return ID >= Builtin::FirstTSBuiltin;\n  }\n\n  /// Return true if this function has no side effects.\n  bool isPure(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'U') != nullptr;\n  }\n\n  /// Return true if this function has no side effects and doesn't\n  /// read memory.\n  bool isConst(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'c') != nullptr;\n  }\n\n  /// Return true if we know this builtin never throws an exception.\n  bool isNoThrow(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'n') != nullptr;\n  }\n\n  /// Return true if we know this builtin never returns.\n  bool isNoReturn(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'r') != nullptr;\n  }\n\n  /// Return true if we know this builtin can return twice.\n  bool isReturnsTwice(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'j') != nullptr;\n  }\n\n  /// Returns true if this builtin does not perform the side-effects\n  /// of its arguments.\n  bool isUnevaluated(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'u') != nullptr;\n  }\n\n  /// Return true if this is a builtin for a libc/libm function,\n  /// with a \"__builtin_\" prefix (e.g. __builtin_abs).\n  bool isLibFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'F') != nullptr;\n  }\n\n  /// Determines whether this builtin is a predefined libc/libm\n  /// function, such as \"malloc\", where we know the signature a\n  /// priori.\n  /// In C, such functions behave as if they are predeclared,\n  /// possibly with a warning on first use. In Objective-C and C++,\n  /// they do not, but they are recognized as builtins once we see\n  /// a declaration.\n  bool isPredefinedLibFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'f') != nullptr;\n  }\n\n  /// Returns true if this builtin requires appropriate header in other\n  /// compilers. In Clang it will work even without including it, but we can emit\n  /// a warning about missing header.\n  bool isHeaderDependentFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'h') != nullptr;\n  }\n\n  /// Determines whether this builtin is a predefined compiler-rt/libgcc\n  /// function, such as \"__clear_cache\", where we know the signature a\n  /// priori.\n  bool isPredefinedRuntimeFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'i') != nullptr;\n  }\n\n  /// Determines whether this builtin is a C++ standard library function\n  /// that lives in (possibly-versioned) namespace std, possibly a template\n  /// specialization, where the signature is determined by the standard library\n  /// declaration.\n  bool isInStdNamespace(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'z') != nullptr;\n  }\n\n  /// Determines whether this builtin can have its address taken with no\n  /// special action required.\n  bool isDirectlyAddressable(unsigned ID) const {\n    // Most standard library functions can have their addresses taken. C++\n    // standard library functions formally cannot in C++20 onwards, and when\n    // we allow it, we need to ensure we instantiate a definition.\n    return isPredefinedLibFunction(ID) && !isInStdNamespace(ID);\n  }\n\n  /// Determines whether this builtin has custom typechecking.\n  bool hasCustomTypechecking(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 't') != nullptr;\n  }\n\n  /// Determines whether a declaration of this builtin should be recognized\n  /// even if the type doesn't match the specified signature.\n  bool allowTypeMismatch(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'T') != nullptr ||\n           hasCustomTypechecking(ID);\n  }\n\n  /// Determines whether this builtin has a result or any arguments which\n  /// are pointer types.\n  bool hasPtrArgsOrResult(unsigned ID) const {\n    return strchr(getRecord(ID).Type, '*') != nullptr;\n  }\n\n  /// Return true if this builtin has a result or any arguments which are\n  /// reference types.\n  bool hasReferenceArgsOrResult(unsigned ID) const {\n    return strchr(getRecord(ID).Type, '&') != nullptr ||\n           strchr(getRecord(ID).Type, 'A') != nullptr;\n  }\n\n  /// If this is a library function that comes from a specific\n  /// header, retrieve that header name.\n  const char *getHeaderName(unsigned ID) const {\n    return getRecord(ID).Header.getName();\n  }\n\n  /// Determine whether this builtin is like printf in its\n  /// formatting rules and, if so, set the index to the format string\n  /// argument and whether this function as a va_list argument.\n  bool isPrintfLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg);\n\n  /// Determine whether this builtin is like scanf in its\n  /// formatting rules and, if so, set the index to the format string\n  /// argument and whether this function as a va_list argument.\n  bool isScanfLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg);\n\n  /// Determine whether this builtin has callback behavior (see\n  /// llvm::AbstractCallSites for details). If so, add the index to the\n  /// callback callee argument and the callback payload arguments.\n  bool performsCallback(unsigned ID,\n                        llvm::SmallVectorImpl<int> &Encoding) const;\n\n  /// Return true if this function has no side effects and doesn't\n  /// read memory, except for possibly errno or raising FP exceptions.\n  ///\n  /// Such functions can be const when the MathErrno lang option and FP\n  /// exceptions are disabled.\n  bool isConstWithoutErrnoAndExceptions(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'e') != nullptr;\n  }\n\n  bool isConstWithoutExceptions(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'g') != nullptr;\n  }\n\n  const char *getRequiredFeatures(unsigned ID) const {\n    return getRecord(ID).Features;\n  }\n\n  unsigned getRequiredVectorWidth(unsigned ID) const;\n\n  /// Return true if builtin ID belongs to AuxTarget.\n  bool isAuxBuiltinID(unsigned ID) const {\n    return ID >= (Builtin::FirstTSBuiltin + TSRecords.size());\n  }\n\n  /// Return real builtin ID (i.e. ID it would have during compilation\n  /// for AuxTarget).\n  unsigned getAuxBuiltinID(unsigned ID) const { return ID - TSRecords.size(); }\n\n  /// Returns true if this is a libc/libm function without the '__builtin_'\n  /// prefix.\n  static bool isBuiltinFunc(llvm::StringRef Name);\n\n  /// Returns true if this is a builtin that can be redeclared.  Returns true\n  /// for non-builtins.\n  bool canBeRedeclared(unsigned ID) const;\n\n  /// Return true if this function can be constant evaluated by Clang frontend.\n  bool isConstantEvaluated(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'E') != nullptr;\n  }\n\nprivate:\n  const Info &getRecord(unsigned ID) const;\n\n  /// Helper function for isPrintfLike and isScanfLike.\n  bool isLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg,\n              const char *Fmt) const;\n};\n\n/// Returns true if the required target features of a builtin function are\n/// enabled.\n/// \\p TargetFeatureMap maps a target feature to true if it is enabled and\n///    false if it is disabled.\nbool evaluateRequiredTargetFeatures(\n    llvm::StringRef RequiredFatures,\n    const llvm::StringMap<bool> &TargetFetureMap);\n\n} // namespace Builtin\n\n/// Kinds of BuiltinTemplateDecl.\nenum BuiltinTemplateKind : int {\n  /// This names the __make_integer_seq BuiltinTemplateDecl.\n  BTK__make_integer_seq,\n\n  /// This names the __type_pack_element BuiltinTemplateDecl.\n  BTK__type_pack_element\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16038",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Builtins.h",
  "source_line": 27,
  "validation_status": "validated"
}