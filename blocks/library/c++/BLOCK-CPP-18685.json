{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/Token.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <vector>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-18685_execute() {\n    {\n  class MacroInfo;\n  class Preprocessor;\n  class SourceLocation;\n\n/// MacroArgs - An instance of this class captures information about\n/// the formal arguments specified to a function-like macro invocation.\nclass MacroArgs final\n    : private llvm::TrailingObjects<MacroArgs, Token> {\n\n  friend TrailingObjects;\n  /// NumUnexpArgTokens - The number of raw, unexpanded tokens for the\n  /// arguments.  All of the actual argument tokens are allocated immediately\n  /// after the MacroArgs object in memory.  This is all of the arguments\n  /// concatenated together, with 'EOF' markers at the end of each argument.\n  unsigned NumUnexpArgTokens;\n\n  /// VarargsElided - True if this is a C99 style varargs macro invocation and\n  /// there was no argument specified for the \"...\" argument.  If the argument\n  /// was specified (even empty) or this isn't a C99 style varargs function, or\n  /// if in strict mode and the C99 varargs macro had only a ... argument, this\n  /// is false.\n  bool VarargsElided;\n\n  /// PreExpArgTokens - Pre-expanded tokens for arguments that need them.  Empty\n  /// if not yet computed.  This includes the EOF marker at the end of the\n  /// stream.\n  std::vector<std::vector<Token> > PreExpArgTokens;\n\n  /// ArgCache - This is a linked list of MacroArgs objects that the\n  /// Preprocessor owns which we use to avoid thrashing malloc/free.\n  MacroArgs *ArgCache;\n\n  /// MacroArgs - The number of arguments the invoked macro expects.\n  unsigned NumMacroArgs;\n\n  MacroArgs(unsigned NumToks, bool varargsElided, unsigned MacroArgs)\n      : NumUnexpArgTokens(NumToks), VarargsElided(varargsElided),\n        ArgCache(nullptr), NumMacroArgs(MacroArgs) {}\n  ~MacroArgs() = default;\n\npublic:\n  /// MacroArgs ctor function - Create a new MacroArgs object with the specified\n  /// macro and argument info.\n  static MacroArgs *create(const MacroInfo *MI,\n                           ArrayRef<Token> UnexpArgTokens,\n                           bool VarargsElided, Preprocessor &PP);\n\n  /// destroy - Destroy and deallocate the memory for this object.\n  ///\n  void destroy(Preprocessor &PP);\n\n  /// ArgNeedsPreexpansion - If we can prove that the argument won't be affected\n  /// by pre-expansion, return false.  Otherwise, conservatively return true.\n  bool ArgNeedsPreexpansion(const Token *ArgTok, Preprocessor &PP) const;\n\n  /// getUnexpArgument - Return a pointer to the first token of the unexpanded\n  /// token list for the specified formal.\n  ///\n  const Token *getUnexpArgument(unsigned Arg) const;\n\n  /// getArgLength - Given a pointer to an expanded or unexpanded argument,\n  /// return the number of tokens, not counting the EOF, that make up the\n  /// argument.\n  static unsigned getArgLength(const Token *ArgPtr);\n\n  /// getPreExpArgument - Return the pre-expanded form of the specified\n  /// argument.\n  const std::vector<Token> &\n    getPreExpArgument(unsigned Arg, Preprocessor &PP);\n\n  /// getNumMacroArguments - Return the number of arguments the invoked macro\n  /// expects.\n  unsigned getNumMacroArguments() const { return NumMacroArgs; }\n\n  /// isVarargsElidedUse - Return true if this is a C99 style varargs macro\n  /// invocation and there was no argument specified for the \"...\" argument.  If\n  /// the argument was specified (even empty) or this isn't a C99 style varargs\n  /// function, or if in strict mode and the C99 varargs macro had only a ...\n  /// argument, this returns false.\n  bool isVarargsElidedUse() const { return VarargsElided; }\n\n  /// Returns true if the macro was defined with a variadic (ellipsis) parameter\n  /// AND was invoked with at least one token supplied as a variadic argument\n  /// (after pre-expansion).\n  ///\n  /// \\code\n  ///   #define F(a)  a\n  ///   #define V(a, ...) __VA_OPT__(a)\n  ///   F()     <-- returns false on this invocation.\n  ///   V(,a)   <-- returns true on this invocation.\n  ///   V(,)    <-- returns false on this invocation.\n  ///   V(,F()) <-- returns false on this invocation.\n  /// \\endcode\n  ///\n  bool invokedWithVariadicArgument(const MacroInfo *const MI, Preprocessor &PP);\n\n  /// StringifyArgument - Implement C99 6.10.3.2p2, converting a sequence of\n  /// tokens into the literal string token that should be produced by the C #\n  /// preprocessor operator.  If Charify is true, then it should be turned into\n  /// a character literal for the Microsoft charize (#@) extension.\n  ///\n  static Token StringifyArgument(const Token *ArgToks,\n                                 Preprocessor &PP, bool Charify,\n                                 SourceLocation ExpansionLocStart,\n                                 SourceLocation ExpansionLocEnd);\n\n\n  /// deallocate - This should only be called by the Preprocessor when managing\n  /// its freelist.\n  MacroArgs *deallocate();\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-18685",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/MacroArgs.h",
  "source_line": 22,
  "validation_status": "validated"
}