{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\n\nnamespace {\n// Keeps track of whether Logging initialization is finalized.\n// Log messages generated before that will go to stderr.\nABSL_CONST_INIT std::atomic<bool> logging_initialized(false);\n\n// The TimeZone used for logging. This may only be set once.\nABSL_CONST_INIT std::atomic<absl::TimeZone*> timezone_ptr{nullptr};\n\n// If true, the logging library will symbolize stack in fatal messages\nABSL_CONST_INIT std::atomic<bool> symbolize_stack_trace(true);\n\n// Specifies maximum number of stack frames to report in fatal messages.\nABSL_CONST_INIT std::atomic<int> max_frames_in_stack_trace(64);\n\nABSL_CONST_INIT std::atomic<bool> exit_on_dfatal(true);\nABSL_CONST_INIT std::atomic<bool> suppress_sigabort_trace(false);\n}  // namespace\n\nbool IsInitialized() {\n  return logging_initialized.load(std::memory_order_acquire);\n}\n\nvoid SetInitialized() {\n  logging_initialized.store(true, std::memory_order_release);\n}\n\nvoid WriteToStderr(absl::string_view message, absl::LogSeverity severity) {\n  if (message.empty()) return;\n#if defined(__EMSCRIPTEN__)\n  // In WebAssembly, bypass filesystem emulation via fwrite.\n  // Skip a trailing newline character as emscripten_errn adds one itself.\n  const auto message_minus_newline = absl::StripSuffix(message, \"\\n\");\n  // emscripten_errn was introduced in 3.1.41 but broken in standalone mode\n  // until 3.1.43.\n#if ABSL_INTERNAL_EMSCRIPTEN_VERSION >= 3001043\n  emscripten_errn(message_minus_newline.data(), message_minus_newline.size());\n#else\n  std::string null_terminated_message(message_minus_newline);\n  _emscripten_err(null_terminated_message.c_str());\n#endif\n#else\n  // Avoid using std::cerr from this module since we may get called during\n  // exit code, and cerr may be partially or fully destroyed by then.\n  std::fwrite(message.data(), message.size(), 1, stderr);\n#endif\n\n#if defined(_WIN64) || defined(_WIN32) || defined(_WIN16)\n  // C99 requires stderr to not be fully-buffered by default (7.19.3.7), but\n  // MS CRT buffers it anyway, so we must `fflush` to ensure the string hits\n  // the console/file before the program dies (and takes the libc buffers\n  // with it).\n  // https://docs.microsoft.com/en-us/cpp/c-runtime-library/stream-i-o\n  if (severity >= absl::LogSeverity::kWarning) {\n    std::fflush(stderr);\n  }\n#else\n  // Avoid unused parameter warning in this branch.\n  (void)severity;\n#endif\n}\n\nvoid SetTimeZone(absl::TimeZone tz) {\n  absl::TimeZone* expected = nullptr;\n  absl::TimeZone* new_tz = new absl::TimeZone(tz);\n  // timezone_ptr can only be set once, otherwise new_tz is leaked.\n  if (!timezone_ptr.compare_exchange_strong(expected, new_tz,\n                                            std::memory_order_release,\n                                            std::memory_order_relaxed)) {\n    ABSL_RAW_LOG(FATAL,\n                 \"absl::log_internal::SetTimeZone() has already been called\");\n  }\n}\n\nconst absl::TimeZone* TimeZone() {\n  return timezone_ptr.load(std::memory_order_acquire);\n}\n\nbool ShouldSymbolizeLogStackTrace() {\n  return symbolize_stack_trace.load(std::memory_order_acquire);\n}\n\nvoid EnableSymbolizeLogStackTrace(bool on_off) {\n  symbolize_stack_trace.store(on_off, std::memory_order_release);\n}\n\nint MaxFramesInLogStackTrace() {\n  return max_frames_in_stack_trace.load(std::memory_order_acquire);\n}\n\nvoid SetMaxFramesInLogStackTrace(int max_num_frames) {\n  max_frames_in_stack_trace.store(max_num_frames, std::memory_order_release);\n}\n\nbool ExitOnDFatal() { return exit_on_dfatal.load(std::memory_order_acquire); }\n\nvoid SetExitOnDFatal(bool on_off) {\n  exit_on_dfatal.store(on_off, std::memory_order_release);\n}\n\nbool SuppressSigabortTrace() {\n  return suppress_sigabort_trace.load(std::memory_order_acquire);\n}\n\nbool SetSuppressSigabortTrace(bool on_off) {\n  return suppress_sigabort_trace.exchange(on_off);\n}\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02712",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/globals.cc",
  "source_line": 32,
  "validation_status": "validated"
}