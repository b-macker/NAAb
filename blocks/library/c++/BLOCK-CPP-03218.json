{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n#include <time.h>\n#include <cctype>\n#include <chrono>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <ctime>\n#include <limits>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <sstream>\n#include \"absl/time/internal/cctz/include/cctz/civil_time.h\"\n#include \"time_zone_if.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz;\nusing namespace detail;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03218_execute() {\n    {\n  // The unparsed input.\n  const char* data = input.c_str();  // NUL terminated\n\n  // Skips leading whitespace.\n  while (std::isspace(*data)) ++data;\n\n  const year_t kyearmax = std::numeric_limits<year_t>::max();\n  const year_t kyearmin = std::numeric_limits<year_t>::min();\n\n  // Sets default values for unspecified fields.\n  bool saw_year = false;\n  year_t year = 1970;\n  std::tm tm{};\n  tm.tm_year = 1970 - 1900;\n  tm.tm_mon = 1 - 1;  // Jan\n  tm.tm_mday = 1;\n  tm.tm_hour = 0;\n  tm.tm_min = 0;\n  tm.tm_sec = 0;\n  tm.tm_wday = 4;  // Thu\n  tm.tm_yday = 0;\n  tm.tm_isdst = 0;\n  auto subseconds = detail::femtoseconds::zero();\n  bool saw_offset = false;\n  int offset = 0;  // No offset from passed tz.\n  std::string zone = \"UTC\";\n\n  const char* fmt = format.c_str();  // NUL terminated\n  bool twelve_hour = false;\n  bool afternoon = false;\n  int week_num = -1;\n  weekday week_start = weekday::sunday;\n\n  bool saw_percent_s = false;\n  std::int_fast64_t percent_s = 0;\n\n  // Steps through format, one specifier at a time.\n  while (data != nullptr && *fmt != '\\0') {\n    if (std::isspace(*fmt)) {\n      while (std::isspace(*data)) ++data;\n      while (std::isspace(*++fmt)) continue;\n      continue;\n    }\n\n    if (*fmt != '%') {\n      if (*data == *fmt) {\n        ++data;\n        ++fmt;\n      } else {\n        data = nullptr;\n      }\n      continue;\n    }\n\n    const char* percent = fmt;\n    if (*++fmt == '\\0') {\n      data = nullptr;\n      continue;\n    }\n    switch (*fmt++) {\n      case 'Y':\n        // Symmetrically with FormatTime(), directly handing %Y avoids the\n        // tm.tm_year overflow problem.  However, tm.tm_year will still be\n        // used by other specifiers like %D.\n        data = ParseInt(data, 0, kyearmin, kyearmax, &year);\n        if (data != nullptr) saw_year = true;\n        continue;\n      case 'm':\n        data = ParseInt(data, 2, 1, 12, &tm.tm_mon);\n        if (data != nullptr) tm.tm_mon -= 1;\n        week_num = -1;\n        continue;\n      case 'd':\n      case 'e':\n        data = ParseInt(data, 2, 1, 31, &tm.tm_mday);\n        week_num = -1;\n        continue;\n      case 'U':\n        data = ParseInt(data, 0, 0, 53, &week_num);\n        week_start = weekday::sunday;\n        continue;\n      case 'W':\n        data = ParseInt(data, 0, 0, 53, &week_num);\n        week_start = weekday::monday;\n        continue;\n      case 'u':\n        data = ParseInt(data, 0, 1, 7, &tm.tm_wday);\n        if (data != nullptr) tm.tm_wday %= 7;\n        continue;\n      case 'w':\n        data = ParseInt(data, 0, 0, 6, &tm.tm_wday);\n        continue;\n      case 'H':\n        data = ParseInt(data, 2, 0, 23, &tm.tm_hour);\n        twelve_hour = false;\n        continue;\n      case 'M':\n        data = ParseInt(data, 2, 0, 59, &tm.tm_min);\n        continue;\n      case 'S':\n        data = ParseInt(data, 2, 0, 60, &tm.tm_sec);\n        continue;\n      case 'I':\n      case 'l':\n      case 'r':  // probably uses %I\n        twelve_hour = true;\n        break;\n      case 'R':  // uses %H\n      case 'T':  // uses %H\n      case 'c':  // probably uses %H\n      case 'X':  // probably uses %H\n        twelve_hour = false;\n        break;\n      case 'z':\n        data = ParseOffset(data, \"\", &offset);\n        if (data != nullptr) saw_offset = true;\n        continue;\n      case 'Z':  // ignored; zone abbreviations are ambiguous\n        data = ParseZone(data, &zone);\n        continue;\n      case 's':\n        data =\n            ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),\n                     std::numeric_limits<std::int_fast64_t>::max(), &percent_s);\n        if (data != nullptr) saw_percent_s = true;\n        continue;\n      case ':':\n        if (fmt[0] == 'z' ||\n            (fmt[0] == ':' &&\n             (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {\n          data = ParseOffset(data, \":\", &offset);\n          if (data != nullptr) saw_offset = true;\n          fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;\n          continue;\n        }\n        break;\n      case '%':\n        data = (*data == '%' ? data + 1 : nullptr);\n        continue;\n      case 'E':\n        if (fmt[0] == 'T') {\n          if (*data == 'T' || *data == 't') {\n            ++data;\n            ++fmt;\n          } else {\n            data = nullptr;\n          }\n          continue;\n        }\n        if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {\n          data = ParseOffset(data, \":\", &offset);\n          if (data != nullptr) saw_offset = true;\n          fmt += (fmt[0] == 'z') ? 1 : 2;\n          continue;\n        }\n        if (fmt[0] == '*' && fmt[1] == 'S') {\n          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);\n          if (data != nullptr && *data == '.') {\n            data = ParseSubSeconds(data + 1, &subseconds);\n          }\n          fmt += 2;\n          continue;\n        }\n        if (fmt[0] == '*' && fmt[1] == 'f') {\n          if (data != nullptr && std::isdigit(*data)) {\n            data = ParseSubSeconds(data, &subseconds);\n          }\n          fmt += 2;\n          continue;\n        }\n        if (fmt[0] == '4' && fmt[1] == 'Y') {\n          const char* bp = data;\n          data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);\n          if (data != nullptr) {\n            if (data - bp == 4) {\n              saw_year = true;\n            } else {\n              data = nullptr;  // stopped too soon\n            }\n          }\n          fmt += 2;\n          continue;\n        }\n        if (std::isdigit(*fmt)) {\n          int n = 0;  // value ignored\n          if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {\n            if (*np == 'S') {\n              data = ParseInt(data, 2, 0, 60, &tm.tm_sec);\n              if (data != nullptr && *data == '.') {\n                data = ParseSubSeconds(data + 1, &subseconds);\n              }\n              fmt = ++np;\n              continue;\n            }\n            if (*np == 'f') {\n              if (data != nullptr && std::isdigit(*data)) {\n                data = ParseSubSeconds(data, &subseconds);\n              }\n              fmt = ++np;\n              continue;\n            }\n          }\n        }\n        if (*fmt == 'c') twelve_hour = false;  // probably uses %H\n        if (*fmt == 'X') twelve_hour = false;  // probably uses %H\n        if (*fmt != '\\0') ++fmt;\n        break;\n      case 'O':\n        if (*fmt == 'H') twelve_hour = false;\n        if (*fmt == 'I') twelve_hour = true;\n        if (*fmt != '\\0') ++fmt;\n        break;\n    }\n\n    // Parses the current specifier.\n    const char* orig_data = data;\n    std::string spec(percent, static_cast<std::size_t>(fmt - percent));\n    data = ParseTM(data, spec.c_str(), &tm);\n\n    // If we successfully parsed %p we need to remember whether the result\n    // was AM or PM so that we can adjust tm_hour before time_zone::lookup().\n    // So reparse the input with a known AM hour, and check if it is shifted\n    // to a PM hour.\n    if (spec == \"%p\" && data != nullptr) {\n      std::string test_input = \"1\";\n      test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));\n      const char* test_data = test_input.c_str();\n      std::tm tmp{};\n      ParseTM(test_data, \"%I%p\", &tmp);\n      afternoon = (tmp.tm_hour == 13);\n    }\n  }\n\n  // Adjust a 12-hour tm_hour value if it should be in the afternoon.\n  if (twelve_hour && afternoon && tm.tm_hour < 12) {\n    tm.tm_hour += 12;\n  }\n\n  if (data == nullptr) {\n    if (err != nullptr) *err = \"Failed to parse input\";\n    return false;\n  }\n\n  // Skip any remaining whitespace.\n  while (std::isspace(*data)) ++data;\n\n  // parse() must consume the entire input string.\n  if (*data != '\\0') {\n    if (err != nullptr) *err = \"Illegal trailing data in input string\";\n    return false;\n  }\n\n  // If we saw %s then we ignore anything else and return that time.\n  if (saw_percent_s) {\n    *sec = FromUnixSeconds(percent_s);\n    *fs = detail::femtoseconds::zero();\n    return true;\n  }\n\n  // If we saw %z, %Ez, or %E*z then we want to interpret the parsed fields\n  // in UTC and then shift by that offset.  Otherwise we want to interpret\n  // the fields directly in the passed time_zone.\n  time_zone ptz = saw_offset ? utc_time_zone() : tz;\n\n  // Allows a leap second of 60 to normalize forward to the following \":00\".\n  if (tm.tm_sec == 60) {\n    tm.tm_sec -= 1;\n    offset -= 1;\n    subseconds = detail::femtoseconds::zero();\n  }\n\n  if (!saw_year) {\n    year = year_t{tm.tm_year};\n    if (year > kyearmax - 1900) {\n      // Platform-dependent, maybe unreachable.\n      if (err != nullptr) *err = \"Out-of-range year\";\n      return false;\n    }\n    year += 1900;\n  }\n\n  // Compute year, tm.tm_mon and tm.tm_mday if we parsed a week number.\n  if (week_num != -1) {\n    if (!FromWeek(week_num, week_start, &year, &tm)) {\n      if (err != nullptr) *err = \"Out-of-range field\";\n      return false;\n    }\n  }\n\n  const int month = tm.tm_mon + 1;\n  civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n\n  // parse() should not allow normalization. Due to the restricted field\n  // ranges above (see ParseInt()), the only possibility is for days to roll\n  // into months. That is, parsing \"Sep 31\" should not produce \"Oct 1\".\n  if (cs.month() != month || cs.day() != tm.tm_mday) {\n    if (err != nullptr) *err = \"Out-of-range field\";\n    return false;\n  }\n\n  // Accounts for the offset adjustment before converting to absolute time.\n  if ((offset < 0 && cs > civil_second::max() + offset) ||\n      (offset > 0 && cs < civil_second::min() + offset)) {\n    if (err != nullptr) *err = \"Out-of-range field\";\n    return false;\n  }\n  cs -= offset;\n\n  const auto tp = ptz.lookup(cs).pre;\n  // Checks for overflow/underflow and returns an error as necessary.\n  if (tp == time_point<seconds>::max()) {\n    const auto al = ptz.lookup(time_point<seconds>::max());\n    if (cs > al.cs) {\n      if (err != nullptr) *err = \"Out-of-range field\";\n      return false;\n    }\n  }\n  if (tp == time_point<seconds>::min()) {\n    const auto al = ptz.lookup(time_point<seconds>::min());\n    if (cs < al.cs) {\n      if (err != nullptr) *err = \"Out-of-range field\";\n      return false;\n    }\n  }\n\n  *sec = tp;\n  *fs = subseconds;\n  return true;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03218",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_format.cc",
  "source_line": 692,
  "validation_status": "validated"
}