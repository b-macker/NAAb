{
  "code": "#include \"absl/debugging/internal/demangle.h\"\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <limits>\n#include <string>\n#include \"absl/base/config.h\"\n#include <cxxabi.h>\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02571_execute() {\n    {\n  ComplexityGuard guard(state);\n  if (guard.IsTooComplex()) return false;\n  ParseState copy = state->parse_state;\n  if (ParseOneCharToken(state, 'J') && ZeroOrMore(ParseTemplateArg, state) &&\n      ParseOneCharToken(state, 'E')) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  // There can be significant overlap between the following leading to\n  // exponential backtracking:\n  //\n  //   <expr-primary> ::= L <type> <expr-cast-value> E\n  //                 e.g. L 2xxIvE 1                 E\n  //   <type>         ==> <local-source-name> <template-args>\n  //                 e.g. L 2xx               IvE\n  //\n  // This means parsing an entire <type> twice, and <type> can contain\n  // <template-arg>, so this can generate exponential backtracking.  There is\n  // only overlap when the remaining input starts with \"L <source-name>\", so\n  // parse all cases that can start this way jointly to share the common prefix.\n  //\n  // We have:\n  //\n  //   <template-arg> ::= <type>\n  //                  ::= <expr-primary>\n  //\n  // First, drop all the productions of <type> that must start with something\n  // other than 'L'.  All that's left is <class-enum-type>; inline it.\n  //\n  //   <type> ::= <nested-name> # starts with 'N'\n  //          ::= <unscoped-name>\n  //          ::= <unscoped-template-name> <template-args>\n  //          ::= <local-name> # starts with 'Z'\n  //\n  // Drop and inline again:\n  //\n  //   <type> ::= <unscoped-name>\n  //          ::= <unscoped-name> <template-args>\n  //          ::= <substitution> <template-args> # starts with 'S'\n  //\n  // Merge the first two, inline <unscoped-name>, drop last:\n  //\n  //   <type> ::= <unqualified-name> [<template-args>]\n  //          ::= St <unqualified-name> [<template-args>] # starts with 'S'\n  //\n  // Drop and inline:\n  //\n  //   <type> ::= <operator-name> [<template-args>] # starts with lowercase\n  //          ::= <ctor-dtor-name> [<template-args>] # starts with 'C' or 'D'\n  //          ::= <source-name> [<template-args>] # starts with digit\n  //          ::= <local-source-name> [<template-args>]\n  //          ::= <unnamed-type-name> [<template-args>] # starts with 'U'\n  //\n  // One more time:\n  //\n  //   <type> ::= L <source-name> [<template-args>]\n  //\n  // Likewise with <expr-primary>:\n  //\n  //   <expr-primary> ::= L <type> <expr-cast-value> E\n  //                  ::= LZ <encoding> E # cannot overlap; drop\n  //                  ::= L <mangled_name> E # cannot overlap; drop\n  //\n  // By similar reasoning as shown above, the only <type>s starting with\n  // <source-name> are \"<source-name> [<template-args>]\".  Inline this.\n  //\n  //   <expr-primary> ::= L <source-name> [<template-args>] <expr-cast-value> E\n  //\n  // Now inline both of these into <template-arg>:\n  //\n  //   <template-arg> ::= L <source-name> [<template-args>]\n  //                  ::= L <source-name> [<template-args>] <expr-cast-value> E\n  //\n  // Merge them and we're done:\n  //   <template-arg>\n  //     ::= L <source-name> [<template-args>] [<expr-cast-value> E]\n  if (ParseLocalSourceName(state) && Optional(ParseTemplateArgs(state))) {\n    copy = state->parse_state;\n    if (ParseExprCastValue(state) && ParseOneCharToken(state, 'E')) {\n      return true;\n    }\n    state->parse_state = copy;\n    return true;\n  }\n\n  // Now that the overlapping cases can't reach this code, we can safely call\n  // both of these.\n  if (ParseType(state) || ParseExprPrimary(state)) {\n    return true;\n  }\n  state->parse_state = copy;\n\n  if (ParseOneCharToken(state, 'X') && ParseExpression(state) &&\n      ParseOneCharToken(state, 'E')) {\n    return true;\n  }\n  state->parse_state = copy;\n  return false;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02571",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/demangle.cc",
  "source_line": 1464,
  "validation_status": "validated"
}