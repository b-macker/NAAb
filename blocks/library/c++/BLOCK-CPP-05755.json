{
  "code": "#include <cstdlib>\n#include <unistd.h>\n#include <ios>\n#include <ostream>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/log_severity.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace absl;\nusing namespace log_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05755_execute() {\n    {\n\n// A `NullStream` implements the API of `LogMessage` (a few methods and\n// `operator<<`) but does nothing.  All methods are defined inline so the\n// compiler can eliminate the whole instance and discard anything that's\n// streamed in.\nclass NullStream {\n public:\n  NullStream& AtLocation(absl::string_view, int) { return *this; }\n  template <typename SourceLocationType>\n  NullStream& AtLocation(SourceLocationType) {\n    return *this;\n  }\n  NullStream& NoPrefix() { return *this; }\n  NullStream& WithVerbosity(int) { return *this; }\n  template <typename TimeType>\n  NullStream& WithTimestamp(TimeType) {\n    return *this;\n  }\n  template <typename Tid>\n  NullStream& WithThreadID(Tid) {\n    return *this;\n  }\n  template <typename LogEntryType>\n  NullStream& WithMetadataFrom(const LogEntryType&) {\n    return *this;\n  }\n  NullStream& WithPerror() { return *this; }\n  template <typename LogSinkType>\n  NullStream& ToSinkAlso(LogSinkType*) {\n    return *this;\n  }\n  template <typename LogSinkType>\n  NullStream& ToSinkOnly(LogSinkType*) {\n    return *this;\n  }\n  template <typename LogSinkType>\n  NullStream& OutputToSink(LogSinkType*, bool) {\n    return *this;\n  }\n  NullStream& InternalStream() { return *this; }\n};\ntemplate <typename T>\ninline NullStream& operator<<(NullStream& str, const T&) {\n  return str;\n}\ninline NullStream& operator<<(NullStream& str,\n                              std::ostream& (*)(std::ostream& os)) {\n  return str;\n}\ninline NullStream& operator<<(NullStream& str,\n                              std::ios_base& (*)(std::ios_base& os)) {\n  return str;\n}\n\n// `NullStreamMaybeFatal` implements the process termination semantics of\n// `LogMessage`, which is used for `DFATAL` severity and expression-defined\n// severity e.g. `LOG(LEVEL(HowBadIsIt()))`.  Like `LogMessage`, it terminates\n// the process when destroyed if the passed-in severity equals `FATAL`.\nclass NullStreamMaybeFatal final : public NullStream {\n public:\n  explicit NullStreamMaybeFatal(absl::LogSeverity severity)\n      : fatal_(severity == absl::LogSeverity::kFatal) {}\n  ~NullStreamMaybeFatal() {\n    if (fatal_) {\n      _exit(1);\n    }\n  }\n\n private:\n  bool fatal_;\n};\n\n// `NullStreamFatal` implements the process termination semantics of\n// `LogMessageFatal`, which means it always terminates the process.  `DFATAL`\n// and expression-defined severity use `NullStreamMaybeFatal` above.\nclass NullStreamFatal final : public NullStream {\n public:\n  NullStreamFatal() = default;\n  // ABSL_ATTRIBUTE_NORETURN doesn't seem to work on destructors with msvc, so\n  // disable msvc's warning about the d'tor never returning.\n#if defined(_MSC_VER) && !defined(__clang__)\n#pragma warning(push)\n#pragma warning(disable : 4722)\n#endif\n  ABSL_ATTRIBUTE_NORETURN ~NullStreamFatal() { _exit(1); }\n#if defined(_MSC_VER) && !defined(__clang__)\n#pragma warning(pop)\n#endif\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05755",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/nullstream.h",
  "source_line": 41,
  "validation_status": "validated"
}