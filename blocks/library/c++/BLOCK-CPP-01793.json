{
  "code": "#include \"absl/numeric/int128.h\"\n#include <stddef.h>\n#include <cassert>\n#include <iomanip>\n#include <ostream>  // NOLINT(readability/streams)\n#include <sstream>\n#include <string>\n#include <type_traits>\n#include \"absl/base/optimization.h\"\n#include \"absl/numeric/bits.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01793_execute() {\n    {\n  // Go 50 bits at a time, that fits in a double\n  static_assert(std::numeric_limits<double>::digits >= 50, \"\");\n  static_assert(std::numeric_limits<long double>::digits <= 150, \"\");\n  // Undefined behavior if v is not finite or cannot fit into uint128.\n  assert(std::isfinite(v) && v > -1 && v < std::ldexp(1.0L, 128));\n\n  v = std::ldexp(v, -100);\n  uint64_t w0 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  v = std::ldexp(v - static_cast<double>(w0), 50);\n  uint64_t w1 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  v = std::ldexp(v - static_cast<double>(w1), 50);\n  uint64_t w2 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  return (static_cast<uint128>(w0) << 100) | (static_cast<uint128>(w1) << 50) |\n         static_cast<uint128>(w2);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01793",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.cc",
  "source_line": 118,
  "validation_status": "validated"
}