{
  "code": "{\npublic:\n  enum Kind : uint8_t {\n    /// Direct - Pass the argument directly using the normal converted LLVM\n    /// type, or by coercing to another specified type stored in\n    /// 'CoerceToType').  If an offset is specified (in UIntData), then the\n    /// argument passed is offset by some number of bytes in the memory\n    /// representation. A dummy argument is emitted before the real argument\n    /// if the specified type stored in \"PaddingType\" is not zero.\n    Direct,\n\n    /// Extend - Valid only for integer argument types. Same as 'direct'\n    /// but also emit a zero/sign extension attribute.\n    Extend,\n\n    /// Indirect - Pass the argument indirectly via a hidden pointer with the\n    /// specified alignment (0 indicates default alignment) and address space.\n    Indirect,\n\n    /// IndirectAliased - Similar to Indirect, but the pointer may be to an\n    /// object that is otherwise referenced.  The object is known to not be\n    /// modified through any other references for the duration of the call, and\n    /// the callee must not itself modify the object.  Because C allows\n    /// parameter variables to be modified and guarantees that they have unique\n    /// addresses, the callee must defensively copy the object into a local\n    /// variable if it might be modified or its address might be compared.\n    /// Since those are uncommon, in principle this convention allows programs\n    /// to avoid copies in more situations.  However, it may introduce *extra*\n    /// copies if the callee fails to prove that a copy is unnecessary and the\n    /// caller naturally produces an unaliased object for the argument.\n    IndirectAliased,\n\n    /// Ignore - Ignore the argument (treat as void). Useful for void and\n    /// empty structs.\n    Ignore,\n\n    /// Expand - Only valid for aggregate argument types. The structure should\n    /// be expanded into consecutive arguments for its constituent fields.\n    /// Currently expand is only allowed on structures whose fields\n    /// are all scalar types or are themselves expandable types.\n    Expand,\n\n    /// CoerceAndExpand - Only valid for aggregate argument types. The\n    /// structure should be expanded into consecutive arguments corresponding\n    /// to the non-array elements of the type stored in CoerceToType.\n    /// Array elements in the type are assumed to be padding and skipped.\n    CoerceAndExpand,\n\n    /// InAlloca - Pass the argument directly using the LLVM inalloca attribute.\n    /// This is similar to indirect with byval, except it only applies to\n    /// arguments stored in memory and forbids any implicit copies.  When\n    /// applied to a return type, it means the value is returned indirectly via\n    /// an implicit sret parameter stored in the argument struct.\n    InAlloca,\n    KindFirst = Direct,\n    KindLast = InAlloca\n  };\n\nprivate:\n  llvm::Type *TypeData; // canHaveCoerceToType()\n  union {\n    llvm::Type *PaddingType; // canHavePaddingType()\n    llvm::Type *UnpaddedCoerceAndExpandType; // isCoerceAndExpand()\n  };\n  struct DirectAttrInfo {\n    unsigned Offset;\n    unsigned Align;\n  };\n  struct IndirectAttrInfo {\n    unsigned Align;\n    unsigned AddrSpace;\n  };\n  union {\n    DirectAttrInfo DirectAttr;     // isDirect() || isExtend()\n    IndirectAttrInfo IndirectAttr; // isIndirect()\n    unsigned AllocaFieldIndex; // isInAlloca()\n  };\n  Kind TheKind;\n  bool PaddingInReg : 1;\n  bool InAllocaSRet : 1;    // isInAlloca()\n  bool InAllocaIndirect : 1;// isInAlloca()\n  bool IndirectByVal : 1;   // isIndirect()\n  bool IndirectRealign : 1; // isIndirect()\n  bool SRetAfterThis : 1;   // isIndirect()\n  bool InReg : 1;           // isDirect() || isExtend() || isIndirect()\n  bool CanBeFlattened: 1;   // isDirect()\n  bool SignExt : 1;         // isExtend()\n\n  bool canHavePaddingType() const {\n    return isDirect() || isExtend() || isIndirect() || isIndirectAliased() ||\n           isExpand();\n  }\n  void setPaddingType(llvm::Type *T) {\n    assert(canHavePaddingType());\n    PaddingType = T;\n  }\n\n  void setUnpaddedCoerceToType(llvm::Type *T) {\n    assert(isCoerceAndExpand());\n    UnpaddedCoerceAndExpandType = T;\n  }\n\npublic:\n  ABIArgInfo(Kind K = Direct)\n      : TypeData(nullptr), PaddingType(nullptr), DirectAttr{0, 0}, TheKind(K),\n        PaddingInReg(false), InAllocaSRet(false),\n        InAllocaIndirect(false), IndirectByVal(false), IndirectRealign(false),\n        SRetAfterThis(false), InReg(false), CanBeFlattened(false),\n        SignExt(false) {}\n\n  static ABIArgInfo getDirect(llvm::Type *T = nullptr, unsigned Offset = 0,\n                              llvm::Type *Padding = nullptr,\n                              bool CanBeFlattened = true, unsigned Align = 0) {\n    auto AI = ABIArgInfo(Direct);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(Padding);\n    AI.setDirectOffset(Offset);\n    AI.setDirectAlign(Align);\n    AI.setCanBeFlattened(CanBeFlattened);\n    return AI;\n  }\n  static ABIArgInfo getDirectInReg(llvm::Type *T = nullptr) {\n    auto AI = getDirect(T);\n    AI.setInReg(true);\n    return AI;\n  }\n\n  static ABIArgInfo getSignExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    auto AI = ABIArgInfo(Extend);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(nullptr);\n    AI.setDirectOffset(0);\n    AI.setDirectAlign(0);\n    AI.setSignExt(true);\n    return AI;\n  }\n\n  static ABIArgInfo getZeroExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    auto AI = ABIArgInfo(Extend);\n    AI.setCoerceToType(T);\n    AI.setPaddingType(nullptr);\n    AI.setDirectOffset(0);\n    AI.setDirectAlign(0);\n    AI.setSignExt(false);\n    return AI;\n  }\n\n  // ABIArgInfo will record the argument as being extended based on the sign\n  // of its type.\n  static ABIArgInfo getExtend(QualType Ty, llvm::Type *T = nullptr) {\n    assert(Ty->isIntegralOrEnumerationType() && \"Unexpected QualType\");\n    if (Ty->hasSignedIntegerRepresentation())\n      return getSignExtend(Ty, T);\n    return getZeroExtend(Ty, T);\n  }\n\n  static ABIArgInfo getExtendInReg(QualType Ty, llvm::Type *T = nullptr) {\n    auto AI = getExtend(Ty, T);\n    AI.setInReg(true);\n    return AI;\n  }\n  static ABIArgInfo getIgnore() {\n    return ABIArgInfo(Ignore);\n  }\n  static ABIArgInfo getIndirect(CharUnits Alignment, bool ByVal = true,\n                                bool Realign = false,\n                                llvm::Type *Padding = nullptr) {\n    auto AI = ABIArgInfo(Indirect);\n    AI.setIndirectAlign(Alignment);\n    AI.setIndirectByVal(ByVal);\n    AI.setIndirectRealign(Realign);\n    AI.setSRetAfterThis(false);\n    AI.setPaddingType(Padding);\n    return AI;\n  }\n\n  /// Pass this in memory using the IR byref attribute.\n  static ABIArgInfo getIndirectAliased(CharUnits Alignment, unsigned AddrSpace,\n                                       bool Realign = false,\n                                       llvm::Type *Padding = nullptr) {\n    auto AI = ABIArgInfo(IndirectAliased);\n    AI.setIndirectAlign(Alignment);\n    AI.setIndirectRealign(Realign);\n    AI.setPaddingType(Padding);\n    AI.setIndirectAddrSpace(AddrSpace);\n    return AI;\n  }\n\n  static ABIArgInfo getIndirectInReg(CharUnits Alignment, bool ByVal = true,\n                                     bool Realign = false) {\n    auto AI = getIndirect(Alignment, ByVal, Realign);\n    AI.setInReg(true);\n    return AI;\n  }\n  static ABIArgInfo getInAlloca(unsigned FieldIndex, bool Indirect = false) {\n    auto AI = ABIArgInfo(InAlloca);\n    AI.setInAllocaFieldIndex(FieldIndex);\n    AI.setInAllocaIndirect(Indirect);\n    return AI;\n  }\n  static ABIArgInfo getExpand() {\n    auto AI = ABIArgInfo(Expand);\n    AI.setPaddingType(nullptr);\n    return AI;\n  }\n  static ABIArgInfo getExpandWithPadding(bool PaddingInReg,\n                                         llvm::Type *Padding) {\n    auto AI = getExpand();\n    AI.setPaddingInReg(PaddingInReg);\n    AI.setPaddingType(Padding);\n    return AI;\n  }\n\n  /// \\param unpaddedCoerceToType The coerce-to type with padding elements\n  ///   removed, canonicalized to a single element if it would otherwise\n  ///   have exactly one element.\n  static ABIArgInfo getCoerceAndExpand(llvm::StructType *coerceToType,\n                                       llvm::Type *unpaddedCoerceToType) {\n#ifndef NDEBUG\n    // Check that unpaddedCoerceToType has roughly the right shape.\n\n    // Assert that we only have a struct type if there are multiple elements.\n    auto unpaddedStruct = dyn_cast<llvm::StructType>(unpaddedCoerceToType);\n    assert(!unpaddedStruct || unpaddedStruct->getNumElements() != 1);\n\n    // Assert that all the non-padding elements have a corresponding element\n    // in the unpadded type.\n    unsigned unpaddedIndex = 0;\n    for (auto eltType : coerceToType->elements()) {\n      if (isPaddingForCoerceAndExpand(eltType)) continue;\n      if (unpaddedStruct) {\n        assert(unpaddedStruct->getElementType(unpaddedIndex) == eltType);\n      } else {\n        assert(unpaddedIndex == 0 && unpaddedCoerceToType == eltType);\n      }\n      unpaddedIndex++;\n    }\n\n    // Assert that there aren't extra elements in the unpadded type.\n    if (unpaddedStruct) {\n      assert(unpaddedStruct->getNumElements() == unpaddedIndex);\n    } else {\n      assert(unpaddedIndex == 1);\n    }\n#endif\n\n    auto AI = ABIArgInfo(CoerceAndExpand);\n    AI.setCoerceToType(coerceToType);\n    AI.setUnpaddedCoerceToType(unpaddedCoerceToType);\n    return AI;\n  }\n\n  static bool isPaddingForCoerceAndExpand(llvm::Type *eltType) {\n    if (eltType->isArrayTy()) {\n      assert(eltType->getArrayElementType()->isIntegerTy(8));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  Kind getKind() const { return TheKind; }\n  bool isDirect() const { return TheKind == Direct; }\n  bool isInAlloca() const { return TheKind == InAlloca; }\n  bool isExtend() const { return TheKind == Extend; }\n  bool isIgnore() const { return TheKind == Ignore; }\n  bool isIndirect() const { return TheKind == Indirect; }\n  bool isIndirectAliased() const { return TheKind == IndirectAliased; }\n  bool isExpand() const { return TheKind == Expand; }\n  bool isCoerceAndExpand() const { return TheKind == CoerceAndExpand; }\n\n  bool canHaveCoerceToType() const {\n    return isDirect() || isExtend() || isCoerceAndExpand();\n  }\n\n  // Direct/Extend accessors\n  unsigned getDirectOffset() const {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    return DirectAttr.Offset;\n  }\n  void setDirectOffset(unsigned Offset) {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    DirectAttr.Offset = Offset;\n  }\n\n  unsigned getDirectAlign() const {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    return DirectAttr.Align;\n  }\n  void setDirectAlign(unsigned Align) {\n    assert((isDirect() || isExtend()) && \"Not a direct or extend kind\");\n    DirectAttr.Align = Align;\n  }\n\n  bool isSignExt() const {\n    assert(isExtend() && \"Invalid kind!\");\n    return SignExt;\n  }\n  void setSignExt(bool SExt) {\n    assert(isExtend() && \"Invalid kind!\");\n    SignExt = SExt;\n  }\n\n  llvm::Type *getPaddingType() const {\n    return (canHavePaddingType() ? PaddingType : nullptr);\n  }\n\n  bool getPaddingInReg() const {\n    return PaddingInReg;\n  }\n  void setPaddingInReg(bool PIR) {\n    PaddingInReg = PIR;\n  }\n\n  llvm::Type *getCoerceToType() const {\n    assert(canHaveCoerceToType() && \"Invalid kind!\");\n    return TypeData;\n  }\n\n  void setCoerceToType(llvm::Type *T) {\n    assert(canHaveCoerceToType() && \"Invalid kind!\");\n    TypeData = T;\n  }\n\n  llvm::StructType *getCoerceAndExpandType() const {\n    assert(isCoerceAndExpand());\n    return cast<llvm::StructType>(TypeData);\n  }\n\n  llvm::Type *getUnpaddedCoerceAndExpandType() const {\n    assert(isCoerceAndExpand());\n    return UnpaddedCoerceAndExpandType;\n  }\n\n  ArrayRef<llvm::Type *>getCoerceAndExpandTypeSequence() const {\n    assert(isCoerceAndExpand());\n    if (auto structTy =\n          dyn_cast<llvm::StructType>(UnpaddedCoerceAndExpandType)) {\n      return structTy->elements();\n    } else {\n      return llvm::ArrayRef(&UnpaddedCoerceAndExpandType, 1);\n    }\n  }\n\n  bool getInReg() const {\n    assert((isDirect() || isExtend() || isIndirect()) && \"Invalid kind!\");\n    return InReg;\n  }\n\n  void setInReg(bool IR) {\n    assert((isDirect() || isExtend() || isIndirect()) && \"Invalid kind!\");\n    InReg = IR;\n  }\n\n  // Indirect accessors\n  CharUnits getIndirectAlign() const {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    return CharUnits::fromQuantity(IndirectAttr.Align);\n  }\n  void setIndirectAlign(CharUnits IA) {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    IndirectAttr.Align = IA.getQuantity();\n  }\n\n  bool getIndirectByVal() const {\n    assert(isIndirect() && \"Invalid kind!\");\n    return IndirectByVal;\n  }\n  void setIndirectByVal(bool IBV) {\n    assert(isIndirect() && \"Invalid kind!\");\n    IndirectByVal = IBV;\n  }\n\n  unsigned getIndirectAddrSpace() const {\n    assert(isIndirectAliased() && \"Invalid kind!\");\n    return IndirectAttr.AddrSpace;\n  }\n\n  void setIndirectAddrSpace(unsigned AddrSpace) {\n    assert(isIndirectAliased() && \"Invalid kind!\");\n    IndirectAttr.AddrSpace = AddrSpace;\n  }\n\n  bool getIndirectRealign() const {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    return IndirectRealign;\n  }\n  void setIndirectRealign(bool IR) {\n    assert((isIndirect() || isIndirectAliased()) && \"Invalid kind!\");\n    IndirectRealign = IR;\n  }\n\n  bool isSRetAfterThis() const {\n    assert(isIndirect() && \"Invalid kind!\");\n    return SRetAfterThis;\n  }\n  void setSRetAfterThis(bool AfterThis) {\n    assert(isIndirect() && \"Invalid kind!\");\n    SRetAfterThis = AfterThis;\n  }\n\n  unsigned getInAllocaFieldIndex() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return AllocaFieldIndex;\n  }\n  void setInAllocaFieldIndex(unsigned FieldIndex) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    AllocaFieldIndex = FieldIndex;\n  }\n\n  unsigned getInAllocaIndirect() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return InAllocaIndirect;\n  }\n  void setInAllocaIndirect(bool Indirect) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    InAllocaIndirect = Indirect;\n  }\n\n  /// Return true if this field of an inalloca struct should be returned\n  /// to implement a struct return calling convention.\n  bool getInAllocaSRet() const {\n    assert(isInAlloca() && \"Invalid kind!\");\n    return InAllocaSRet;\n  }\n\n  void setInAllocaSRet(bool SRet) {\n    assert(isInAlloca() && \"Invalid kind!\");\n    InAllocaSRet = SRet;\n  }\n\n  bool getCanBeFlattened() const {\n    assert(isDirect() && \"Invalid kind!\");\n    return CanBeFlattened;\n  }\n\n  void setCanBeFlattened(bool Flatten) {\n    assert(isDirect() && \"Invalid kind!\");\n    CanBeFlattened = Flatten;\n  }\n\n  void dump() const;\n}",
  "id": "BLOCK-CPP-17522",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/CGFunctionInfo.h",
  "source_line": 32,
  "validation_status": "validated"
}