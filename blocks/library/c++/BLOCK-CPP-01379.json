{
  "code": "{\n  if (const_check(!is_supported_floating_point(value))) return out;\n  float_specs fspecs = parse_float_type_spec(specs);\n  fspecs.sign = specs.sign;\n  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.\n    fspecs.sign = sign::minus;\n    value = -value;\n  } else if (fspecs.sign == sign::minus) {\n    fspecs.sign = sign::none;\n  }\n\n  if (!detail::isfinite(value))\n    return write_nonfinite(out, detail::isnan(value), specs, fspecs);\n\n  if (specs.align == align::numeric && fspecs.sign) {\n    auto it = reserve(out, 1);\n    *it++ = detail::sign<Char>(fspecs.sign);\n    out = base_iterator(out, it);\n    fspecs.sign = sign::none;\n    if (specs.width != 0) --specs.width;\n  }\n\n  memory_buffer buffer;\n  if (fspecs.format == float_format::hex) {\n    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));\n    snprintf_float(convert_float(value), specs.precision, fspecs, buffer);\n    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},\n                                     specs);\n  }\n  int precision = specs.precision >= 0 || specs.type == presentation_type::none\n                      ? specs.precision\n                      : 6;\n  if (fspecs.format == float_format::exp) {\n    if (precision == max_value<int>())\n      throw_format_error(\"number is too big\");\n    else\n      ++precision;\n  } else if (fspecs.format != float_format::fixed && precision == 0) {\n    precision = 1;\n  }\n  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;\n  int exp = format_float(convert_float(value), precision, fspecs, buffer);\n  fspecs.precision = precision;\n  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};\n  return write_float(out, f, specs, fspecs, loc);\n}",
  "id": "BLOCK-CPP-01379",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 3187,
  "validation_status": "validated"
}