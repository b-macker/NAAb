{
  "code": "{\n    /// hasPrototype - This is true if the function had at least one typed\n    /// parameter.  If the function is () or (a,b,c), then it has no prototype,\n    /// and is treated as a K&R-style function.\n    unsigned hasPrototype : 1;\n\n    /// isVariadic - If this function has a prototype, and if that\n    /// proto ends with ',...)', this is true. When true, EllipsisLoc\n    /// contains the location of the ellipsis.\n    unsigned isVariadic : 1;\n\n    /// Can this declaration be a constructor-style initializer?\n    unsigned isAmbiguous : 1;\n\n    /// Whether the ref-qualifier (if any) is an lvalue reference.\n    /// Otherwise, it's an rvalue reference.\n    unsigned RefQualifierIsLValueRef : 1;\n\n    /// ExceptionSpecType - An ExceptionSpecificationType value.\n    unsigned ExceptionSpecType : 4;\n\n    /// DeleteParams - If this is true, we need to delete[] Params.\n    unsigned DeleteParams : 1;\n\n    /// HasTrailingReturnType - If this is true, a trailing return type was\n    /// specified.\n    unsigned HasTrailingReturnType : 1;\n\n    /// The location of the left parenthesis in the source.\n    SourceLocation LParenLoc;\n\n    /// When isVariadic is true, the location of the ellipsis in the source.\n    SourceLocation EllipsisLoc;\n\n    /// The location of the right parenthesis in the source.\n    SourceLocation RParenLoc;\n\n    /// NumParams - This is the number of formal parameters specified by the\n    /// declarator.\n    unsigned NumParams;\n\n    /// NumExceptionsOrDecls - This is the number of types in the\n    /// dynamic-exception-decl, if the function has one. In C, this is the\n    /// number of declarations in the function prototype.\n    unsigned NumExceptionsOrDecls;\n\n    /// The location of the ref-qualifier, if any.\n    ///\n    /// If this is an invalid location, there is no ref-qualifier.\n    SourceLocation RefQualifierLoc;\n\n    /// The location of the 'mutable' qualifer in a lambda-declarator, if\n    /// any.\n    SourceLocation MutableLoc;\n\n    /// The beginning location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocBeg;\n\n    /// The end location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocEnd;\n\n    /// Params - This is a pointer to a new[]'d array of ParamInfo objects that\n    /// describe the parameters specified by this function declarator.  null if\n    /// there are no parameters specified.\n    ParamInfo *Params;\n\n    /// DeclSpec for the function with the qualifier related info.\n    DeclSpec *MethodQualifiers;\n\n    /// AttributeFactory for the MethodQualifiers.\n    AttributeFactory *QualAttrFactory;\n\n    union {\n      /// Pointer to a new[]'d array of TypeAndRange objects that\n      /// contain the types in the function's dynamic exception specification\n      /// and their locations, if there is one.\n      TypeAndRange *Exceptions;\n\n      /// Pointer to the expression in the noexcept-specifier of this\n      /// function, if it has one.\n      Expr *NoexceptExpr;\n\n      /// Pointer to the cached tokens for an exception-specification\n      /// that has not yet been parsed.\n      CachedTokens *ExceptionSpecTokens;\n\n      /// Pointer to a new[]'d array of declarations that need to be available\n      /// for lookup inside the function body, if one exists. Does not exist in\n      /// C++.\n      NamedDecl **DeclsInPrototype;\n    };\n\n    /// If HasTrailingReturnType is true, this is the trailing return\n    /// type specified.\n    UnionParsedType TrailingReturnType;\n\n    /// If HasTrailingReturnType is true, this is the location of the trailing\n    /// return type.\n    SourceLocation TrailingReturnTypeLoc;\n\n    /// Reset the parameter list to having zero parameters.\n    ///\n    /// This is used in various places for error recovery.\n    void freeParams() {\n      for (unsigned I = 0; I < NumParams; ++I)\n        Params[I].DefaultArgTokens.reset();\n      if (DeleteParams) {\n        delete[] Params;\n        DeleteParams = false;\n      }\n      NumParams = 0;\n    }\n\n    void destroy() {\n      freeParams();\n      delete QualAttrFactory;\n      delete MethodQualifiers;\n      switch (getExceptionSpecType()) {\n      default:\n        break;\n      case EST_Dynamic:\n        delete[] Exceptions;\n        break;\n      case EST_Unparsed:\n        delete ExceptionSpecTokens;\n        break;\n      case EST_None:\n        if (NumExceptionsOrDecls != 0)\n          delete[] DeclsInPrototype;\n        break;\n      }\n    }\n\n    DeclSpec &getOrCreateMethodQualifiers() {\n      if (!MethodQualifiers) {\n        QualAttrFactory = new AttributeFactory();\n        MethodQualifiers = new DeclSpec(*QualAttrFactory);\n      }\n      return *MethodQualifiers;\n    }\n\n    /// isKNRPrototype - Return true if this is a K&R style identifier list,\n    /// like \"void foo(a,b,c)\".  In a function definition, this will be followed\n    /// by the parameter type definitions.\n    bool isKNRPrototype() const { return !hasPrototype && NumParams != 0; }\n\n    SourceLocation getLParenLoc() const { return LParenLoc; }\n\n    SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n    SourceLocation getRParenLoc() const { return RParenLoc; }\n\n    SourceLocation getExceptionSpecLocBeg() const {\n      return ExceptionSpecLocBeg;\n    }\n\n    SourceLocation getExceptionSpecLocEnd() const {\n      return ExceptionSpecLocEnd;\n    }\n\n    SourceRange getExceptionSpecRange() const {\n      return SourceRange(getExceptionSpecLocBeg(), getExceptionSpecLocEnd());\n    }\n\n    /// Retrieve the location of the ref-qualifier, if any.\n    SourceLocation getRefQualifierLoc() const { return RefQualifierLoc; }\n\n    /// Retrieve the location of the 'const' qualifier.\n    SourceLocation getConstQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getConstSpecLoc();\n    }\n\n    /// Retrieve the location of the 'volatile' qualifier.\n    SourceLocation getVolatileQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getVolatileSpecLoc();\n    }\n\n    /// Retrieve the location of the 'restrict' qualifier.\n    SourceLocation getRestrictQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getRestrictSpecLoc();\n    }\n\n    /// Retrieve the location of the 'mutable' qualifier, if any.\n    SourceLocation getMutableLoc() const { return MutableLoc; }\n\n    /// Determine whether this function declaration contains a\n    /// ref-qualifier.\n    bool hasRefQualifier() const { return getRefQualifierLoc().isValid(); }\n\n    /// Determine whether this lambda-declarator contains a 'mutable'\n    /// qualifier.\n    bool hasMutableQualifier() const { return getMutableLoc().isValid(); }\n\n    /// Determine whether this method has qualifiers.\n    bool hasMethodTypeQualifiers() const {\n      return MethodQualifiers && (MethodQualifiers->getTypeQualifiers() ||\n                                  MethodQualifiers->getAttributes().size());\n    }\n\n    /// Get the type of exception specification this function has.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      return static_cast<ExceptionSpecificationType>(ExceptionSpecType);\n    }\n\n    /// Get the number of dynamic exception specifications.\n    unsigned getNumExceptions() const {\n      assert(ExceptionSpecType != EST_None);\n      return NumExceptionsOrDecls;\n    }\n\n    /// Get the non-parameter decls defined within this function\n    /// prototype. Typically these are tag declarations.\n    ArrayRef<NamedDecl *> getDeclsInPrototype() const {\n      assert(ExceptionSpecType == EST_None);\n      return llvm::ArrayRef(DeclsInPrototype, NumExceptionsOrDecls);\n    }\n\n    /// Determine whether this function declarator had a\n    /// trailing-return-type.\n    bool hasTrailingReturnType() const { return HasTrailingReturnType; }\n\n    /// Get the trailing-return-type for this function declarator.\n    ParsedType getTrailingReturnType() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnType;\n    }\n\n    /// Get the trailing-return-type location for this function declarator.\n    SourceLocation getTrailingReturnTypeLoc() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnTypeLoc;\n    }\n  }",
  "id": "BLOCK-CPP-19725",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DeclSpec.h",
  "source_line": 1315,
  "validation_status": "validated"
}