{
  "code": "{\n//     ...\n//   }\n//\n//   std::vector v = {1,2,3,4,5};\n//   MyRoutine(v);\n//\n//   absl::InlinedVector<int, 4> my_inline_vector;\n//   MyRoutine(my_inline_vector);\n//\n//   // Explicit constructor from pointer,size\n//   int* my_array = new int[10];\n//   MyRoutine(absl::Span<const int>(my_array, 10));\ntemplate <typename T>\nclass Span {\n private:\n  // Used to determine whether a Span can be constructed from a container of\n  // type C.\n  template <typename C>\n  using EnableIfConvertibleFrom =\n      typename std::enable_if<span_internal::HasData<T, C>::value &&\n                              span_internal::HasSize<C>::value>::type;\n\n  // Used to SFINAE-enable a function when the slice elements are const.\n  template <typename U>\n  using EnableIfValueIsConst =\n      typename std::enable_if<std::is_const<T>::value, U>::type;\n\n  // Used to SFINAE-enable a function when the slice elements are mutable.\n  template <typename U>\n  using EnableIfValueIsMutable =\n      typename std::enable_if<!std::is_const<T>::value, U>::type;\n\n public:\n  using element_type = T;\n  using value_type = absl::remove_cv_t<T>;\n  // TODO(b/316099902) - pointer should be Nullable<T*>, but this makes it hard\n  // to recognize foreach loops as safe.\n  using pointer = T*;\n  using const_pointer = const T*;\n  using reference = T&;\n  using const_reference = const T&;\n  using iterator = pointer;\n  using const_iterator = const_pointer;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n\n  static const size_type npos = ~(size_type(0));\n\n  constexpr Span() noexcept : Span(nullptr, 0) {}\n  constexpr Span(pointer array, size_type length) noexcept\n      : ptr_(array), len_(length) {}\n\n  // Implicit conversion constructors\n  template <size_t N>\n  constexpr Span(T (&a)[N]) noexcept  // NOLINT(runtime/explicit)\n      : Span(a, N) {}\n\n  // Explicit reference constructor for a mutable `Span<T>` type. Can be\n  // replaced with MakeSpan() to infer the type parameter.\n  template <typename V, typename = EnableIfConvertibleFrom<V>,\n            typename = EnableIfValueIsMutable<V>,\n            typename = span_internal::EnableIfNotIsView<V>>\n  explicit Span(\n      V& v\n          ABSL_ATTRIBUTE_LIFETIME_BOUND) noexcept  // NOLINT(runtime/references)\n      : Span(span_internal::GetData(v), v.size()) {}\n\n  // Implicit reference constructor for a read-only `Span<const T>` type\n  template <typename V, typename = EnableIfConvertibleFrom<V>,\n            typename = EnableIfValueIsConst<V>,\n            typename = span_internal::EnableIfNotIsView<V>>\n  constexpr Span(\n      const V& v\n          ABSL_ATTRIBUTE_LIFETIME_BOUND) noexcept  // NOLINT(runtime/explicit)\n      : Span(span_internal::GetData(v), v.size()) {}\n\n  // Overloads of the above two functions that are only enabled for view types.\n  // This is so we can drop the ABSL_ATTRIBUTE_LIFETIME_BOUND annotation. These\n  // overloads must be made unique by using a different template parameter list\n  // (hence the = 0 for the IsView enabler).\n  template <typename V, typename = EnableIfConvertibleFrom<V>,\n            typename = EnableIfValueIsMutable<V>,\n            span_internal::EnableIfIsView<V> = 0>\n  explicit Span(V& v) noexcept  // NOLINT(runtime/references)\n      : Span(span_internal::GetData(v), v.size()) {}\n  template <typename V, typename = EnableIfConvertibleFrom<V>,\n            typename = EnableIfValueIsConst<V>,\n            span_internal::EnableIfIsView<V> = 0>\n  constexpr Span(const V& v) noexcept  // NOLINT(runtime/explicit)\n      : Span(span_internal::GetData(v), v.size()) {}\n\n  // Implicit constructor from an initializer list, making it possible to pass a\n  // brace-enclosed initializer list to a function expecting a `Span`. Such\n  // spans constructed from an initializer list must be of type `Span<const T>`.\n  //\n  //   void Process(absl::Span<const int> x);\n  //   Process({1, 2, 3});\n  //\n  // Note that as always the array referenced by the span must outlive the span.\n  // Since an initializer list constructor acts as if it is fed a temporary\n  // array (cf. C++ standard [dcl.init.list]/5), it's safe to use this\n  // constructor only when the `std::initializer_list` itself outlives the span.\n  // In order to meet this requirement it's sufficient to ensure that neither\n  // the span nor a copy of it is used outside of the expression in which it's\n  // created:\n  //\n  //   // Assume that this function uses the array directly, not retaining any\n  //   // copy of the span or pointer to any of its elements.\n  //   void Process(absl::Span<const int> ints);\n  //\n  //   // Okay: the std::initializer_list<int> will reference a temporary array\n  //   // that isn't destroyed until after the call to Process returns.\n  //   Process({ 17, 19 });\n  //\n  //   // Not okay: the storage used by the std::initializer_list<int> is not\n  //   // allowed to be referenced after the first line.\n  //   absl::Span<const int> ints = { 17, 19 };\n  //   Process(ints);\n  //\n  //   // Not okay for the same reason as above: even when the elements of the\n  //   // initializer list expression are not temporaries the underlying array\n  //   // is, so the initializer list must still outlive the span.\n  //   const int foo = 17;\n  //   absl::Span<const int> ints = { foo };\n  //   Process(ints);\n  //\n  template <typename LazyT = T,\n            typename = EnableIfValueIsConst<LazyT>>\n  Span(std::initializer_list<value_type> v\n           ABSL_ATTRIBUTE_LIFETIME_BOUND) noexcept  // NOLINT(runtime/explicit)\n      : Span(v.begin(), v.size()) {}\n\n  // Accessors\n\n  // Span::data()\n  //\n  // Returns a pointer to the span's underlying array of data (which is held\n  // outside the span).\n  constexpr pointer data() const noexcept { return ptr_; }\n\n  // Span::size()\n  //\n  // Returns the size of this span.\n  constexpr size_type size() const noexcept { return len_; }\n\n  // Span::length()\n  //\n  // Returns the length (size) of this span.\n  constexpr size_type length() const noexcept { return size(); }\n\n  // Span::empty()\n  //\n  // Returns a boolean indicating whether or not this span is considered empty.\n  constexpr bool empty() const noexcept { return size() == 0; }\n\n  // Span::operator[]\n  //\n  // Returns a reference to the i'th element of this span.\n  constexpr reference operator[](size_type i) const noexcept {\n    return ABSL_HARDENING_ASSERT(i < size()), ptr_[i];\n  }\n\n  // Span::at()\n  //\n  // Returns a reference to the i'th element of this span.\n  constexpr reference at(size_type i) const {\n    return ABSL_PREDICT_TRUE(i < size())  //\n               ? *(data() + i)\n               : (base_internal::ThrowStdOutOfRange(\n                      \"Span::at failed bounds check\"),\n                  *(data() + i));\n  }\n\n  // Span::front()\n  //\n  // Returns a reference to the first element of this span. The span must not\n  // be empty.\n  constexpr reference front() const noexcept {\n    return ABSL_HARDENING_ASSERT(size() > 0), *data();\n  }\n\n  // Span::back()\n  //\n  // Returns a reference to the last element of this span. The span must not\n  // be empty.\n  constexpr reference back() const noexcept {\n    return ABSL_HARDENING_ASSERT(size() > 0), *(data() + size() - 1);\n  }\n\n  // Span::begin()\n  //\n  // Returns an iterator pointing to the first element of this span, or `end()`\n  // if the span is empty.\n  constexpr iterator begin() const noexcept { return data(); }\n\n  // Span::cbegin()\n  //\n  // Returns a const iterator pointing to the first element of this span, or\n  // `end()` if the span is empty.\n  constexpr const_iterator cbegin() const noexcept { return begin(); }\n\n  // Span::end()\n  //\n  // Returns an iterator pointing just beyond the last element at the\n  // end of this span. This iterator acts as a placeholder; attempting to\n  // access it results in undefined behavior.\n  constexpr iterator end() const noexcept { return data() + size(); }\n\n  // Span::cend()\n  //\n  // Returns a const iterator pointing just beyond the last element at the\n  // end of this span. This iterator acts as a placeholder; attempting to\n  // access it results in undefined behavior.\n  constexpr const_iterator cend() const noexcept { return end(); }\n\n  // Span::rbegin()\n  //\n  // Returns a reverse iterator pointing to the last element at the end of this\n  // span, or `rend()` if the span is empty.\n  constexpr reverse_iterator rbegin() const noexcept {\n    return reverse_iterator(end());\n  }\n\n  // Span::crbegin()\n  //\n  // Returns a const reverse iterator pointing to the last element at the end of\n  // this span, or `crend()` if the span is empty.\n  constexpr const_reverse_iterator crbegin() const noexcept { return rbegin(); }\n\n  // Span::rend()\n  //\n  // Returns a reverse iterator pointing just before the first element\n  // at the beginning of this span. This pointer acts as a placeholder;\n  // attempting to access its element results in undefined behavior.\n  constexpr reverse_iterator rend() const noexcept {\n    return reverse_iterator(begin());\n  }\n\n  // Span::crend()\n  //\n  // Returns a reverse const iterator pointing just before the first element\n  // at the beginning of this span. This pointer acts as a placeholder;\n  // attempting to access its element results in undefined behavior.\n  constexpr const_reverse_iterator crend() const noexcept { return rend(); }\n\n  // Span mutations\n\n  // Span::remove_prefix()\n  //\n  // Removes the first `n` elements from the span.\n  void remove_prefix(size_type n) noexcept {\n    ABSL_HARDENING_ASSERT(size() >= n);\n    ptr_ += n;\n    len_ -= n;\n  }\n\n  // Span::remove_suffix()\n  //\n  // Removes the last `n` elements from the span.\n  void remove_suffix(size_type n) noexcept {\n    ABSL_HARDENING_ASSERT(size() >= n);\n    len_ -= n;\n  }\n\n  // Span::subspan()\n  //\n  // Returns a `Span` starting at element `pos` and of length `len`. Both `pos`\n  // and `len` are of type `size_type` and thus non-negative. Parameter `pos`\n  // must be <= size(). Any `len` value that points past the end of the span\n  // will be trimmed to at most size() - `pos`. A default `len` value of `npos`\n  // ensures the returned subspan continues until the end of the span.\n  //\n  // Examples:\n  //\n  //   std::vector<int> vec = {10, 11, 12, 13};\n  //   absl::MakeSpan(vec).subspan(1, 2);  // {11, 12}\n  //   absl::MakeSpan(vec).subspan(2, 8);  // {12, 13}\n  //   absl::MakeSpan(vec).subspan(1);     // {11, 12, 13}\n  //   absl::MakeSpan(vec).subspan(4);     // {}\n  //   absl::MakeSpan(vec).subspan(5);     // throws std::out_of_range\n  constexpr Span subspan(size_type pos = 0, size_type len = npos) const {\n    return (pos <= size())\n               ? Span(data() + pos, (std::min)(size() - pos, len))\n               : (base_internal::ThrowStdOutOfRange(\"pos > size()\"), Span());\n  }\n\n  // Span::first()\n  //\n  // Returns a `Span` containing first `len` elements. Parameter `len` is of\n  // type `size_type` and thus non-negative. `len` value must be <= size().\n  //\n  // Examples:\n  //\n  //   std::vector<int> vec = {10, 11, 12, 13};\n  //   absl::MakeSpan(vec).first(1);  // {10}\n  //   absl::MakeSpan(vec).first(3);  // {10, 11, 12}\n  //   absl::MakeSpan(vec).first(5);  // throws std::out_of_range\n  constexpr Span first(size_type len) const {\n    return (len <= size())\n               ? Span(data(), len)\n               : (base_internal::ThrowStdOutOfRange(\"len > size()\"), Span());\n  }\n\n  // Span::last()\n  //\n  // Returns a `Span` containing last `len` elements. Parameter `len` is of\n  // type `size_type` and thus non-negative. `len` value must be <= size().\n  //\n  // Examples:\n  //\n  //   std::vector<int> vec = {10, 11, 12, 13};\n  //   absl::MakeSpan(vec).last(1);  // {13}\n  //   absl::MakeSpan(vec).last(3);  // {11, 12, 13}\n  //   absl::MakeSpan(vec).last(5);  // throws std::out_of_range\n  constexpr Span last(size_type len) const {\n    return (len <= size())\n               ? Span(size() - len + data(), len)\n               : (base_internal::ThrowStdOutOfRange(\"len > size()\"), Span());\n  }\n\n  // Support for absl::Hash.\n  template <typename H>\n  friend H AbslHashValue(H h, Span v) {\n    return H::combine(H::combine_contiguous(std::move(h), v.data(), v.size()),\n                      v.size());\n  }\n\n private:\n  pointer ptr_;\n  size_type len_;\n};\n\ntemplate <typename T>\nconst typename Span<T>::size_type Span<T>::npos;\n\n// Span relationals\n\n// Equality is compared element-by-element, while ordering is lexicographical.\n// We provide three overloads for each operator to cover any combination on the\n// left or right hand side of mutable Span<T>, read-only Span<const T>, and\n// convertible-to-read-only Span<T>.\n// TODO(zhangxy): Due to MSVC overload resolution bug with partial ordering\n// template functions, 5 overloads per operator is needed as a workaround. We\n// should update them to 3 overloads per operator using non-deduced context like\n// string_view, i.e.\n// - (Span<T>, Span<T>)\n// - (Span<T>, non_deduced<Span<const T>>)\n// - (non_deduced<Span<const T>>, Span<T>)\n\n// operator==\ntemplate <typename T>\nbool operator==(Span<T> a, Span<T> b) {\n  return span_internal::EqualImpl<Span, const T>(a, b);\n}\ntemplate <typename T>\nbool operator==(Span<const T> a, Span<T> b) {\n  return span_internal::EqualImpl<Span, const T>(a, b);\n}\ntemplate <typename T>\nbool operator==(Span<T> a, Span<const T> b) {\n  return span_internal::EqualImpl<Span, const T>(a, b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator==(const U& a, Span<T> b) {\n  return span_internal::EqualImpl<Span, const T>(a, b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator==(Span<T> a, const U& b) {\n  return span_internal::EqualImpl<Span, const T>(a, b);\n}\n\n// operator!=\ntemplate <typename T>\nbool operator!=(Span<T> a, Span<T> b) {\n  return !(a == b);\n}\ntemplate <typename T>\nbool operator!=(Span<const T> a, Span<T> b) {\n  return !(a == b);\n}\ntemplate <typename T>\nbool operator!=(Span<T> a, Span<const T> b) {\n  return !(a == b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator!=(const U& a, Span<T> b) {\n  return !(a == b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator!=(Span<T> a, const U& b) {\n  return !(a == b);\n}\n\n// operator<\ntemplate <typename T>\nbool operator<(Span<T> a, Span<T> b) {\n  return span_internal::LessThanImpl<Span, const T>(a, b);\n}\ntemplate <typename T>\nbool operator<(Span<const T> a, Span<T> b) {\n  return span_internal::LessThanImpl<Span, const T>(a, b);\n}\ntemplate <typename T>\nbool operator<(Span<T> a, Span<const T> b) {\n  return span_internal::LessThanImpl<Span, const T>(a, b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator<(const U& a, Span<T> b) {\n  return span_internal::LessThanImpl<Span, const T>(a, b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator<(Span<T> a, const U& b) {\n  return span_internal::LessThanImpl<Span, const T>(a, b);\n}\n\n// operator>\ntemplate <typename T>\nbool operator>(Span<T> a, Span<T> b) {\n  return b < a;\n}\ntemplate <typename T>\nbool operator>(Span<const T> a, Span<T> b) {\n  return b < a;\n}\ntemplate <typename T>\nbool operator>(Span<T> a, Span<const T> b) {\n  return b < a;\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator>(const U& a, Span<T> b) {\n  return b < a;\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator>(Span<T> a, const U& b) {\n  return b < a;\n}\n\n// operator<=\ntemplate <typename T>\nbool operator<=(Span<T> a, Span<T> b) {\n  return !(b < a);\n}\ntemplate <typename T>\nbool operator<=(Span<const T> a, Span<T> b) {\n  return !(b < a);\n}\ntemplate <typename T>\nbool operator<=(Span<T> a, Span<const T> b) {\n  return !(b < a);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator<=(const U& a, Span<T> b) {\n  return !(b < a);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator<=(Span<T> a, const U& b) {\n  return !(b < a);\n}\n\n// operator>=\ntemplate <typename T>\nbool operator>=(Span<T> a, Span<T> b) {\n  return !(a < b);\n}\ntemplate <typename T>\nbool operator>=(Span<const T> a, Span<T> b) {\n  return !(a < b);\n}\ntemplate <typename T>\nbool operator>=(Span<T> a, Span<const T> b) {\n  return !(a < b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator>=(const U& a, Span<T> b) {\n  return !(a < b);\n}\ntemplate <\n    typename T, typename U,\n    typename = span_internal::EnableIfConvertibleTo<U, absl::Span<const T>>>\nbool operator>=(Span<T> a, const U& b) {\n  return !(a < b);\n}\n\n// MakeSpan()\n//\n// Constructs a mutable `Span<T>`, deducing `T` automatically from either a\n// container or pointer+size.\n//\n// Because a read-only `Span<const T>` is implicitly constructed from container\n// types regardless of whether the container itself is a const container,\n// constructing mutable spans of type `Span<T>` from containers requires\n// explicit constructors. The container-accepting version of `MakeSpan()`\n// deduces the type of `T` by the constness of the pointer received from the\n// container's `data()` member. Similarly, the pointer-accepting version returns\n// a `Span<const T>` if `T` is `const`, and a `Span<T>` otherwise.\n//\n// Examples:\n//\n//   void MyRoutine(absl::Span<MyComplicatedType> a) {\n//     ...\n//   };\n//   // my_vector is a container of non-const types\n//   std::vector<MyComplicatedType> my_vector;\n//\n//   // Constructing a Span implicitly attempts to create a Span of type\n//   // `Span<const T>`\n//   MyRoutine(my_vector);                // error, type mismatch\n//\n//   // Explicitly constructing the Span is verbose\n//   MyRoutine(absl::Span<MyComplicatedType>(my_vector));\n//\n//   // Use MakeSpan() to make an absl::Span<T>\n//   MyRoutine(absl::MakeSpan(my_vector));\n//\n//   // Construct a span from an array ptr+size\n//   absl::Span<T> my_span() {\n//     return absl::MakeSpan(&array[0], num_elements_);\n//   }\n//\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nconstexpr Span<T> MakeSpan(absl::Nullable<T*> ptr, size_t size) noexcept {\n  return Span<T>(ptr, size);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nSpan<T> MakeSpan(absl::Nullable<T*> begin, absl::Nullable<T*> end) noexcept {\n  return ABSL_HARDENING_ASSERT(begin <= end),\n         Span<T>(begin, static_cast<size_t>(end - begin));\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename C>\nconstexpr auto MakeSpan(C& c) noexcept  // NOLINT(runtime/references)\n    -> decltype(absl::MakeSpan(span_internal::GetData(c), c.size())) {\n  return MakeSpan(span_internal::GetData(c), c.size());\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T, size_t N>\nconstexpr Span<T> MakeSpan(T (&array)[N]) noexcept {\n  return Span<T>(array, N);\n}\n\n// MakeConstSpan()\n//\n// Constructs a `Span<const T>` as with `MakeSpan`, deducing `T` automatically,\n// but always returning a `Span<const T>`.\n//\n// Examples:\n//\n//   void ProcessInts(absl::Span<const int> some_ints);\n//\n//   // Call with a pointer and size.\n//   int array[3] = { 0, 0, 0 };\n//   ProcessInts(absl::MakeConstSpan(&array[0], 3));\n//\n//   // Call with a [begin, end) pair.\n//   ProcessInts(absl::MakeConstSpan(&array[0], &array[3]));\n//\n//   // Call directly with an array.\n//   ProcessInts(absl::MakeConstSpan(array));\n//\n//   // Call with a contiguous container.\n//   std::vector<int> some_ints = ...;\n//   ProcessInts(absl::MakeConstSpan(some_ints));\n//   ProcessInts(absl::MakeConstSpan(std::vector<int>{ 0, 0, 0 }));\n//\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nconstexpr Span<const T> MakeConstSpan(absl::Nullable<T*> ptr,\n                                      size_t size) noexcept {\n  return Span<const T>(ptr, size);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T>\nSpan<const T> MakeConstSpan(absl::Nullable<T*> begin,\n                            absl::Nullable<T*> end) noexcept {\n  return ABSL_HARDENING_ASSERT(begin <= end), Span<const T>(begin, end - begin);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename C>\nconstexpr auto MakeConstSpan(const C& c) noexcept -> decltype(MakeSpan(c)) {\n  return MakeSpan(c);\n}\n\ntemplate <int&... ExplicitArgumentBarrier, typename T, size_t N>\nconstexpr Span<const T> MakeConstSpan(const T (&array)[N]) noexcept {\n  return Span<const T>(array, N);\n}\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04495",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/span.h",
  "source_line": 140,
  "validation_status": "validated"
}