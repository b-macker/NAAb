{
  "code": "{\n public:\n  constexpr RefcountAndFlags() : count_{kRefIncrement} {}\n  struct Immortal {};\n  explicit constexpr RefcountAndFlags(Immortal) : count_(kImmortalFlag) {}\n\n  // Increments the reference count. Imposes no memory ordering.\n  inline void Increment() {\n    count_.fetch_add(kRefIncrement, std::memory_order_relaxed);\n  }\n\n  // Asserts that the current refcount is greater than 0. If the refcount is\n  // greater than 1, decrements the reference count.\n  //\n  // Returns false if there are no references outstanding; true otherwise.\n  // Inserts barriers to ensure that state written before this method returns\n  // false will be visible to a thread that just observed this method returning\n  // false.  Always returns false when the immortal bit is set.\n  inline bool Decrement() {\n    int32_t refcount = count_.load(std::memory_order_acquire);\n    assert(refcount > 0 || refcount & kImmortalFlag);\n    return refcount != kRefIncrement &&\n           count_.fetch_sub(kRefIncrement, std::memory_order_acq_rel) !=\n               kRefIncrement;\n  }\n\n  // Same as Decrement but expect that refcount is greater than 1.\n  inline bool DecrementExpectHighRefcount() {\n    int32_t refcount =\n        count_.fetch_sub(kRefIncrement, std::memory_order_acq_rel);\n    assert(refcount > 0 || refcount & kImmortalFlag);\n    return refcount != kRefIncrement;\n  }\n\n  // Returns the current reference count using acquire semantics.\n  inline size_t Get() const {\n    return static_cast<size_t>(count_.load(std::memory_order_acquire) >>\n                               kNumFlags);\n  }\n\n  // Returns whether the atomic integer is 1.\n  // If the reference count is used in the conventional way, a\n  // reference count of 1 implies that the current thread owns the\n  // reference and no other thread shares it.\n  // This call performs the test for a reference count of one, and\n  // performs the memory barrier needed for the owning thread\n  // to act on the object, knowing that it has exclusive access to the\n  // object. Always returns false when the immortal bit is set.\n  inline bool IsOne() {\n    return count_.load(std::memory_order_acquire) == kRefIncrement;\n  }\n\n  bool IsImmortal() const {\n    return (count_.load(std::memory_order_relaxed) & kImmortalFlag) != 0;\n  }\n\n private:\n  // We reserve the bottom bit for flag.\n  // kImmortalBit indicates that this entity should never be collected; it is\n  // used for the StringConstant constructor to avoid collecting immutable\n  // constant cords.\n  enum Flags {\n    kNumFlags = 1,\n\n    kImmortalFlag = 0x1,\n    kRefIncrement = (1 << kNumFlags),\n  };\n\n  std::atomic<int32_t> count_;\n}",
  "id": "BLOCK-CPP-06110",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_internal.h",
  "source_line": 140,
  "validation_status": "validated"
}