{
  "code": "{\n    friend class ASTNodeImporter;\n  public:\n    using NonEquivalentDeclSet = llvm::DenseSet<std::pair<Decl *, Decl *>>;\n    using ImportedCXXBaseSpecifierMap =\n        llvm::DenseMap<const CXXBaseSpecifier *, CXXBaseSpecifier *>;\n\n    enum class ODRHandlingType { Conservative, Liberal };\n\n    // An ImportPath is the list of the AST nodes which we visit during an\n    // Import call.\n    // If node `A` depends on node `B` then the path contains an `A`->`B` edge.\n    // From the call stack of the import functions we can read the very same\n    // path.\n    //\n    // Now imagine the following AST, where the `->` represents dependency in\n    // therms of the import.\n    // ```\n    // A->B->C->D\n    //    `->E\n    // ```\n    // We would like to import A.\n    // The import behaves like a DFS, so we will visit the nodes in this order:\n    // ABCDE.\n    // During the visitation we will have the following ImportPaths:\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCD\n    // ABC\n    // AB\n    // ABE\n    // AB\n    // A\n    // ```\n    // If during the visit of E there is an error then we set an error for E,\n    // then as the call stack shrinks for B, then for A:\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCD\n    // ABC\n    // AB\n    // ABE // Error! Set an error to E\n    // AB  // Set an error to B\n    // A   // Set an error to A\n    // ```\n    // However, during the import we could import C and D without any error and\n    // they are independent from A,B and E.\n    // We must not set up an error for C and D.\n    // So, at the end of the import we have an entry in `ImportDeclErrors` for\n    // A,B,E but not for C,D.\n    //\n    // Now what happens if there is a cycle in the import path?\n    // Let's consider this AST:\n    // ```\n    // A->B->C->A\n    //    `->E\n    // ```\n    // During the visitation we will have the below ImportPaths and if during\n    // the visit of E there is an error then we will set up an error for E,B,A.\n    // But what's up with C?\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCA\n    // ABC\n    // AB\n    // ABE // Error! Set an error to E\n    // AB  // Set an error to B\n    // A   // Set an error to A\n    // ```\n    // This time we know that both B and C are dependent on A.\n    // This means we must set up an error for C too.\n    // As the call stack reverses back we get to A and we must set up an error\n    // to all nodes which depend on A (this includes C).\n    // But C is no longer on the import path, it just had been previously.\n    // Such situation can happen only if during the visitation we had a cycle.\n    // If we didn't have any cycle, then the normal way of passing an Error\n    // object through the call stack could handle the situation.\n    // This is why we must track cycles during the import process for each\n    // visited declaration.\n    class ImportPathTy {\n    public:\n      using VecTy = llvm::SmallVector<Decl *, 32>;\n\n      void push(Decl *D) {\n        Nodes.push_back(D);\n        ++Aux[D];\n      }\n\n      void pop() {\n        if (Nodes.empty())\n          return;\n        --Aux[Nodes.back()];\n        Nodes.pop_back();\n      }\n\n      /// Returns true if the last element can be found earlier in the path.\n      bool hasCycleAtBack() const {\n        auto Pos = Aux.find(Nodes.back());\n        return Pos != Aux.end() && Pos->second > 1;\n      }\n\n      using Cycle = llvm::iterator_range<VecTy::const_reverse_iterator>;\n      Cycle getCycleAtBack() const {\n        assert(Nodes.size() >= 2);\n        return Cycle(Nodes.rbegin(),\n                     std::find(Nodes.rbegin() + 1, Nodes.rend(), Nodes.back()) +\n                         1);\n      }\n\n      /// Returns the copy of the cycle.\n      VecTy copyCycleAtBack() const {\n        auto R = getCycleAtBack();\n        return VecTy(R.begin(), R.end());\n      }\n\n    private:\n      // All nodes of the path.\n      VecTy Nodes;\n      // Auxiliary container to be able to answer \"Do we have a cycle ending\n      // at last element?\" as fast as possible.\n      // We count each Decl's occurrence over the path.\n      llvm::SmallDenseMap<Decl *, int, 32> Aux;\n    };\n\n  private:\n    std::shared_ptr<ASTImporterSharedState> SharedState = nullptr;\n\n    /// The path which we go through during the import of a given AST node.\n    ImportPathTy ImportPath;\n    /// Sometimes we have to save some part of an import path, so later we can\n    /// set up properties to the saved nodes.\n    /// We may have several of these import paths associated to one Decl.\n    using SavedImportPathsForOneDecl =\n        llvm::SmallVector<ImportPathTy::VecTy, 32>;\n    using SavedImportPathsTy =\n        llvm::SmallDenseMap<Decl *, SavedImportPathsForOneDecl, 32>;\n    SavedImportPathsTy SavedImportPaths;\n\n    /// The contexts we're importing to and from.\n    ASTContext &ToContext, &FromContext;\n\n    /// The file managers we're importing to and from.\n    FileManager &ToFileManager, &FromFileManager;\n\n    /// Whether to perform a minimal import.\n    bool Minimal;\n\n    ODRHandlingType ODRHandling;\n\n    /// Whether the last diagnostic came from the \"from\" context.\n    bool LastDiagFromFrom = false;\n\n    /// Mapping from the already-imported types in the \"from\" context\n    /// to the corresponding types in the \"to\" context.\n    llvm::DenseMap<const Type *, const Type *> ImportedTypes;\n\n    /// Mapping from the already-imported declarations in the \"from\"\n    /// context to the corresponding declarations in the \"to\" context.\n    llvm::DenseMap<Decl *, Decl *> ImportedDecls;\n\n    /// Mapping from the already-imported declarations in the \"from\"\n    /// context to the error status of the import of that declaration.\n    /// This map contains only the declarations that were not correctly\n    /// imported. The same declaration may or may not be included in\n    /// ImportedDecls. This map is updated continuously during imports and never\n    /// cleared (like ImportedDecls).\n    llvm::DenseMap<Decl *, ASTImportError> ImportDeclErrors;\n\n    /// Mapping from the already-imported declarations in the \"to\"\n    /// context to the corresponding declarations in the \"from\" context.\n    llvm::DenseMap<Decl *, Decl *> ImportedFromDecls;\n\n    /// Mapping from the already-imported statements in the \"from\"\n    /// context to the corresponding statements in the \"to\" context.\n    llvm::DenseMap<Stmt *, Stmt *> ImportedStmts;\n\n    /// Mapping from the already-imported FileIDs in the \"from\" source\n    /// manager to the corresponding FileIDs in the \"to\" source manager.\n    llvm::DenseMap<FileID, FileID> ImportedFileIDs;\n\n    /// Mapping from the already-imported CXXBasesSpecifier in\n    ///  the \"from\" source manager to the corresponding CXXBasesSpecifier\n    ///  in the \"to\" source manager.\n    ImportedCXXBaseSpecifierMap ImportedCXXBaseSpecifiers;\n\n    /// Declaration (from, to) pairs that are known not to be equivalent\n    /// (which we have already complained about).\n    NonEquivalentDeclSet NonEquivalentDecls;\n\n    using FoundDeclsTy = SmallVector<NamedDecl *, 2>;\n    FoundDeclsTy findDeclsInToCtx(DeclContext *DC, DeclarationName Name);\n\n    void AddToLookupTable(Decl *ToD);\n    llvm::Error ImportAttrs(Decl *ToD, Decl *FromD);\n\n  protected:\n    /// Can be overwritten by subclasses to implement their own import logic.\n    /// The overwritten method should call this method if it didn't import the\n    /// decl on its own.\n    virtual Expected<Decl *> ImportImpl(Decl *From);\n\n    /// Used only in unittests to verify the behaviour of the error handling.\n    virtual bool returnWithErrorInTest() { return false; };\n\n  public:\n\n    /// \\param ToContext The context we'll be importing into.\n    ///\n    /// \\param ToFileManager The file manager we'll be importing into.\n    ///\n    /// \\param FromContext The context we'll be importing from.\n    ///\n    /// \\param FromFileManager The file manager we'll be importing into.\n    ///\n    /// \\param MinimalImport If true, the importer will attempt to import\n    /// as little as it can, e.g., by importing declarations as forward\n    /// declarations that can be completed at a later point.\n    ///\n    /// \\param SharedState The importer specific lookup table which may be\n    /// shared amongst several ASTImporter objects.\n    /// If not set then the original C/C++ lookup is used.\n    ASTImporter(ASTContext &ToContext, FileManager &ToFileManager,\n                ASTContext &FromContext, FileManager &FromFileManager,\n                bool MinimalImport,\n                std::shared_ptr<ASTImporterSharedState> SharedState = nullptr);\n\n    virtual ~ASTImporter();\n\n    /// Whether the importer will perform a minimal import, creating\n    /// to-be-completed forward declarations when possible.\n    bool isMinimalImport() const { return Minimal; }\n\n    void setODRHandling(ODRHandlingType T) { ODRHandling = T; }\n\n    /// \\brief Import the given object, returns the result.\n    ///\n    /// \\param To Import the object into this variable.\n    /// \\param From Object to import.\n    /// \\return Error information (success or error).\n    template <typename ImportT>\n    [[nodiscard]] llvm::Error importInto(ImportT &To, const ImportT &From) {\n      auto ToOrErr = Import(From);\n      if (ToOrErr)\n        To = *ToOrErr;\n      return ToOrErr.takeError();\n    }\n\n    /// Import cleanup objects owned by ExprWithCleanup.\n    llvm::Expected<ExprWithCleanups::CleanupObject>\n    Import(ExprWithCleanups::CleanupObject From);\n\n    /// Import the given type from the \"from\" context into the \"to\"\n    /// context.\n    ///\n    /// \\returns The equivalent type in the \"to\" context, or the import error.\n    llvm::Expected<const Type *> Import(const Type *FromT);\n\n    /// Import the given qualified type from the \"from\" context into the \"to\"\n    /// context. A null type is imported as a null type (no error).\n    ///\n    /// \\returns The equivalent type in the \"to\" context, or the import error.\n    llvm::Expected<QualType> Import(QualType FromT);\n\n    /// Import the given type source information from the\n    /// \"from\" context into the \"to\" context.\n    ///\n    /// \\returns The equivalent type source information in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<TypeSourceInfo *> Import(TypeSourceInfo *FromTSI);\n\n    /// Import the given attribute from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent attribute in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Attr *> Import(const Attr *FromAttr);\n\n    /// Import the given declaration from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent declaration in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Decl *> Import(Decl *FromD);\n    llvm::Expected<const Decl *> Import(const Decl *FromD) {\n      return Import(const_cast<Decl *>(FromD));\n    }\n\n    llvm::Expected<InheritedConstructor>\n    Import(const InheritedConstructor &From);\n\n    /// Return the copy of the given declaration in the \"to\" context if\n    /// it has already been imported from the \"from\" context.  Otherwise return\n    /// nullptr.\n    Decl *GetAlreadyImportedOrNull(const Decl *FromD) const;\n\n    /// Return the translation unit from where the declaration was\n    /// imported. If it does not exist nullptr is returned.\n    TranslationUnitDecl *GetFromTU(Decl *ToD);\n\n    /// Return the declaration in the \"from\" context from which the declaration\n    /// in the \"to\" context was imported. If it was not imported or of the wrong\n    /// type a null value is returned.\n    template <typename DeclT>\n    std::optional<DeclT *> getImportedFromDecl(const DeclT *ToD) const {\n      auto FromI = ImportedFromDecls.find(ToD);\n      if (FromI == ImportedFromDecls.end())\n        return {};\n      auto *FromD = dyn_cast<DeclT>(FromI->second);\n      if (!FromD)\n        return {};\n      return FromD;\n    }\n\n    /// Import the given declaration context from the \"from\"\n    /// AST context into the \"to\" AST context.\n    ///\n    /// \\returns the equivalent declaration context in the \"to\"\n    /// context, or error value.\n    llvm::Expected<DeclContext *> ImportContext(DeclContext *FromDC);\n\n    /// Import the given expression from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent expression in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Expr *> Import(Expr *FromE);\n\n    /// Import the given statement from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent statement in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Stmt *> Import(Stmt *FromS);\n\n    /// Import the given nested-name-specifier from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent nested-name-specifier in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<NestedNameSpecifier *> Import(NestedNameSpecifier *FromNNS);\n\n    /// Import the given nested-name-specifier-loc from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent nested-name-specifier-loc in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<NestedNameSpecifierLoc>\n    Import(NestedNameSpecifierLoc FromNNS);\n\n    /// Import the given template name from the \"from\" context into the\n    /// \"to\" context, or the import error.\n    llvm::Expected<TemplateName> Import(TemplateName From);\n\n    /// Import the given source location from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent source location in the \"to\" context, or the\n    /// import error.\n    llvm::Expected<SourceLocation> Import(SourceLocation FromLoc);\n\n    /// Import the given source range from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent source range in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<SourceRange> Import(SourceRange FromRange);\n\n    /// Import the given declaration name from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent declaration name in the \"to\" context, or the\n    /// import error.\n    llvm::Expected<DeclarationName> Import(DeclarationName FromName);\n\n    /// Import the given identifier from the \"from\" context\n    /// into the \"to\" context.\n    ///\n    /// \\returns The equivalent identifier in the \"to\" context. Note: It\n    /// returns nullptr only if the FromId was nullptr.\n    IdentifierInfo *Import(const IdentifierInfo *FromId);\n\n    /// Import the given Objective-C selector from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent selector in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Selector> Import(Selector FromSel);\n\n    /// Import the given file ID from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent file ID in the source manager of the \"to\"\n    /// context, or the import error.\n    llvm::Expected<FileID> Import(FileID, bool IsBuiltin = false);\n\n    /// Import the given C++ constructor initializer from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent initializer in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<CXXCtorInitializer *> Import(CXXCtorInitializer *FromInit);\n\n    /// Import the given CXXBaseSpecifier from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent CXXBaseSpecifier in the source manager of the\n    /// \"to\" context, or the import error.\n    llvm::Expected<CXXBaseSpecifier *> Import(const CXXBaseSpecifier *FromSpec);\n\n    /// Import the given APValue from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\return the equivalent APValue in the \"to\" context or the import\n    /// error.\n    llvm::Expected<APValue> Import(const APValue &FromValue);\n\n    /// Import the definition of the given declaration, including all of\n    /// the declarations it contains.\n    [[nodiscard]] llvm::Error ImportDefinition(Decl *From);\n\n    /// Cope with a name conflict when importing a declaration into the\n    /// given context.\n    ///\n    /// This routine is invoked whenever there is a name conflict while\n    /// importing a declaration. The returned name will become the name of the\n    /// imported declaration. By default, the returned name is the same as the\n    /// original name, leaving the conflict unresolve such that name lookup\n    /// for this name is likely to find an ambiguity later.\n    ///\n    /// Subclasses may override this routine to resolve the conflict, e.g., by\n    /// renaming the declaration being imported.\n    ///\n    /// \\param Name the name of the declaration being imported, which conflicts\n    /// with other declarations.\n    ///\n    /// \\param DC the declaration context (in the \"to\" AST context) in which\n    /// the name is being imported.\n    ///\n    /// \\param IDNS the identifier namespace in which the name will be found.\n    ///\n    /// \\param Decls the set of declarations with the same name as the\n    /// declaration being imported.\n    ///\n    /// \\param NumDecls the number of conflicting declarations in \\p Decls.\n    ///\n    /// \\returns the name that the newly-imported declaration should have. Or\n    /// an error if we can't handle the name conflict.\n    virtual Expected<DeclarationName>\n    HandleNameConflict(DeclarationName Name, DeclContext *DC, unsigned IDNS,\n                       NamedDecl **Decls, unsigned NumDecls);\n\n    /// Retrieve the context that AST nodes are being imported into.\n    ASTContext &getToContext() const { return ToContext; }\n\n    /// Retrieve the context that AST nodes are being imported from.\n    ASTContext &getFromContext() const { return FromContext; }\n\n    /// Retrieve the file manager that AST nodes are being imported into.\n    FileManager &getToFileManager() const { return ToFileManager; }\n\n    /// Retrieve the file manager that AST nodes are being imported from.\n    FileManager &getFromFileManager() const { return FromFileManager; }\n\n    /// Report a diagnostic in the \"to\" context.\n    DiagnosticBuilder ToDiag(SourceLocation Loc, unsigned DiagID);\n\n    /// Report a diagnostic in the \"from\" context.\n    DiagnosticBuilder FromDiag(SourceLocation Loc, unsigned DiagID);\n\n    /// Return the set of declarations that we know are not equivalent.\n    NonEquivalentDeclSet &getNonEquivalentDecls() { return NonEquivalentDecls; }\n\n    /// Called for ObjCInterfaceDecl, ObjCProtocolDecl, and TagDecl.\n    /// Mark the Decl as complete, filling it in as much as possible.\n    ///\n    /// \\param D A declaration in the \"to\" context.\n    virtual void CompleteDecl(Decl* D);\n\n    /// Subclasses can override this function to observe all of the \\c From ->\n    /// \\c To declaration mappings as they are imported.\n    virtual void Imported(Decl *From, Decl *To) {}\n\n    void RegisterImportedDecl(Decl *FromD, Decl *ToD);\n\n    /// Store and assign the imported declaration to its counterpart.\n    /// It may happen that several decls from the 'from' context are mapped to\n    /// the same decl in the 'to' context.\n    Decl *MapImported(Decl *From, Decl *To);\n\n    /// Called by StructuralEquivalenceContext.  If a RecordDecl is\n    /// being compared to another RecordDecl as part of import, completing the\n    /// other RecordDecl may trigger importation of the first RecordDecl. This\n    /// happens especially for anonymous structs.  If the original of the second\n    /// RecordDecl can be found, we can complete it without the need for\n    /// importation, eliminating this loop.\n    virtual Decl *GetOriginalDecl(Decl *To) { return nullptr; }\n\n    /// Return if import of the given declaration has failed and if yes\n    /// the kind of the problem. This gives the first error encountered with\n    /// the node.\n    std::optional<ASTImportError> getImportDeclErrorIfAny(Decl *FromD) const;\n\n    /// Mark (newly) imported declaration with error.\n    void setImportDeclError(Decl *From, ASTImportError Error);\n\n    /// Determine whether the given types are structurally\n    /// equivalent.\n    bool IsStructurallyEquivalent(QualType From, QualType To,\n                                  bool Complain = true);\n\n    /// Determine the index of a field in its parent record.\n    /// F should be a field (or indirect field) declaration.\n    /// \\returns The index of the field in its parent context (starting from 0).\n    /// On error `std::nullopt` is returned (parent context is non-record).\n    static std::optional<unsigned> getFieldIndex(Decl *F);\n  }",
  "id": "BLOCK-CPP-07096",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTImporter.h",
  "source_line": 62,
  "validation_status": "validated"
}