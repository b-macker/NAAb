{
  "code": "{\n  // Base64 encodes three bytes of input at a time. If the input is not\n  // divisible by three, we pad as appropriate.\n  //\n  // Base64 encodes each three bytes of input into four bytes of output.\n  size_t len = (input_len / 3) * 4;\n\n  // Since all base 64 input is an integral number of octets, only the following\n  // cases can arise:\n  if (input_len % 3 == 0) {\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (1) the final quantum of encoding input is an integral multiple of 24\n    // bits; here, the final unit of encoded output will be an integral\n    // multiple of 4 characters with no \"=\" padding,\n  } else if (input_len % 3 == 1) {\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (2) the final quantum of encoding input is exactly 8 bits; here, the\n    // final unit of encoded output will be two characters followed by two\n    // \"=\" padding characters, or\n    len += 2;\n    if (do_padding) {\n      len += 2;\n    }\n  } else {  // (input_len % 3 == 2)\n    // (from https://tools.ietf.org/html/rfc3548)\n    // (3) the final quantum of encoding input is exactly 16 bits; here, the\n    // final unit of encoded output will be three characters followed by one\n    // \"=\" padding character.\n    len += 3;\n    if (do_padding) {\n      len += 1;\n    }\n  }\n\n  assert(len >= input_len);  // make sure we didn't overflow\n  return len;\n}",
  "id": "BLOCK-CPP-02937",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/escaping.cc",
  "source_line": 35,
  "validation_status": "validated"
}