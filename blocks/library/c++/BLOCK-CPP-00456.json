{
  "code": "{\n\ntemplate <typename Mutex>\nSPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(\n    filename_t base_filename,\n    std::size_t max_size,\n    std::size_t max_files,\n    bool rotate_on_open,\n    const file_event_handlers &event_handlers)\n    : base_filename_(std::move(base_filename)),\n      max_size_(max_size),\n      max_files_(max_files),\n      file_helper_{event_handlers} {\n    if (max_size == 0) {\n        throw_spdlog_ex(\"rotating sink constructor: max_size arg cannot be zero\");\n    }\n\n    if (max_files > 200000) {\n        throw_spdlog_ex(\"rotating sink constructor: max_files arg cannot exceed 200000\");\n    }\n    file_helper_.open(calc_filename(base_filename_, 0));\n    current_size_ = file_helper_.size();  // expensive. called only once\n    if (rotate_on_open && current_size_ > 0) {\n        rotate_();\n        current_size_ = 0;\n    }\n}\n\n// calc filename according to index and file extension if exists.\n// e.g. calc_filename(\"logs/mylog.txt, 3) => \"logs/mylog.3.txt\".\ntemplate <typename Mutex>\nSPDLOG_INLINE filename_t rotating_file_sink<Mutex>::calc_filename(const filename_t &filename,\n                                                                  std::size_t index) {\n    if (index == 0u) {\n        return filename;\n    }\n\n    filename_t basename, ext;\n    std::tie(basename, ext) = details::file_helper::split_by_extension(filename);\n    return fmt_lib::format(SPDLOG_FILENAME_T(\"{}.{}{}\"), basename, index, ext);\n}\n\ntemplate <typename Mutex>\nSPDLOG_INLINE filename_t rotating_file_sink<Mutex>::filename() {\n    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n    return file_helper_.filename();\n}\n\ntemplate <typename Mutex>\nSPDLOG_INLINE void rotating_file_sink<Mutex>::sink_it_(const details::log_msg &msg) {\n    memory_buf_t formatted;\n    base_sink<Mutex>::formatter_->format(msg, formatted);\n    auto new_size = current_size_ + formatted.size();\n\n    // rotate if the new estimated file size exceeds max size.\n    // rotate only if the real size > 0 to better deal with full disk (see issue #2261).\n    // we only check the real size when new_size > max_size_ because it is relatively expensive.\n    if (new_size > max_size_) {\n        file_helper_.flush();\n        if (file_helper_.size() > 0) {\n            rotate_();\n            new_size = formatted.size();\n        }\n    }\n    file_helper_.write(formatted);\n    current_size_ = new_size;\n}\n\ntemplate <typename Mutex>\nSPDLOG_INLINE void rotating_file_sink<Mutex>::flush_() {\n    file_helper_.flush();\n}\n\n// Rotate files:\n// log.txt -> log.1.txt\n// log.1.txt -> log.2.txt\n// log.2.txt -> log.3.txt\n// log.3.txt -> delete\ntemplate <typename Mutex>\nSPDLOG_INLINE void rotating_file_sink<Mutex>::rotate_() {\n    using details::os::filename_to_str;\n    using details::os::path_exists;\n\n    file_helper_.close();\n    for (auto i = max_files_; i > 0; --i) {\n        filename_t src = calc_filename(base_filename_, i - 1);\n        if (!path_exists(src)) {\n            continue;\n        }\n        filename_t target = calc_filename(base_filename_, i);\n\n        if (!rename_file_(src, target)) {\n            // if failed try again after a small delay.\n            // this is a workaround to a windows issue, where very high rotation\n            // rates can cause the rename to fail with permission denied (because of antivirus?).\n            details::os::sleep_for_millis(100);\n            if (!rename_file_(src, target)) {\n                file_helper_.reopen(\n                    true);  // truncate the log file anyway to prevent it to grow beyond its limit!\n                current_size_ = 0;\n                throw_spdlog_ex(\"rotating_file_sink: failed renaming \" + filename_to_str(src) +\n                                    \" to \" + filename_to_str(target),\n                                errno);\n            }\n        }\n    }\n    file_helper_.reopen(true);\n}\n\n// delete the target if exists, and rename the src file  to target\n// return true on success, false otherwise.\ntemplate <typename Mutex>\nSPDLOG_INLINE bool rotating_file_sink<Mutex>::rename_file_(const filename_t &src_filename,\n                                                           const filename_t &target_filename) {\n    // try to delete the target file in case it already exists.\n    (void)details::os::remove(target_filename);\n    return details::os::rename(src_filename, target_filename) == 0;\n}\n\n}",
  "id": "BLOCK-CPP-00456",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/rotating_file_sink-inl.h",
  "source_line": 24,
  "validation_status": "validated"
}