{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n//-----------------------------------------------------------------------------\n// crc32c_t\n//-----------------------------------------------------------------------------\n\n// `crc32c_t` defines a strongly-typed integer for holding a CRC32C value.\n//\n// Some operators are intentionally omitted. Only equality operators are defined\n// so that `crc32c_t` can be directly compared. Methods for putting `crc32c_t`\n// directly into a set are omitted because this is bug-prone due to checksum\n// collisions. Use an explicit conversion to the `uint32_t` space for operations\n// that treat `crc32c_t` as an integer.\nclass crc32c_t final {\n public:\n  crc32c_t() = default;\n  constexpr explicit crc32c_t(uint32_t crc) : crc_(crc) {}\n\n  crc32c_t(const crc32c_t&) = default;\n  crc32c_t& operator=(const crc32c_t&) = default;\n\n  explicit operator uint32_t() const { return crc_; }\n\n  friend bool operator==(crc32c_t lhs, crc32c_t rhs) {\n    return static_cast<uint32_t>(lhs) == static_cast<uint32_t>(rhs);\n  }\n\n  friend bool operator!=(crc32c_t lhs, crc32c_t rhs) { return !(lhs == rhs); }\n\n  template <typename Sink>\n  friend void AbslStringify(Sink& sink, crc32c_t crc) {\n    absl::Format(&sink, \"%08x\", static_cast<uint32_t>(crc));\n  }\n\n private:\n  uint32_t crc_;\n};\n\n\nnamespace crc_internal {\n// Non-inline code path for `absl::ExtendCrc32c()`. Do not call directly.\n// Call `absl::ExtendCrc32c()` (defined below) instead.\ncrc32c_t ExtendCrc32cInternal(crc32c_t initial_crc,\n                              absl::string_view buf_to_add);\n}  // namespace crc_internal\n\n// -----------------------------------------------------------------------------\n// CRC32C Computation Functions\n// -----------------------------------------------------------------------------\n\n// ComputeCrc32c()\n//\n// Returns the CRC32C value of the provided string.\ncrc32c_t ComputeCrc32c(absl::string_view buf);\n\n// ExtendCrc32c()\n//\n// Computes a CRC32C value from an `initial_crc` CRC32C value including the\n// `buf_to_add` bytes of an additional buffer. Using this function is more\n// efficient than computing a CRC32C value for the combined buffer from\n// scratch.\n//\n// Note: `ExtendCrc32c` with an initial_crc of 0 is equivalent to\n// `ComputeCrc32c`.\n//\n// This operation has a runtime cost of O(`buf_to_add.size()`)\ninline crc32c_t ExtendCrc32c(crc32c_t initial_crc,\n                             absl::string_view buf_to_add) {\n  // Approximately 75% of calls have size <= 64.\n  if (buf_to_add.size() <= 64) {\n    uint32_t crc = static_cast<uint32_t>(initial_crc);\n    if (crc_internal::ExtendCrc32cInline(&crc, buf_to_add.data(),\n                                         buf_to_add.size())) {\n      return crc32c_t{crc};\n    }\n  }\n  return crc_internal::ExtendCrc32cInternal(initial_crc, buf_to_add);\n}\n\n// ExtendCrc32cByZeroes()\n//\n// Computes a CRC32C value for a buffer with an `initial_crc` CRC32C value,\n// where `length` bytes with a value of 0 are appended to the buffer. Using this\n// function is more efficient than computing a CRC32C value for the combined\n// buffer from scratch.\n//\n// This operation has a runtime cost of O(log(`length`))\ncrc32c_t ExtendCrc32cByZeroes(crc32c_t initial_crc, size_t length);\n\n// MemcpyCrc32c()\n//\n// Copies `src` to `dest` using `memcpy()` semantics, returning the CRC32C\n// value of the copied buffer.\n//\n// Using `MemcpyCrc32c()` is potentially faster than performing the `memcpy()`\n// and `ComputeCrc32c()` operations separately.\ncrc32c_t MemcpyCrc32c(void* dest, const void* src, size_t count,\n                      crc32c_t initial_crc = crc32c_t{0});\n\n// -----------------------------------------------------------------------------\n// CRC32C Arithmetic Functions\n// -----------------------------------------------------------------------------\n\n// The following functions perform arithmetic on CRC32C values, which are\n// generally more efficient than recalculating any given result's CRC32C value.\n\n// ConcatCrc32c()\n//\n// Calculates the CRC32C value of two buffers with known CRC32C values\n// concatenated together.\n//\n// Given a buffer with CRC32C value `crc1` and a buffer with\n// CRC32C value `crc2` and length, `crc2_length`, returns the CRC32C value of\n// the concatenation of these two buffers.\n//\n// This operation has a runtime cost of O(log(`crc2_length`)).\ncrc32c_t ConcatCrc32c(crc32c_t crc1, crc32c_t crc2, size_t crc2_length);\n\n// RemoveCrc32cPrefix()\n//\n// Calculates the CRC32C value of an existing buffer with a series of bytes\n// (the prefix) removed from the beginning of that buffer.\n//\n// Given the CRC32C value of an existing buffer, `full_string_crc`; The CRC32C\n// value of a prefix of that buffer, `prefix_crc`; and the length of the buffer\n// with the prefix removed, `remaining_string_length` , return the CRC32C\n// value of the buffer with the prefix removed.\n//\n// This operation has a runtime cost of O(log(`remaining_string_length`)).\ncrc32c_t RemoveCrc32cPrefix(crc32c_t prefix_crc, crc32c_t full_string_crc,\n                            size_t remaining_string_length);\n// RemoveCrc32cSuffix()\n//\n// Calculates the CRC32C value of an existing buffer with a series of bytes\n// (the suffix) removed from the end of that buffer.\n//\n// Given a CRC32C value of an existing buffer `full_string_crc`, the CRC32C\n// value of the suffix to remove `suffix_crc`, and the length of that suffix\n// `suffix_len`, returns the CRC32C value of the buffer with suffix removed.\n//\n// This operation has a runtime cost of O(log(`suffix_len`))\ncrc32c_t RemoveCrc32cSuffix(crc32c_t full_string_crc, crc32c_t suffix_crc,\n                            size_t suffix_length);\n\n// operator<<\n//\n// Streams the CRC32C value `crc` to the stream `os`.\ninline std::ostream& operator<<(std::ostream& os, crc32c_t crc) {\n  return os << absl::StreamFormat(\"%08x\", static_cast<uint32_t>(crc));\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03569",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/crc32c.h",
  "source_line": 35,
  "validation_status": "validated"
}