{
  "code": "{\npublic:\n  static const unsigned InvalidDistance = TypoCorrection::InvalidDistance;\n\n  explicit CorrectionCandidateCallback(IdentifierInfo *Typo = nullptr,\n                                       NestedNameSpecifier *TypoNNS = nullptr)\n      : Typo(Typo), TypoNNS(TypoNNS) {}\n\n  virtual ~CorrectionCandidateCallback() = default;\n\n  /// Simple predicate used by the default RankCandidate to\n  /// determine whether to return an edit distance of 0 or InvalidDistance.\n  /// This can be overridden by validators that only need to determine if a\n  /// candidate is viable, without ranking potentially viable candidates.\n  /// Only ValidateCandidate or RankCandidate need to be overridden by a\n  /// callback wishing to check the viability of correction candidates.\n  /// The default predicate always returns true if the candidate is not a type\n  /// name or keyword, true for types if WantTypeSpecifiers is true, and true\n  /// for keywords if WantTypeSpecifiers, WantExpressionKeywords,\n  /// WantCXXNamedCasts, WantRemainingKeywords, or WantObjCSuper is true.\n  virtual bool ValidateCandidate(const TypoCorrection &candidate);\n\n  /// Method used by Sema::CorrectTypo to assign an \"edit distance\" rank\n  /// to a candidate (where a lower value represents a better candidate), or\n  /// returning InvalidDistance if the candidate is not at all viable. For\n  /// validation callbacks that only need to determine if a candidate is viable,\n  /// the default RankCandidate returns either 0 or InvalidDistance depending\n  /// whether ValidateCandidate returns true or false.\n  virtual unsigned RankCandidate(const TypoCorrection &candidate) {\n    return (!MatchesTypo(candidate) && ValidateCandidate(candidate))\n               ? 0\n               : InvalidDistance;\n  }\n\n  /// Clone this CorrectionCandidateCallback. CorrectionCandidateCallbacks are\n  /// initially stack-allocated. However in case where delayed typo-correction\n  /// is done we need to move the callback to storage with a longer lifetime.\n  /// Every class deriving from CorrectionCandidateCallback must implement\n  /// this method.\n  virtual std::unique_ptr<CorrectionCandidateCallback> clone() = 0;\n\n  void setTypoName(IdentifierInfo *II) { Typo = II; }\n  void setTypoNNS(NestedNameSpecifier *NNS) { TypoNNS = NNS; }\n\n  // Flags for context-dependent keywords. WantFunctionLikeCasts is only\n  // used/meaningful when WantCXXNamedCasts is false.\n  // TODO: Expand these to apply to non-keywords or possibly remove them.\n  bool WantTypeSpecifiers = true;\n  bool WantExpressionKeywords = true;\n  bool WantCXXNamedCasts = true;\n  bool WantFunctionLikeCasts = true;\n  bool WantRemainingKeywords = true;\n  bool WantObjCSuper = false;\n  // Temporary hack for the one case where a CorrectTypoContext enum is used\n  // when looking up results.\n  bool IsObjCIvarLookup = false;\n  bool IsAddressOfOperand = false;\n\nprotected:\n  bool MatchesTypo(const TypoCorrection &candidate) {\n    return Typo && candidate.isResolved() && !candidate.requiresImport() &&\n           candidate.getCorrectionAsIdentifierInfo() == Typo &&\n           // FIXME: This probably does not return true when both\n           // NestedNameSpecifiers have the same textual representation.\n           candidate.getCorrectionSpecifier() == TypoNNS;\n  }\n\n  IdentifierInfo *Typo;\n  NestedNameSpecifier *TypoNNS;\n}",
  "id": "BLOCK-CPP-20767",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/TypoCorrection.h",
  "source_line": 281,
  "validation_status": "validated"
}