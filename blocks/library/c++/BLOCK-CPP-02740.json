{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace log_internal {\nnamespace {\n\n// Returns a mutable reference to a thread-local variable that should be true if\n// a globally-registered `LogSink`'s `Send()` is currently being invoked on this\n// thread.\nbool& ThreadIsLoggingStatus() {\n#ifdef ABSL_HAVE_THREAD_LOCAL\n  ABSL_CONST_INIT thread_local bool thread_is_logging = false;\n  return thread_is_logging;\n#else\n  ABSL_CONST_INIT static pthread_key_t thread_is_logging_key;\n  static const bool unused = [] {\n    if (pthread_key_create(&thread_is_logging_key, [](void* data) {\n          delete reinterpret_cast<bool*>(data);\n        })) {\n      perror(\"pthread_key_create failed!\");\n      abort();\n    }\n    return true;\n  }();\n  (void)unused;  // Fixes -wunused-variable warning\n  bool* thread_is_logging_ptr =\n      reinterpret_cast<bool*>(pthread_getspecific(thread_is_logging_key));\n\n  if (ABSL_PREDICT_FALSE(!thread_is_logging_ptr)) {\n    thread_is_logging_ptr = new bool{false};\n    if (pthread_setspecific(thread_is_logging_key, thread_is_logging_ptr)) {\n      perror(\"pthread_setspecific failed\");\n      abort();\n    }\n  }\n  return *thread_is_logging_ptr;\n#endif\n}\n\nclass StderrLogSink final : public LogSink {\n public:\n  ~StderrLogSink() override = default;\n\n  void Send(const absl::LogEntry& entry) override {\n    if (entry.log_severity() < absl::StderrThreshold() &&\n        absl::log_internal::IsInitialized()) {\n      return;\n    }\n\n    ABSL_CONST_INIT static absl::once_flag warn_if_not_initialized;\n    absl::call_once(warn_if_not_initialized, []() {\n      if (absl::log_internal::IsInitialized()) return;\n      const char w[] =\n          \"WARNING: All log messages before absl::InitializeLog() is called\"\n          \" are written to STDERR\\n\";\n      absl::log_internal::WriteToStderr(w, absl::LogSeverity::kWarning);\n    });\n\n    if (!entry.stacktrace().empty()) {\n      absl::log_internal::WriteToStderr(entry.stacktrace(),\n                                        entry.log_severity());\n    } else {\n      // TODO(b/226937039): do this outside else condition once we avoid\n      // ReprintFatalMessage\n      absl::log_internal::WriteToStderr(\n          entry.text_message_with_prefix_and_newline(), entry.log_severity());\n    }\n  }\n};\n\n#if defined(__ANDROID__)\nclass AndroidLogSink final : public LogSink {\n public:\n  ~AndroidLogSink() override = default;\n\n  void Send(const absl::LogEntry& entry) override {\n    const int level = AndroidLogLevel(entry);\n    const char* const tag = GetAndroidNativeTag();\n    __android_log_write(level, tag,\n                        entry.text_message_with_prefix_and_newline_c_str());\n    if (entry.log_severity() == absl::LogSeverity::kFatal)\n      __android_log_write(ANDROID_LOG_FATAL, tag, \"terminating.\\n\");\n  }\n\n private:\n  static int AndroidLogLevel(const absl::LogEntry& entry) {\n    switch (entry.log_severity()) {\n      case absl::LogSeverity::kFatal:\n        return ANDROID_LOG_FATAL;\n      case absl::LogSeverity::kError:\n        return ANDROID_LOG_ERROR;\n      case absl::LogSeverity::kWarning:\n        return ANDROID_LOG_WARN;\n      default:\n        if (entry.verbosity() >= 2) return ANDROID_LOG_VERBOSE;\n        if (entry.verbosity() == 1) return ANDROID_LOG_DEBUG;\n        return ANDROID_LOG_INFO;\n    }\n  }\n};\n#endif  // !defined(__ANDROID__)\n\n#if defined(_WIN32)\nclass WindowsDebuggerLogSink final : public LogSink {\n public:\n  ~WindowsDebuggerLogSink() override = default;\n\n  void Send(const absl::LogEntry& entry) override {\n    if (entry.log_severity() < absl::StderrThreshold() &&\n        absl::log_internal::IsInitialized()) {\n      return;\n    }\n    ::OutputDebugStringA(entry.text_message_with_prefix_and_newline_c_str());\n  }\n};\n#endif  // !defined(_WIN32)\n\nclass GlobalLogSinkSet final {\n public:\n  GlobalLogSinkSet() {\n#if defined(__myriad2__) || defined(__Fuchsia__)\n    // myriad2 and Fuchsia do not log to stderr by default.\n#else\n    static absl::NoDestructor<StderrLogSink> stderr_log_sink;\n    AddLogSink(stderr_log_sink.get());\n#endif\n#ifdef __ANDROID__\n    static absl::NoDestructor<AndroidLogSink> android_log_sink;\n    AddLogSink(android_log_sink.get());\n#endif\n#if defined(_WIN32)\n    static absl::NoDestructor<WindowsDebuggerLogSink> debugger_log_sink;\n    AddLogSink(debugger_log_sink.get());\n#endif  // !defined(_WIN32)\n  }\n\n  void LogToSinks(const absl::LogEntry& entry,\n                  absl::Span<absl::LogSink*> extra_sinks, bool extra_sinks_only)\n      ABSL_LOCKS_EXCLUDED(guard_) {\n    SendToSinks(entry, extra_sinks);\n\n    if (!extra_sinks_only) {\n      if (ThreadIsLoggingToLogSink()) {\n        absl::log_internal::WriteToStderr(\n            entry.text_message_with_prefix_and_newline(), entry.log_severity());\n      } else {\n        absl::ReaderMutexLock global_sinks_lock(&guard_);\n        ThreadIsLoggingStatus() = true;\n        // Ensure the \"thread is logging\" status is reverted upon leaving the\n        // scope even in case of exceptions.\n        auto status_cleanup =\n            absl::MakeCleanup([] { ThreadIsLoggingStatus() = false; });\n        SendToSinks(entry, absl::MakeSpan(sinks_));\n      }\n    }\n  }\n\n  void AddLogSink(absl::LogSink* sink) ABSL_LOCKS_EXCLUDED(guard_) {\n    {\n      absl::WriterMutexLock global_sinks_lock(&guard_);\n      auto pos = std::find(sinks_.begin(), sinks_.end(), sink);\n      if (pos == sinks_.end()) {\n        sinks_.push_back(sink);\n        return;\n      }\n    }\n    ABSL_INTERNAL_LOG(FATAL, \"Duplicate log sinks are not supported\");\n  }\n\n  void RemoveLogSink(absl::LogSink* sink) ABSL_LOCKS_EXCLUDED(guard_) {\n    {\n      absl::WriterMutexLock global_sinks_lock(&guard_);\n      auto pos = std::find(sinks_.begin(), sinks_.end(), sink);\n      if (pos != sinks_.end()) {\n        sinks_.erase(pos);\n        return;\n      }\n    }\n    ABSL_INTERNAL_LOG(FATAL, \"Mismatched log sink being removed\");\n  }\n\n  void FlushLogSinks() ABSL_LOCKS_EXCLUDED(guard_) {\n    if (ThreadIsLoggingToLogSink()) {\n      // The thread_local condition demonstrates that we're already holding the\n      // lock in order to iterate over `sinks_` for dispatch.  The thread-safety\n      // annotations don't know this, so we use `ABSL_NO_THREAD_SAFETY_ANALYSIS`\n      guard_.AssertReaderHeld();\n      FlushLogSinksLocked();\n    } else {\n      absl::ReaderMutexLock global_sinks_lock(&guard_);\n      // In case if LogSink::Flush overload decides to log\n      ThreadIsLoggingStatus() = true;\n      // Ensure the \"thread is logging\" status is reverted upon leaving the\n      // scope even in case of exceptions.\n      auto status_cleanup =\n          absl::MakeCleanup([] { ThreadIsLoggingStatus() = false; });\n      FlushLogSinksLocked();\n    }\n  }\n\n private:\n  void FlushLogSinksLocked() ABSL_SHARED_LOCKS_REQUIRED(guard_) {\n    for (absl::LogSink* sink : sinks_) {\n      sink->Flush();\n    }\n  }\n\n  // Helper routine for LogToSinks.\n  static void SendToSinks(const absl::LogEntry& entry,\n                          absl::Span<absl::LogSink*> sinks) {\n    for (absl::LogSink* sink : sinks) {\n      sink->Send(entry);\n    }\n  }\n\n  using LogSinksSet = std::vector<absl::LogSink*>;\n  absl::Mutex guard_;\n  LogSinksSet sinks_ ABSL_GUARDED_BY(guard_);\n};\n\n// Returns reference to the global LogSinks set.\nGlobalLogSinkSet& GlobalSinks() {\n  static absl::NoDestructor<GlobalLogSinkSet> global_sinks;\n  return *global_sinks;\n}\n\n}  // namespace\n\nbool ThreadIsLoggingToLogSink() { return ThreadIsLoggingStatus(); }\n\nvoid LogToSinks(const absl::LogEntry& entry,\n                absl::Span<absl::LogSink*> extra_sinks, bool extra_sinks_only) {\n  log_internal::GlobalSinks().LogToSinks(entry, extra_sinks, extra_sinks_only);\n}\n\nvoid AddLogSink(absl::LogSink* sink) {\n  log_internal::GlobalSinks().AddLogSink(sink);\n}\n\nvoid RemoveLogSink(absl::LogSink* sink) {\n  log_internal::GlobalSinks().RemoveLogSink(sink);\n}\n\nvoid FlushLogSinks() { log_internal::GlobalSinks().FlushLogSinks(); }\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02740",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/log_sink_set.cc",
  "source_line": 50,
  "validation_status": "validated"
}