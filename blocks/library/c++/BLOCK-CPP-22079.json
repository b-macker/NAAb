{
  "code": "{\n\nclass BumpVectorContext {\n  llvm::PointerIntPair<llvm::BumpPtrAllocator*, 1> Alloc;\n\npublic:\n  /// Construct a new BumpVectorContext that creates a new BumpPtrAllocator\n  /// and destroys it when the BumpVectorContext object is destroyed.\n  BumpVectorContext() : Alloc(new llvm::BumpPtrAllocator(), 1) {}\n\n  BumpVectorContext(BumpVectorContext &&Other) : Alloc(Other.Alloc) {\n    Other.Alloc.setInt(false);\n    Other.Alloc.setPointer(nullptr);\n  }\n\n  // The move assignment operator is defined as deleted pending further\n  // motivation.\n  BumpVectorContext &operator=(BumpVectorContext &&) = delete;\n\n  // The copy constrcutor and copy assignment operator is defined as deleted\n  // pending further motivation.\n  BumpVectorContext(const BumpVectorContext &) = delete;\n  BumpVectorContext &operator=(const BumpVectorContext &) = delete;\n\n  /// Construct a new BumpVectorContext that reuses an existing\n  /// BumpPtrAllocator.  This BumpPtrAllocator is not destroyed when the\n  /// BumpVectorContext object is destroyed.\n  BumpVectorContext(llvm::BumpPtrAllocator &A) : Alloc(&A, 0) {}\n\n  ~BumpVectorContext() {\n    if (Alloc.getInt())\n      delete Alloc.getPointer();\n  }\n\n  llvm::BumpPtrAllocator &getAllocator() { return *Alloc.getPointer(); }\n};\n\ntemplate<typename T>\nclass BumpVector {\n  T *Begin = nullptr;\n  T *End = nullptr;\n  T *Capacity = nullptr;\n\npublic:\n  // Default ctor - Initialize to empty.\n  explicit BumpVector(BumpVectorContext &C, unsigned N) {\n    reserve(C, N);\n  }\n\n  ~BumpVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, BumpVectorContext &C) {\n    if (End < Capacity) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  /// insert - Insert some number of copies of element into a position. Return\n  /// iterator to position after last inserted copy.\n  iterator insert(iterator I, size_t Cnt, const_reference E,\n      BumpVectorContext &C) {\n    assert(I >= Begin && I <= End && \"Iterator out of bounds.\");\n    if (End + Cnt <= Capacity) {\n    Retry:\n      move_range_right(I, End, Cnt);\n      construct_range(I, I + Cnt, E);\n      End += Cnt;\n      return I + Cnt;\n    }\n    ptrdiff_t D = I - Begin;\n    grow(C, size() + Cnt);\n    I = Begin + D;\n    goto Retry;\n  }\n\n  void reserve(BumpVectorContext &C, unsigned N) {\n    if (unsigned(Capacity-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return Capacity - Begin; }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(BumpVectorContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\n  void move_range_right(T *S, T *E, size_t D) {\n    for (T *I = E + D - 1, *IL = S + D - 1; I != IL; --I) {\n      --E;\n      new (I) T(*E);\n      E->~T();\n    }\n  }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T>\nvoid BumpVector<T>::grow(BumpVectorContext &C, size_t MinSize) {\n  size_t CurCapacity = Capacity-Begin;\n  size_t CurSize = size();\n  size_t NewCapacity = 2*CurCapacity;\n  if (NewCapacity < MinSize)\n    NewCapacity = MinSize;\n\n  // Allocate the memory from the BumpPtrAllocator.\n  T *NewElts = C.getAllocator().template Allocate<T>(NewCapacity);\n\n  // Copy the elements over.\n  if (Begin != End) {\n    if (std::is_class<T>::value) {\n      std::uninitialized_copy(Begin, End, NewElts);\n      // Destroy the original elements.\n      destroy_range(Begin, End);\n    } else {\n      // Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).\n      memcpy(NewElts, Begin, CurSize * sizeof(T));\n    }\n  }\n\n  // For now, leak 'Begin'.  We can add it back to a freelist in\n  // BumpVectorContext.\n  Begin = NewElts;\n  End = NewElts+CurSize;\n  Capacity = Begin+NewCapacity;\n}\n\n}",
  "id": "BLOCK-CPP-22079",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Support/BumpVector.h",
  "source_line": 30,
  "validation_status": "validated"
}