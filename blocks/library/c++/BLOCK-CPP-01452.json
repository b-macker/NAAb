{
  "code": "{\n  char* buf;\n  int size;\n  int precision;\n  int exp10;\n  bool fixed;\n\n  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,\n                                        uint64_t remainder, uint64_t error,\n                                        bool integral) {\n    FMT_ASSERT(remainder < divisor, \"\");\n    buf[size++] = digit;\n    if (!integral && error >= remainder) return digits::error;\n    if (size < precision) return digits::more;\n    if (!integral) {\n      // Check if error * 2 < divisor with overflow prevention.\n      // The check is not needed for the integral part because error = 1\n      // and divisor > (1 << 32) there.\n      if (error >= divisor || error >= divisor - error) return digits::error;\n    } else {\n      FMT_ASSERT(error == 1 && divisor > 2, \"\");\n    }\n    auto dir = get_round_direction(divisor, remainder, error);\n    if (dir != round_direction::up)\n      return dir == round_direction::down ? digits::done : digits::error;\n    ++buf[size - 1];\n    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {\n      buf[i] = '0';\n      ++buf[i - 1];\n    }\n    if (buf[0] > '9') {\n      buf[0] = '1';\n      if (fixed)\n        buf[size++] = '0';\n      else\n        ++exp10;\n    }\n    return digits::done;\n  }\n}",
  "id": "BLOCK-CPP-01452",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 2563,
  "validation_status": "validated"
}