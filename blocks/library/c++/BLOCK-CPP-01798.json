{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nABSL_DLL const uint128 kuint128max = MakeUint128(\n    std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max());\n\nnamespace {\n\n// Returns the 0-based position of the last set bit (i.e., most significant bit)\n// in the given uint128. The argument is not 0.\n//\n// For example:\n//   Given: 5 (decimal) == 101 (binary)\n//   Returns: 2\ninline ABSL_ATTRIBUTE_ALWAYS_INLINE int Fls128(uint128 n) {\n  if (uint64_t hi = Uint128High64(n)) {\n    ABSL_ASSUME(hi != 0);\n    return 127 - countl_zero(hi);\n  }\n  const uint64_t low = Uint128Low64(n);\n  ABSL_ASSUME(low != 0);\n  return 63 - countl_zero(low);\n}\n\n// Long division/modulo for uint128 implemented using the shift-subtract\n// division algorithm adapted from:\n// https://stackoverflow.com/questions/5386377/division-without-using\ninline void DivModImpl(uint128 dividend, uint128 divisor, uint128* quotient_ret,\n                       uint128* remainder_ret) {\n  assert(divisor != 0);\n\n  if (divisor > dividend) {\n    *quotient_ret = 0;\n    *remainder_ret = dividend;\n    return;\n  }\n\n  if (divisor == dividend) {\n    *quotient_ret = 1;\n    *remainder_ret = 0;\n    return;\n  }\n\n  uint128 denominator = divisor;\n  uint128 quotient = 0;\n\n  // Left aligns the MSB of the denominator and the dividend.\n  const int shift = Fls128(dividend) - Fls128(denominator);\n  denominator <<= shift;\n\n  // Uses shift-subtract algorithm to divide dividend by denominator. The\n  // remainder will be left in dividend.\n  for (int i = 0; i <= shift; ++i) {\n    quotient <<= 1;\n    if (dividend >= denominator) {\n      dividend -= denominator;\n      quotient |= 1;\n    }\n    denominator >>= 1;\n  }\n\n  *quotient_ret = quotient;\n  *remainder_ret = dividend;\n}\n\ntemplate <typename T>\nuint128 MakeUint128FromFloat(T v) {\n  static_assert(std::is_floating_point<T>::value, \"\");\n\n  // Rounding behavior is towards zero, same as for built-in types.\n\n  // Undefined behavior if v is NaN or cannot fit into uint128.\n  assert(std::isfinite(v) && v > -1 &&\n         (std::numeric_limits<T>::max_exponent <= 128 ||\n          v < std::ldexp(static_cast<T>(1), 128)));\n\n  if (v >= std::ldexp(static_cast<T>(1), 64)) {\n    uint64_t hi = static_cast<uint64_t>(std::ldexp(v, -64));\n    uint64_t lo = static_cast<uint64_t>(v - std::ldexp(static_cast<T>(hi), 64));\n    return MakeUint128(hi, lo);\n  }\n\n  return MakeUint128(0, static_cast<uint64_t>(v));\n}\n\n#if defined(__clang__) && (__clang_major__ < 9) && !defined(__SSE3__)\n// Workaround for clang bug: https://bugs.llvm.org/show_bug.cgi?id=38289\n// Casting from long double to uint64_t is miscompiled and drops bits.\n// It is more work, so only use when we need the workaround.\nuint128 MakeUint128FromFloat(long double v) {\n  // Go 50 bits at a time, that fits in a double\n  static_assert(std::numeric_limits<double>::digits >= 50, \"\");\n  static_assert(std::numeric_limits<long double>::digits <= 150, \"\");\n  // Undefined behavior if v is not finite or cannot fit into uint128.\n  assert(std::isfinite(v) && v > -1 && v < std::ldexp(1.0L, 128));\n\n  v = std::ldexp(v, -100);\n  uint64_t w0 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  v = std::ldexp(v - static_cast<double>(w0), 50);\n  uint64_t w1 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  v = std::ldexp(v - static_cast<double>(w1), 50);\n  uint64_t w2 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));\n  return (static_cast<uint128>(w0) << 100) | (static_cast<uint128>(w1) << 50) |\n         static_cast<uint128>(w2);\n}\n#endif  // __clang__ && (__clang_major__ < 9) && !__SSE3__\n}  // namespace\n\nuint128::uint128(float v) : uint128(MakeUint128FromFloat(v)) {}\nuint128::uint128(double v) : uint128(MakeUint128FromFloat(v)) {}\nuint128::uint128(long double v) : uint128(MakeUint128FromFloat(v)) {}\n\n#if !defined(ABSL_HAVE_INTRINSIC_INT128)\nuint128 operator/(uint128 lhs, uint128 rhs) {\n  uint128 quotient = 0;\n  uint128 remainder = 0;\n  DivModImpl(lhs, rhs, &quotient, &remainder);\n  return quotient;\n}\n\nuint128 operator%(uint128 lhs, uint128 rhs) {\n  uint128 quotient = 0;\n  uint128 remainder = 0;\n  DivModImpl(lhs, rhs, &quotient, &remainder);\n  return remainder;\n}\n#endif  // !defined(ABSL_HAVE_INTRINSIC_INT128)\n\nnamespace {\n\nstd::string Uint128ToFormattedString(uint128 v, std::ios_base::fmtflags flags) {\n  // Select a divisor which is the largest power of the base < 2^64.\n  uint128 div;\n  int div_base_log;\n  switch (flags & std::ios::basefield) {\n    case std::ios::hex:\n      div = 0x1000000000000000;  // 16^15\n      div_base_log = 15;\n      break;\n    case std::ios::oct:\n      div = 01000000000000000000000;  // 8^21\n      div_base_log = 21;\n      break;\n    default:  // std::ios::dec\n      div = 10000000000000000000u;  // 10^19\n      div_base_log = 19;\n      break;\n  }\n\n  // Now piece together the uint128 representation from three chunks of the\n  // original value, each less than \"div\" and therefore representable as a\n  // uint64_t.\n  std::ostringstream os;\n  std::ios_base::fmtflags copy_mask =\n      std::ios::basefield | std::ios::showbase | std::ios::uppercase;\n  os.setf(flags & copy_mask, copy_mask);\n  uint128 high = v;\n  uint128 low;\n  DivModImpl(high, div, &high, &low);\n  uint128 mid;\n  DivModImpl(high, div, &high, &mid);\n  if (Uint128Low64(high) != 0) {\n    os << Uint128Low64(high);\n    os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);\n    os << Uint128Low64(mid);\n    os << std::setw(div_base_log);\n  } else if (Uint128Low64(mid) != 0) {\n    os << Uint128Low64(mid);\n    os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);\n  }\n  os << Uint128Low64(low);\n  return os.str();\n}\n\n}  // namespace\n\nstd::string uint128::ToString() const {\n  return Uint128ToFormattedString(*this, std::ios_base::dec);\n}\n\nstd::ostream& operator<<(std::ostream& os, uint128 v) {\n  std::ios_base::fmtflags flags = os.flags();\n  std::string rep = Uint128ToFormattedString(v, flags);\n\n  // Add the requisite padding.\n  std::streamsize width = os.width(0);\n  if (static_cast<size_t>(width) > rep.size()) {\n    const size_t count = static_cast<size_t>(width) - rep.size();\n    std::ios::fmtflags adjustfield = flags & std::ios::adjustfield;\n    if (adjustfield == std::ios::left) {\n      rep.append(count, os.fill());\n    } else if (adjustfield == std::ios::internal &&\n               (flags & std::ios::showbase) &&\n               (flags & std::ios::basefield) == std::ios::hex && v != 0) {\n      rep.insert(size_t{2}, count, os.fill());\n    } else {\n      rep.insert(size_t{0}, count, os.fill());\n    }\n  }\n\n  return os << rep;\n}\n\nnamespace {\n\nuint128 UnsignedAbsoluteValue(int128 v) {\n  // Cast to uint128 before possibly negating because -Int128Min() is undefined.\n  return Int128High64(v) < 0 ? -uint128(v) : uint128(v);\n}\n\n}  // namespace\n\n#if !defined(ABSL_HAVE_INTRINSIC_INT128)\nnamespace {\n\ntemplate <typename T>\nint128 MakeInt128FromFloat(T v) {\n  // Conversion when v is NaN or cannot fit into int128 would be undefined\n  // behavior if using an intrinsic 128-bit integer.\n  assert(std::isfinite(v) && (std::numeric_limits<T>::max_exponent <= 127 ||\n                              (v >= -std::ldexp(static_cast<T>(1), 127) &&\n                               v < std::ldexp(static_cast<T>(1), 127))));\n\n  // We must convert the absolute value and then negate as needed, because\n  // floating point types are typically sign-magnitude. Otherwise, the\n  // difference between the high and low 64 bits when interpreted as two's\n  // complement overwhelms the precision of the mantissa.\n  uint128 result = v < 0 ? -MakeUint128FromFloat(-v) : MakeUint128FromFloat(v);\n  return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(result)),\n                    Uint128Low64(result));\n}\n\n}  // namespace\n\nint128::int128(float v) : int128(MakeInt128FromFloat(v)) {}\nint128::int128(double v) : int128(MakeInt128FromFloat(v)) {}\nint128::int128(long double v) : int128(MakeInt128FromFloat(v)) {}\n\nint128 operator/(int128 lhs, int128 rhs) {\n  assert(lhs != Int128Min() || rhs != -1);  // UB on two's complement.\n\n  uint128 quotient = 0;\n  uint128 remainder = 0;\n  DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),\n             &quotient, &remainder);\n  if ((Int128High64(lhs) < 0) != (Int128High64(rhs) < 0)) quotient = -quotient;\n  return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(quotient)),\n                    Uint128Low64(quotient));\n}\n\nint128 operator%(int128 lhs, int128 rhs) {\n  assert(lhs != Int128Min() || rhs != -1);  // UB on two's complement.\n\n  uint128 quotient = 0;\n  uint128 remainder = 0;\n  DivModImpl(UnsignedAbsoluteValue(lhs), UnsignedAbsoluteValue(rhs),\n             &quotient, &remainder);\n  if (Int128High64(lhs) < 0) remainder = -remainder;\n  return MakeInt128(int128_internal::BitCastToSigned(Uint128High64(remainder)),\n                    Uint128Low64(remainder));\n}\n#endif  // ABSL_HAVE_INTRINSIC_INT128\n\nstd::string int128::ToString() const {\n  std::string rep;\n  if (Int128High64(*this) < 0) rep = \"-\";\n  rep.append(Uint128ToFormattedString(UnsignedAbsoluteValue(*this),\n                                      std::ios_base::dec));\n  return rep;\n}\n\nstd::ostream& operator<<(std::ostream& os, int128 v) {\n  std::ios_base::fmtflags flags = os.flags();\n  std::string rep;\n\n  // Add the sign if needed.\n  bool print_as_decimal =\n      (flags & std::ios::basefield) == std::ios::dec ||\n      (flags & std::ios::basefield) == std::ios_base::fmtflags();\n  if (print_as_decimal) {\n    if (Int128High64(v) < 0) {\n      rep = \"-\";\n    } else if (flags & std::ios::showpos) {\n      rep = \"+\";\n    }\n  }\n\n  rep.append(Uint128ToFormattedString(\n      print_as_decimal ? UnsignedAbsoluteValue(v) : uint128(v), os.flags()));\n\n  // Add the requisite padding.\n  std::streamsize width = os.width(0);\n  if (static_cast<size_t>(width) > rep.size()) {\n    const size_t count = static_cast<size_t>(width) - rep.size();\n    switch (flags & std::ios::adjustfield) {\n      case std::ios::left:\n        rep.append(count, os.fill());\n        break;\n      case std::ios::internal:\n        if (print_as_decimal && (rep[0] == '+' || rep[0] == '-')) {\n          rep.insert(size_t{1}, count, os.fill());\n        } else if ((flags & std::ios::basefield) == std::ios::hex &&\n                   (flags & std::ios::showbase) && v != 0) {\n          rep.insert(size_t{2}, count, os.fill());\n        } else {\n          rep.insert(size_t{0}, count, os.fill());\n        }\n        break;\n      default:  // std::ios::right\n        rep.insert(size_t{0}, count, os.fill());\n        break;\n    }\n  }\n\n  return os << rep;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-01798",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/numeric/int128.cc",
  "source_line": 29,
  "validation_status": "validated"
}