{
  "code": "{\n    /// The current pool of diagnostics into which delayed\n    /// diagnostics should go.\n    sema::DelayedDiagnosticPool *CurPool = nullptr;\n\n  public:\n    DelayedDiagnostics() = default;\n\n    /// Adds a delayed diagnostic.\n    void add(const sema::DelayedDiagnostic &diag); // in DelayedDiagnostic.h\n\n    /// Determines whether diagnostics should be delayed.\n    bool shouldDelayDiagnostics() { return CurPool != nullptr; }\n\n    /// Returns the current delayed-diagnostics pool.\n    sema::DelayedDiagnosticPool *getCurrentPool() const {\n      return CurPool;\n    }\n\n    /// Enter a new scope.  Access and deprecation diagnostics will be\n    /// collected in this pool.\n    DelayedDiagnosticsState push(sema::DelayedDiagnosticPool &pool) {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = &pool;\n      return state;\n    }\n\n    /// Leave a delayed-diagnostic state that was previously pushed.\n    /// Do not emit any of the diagnostics.  This is performed as part\n    /// of the bookkeeping of popping a pool \"properly\".\n    void popWithoutEmitting(DelayedDiagnosticsState state) {\n      CurPool = state.SavedPool;\n    }\n\n    /// Enter a new scope where access and deprecation diagnostics are\n    /// not delayed.\n    DelayedDiagnosticsState pushUndelayed() {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = nullptr;\n      return state;\n    }\n\n    /// Undo a previous pushUndelayed().\n    void popUndelayed(DelayedDiagnosticsState state) {\n      assert(CurPool == nullptr);\n      CurPool = state.SavedPool;\n    }\n  }",
  "id": "BLOCK-CPP-20516",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Sema.h",
  "source_line": 967,
  "validation_status": "validated"
}