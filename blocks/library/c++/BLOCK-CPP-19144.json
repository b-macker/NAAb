{
  "code": "{\npublic:\n  std::vector<std::pair<std::string, bool/*isUndef*/>> Macros;\n  std::vector<std::string> Includes;\n  std::vector<std::string> MacroIncludes;\n\n  /// Perform extra checks when loading PCM files for mutable file systems.\n  bool ModulesCheckRelocated = true;\n\n  /// Initialize the preprocessor with the compiler and target specific\n  /// predefines.\n  bool UsePredefines = true;\n\n  /// Whether we should maintain a detailed record of all macro\n  /// definitions and expansions.\n  bool DetailedRecord = false;\n\n  /// When true, we are creating or using a PCH where a #pragma hdrstop is\n  /// expected to indicate the beginning or end of the PCH.\n  bool PCHWithHdrStop = false;\n\n  /// When true, we are creating a PCH or creating the PCH object while\n  /// expecting a #pragma hdrstop to separate the two.  Allow for a\n  /// missing #pragma hdrstop, which generates a PCH for the whole file,\n  /// and creates an empty PCH object.\n  bool PCHWithHdrStopCreate = false;\n\n  /// If non-empty, the filename used in an #include directive in the primary\n  /// source file (or command-line preinclude) that is used to implement\n  /// MSVC-style precompiled headers. When creating a PCH, after the #include\n  /// of this header, the PCH generation stops. When using a PCH, tokens are\n  /// skipped until after an #include of this header is seen.\n  std::string PCHThroughHeader;\n\n  /// The implicit PCH included at the start of the translation unit, or empty.\n  std::string ImplicitPCHInclude;\n\n  /// Headers that will be converted to chained PCHs in memory.\n  std::vector<std::string> ChainedIncludes;\n\n  /// Whether to disable most of the normal validation performed on\n  /// precompiled headers and module files.\n  DisableValidationForModuleKind DisablePCHOrModuleValidation =\n      DisableValidationForModuleKind::None;\n\n  /// When true, a PCH with compiler errors will not be rejected.\n  bool AllowPCHWithCompilerErrors = false;\n\n  /// When true, a PCH with modules cache path different to the current\n  /// compilation will not be rejected.\n  bool AllowPCHWithDifferentModulesCachePath = false;\n\n  /// Dump declarations that are deserialized from PCH, for testing.\n  bool DumpDeserializedPCHDecls = false;\n\n  /// This is a set of names for decls that we do not want to be\n  /// deserialized, and we emit an error if they are; for testing purposes.\n  std::set<std::string> DeserializedPCHDeclsToErrorOn;\n\n  /// If non-zero, the implicit PCH include is actually a precompiled\n  /// preamble that covers this number of bytes in the main source file.\n  ///\n  /// The boolean indicates whether the preamble ends at the start of a new\n  /// line.\n  std::pair<unsigned, bool> PrecompiledPreambleBytes;\n\n  /// True indicates that a preamble is being generated.\n  ///\n  /// When the lexer is done, one of the things that need to be preserved is the\n  /// conditional #if stack, so the ASTWriter/ASTReader can save/restore it when\n  /// processing the rest of the file. Similarly, we track an unterminated\n  /// #pragma assume_nonnull.\n  bool GeneratePreamble = false;\n\n  /// Whether to write comment locations into the PCH when building it.\n  /// Reading the comments from the PCH can be a performance hit even if the\n  /// clients don't use them.\n  bool WriteCommentListToPCH = true;\n\n  /// When enabled, preprocessor is in a mode for parsing a single file only.\n  ///\n  /// Disables #includes of other files and if there are unresolved identifiers\n  /// in preprocessor directive conditions it causes all blocks to be parsed so\n  /// that the client can get the maximum amount of information from the parser.\n  bool SingleFileParseMode = false;\n\n  /// When enabled, the preprocessor will construct editor placeholder tokens.\n  bool LexEditorPlaceholders = true;\n\n  /// True if the SourceManager should report the original file name for\n  /// contents of files that were remapped to other files. Defaults to true.\n  bool RemappedFilesKeepOriginalName = true;\n\n  /// The set of file remappings, which take existing files on\n  /// the system (the first part of each pair) and gives them the\n  /// contents of other files on the system (the second part of each\n  /// pair).\n  std::vector<std::pair<std::string, std::string>> RemappedFiles;\n\n  /// The set of file-to-buffer remappings, which take existing files\n  /// on the system (the first part of each pair) and gives them the contents\n  /// of the specified memory buffer (the second part of each pair).\n  std::vector<std::pair<std::string, llvm::MemoryBuffer *>> RemappedFileBuffers;\n\n  /// Whether the compiler instance should retain (i.e., not free)\n  /// the buffers associated with remapped files.\n  ///\n  /// This flag defaults to false; it can be set true only through direct\n  /// manipulation of the compiler invocation object, in cases where the\n  /// compiler invocation and its buffers will be reused.\n  bool RetainRemappedFileBuffers = false;\n\n  /// When enabled, excluded conditional blocks retain in the main file.\n  bool RetainExcludedConditionalBlocks = false;\n\n  /// The Objective-C++ ARC standard library that we should support,\n  /// by providing appropriate definitions to retrofit the standard library\n  /// with support for lifetime-qualified pointers.\n  ObjCXXARCStandardLibraryKind ObjCXXARCStandardLibrary = ARCXX_nolib;\n\n  /// Records the set of modules\n  class FailedModulesSet {\n    llvm::StringSet<> Failed;\n\n  public:\n    bool hasAlreadyFailed(StringRef module) {\n      return Failed.count(module) > 0;\n    }\n\n    void addFailed(StringRef module) {\n      Failed.insert(module);\n    }\n  };\n\n  /// The set of modules that failed to build.\n  ///\n  /// This pointer will be shared among all of the compiler instances created\n  /// to (re)build modules, so that once a module fails to build anywhere,\n  /// other instances will see that the module has failed and won't try to\n  /// build it again.\n  std::shared_ptr<FailedModulesSet> FailedModules;\n\n  /// Function for getting the dependency preprocessor directives of a file.\n  ///\n  /// These are directives derived from a special form of lexing where the\n  /// source input is scanned for the preprocessor directives that might have an\n  /// effect on the dependencies for a compilation unit.\n  ///\n  /// Enables a client to cache the directives for a file and provide them\n  /// across multiple compiler invocations.\n  /// FIXME: Allow returning an error.\n  std::function<std::optional<ArrayRef<dependency_directives_scan::Directive>>(\n      FileEntryRef)>\n      DependencyDirectivesForFile;\n\n  /// Set up preprocessor for RunAnalysis action.\n  bool SetUpStaticAnalyzer = false;\n\n  /// Prevents intended crashes when using #pragma clang __debug. For testing.\n  bool DisablePragmaDebugCrash = false;\n\n  /// If set, the UNIX timestamp specified by SOURCE_DATE_EPOCH.\n  std::optional<uint64_t> SourceDateEpoch;\n\npublic:\n  PreprocessorOptions() : PrecompiledPreambleBytes(0, false) {}\n\n  void addMacroDef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), false);\n  }\n  void addMacroUndef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), true);\n  }\n\n  void addRemappedFile(StringRef From, StringRef To) {\n    RemappedFiles.emplace_back(std::string(From), std::string(To));\n  }\n\n  void addRemappedFile(StringRef From, llvm::MemoryBuffer *To) {\n    RemappedFileBuffers.emplace_back(std::string(From), To);\n  }\n\n  void clearRemappedFiles() {\n    RemappedFiles.clear();\n    RemappedFileBuffers.clear();\n  }\n\n  /// Reset any options that are not considered when building a\n  /// module.\n  void resetNonModularOptions() {\n    Includes.clear();\n    MacroIncludes.clear();\n    ChainedIncludes.clear();\n    DumpDeserializedPCHDecls = false;\n    ImplicitPCHInclude.clear();\n    SingleFileParseMode = false;\n    LexEditorPlaceholders = true;\n    RetainRemappedFileBuffers = true;\n    PrecompiledPreambleBytes.first = 0;\n    PrecompiledPreambleBytes.second = false;\n    RetainExcludedConditionalBlocks = false;\n  }\n}",
  "id": "BLOCK-CPP-19144",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/PreprocessorOptions.h",
  "source_line": 66,
  "validation_status": "validated"
}