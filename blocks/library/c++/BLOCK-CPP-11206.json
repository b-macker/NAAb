{
  "code": "{\n  OptionalFlag HasThousandsGrouping; // ''', POSIX extension.\n  OptionalFlag IsLeftJustified; // '-'\n  OptionalFlag HasPlusPrefix; // '+'\n  OptionalFlag HasSpacePrefix; // ' '\n  OptionalFlag HasAlternativeForm; // '#'\n  OptionalFlag HasLeadingZeroes; // '0'\n  OptionalFlag HasObjCTechnicalTerm; // '[tt]'\n  OptionalFlag IsPrivate;            // '{private}'\n  OptionalFlag IsPublic;             // '{public}'\n  OptionalFlag IsSensitive;          // '{sensitive}'\n  OptionalAmount Precision;\n  StringRef MaskType;\n\n  ArgType getScalarArgType(ASTContext &Ctx, bool IsObjCLiteral) const;\n\npublic:\n  PrintfSpecifier()\n      : FormatSpecifier(/* isPrintf = */ true), HasThousandsGrouping(\"'\"),\n        IsLeftJustified(\"-\"), HasPlusPrefix(\"+\"), HasSpacePrefix(\" \"),\n        HasAlternativeForm(\"#\"), HasLeadingZeroes(\"0\"),\n        HasObjCTechnicalTerm(\"tt\"), IsPrivate(\"private\"), IsPublic(\"public\"),\n        IsSensitive(\"sensitive\") {}\n\n  static PrintfSpecifier Parse(const char *beg, const char *end);\n\n    // Methods for incrementally constructing the PrintfSpecifier.\n  void setConversionSpecifier(const PrintfConversionSpecifier &cs) {\n    CS = cs;\n  }\n  void setHasThousandsGrouping(const char *position) {\n    HasThousandsGrouping.setPosition(position);\n  }\n  void setIsLeftJustified(const char *position) {\n    IsLeftJustified.setPosition(position);\n  }\n  void setHasPlusPrefix(const char *position) {\n    HasPlusPrefix.setPosition(position);\n  }\n  void setHasSpacePrefix(const char *position) {\n    HasSpacePrefix.setPosition(position);\n  }\n  void setHasAlternativeForm(const char *position) {\n    HasAlternativeForm.setPosition(position);\n  }\n  void setHasLeadingZeros(const char *position) {\n    HasLeadingZeroes.setPosition(position);\n  }\n  void setHasObjCTechnicalTerm(const char *position) {\n    HasObjCTechnicalTerm.setPosition(position);\n  }\n  void setIsPrivate(const char *position) { IsPrivate.setPosition(position); }\n  void setIsPublic(const char *position) { IsPublic.setPosition(position); }\n  void setIsSensitive(const char *position) {\n    IsSensitive.setPosition(position);\n  }\n  void setUsesPositionalArg() { UsesPositionalArg = true; }\n\n    // Methods for querying the format specifier.\n\n  const PrintfConversionSpecifier &getConversionSpecifier() const {\n    return cast<PrintfConversionSpecifier>(CS);\n  }\n\n  void setPrecision(const OptionalAmount &Amt) {\n    Precision = Amt;\n    Precision.setUsesDotPrefix();\n  }\n\n  const OptionalAmount &getPrecision() const {\n    return Precision;\n  }\n\n  bool consumesDataArgument() const {\n    return getConversionSpecifier().consumesDataArgument();\n  }\n\n  /// Returns the builtin type that a data argument\n  /// paired with this format specifier should have.  This method\n  /// will return null if the format specifier does not have\n  /// a matching data argument or the matching argument matches\n  /// more than one type.\n  ArgType getArgType(ASTContext &Ctx, bool IsObjCLiteral) const;\n\n  const OptionalFlag &hasThousandsGrouping() const {\n      return HasThousandsGrouping;\n  }\n  const OptionalFlag &isLeftJustified() const { return IsLeftJustified; }\n  const OptionalFlag &hasPlusPrefix() const { return HasPlusPrefix; }\n  const OptionalFlag &hasAlternativeForm() const { return HasAlternativeForm; }\n  const OptionalFlag &hasLeadingZeros() const { return HasLeadingZeroes; }\n  const OptionalFlag &hasSpacePrefix() const { return HasSpacePrefix; }\n  const OptionalFlag &hasObjCTechnicalTerm() const { return HasObjCTechnicalTerm; }\n  const OptionalFlag &isPrivate() const { return IsPrivate; }\n  const OptionalFlag &isPublic() const { return IsPublic; }\n  const OptionalFlag &isSensitive() const { return IsSensitive; }\n  bool usesPositionalArg() const { return UsesPositionalArg; }\n\n  StringRef getMaskType() const { return MaskType; }\n  void setMaskType(StringRef S) { MaskType = S; }\n\n  /// Changes the specifier and length according to a QualType, retaining any\n  /// flags or options. Returns true on success, or false when a conversion\n  /// was not successful.\n  bool fixType(QualType QT, const LangOptions &LangOpt, ASTContext &Ctx,\n               bool IsObjCLiteral);\n\n  void toString(raw_ostream &os) const;\n\n  // Validation methods - to check if any element results in undefined behavior\n  bool hasValidPlusPrefix() const;\n  bool hasValidAlternativeForm() const;\n  bool hasValidLeadingZeros() const;\n  bool hasValidSpacePrefix() const;\n  bool hasValidLeftJustified() const;\n  bool hasValidThousandsGroupingPrefix() const;\n\n  bool hasValidPrecision() const;\n  bool hasValidFieldWidth() const;\n}",
  "id": "BLOCK-CPP-11206",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/FormatString.h",
  "source_line": 511,
  "validation_status": "validated"
}