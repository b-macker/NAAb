{
  "code": "{\n  /// Represents the parsed form of a C++ template argument.\n  class ParsedTemplateArgument {\n  public:\n    /// Describes the kind of template argument that was parsed.\n    enum KindType {\n      /// A template type parameter, stored as a type.\n      Type,\n      /// A non-type template parameter, stored as an expression.\n      NonType,\n      /// A template template argument, stored as a template name.\n      Template\n    };\n\n    /// Build an empty template argument.\n    ///\n    /// This template argument is invalid.\n    ParsedTemplateArgument() : Kind(Type), Arg(nullptr) { }\n\n    /// Create a template type argument or non-type template argument.\n    ///\n    /// \\param Arg the template type argument or non-type template argument.\n    /// \\param Loc the location of the type.\n    ParsedTemplateArgument(KindType Kind, void *Arg, SourceLocation Loc)\n      : Kind(Kind), Arg(Arg), Loc(Loc) { }\n\n    /// Create a template template argument.\n    ///\n    /// \\param SS the C++ scope specifier that precedes the template name, if\n    /// any.\n    ///\n    /// \\param Template the template to which this template template\n    /// argument refers.\n    ///\n    /// \\param TemplateLoc the location of the template name.\n    ParsedTemplateArgument(const CXXScopeSpec &SS,\n                           ParsedTemplateTy Template,\n                           SourceLocation TemplateLoc)\n      : Kind(ParsedTemplateArgument::Template),\n        Arg(Template.getAsOpaquePtr()), SS(SS), Loc(TemplateLoc) {}\n\n    /// Determine whether the given template argument is invalid.\n    bool isInvalid() const { return Arg == nullptr; }\n\n    /// Determine what kind of template argument we have.\n    KindType getKind() const { return Kind; }\n\n    /// Retrieve the template type argument's type.\n    ParsedType getAsType() const {\n      assert(Kind == Type && \"Not a template type argument\");\n      return ParsedType::getFromOpaquePtr(Arg);\n    }\n\n    /// Retrieve the non-type template argument's expression.\n    Expr *getAsExpr() const {\n      assert(Kind == NonType && \"Not a non-type template argument\");\n      return static_cast<Expr*>(Arg);\n    }\n\n    /// Retrieve the template template argument's template name.\n    ParsedTemplateTy getAsTemplate() const {\n      assert(Kind == Template && \"Not a template template argument\");\n      return ParsedTemplateTy::getFromOpaquePtr(Arg);\n    }\n\n    /// Retrieve the location of the template argument.\n    SourceLocation getLocation() const { return Loc; }\n\n    /// Retrieve the nested-name-specifier that precedes the template\n    /// name in a template template argument.\n    const CXXScopeSpec &getScopeSpec() const {\n      assert(Kind == Template &&\n             \"Only template template arguments can have a scope specifier\");\n      return SS;\n    }\n\n    /// Retrieve the location of the ellipsis that makes a template\n    /// template argument into a pack expansion.\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == Template &&\n             \"Only template template arguments can have an ellipsis\");\n      return EllipsisLoc;\n    }\n\n    /// Retrieve a pack expansion of the given template template\n    /// argument.\n    ///\n    /// \\param EllipsisLoc The location of the ellipsis.\n    ParsedTemplateArgument getTemplatePackExpansion(\n                                              SourceLocation EllipsisLoc) const;\n\n  private:\n    KindType Kind;\n\n    /// The actual template argument representation, which may be\n    /// an \\c Sema::TypeTy* (for a type), an Expr* (for an\n    /// expression), or an Sema::TemplateTy (for a template).\n    void *Arg;\n\n    /// The nested-name-specifier that can accompany a template template\n    /// argument.\n    CXXScopeSpec SS;\n\n    /// the location of the template argument.\n    SourceLocation Loc;\n\n    /// The ellipsis location that can accompany a template template\n    /// argument (turning it into a template template argument expansion).\n    SourceLocation EllipsisLoc;\n  };\n\n  /// Information about a template-id annotation\n  /// token.\n  ///\n  /// A template-id annotation token contains the template name,\n  /// template arguments, and the source locations for important\n  /// tokens. All of the information about template arguments is allocated\n  /// directly after this structure.\n  /// A template-id annotation token can also be generated by a type-constraint\n  /// construct with no explicit template arguments, e.g. \"template<C T>\" would\n  /// annotate C as a TemplateIdAnnotation with no template arguments (the angle\n  /// locations would be invalid in this case).\n  struct TemplateIdAnnotation final\n      : private llvm::TrailingObjects<TemplateIdAnnotation,\n                                      ParsedTemplateArgument> {\n    friend TrailingObjects;\n    /// TemplateKWLoc - The location of the template keyword.\n    /// For e.g. typename T::template Y<U>\n    SourceLocation TemplateKWLoc;\n\n    /// TemplateNameLoc - The location of the template name within the\n    /// source.\n    SourceLocation TemplateNameLoc;\n\n    /// FIXME: Temporarily stores the name of a specialization\n    IdentifierInfo *Name;\n\n    /// FIXME: Temporarily stores the overloaded operator kind.\n    OverloadedOperatorKind Operator;\n\n    /// The declaration of the template corresponding to the\n    /// template-name.\n    ParsedTemplateTy Template;\n\n    /// The kind of template that Template refers to. If this is\n    /// TNK_Non_template, an error was encountered and diagnosed\n    /// when parsing or looking up the template name.\n    TemplateNameKind Kind;\n\n    /// The location of the '<' before the template argument\n    /// list.\n    SourceLocation LAngleLoc;\n\n    /// The location of the '>' after the template argument\n    /// list.\n    SourceLocation RAngleLoc;\n\n    /// NumArgs - The number of template arguments.\n    unsigned NumArgs;\n\n    /// Whether an error was encountered in the template arguments.\n    /// If so, NumArgs and the trailing arguments are best-effort.\n    bool ArgsInvalid;\n\n    /// Retrieves a pointer to the template arguments\n    ParsedTemplateArgument *getTemplateArgs() {\n      return getTrailingObjects<ParsedTemplateArgument>();\n    }\n\n    /// Creates a new TemplateIdAnnotation with NumArgs arguments and\n    /// appends it to List.\n    static TemplateIdAnnotation *\n    Create(SourceLocation TemplateKWLoc, SourceLocation TemplateNameLoc,\n           IdentifierInfo *Name, OverloadedOperatorKind OperatorKind,\n           ParsedTemplateTy OpaqueTemplateName, TemplateNameKind TemplateKind,\n           SourceLocation LAngleLoc, SourceLocation RAngleLoc,\n           ArrayRef<ParsedTemplateArgument> TemplateArgs, bool ArgsInvalid,\n           SmallVectorImpl<TemplateIdAnnotation *> &CleanupList) {\n      TemplateIdAnnotation *TemplateId = new (llvm::safe_malloc(\n          totalSizeToAlloc<ParsedTemplateArgument>(TemplateArgs.size())))\n          TemplateIdAnnotation(TemplateKWLoc, TemplateNameLoc, Name,\n                               OperatorKind, OpaqueTemplateName, TemplateKind,\n                               LAngleLoc, RAngleLoc, TemplateArgs, ArgsInvalid);\n      CleanupList.push_back(TemplateId);\n      return TemplateId;\n    }\n\n    void Destroy() {\n      for (ParsedTemplateArgument &A :\n           llvm::make_range(getTemplateArgs(), getTemplateArgs() + NumArgs))\n        A.~ParsedTemplateArgument();\n      this->~TemplateIdAnnotation();\n      free(this);\n    }\n\n    /// Determine whether this might be a type template.\n    bool mightBeType() const {\n      return Kind == TNK_Non_template ||\n             Kind == TNK_Type_template ||\n             Kind == TNK_Dependent_template_name ||\n             Kind == TNK_Undeclared_template;\n    }\n\n    bool hasInvalidName() const { return Kind == TNK_Non_template; }\n    bool hasInvalidArgs() const { return ArgsInvalid; }\n\n    bool isInvalid() const { return hasInvalidName() || hasInvalidArgs(); }\n\n  private:\n    TemplateIdAnnotation(const TemplateIdAnnotation &) = delete;\n\n    TemplateIdAnnotation(SourceLocation TemplateKWLoc,\n                         SourceLocation TemplateNameLoc, IdentifierInfo *Name,\n                         OverloadedOperatorKind OperatorKind,\n                         ParsedTemplateTy OpaqueTemplateName,\n                         TemplateNameKind TemplateKind,\n                         SourceLocation LAngleLoc, SourceLocation RAngleLoc,\n                         ArrayRef<ParsedTemplateArgument> TemplateArgs,\n                         bool ArgsInvalid) noexcept\n        : TemplateKWLoc(TemplateKWLoc), TemplateNameLoc(TemplateNameLoc),\n          Name(Name), Operator(OperatorKind), Template(OpaqueTemplateName),\n          Kind(TemplateKind), LAngleLoc(LAngleLoc), RAngleLoc(RAngleLoc),\n          NumArgs(TemplateArgs.size()), ArgsInvalid(ArgsInvalid) {\n\n      std::uninitialized_copy(TemplateArgs.begin(), TemplateArgs.end(),\n                              getTemplateArgs());\n    }\n    ~TemplateIdAnnotation() = default;\n  };\n\n  /// Retrieves the range of the given template parameter lists.\n  SourceRange getTemplateParamsRange(TemplateParameterList const *const *Params,\n                                     unsigned NumParams);\n}",
  "id": "BLOCK-CPP-20175",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ParsedTemplate.h",
  "source_line": 27,
  "validation_status": "validated"
}