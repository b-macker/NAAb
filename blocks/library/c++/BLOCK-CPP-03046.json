{
  "code": "#include \"absl/strings/internal/str_format/float_conversion.h\"\n#include <string.h>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <limits>\n#include <string>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/functional/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/numeric/internal/representation.h\"\n#include \"absl/strings/numbers.h\"\n#include \"absl/types/optional.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace str_format_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03046_execute() {\n    {\n    // We need to print the digits directly into the sink object without\n    // buffering them all first. To do this we need two things:\n    // - to know the total number of digits to do padding when necessary\n    // - to generate the decimal digits from the left.\n    //\n    // In order to do this, we do a two pass conversion.\n    // On the first pass we convert the binary representation of the value into\n    // a decimal representation in which each uint32_t chunk holds up to 9\n    // decimal digits.  In the second pass we take each decimal-holding-uint32_t\n    // value and generate the ascii decimal digits into `digits_`.\n    //\n    // The binary and decimal representations actually share the same memory\n    // region. As we go converting the chunks from binary to decimal we free\n    // them up and reuse them for the decimal representation. One caveat is that\n    // the decimal representation is around 7% less efficient in space than the\n    // binary one. We allocate an extra 10% memory to account for this. See\n    // ChunksNeeded for this calculation.\n    size_t after_chunk_index = static_cast<size_t>(exp / 32 + 1);\n    decimal_start_ = decimal_end_ = ChunksNeeded(exp);\n    const int offset = exp % 32;\n    // Left shift v by exp bits.\n    data_[after_chunk_index - 1] = static_cast<uint32_t>(v << offset);\n    for (v >>= (32 - offset); v; v >>= 32)\n      data_[++after_chunk_index - 1] = static_cast<uint32_t>(v);\n\n    while (after_chunk_index > 0) {\n      // While we have more than one chunk available, go in steps of 1e9.\n      // `data_[after_chunk_index - 1]` holds the highest non-zero binary chunk,\n      // so keep the variable updated.\n      uint32_t carry = 0;\n      for (size_t i = after_chunk_index; i > 0; --i) {\n        uint64_t tmp = uint64_t{data_[i - 1]} + (uint64_t{carry} << 32);\n        data_[i - 1] = static_cast<uint32_t>(tmp / uint64_t{1000000000});\n        carry = static_cast<uint32_t>(tmp % uint64_t{1000000000});\n      }\n\n      // If the highest chunk is now empty, remove it from view.\n      if (data_[after_chunk_index - 1] == 0)\n        --after_chunk_index;\n\n      --decimal_start_;\n      assert(decimal_start_ != after_chunk_index - 1);\n      data_[decimal_start_] = carry;\n    }\n\n    // Fill the first set of digits. The first chunk might not be complete, so\n    // handle differently.\n    for (uint32_t first = data_[decimal_start_++]; first != 0; first /= 10) {\n      digits_[kDigitsPerChunk - ++size_] = first % 10 + '0';\n    }\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03046",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/float_conversion.cc",
  "source_line": 178,
  "validation_status": "validated"
}