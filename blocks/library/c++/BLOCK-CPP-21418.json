{
  "code": "{\npublic:\n  using Name = StringRef;\n\n  ThreadSafetyHandler() = default;\n  virtual ~ThreadSafetyHandler();\n\n  /// Warn about lock expressions which fail to resolve to lockable objects.\n  /// \\param Loc -- the SourceLocation of the unresolved expression.\n  virtual void handleInvalidLockExp(SourceLocation Loc) {}\n\n  /// Warn about unlock function calls that do not have a prior matching lock\n  /// expression.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc -- The SourceLocation of the Unlock\n  /// \\param LocPreviousUnlock -- If valid, the location of a previous Unlock.\n  virtual void handleUnmatchedUnlock(StringRef Kind, Name LockName,\n                                     SourceLocation Loc,\n                                     SourceLocation LocPreviousUnlock) {}\n\n  /// Warn about an unlock function call that attempts to unlock a lock with\n  /// the incorrect lock kind. For instance, a shared lock being unlocked\n  /// exclusively, or vice versa.\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param Expected -- the kind of lock expected.\n  /// \\param Received -- the kind of lock received.\n  /// \\param LocLocked -- The SourceLocation of the Lock.\n  /// \\param LocUnlock -- The SourceLocation of the Unlock.\n  virtual void handleIncorrectUnlockKind(StringRef Kind, Name LockName,\n                                         LockKind Expected, LockKind Received,\n                                         SourceLocation LocLocked,\n                                         SourceLocation LocUnlock) {}\n\n  /// Warn about lock function calls for locks which are already held.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LocLocked -- The location of the first lock expression.\n  /// \\param LocDoubleLock -- The location of the second lock expression.\n  virtual void handleDoubleLock(StringRef Kind, Name LockName,\n                                SourceLocation LocLocked,\n                                SourceLocation LocDoubleLock) {}\n\n  /// Warn about situations where a mutex is sometimes held and sometimes not.\n  /// The three situations are:\n  /// 1. a mutex is locked on an \"if\" branch but not the \"else\" branch,\n  /// 2, or a mutex is only held at the start of some loop iterations,\n  /// 3. or when a mutex is locked but not unlocked inside a function.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LocLocked -- The location of the lock expression where the mutex is\n  ///               locked\n  /// \\param LocEndOfScope -- The location of the end of the scope where the\n  ///               mutex is no longer held\n  /// \\param LEK -- which of the three above cases we should warn for\n  virtual void handleMutexHeldEndOfScope(StringRef Kind, Name LockName,\n                                         SourceLocation LocLocked,\n                                         SourceLocation LocEndOfScope,\n                                         LockErrorKind LEK) {}\n\n  /// Warn when a mutex is held exclusively and shared at the same point. For\n  /// example, if a mutex is locked exclusively during an if branch and shared\n  /// during the else branch.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc1 -- The location of the first lock expression.\n  /// \\param Loc2 -- The location of the second lock expression.\n  virtual void handleExclusiveAndShared(StringRef Kind, Name LockName,\n                                        SourceLocation Loc1,\n                                        SourceLocation Loc2) {}\n\n  /// Warn when a protected operation occurs while no locks are held.\n  /// \\param D -- The decl for the protected variable or function\n  /// \\param POK -- The kind of protected operation (e.g. variable access)\n  /// \\param AK -- The kind of access (i.e. read or write) that occurred\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNoMutexHeld(const NamedDecl *D, ProtectedOperationKind POK,\n                                 AccessKind AK, SourceLocation Loc) {}\n\n  /// Warn when a protected operation occurs while the specific mutex protecting\n  /// the operation is not locked.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param D -- The decl for the protected variable or function\n  /// \\param POK -- The kind of protected operation (e.g. variable access)\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param LK -- The kind of access (i.e. read or write) that occurred\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleMutexNotHeld(StringRef Kind, const NamedDecl *D,\n                                  ProtectedOperationKind POK, Name LockName,\n                                  LockKind LK, SourceLocation Loc,\n                                  Name *PossibleMatch = nullptr) {}\n\n  /// Warn when acquiring a lock that the negative capability is not held.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param LockName -- The name for the lock expression, to be printed in the\n  /// diagnostic.\n  /// \\param Neg -- The name of the negative capability to be printed in the\n  /// diagnostic.\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNegativeNotHeld(StringRef Kind, Name LockName, Name Neg,\n                                     SourceLocation Loc) {}\n\n  /// Warn when calling a function that a negative capability is not held.\n  /// \\param D -- The decl for the function requiring the negative capability.\n  /// \\param LockName -- The name for the lock expression, to be printed in the\n  /// diagnostic.\n  /// \\param Loc -- The location of the protected operation.\n  virtual void handleNegativeNotHeld(const NamedDecl *D, Name LockName,\n                                     SourceLocation Loc) {}\n\n  /// Warn when a function is called while an excluded mutex is locked. For\n  /// example, the mutex may be locked inside the function.\n  /// \\param Kind -- the capability's name parameter (role, mutex, etc).\n  /// \\param FunName -- The name of the function\n  /// \\param LockName -- A StringRef name for the lock expression, to be printed\n  /// in the error message.\n  /// \\param Loc -- The location of the function call.\n  virtual void handleFunExcludesLock(StringRef Kind, Name FunName,\n                                     Name LockName, SourceLocation Loc) {}\n\n  /// Warn that L1 cannot be acquired before L2.\n  virtual void handleLockAcquiredBefore(StringRef Kind, Name L1Name,\n                                        Name L2Name, SourceLocation Loc) {}\n\n  /// Warn that there is a cycle in acquired_before/after dependencies.\n  virtual void handleBeforeAfterCycle(Name L1Name, SourceLocation Loc) {}\n\n  /// Called by the analysis when starting analysis of a function.\n  /// Used to issue suggestions for changes to annotations.\n  virtual void enterFunction(const FunctionDecl *FD) {}\n\n  /// Called by the analysis when finishing analysis of a function.\n  virtual void leaveFunction(const FunctionDecl *FD) {}\n\n  bool issueBetaWarnings() { return IssueBetaWarnings; }\n  void setIssueBetaWarnings(bool b) { IssueBetaWarnings = b; }\n\nprivate:\n  bool IssueBetaWarnings = false;\n}",
  "id": "BLOCK-CPP-21418",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafety.h",
  "source_line": 93,
  "validation_status": "validated"
}