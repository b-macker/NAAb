{
  "code": "{\n  public:\n    // `Native` represents default align mode, which may vary based on the\n    // platform.\n    enum Mode : unsigned char { Native, Natural, Packed, Mac68k };\n\n    // #pragma pack info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, unsigned Num, bool IsXL)\n        : PackAttr(true), AlignMode(M), PackNumber(Num), XLStack(IsXL) {\n      assert(Num == PackNumber && \"The pack number has been truncated.\");\n    }\n\n    // #pragma align info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, bool IsXL)\n        : PackAttr(false), AlignMode(M),\n          PackNumber(M == Packed ? 1 : UninitPackVal), XLStack(IsXL) {}\n\n    explicit AlignPackInfo(bool IsXL) : AlignPackInfo(Native, IsXL) {}\n\n    AlignPackInfo() : AlignPackInfo(Native, false) {}\n\n    // When a AlignPackInfo itself cannot be used, this returns an 32-bit\n    // integer encoding for it. This should only be passed to\n    // AlignPackInfo::getFromRawEncoding, it should not be inspected directly.\n    static uint32_t getRawEncoding(const AlignPackInfo &Info) {\n      std::uint32_t Encoding{};\n      if (Info.IsXLStack())\n        Encoding |= IsXLMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getAlignMode()) << 1;\n\n      if (Info.IsPackAttr())\n        Encoding |= PackAttrMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getPackNumber()) << 4;\n\n      return Encoding;\n    }\n\n    static AlignPackInfo getFromRawEncoding(unsigned Encoding) {\n      bool IsXL = static_cast<bool>(Encoding & IsXLMask);\n      AlignPackInfo::Mode M =\n          static_cast<AlignPackInfo::Mode>((Encoding & AlignModeMask) >> 1);\n      int PackNumber = (Encoding & PackNumMask) >> 4;\n\n      if (Encoding & PackAttrMask)\n        return AlignPackInfo(M, PackNumber, IsXL);\n\n      return AlignPackInfo(M, IsXL);\n    }\n\n    bool IsPackAttr() const { return PackAttr; }\n\n    bool IsAlignAttr() const { return !PackAttr; }\n\n    Mode getAlignMode() const { return AlignMode; }\n\n    unsigned getPackNumber() const { return PackNumber; }\n\n    bool IsPackSet() const {\n      // #pragma align, #pragma pack(), and #pragma pack(0) do not set the pack\n      // attriute on a decl.\n      return PackNumber != UninitPackVal && PackNumber != 0;\n    }\n\n    bool IsXLStack() const { return XLStack; }\n\n    bool operator==(const AlignPackInfo &Info) const {\n      return std::tie(AlignMode, PackNumber, PackAttr, XLStack) ==\n             std::tie(Info.AlignMode, Info.PackNumber, Info.PackAttr,\n                      Info.XLStack);\n    }\n\n    bool operator!=(const AlignPackInfo &Info) const {\n      return !(*this == Info);\n    }\n\n  private:\n    /// \\brief True if this is a pragma pack attribute,\n    ///         not a pragma align attribute.\n    bool PackAttr;\n\n    /// \\brief The alignment mode that is in effect.\n    Mode AlignMode;\n\n    /// \\brief The pack number of the stack.\n    unsigned char PackNumber;\n\n    /// \\brief True if it is a XL #pragma align/pack stack.\n    bool XLStack;\n\n    /// \\brief Uninitialized pack value.\n    static constexpr unsigned char UninitPackVal = -1;\n\n    // Masks to encode and decode an AlignPackInfo.\n    static constexpr uint32_t IsXLMask{0x0000'0001};\n    static constexpr uint32_t AlignModeMask{0x0000'0006};\n    static constexpr uint32_t PackAttrMask{0x00000'0008};\n    static constexpr uint32_t PackNumMask{0x0000'01F0};\n  }",
  "id": "BLOCK-CPP-20512",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Sema.h",
  "source_line": 491,
  "validation_status": "validated"
}