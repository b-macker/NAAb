{
  "code": "{\npublic:\n  enum CommentKind {\n    RCK_Invalid,      ///< Invalid comment\n    RCK_OrdinaryBCPL, ///< Any normal BCPL comments\n    RCK_OrdinaryC,    ///< Any normal C comment\n    RCK_BCPLSlash,    ///< \\code /// stuff \\endcode\n    RCK_BCPLExcl,     ///< \\code //! stuff \\endcode\n    RCK_JavaDoc,      ///< \\code /** stuff */ \\endcode\n    RCK_Qt,           ///< \\code /*! stuff */ \\endcode, also used by HeaderDoc\n    RCK_Merged        ///< Two or more documentation comments merged together\n  };\n\n  RawComment() : Kind(RCK_Invalid), IsAlmostTrailingComment(false) { }\n\n  RawComment(const SourceManager &SourceMgr, SourceRange SR,\n             const CommentOptions &CommentOpts, bool Merged);\n\n  CommentKind getKind() const LLVM_READONLY {\n    return (CommentKind) Kind;\n  }\n\n  bool isInvalid() const LLVM_READONLY {\n    return Kind == RCK_Invalid;\n  }\n\n  bool isMerged() const LLVM_READONLY {\n    return Kind == RCK_Merged;\n  }\n\n  /// Is this comment attached to any declaration?\n  bool isAttached() const LLVM_READONLY {\n    return IsAttached;\n  }\n\n  void setAttached() {\n    IsAttached = true;\n  }\n\n  /// Returns true if it is a comment that should be put after a member:\n  /// \\code ///< stuff \\endcode\n  /// \\code //!< stuff \\endcode\n  /// \\code /**< stuff */ \\endcode\n  /// \\code /*!< stuff */ \\endcode\n  bool isTrailingComment() const LLVM_READONLY {\n    return IsTrailingComment;\n  }\n\n  /// Returns true if it is a probable typo:\n  /// \\code //< stuff \\endcode\n  /// \\code /*< stuff */ \\endcode\n  bool isAlmostTrailingComment() const LLVM_READONLY {\n    return IsAlmostTrailingComment;\n  }\n\n  /// Returns true if this comment is not a documentation comment.\n  bool isOrdinary() const LLVM_READONLY {\n    return ((Kind == RCK_OrdinaryBCPL) || (Kind == RCK_OrdinaryC));\n  }\n\n  /// Returns true if this comment any kind of a documentation comment.\n  bool isDocumentation() const LLVM_READONLY {\n    return !isInvalid() && !isOrdinary();\n  }\n\n  /// Returns raw comment text with comment markers.\n  StringRef getRawText(const SourceManager &SourceMgr) const {\n    if (RawTextValid)\n      return RawText;\n\n    RawText = getRawTextSlow(SourceMgr);\n    RawTextValid = true;\n    return RawText;\n  }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  const char *getBriefText(const ASTContext &Context) const {\n    if (BriefTextValid)\n      return BriefText;\n\n    return extractBriefText(Context);\n  }\n\n  bool hasUnsupportedSplice(const SourceManager &SourceMgr) const {\n    if (!isInvalid())\n      return false;\n    StringRef Text = getRawText(SourceMgr);\n    if (Text.size() < 6 || Text[0] != '/')\n      return false;\n    if (Text[1] == '*')\n      return Text[Text.size() - 1] != '/' || Text[Text.size() - 2] != '*';\n    return Text[1] != '/';\n  }\n\n  /// Returns sanitized comment text, suitable for presentation in editor UIs.\n  /// E.g. will transform:\n  ///     // This is a long multiline comment.\n  ///     //   Parts of it  might be indented.\n  ///     /* The comments styles might be mixed. */\n  ///  into\n  ///     \"This is a long multiline comment.\\n\"\n  ///     \"  Parts of it  might be indented.\\n\"\n  ///     \"The comments styles might be mixed.\"\n  /// Also removes leading indentation and sanitizes some common cases:\n  ///     /* This is a first line.\n  ///      *   This is a second line. It is indented.\n  ///      * This is a third line. */\n  /// and\n  ///     /* This is a first line.\n  ///          This is a second line. It is indented.\n  ///     This is a third line. */\n  /// will both turn into:\n  ///     \"This is a first line.\\n\"\n  ///     \"  This is a second line. It is indented.\\n\"\n  ///     \"This is a third line.\"\n  std::string getFormattedText(const SourceManager &SourceMgr,\n                               DiagnosticsEngine &Diags) const;\n\n  struct CommentLine {\n    std::string Text;\n    PresumedLoc Begin;\n    PresumedLoc End;\n\n    CommentLine(StringRef Text, PresumedLoc Begin, PresumedLoc End)\n        : Text(Text), Begin(Begin), End(End) {}\n  };\n\n  /// Returns sanitized comment text as separated lines with locations in\n  /// source, suitable for further processing and rendering requiring source\n  /// locations.\n  std::vector<CommentLine> getFormattedLines(const SourceManager &SourceMgr,\n                                             DiagnosticsEngine &Diags) const;\n\n  /// Parse the comment, assuming it is attached to decl \\c D.\n  comments::FullComment *parse(const ASTContext &Context,\n                               const Preprocessor *PP, const Decl *D) const;\n\nprivate:\n  SourceRange Range;\n\n  mutable StringRef RawText;\n  mutable const char *BriefText = nullptr;\n\n  mutable bool RawTextValid : 1;   ///< True if RawText is valid\n  mutable bool BriefTextValid : 1; ///< True if BriefText is valid\n\n  unsigned Kind : 3;\n\n  /// True if comment is attached to a declaration in ASTContext.\n  bool IsAttached : 1;\n\n  bool IsTrailingComment : 1;\n  bool IsAlmostTrailingComment : 1;\n\n  /// Constructor for AST deserialization.\n  RawComment(SourceRange SR, CommentKind K, bool IsTrailingComment,\n             bool IsAlmostTrailingComment) :\n    Range(SR), RawTextValid(false), BriefTextValid(false), Kind(K),\n    IsAttached(false), IsTrailingComment(IsTrailingComment),\n    IsAlmostTrailingComment(IsAlmostTrailingComment)\n  { }\n\n  StringRef getRawTextSlow(const SourceManager &SourceMgr) const;\n\n  const char *extractBriefText(const ASTContext &Context) const;\n\n  friend class ASTReader;\n}",
  "id": "BLOCK-CPP-12342",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/RawCommentList.h",
  "source_line": 32,
  "validation_status": "validated"
}