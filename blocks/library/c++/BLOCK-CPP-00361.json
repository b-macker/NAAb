{
  "code": "{\nnamespace sinks {\n\n/*\n * Android sink\n * (logging using __android_log_write or __android_log_buf_write depending on the specified\n * BufferID)\n */\ntemplate <typename Mutex, int BufferID = log_id::LOG_ID_MAIN>\nclass android_sink final : public base_sink<Mutex> {\npublic:\n    explicit android_sink(std::string tag = \"spdlog\", bool use_raw_msg = false)\n        : tag_(std::move(tag)),\n          use_raw_msg_(use_raw_msg) {}\n\nprotected:\n    void sink_it_(const details::log_msg &msg) override {\n        const android_LogPriority priority = convert_to_android_(msg.level);\n        memory_buf_t formatted;\n        if (use_raw_msg_) {\n            details::fmt_helper::append_string_view(msg.payload, formatted);\n        } else {\n            base_sink<Mutex>::formatter_->format(msg, formatted);\n        }\n        formatted.push_back('\\0');\n        const char *msg_output = formatted.data();\n\n        // See system/core/liblog/logger_write.c for explanation of return value\n        int ret = android_log(priority, tag_.c_str(), msg_output);\n        if (ret == -EPERM) {\n            return;  // !__android_log_is_loggable\n        }\n        int retry_count = 0;\n        while ((ret == -11 /*EAGAIN*/) && (retry_count < SPDLOG_ANDROID_RETRIES)) {\n            details::os::sleep_for_millis(5);\n            ret = android_log(priority, tag_.c_str(), msg_output);\n            retry_count++;\n        }\n\n        if (ret < 0) {\n            throw_spdlog_ex(\"logging to Android failed\", ret);\n        }\n    }\n\n    void flush_() override {}\n\nprivate:\n    // There might be liblog versions used, that do not support __android_log_buf_write. So we only\n    // compile and link against\n    // __android_log_buf_write, if user explicitly provides a non-default log buffer. Otherwise,\n    // when using the default log buffer, always log via __android_log_write.\n    template <int ID = BufferID>\n    typename std::enable_if<ID == static_cast<int>(log_id::LOG_ID_MAIN), int>::type android_log(\n        int prio, const char *tag, const char *text) {\n        return __android_log_write(prio, tag, text);\n    }\n\n    template <int ID = BufferID>\n    typename std::enable_if<ID != static_cast<int>(log_id::LOG_ID_MAIN), int>::type android_log(\n        int prio, const char *tag, const char *text) {\n        return __android_log_buf_write(ID, prio, tag, text);\n    }\n\n    static android_LogPriority convert_to_android_(spdlog::level::level_enum level) {\n        switch (level) {\n            case spdlog::level::trace:\n                return ANDROID_LOG_VERBOSE;\n            case spdlog::level::debug:\n                return ANDROID_LOG_DEBUG;\n            case spdlog::level::info:\n                return ANDROID_LOG_INFO;\n            case spdlog::level::warn:\n                return ANDROID_LOG_WARN;\n            case spdlog::level::err:\n                return ANDROID_LOG_ERROR;\n            case spdlog::level::critical:\n                return ANDROID_LOG_FATAL;\n            default:\n                return ANDROID_LOG_DEFAULT;\n        }\n    }\n\n    std::string tag_;\n    bool use_raw_msg_;\n};\n\nusing android_sink_mt = android_sink<std::mutex>;\nusing android_sink_st = android_sink<details::null_mutex>;\n\ntemplate <int BufferId = log_id::LOG_ID_MAIN>\nusing android_sink_buf_mt = android_sink<std::mutex, BufferId>;\ntemplate <int BufferId = log_id::LOG_ID_MAIN>\nusing android_sink_buf_st = android_sink<details::null_mutex, BufferId>;\n\n}  // namespace sinks\n\n// Create and register android syslog logger\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> android_logger_mt(const std::string &logger_name,\n                                                 const std::string &tag = \"spdlog\") {\n    return Factory::template create<sinks::android_sink_mt>(logger_name, tag);\n}\n\ntemplate <typename Factory = spdlog::synchronous_factory>\ninline std::shared_ptr<logger> android_logger_st(const std::string &logger_name,\n                                                 const std::string &tag = \"spdlog\") {\n    return Factory::template create<sinks::android_sink_st>(logger_name, tag);\n}\n\n}",
  "id": "BLOCK-CPP-00361",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/sinks/android_sink.h",
  "source_line": 25,
  "validation_status": "validated"
}