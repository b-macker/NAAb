{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n#include <sys/system_properties.h>\n#include <dlfcn.h>\n#include <CoreFoundation/CFTimeZone.h>\n#include <vector>\n#include <fuchsia/intl/cpp/fidl.h>\n#include <lib/async-loop/cpp/loop.h>\n#include <lib/fdio/directory.h>\n#include <zircon/types.h>\n#include <sdkddkver.h>\n#include <roapi.h>\n#include <tchar.h>\n#include <wchar.h>\n#include <windows.globalization.h>\n#include <windows.h>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include \"time_zone_fixed.h\"\n#include \"time_zone_impl.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03256_execute() {\n    {\n  const char* zone = \":localtime\";\n#if defined(__ANDROID__)\n  char sysprop[PROP_VALUE_MAX];\n  if (__system_property_get(\"persist.sys.timezone\", sysprop) > 0) {\n    zone = sysprop;\n  }\n#endif\n#if defined(__APPLE__)\n  std::vector<char> buffer;\n  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();\n  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {\n    CFStringEncoding encoding = kCFStringEncodingUTF8;\n    CFIndex length = CFStringGetLength(tz_name);\n    CFIndex max_size = CFStringGetMaximumSizeForEncoding(length, encoding) + 1;\n    buffer.resize(static_cast<size_t>(max_size));\n    if (CFStringGetCString(tz_name, &buffer[0], max_size, encoding)) {\n      zone = &buffer[0];\n    }\n  }\n  CFRelease(tz_default);\n#endif\n#if defined(__Fuchsia__)\n  std::string primary_tz;\n  [&]() {\n    // Note: We can't use the synchronous FIDL API here because it doesn't\n    // allow timeouts; if the FIDL call failed, local_time_zone() would never\n    // return.\n\n    const zx::duration kTimeout = zx::msec(500);\n\n    // Don't attach to the thread because otherwise the thread's dispatcher\n    // would be set to null when the loop is destroyed, causing any other FIDL\n    // code running on the same thread to crash.\n    async::Loop loop(&kAsyncLoopConfigNeverAttachToThread);\n\n    fuchsia::intl::PropertyProviderHandle handle;\n    zx_status_t status = fdio_service_connect_by_name(\n        fuchsia::intl::PropertyProvider::Name_,\n        handle.NewRequest().TakeChannel().release());\n    if (status != ZX_OK) {\n      return;\n    }\n\n    fuchsia::intl::PropertyProviderPtr intl_provider;\n    status = intl_provider.Bind(std::move(handle), loop.dispatcher());\n    if (status != ZX_OK) {\n      return;\n    }\n\n    intl_provider->GetProfile(\n        [&loop, &primary_tz](fuchsia::intl::Profile profile) {\n          if (!profile.time_zones().empty()) {\n            primary_tz = profile.time_zones()[0].id;\n          }\n          loop.Quit();\n        });\n    loop.Run(zx::deadline_after(kTimeout));\n  }();\n\n  if (!primary_tz.empty()) {\n    zone = primary_tz.c_str();\n  }\n#endif\n#if defined(USE_WIN32_LOCAL_TIME_ZONE)\n  // Use the WinRT Calendar class to get the local time zone. This feature is\n  // available on Windows 10 and later. The library is dynamically linked to\n  // maintain binary compatibility with Windows XP - Windows 7. On Windows 8,\n  // The combase.dll API functions are available but the RoActivateInstance\n  // call will fail for the Calendar class.\n  std::string winrt_tz;\n  const HMODULE combase =\n      LoadLibraryEx(_T(\"combase.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\n  if (combase) {\n    const auto ro_initialize = reinterpret_cast<decltype(&::RoInitialize)>(\n        GetProcAddress(combase, \"RoInitialize\"));\n    const auto ro_uninitialize = reinterpret_cast<decltype(&::RoUninitialize)>(\n        GetProcAddress(combase, \"RoUninitialize\"));\n    if (ro_initialize && ro_uninitialize) {\n      const HRESULT hr = ro_initialize(RO_INIT_MULTITHREADED);\n      // RPC_E_CHANGED_MODE means that a previous RoInitialize call specified\n      // a different concurrency model. The WinRT runtime is initialized and\n      // should work for our purpose here, but we should *not* call\n      // RoUninitialize because it's a failure.\n      if (SUCCEEDED(hr) || hr == RPC_E_CHANGED_MODE) {\n        winrt_tz = win32_local_time_zone(combase);\n        if (SUCCEEDED(hr)) {\n          ro_uninitialize();\n        }\n      }\n    }\n    FreeLibrary(combase);\n  }\n  if (!winrt_tz.empty()) {\n    zone = winrt_tz.c_str();\n  }\n#endif\n\n  // Allow ${TZ} to override to default zone.\n  char* tz_env = nullptr;\n#if defined(_MSC_VER)\n  _dupenv_s(&tz_env, nullptr, \"TZ\");\n#else\n  tz_env = std::getenv(\"TZ\");\n#endif\n  if (tz_env) zone = tz_env;\n\n  // We only support the \"[:]<zone-name>\" form.\n  if (*zone == ':') ++zone;\n\n  // Map \"localtime\" to a system-specific name, but\n  // allow ${LOCALTIME} to override the default name.\n  char* localtime_env = nullptr;\n  if (strcmp(zone, \"localtime\") == 0) {\n#if defined(_MSC_VER)\n    // System-specific default is just \"localtime\".\n    _dupenv_s(&localtime_env, nullptr, \"LOCALTIME\");\n#else\n    zone = \"/etc/localtime\";  // System-specific default.\n    localtime_env = std::getenv(\"LOCALTIME\");\n#endif\n    if (localtime_env) zone = localtime_env;\n  }\n\n  const std::string name = zone;\n#if defined(_MSC_VER)\n  free(localtime_env);\n  free(tz_env);\n#endif\n\n  time_zone tz;\n  load_time_zone(name, &tz);  // Falls back to UTC.\n  // TODO: Follow the RFC3339 \"Unknown Local Offset Convention\" and\n  // arrange for %z to generate \"-0000\" when we don't know the local\n  // offset because the load_time_zone() failed and we're using UTC.\n  return tz;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03256",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/src/time_zone_lookup.cc",
  "source_line": 222,
  "validation_status": "validated"
}