{
  "code": "{\n  FrontendInputFile CurrentInput;\n  std::unique_ptr<ASTUnit> CurrentASTUnit;\n  CompilerInstance *Instance;\n  friend class ASTMergeAction;\n  friend class WrapperFrontendAction;\n\nprivate:\n  std::unique_ptr<ASTConsumer> CreateWrappedASTConsumer(CompilerInstance &CI,\n                                                        StringRef InFile);\n\nprotected:\n  /// @name Implementation Action Interface\n  /// @{\n\n  /// Prepare to execute the action on the given CompilerInstance.\n  ///\n  /// This is called before executing the action on any inputs, and can modify\n  /// the configuration as needed (including adjusting the input list).\n  virtual bool PrepareToExecuteAction(CompilerInstance &CI) { return true; }\n\n  /// Create the AST consumer object for this action, if supported.\n  ///\n  /// This routine is called as part of BeginSourceFile(), which will\n  /// fail if the AST consumer cannot be created. This will not be called if the\n  /// action has indicated that it only uses the preprocessor.\n  ///\n  /// \\param CI - The current compiler instance, provided as a convenience, see\n  /// getCompilerInstance().\n  ///\n  /// \\param InFile - The current input file, provided as a convenience, see\n  /// getCurrentFile().\n  ///\n  /// \\return The new AST consumer, or null on failure.\n  virtual std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                         StringRef InFile) = 0;\n\n  /// Callback before starting processing a single input, giving the\n  /// opportunity to modify the CompilerInvocation or do some other action\n  /// before BeginSourceFileAction is called.\n  ///\n  /// \\return True on success; on failure BeginSourceFileAction(),\n  /// ExecuteAction() and EndSourceFileAction() will not be called.\n  virtual bool BeginInvocation(CompilerInstance &CI) { return true; }\n\n  /// Callback at the start of processing a single input.\n  ///\n  /// \\return True on success; on failure ExecutionAction() and\n  /// EndSourceFileAction() will not be called.\n  virtual bool BeginSourceFileAction(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Callback to run the program action, using the initialized\n  /// compiler instance.\n  ///\n  /// This is guaranteed to only be called between BeginSourceFileAction()\n  /// and EndSourceFileAction().\n  virtual void ExecuteAction() = 0;\n\n  /// Callback at the end of processing a single input.\n  ///\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual void EndSourceFileAction() {}\n\n  /// Callback at the end of processing a single input, to determine\n  /// if the output files should be erased or not.\n  ///\n  /// By default it returns true if a compiler error occurred.\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual bool shouldEraseOutputFiles();\n\n  /// @}\n\npublic:\n  FrontendAction();\n  virtual ~FrontendAction();\n\n  /// @name Compiler Instance Access\n  /// @{\n\n  CompilerInstance &getCompilerInstance() const {\n    assert(Instance && \"Compiler instance not registered!\");\n    return *Instance;\n  }\n\n  void setCompilerInstance(CompilerInstance *Value) { Instance = Value; }\n\n  /// @}\n  /// @name Current File Information\n  /// @{\n\n  bool isCurrentFileAST() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return (bool)CurrentASTUnit;\n  }\n\n  const FrontendInputFile &getCurrentInput() const {\n    return CurrentInput;\n  }\n\n  StringRef getCurrentFile() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getFile();\n  }\n\n  StringRef getCurrentFileOrBufferName() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.isFile()\n               ? CurrentInput.getFile()\n               : CurrentInput.getBuffer().getBufferIdentifier();\n  }\n\n  InputKind getCurrentFileKind() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getKind();\n  }\n\n  ASTUnit &getCurrentASTUnit() const {\n    assert(CurrentASTUnit && \"No current AST unit!\");\n    return *CurrentASTUnit;\n  }\n\n  Module *getCurrentModule() const;\n\n  std::unique_ptr<ASTUnit> takeCurrentASTUnit() {\n    return std::move(CurrentASTUnit);\n  }\n\n  void setCurrentInput(const FrontendInputFile &CurrentInput,\n                       std::unique_ptr<ASTUnit> AST = nullptr);\n\n  /// @}\n  /// @name Supported Modes\n  /// @{\n\n  /// Is this action invoked on a model file?\n  ///\n  /// Model files are incomplete translation units that relies on type\n  /// information from another translation unit. Check ParseModelFileAction for\n  /// details.\n  virtual bool isModelParsingAction() const { return false; }\n\n  /// Does this action only use the preprocessor?\n  ///\n  /// If so no AST context will be created and this action will be invalid\n  /// with AST file inputs.\n  virtual bool usesPreprocessorOnly() const = 0;\n\n  /// For AST-based actions, the kind of translation unit we're handling.\n  virtual TranslationUnitKind getTranslationUnitKind() { return TU_Complete; }\n\n  /// Does this action support use with PCH?\n  virtual bool hasPCHSupport() const { return true; }\n\n  /// Does this action support use with AST files?\n  virtual bool hasASTFileSupport() const { return true; }\n\n  /// Does this action support use with IR files?\n  virtual bool hasIRSupport() const { return false; }\n\n  /// Does this action support use with code completion?\n  virtual bool hasCodeCompletionSupport() const { return false; }\n\n  /// @}\n  /// @name Public Action Interface\n  /// @{\n\n  /// Prepare the action to execute on the given compiler instance.\n  bool PrepareToExecute(CompilerInstance &CI) {\n    return PrepareToExecuteAction(CI);\n  }\n\n  /// Prepare the action for processing the input file \\p Input.\n  ///\n  /// This is run after the options and frontend have been initialized,\n  /// but prior to executing any per-file processing.\n  ///\n  /// \\param CI - The compiler instance this action is being run from. The\n  /// action may store and use this object up until the matching EndSourceFile\n  /// action.\n  ///\n  /// \\param Input - The input filename and kind. Some input kinds are handled\n  /// specially, for example AST inputs, since the AST file itself contains\n  /// several objects which would normally be owned by the\n  /// CompilerInstance. When processing AST input files, these objects should\n  /// generally not be initialized in the CompilerInstance -- they will\n  /// automatically be shared with the AST file in between\n  /// BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\return True on success; on failure the compilation of this file should\n  /// be aborted and neither Execute() nor EndSourceFile() should be called.\n  bool BeginSourceFile(CompilerInstance &CI, const FrontendInputFile &Input);\n\n  /// Set the source manager's main input file, and run the action.\n  llvm::Error Execute();\n\n  /// Perform any per-file post processing, deallocate per-file\n  /// objects, and run statistics and output file cleanup code.\n  virtual void EndSourceFile();\n\n  /// @}\n}",
  "id": "BLOCK-CPP-18305",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/FrontendAction.h",
  "source_line": 36,
  "validation_status": "validated"
}