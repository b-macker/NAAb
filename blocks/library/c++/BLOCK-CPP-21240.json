{
  "code": "{\npublic:\n  /// Constructs a clang tool to run over a list of files.\n  ///\n  /// \\param Compilations The CompilationDatabase which contains the compile\n  ///        command lines for the given source paths.\n  /// \\param SourcePaths The source files to run over. If a source files is\n  ///        not found in Compilations, it is skipped.\n  /// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n  /// clang modules.\n  /// \\param BaseFS VFS used for all underlying file accesses when running the\n  /// tool.\n  /// \\param Files The file manager to use for underlying file operations when\n  /// running the tool.\n  ClangTool(const CompilationDatabase &Compilations,\n            ArrayRef<std::string> SourcePaths,\n            std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n                std::make_shared<PCHContainerOperations>(),\n            IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS =\n                llvm::vfs::getRealFileSystem(),\n            IntrusiveRefCntPtr<FileManager> Files = nullptr);\n\n  ~ClangTool();\n\n  /// Set a \\c DiagnosticConsumer to use during parsing.\n  void setDiagnosticConsumer(DiagnosticConsumer *DiagConsumer) {\n    this->DiagConsumer = DiagConsumer;\n  }\n\n  /// Map a virtual file to be used while running the tool.\n  ///\n  /// \\param FilePath The path at which the content will be mapped.\n  /// \\param Content A null terminated buffer of the file's content.\n  void mapVirtualFile(StringRef FilePath, StringRef Content);\n\n  /// Append a command line arguments adjuster to the adjuster chain.\n  ///\n  /// \\param Adjuster An argument adjuster, which will be run on the output of\n  ///        previous argument adjusters.\n  void appendArgumentsAdjuster(ArgumentsAdjuster Adjuster);\n\n  /// Clear the command line arguments adjuster chain.\n  void clearArgumentsAdjusters();\n\n  /// Runs an action over all files specified in the command line.\n  ///\n  /// \\param Action Tool action.\n  ///\n  /// \\returns 0 on success; 1 if any error occurred; 2 if there is no error but\n  /// some files are skipped due to missing compile commands.\n  int run(ToolAction *Action);\n\n  /// Create an AST for each file specified in the command line and\n  /// append them to ASTs.\n  int buildASTs(std::vector<std::unique_ptr<ASTUnit>> &ASTs);\n\n  /// Sets whether an error message should be printed out if an action fails. By\n  /// default, if an action fails, a message is printed out to stderr.\n  void setPrintErrorMessage(bool PrintErrorMessage);\n\n  /// Returns the file manager used in the tool.\n  ///\n  /// The file manager is shared between all translation units.\n  FileManager &getFiles() { return *Files; }\n\n  llvm::ArrayRef<std::string> getSourcePaths() const { return SourcePaths; }\n\nprivate:\n  const CompilationDatabase &Compilations;\n  std::vector<std::string> SourcePaths;\n  std::shared_ptr<PCHContainerOperations> PCHContainerOps;\n\n  llvm::IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> OverlayFileSystem;\n  llvm::IntrusiveRefCntPtr<llvm::vfs::InMemoryFileSystem> InMemoryFileSystem;\n  llvm::IntrusiveRefCntPtr<FileManager> Files;\n\n  // Contains a list of pairs (<file name>, <file content>).\n  std::vector<std::pair<StringRef, StringRef>> MappedFileContents;\n\n  llvm::StringSet<> SeenWorkingDirectories;\n\n  ArgumentsAdjuster ArgsAdjuster;\n\n  DiagnosticConsumer *DiagConsumer = nullptr;\n\n  bool PrintErrorMessage = true;\n}",
  "id": "BLOCK-CPP-21240",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/Tooling.h",
  "source_line": 308,
  "validation_status": "validated"
}