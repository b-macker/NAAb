{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace synchronization_internal {\n\n// An optional timeout, with nanosecond granularity.\n//\n// This is a private low-level API for use by a handful of low-level\n// components. Higher-level components should build APIs based on\n// absl::Time and absl::Duration.\nclass KernelTimeout {\n public:\n  // Construct an absolute timeout that should expire at `t`.\n  explicit KernelTimeout(absl::Time t);\n\n  // Construct a relative timeout that should expire after `d`.\n  explicit KernelTimeout(absl::Duration d);\n\n  // Infinite timeout.\n  constexpr KernelTimeout() : rep_(kNoTimeout) {}\n\n  // A more explicit factory for those who prefer it.\n  // Equivalent to `KernelTimeout()`.\n  static constexpr KernelTimeout Never() { return KernelTimeout(); }\n\n  // Returns true if there is a timeout that will eventually expire.\n  // Returns false if the timeout is infinite.\n  bool has_timeout() const { return rep_ != kNoTimeout; }\n\n  // If `has_timeout()` is true, returns true if the timeout was provided as an\n  // `absl::Time`. The return value is undefined if `has_timeout()` is false\n  // because all indefinite timeouts are equivalent.\n  bool is_absolute_timeout() const { return (rep_ & 1) == 0; }\n\n  // If `has_timeout()` is true, returns true if the timeout was provided as an\n  // `absl::Duration`. The return value is undefined if `has_timeout()` is false\n  // because all indefinite timeouts are equivalent.\n  bool is_relative_timeout() const { return (rep_ & 1) == 1; }\n\n  // Convert to `struct timespec` for interfaces that expect an absolute\n  // timeout. If !has_timeout() or is_relative_timeout(), attempts to convert to\n  // a reasonable absolute timeout, but callers should to test has_timeout() and\n  // is_relative_timeout() and prefer to use a more appropriate interface.\n  struct timespec MakeAbsTimespec() const;\n\n  // Convert to `struct timespec` for interfaces that expect a relative\n  // timeout. If !has_timeout() or is_absolute_timeout(), attempts to convert to\n  // a reasonable relative timeout, but callers should to test has_timeout() and\n  // is_absolute_timeout() and prefer to use a more appropriate interface. Since\n  // the return value is a relative duration, it should be recomputed by calling\n  // this method in the case of a spurious wakeup.\n  struct timespec MakeRelativeTimespec() const;\n\n#ifndef _WIN32\n  // Convert to `struct timespec` for interfaces that expect an absolute timeout\n  // on a specific clock `c`. This is similar to `MakeAbsTimespec()`, but\n  // callers usually want to use this method with `CLOCK_MONOTONIC` when\n  // relative timeouts are requested, and when the appropriate interface expects\n  // an absolute timeout relative to a specific clock (for example,\n  // pthread_cond_clockwait() or sem_clockwait()). If !has_timeout(), attempts\n  // to convert to a reasonable absolute timeout, but callers should to test\n  // has_timeout() prefer to use a more appropriate interface.\n  struct timespec MakeClockAbsoluteTimespec(clockid_t c) const;\n#endif\n\n  // Convert to unix epoch nanos for interfaces that expect an absolute timeout\n  // in nanoseconds. If !has_timeout() or is_relative_timeout(), attempts to\n  // convert to a reasonable absolute timeout, but callers should to test\n  // has_timeout() and is_relative_timeout() and prefer to use a more\n  // appropriate interface.\n  int64_t MakeAbsNanos() const;\n\n  // Converts to milliseconds from now, or INFINITE when\n  // !has_timeout(). For use by SleepConditionVariableSRW on\n  // Windows. Callers should recognize that the return value is a\n  // relative duration (it should be recomputed by calling this method\n  // in the case of a spurious wakeup).\n  // This header file may be included transitively by public header files,\n  // so we define our own DWORD and INFINITE instead of getting them from\n  // <intsafe.h> and <WinBase.h>.\n  typedef unsigned long DWord;  // NOLINT\n  DWord InMillisecondsFromNow() const;\n\n  // Convert to std::chrono::time_point for interfaces that expect an absolute\n  // timeout, like std::condition_variable::wait_until(). If !has_timeout() or\n  // is_relative_timeout(), attempts to convert to a reasonable absolute\n  // timeout, but callers should test has_timeout() and is_relative_timeout()\n  // and prefer to use a more appropriate interface.\n  std::chrono::time_point<std::chrono::system_clock> ToChronoTimePoint() const;\n\n  // Convert to std::chrono::time_point for interfaces that expect a relative\n  // timeout, like std::condition_variable::wait_for(). If !has_timeout() or\n  // is_absolute_timeout(), attempts to convert to a reasonable relative\n  // timeout, but callers should test has_timeout() and is_absolute_timeout()\n  // and prefer to use a more appropriate interface. Since the return value is a\n  // relative duration, it should be recomputed by calling this method in the\n  // case of a spurious wakeup.\n  std::chrono::nanoseconds ToChronoDuration() const;\n\n  // Returns true if steady (aka monotonic) clocks are supported by the system.\n  // This method exists because go/btm requires synchronized clocks, and\n  // thus requires we use the system (aka walltime) clock.\n  static constexpr bool SupportsSteadyClock() { return true; }\n\n private:\n  // Returns the current time, expressed as a count of nanoseconds since the\n  // epoch used by an arbitrary clock. The implementation tries to use a steady\n  // (monotonic) clock if one is available.\n  static int64_t SteadyClockNow();\n\n  // Internal representation.\n  //   - If the value is kNoTimeout, then the timeout is infinite, and\n  //     has_timeout() will return true.\n  //   - If the low bit is 0, then the high 63 bits is the number of nanoseconds\n  //     after the unix epoch.\n  //   - If the low bit is 1, then the high 63 bits is the number of nanoseconds\n  //     after the epoch used by SteadyClockNow().\n  //\n  // In all cases the time is stored as an absolute time, the only difference is\n  // the clock epoch. The use of absolute times is important since in the case\n  // of a relative timeout with a spurious wakeup, the program would have to\n  // restart the wait, and thus needs a way of recomputing the remaining time.\n  uint64_t rep_;\n\n  // Returns the number of nanoseconds stored in the internal representation.\n  // When combined with the clock epoch indicated by the low bit (which is\n  // accessed through is_absolute_timeout() and is_relative_timeout()), the\n  // return value is used to compute when the timeout should occur.\n  int64_t RawAbsNanos() const { return static_cast<int64_t>(rep_ >> 1); }\n\n  // Converts to nanoseconds from now. Since the return value is a relative\n  // duration, it should be recomputed by calling this method in the case of a\n  // spurious wakeup.\n  int64_t InNanosecondsFromNow() const;\n\n  // A value that represents no timeout (or an infinite timeout).\n  static constexpr uint64_t kNoTimeout = (std::numeric_limits<uint64_t>::max)();\n\n  // The maximum value that can be stored in the high 63 bits.\n  static constexpr int64_t kMaxNanos = (std::numeric_limits<int64_t>::max)();\n};\n\n}  // namespace synchronization_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06467",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/kernel_timeout.h",
  "source_line": 33,
  "validation_status": "validated"
}