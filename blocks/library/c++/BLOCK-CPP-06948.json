{
  "code": "{\n  class ASTContext;\n  class CXXMethodDecl;\n  class CXXRecordDecl;\n  class Decl;\n  class DeclGroupRef;\n  class ASTMutationListener;\n  class ASTDeserializationListener; // layering violation because void* is ugly\n  class SemaConsumer; // layering violation required for safe SemaConsumer\n  class TagDecl;\n  class VarDecl;\n  class FunctionDecl;\n  class ImportDecl;\n\n/// ASTConsumer - This is an abstract interface that should be implemented by\n/// clients that read ASTs.  This abstraction layer allows the client to be\n/// independent of the AST producer (e.g. parser vs AST dump file reader, etc).\nclass ASTConsumer {\n  /// Whether this AST consumer also requires information about\n  /// semantic analysis.\n  bool SemaConsumer = false;\n\n  friend class SemaConsumer;\n\npublic:\n  ASTConsumer() = default;\n\n  virtual ~ASTConsumer() {}\n\n  /// Initialize - This is called to initialize the consumer, providing the\n  /// ASTContext.\n  virtual void Initialize(ASTContext &Context) {}\n\n  /// HandleTopLevelDecl - Handle the specified top-level declaration.  This is\n  /// called by the parser to process every top-level Decl*.\n  ///\n  /// \\returns true to continue parsing, or false to abort parsing.\n  virtual bool HandleTopLevelDecl(DeclGroupRef D);\n\n  /// This callback is invoked each time an inline (method or friend)\n  /// function definition in a class is completed.\n  virtual void HandleInlineFunctionDefinition(FunctionDecl *D) {}\n\n  /// HandleInterestingDecl - Handle the specified interesting declaration. This\n  /// is called by the AST reader when deserializing things that might interest\n  /// the consumer. The default implementation forwards to HandleTopLevelDecl.\n  virtual void HandleInterestingDecl(DeclGroupRef D);\n\n  /// HandleTranslationUnit - This method is called when the ASTs for entire\n  /// translation unit have been parsed.\n  virtual void HandleTranslationUnit(ASTContext &Ctx) {}\n\n  /// HandleTagDeclDefinition - This callback is invoked each time a TagDecl\n  /// (e.g. struct, union, enum, class) is completed.  This allows the client to\n  /// hack on the type, which can occur at any point in the file (because these\n  /// can be defined in declspecs).\n  virtual void HandleTagDeclDefinition(TagDecl *D) {}\n\n  /// This callback is invoked the first time each TagDecl is required to\n  /// be complete.\n  virtual void HandleTagDeclRequiredDefinition(const TagDecl *D) {}\n\n  /// Invoked when a function is implicitly instantiated.\n  /// Note that at this point it does not have a body, its body is\n  /// instantiated at the end of the translation unit and passed to\n  /// HandleTopLevelDecl.\n  virtual void HandleCXXImplicitFunctionInstantiation(FunctionDecl *D) {}\n\n  /// Handle the specified top-level declaration that occurred inside\n  /// and ObjC container.\n  /// The default implementation ignored them.\n  virtual void HandleTopLevelDeclInObjCContainer(DeclGroupRef D);\n\n  /// Handle an ImportDecl that was implicitly created due to an\n  /// inclusion directive.\n  /// The default implementation passes it to HandleTopLevelDecl.\n  virtual void HandleImplicitImportDecl(ImportDecl *D);\n\n  /// CompleteTentativeDefinition - Callback invoked at the end of a translation\n  /// unit to notify the consumer that the given tentative definition should be\n  /// completed.\n  ///\n  /// The variable declaration itself will be a tentative\n  /// definition. If it had an incomplete array type, its type will\n  /// have already been changed to an array of size 1. However, the\n  /// declaration remains a tentative definition and has not been\n  /// modified by the introduction of an implicit zero initializer.\n  virtual void CompleteTentativeDefinition(VarDecl *D) {}\n\n  /// CompleteExternalDeclaration - Callback invoked at the end of a translation\n  /// unit to notify the consumer that the given external declaration should be\n  /// completed.\n  virtual void CompleteExternalDeclaration(VarDecl *D) {}\n\n  /// Callback invoked when an MSInheritanceAttr has been attached to a\n  /// CXXRecordDecl.\n  virtual void AssignInheritanceModel(CXXRecordDecl *RD) {}\n\n  /// HandleCXXStaticMemberVarInstantiation - Tell the consumer that this\n  // variable has been instantiated.\n  virtual void HandleCXXStaticMemberVarInstantiation(VarDecl *D) {}\n\n  /// Callback involved at the end of a translation unit to\n  /// notify the consumer that a vtable for the given C++ class is\n  /// required.\n  ///\n  /// \\param RD The class whose vtable was used.\n  virtual void HandleVTable(CXXRecordDecl *RD) {}\n\n  /// If the consumer is interested in entities getting modified after\n  /// their initial creation, it should return a pointer to\n  /// an ASTMutationListener here.\n  virtual ASTMutationListener *GetASTMutationListener() { return nullptr; }\n\n  /// If the consumer is interested in entities being deserialized from\n  /// AST files, it should return a pointer to a ASTDeserializationListener here\n  virtual ASTDeserializationListener *GetASTDeserializationListener() {\n    return nullptr;\n  }\n\n  /// PrintStats - If desired, print any statistics.\n  virtual void PrintStats() {}\n\n  /// This callback is called for each function if the Parser was\n  /// initialized with \\c SkipFunctionBodies set to \\c true.\n  ///\n  /// \\return \\c true if the function's body should be skipped. The function\n  /// body may be parsed anyway if it is needed (for instance, if it contains\n  /// the code completion point or is constexpr).\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\n}",
  "id": "BLOCK-CPP-06948",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTConsumer.h",
  "source_line": 16,
  "validation_status": "validated"
}