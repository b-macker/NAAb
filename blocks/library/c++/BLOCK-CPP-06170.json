{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\n// Returns the current sample rate. This represents the average interval\n// between samples.\nint32_t get_cordz_mean_interval();\n\n// Sets the sample rate with the average interval between samples.\nvoid set_cordz_mean_interval(int32_t mean_interval);\n\n// Cordz is only enabled on Linux with thread_local support.\n#if defined(ABSL_INTERNAL_CORDZ_ENABLED)\n#error ABSL_INTERNAL_CORDZ_ENABLED cannot be set directly\n#elif defined(__linux__) && defined(ABSL_HAVE_THREAD_LOCAL)\n#define ABSL_INTERNAL_CORDZ_ENABLED 1\n#endif\n\n#ifdef ABSL_INTERNAL_CORDZ_ENABLED\n\n// cordz_next_sample is the number of events until the next sample event. If\n// the value is 1 or less, the code will check on the next event if cordz is\n// enabled, and if so, will sample the Cord. cordz is only enabled when we can\n// use thread locals.\nABSL_CONST_INIT extern thread_local int64_t cordz_next_sample;\n\n// Determines if the next sample should be profiled. If it is, the value pointed\n// at by next_sample will be set with the interval until the next sample.\nbool cordz_should_profile_slow();\n\n// Returns true if the next cord should be sampled.\ninline bool cordz_should_profile() {\n  if (ABSL_PREDICT_TRUE(cordz_next_sample > 1)) {\n    cordz_next_sample--;\n    return false;\n  }\n  return cordz_should_profile_slow();\n}\n\n// Sets the interval until the next sample (for testing only)\nvoid cordz_set_next_sample_for_testing(int64_t next_sample);\n\n#else  // ABSL_INTERNAL_CORDZ_ENABLED\n\ninline bool cordz_should_profile() { return false; }\ninline void cordz_set_next_sample_for_testing(int64_t) {}\n\n#endif  // ABSL_INTERNAL_CORDZ_ENABLED\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06170",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_functions.h",
  "source_line": 24,
  "validation_status": "validated"
}