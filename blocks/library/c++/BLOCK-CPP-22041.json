{
  "code": "{\nnamespace dataflow {\n\n/// Base class for all values computed by abstract interpretation.\n///\n/// Don't use `Value` instances by value. All `Value` instances are allocated\n/// and owned by `DataflowAnalysisContext`.\nclass Value {\npublic:\n  enum class Kind {\n    Integer,\n    Reference,\n    Pointer,\n    Struct,\n\n    // TODO: Top values should not be need to be type-specific.\n    TopBool,\n    AtomicBool,\n    FormulaBool,\n  };\n\n  explicit Value(Kind ValKind) : ValKind(ValKind) {}\n\n  // Non-copyable because addresses of values are used as their identities\n  // throughout framework and user code. The framework is responsible for\n  // construction and destruction of values.\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  virtual ~Value() = default;\n\n  Kind getKind() const { return ValKind; }\n\n  /// Returns the value of the synthetic property with the given `Name` or null\n  /// if the property isn't assigned a value.\n  Value *getProperty(llvm::StringRef Name) const {\n    return Properties.lookup(Name);\n  }\n\n  /// Assigns `Val` as the value of the synthetic property with the given\n  /// `Name`.\n  void setProperty(llvm::StringRef Name, Value &Val) {\n    Properties.insert_or_assign(Name, &Val);\n  }\n\n  llvm::iterator_range<llvm::StringMap<Value *>::const_iterator>\n  properties() const {\n    return {Properties.begin(), Properties.end()};\n  }\n\nprivate:\n  Kind ValKind;\n  llvm::StringMap<Value *> Properties;\n};\n\n/// An equivalence relation for values. It obeys reflexivity, symmetry and\n/// transitivity. It does *not* include comparison of `Properties`.\n///\n/// Computes equivalence for these subclasses:\n/// * ReferenceValue, PointerValue -- pointee locations are equal. Does not\n///   compute deep equality of `Value` at said location.\n/// * TopBoolValue -- both are `TopBoolValue`s.\n///\n/// Otherwise, falls back to pointer equality.\nbool areEquivalentValues(const Value &Val1, const Value &Val2);\n\n/// Models a boolean.\nclass BoolValue : public Value {\n  const Formula *F;\n\npublic:\n  explicit BoolValue(Kind ValueKind, const Formula &F)\n      : Value(ValueKind), F(&F) {}\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::TopBool ||\n           Val->getKind() == Kind::AtomicBool ||\n           Val->getKind() == Kind::FormulaBool;\n  }\n\n  const Formula &formula() const { return *F; }\n};\n\n/// A TopBoolValue represents a boolean that is explicitly unconstrained.\n///\n/// This is equivalent to an AtomicBoolValue that does not appear anywhere\n/// else in a system of formula.\n/// Knowing the value is unconstrained is useful when e.g. reasoning about\n/// convergence.\nclass TopBoolValue final : public BoolValue {\npublic:\n  TopBoolValue(const Formula &F) : BoolValue(Kind::TopBool, F) {\n    assert(F.kind() == Formula::AtomRef);\n  }\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::TopBool;\n  }\n\n  Atom getAtom() const { return formula().getAtom(); }\n};\n\n/// Models an atomic boolean.\n///\n/// FIXME: Merge this class into FormulaBoolValue.\n///        When we want to specify atom identity, use Atom.\nclass AtomicBoolValue final : public BoolValue {\npublic:\n  explicit AtomicBoolValue(const Formula &F) : BoolValue(Kind::AtomicBool, F) {\n    assert(F.kind() == Formula::AtomRef);\n  }\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::AtomicBool;\n  }\n\n  Atom getAtom() const { return formula().getAtom(); }\n};\n\n/// Models a compound boolean formula.\nclass FormulaBoolValue final : public BoolValue {\npublic:\n  explicit FormulaBoolValue(const Formula &F)\n      : BoolValue(Kind::FormulaBool, F) {\n    assert(F.kind() != Formula::AtomRef && \"For now, use AtomicBoolValue\");\n  }\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::FormulaBool;\n  }\n};\n\n/// Models an integer.\nclass IntegerValue : public Value {\npublic:\n  explicit IntegerValue() : Value(Kind::Integer) {}\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::Integer;\n  }\n};\n\n/// Models a dereferenced pointer. For example, a reference in C++ or an lvalue\n/// in C.\nclass ReferenceValue final : public Value {\npublic:\n  explicit ReferenceValue(StorageLocation &ReferentLoc)\n      : Value(Kind::Reference), ReferentLoc(ReferentLoc) {}\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::Reference;\n  }\n\n  StorageLocation &getReferentLoc() const { return ReferentLoc; }\n\nprivate:\n  StorageLocation &ReferentLoc;\n};\n\n/// Models a symbolic pointer. Specifically, any value of type `T*`.\nclass PointerValue final : public Value {\npublic:\n  explicit PointerValue(StorageLocation &PointeeLoc)\n      : Value(Kind::Pointer), PointeeLoc(PointeeLoc) {}\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::Pointer;\n  }\n\n  StorageLocation &getPointeeLoc() const { return PointeeLoc; }\n\nprivate:\n  StorageLocation &PointeeLoc;\n};\n\n/// Models a value of `struct` or `class` type.\n/// In C++, prvalues of class type serve only a limited purpose: They can only\n/// be used to initialize a result object. It is not possible to access member\n/// variables or call member functions on a prvalue of class type.\n/// Correspondingly, `StructValue` also serves only two limited purposes:\n/// - It conveys a prvalue of class type from the place where the object is\n///   constructed to the result object that it initializes.\n///\n///   When creating a prvalue of class type, we already need a storage location\n///   for `this`, even though prvalues are otherwise not associated with storage\n///   locations. `StructValue` is therefore essentially a wrapper for a storage\n///   location, which is then used to set the storage location for the result\n///   object when we process the AST node for that result object.\n///\n///   For example:\n///      MyStruct S = MyStruct(3);\n///\n///   In this example, `MyStruct(3) is a prvalue, which is modeled as a\n///   `StructValue` that wraps an `AbstractStorageLocation`. This\n//    `AbstractStorageLocation` is then used as the storage location for `S`.\n///\n/// - It allows properties to be associated with an object of class type.\n///   Note that when doing so, you should avoid mutating the properties of an\n///   existing `StructValue` in place, as these changes would be visible to\n///   other `Environment`s that share the same `StructValue`. Instead, associate\n///   a new `StructValue` with the `AggregateStorageLocation` and set the\n///   properties on this new `StructValue`. (See also `refreshStructValue()` in\n///   DataflowEnvironment.h, which makes this easy.)\n///   Note also that this implies that it is common for the same\n///   `AggregateStorageLocation` to be associated with different `StructValue`s\n///   in different environments.\n/// Over time, we may eliminate `StructValue` entirely. See also the discussion\n/// here: https://reviews.llvm.org/D155204#inline-1503204\nclass StructValue final : public Value {\npublic:\n  explicit StructValue(AggregateStorageLocation &Loc)\n      : Value(Kind::Struct), Loc(Loc) {}\n\n  static bool classof(const Value *Val) {\n    return Val->getKind() == Kind::Struct;\n  }\n\n  /// Returns the storage location that this `StructValue` is associated with.\n  AggregateStorageLocation &getAggregateLoc() const { return Loc; }\n\n  /// Convenience function that returns the child storage location for `Field`.\n  /// See also the documentation for `AggregateStorageLocation::getChild()`.\n  StorageLocation *getChild(const ValueDecl &Field) const {\n    return Loc.getChild(Field);\n  }\n\nprivate:\n  AggregateStorageLocation &Loc;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const Value &Val);\n\n} // namespace dataflow\n}",
  "id": "BLOCK-CPP-22041",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/Value.h",
  "source_line": 26,
  "validation_status": "validated"
}