{
  "code": "{\n\n// A traits-like metafunction for selecting the default Delimiter object type\n// for a particular Delimiter type. The base case simply exposes type Delimiter\n// itself as the delimiter's Type. However, there are specializations for\n// string-like objects that map them to the ByString delimiter object.\n// This allows functions like absl::StrSplit() and absl::MaxSplits() to accept\n// string-like objects (e.g., ',') as delimiter arguments but they will be\n// treated as if a ByString delimiter was given.\ntemplate <typename Delimiter>\nstruct SelectDelimiter {\n  using type = Delimiter;\n};\n\ntemplate <>\nstruct SelectDelimiter<char> {\n  using type = ByChar;\n};\ntemplate <>\nstruct SelectDelimiter<char*> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<const char*> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<absl::string_view> {\n  using type = ByString;\n};\ntemplate <>\nstruct SelectDelimiter<std::string> {\n  using type = ByString;\n};\n\n// Wraps another delimiter and sets a max number of matches for that delimiter.\ntemplate <typename Delimiter>\nclass MaxSplitsImpl {\n public:\n  MaxSplitsImpl(Delimiter delimiter, int limit)\n      : delimiter_(delimiter), limit_(limit), count_(0) {}\n  absl::string_view Find(absl::string_view text, size_t pos) {\n    if (count_++ == limit_) {\n      return absl::string_view(text.data() + text.size(),\n                               0);  // No more matches.\n    }\n    return delimiter_.Find(text, pos);\n  }\n\n private:\n  Delimiter delimiter_;\n  const int limit_;\n  int count_;\n};\n\n}",
  "id": "BLOCK-CPP-04200",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/str_split.h",
  "source_line": 240,
  "validation_status": "validated"
}