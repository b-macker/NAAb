{
  "code": "{\n\nclass CompilationDatabase;\n\n/// Retrieves the flags of the `-cc1` job in `Compilation` that has only source\n/// files as its inputs.\n/// Returns nullptr if there are no such jobs or multiple of them. Note that\n/// offloading jobs are ignored.\nconst llvm::opt::ArgStringList *\ngetCC1Arguments(DiagnosticsEngine *Diagnostics,\n                driver::Compilation *Compilation);\n\n/// Interface to process a clang::CompilerInvocation.\n///\n/// If your tool is based on FrontendAction, you should be deriving from\n/// FrontendActionFactory instead.\nclass ToolAction {\npublic:\n  virtual ~ToolAction();\n\n  /// Perform an action for an invocation.\n  virtual bool\n  runInvocation(std::shared_ptr<CompilerInvocation> Invocation,\n                FileManager *Files,\n                std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n                DiagnosticConsumer *DiagConsumer) = 0;\n};\n\n/// Interface to generate clang::FrontendActions.\n///\n/// Having a factory interface allows, for example, a new FrontendAction to be\n/// created for each translation unit processed by ClangTool.  This class is\n/// also a ToolAction which uses the FrontendActions created by create() to\n/// process each translation unit.\nclass FrontendActionFactory : public ToolAction {\npublic:\n  ~FrontendActionFactory() override;\n\n  /// Invokes the compiler with a FrontendAction created by create().\n  bool runInvocation(std::shared_ptr<CompilerInvocation> Invocation,\n                     FileManager *Files,\n                     std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n                     DiagnosticConsumer *DiagConsumer) override;\n\n  /// Returns a new clang::FrontendAction.\n  virtual std::unique_ptr<FrontendAction> create() = 0;\n};\n\n/// Returns a new FrontendActionFactory for a given type.\n///\n/// T must derive from clang::FrontendAction.\n///\n/// Example:\n/// std::unique_ptr<FrontendActionFactory> Factory =\n///   newFrontendActionFactory<clang::SyntaxOnlyAction>();\ntemplate <typename T>\nstd::unique_ptr<FrontendActionFactory> newFrontendActionFactory();\n\n/// Callbacks called before and after each source file processed by a\n/// FrontendAction created by the FrontedActionFactory returned by \\c\n/// newFrontendActionFactory.\nclass SourceFileCallbacks {\npublic:\n  virtual ~SourceFileCallbacks() = default;\n\n  /// Called before a source file is processed by a FrontEndAction.\n  /// \\see clang::FrontendAction::BeginSourceFileAction\n  virtual bool handleBeginSource(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Called after a source file is processed by a FrontendAction.\n  /// \\see clang::FrontendAction::EndSourceFileAction\n  virtual void handleEndSource() {}\n};\n\n/// Returns a new FrontendActionFactory for any type that provides an\n/// implementation of newASTConsumer().\n///\n/// FactoryT must implement: ASTConsumer *newASTConsumer().\n///\n/// Example:\n/// struct ProvidesASTConsumers {\n///   std::unique_ptr<clang::ASTConsumer> newASTConsumer();\n/// } Factory;\n/// std::unique_ptr<FrontendActionFactory> FactoryAdapter(\n///   newFrontendActionFactory(&Factory));\ntemplate <typename FactoryT>\ninline std::unique_ptr<FrontendActionFactory> newFrontendActionFactory(\n    FactoryT *ConsumerFactory, SourceFileCallbacks *Callbacks = nullptr);\n\n/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag.\n///\n/// \\param ToolAction The action to run over the code.\n/// \\param Code C++ code.\n/// \\param FileName The file name which 'Code' will be mapped as.\n/// \\param PCHContainerOps  The PCHContainerOperations for loading and creating\n///                         clang modules.\n///\n/// \\return - True if 'ToolAction' was successfully executed.\nbool runToolOnCode(std::unique_ptr<FrontendAction> ToolAction, const Twine &Code,\n                   const Twine &FileName = \"input.cc\",\n                   std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n                       std::make_shared<PCHContainerOperations>());\n\n/// The first part of the pair is the filename, the second part the\n/// file-content.\nusing FileContentMappings = std::vector<std::pair<std::string, std::string>>;\n\n/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag and\n///        with additional other flags.\n///\n/// \\param ToolAction The action to run over the code.\n/// \\param Code C++ code.\n/// \\param Args Additional flags to pass on.\n/// \\param FileName The file name which 'Code' will be mapped as.\n/// \\param ToolName The name of the binary running the tool. Standard library\n///                 header paths will be resolved relative to this.\n/// \\param PCHContainerOps   The PCHContainerOperations for loading and creating\n///                          clang modules.\n///\n/// \\return - True if 'ToolAction' was successfully executed.\nbool runToolOnCodeWithArgs(\n    std::unique_ptr<FrontendAction> ToolAction, const Twine &Code,\n    const std::vector<std::string> &Args, const Twine &FileName = \"input.cc\",\n    const Twine &ToolName = \"clang-tool\",\n    std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n        std::make_shared<PCHContainerOperations>(),\n    const FileContentMappings &VirtualMappedFiles = FileContentMappings());\n\n// Similar to the overload except this takes a VFS.\nbool runToolOnCodeWithArgs(\n    std::unique_ptr<FrontendAction> ToolAction, const Twine &Code,\n    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n    const std::vector<std::string> &Args, const Twine &FileName = \"input.cc\",\n    const Twine &ToolName = \"clang-tool\",\n    std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n        std::make_shared<PCHContainerOperations>());\n\n/// Builds an AST for 'Code'.\n///\n/// \\param Code C++ code.\n/// \\param FileName The file name which 'Code' will be mapped as.\n/// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n/// clang modules.\n///\n/// \\return The resulting AST or null if an error occurred.\nstd::unique_ptr<ASTUnit>\nbuildASTFromCode(StringRef Code, StringRef FileName = \"input.cc\",\n                 std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n                     std::make_shared<PCHContainerOperations>());\n\n/// Builds an AST for 'Code' with additional flags.\n///\n/// \\param Code C++ code.\n/// \\param Args Additional flags to pass on.\n/// \\param FileName The file name which 'Code' will be mapped as.\n/// \\param ToolName The name of the binary running the tool. Standard library\n///                 header paths will be resolved relative to this.\n/// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n/// clang modules.\n///\n/// \\param Adjuster A function to filter the command line arguments as specified.\n///\n/// \\return The resulting AST or null if an error occurred.\nstd::unique_ptr<ASTUnit> buildASTFromCodeWithArgs(\n    StringRef Code, const std::vector<std::string> &Args,\n    StringRef FileName = \"input.cc\", StringRef ToolName = \"clang-tool\",\n    std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n        std::make_shared<PCHContainerOperations>(),\n    ArgumentsAdjuster Adjuster = getClangStripDependencyFileAdjuster(),\n    const FileContentMappings &VirtualMappedFiles = FileContentMappings(),\n    DiagnosticConsumer *DiagConsumer = nullptr);\n\n/// Utility to run a FrontendAction in a single clang invocation.\nclass ToolInvocation {\npublic:\n  /// Create a tool invocation.\n  ///\n  /// \\param CommandLine The command line arguments to clang. Note that clang\n  /// uses its binary name (CommandLine[0]) to locate its builtin headers.\n  /// Callers have to ensure that they are installed in a compatible location\n  /// (see clang driver implementation) or mapped in via mapVirtualFile.\n  /// \\param FAction The action to be executed.\n  /// \\param Files The FileManager used for the execution. Class does not take\n  /// ownership.\n  /// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n  /// clang modules.\n  ToolInvocation(std::vector<std::string> CommandLine,\n                 std::unique_ptr<FrontendAction> FAction, FileManager *Files,\n                 std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n                     std::make_shared<PCHContainerOperations>());\n\n  /// Create a tool invocation.\n  ///\n  /// \\param CommandLine The command line arguments to clang.\n  /// \\param Action The action to be executed.\n  /// \\param Files The FileManager used for the execution.\n  /// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n  /// clang modules.\n  ToolInvocation(std::vector<std::string> CommandLine, ToolAction *Action,\n                 FileManager *Files,\n                 std::shared_ptr<PCHContainerOperations> PCHContainerOps);\n\n  ~ToolInvocation();\n\n  /// Set a \\c DiagnosticConsumer to use during driver command-line parsing and\n  /// the action invocation itself.\n  void setDiagnosticConsumer(DiagnosticConsumer *DiagConsumer) {\n    this->DiagConsumer = DiagConsumer;\n  }\n\n  /// Set a \\c DiagnosticOptions to use during driver command-line parsing.\n  void setDiagnosticOptions(DiagnosticOptions *DiagOpts) {\n    this->DiagOpts = DiagOpts;\n  }\n\n  /// Run the clang invocation.\n  ///\n  /// \\returns True if there were no errors during execution.\n  bool run();\n\n private:\n  bool runInvocation(const char *BinaryName,\n                     driver::Compilation *Compilation,\n                     std::shared_ptr<CompilerInvocation> Invocation,\n                     std::shared_ptr<PCHContainerOperations> PCHContainerOps);\n\n  std::vector<std::string> CommandLine;\n  ToolAction *Action;\n  bool OwnsAction;\n  FileManager *Files;\n  std::shared_ptr<PCHContainerOperations> PCHContainerOps;\n  DiagnosticConsumer *DiagConsumer = nullptr;\n  DiagnosticOptions *DiagOpts = nullptr;\n};\n\n/// Utility to run a FrontendAction over a set of files.\n///\n/// This class is written to be usable for command line utilities.\n/// By default the class uses ClangSyntaxOnlyAdjuster to modify\n/// command line arguments before the arguments are used to run\n/// a frontend action. One could install an additional command line\n/// arguments adjuster by calling the appendArgumentsAdjuster() method.\nclass ClangTool {\npublic:\n  /// Constructs a clang tool to run over a list of files.\n  ///\n  /// \\param Compilations The CompilationDatabase which contains the compile\n  ///        command lines for the given source paths.\n  /// \\param SourcePaths The source files to run over. If a source files is\n  ///        not found in Compilations, it is skipped.\n  /// \\param PCHContainerOps The PCHContainerOperations for loading and creating\n  /// clang modules.\n  /// \\param BaseFS VFS used for all underlying file accesses when running the\n  /// tool.\n  /// \\param Files The file manager to use for underlying file operations when\n  /// running the tool.\n  ClangTool(const CompilationDatabase &Compilations,\n            ArrayRef<std::string> SourcePaths,\n            std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n                std::make_shared<PCHContainerOperations>(),\n            IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS =\n                llvm::vfs::getRealFileSystem(),\n            IntrusiveRefCntPtr<FileManager> Files = nullptr);\n\n  ~ClangTool();\n\n  /// Set a \\c DiagnosticConsumer to use during parsing.\n  void setDiagnosticConsumer(DiagnosticConsumer *DiagConsumer) {\n    this->DiagConsumer = DiagConsumer;\n  }\n\n  /// Map a virtual file to be used while running the tool.\n  ///\n  /// \\param FilePath The path at which the content will be mapped.\n  /// \\param Content A null terminated buffer of the file's content.\n  void mapVirtualFile(StringRef FilePath, StringRef Content);\n\n  /// Append a command line arguments adjuster to the adjuster chain.\n  ///\n  /// \\param Adjuster An argument adjuster, which will be run on the output of\n  ///        previous argument adjusters.\n  void appendArgumentsAdjuster(ArgumentsAdjuster Adjuster);\n\n  /// Clear the command line arguments adjuster chain.\n  void clearArgumentsAdjusters();\n\n  /// Runs an action over all files specified in the command line.\n  ///\n  /// \\param Action Tool action.\n  ///\n  /// \\returns 0 on success; 1 if any error occurred; 2 if there is no error but\n  /// some files are skipped due to missing compile commands.\n  int run(ToolAction *Action);\n\n  /// Create an AST for each file specified in the command line and\n  /// append them to ASTs.\n  int buildASTs(std::vector<std::unique_ptr<ASTUnit>> &ASTs);\n\n  /// Sets whether an error message should be printed out if an action fails. By\n  /// default, if an action fails, a message is printed out to stderr.\n  void setPrintErrorMessage(bool PrintErrorMessage);\n\n  /// Returns the file manager used in the tool.\n  ///\n  /// The file manager is shared between all translation units.\n  FileManager &getFiles() { return *Files; }\n\n  llvm::ArrayRef<std::string> getSourcePaths() const { return SourcePaths; }\n\nprivate:\n  const CompilationDatabase &Compilations;\n  std::vector<std::string> SourcePaths;\n  std::shared_ptr<PCHContainerOperations> PCHContainerOps;\n\n  llvm::IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> OverlayFileSystem;\n  llvm::IntrusiveRefCntPtr<llvm::vfs::InMemoryFileSystem> InMemoryFileSystem;\n  llvm::IntrusiveRefCntPtr<FileManager> Files;\n\n  // Contains a list of pairs (<file name>, <file content>).\n  std::vector<std::pair<StringRef, StringRef>> MappedFileContents;\n\n  llvm::StringSet<> SeenWorkingDirectories;\n\n  ArgumentsAdjuster ArgsAdjuster;\n\n  DiagnosticConsumer *DiagConsumer = nullptr;\n\n  bool PrintErrorMessage = true;\n};\n\ntemplate <typename T>\nstd::unique_ptr<FrontendActionFactory> newFrontendActionFactory() {\n  class SimpleFrontendActionFactory : public FrontendActionFactory {\n  public:\n    std::unique_ptr<FrontendAction> create() override {\n      return std::make_unique<T>();\n    }\n  };\n\n  return std::unique_ptr<FrontendActionFactory>(\n      new SimpleFrontendActionFactory);\n}\n\ntemplate <typename FactoryT>\ninline std::unique_ptr<FrontendActionFactory> newFrontendActionFactory(\n    FactoryT *ConsumerFactory, SourceFileCallbacks *Callbacks) {\n  class FrontendActionFactoryAdapter : public FrontendActionFactory {\n  public:\n    explicit FrontendActionFactoryAdapter(FactoryT *ConsumerFactory,\n                                          SourceFileCallbacks *Callbacks)\n        : ConsumerFactory(ConsumerFactory), Callbacks(Callbacks) {}\n\n    std::unique_ptr<FrontendAction> create() override {\n      return std::make_unique<ConsumerFactoryAdaptor>(ConsumerFactory,\n                                                      Callbacks);\n    }\n\n  private:\n    class ConsumerFactoryAdaptor : public ASTFrontendAction {\n    public:\n      ConsumerFactoryAdaptor(FactoryT *ConsumerFactory,\n                             SourceFileCallbacks *Callbacks)\n          : ConsumerFactory(ConsumerFactory), Callbacks(Callbacks) {}\n\n      std::unique_ptr<ASTConsumer>\n      CreateASTConsumer(CompilerInstance &, StringRef) override {\n        return ConsumerFactory->newASTConsumer();\n      }\n\n    protected:\n      bool BeginSourceFileAction(CompilerInstance &CI) override {\n        if (!ASTFrontendAction::BeginSourceFileAction(CI))\n          return false;\n        if (Callbacks)\n          return Callbacks->handleBeginSource(CI);\n        return true;\n      }\n\n      void EndSourceFileAction() override {\n        if (Callbacks)\n          Callbacks->handleEndSource();\n        ASTFrontendAction::EndSourceFileAction();\n      }\n\n    private:\n      FactoryT *ConsumerFactory;\n      SourceFileCallbacks *Callbacks;\n    };\n    FactoryT *ConsumerFactory;\n    SourceFileCallbacks *Callbacks;\n  };\n\n  return std::unique_ptr<FrontendActionFactory>(\n      new FrontendActionFactoryAdapter(ConsumerFactory, Callbacks));\n}\n\n/// Returns the absolute path of \\c File, by prepending it with\n/// the current directory if \\c File is not absolute.\n///\n/// Otherwise returns \\c File.\n/// If 'File' starts with \"./\", the returned path will not contain the \"./\".\n/// Otherwise, the returned path will contain the literal path-concatenation of\n/// the current directory and \\c File.\n///\n/// The difference to llvm::sys::fs::make_absolute is the canonicalization this\n/// does by removing \"./\" and computing native paths.\n///\n/// \\param File Either an absolute or relative path.\nstd::string getAbsolutePath(StringRef File);\n\n/// An overload of getAbsolutePath that works over the provided \\p FS.\nllvm::Expected<std::string> getAbsolutePath(llvm::vfs::FileSystem &FS,\n                                            StringRef File);\n\n/// Changes CommandLine to contain implicit flags that would have been\n/// defined had the compiler driver been invoked through the path InvokedAs.\n///\n/// For example, when called with \\c InvokedAs set to `i686-linux-android-g++`,\n/// the arguments '-target', 'i686-linux-android`, `--driver-mode=g++` will\n/// be inserted after the first argument in \\c CommandLine.\n///\n/// This function will not add new `-target` or `--driver-mode` flags if they\n/// are already present in `CommandLine` (even if they have different settings\n/// than would have been inserted).\n///\n/// \\pre `llvm::InitializeAllTargets()` has been called.\n///\n/// \\param CommandLine the command line used to invoke the compiler driver or\n/// Clang tool, including the path to the executable as \\c CommandLine[0].\n/// \\param InvokedAs the path to the driver used to infer implicit flags.\n///\n/// \\note This will not set \\c CommandLine[0] to \\c InvokedAs. The tooling\n/// infrastructure expects that CommandLine[0] is a tool path relative to which\n/// the builtin headers can be found.\nvoid addTargetAndModeForProgramName(std::vector<std::string> &CommandLine,\n                                    StringRef InvokedAs);\n\n/// Helper function that expands response files in command line.\nvoid addExpandedResponseFiles(std::vector<std::string> &CommandLine,\n                              llvm::StringRef WorkingDir,\n                              llvm::cl::TokenizerCallback Tokenizer,\n                              llvm::vfs::FileSystem &FS);\n\n/// Creates a \\c CompilerInvocation.\nCompilerInvocation *newInvocation(DiagnosticsEngine *Diagnostics,\n                                  ArrayRef<const char *> CC1Args,\n                                  const char *const BinaryName);\n\n}",
  "id": "BLOCK-CPP-21247",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Tooling/Tooling.h",
  "source_line": 64,
  "validation_status": "validated"
}