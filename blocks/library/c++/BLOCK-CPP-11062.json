{
  "code": "{\n\nclass ASTContext;\nclass CXXBaseSpecifier;\n\n/// ObjCStringLiteral, used for Objective-C string literals\n/// i.e. @\"foo\".\nclass ObjCStringLiteral : public Expr {\n  Stmt *String;\n  SourceLocation AtLoc;\n\npublic:\n  ObjCStringLiteral(StringLiteral *SL, QualType T, SourceLocation L)\n      : Expr(ObjCStringLiteralClass, T, VK_PRValue, OK_Ordinary), String(SL),\n        AtLoc(L) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCStringLiteral(EmptyShell Empty)\n      : Expr(ObjCStringLiteralClass, Empty) {}\n\n  StringLiteral *getString() { return cast<StringLiteral>(String); }\n  const StringLiteral *getString() const { return cast<StringLiteral>(String); }\n  void setString(StringLiteral *S) { String = S; }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return String->getEndLoc(); }\n\n  // Iterators\n  child_range children() { return child_range(&String, &String+1); }\n\n  const_child_range children() const {\n    return const_child_range(&String, &String + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCStringLiteralClass;\n  }\n};\n\n/// ObjCBoolLiteralExpr - Objective-C Boolean Literal.\nclass ObjCBoolLiteralExpr : public Expr {\n  bool Value;\n  SourceLocation Loc;\n\npublic:\n  ObjCBoolLiteralExpr(bool val, QualType Ty, SourceLocation l)\n      : Expr(ObjCBoolLiteralExprClass, Ty, VK_PRValue, OK_Ordinary), Value(val),\n        Loc(l) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCBoolLiteralExpr(EmptyShell Empty)\n      : Expr(ObjCBoolLiteralExprClass, Empty) {}\n\n  bool getValue() const { return Value; }\n  void setValue(bool V) { Value = V; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoolLiteralExprClass;\n  }\n};\n\n/// ObjCBoxedExpr - used for generalized expression boxing.\n/// as in: @(strdup(\"hello world\")), @(random()) or @(view.frame)\n/// Also used for boxing non-parenthesized numeric literals;\n/// as in: @42 or \\@true (c++/objc++) or \\@__objc_yes (c/objc).\nclass ObjCBoxedExpr : public Expr {\n  Stmt *SubExpr;\n  ObjCMethodDecl *BoxingMethod;\n  SourceRange Range;\n\npublic:\n  friend class ASTStmtReader;\n\n  ObjCBoxedExpr(Expr *E, QualType T, ObjCMethodDecl *method, SourceRange R)\n      : Expr(ObjCBoxedExprClass, T, VK_PRValue, OK_Ordinary), SubExpr(E),\n        BoxingMethod(method), Range(R) {\n    setDependence(computeDependence(this));\n  }\n  explicit ObjCBoxedExpr(EmptyShell Empty)\n      : Expr(ObjCBoxedExprClass, Empty) {}\n\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n\n  ObjCMethodDecl *getBoxingMethod() const {\n    return BoxingMethod;\n  }\n\n  // Indicates whether this boxed expression can be emitted as a compile-time\n  // constant.\n  bool isExpressibleAsConstantInitializer() const {\n    return !BoxingMethod && SubExpr;\n  }\n\n  SourceLocation getAtLoc() const { return Range.getBegin(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return Range;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n\n  using const_arg_iterator = ConstExprIterator;\n\n  const_arg_iterator arg_begin() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr);\n  }\n\n  const_arg_iterator arg_end() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoxedExprClass;\n  }\n};\n\n/// ObjCArrayLiteral - used for objective-c array containers; as in:\n/// @[@\"Hello\", NSApp, [NSNumber numberWithInt:42]];\nclass ObjCArrayLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCArrayLiteral, Expr *> {\n  unsigned NumElements;\n  SourceRange Range;\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  ObjCArrayLiteral(ArrayRef<Expr *> Elements,\n                   QualType T, ObjCMethodDecl * Method,\n                   SourceRange SR);\n\n  explicit ObjCArrayLiteral(EmptyShell Empty, unsigned NumElements)\n      : Expr(ObjCArrayLiteralClass, Empty), NumElements(NumElements) {}\n\npublic:\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  static ObjCArrayLiteral *Create(const ASTContext &C,\n                                  ArrayRef<Expr *> Elements,\n                                  QualType T, ObjCMethodDecl * Method,\n                                  SourceRange SR);\n\n  static ObjCArrayLiteral *CreateEmpty(const ASTContext &C,\n                                       unsigned NumElements);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  /// Retrieve elements of array of literals.\n  Expr **getElements() { return getTrailingObjects<Expr *>(); }\n\n  /// Retrieve elements of array of literals.\n  const Expr * const *getElements() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  /// getNumElements - Return number of elements of objective-c array literal.\n  unsigned getNumElements() const { return NumElements; }\n\n  /// getElement - Return the Element at the specified index.\n  Expr *getElement(unsigned Index) {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n  const Expr *getElement(unsigned Index) const {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n\n  ObjCMethodDecl *getArrayWithObjectsMethod() const {\n    return ArrayWithObjectsMethod;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(getElements()),\n                       reinterpret_cast<Stmt **>(getElements()) + NumElements);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCArrayLiteral *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n      return T->getStmtClass() == ObjCArrayLiteralClass;\n  }\n};\n\n/// An element in an Objective-C dictionary literal.\n///\nstruct ObjCDictionaryElement {\n  /// The key for the dictionary element.\n  Expr *Key;\n\n  /// The value of the dictionary element.\n  Expr *Value;\n\n  /// The location of the ellipsis, if this is a pack expansion.\n  SourceLocation EllipsisLoc;\n\n  /// The number of elements this pack expansion will expand to, if\n  /// this is a pack expansion and is known.\n  std::optional<unsigned> NumExpansions;\n\n  /// Determines whether this dictionary element is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n};\n\n}",
  "id": "BLOCK-CPP-11062",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ExprObjC.h",
  "source_line": 44,
  "validation_status": "validated"
}