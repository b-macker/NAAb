{
  "code": "{\n\nclass SPDLOG_API logger {\npublic:\n    // Empty logger\n    explicit logger(std::string name)\n        : name_(std::move(name)),\n          sinks_() {}\n\n    // Logger with range on sinks\n    template <typename It>\n    logger(std::string name, It begin, It end)\n        : name_(std::move(name)),\n          sinks_(begin, end) {}\n\n    // Logger with single sink\n    logger(std::string name, sink_ptr single_sink)\n        : logger(std::move(name), {std::move(single_sink)}) {}\n\n    // Logger with sinks init list\n    logger(std::string name, sinks_init_list sinks)\n        : logger(std::move(name), sinks.begin(), sinks.end()) {}\n\n    virtual ~logger() = default;\n\n    logger(const logger &other);\n    logger(logger &&other) SPDLOG_NOEXCEPT;\n    logger &operator=(logger other) SPDLOG_NOEXCEPT;\n    void swap(spdlog::logger &other) SPDLOG_NOEXCEPT;\n\n    template <typename... Args>\n    void log(source_loc loc, level::level_enum lvl, format_string_t<Args...> fmt, Args &&...args) {\n        log_(loc, lvl, details::to_string_view(fmt), std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void log(level::level_enum lvl, format_string_t<Args...> fmt, Args &&...args) {\n        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename T>\n    void log(level::level_enum lvl, const T &msg) {\n        log(source_loc{}, lvl, msg);\n    }\n\n    // T cannot be statically converted to format string (including string_view/wstring_view)\n    template <class T,\n              typename std::enable_if<!is_convertible_to_any_format_string<const T &>::value,\n                                      int>::type = 0>\n    void log(source_loc loc, level::level_enum lvl, const T &msg) {\n        log(loc, lvl, \"{}\", msg);\n    }\n\n    void log(log_clock::time_point log_time,\n             source_loc loc,\n             level::level_enum lvl,\n             string_view_t msg) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n\n        details::log_msg log_msg(log_time, loc, name_, lvl, msg);\n        log_it_(log_msg, log_enabled, traceback_enabled);\n    }\n\n    void log(source_loc loc, level::level_enum lvl, string_view_t msg) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n\n        details::log_msg log_msg(loc, name_, lvl, msg);\n        log_it_(log_msg, log_enabled, traceback_enabled);\n    }\n\n    void log(level::level_enum lvl, string_view_t msg) { log(source_loc{}, lvl, msg); }\n\n    template <typename... Args>\n    void trace(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::trace, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void debug(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::debug, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void info(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::info, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void warn(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::warn, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void error(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::err, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void critical(format_string_t<Args...> fmt, Args &&...args) {\n        log(level::critical, fmt, std::forward<Args>(args)...);\n    }\n\n#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\n    template <typename... Args>\n    void log(source_loc loc, level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&...args) {\n        log_(loc, lvl, details::to_string_view(fmt), std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void log(level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&...args) {\n        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n    }\n\n    void log(log_clock::time_point log_time,\n             source_loc loc,\n             level::level_enum lvl,\n             wstring_view_t msg) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n\n        memory_buf_t buf;\n        details::os::wstr_to_utf8buf(wstring_view_t(msg.data(), msg.size()), buf);\n        details::log_msg log_msg(log_time, loc, name_, lvl, string_view_t(buf.data(), buf.size()));\n        log_it_(log_msg, log_enabled, traceback_enabled);\n    }\n\n    void log(source_loc loc, level::level_enum lvl, wstring_view_t msg) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n\n        memory_buf_t buf;\n        details::os::wstr_to_utf8buf(wstring_view_t(msg.data(), msg.size()), buf);\n        details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));\n        log_it_(log_msg, log_enabled, traceback_enabled);\n    }\n\n    void log(level::level_enum lvl, wstring_view_t msg) { log(source_loc{}, lvl, msg); }\n\n    template <typename... Args>\n    void trace(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::trace, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void debug(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::debug, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void info(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::info, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void warn(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::warn, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void error(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::err, fmt, std::forward<Args>(args)...);\n    }\n\n    template <typename... Args>\n    void critical(wformat_string_t<Args...> fmt, Args &&...args) {\n        log(level::critical, fmt, std::forward<Args>(args)...);\n    }\n#endif\n\n    template <typename T>\n    void trace(const T &msg) {\n        log(level::trace, msg);\n    }\n\n    template <typename T>\n    void debug(const T &msg) {\n        log(level::debug, msg);\n    }\n\n    template <typename T>\n    void info(const T &msg) {\n        log(level::info, msg);\n    }\n\n    template <typename T>\n    void warn(const T &msg) {\n        log(level::warn, msg);\n    }\n\n    template <typename T>\n    void error(const T &msg) {\n        log(level::err, msg);\n    }\n\n    template <typename T>\n    void critical(const T &msg) {\n        log(level::critical, msg);\n    }\n\n    // return true logging is enabled for the given level.\n    bool should_log(level::level_enum msg_level) const {\n        return msg_level >= level_.load(std::memory_order_relaxed);\n    }\n\n    // return true if backtrace logging is enabled.\n    bool should_backtrace() const { return tracer_.enabled(); }\n\n    void set_level(level::level_enum log_level);\n\n    level::level_enum level() const;\n\n    const std::string &name() const;\n\n    // set formatting for the sinks in this logger.\n    // each sink will get a separate instance of the formatter object.\n    void set_formatter(std::unique_ptr<formatter> f);\n\n    // set formatting for the sinks in this logger.\n    // equivalent to\n    //     set_formatter(make_unique<pattern_formatter>(pattern, time_type))\n    // Note: each sink will get a new instance of a formatter object, replacing the old one.\n    void set_pattern(std::string pattern, pattern_time_type time_type = pattern_time_type::local);\n\n    // backtrace support.\n    // efficiently store all debug/trace messages in a circular buffer until needed for debugging.\n    void enable_backtrace(size_t n_messages);\n    void disable_backtrace();\n    void dump_backtrace();\n\n    // flush functions\n    void flush();\n    void flush_on(level::level_enum log_level);\n    level::level_enum flush_level() const;\n\n    // sinks\n    const std::vector<sink_ptr> &sinks() const;\n\n    std::vector<sink_ptr> &sinks();\n\n    // error handler\n    void set_error_handler(err_handler);\n\n    // create new logger with same sinks and configuration.\n    virtual std::shared_ptr<logger> clone(std::string logger_name);\n\nprotected:\n    std::string name_;\n    std::vector<sink_ptr> sinks_;\n    spdlog::level_t level_{level::info};\n    spdlog::level_t flush_level_{level::off};\n    err_handler custom_err_handler_{nullptr};\n    details::backtracer tracer_;\n\n    // common implementation for after templated public api has been resolved\n    template <typename... Args>\n    void log_(source_loc loc, level::level_enum lvl, string_view_t fmt, Args &&...args) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n        SPDLOG_TRY {\n            memory_buf_t buf;\n#ifdef SPDLOG_USE_STD_FORMAT\n            fmt_lib::vformat_to(std::back_inserter(buf), fmt, fmt_lib::make_format_args(args...));\n#else\n            fmt::vformat_to(fmt::appender(buf), fmt, fmt::make_format_args(args...));\n#endif\n\n            details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));\n            log_it_(log_msg, log_enabled, traceback_enabled);\n        }\n        SPDLOG_LOGGER_CATCH(loc)\n    }\n\n#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\n    template <typename... Args>\n    void log_(source_loc loc, level::level_enum lvl, wstring_view_t fmt, Args &&...args) {\n        bool log_enabled = should_log(lvl);\n        bool traceback_enabled = tracer_.enabled();\n        if (!log_enabled && !traceback_enabled) {\n            return;\n        }\n        SPDLOG_TRY {\n            // format to wmemory_buffer and convert to utf8\n            wmemory_buf_t wbuf;\n            fmt_lib::vformat_to(std::back_inserter(wbuf), fmt,\n                                fmt_lib::make_format_args<fmt_lib::wformat_context>(args...));\n\n            memory_buf_t buf;\n            details::os::wstr_to_utf8buf(wstring_view_t(wbuf.data(), wbuf.size()), buf);\n            details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));\n            log_it_(log_msg, log_enabled, traceback_enabled);\n        }\n        SPDLOG_LOGGER_CATCH(loc)\n    }\n#endif  // SPDLOG_WCHAR_TO_UTF8_SUPPORT\n\n    // log the given message (if the given log level is high enough),\n    // and save backtrace (if backtrace is enabled).\n    void log_it_(const details::log_msg &log_msg, bool log_enabled, bool traceback_enabled);\n    virtual void sink_it_(const details::log_msg &msg);\n    virtual void flush_();\n    void dump_backtrace_();\n    bool should_flush_(const details::log_msg &msg);\n\n    // handle errors during logging.\n    // default handler prints the error to stderr at max rate of 1 message/sec.\n    void err_handler_(const std::string &msg);\n};\n\nvoid swap(logger &a, logger &b);\n\n}",
  "id": "BLOCK-CPP-00069",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/logger.h",
  "source_line": 48,
  "validation_status": "validated"
}