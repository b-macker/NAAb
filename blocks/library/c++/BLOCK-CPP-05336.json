{
  "code": "{\n  // A sentinel value for reserved_growth_ indicating that we just ran out of\n  // reserved growth on the last insertion. When reserve is called and then\n  // insertions take place, reserved_growth_'s state machine is N, ..., 1,\n  // kReservedGrowthJustRanOut, 0.\n  static constexpr size_t kReservedGrowthJustRanOut =\n      (std::numeric_limits<size_t>::max)();\n\n public:\n  CommonFieldsGenerationInfoEnabled() = default;\n  CommonFieldsGenerationInfoEnabled(CommonFieldsGenerationInfoEnabled&& that)\n      : reserved_growth_(that.reserved_growth_),\n        reservation_size_(that.reservation_size_),\n        generation_(that.generation_) {\n    that.reserved_growth_ = 0;\n    that.reservation_size_ = 0;\n    that.generation_ = EmptyGeneration();\n  }\n  CommonFieldsGenerationInfoEnabled& operator=(\n      CommonFieldsGenerationInfoEnabled&&) = default;\n\n  // Whether we should rehash on insert in order to detect bugs of using invalid\n  // references. We rehash on the first insertion after reserved_growth_ reaches\n  // 0 after a call to reserve. We also do a rehash with low probability\n  // whenever reserved_growth_ is zero.\n  bool should_rehash_for_bug_detection_on_insert(const ctrl_t* ctrl,\n                                                 size_t capacity) const;\n  // Similar to above, except that we don't depend on reserved_growth_.\n  bool should_rehash_for_bug_detection_on_move(const ctrl_t* ctrl,\n                                               size_t capacity) const;\n  void maybe_increment_generation_on_insert() {\n    if (reserved_growth_ == kReservedGrowthJustRanOut) reserved_growth_ = 0;\n\n    if (reserved_growth_ > 0) {\n      if (--reserved_growth_ == 0) reserved_growth_ = kReservedGrowthJustRanOut;\n    } else {\n      increment_generation();\n    }\n  }\n  void increment_generation() { *generation_ = NextGeneration(*generation_); }\n  void reset_reserved_growth(size_t reservation, size_t size) {\n    reserved_growth_ = reservation - size;\n  }\n  size_t reserved_growth() const { return reserved_growth_; }\n  void set_reserved_growth(size_t r) { reserved_growth_ = r; }\n  size_t reservation_size() const { return reservation_size_; }\n  void set_reservation_size(size_t r) { reservation_size_ = r; }\n  GenerationType generation() const { return *generation_; }\n  void set_generation(GenerationType g) { *generation_ = g; }\n  GenerationType* generation_ptr() const { return generation_; }\n  void set_generation_ptr(GenerationType* g) { generation_ = g; }\n\n private:\n  // The number of insertions remaining that are guaranteed to not rehash due to\n  // a prior call to reserve. Note: we store reserved growth in addition to\n  // reservation size because calls to erase() decrease size_ but don't decrease\n  // reserved growth.\n  size_t reserved_growth_ = 0;\n  // The maximum argument to reserve() since the container was cleared. We need\n  // to keep track of this, in addition to reserved growth, because we reset\n  // reserved growth to this when erase(begin(), end()) is called.\n  size_t reservation_size_ = 0;\n  // Pointer to the generation counter, which is used to validate iterators and\n  // is stored in the backing array between the control bytes and the slots.\n  // Note that we can't store the generation inside the container itself and\n  // keep a pointer to the container in the iterators because iterators must\n  // remain valid when the container is moved.\n  // Note: we could derive this pointer from the control pointer, but it makes\n  // the code more complicated, and there's a benefit in having the sizes of\n  // raw_hash_set in sanitizer mode and non-sanitizer mode a bit more different,\n  // which is that tests are less likely to rely on the size remaining the same.\n  GenerationType* generation_ = EmptyGeneration();\n}",
  "id": "BLOCK-CPP-05336",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 844,
  "validation_status": "validated"
}