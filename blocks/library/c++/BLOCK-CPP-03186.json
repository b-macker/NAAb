{
  "code": "#include \"absl/synchronization/internal/sem_waiter.h\"\n#include <semaphore.h>\n#include <atomic>\n#include <cassert>\n#include <cstdint>\n#include <cerrno>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/synchronization/internal/kernel_timeout.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03186_execute() {\n    {\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\nconstexpr char SemWaiter::kName[];\n#endif\n\nSemWaiter::SemWaiter() : wakeups_(0) {\n  if (sem_init(&sem_, 0, 0) != 0) {\n    ABSL_RAW_LOG(FATAL, \"sem_init failed with errno %d\\n\", errno);\n  }\n}\n\n#if defined(__GLIBC__) && \\\n    (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 30))\n#define ABSL_INTERNAL_HAVE_SEM_CLOCKWAIT 1\n#elif defined(__ANDROID_API__) && __ANDROID_API__ >= 30\n#define ABSL_INTERNAL_HAVE_SEM_CLOCKWAIT 1\n#endif\n\n// Calls sem_timedwait() or possibly something else like\n// sem_clockwait() depending on the platform and\n// KernelTimeout requested. The return value is the same as a call to the return\n// value to a call to sem_timedwait().\nint SemWaiter::TimedWait(KernelTimeout t) {\n  if (KernelTimeout::SupportsSteadyClock() && t.is_relative_timeout()) {\n#if defined(ABSL_INTERNAL_HAVE_SEM_CLOCKWAIT) && defined(CLOCK_MONOTONIC)\n    const auto abs_clock_timeout = t.MakeClockAbsoluteTimespec(CLOCK_MONOTONIC);\n    return sem_clockwait(&sem_, CLOCK_MONOTONIC, &abs_clock_timeout);\n#endif\n  }\n\n  const auto abs_timeout = t.MakeAbsTimespec();\n  return sem_timedwait(&sem_, &abs_timeout);\n}\n\nbool SemWaiter::Wait(KernelTimeout t) {\n  // Loop until we timeout or consume a wakeup.\n  // Note that, since the thread ticker is just reset, we don't need to check\n  // whether the thread is idle on the very first pass of the loop.\n  bool first_pass = true;\n  while (true) {\n    int x = wakeups_.load(std::memory_order_relaxed);\n    while (x != 0) {\n      if (!wakeups_.compare_exchange_weak(x, x - 1,\n                                          std::memory_order_acquire,\n                                          std::memory_order_relaxed)) {\n        continue;  // Raced with someone, retry.\n      }\n      // Successfully consumed a wakeup, we're done.\n      return true;\n    }\n\n    if (!first_pass) MaybeBecomeIdle();\n    // Nothing to consume, wait (looping on EINTR).\n    while (true) {\n      if (!t.has_timeout()) {\n        if (sem_wait(&sem_) == 0) break;\n        if (errno == EINTR) continue;\n        ABSL_RAW_LOG(FATAL, \"sem_wait failed: %d\", errno);\n      } else {\n        if (TimedWait(t) == 0) break;\n        if (errno == EINTR) continue;\n        if (errno == ETIMEDOUT) return false;\n        ABSL_RAW_LOG(FATAL, \"SemWaiter::TimedWait() failed: %d\", errno);\n      }\n    }\n    first_pass = false;\n  }\n}\n\nvoid SemWaiter::Post() {\n  // Post a wakeup.\n  if (wakeups_.fetch_add(1, std::memory_order_release) == 0) {\n    // We incremented from 0, need to wake a potential waiter.\n    Poke();\n  }\n}\n\nvoid SemWaiter::Poke() {\n  if (sem_post(&sem_) != 0) {  // Wake any semaphore waiter.\n    ABSL_RAW_LOG(FATAL, \"sem_post failed with errno %d\\n\", errno);\n  }\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03186",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/sem_waiter.cc",
  "source_line": 34,
  "validation_status": "validated"
}