{
  "code": "#include <cmath>         // std::signbit\n#include <cstdint>       // uint32_t\n#include <cstring>       // std::memcpy\n#include <limits>        // std::numeric_limits\n#include <memory>        // std::uninitialized_copy\n#include <stdexcept>     // std::runtime_error\n#include <system_error>  // std::system_error\n#include \"core.h\"\n\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail_exported;\nusing namespace detail_exported;\nusing namespace dragonbox;\nusing namespace dragonbox;\nusing namespace digits;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01378_execute() {\n    {\n  // float is passed as double to reduce the number of instantiations.\n  static_assert(!std::is_same<Float, float>::value, \"\");\n  FMT_ASSERT(value >= 0, \"value is negative\");\n  auto converted_value = convert_float(value);\n\n  const bool fixed = specs.format == float_format::fixed;\n  if (value <= 0) {  // <= instead of == to silence a warning.\n    if (precision <= 0 || !fixed) {\n      buf.push_back('0');\n      return 0;\n    }\n    buf.try_resize(to_unsigned(precision));\n    fill_n(buf.data(), precision, '0');\n    return -precision;\n  }\n\n  int exp = 0;\n  bool use_dragon = true;\n  unsigned dragon_flags = 0;\n  if (!is_fast_float<Float>()) {\n    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)\n    using info = dragonbox::float_info<decltype(converted_value)>;\n    const auto f = basic_fp<typename info::carrier_uint>(converted_value);\n    // Compute exp, an approximate power of 10, such that\n    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).\n    // This is based on log10(value) == log2(value) / log2(10) and approximation\n    // of log2(value) by e + num_fraction_bits idea from double-conversion.\n    exp = static_cast<int>(\n        std::ceil((f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10));\n    dragon_flags = dragon::fixup;\n  } else if (!is_constant_evaluated() && precision < 0) {\n    // Use Dragonbox for the shortest format.\n    if (specs.binary32) {\n      auto dec = dragonbox::to_decimal(static_cast<float>(value));\n      write<char>(buffer_appender<char>(buf), dec.significand);\n      return dec.exponent;\n    }\n    auto dec = dragonbox::to_decimal(static_cast<double>(value));\n    write<char>(buffer_appender<char>(buf), dec.significand);\n    return dec.exponent;\n  } else {\n    // Use Grisu + Dragon4 for the given precision:\n    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.\n    const int min_exp = -60;  // alpha in Grisu.\n    int cached_exp10 = 0;     // K in Grisu.\n    fp normalized = normalize(fp(converted_value));\n    const auto cached_pow = get_cached_power(\n        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);\n    normalized = normalized * cached_pow;\n    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};\n    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&\n        !is_constant_evaluated()) {\n      exp += handler.exp10;\n      buf.try_resize(to_unsigned(handler.size));\n      use_dragon = false;\n    } else {\n      exp += handler.size - cached_exp10 - 1;\n      precision = handler.precision;\n    }\n  }\n  if (use_dragon) {\n    auto f = basic_fp<uint128_t>();\n    bool is_predecessor_closer = specs.binary32\n                                     ? f.assign(static_cast<float>(value))\n                                     : f.assign(converted_value);\n    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;\n    if (fixed) dragon_flags |= dragon::fixed;\n    // Limit precision to the maximum possible number of significant digits in\n    // an IEEE754 double because we don't need to generate zeros.\n    const int max_double_digits = 767;\n    if (precision > max_double_digits) precision = max_double_digits;\n    format_dragon(f, dragon_flags, precision, buf, exp);\n  }\n  if (!fixed && !specs.showpoint) {\n    // Remove trailing zeros.\n    auto num_digits = buf.size();\n    while (num_digits > 0 && buf[num_digits - 1] == '0') {\n      --num_digits;\n      ++exp;\n    }\n    buf.try_resize(num_digits);\n  }\n  return exp;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01378",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 3098,
  "validation_status": "validated"
}