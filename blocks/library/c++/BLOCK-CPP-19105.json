{
  "code": "{\n    mutable llvm::PointerUnion<MacroDirective *, ModuleMacroInfo *> State;\n\n    ModuleMacroInfo *getModuleInfo(Preprocessor &PP,\n                                   const IdentifierInfo *II) const {\n      if (II->isOutOfDate())\n        PP.updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n      // FIXME: Find a spare bit on IdentifierInfo and store a\n      //        HasModuleMacros flag.\n      if (!II->hasMacroDefinition() ||\n          (!PP.getLangOpts().Modules &&\n           !PP.getLangOpts().ModulesLocalVisibility) ||\n          !PP.CurSubmoduleState->VisibleModules.getGeneration())\n        return nullptr;\n\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n\n      if (PP.CurSubmoduleState->VisibleModules.getGeneration() !=\n          Info->ActiveModuleMacrosGeneration)\n        PP.updateModuleMacroInfo(II, *Info);\n      return Info;\n    }\n\n  public:\n    MacroState() : MacroState(nullptr) {}\n    MacroState(MacroDirective *MD) : State(MD) {}\n\n    MacroState(MacroState &&O) noexcept : State(O.State) {\n      O.State = (MacroDirective *)nullptr;\n    }\n\n    MacroState &operator=(MacroState &&O) noexcept {\n      auto S = O.State;\n      O.State = (MacroDirective *)nullptr;\n      State = S;\n      return *this;\n    }\n\n    ~MacroState() {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->~ModuleMacroInfo();\n    }\n\n    MacroDirective *getLatest() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->MD;\n      return State.get<MacroDirective*>();\n    }\n\n    void setLatest(MacroDirective *MD) {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->MD = MD;\n      else\n        State = MD;\n    }\n\n    bool isAmbiguous(Preprocessor &PP, const IdentifierInfo *II) const {\n      auto *Info = getModuleInfo(PP, II);\n      return Info ? Info->IsAmbiguous : false;\n    }\n\n    ArrayRef<ModuleMacro *>\n    getActiveModuleMacros(Preprocessor &PP, const IdentifierInfo *II) const {\n      if (auto *Info = getModuleInfo(PP, II))\n        return Info->ActiveModuleMacros;\n      return std::nullopt;\n    }\n\n    MacroDirective::DefInfo findDirectiveAtLoc(SourceLocation Loc,\n                                               SourceManager &SourceMgr) const {\n      // FIXME: Incorporate module macros into the result of this.\n      if (auto *Latest = getLatest())\n        return Latest->findDirectiveAtLoc(Loc, SourceMgr);\n      return {};\n    }\n\n    void overrideActiveModuleMacros(Preprocessor &PP, IdentifierInfo *II) {\n      if (auto *Info = getModuleInfo(PP, II)) {\n        Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                      Info->ActiveModuleMacros.begin(),\n                                      Info->ActiveModuleMacros.end());\n        Info->ActiveModuleMacros.clear();\n        Info->IsAmbiguous = false;\n      }\n    }\n\n    ArrayRef<ModuleMacro*> getOverriddenMacros() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->OverriddenMacros;\n      return std::nullopt;\n    }\n\n    void setOverriddenMacros(Preprocessor &PP,\n                             ArrayRef<ModuleMacro *> Overrides) {\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        if (Overrides.empty())\n          return;\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n      Info->OverriddenMacros.clear();\n      Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                    Overrides.begin(), Overrides.end());\n      Info->ActiveModuleMacrosGeneration = 0;\n    }\n  }",
  "id": "BLOCK-CPP-19105",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/Preprocessor.h",
  "source_line": 825,
  "validation_status": "validated"
}