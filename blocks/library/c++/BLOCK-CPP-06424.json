{
  "code": "{\n  int next_arg = 0;\n  const char* p = src.data();\n  const char* const end = p + src.size();\n  while (p != end) {\n    const char* percent =\n        static_cast<const char*>(memchr(p, '%', static_cast<size_t>(end - p)));\n    if (!percent) {\n      // We found the last substring.\n      return consumer.Append(string_view(p, static_cast<size_t>(end - p)));\n    }\n    // We found a percent, so push the text run then process the percent.\n    if (ABSL_PREDICT_FALSE(!consumer.Append(\n            string_view(p, static_cast<size_t>(percent - p))))) {\n      return false;\n    }\n    if (ABSL_PREDICT_FALSE(percent + 1 >= end)) return false;\n\n    auto tag = GetTagForChar(percent[1]);\n    if (tag.is_conv()) {\n      if (ABSL_PREDICT_FALSE(next_arg < 0)) {\n        // This indicates an error in the format string.\n        // The only way to get `next_arg < 0` here is to have a positional\n        // argument first which sets next_arg to -1 and then a non-positional\n        // argument.\n        return false;\n      }\n      p = percent + 2;\n\n      // Keep this case separate from the one below.\n      // ConvertOne is more efficient when the compiler can see that the `basic`\n      // flag is set.\n      UnboundConversion conv;\n      conv.conv = tag.as_conv();\n      conv.arg_position = ++next_arg;\n      if (ABSL_PREDICT_FALSE(\n              !consumer.ConvertOne(conv, string_view(percent + 1, 1)))) {\n        return false;\n      }\n    } else if (percent[1] != '%') {\n      UnboundConversion conv;\n      p = ConsumeUnboundConversionNoInline(percent + 1, end, &conv, &next_arg);\n      if (ABSL_PREDICT_FALSE(p == nullptr)) return false;\n      if (ABSL_PREDICT_FALSE(!consumer.ConvertOne(\n              conv, string_view(percent + 1,\n                                static_cast<size_t>(p - (percent + 1)))))) {\n        return false;\n      }\n    } else {\n      if (ABSL_PREDICT_FALSE(!consumer.Append(\"%\"))) return false;\n      p = percent + 2;\n      continue;\n    }\n  }\n  return true;\n}",
  "id": "BLOCK-CPP-06424",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/parser.h",
  "source_line": 56,
  "validation_status": "validated"
}