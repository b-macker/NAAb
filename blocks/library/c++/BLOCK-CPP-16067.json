{
  "code": "{\nnamespace charinfo {\n  extern const uint16_t InfoTable[256];\n\n  enum {\n    CHAR_HORZ_WS  = 0x0001,  // '\\t', '\\f', '\\v'.  Note, no '\\0'\n    CHAR_VERT_WS  = 0x0002,  // '\\r', '\\n'\n    CHAR_SPACE    = 0x0004,  // ' '\n    CHAR_DIGIT    = 0x0008,  // 0-9\n    CHAR_XLETTER  = 0x0010,  // a-f,A-F\n    CHAR_UPPER    = 0x0020,  // A-Z\n    CHAR_LOWER    = 0x0040,  // a-z\n    CHAR_UNDER    = 0x0080,  // _\n    CHAR_PERIOD   = 0x0100,  // .\n    CHAR_RAWDEL   = 0x0200,  // {}[]#<>%:;?*+-/^&|~!=,\"'\n    CHAR_PUNCT    = 0x0400   // `$@()\n  };\n\n  enum {\n    CHAR_XUPPER = CHAR_XLETTER | CHAR_UPPER,\n    CHAR_XLOWER = CHAR_XLETTER | CHAR_LOWER\n  };\n} // end namespace charinfo\n\n/// Returns true if a byte is an ASCII character.\nLLVM_READNONE inline bool isASCII(char c) {\n  return static_cast<unsigned char>(c) <= 127;\n}\n\nLLVM_READNONE inline bool isASCII(unsigned char c) { return c <= 127; }\n\n/// Returns true if a codepoint is an ASCII character.\nLLVM_READNONE inline bool isASCII(uint32_t c) { return c <= 127; }\nLLVM_READNONE inline bool isASCII(int64_t c) { return 0 <= c && c <= 127; }\n\n/// Returns true if this is a valid first character of a C identifier,\n/// which is [a-zA-Z_].\nLLVM_READONLY inline bool isAsciiIdentifierStart(unsigned char c,\n                                                 bool AllowDollar = false) {\n  using namespace charinfo;\n  if (InfoTable[c] & (CHAR_UPPER|CHAR_LOWER|CHAR_UNDER))\n    return true;\n  return AllowDollar && c == '$';\n}\n\n/// Returns true if this is a body character of a C identifier,\n/// which is [a-zA-Z0-9_].\nLLVM_READONLY inline bool isAsciiIdentifierContinue(unsigned char c,\n                                                    bool AllowDollar = false) {\n  using namespace charinfo;\n  if (InfoTable[c] & (CHAR_UPPER|CHAR_LOWER|CHAR_DIGIT|CHAR_UNDER))\n    return true;\n  return AllowDollar && c == '$';\n}\n\n/// Returns true if this character is horizontal ASCII whitespace:\n/// ' ', '\\\\t', '\\\\f', '\\\\v'.\n///\n/// Note that this returns false for '\\\\0'.\nLLVM_READONLY inline bool isHorizontalWhitespace(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_HORZ_WS|CHAR_SPACE)) != 0;\n}\n\n/// Returns true if this character is vertical ASCII whitespace: '\\\\n', '\\\\r'.\n///\n/// Note that this returns false for '\\\\0'.\nLLVM_READONLY inline bool isVerticalWhitespace(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & CHAR_VERT_WS) != 0;\n}\n\n/// Return true if this character is horizontal or vertical ASCII whitespace:\n/// ' ', '\\\\t', '\\\\f', '\\\\v', '\\\\n', '\\\\r'.\n///\n/// Note that this returns false for '\\\\0'.\nLLVM_READONLY inline bool isWhitespace(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_HORZ_WS|CHAR_VERT_WS|CHAR_SPACE)) != 0;\n}\n\n/// Return true if this character is an ASCII digit: [0-9]\nLLVM_READONLY inline bool isDigit(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & CHAR_DIGIT) != 0;\n}\n\n/// Return true if this character is a lowercase ASCII letter: [a-z]\nLLVM_READONLY inline bool isLowercase(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & CHAR_LOWER) != 0;\n}\n\n/// Return true if this character is an uppercase ASCII letter: [A-Z]\nLLVM_READONLY inline bool isUppercase(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & CHAR_UPPER) != 0;\n}\n\n/// Return true if this character is an ASCII letter: [a-zA-Z]\nLLVM_READONLY inline bool isLetter(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_UPPER|CHAR_LOWER)) != 0;\n}\n\n/// Return true if this character is an ASCII letter or digit: [a-zA-Z0-9]\nLLVM_READONLY inline bool isAlphanumeric(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_DIGIT|CHAR_UPPER|CHAR_LOWER)) != 0;\n}\n\n/// Return true if this character is an ASCII hex digit: [0-9a-fA-F]\nLLVM_READONLY inline bool isHexDigit(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_DIGIT|CHAR_XLETTER)) != 0;\n}\n\n/// Return true if this character is an ASCII punctuation character.\n///\n/// Note that '_' is both a punctuation character and an identifier character!\nLLVM_READONLY inline bool isPunctuation(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_UNDER|CHAR_PERIOD|CHAR_RAWDEL|CHAR_PUNCT)) != 0;\n}\n\n/// Return true if this character is an ASCII printable character; that is, a\n/// character that should take exactly one column to print in a fixed-width\n/// terminal.\nLLVM_READONLY inline bool isPrintable(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_UPPER|CHAR_LOWER|CHAR_PERIOD|CHAR_PUNCT|\n                          CHAR_DIGIT|CHAR_UNDER|CHAR_RAWDEL|CHAR_SPACE)) != 0;\n}\n\n/// Return true if this is the body character of a C preprocessing number,\n/// which is [a-zA-Z0-9_.].\nLLVM_READONLY inline bool isPreprocessingNumberBody(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] &\n          (CHAR_UPPER|CHAR_LOWER|CHAR_DIGIT|CHAR_UNDER|CHAR_PERIOD)) != 0;\n}\n\n/// Return true if this is the body character of a C++ raw string delimiter.\nLLVM_READONLY inline bool isRawStringDelimBody(unsigned char c) {\n  using namespace charinfo;\n  return (InfoTable[c] & (CHAR_UPPER|CHAR_LOWER|CHAR_PERIOD|\n                          CHAR_DIGIT|CHAR_UNDER|CHAR_RAWDEL)) != 0;\n}\n\nenum class EscapeChar {\n  Single = 1,\n  Double = 2,\n  SingleAndDouble = static_cast<int>(Single) | static_cast<int>(Double),\n};\n\n/// Return C-style escaped string for special characters, or an empty string if\n/// there is no such mapping.\ntemplate <EscapeChar Opt, class CharT>\nLLVM_READONLY inline auto escapeCStyle(CharT Ch) -> StringRef {\n  switch (Ch) {\n  case '\\\\':\n    return \"\\\\\\\\\";\n  case '\\'':\n    if ((static_cast<int>(Opt) & static_cast<int>(EscapeChar::Single)) == 0)\n      break;\n    return \"\\\\'\";\n  case '\"':\n    if ((static_cast<int>(Opt) & static_cast<int>(EscapeChar::Double)) == 0)\n      break;\n    return \"\\\\\\\"\";\n  case '\\a':\n    return \"\\\\a\";\n  case '\\b':\n    return \"\\\\b\";\n  case '\\f':\n    return \"\\\\f\";\n  case '\\n':\n    return \"\\\\n\";\n  case '\\r':\n    return \"\\\\r\";\n  case '\\t':\n    return \"\\\\t\";\n  case '\\v':\n    return \"\\\\v\";\n  }\n  return {};\n}\n\n/// Converts the given ASCII character to its lowercase equivalent.\n///\n/// If the character is not an uppercase character, it is returned as is.\nLLVM_READONLY inline char toLowercase(char c) {\n  if (isUppercase(c))\n    return c + 'a' - 'A';\n  return c;\n}\n\n/// Converts the given ASCII character to its uppercase equivalent.\n///\n/// If the character is not a lowercase character, it is returned as is.\nLLVM_READONLY inline char toUppercase(char c) {\n  if (isLowercase(c))\n    return c + 'A' - 'a';\n  return c;\n}\n\n\n/// Return true if this is a valid ASCII identifier.\n///\n/// Note that this is a very simple check; it does not accept UCNs as valid\n/// identifier characters.\nLLVM_READONLY inline bool isValidAsciiIdentifier(StringRef S,\n                                                 bool AllowDollar = false) {\n  if (S.empty() || !isAsciiIdentifierStart(S[0], AllowDollar))\n    return false;\n\n  for (StringRef::iterator I = S.begin(), E = S.end(); I != E; ++I)\n    if (!isAsciiIdentifierContinue(*I, AllowDollar))\n      return false;\n\n  return true;\n}\n\n}",
  "id": "BLOCK-CPP-16067",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/CharInfo.h",
  "source_line": 17,
  "validation_status": "validated"
}