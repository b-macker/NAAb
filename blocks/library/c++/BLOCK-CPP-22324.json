{
  "code": "{\n\ntemplate <typename DECL>\nclass ASTDecl {\n  template <typename CHECKER>\n  static void _checkDecl(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTDecl(cast<DECL>(D), mgr, BR);\n  }\n\n  static bool _handlesDecl(const Decl *D) {\n    return isa<DECL>(D);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDecl(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkDecl<CHECKER>),\n                         _handlesDecl);\n  }\n};\n\nclass ASTCodeBody {\n  template <typename CHECKER>\n  static void _checkBody(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTCodeBody(D, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBody(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkBody<CHECKER>));\n  }\n};\n\nclass EndOfTranslationUnit {\n  template <typename CHECKER>\n  static void _checkEndOfTranslationUnit(void *checker,\n                                         const TranslationUnitDecl *TU,\n                                         AnalysisManager& mgr,\n                                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkEndOfTranslationUnit(TU, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr){\n    mgr._registerForEndOfTranslationUnit(\n                              CheckerManager::CheckEndOfTranslationUnit(checker,\n                                          _checkEndOfTranslationUnit<CHECKER>));\n  }\n};\n\ntemplate <typename STMT>\nclass PreStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreStmt(CheckerManager::CheckStmtFunc(checker,\n                                                          _checkStmt<CHECKER>),\n                            _handlesStmt);\n  }\n};\n\ntemplate <typename STMT>\nclass PostStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostStmt(CheckerManager::CheckStmtFunc(checker,\n                                                           _checkStmt<CHECKER>),\n                             _handlesStmt);\n  }\n};\n\nclass PreObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass ObjCMessageNil {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkObjCMessageNil(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForObjCMessageNil(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PostObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PreCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass PostCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass Location {\n  template <typename CHECKER>\n  static void _checkLocation(void *checker,\n                             const SVal &location, bool isLoad, const Stmt *S,\n                             CheckerContext &C) {\n    ((const CHECKER *)checker)->checkLocation(location, isLoad, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLocation(\n           CheckerManager::CheckLocationFunc(checker, _checkLocation<CHECKER>));\n  }\n};\n\nclass Bind {\n  template <typename CHECKER>\n  static void _checkBind(void *checker,\n                         const SVal &location, const SVal &val, const Stmt *S,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBind(location, val, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBind(\n           CheckerManager::CheckBindFunc(checker, _checkBind<CHECKER>));\n  }\n};\n\nclass EndAnalysis {\n  template <typename CHECKER>\n  static void _checkEndAnalysis(void *checker, ExplodedGraph &G,\n                                BugReporter &BR, ExprEngine &Eng) {\n    ((const CHECKER *)checker)->checkEndAnalysis(G, BR, Eng);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndAnalysis(\n     CheckerManager::CheckEndAnalysisFunc(checker, _checkEndAnalysis<CHECKER>));\n  }\n};\n\nclass BeginFunction {\n  template <typename CHECKER>\n  static void _checkBeginFunction(void *checker, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBeginFunction(C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBeginFunction(CheckerManager::CheckBeginFunctionFunc(\n        checker, _checkBeginFunction<CHECKER>));\n  }\n};\n\nclass EndFunction {\n  template <typename CHECKER>\n  static void _checkEndFunction(void *checker, const ReturnStmt *RS,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkEndFunction(RS, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndFunction(\n     CheckerManager::CheckEndFunctionFunc(checker, _checkEndFunction<CHECKER>));\n  }\n};\n\nclass BranchCondition {\n  template <typename CHECKER>\n  static void _checkBranchCondition(void *checker, const Stmt *Condition,\n                                    CheckerContext & C) {\n    ((const CHECKER *)checker)->checkBranchCondition(Condition, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBranchCondition(\n      CheckerManager::CheckBranchConditionFunc(checker,\n                                               _checkBranchCondition<CHECKER>));\n  }\n};\n\nclass NewAllocator {\n  template <typename CHECKER>\n  static void _checkNewAllocator(void *checker, const CXXAllocatorCall &Call,\n                                 CheckerContext &C) {\n    ((const CHECKER *)checker)->checkNewAllocator(Call, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForNewAllocator(\n        CheckerManager::CheckNewAllocatorFunc(checker,\n                                              _checkNewAllocator<CHECKER>));\n  }\n};\n\nclass LiveSymbols {\n  template <typename CHECKER>\n  static void _checkLiveSymbols(void *checker, ProgramStateRef state,\n                                SymbolReaper &SR) {\n    ((const CHECKER *)checker)->checkLiveSymbols(state, SR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLiveSymbols(\n     CheckerManager::CheckLiveSymbolsFunc(checker, _checkLiveSymbols<CHECKER>));\n  }\n};\n\nclass DeadSymbols {\n  template <typename CHECKER>\n  static void _checkDeadSymbols(void *checker,\n                                SymbolReaper &SR, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkDeadSymbols(SR, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDeadSymbols(\n     CheckerManager::CheckDeadSymbolsFunc(checker, _checkDeadSymbols<CHECKER>));\n  }\n};\n\nclass RegionChanges {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkRegionChanges(void *checker,\n                      ProgramStateRef state,\n                      const InvalidatedSymbols *invalidated,\n                      ArrayRef<const MemRegion *> Explicits,\n                      ArrayRef<const MemRegion *> Regions,\n                      const LocationContext *LCtx,\n                      const CallEvent *Call) {\n    return ((const CHECKER *) checker)->checkRegionChanges(state, invalidated,\n                                                           Explicits, Regions,\n                                                           LCtx, Call);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForRegionChanges(\n          CheckerManager::CheckRegionChangesFunc(checker,\n                                                 _checkRegionChanges<CHECKER>));\n  }\n};\n\nclass PointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkPointerEscape(void *Checker,\n                     ProgramStateRef State,\n                     const InvalidatedSymbols &Escaped,\n                     const CallEvent *Call,\n                     PointerEscapeKind Kind,\n                     RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                            Escaped,\n                                                            Call,\n                                                            Kind);\n\n    InvalidatedSymbols RegularEscape;\n    for (SymbolRef Sym : Escaped)\n      if (!ETraits->hasTrait(\n              Sym, RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(\n              Sym, RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        RegularEscape.insert(Sym);\n\n    if (RegularEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                          RegularEscape,\n                                                          Call,\n                                                          Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n          CheckerManager::CheckPointerEscapeFunc(checker,\n                                                _checkPointerEscape<CHECKER>));\n  }\n};\n\nclass ConstPointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkConstPointerEscape(void *Checker,\n                      ProgramStateRef State,\n                      const InvalidatedSymbols &Escaped,\n                      const CallEvent *Call,\n                      PointerEscapeKind Kind,\n                      RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return State;\n\n    InvalidatedSymbols ConstEscape;\n    for (SymbolRef Sym : Escaped) {\n      if (ETraits->hasTrait(\n              Sym, RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(\n              Sym, RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        ConstEscape.insert(Sym);\n    }\n\n    if (ConstEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkConstPointerEscape(State,\n                                                               ConstEscape,\n                                                               Call,\n                                                               Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n      CheckerManager::CheckPointerEscapeFunc(checker,\n                                            _checkConstPointerEscape<CHECKER>));\n  }\n};\n\n\ntemplate <typename EVENT>\nclass Event {\n  template <typename CHECKER>\n  static void _checkEvent(void *checker, const void *event) {\n    ((const CHECKER *)checker)->checkEvent(*(const EVENT *)event);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerListenerForEvent<EVENT>(\n                 CheckerManager::CheckEventFunc(checker, _checkEvent<CHECKER>));\n  }\n};\n\n}",
  "id": "BLOCK-CPP-22324",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/Checker.h",
  "source_line": 26,
  "validation_status": "validated"
}