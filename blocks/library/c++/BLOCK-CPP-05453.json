{
  "code": "#include <climits>\n#include \"absl/base/config.h\"\n#include <link.h>  // for ElfW\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05453_execute() {\n    {\n private:\n  // Sentinel: there could never be an elf image at &kInvalidBaseSentinel.\n  static const int kInvalidBaseSentinel;\n\n public:\n  // Sentinel: there could never be an elf image at this address.\n  static constexpr const void *const kInvalidBase =\n    static_cast<const void*>(&kInvalidBaseSentinel);\n\n  // Information about a single vdso symbol.\n  // All pointers are into .dynsym, .dynstr, or .text of the VDSO.\n  // Do not free() them or modify through them.\n  struct SymbolInfo {\n    const char      *name;      // E.g. \"__vdso_getcpu\"\n    const char      *version;   // E.g. \"LINUX_2.6\", could be \"\"\n                                // for unversioned symbol.\n    const void      *address;   // Relocated symbol address.\n    const ElfW(Sym) *symbol;    // Symbol in the dynamic symbol table.\n  };\n\n  // Supports iteration over all dynamic symbols.\n  class SymbolIterator {\n   public:\n    friend class ElfMemImage;\n    const SymbolInfo *operator->() const;\n    const SymbolInfo &operator*() const;\n    SymbolIterator& operator++();\n    bool operator!=(const SymbolIterator &rhs) const;\n    bool operator==(const SymbolIterator &rhs) const;\n   private:\n    SymbolIterator(const void *const image, int index);\n    void Update(int incr);\n    SymbolInfo info_;\n    int index_;\n    const void *const image_;\n  };\n\n\n  explicit ElfMemImage(const void *base);\n  void                 Init(const void *base);\n  bool                 IsPresent() const { return ehdr_ != nullptr; }\n  const ElfW(Phdr)*    GetPhdr(int index) const;\n  const ElfW(Sym)*     GetDynsym(int index) const;\n  const ElfW(Versym)*  GetVersym(int index) const;\n  const ElfW(Verdef)*  GetVerdef(int index) const;\n  const ElfW(Verdaux)* GetVerdefAux(const ElfW(Verdef) *verdef) const;\n  const char*          GetDynstr(ElfW(Word) offset) const;\n  const void*          GetSymAddr(const ElfW(Sym) *sym) const;\n  const char*          GetVerstr(ElfW(Word) offset) const;\n  int                  GetNumSymbols() const;\n\n  SymbolIterator begin() const;\n  SymbolIterator end() const;\n\n  // Look up versioned dynamic symbol in the image.\n  // Returns false if image is not present, or doesn't contain given\n  // symbol/version/type combination.\n  // If info_out is non-null, additional details are filled in.\n  bool LookupSymbol(const char *name, const char *version,\n                    int symbol_type, SymbolInfo *info_out) const;\n\n  // Find info about symbol (if any) which overlaps given address.\n  // Returns true if symbol was found; false if image isn't present\n  // or doesn't have a symbol overlapping given address.\n  // If info_out is non-null, additional details are filled in.\n  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;\n\n private:\n  const ElfW(Ehdr) *ehdr_;\n  const ElfW(Sym) *dynsym_;\n  const ElfW(Versym) *versym_;\n  const ElfW(Verdef) *verdef_;\n  const ElfW(Word) *hash_;\n  const char *dynstr_;\n  size_t strsize_;\n  size_t verdefnum_;\n  ElfW(Addr) link_base_;     // Link-time base (p_vaddr of first PT_LOAD).\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05453",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/elf_mem_image.h",
  "source_line": 54,
  "validation_status": "validated"
}