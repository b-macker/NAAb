{
  "code": "#include \"absl/debugging/internal/examine_stack.h\"\n#include <unistd.h>\n#include \"absl/base/config.h\"\n#include <sys/mman.h>\n#include <sys/ucontext.h>\n#include <csignal>\n#include <cstdio>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/debugging/stacktrace.h\"\n#include \"absl/debugging/symbolize.h\"\n\nusing namespace absl;\nusing namespace debugging_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02595_execute() {\n    {\n  char tmp[1024];\n  const char* symbol = \"(unknown)\";\n  // Symbolizes the previous address of pc because pc may be in the\n  // next function.  The overrun happens when the function ends with\n  // a call to a function annotated noreturn (e.g. CHECK).\n  // If symbolization of pc-1 fails, also try pc on the off-chance\n  // that we crashed on the first instruction of a function (that\n  // actually happens very often for e.g. __restore_rt).\n  const uintptr_t prev_pc = reinterpret_cast<uintptr_t>(pc) - 1;\n  if (absl::Symbolize(reinterpret_cast<const char*>(prev_pc), tmp,\n                      sizeof(tmp)) ||\n      absl::Symbolize(pc, tmp, sizeof(tmp))) {\n    symbol = tmp;\n  }\n  char buf[1024];\n  snprintf(buf, sizeof(buf), \"%s@ %*p  %s\\n\", prefix, kPrintfPointerFieldWidth,\n           pc, symbol);\n  writer(buf, writer_arg);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02595",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/internal/examine_stack.cc",
  "source_line": 101,
  "validation_status": "validated"
}