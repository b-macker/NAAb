{
  "code": "{\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  struct FlagTy {\n    /// Used for 'atomic update' or 'atomic capture' constructs. They may\n    /// have atomic expressions of forms:\n    /// \\code\n    /// x = x binop expr;\n    /// x = expr binop x;\n    /// \\endcode\n    /// This field is 1 for the first form of the expression and 0 for the\n    /// second. Required for correct codegen of non-associative operations (like\n    /// << or >>).\n    uint8_t IsXLHSInRHSPart : 1;\n    /// Used for 'atomic update' or 'atomic capture' constructs. They may\n    /// have atomic expressions of forms:\n    /// \\code\n    /// v = x; <update x>;\n    /// <update x>; v = x;\n    /// \\endcode\n    /// This field is 1 for the first(postfix) form of the expression and 0\n    /// otherwise.\n    uint8_t IsPostfixUpdate : 1;\n    /// 1 if 'v' is updated only when the condition is false (compare capture\n    /// only).\n    uint8_t IsFailOnly : 1;\n  } Flags;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPAtomicDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPAtomicDirective()\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               SourceLocation(), SourceLocation()) {}\n\n  enum DataPositionTy : size_t {\n    POS_X = 0,\n    POS_V,\n    POS_E,\n    POS_UpdateExpr,\n    POS_D,\n    POS_Cond,\n    POS_R,\n  };\n\n  /// Set 'x' part of the associated expression/statement.\n  void setX(Expr *X) { Data->getChildren()[DataPositionTy::POS_X] = X; }\n  /// Set helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  void setUpdateExpr(Expr *UE) {\n    Data->getChildren()[DataPositionTy::POS_UpdateExpr] = UE;\n  }\n  /// Set 'v' part of the associated expression/statement.\n  void setV(Expr *V) { Data->getChildren()[DataPositionTy::POS_V] = V; }\n  /// Set 'r' part of the associated expression/statement.\n  void setR(Expr *R) { Data->getChildren()[DataPositionTy::POS_R] = R; }\n  /// Set 'expr' part of the associated expression/statement.\n  void setExpr(Expr *E) { Data->getChildren()[DataPositionTy::POS_E] = E; }\n  /// Set 'd' part of the associated expression/statement.\n  void setD(Expr *D) { Data->getChildren()[DataPositionTy::POS_D] = D; }\n  /// Set conditional expression in `atomic compare`.\n  void setCond(Expr *C) { Data->getChildren()[DataPositionTy::POS_Cond] = C; }\n\npublic:\n  struct Expressions {\n    /// 'x' part of the associated expression/statement.\n    Expr *X = nullptr;\n    /// 'v' part of the associated expression/statement.\n    Expr *V = nullptr;\n    // 'r' part of the associated expression/statement.\n    Expr *R = nullptr;\n    /// 'expr' part of the associated expression/statement.\n    Expr *E = nullptr;\n    /// UE Helper expression of the form:\n    /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n    /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n    Expr *UE = nullptr;\n    /// 'd' part of the associated expression/statement.\n    Expr *D = nullptr;\n    /// Conditional expression in `atomic compare` construct.\n    Expr *Cond = nullptr;\n    /// True if UE has the first form and false if the second.\n    bool IsXLHSInRHSPart;\n    /// True if original value of 'x' must be stored in 'v', not an updated one.\n    bool IsPostfixUpdate;\n    /// True if 'v' is updated only when the condition is false (compare capture\n    /// only).\n    bool IsFailOnly;\n  };\n\n  /// Creates directive with a list of \\a Clauses and 'x', 'v' and 'expr'\n  /// parts of the atomic construct (see Section 2.12.6, atomic Construct, for\n  /// detailed description of 'x', 'v' and 'expr').\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Associated expressions or statements.\n  static OMPAtomicDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    ArrayRef<OMPClause *> Clauses,\n                                    Stmt *AssociatedStmt, Expressions Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPAtomicDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get 'x' part of the associated expression/statement.\n  Expr *getX() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_X]);\n  }\n  const Expr *getX() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_X]);\n  }\n  /// Get helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *getUpdateExpr() {\n    return cast_or_null<Expr>(\n        Data->getChildren()[DataPositionTy::POS_UpdateExpr]);\n  }\n  const Expr *getUpdateExpr() const {\n    return cast_or_null<Expr>(\n        Data->getChildren()[DataPositionTy::POS_UpdateExpr]);\n  }\n  /// Return true if helper update expression has form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' and false if it has form\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  bool isXLHSInRHSPart() const { return Flags.IsXLHSInRHSPart; }\n  /// Return true if 'v' expression must be updated to original value of\n  /// 'x', false if 'v' must be updated to the new value of 'x'.\n  bool isPostfixUpdate() const { return Flags.IsPostfixUpdate; }\n  /// Return true if 'v' is updated only when the condition is evaluated false\n  /// (compare capture only).\n  bool isFailOnly() const { return Flags.IsFailOnly; }\n  /// Get 'v' part of the associated expression/statement.\n  Expr *getV() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_V]);\n  }\n  const Expr *getV() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_V]);\n  }\n  /// Get 'r' part of the associated expression/statement.\n  Expr *getR() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_R]);\n  }\n  const Expr *getR() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_R]);\n  }\n  /// Get 'expr' part of the associated expression/statement.\n  Expr *getExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_E]);\n  }\n  const Expr *getExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_E]);\n  }\n  /// Get 'd' part of the associated expression/statement.\n  Expr *getD() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_D]);\n  }\n  Expr *getD() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_D]);\n  }\n  /// Get the 'cond' part of the source atomic expression.\n  Expr *getCondExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_Cond]);\n  }\n  Expr *getCondExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[DataPositionTy::POS_Cond]);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPAtomicDirectiveClass;\n  }\n}",
  "id": "BLOCK-CPP-13383",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/StmtOpenMP.h",
  "source_line": 2895,
  "validation_status": "validated"
}