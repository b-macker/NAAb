{
  "code": "#include <cstdint>\n#include <limits>\n#include <ostream>\n#include <type_traits>\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace cctz;\nusing namespace detail;\nusing namespace impl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06592_execute() {\n    {\n\nCONSTEXPR_F bool is_leap_year(year_t y) noexcept {\n  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\n}\nCONSTEXPR_F int year_index(year_t y, month_t m) noexcept {\n  const int yi = static_cast<int>((y + (m > 2)) % 400);\n  return yi < 0 ? yi + 400 : yi;\n}\nCONSTEXPR_F int days_per_century(int yi) noexcept {\n  return 36524 + (yi == 0 || yi > 300);\n}\nCONSTEXPR_F int days_per_4years(int yi) noexcept {\n  return 1460 + (yi == 0 || yi > 300 || (yi - 1) % 100 < 96);\n}\nCONSTEXPR_F int days_per_year(year_t y, month_t m) noexcept {\n  return is_leap_year(y + (m > 2)) ? 366 : 365;\n}\nCONSTEXPR_F int days_per_month(year_t y, month_t m) noexcept {\n  CONSTEXPR_D int k_days_per_month[1 + 12] = {\n      -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // non leap year\n  };\n  return k_days_per_month[m] + (m == 2 && is_leap_year(y));\n}\n\nCONSTEXPR_F fields n_day(year_t y, month_t m, diff_t d, diff_t cd, hour_t hh,\n                         minute_t mm, second_t ss) noexcept {\n  year_t ey = y % 400;\n  const year_t oey = ey;\n  ey += (cd / 146097) * 400;\n  cd %= 146097;\n  if (cd < 0) {\n    ey -= 400;\n    cd += 146097;\n  }\n  ey += (d / 146097) * 400;\n  d = d % 146097 + cd;\n  if (d > 0) {\n    if (d > 146097) {\n      ey += 400;\n      d -= 146097;\n    }\n  } else {\n    if (d > -365) {\n      // We often hit the previous year when stepping a civil time backwards,\n      // so special case it to avoid counting up by 100/4/1-year chunks.\n      ey -= 1;\n      d += days_per_year(ey, m);\n    } else {\n      ey -= 400;\n      d += 146097;\n    }\n  }\n  if (d > 365) {\n    int yi = year_index(ey, m);  // Index into Gregorian 400 year cycle.\n    for (;;) {\n      int n = days_per_century(yi);\n      if (d <= n) break;\n      d -= n;\n      ey += 100;\n      yi += 100;\n      if (yi >= 400) yi -= 400;\n    }\n    for (;;) {\n      int n = days_per_4years(yi);\n      if (d <= n) break;\n      d -= n;\n      ey += 4;\n      yi += 4;\n      if (yi >= 400) yi -= 400;\n    }\n    for (;;) {\n      int n = days_per_year(ey, m);\n      if (d <= n) break;\n      d -= n;\n      ++ey;\n    }\n  }\n  if (d > 28) {\n    for (;;) {\n      int n = days_per_month(ey, m);\n      if (d <= n) break;\n      d -= n;\n      if (++m > 12) {\n        ++ey;\n        m = 1;\n      }\n    }\n  }\n  return fields(y + (ey - oey), m, static_cast<day_t>(d), hh, mm, ss);\n}\nCONSTEXPR_F fields n_mon(year_t y, diff_t m, diff_t d, diff_t cd, hour_t hh,\n                         minute_t mm, second_t ss) noexcept {\n  if (m != 12) {\n    y += m / 12;\n    m %= 12;\n    if (m <= 0) {\n      y -= 1;\n      m += 12;\n    }\n  }\n  return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);\n}\nCONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd, diff_t hh,\n                          minute_t mm, second_t ss) noexcept {\n  cd += hh / 24;\n  hh %= 24;\n  if (hh < 0) {\n    cd -= 1;\n    hh += 24;\n  }\n  return n_mon(y, m, d, cd, static_cast<hour_t>(hh), mm, ss);\n}\nCONSTEXPR_F fields n_min(year_t y, diff_t m, diff_t d, diff_t hh, diff_t ch,\n                         diff_t mm, second_t ss) noexcept {\n  ch += mm / 60;\n  mm %= 60;\n  if (mm < 0) {\n    ch -= 1;\n    mm += 60;\n  }\n  return n_hour(y, m, d, hh / 24 + ch / 24, hh % 24 + ch % 24,\n                static_cast<minute_t>(mm), ss);\n}\nCONSTEXPR_F fields n_sec(year_t y, diff_t m, diff_t d, diff_t hh, diff_t mm,\n                         diff_t ss) noexcept {\n  // Optimization for when (non-constexpr) fields are already normalized.\n  if (0 <= ss && ss < 60) {\n    const second_t nss = static_cast<second_t>(ss);\n    if (0 <= mm && mm < 60) {\n      const minute_t nmm = static_cast<minute_t>(mm);\n      if (0 <= hh && hh < 24) {\n        const hour_t nhh = static_cast<hour_t>(hh);\n        if (1 <= d && d <= 28 && 1 <= m && m <= 12) {\n          const day_t nd = static_cast<day_t>(d);\n          const month_t nm = static_cast<month_t>(m);\n          return fields(y, nm, nd, nhh, nmm, nss);\n        }\n        return n_mon(y, m, d, 0, nhh, nmm, nss);\n      }\n      return n_hour(y, m, d, hh / 24, hh % 24, nmm, nss);\n    }\n    return n_min(y, m, d, hh, mm / 60, mm % 60, nss);\n  }\n  diff_t cm = ss / 60;\n  ss %= 60;\n  if (ss < 0) {\n    cm -= 1;\n    ss += 60;\n  }\n  return n_min(y, m, d, hh, mm / 60 + cm / 60, mm % 60 + cm % 60,\n               static_cast<second_t>(ss));\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06592",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/civil_time_detail.h",
  "source_line": 81,
  "validation_status": "validated"
}