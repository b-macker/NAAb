{
  "code": "{\n  public:\n    /// A set of declarations.\n    using DeclArgumentPack = SmallVector<VarDecl *, 4>;\n\n  private:\n    /// Reference to the semantic analysis that is performing\n    /// this template instantiation.\n    Sema &SemaRef;\n\n    using LocalDeclsMap =\n        llvm::SmallDenseMap<const Decl *,\n                            llvm::PointerUnion<Decl *, DeclArgumentPack *>, 4>;\n\n    /// A mapping from local declarations that occur\n    /// within a template to their instantiations.\n    ///\n    /// This mapping is used during instantiation to keep track of,\n    /// e.g., function parameter and variable declarations. For example,\n    /// given:\n    ///\n    /// \\code\n    ///   template<typename T> T add(T x, T y) { return x + y; }\n    /// \\endcode\n    ///\n    /// when we instantiate add<int>, we will introduce a mapping from\n    /// the ParmVarDecl for 'x' that occurs in the template to the\n    /// instantiated ParmVarDecl for 'x'.\n    ///\n    /// For a parameter pack, the local instantiation scope may contain a\n    /// set of instantiated parameters. This is stored as a DeclArgumentPack\n    /// pointer.\n    LocalDeclsMap LocalDecls;\n\n    /// The set of argument packs we've allocated.\n    SmallVector<DeclArgumentPack *, 1> ArgumentPacks;\n\n    /// The outer scope, which contains local variable\n    /// definitions from some other instantiation (that may not be\n    /// relevant to this particular scope).\n    LocalInstantiationScope *Outer;\n\n    /// Whether we have already exited this scope.\n    bool Exited = false;\n\n    /// Whether to combine this scope with the outer scope, such that\n    /// lookup will search our outer scope.\n    bool CombineWithOuterScope;\n\n    /// If non-NULL, the template parameter pack that has been\n    /// partially substituted per C++0x [temp.arg.explicit]p9.\n    NamedDecl *PartiallySubstitutedPack = nullptr;\n\n    /// If \\c PartiallySubstitutedPack is non-null, the set of\n    /// explicitly-specified template arguments in that pack.\n    const TemplateArgument *ArgsInPartiallySubstitutedPack;\n\n    /// If \\c PartiallySubstitutedPack, the number of\n    /// explicitly-specified template arguments in\n    /// ArgsInPartiallySubstitutedPack.\n    unsigned NumArgsInPartiallySubstitutedPack;\n\n  public:\n    LocalInstantiationScope(Sema &SemaRef, bool CombineWithOuterScope = false)\n        : SemaRef(SemaRef), Outer(SemaRef.CurrentInstantiationScope),\n          CombineWithOuterScope(CombineWithOuterScope) {\n      SemaRef.CurrentInstantiationScope = this;\n    }\n\n    LocalInstantiationScope(const LocalInstantiationScope &) = delete;\n    LocalInstantiationScope &\n    operator=(const LocalInstantiationScope &) = delete;\n\n    ~LocalInstantiationScope() {\n      Exit();\n    }\n\n    const Sema &getSema() const { return SemaRef; }\n\n    /// Exit this local instantiation scope early.\n    void Exit() {\n      if (Exited)\n        return;\n\n      for (unsigned I = 0, N = ArgumentPacks.size(); I != N; ++I)\n        delete ArgumentPacks[I];\n\n      SemaRef.CurrentInstantiationScope = Outer;\n      Exited = true;\n    }\n\n    /// Clone this scope, and all outer scopes, down to the given\n    /// outermost scope.\n    LocalInstantiationScope *cloneScopes(LocalInstantiationScope *Outermost) {\n      if (this == Outermost) return this;\n\n      // Save the current scope from SemaRef since the LocalInstantiationScope\n      // will overwrite it on construction\n      LocalInstantiationScope *oldScope = SemaRef.CurrentInstantiationScope;\n\n      LocalInstantiationScope *newScope =\n        new LocalInstantiationScope(SemaRef, CombineWithOuterScope);\n\n      newScope->Outer = nullptr;\n      if (Outer)\n        newScope->Outer = Outer->cloneScopes(Outermost);\n\n      newScope->PartiallySubstitutedPack = PartiallySubstitutedPack;\n      newScope->ArgsInPartiallySubstitutedPack = ArgsInPartiallySubstitutedPack;\n      newScope->NumArgsInPartiallySubstitutedPack =\n        NumArgsInPartiallySubstitutedPack;\n\n      for (LocalDeclsMap::iterator I = LocalDecls.begin(), E = LocalDecls.end();\n           I != E; ++I) {\n        const Decl *D = I->first;\n        llvm::PointerUnion<Decl *, DeclArgumentPack *> &Stored =\n          newScope->LocalDecls[D];\n        if (I->second.is<Decl *>()) {\n          Stored = I->second.get<Decl *>();\n        } else {\n          DeclArgumentPack *OldPack = I->second.get<DeclArgumentPack *>();\n          DeclArgumentPack *NewPack = new DeclArgumentPack(*OldPack);\n          Stored = NewPack;\n          newScope->ArgumentPacks.push_back(NewPack);\n        }\n      }\n      // Restore the saved scope to SemaRef\n      SemaRef.CurrentInstantiationScope = oldScope;\n      return newScope;\n    }\n\n    /// deletes the given scope, and all outer scopes, down to the\n    /// given outermost scope.\n    static void deleteScopes(LocalInstantiationScope *Scope,\n                             LocalInstantiationScope *Outermost) {\n      while (Scope && Scope != Outermost) {\n        LocalInstantiationScope *Out = Scope->Outer;\n        delete Scope;\n        Scope = Out;\n      }\n    }\n\n    /// Find the instantiation of the declaration D within the current\n    /// instantiation scope.\n    ///\n    /// \\param D The declaration whose instantiation we are searching for.\n    ///\n    /// \\returns A pointer to the declaration or argument pack of declarations\n    /// to which the declaration \\c D is instantiated, if found. Otherwise,\n    /// returns NULL.\n    llvm::PointerUnion<Decl *, DeclArgumentPack *> *\n    findInstantiationOf(const Decl *D);\n\n    void InstantiatedLocal(const Decl *D, Decl *Inst);\n    void InstantiatedLocalPackArg(const Decl *D, VarDecl *Inst);\n    void MakeInstantiatedLocalArgPack(const Decl *D);\n\n    /// Note that the given parameter pack has been partially substituted\n    /// via explicit specification of template arguments\n    /// (C++0x [temp.arg.explicit]p9).\n    ///\n    /// \\param Pack The parameter pack, which will always be a template\n    /// parameter pack.\n    ///\n    /// \\param ExplicitArgs The explicitly-specified template arguments provided\n    /// for this parameter pack.\n    ///\n    /// \\param NumExplicitArgs The number of explicitly-specified template\n    /// arguments provided for this parameter pack.\n    void SetPartiallySubstitutedPack(NamedDecl *Pack,\n                                     const TemplateArgument *ExplicitArgs,\n                                     unsigned NumExplicitArgs);\n\n    /// Reset the partially-substituted pack when it is no longer of\n    /// interest.\n    void ResetPartiallySubstitutedPack() {\n      assert(PartiallySubstitutedPack && \"No partially-substituted pack\");\n      PartiallySubstitutedPack = nullptr;\n      ArgsInPartiallySubstitutedPack = nullptr;\n      NumArgsInPartiallySubstitutedPack = 0;\n    }\n\n    /// Retrieve the partially-substitued template parameter pack.\n    ///\n    /// If there is no partially-substituted parameter pack, returns NULL.\n    NamedDecl *\n    getPartiallySubstitutedPack(const TemplateArgument **ExplicitArgs = nullptr,\n                                unsigned *NumExplicitArgs = nullptr) const;\n\n    /// Determine whether D is a pack expansion created in this scope.\n    bool isLocalPackExpansion(const Decl *D);\n  }",
  "id": "BLOCK-CPP-20696",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Template.h",
  "source_line": 363,
  "validation_status": "validated"
}