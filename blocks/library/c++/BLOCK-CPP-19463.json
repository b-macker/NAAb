{
  "code": "#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <optional>\n#include <string>\n#include <utility>\n    /// Code completion inside the filename part of a #include directive.\n\nusing namespace clang;\nusing namespace or;\nusing namespace or;\nusing namespace clang;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-19463_execute() {\n    {\npublic:\n  /// Describes the kind of result generated.\n  enum ResultKind {\n    /// Refers to a declaration.\n    RK_Declaration = 0,\n\n    /// Refers to a keyword or symbol.\n    RK_Keyword,\n\n    /// Refers to a macro.\n    RK_Macro,\n\n    /// Refers to a precomputed pattern.\n    RK_Pattern\n  };\n\n  /// When Kind == RK_Declaration or RK_Pattern, the declaration we are\n  /// referring to. In the latter case, the declaration might be NULL.\n  const NamedDecl *Declaration = nullptr;\n\n  union {\n    /// When Kind == RK_Keyword, the string representing the keyword\n    /// or symbol's spelling.\n    const char *Keyword;\n\n    /// When Kind == RK_Pattern, the code-completion string that\n    /// describes the completion text to insert.\n    CodeCompletionString *Pattern;\n\n    /// When Kind == RK_Macro, the identifier that refers to a macro.\n    const IdentifierInfo *Macro;\n  };\n\n  /// The priority of this particular code-completion result.\n  unsigned Priority;\n\n  /// Specifies which parameter (of a function, Objective-C method,\n  /// macro, etc.) we should start with when formatting the result.\n  unsigned StartParameter = 0;\n\n  /// The kind of result stored here.\n  ResultKind Kind;\n\n  /// The cursor kind that describes this result.\n  CXCursorKind CursorKind;\n\n  /// The availability of this result.\n  CXAvailabilityKind Availability = CXAvailability_Available;\n\n  /// Fix-its that *must* be applied before inserting the text for the\n  /// corresponding completion.\n  ///\n  /// By default, CodeCompletionBuilder only returns completions with empty\n  /// fix-its. Extra completions with non-empty fix-its should be explicitly\n  /// requested by setting CompletionOptions::IncludeFixIts.\n  ///\n  /// For the clients to be able to compute position of the cursor after\n  /// applying fix-its, the following conditions are guaranteed to hold for\n  /// RemoveRange of the stored fix-its:\n  ///  - Ranges in the fix-its are guaranteed to never contain the completion\n  ///  point (or identifier under completion point, if any) inside them, except\n  ///  at the start or at the end of the range.\n  ///  - If a fix-it range starts or ends with completion point (or starts or\n  ///  ends after the identifier under completion point), it will contain at\n  ///  least one character. It allows to unambiguously recompute completion\n  ///  point after applying the fix-it.\n  ///\n  /// The intuition is that provided fix-its change code around the identifier\n  /// we complete, but are not allowed to touch the identifier itself or the\n  /// completion point. One example of completions with corrections are the ones\n  /// replacing '.' with '->' and vice versa:\n  ///\n  /// std::unique_ptr<std::vector<int>> vec_ptr;\n  /// In 'vec_ptr.^', one of the completions is 'push_back', it requires\n  /// replacing '.' with '->'.\n  /// In 'vec_ptr->^', one of the completions is 'release', it requires\n  /// replacing '->' with '.'.\n  std::vector<FixItHint> FixIts;\n\n  /// Whether this result is hidden by another name.\n  bool Hidden : 1;\n\n  /// Whether this is a class member from base class.\n  bool InBaseClass : 1;\n\n  /// Whether this result was found via lookup into a base class.\n  bool QualifierIsInformative : 1;\n\n  /// Whether this declaration is the beginning of a\n  /// nested-name-specifier and, therefore, should be followed by '::'.\n  bool StartsNestedNameSpecifier : 1;\n\n  /// Whether all parameters (of a function, Objective-C\n  /// method, etc.) should be considered \"informative\".\n  bool AllParametersAreInformative : 1;\n\n  /// Whether we're completing a declaration of the given entity,\n  /// rather than a use of that entity.\n  bool DeclaringEntity : 1;\n\n  /// When completing a function, whether it can be a call. This will usually be\n  /// true, but we have some heuristics, e.g. when a pointer to a non-static\n  /// member function is completed outside of that class' scope, it can never\n  /// be a call.\n  bool FunctionCanBeCall : 1;\n\n  /// If the result should have a nested-name-specifier, this is it.\n  /// When \\c QualifierIsInformative, the nested-name-specifier is\n  /// informative rather than required.\n  NestedNameSpecifier *Qualifier = nullptr;\n\n  /// If this Decl was unshadowed by using declaration, this can store a\n  /// pointer to the UsingShadowDecl which was used in the unshadowing process.\n  /// This information can be used to uprank CodeCompletionResults / which have\n  /// corresponding `using decl::qualified::name;` nearby.\n  const UsingShadowDecl *ShadowDecl = nullptr;\n\n  /// If the result is RK_Macro, this can store the information about the macro\n  /// definition. This should be set in most cases but can be missing when\n  /// the macro has been undefined.\n  const MacroInfo *MacroDefInfo = nullptr;\n\n  /// Build a result that refers to a declaration.\n  CodeCompletionResult(const NamedDecl *Declaration, unsigned Priority,\n                       NestedNameSpecifier *Qualifier = nullptr,\n                       bool QualifierIsInformative = false,\n                       bool Accessible = true,\n                       std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Declaration(Declaration), Priority(Priority), Kind(RK_Declaration),\n        FixIts(std::move(FixIts)), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(QualifierIsInformative),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), FunctionCanBeCall(true), Qualifier(Qualifier) {\n    // FIXME: Add assert to check FixIts range requirements.\n    computeCursorKindAndAvailability(Accessible);\n  }\n\n  /// Build a result that refers to a keyword or symbol.\n  CodeCompletionResult(const char *Keyword, unsigned Priority = CCP_Keyword)\n      : Keyword(Keyword), Priority(Priority), Kind(RK_Keyword),\n        CursorKind(CXCursor_NotImplemented), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        FunctionCanBeCall(true) {}\n\n  /// Build a result that refers to a macro.\n  CodeCompletionResult(const IdentifierInfo *Macro,\n                       const MacroInfo *MI = nullptr,\n                       unsigned Priority = CCP_Macro)\n      : Macro(Macro), Priority(Priority), Kind(RK_Macro),\n        CursorKind(CXCursor_MacroDefinition), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        FunctionCanBeCall(true), MacroDefInfo(MI) {}\n\n  /// Build a result that refers to a pattern.\n  CodeCompletionResult(\n      CodeCompletionString *Pattern, unsigned Priority = CCP_CodePattern,\n      CXCursorKind CursorKind = CXCursor_NotImplemented,\n      CXAvailabilityKind Availability = CXAvailability_Available,\n      const NamedDecl *D = nullptr)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        CursorKind(CursorKind), Availability(Availability), Hidden(false),\n        InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), FunctionCanBeCall(true) {}\n\n  /// Build a result that refers to a pattern with an associated\n  /// declaration.\n  CodeCompletionResult(CodeCompletionString *Pattern, const NamedDecl *D,\n                       unsigned Priority)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        Hidden(false), InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), FunctionCanBeCall(true) {\n    computeCursorKindAndAvailability();\n  }\n\n  /// Retrieve the declaration stored in this result. This might be nullptr if\n  /// Kind is RK_Pattern.\n  const NamedDecl *getDeclaration() const {\n    assert(((Kind == RK_Declaration) || (Kind == RK_Pattern)) &&\n           \"Not a declaration or pattern result\");\n    return Declaration;\n  }\n\n  /// Retrieve the keyword stored in this result.\n  const char *getKeyword() const {\n    assert(Kind == RK_Keyword && \"Not a keyword result\");\n    return Keyword;\n  }\n\n  /// Create a new code-completion string that describes how to insert\n  /// this result into a program.\n  ///\n  /// \\param S The semantic analysis that created the result.\n  ///\n  /// \\param Allocator The allocator that will be used to allocate the\n  /// string itself.\n  CodeCompletionString *CreateCodeCompletionString(Sema &S,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  CodeCompletionString *CreateCodeCompletionString(ASTContext &Ctx,\n                                                   Preprocessor &PP,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  /// Creates a new code-completion string for the macro result. Similar to the\n  /// above overloads, except this only requires preprocessor information.\n  /// The result kind must be `RK_Macro`.\n  CodeCompletionString *\n  CreateCodeCompletionStringForMacro(Preprocessor &PP,\n                                     CodeCompletionAllocator &Allocator,\n                                     CodeCompletionTUInfo &CCTUInfo);\n\n  CodeCompletionString *createCodeCompletionStringForDecl(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  CodeCompletionString *createCodeCompletionStringForOverride(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  /// Retrieve the name that should be used to order a result.\n  ///\n  /// If the name needs to be constructed as a string, that string will be\n  /// saved into Saved and the returned StringRef will refer to it.\n  StringRef getOrderedName(std::string &Saved) const;\n\nprivate:\n  void computeCursorKindAndAvailability(bool Accessible = true);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-19463",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/CodeCompleteConsumer.h",
  "source_line": 754,
  "validation_status": "validated"
}