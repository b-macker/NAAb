{
  "code": "{\n public:\n  // PeriodicSamplerBase is trivial / copyable / movable / destructible.\n  PeriodicSamplerBase() = default;\n  PeriodicSamplerBase(PeriodicSamplerBase&&) = default;\n  PeriodicSamplerBase(const PeriodicSamplerBase&) = default;\n\n  // Returns true roughly once every `period` calls. This is established by a\n  // randomly picked `stride` that is counted down on each call to `Sample`.\n  // This stride is picked such that the probability of `Sample()` returning\n  // true is 1 in `period`.\n  inline bool Sample() noexcept;\n\n  // The below methods are intended for optimized use cases where the\n  // size of the inlined fast path code is highly important. Applications\n  // should use the `Sample()` method unless they have proof that their\n  // specific use case requires the optimizations offered by these methods.\n  //\n  // An example of such a use case is SwissTable sampling. All sampling checks\n  // are in inlined SwissTable methods, and the number of call sites is huge.\n  // In this case, the inlined code size added to each translation unit calling\n  // SwissTable methods is non-trivial.\n  //\n  // The `SubtleMaybeSample()` function spuriously returns true even if the\n  // function should not be sampled, applications MUST match each call to\n  // 'SubtleMaybeSample()' returning true with a `SubtleConfirmSample()` call,\n  // and use the result of the latter as the sampling decision.\n  // In other words: the code should logically be equivalent to:\n  //\n  //    if (SubtleMaybeSample() && SubtleConfirmSample()) {\n  //      // Sample this call\n  //    }\n  //\n  // In the 'inline-size' optimized case, the `SubtleConfirmSample()` call can\n  // be placed out of line, for example, the typical use case looks as follows:\n  //\n  //   // --- frobber.h -----------\n  //   void FrobberSampled();\n  //\n  //   inline void FrobberImpl() {\n  //     // ...\n  //   }\n  //\n  //   inline void Frobber() {\n  //     if (ABSL_PREDICT_FALSE(sampler.SubtleMaybeSample())) {\n  //       FrobberSampled();\n  //     } else {\n  //       FrobberImpl();\n  //     }\n  //   }\n  //\n  //   // --- frobber.cc -----------\n  //   void FrobberSampled() {\n  //     if (!sampler.SubtleConfirmSample())) {\n  //       // Spurious false positive\n  //       FrobberImpl();\n  //       return;\n  //     }\n  //\n  //     // Sampled execution\n  //     // ...\n  //   }\n  inline bool SubtleMaybeSample() noexcept;\n  bool SubtleConfirmSample() noexcept;\n\n protected:\n  // We explicitly don't use a virtual destructor as this class is never\n  // virtually destroyed, and it keeps the class trivial, which avoids TLS\n  // prologue and epilogue code for our TLS instances.\n  ~PeriodicSamplerBase() = default;\n\n  // Returns the next stride for our sampler.\n  // This function is virtual for testing purposes only.\n  virtual int64_t GetExponentialBiased(int period) noexcept;\n\n private:\n  // Returns the current period of this sampler. Thread-safe.\n  virtual int period() const noexcept = 0;\n\n  // Keep and decrement stride_ as an unsigned integer, but compare the value\n  // to zero casted as a signed int. clang and msvc do not create optimum code\n  // if we use signed for the combined decrement and sign comparison.\n  //\n  // Below 3 alternative options, all compiles generate the best code\n  // using the unsigned increment <---> signed int comparison option.\n  //\n  // Option 1:\n  //   int64_t stride_;\n  //   if (ABSL_PREDICT_TRUE(++stride_ < 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/R5MzzA\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/z7NZAt\n  //   Clang x64 (BAD): https://gcc.godbolt.org/z/t4gPsd\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/rE6s8W\n  //   MSVC  x64 (OK) : https://gcc.godbolt.org/z/ARMXqS\n  //\n  // Option 2:\n  //   int64_t stride_ = 0;\n  //   if (ABSL_PREDICT_TRUE(--stride_ >= 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/jSQxYK\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/VJdYaA\n  //   Clang x64 (BAD): https://gcc.godbolt.org/z/Xm4NjX\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/4snaFd\n  //   MSVC  x64 (BAD): https://gcc.godbolt.org/z/BgnEKE\n  //\n  // Option 3:\n  //   uint64_t stride_;\n  //   if (ABSL_PREDICT_TRUE(static_cast<int64_t>(++stride_) < 0)) { ... }\n  //\n  //   GCC   x64 (OK) : https://gcc.godbolt.org/z/bFbfPy\n  //   GCC   ppc (OK) : https://gcc.godbolt.org/z/S9KkUE\n  //   Clang x64 (OK) : https://gcc.godbolt.org/z/UYzRb4\n  //   ICC   x64 (OK) : https://gcc.godbolt.org/z/ptTNfD\n  //   MSVC  x64 (OK) : https://gcc.godbolt.org/z/76j4-5\n  uint64_t stride_ = 0;\n  absl::profiling_internal::ExponentialBiased rng_;\n}",
  "id": "BLOCK-CPP-05828",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/profiling/internal/periodic_sampler.h",
  "source_line": 36,
  "validation_status": "validated"
}