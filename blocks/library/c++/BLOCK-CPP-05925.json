{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// pcg_engine is a simplified implementation of Melissa O'Neil's PCG engine in\n// C++.  PCG combines a linear congruential generator (LCG) with output state\n// mixing functions to generate each random variate.  pcg_engine supports only a\n// single sequence (oneseq), and does not support streams.\n//\n// pcg_engine is parameterized by two types:\n//   Params, which provides the multiplier and increment values;\n//   Mix, which mixes the state into the result.\n//\ntemplate <typename Params, typename Mix>\nclass pcg_engine {\n  static_assert(std::is_same<typename Params::state_type,\n                             typename Mix::state_type>::value,\n                \"Class-template absl::pcg_engine must be parameterized by \"\n                \"Params and Mix with identical state_type\");\n\n  static_assert(std::is_unsigned<typename Mix::result_type>::value,\n                \"Class-template absl::pcg_engine must be parameterized by \"\n                \"an unsigned Mix::result_type\");\n\n  using params_type = Params;\n  using mix_type = Mix;\n  using state_type = typename Mix::state_type;\n\n public:\n  // C++11 URBG interface:\n  using result_type = typename Mix::result_type;\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  explicit pcg_engine(uint64_t seed_value = 0) { seed(seed_value); }\n\n  template <class SeedSequence,\n            typename = typename absl::enable_if_t<\n                !std::is_same<SeedSequence, pcg_engine>::value>>\n  explicit pcg_engine(SeedSequence&& seq) {\n    seed(seq);\n  }\n\n  pcg_engine(const pcg_engine&) = default;\n  pcg_engine& operator=(const pcg_engine&) = default;\n  pcg_engine(pcg_engine&&) = default;\n  pcg_engine& operator=(pcg_engine&&) = default;\n\n  result_type operator()() {\n    // Advance the LCG state, always using the new value to generate the output.\n    state_ = lcg(state_);\n    return Mix{}(state_);\n  }\n\n  void seed(uint64_t seed_value = 0) {\n    state_type tmp = seed_value;\n    state_ = lcg(tmp + Params::increment());\n  }\n\n  template <class SeedSequence>\n  typename absl::enable_if_t<\n      !std::is_convertible<SeedSequence, uint64_t>::value, void>\n  seed(SeedSequence&& seq) {\n    reseed(seq);\n  }\n\n  void discard(uint64_t count) { state_ = advance(state_, count); }\n\n  bool operator==(const pcg_engine& other) const {\n    return state_ == other.state_;\n  }\n\n  bool operator!=(const pcg_engine& other) const { return !(*this == other); }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) == 16),\n                                    std::basic_ostream<CharT, Traits>&>\n  operator<<(\n      std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n      const pcg_engine& engine) {\n    auto saver = random_internal::make_ostream_state_saver(os);\n    random_internal::stream_u128_helper<state_type> helper;\n    helper.write(pcg_engine::params_type::multiplier(), os);\n    os << os.fill();\n    helper.write(pcg_engine::params_type::increment(), os);\n    os << os.fill();\n    helper.write(engine.state_, os);\n    return os;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) <= 8),\n                                    std::basic_ostream<CharT, Traits>&>\n  operator<<(\n      std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n      const pcg_engine& engine) {\n    auto saver = random_internal::make_ostream_state_saver(os);\n    os << pcg_engine::params_type::multiplier() << os.fill();\n    os << pcg_engine::params_type::increment() << os.fill();\n    os << engine.state_;\n    return os;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) == 16),\n                                    std::basic_istream<CharT, Traits>&>\n  operator>>(\n      std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n      pcg_engine& engine) {                   // NOLINT(runtime/references)\n    random_internal::stream_u128_helper<state_type> helper;\n    auto mult = helper.read(is);\n    auto inc = helper.read(is);\n    auto tmp = helper.read(is);\n    if (mult != pcg_engine::params_type::multiplier() ||\n        inc != pcg_engine::params_type::increment()) {\n      // signal failure by setting the failbit.\n      is.setstate(is.rdstate() | std::ios_base::failbit);\n    }\n    if (!is.fail()) {\n      engine.state_ = tmp;\n    }\n    return is;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) <= 8),\n                                    std::basic_istream<CharT, Traits>&>\n  operator>>(\n      std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n      pcg_engine& engine) {                   // NOLINT(runtime/references)\n    state_type mult{}, inc{}, tmp{};\n    is >> mult >> inc >> tmp;\n    if (mult != pcg_engine::params_type::multiplier() ||\n        inc != pcg_engine::params_type::increment()) {\n      // signal failure by setting the failbit.\n      is.setstate(is.rdstate() | std::ios_base::failbit);\n    }\n    if (!is.fail()) {\n      engine.state_ = tmp;\n    }\n    return is;\n  }\n\n private:\n  state_type state_;\n\n  // Returns the linear-congruential generator next state.\n  static inline constexpr state_type lcg(state_type s) {\n    return s * Params::multiplier() + Params::increment();\n  }\n\n  // Returns the linear-congruential arbitrary seek state.\n  inline state_type advance(state_type s, uint64_t n) const {\n    state_type mult = Params::multiplier();\n    state_type inc = Params::increment();\n    state_type m = 1;\n    state_type i = 0;\n    while (n > 0) {\n      if (n & 1) {\n        m *= mult;\n        i = i * mult + inc;\n      }\n      inc = (mult + 1) * inc;\n      mult *= mult;\n      n >>= 1;\n    }\n    return m * s + i;\n  }\n\n  template <class SeedSequence>\n  void reseed(SeedSequence& seq) {\n    using sequence_result_type = typename SeedSequence::result_type;\n    constexpr size_t kBufferSize =\n        sizeof(state_type) / sizeof(sequence_result_type);\n    sequence_result_type buffer[kBufferSize];\n    seq.generate(std::begin(buffer), std::end(buffer));\n    // Convert the seed output to a single state value.\n    state_type tmp = buffer[0];\n    for (size_t i = 1; i < kBufferSize; i++) {\n      tmp <<= (sizeof(sequence_result_type) * 8);\n      tmp |= buffer[i];\n    }\n    state_ = lcg(tmp + params_type::increment());\n  }\n};\n\n// Parameterized implementation of the PCG 128-bit oneseq state.\n// This provides state_type, multiplier, and increment for pcg_engine.\ntemplate <uint64_t kMultA, uint64_t kMultB, uint64_t kIncA, uint64_t kIncB>\nclass pcg128_params {\n public:\n  using state_type = absl::uint128;\n  static inline constexpr state_type multiplier() {\n    return absl::MakeUint128(kMultA, kMultB);\n  }\n  static inline constexpr state_type increment() {\n    return absl::MakeUint128(kIncA, kIncB);\n  }\n};\n\n// Implementation of the PCG xsl_rr_128_64 128-bit mixing function, which\n// accepts an input of state_type and mixes it into an output of result_type.\nstruct pcg_xsl_rr_128_64 {\n  using state_type = absl::uint128;\n  using result_type = uint64_t;\n\n  inline uint64_t operator()(state_type state) {\n    // This is equivalent to the xsl_rr_128_64 mixing function.\n    uint64_t rotate = static_cast<uint64_t>(state >> 122u);\n    state ^= state >> 64;\n    uint64_t s = static_cast<uint64_t>(state);\n    return rotr(s, static_cast<int>(rotate));\n  }\n};\n\n// Parameterized implementation of the PCG 64-bit oneseq state.\n// This provides state_type, multiplier, and increment for pcg_engine.\ntemplate <uint64_t kMult, uint64_t kInc>\nclass pcg64_params {\n public:\n  using state_type = uint64_t;\n  static inline constexpr state_type multiplier() { return kMult; }\n  static inline constexpr state_type increment() { return kInc; }\n};\n\n// Implementation of the PCG xsh_rr_64_32 64-bit mixing function, which accepts\n// an input of state_type and mixes it into an output of result_type.\nstruct pcg_xsh_rr_64_32 {\n  using state_type = uint64_t;\n  using result_type = uint32_t;\n  inline uint32_t operator()(uint64_t state) {\n    return rotr(static_cast<uint32_t>(((state >> 18) ^ state) >> 27),\n                state >> 59);\n  }\n};\n\n// Stable pcg_engine implementations:\n// This is a 64-bit generator using 128-bits of state.\n// The output sequence is equivalent to Melissa O'Neil's pcg64_oneseq.\nusing pcg64_2018_engine = pcg_engine<\n    random_internal::pcg128_params<0x2360ed051fc65da4ull, 0x4385df649fccf645ull,\n                                   0x5851f42d4c957f2d, 0x14057b7ef767814f>,\n    random_internal::pcg_xsl_rr_128_64>;\n\n// This is a 32-bit generator using 64-bits of state.\n// This is equivalent to Melissa O'Neil's pcg32_oneseq.\nusing pcg32_2018_engine = pcg_engine<\n    random_internal::pcg64_params<0x5851f42d4c957f2dull, 0x14057b7ef767814full>,\n    random_internal::pcg_xsh_rr_64_32>;\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05925",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/pcg_engine.h",
  "source_line": 27,
  "validation_status": "validated"
}