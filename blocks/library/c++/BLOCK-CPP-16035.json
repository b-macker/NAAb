{
  "code": "#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstring>\n#include \"clang/Basic/BuiltinHeaders.def\"\n#include \"clang/Basic/Builtins.def\"\n\nusing namespace clang;\nusing namespace Builtin;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16035_execute() {\n    {\n  llvm::ArrayRef<Info> TSRecords;\n  llvm::ArrayRef<Info> AuxTSRecords;\n\npublic:\n  Context() = default;\n\n  /// Perform target-specific initialization\n  /// \\param AuxTarget Target info to incorporate builtins from. May be nullptr.\n  void InitializeTarget(const TargetInfo &Target, const TargetInfo *AuxTarget);\n\n  /// Mark the identifiers for all the builtins with their\n  /// appropriate builtin ID # and mark any non-portable builtin identifiers as\n  /// such.\n  void initializeBuiltins(IdentifierTable &Table, const LangOptions& LangOpts);\n\n  /// Return the identifier name for the specified builtin,\n  /// e.g. \"__builtin_abs\".\n  llvm::StringRef getName(unsigned ID) const { return getRecord(ID).Name; }\n\n  /// Get the type descriptor string for the specified builtin.\n  const char *getTypeString(unsigned ID) const {\n    return getRecord(ID).Type;\n  }\n\n  /// Return true if this function is a target-specific builtin.\n  bool isTSBuiltin(unsigned ID) const {\n    return ID >= Builtin::FirstTSBuiltin;\n  }\n\n  /// Return true if this function has no side effects.\n  bool isPure(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'U') != nullptr;\n  }\n\n  /// Return true if this function has no side effects and doesn't\n  /// read memory.\n  bool isConst(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'c') != nullptr;\n  }\n\n  /// Return true if we know this builtin never throws an exception.\n  bool isNoThrow(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'n') != nullptr;\n  }\n\n  /// Return true if we know this builtin never returns.\n  bool isNoReturn(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'r') != nullptr;\n  }\n\n  /// Return true if we know this builtin can return twice.\n  bool isReturnsTwice(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'j') != nullptr;\n  }\n\n  /// Returns true if this builtin does not perform the side-effects\n  /// of its arguments.\n  bool isUnevaluated(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'u') != nullptr;\n  }\n\n  /// Return true if this is a builtin for a libc/libm function,\n  /// with a \"__builtin_\" prefix (e.g. __builtin_abs).\n  bool isLibFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'F') != nullptr;\n  }\n\n  /// Determines whether this builtin is a predefined libc/libm\n  /// function, such as \"malloc\", where we know the signature a\n  /// priori.\n  /// In C, such functions behave as if they are predeclared,\n  /// possibly with a warning on first use. In Objective-C and C++,\n  /// they do not, but they are recognized as builtins once we see\n  /// a declaration.\n  bool isPredefinedLibFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'f') != nullptr;\n  }\n\n  /// Returns true if this builtin requires appropriate header in other\n  /// compilers. In Clang it will work even without including it, but we can emit\n  /// a warning about missing header.\n  bool isHeaderDependentFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'h') != nullptr;\n  }\n\n  /// Determines whether this builtin is a predefined compiler-rt/libgcc\n  /// function, such as \"__clear_cache\", where we know the signature a\n  /// priori.\n  bool isPredefinedRuntimeFunction(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'i') != nullptr;\n  }\n\n  /// Determines whether this builtin is a C++ standard library function\n  /// that lives in (possibly-versioned) namespace std, possibly a template\n  /// specialization, where the signature is determined by the standard library\n  /// declaration.\n  bool isInStdNamespace(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'z') != nullptr;\n  }\n\n  /// Determines whether this builtin can have its address taken with no\n  /// special action required.\n  bool isDirectlyAddressable(unsigned ID) const {\n    // Most standard library functions can have their addresses taken. C++\n    // standard library functions formally cannot in C++20 onwards, and when\n    // we allow it, we need to ensure we instantiate a definition.\n    return isPredefinedLibFunction(ID) && !isInStdNamespace(ID);\n  }\n\n  /// Determines whether this builtin has custom typechecking.\n  bool hasCustomTypechecking(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 't') != nullptr;\n  }\n\n  /// Determines whether a declaration of this builtin should be recognized\n  /// even if the type doesn't match the specified signature.\n  bool allowTypeMismatch(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'T') != nullptr ||\n           hasCustomTypechecking(ID);\n  }\n\n  /// Determines whether this builtin has a result or any arguments which\n  /// are pointer types.\n  bool hasPtrArgsOrResult(unsigned ID) const {\n    return strchr(getRecord(ID).Type, '*') != nullptr;\n  }\n\n  /// Return true if this builtin has a result or any arguments which are\n  /// reference types.\n  bool hasReferenceArgsOrResult(unsigned ID) const {\n    return strchr(getRecord(ID).Type, '&') != nullptr ||\n           strchr(getRecord(ID).Type, 'A') != nullptr;\n  }\n\n  /// If this is a library function that comes from a specific\n  /// header, retrieve that header name.\n  const char *getHeaderName(unsigned ID) const {\n    return getRecord(ID).Header.getName();\n  }\n\n  /// Determine whether this builtin is like printf in its\n  /// formatting rules and, if so, set the index to the format string\n  /// argument and whether this function as a va_list argument.\n  bool isPrintfLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg);\n\n  /// Determine whether this builtin is like scanf in its\n  /// formatting rules and, if so, set the index to the format string\n  /// argument and whether this function as a va_list argument.\n  bool isScanfLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg);\n\n  /// Determine whether this builtin has callback behavior (see\n  /// llvm::AbstractCallSites for details). If so, add the index to the\n  /// callback callee argument and the callback payload arguments.\n  bool performsCallback(unsigned ID,\n                        llvm::SmallVectorImpl<int> &Encoding) const;\n\n  /// Return true if this function has no side effects and doesn't\n  /// read memory, except for possibly errno or raising FP exceptions.\n  ///\n  /// Such functions can be const when the MathErrno lang option and FP\n  /// exceptions are disabled.\n  bool isConstWithoutErrnoAndExceptions(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'e') != nullptr;\n  }\n\n  bool isConstWithoutExceptions(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'g') != nullptr;\n  }\n\n  const char *getRequiredFeatures(unsigned ID) const {\n    return getRecord(ID).Features;\n  }\n\n  unsigned getRequiredVectorWidth(unsigned ID) const;\n\n  /// Return true if builtin ID belongs to AuxTarget.\n  bool isAuxBuiltinID(unsigned ID) const {\n    return ID >= (Builtin::FirstTSBuiltin + TSRecords.size());\n  }\n\n  /// Return real builtin ID (i.e. ID it would have during compilation\n  /// for AuxTarget).\n  unsigned getAuxBuiltinID(unsigned ID) const { return ID - TSRecords.size(); }\n\n  /// Returns true if this is a libc/libm function without the '__builtin_'\n  /// prefix.\n  static bool isBuiltinFunc(llvm::StringRef Name);\n\n  /// Returns true if this is a builtin that can be redeclared.  Returns true\n  /// for non-builtins.\n  bool canBeRedeclared(unsigned ID) const;\n\n  /// Return true if this function can be constant evaluated by Clang frontend.\n  bool isConstantEvaluated(unsigned ID) const {\n    return strchr(getRecord(ID).Attributes, 'E') != nullptr;\n  }\n\nprivate:\n  const Info &getRecord(unsigned ID) const;\n\n  /// Helper function for isPrintfLike and isScanfLike.\n  bool isLike(unsigned ID, unsigned &FormatIdx, bool &HasVAListArg,\n              const char *Fmt) const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16035",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Builtins.h",
  "source_line": 85,
  "validation_status": "validated"
}