{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace str_format_internal {\n\n// The analyzed properties of a single specified conversion.\nstruct UnboundConversion {\n  // This is a user defined default constructor on purpose to skip the\n  // initialization of parts of the object that are not necessary.\n  UnboundConversion() {}  // NOLINT\n\n  // This constructor is provided for the static checker. We don't want to do\n  // the unnecessary initialization in the normal case.\n  explicit constexpr UnboundConversion(absl::ConstInitType)\n      : arg_position{}, width{}, precision{} {}\n\n  class InputValue {\n   public:\n    constexpr void set_value(int value) {\n      assert(value >= 0);\n      value_ = value;\n    }\n    constexpr int value() const { return value_; }\n\n    // Marks the value as \"from arg\". aka the '*' format.\n    // Requires `value >= 1`.\n    // When set, is_from_arg() return true and get_from_arg() returns the\n    // original value.\n    // `value()`'s return value is unspecified in this state.\n    constexpr void set_from_arg(int value) {\n      assert(value > 0);\n      value_ = -value - 1;\n    }\n    constexpr bool is_from_arg() const { return value_ < -1; }\n    constexpr int get_from_arg() const {\n      assert(is_from_arg());\n      return -value_ - 1;\n    }\n\n   private:\n    int value_ = -1;\n  };\n\n  // No need to initialize. It will always be set in the parser.\n  int arg_position;\n\n  InputValue width;\n  InputValue precision;\n\n  Flags flags = Flags::kBasic;\n  LengthMod length_mod = LengthMod::none;\n  FormatConversionChar conv = FormatConversionCharInternal::kNone;\n};\n\n// Helper tag class for the table below.\n// It allows fast `char -> ConversionChar/LengthMod/Flags` checking and\n// conversions.\nclass ConvTag {\n public:\n  constexpr ConvTag(FormatConversionChar conversion_char)  // NOLINT\n      : tag_(static_cast<uint8_t>(conversion_char)) {}\n  constexpr ConvTag(LengthMod length_mod)  // NOLINT\n      : tag_(0x80 | static_cast<uint8_t>(length_mod)) {}\n  constexpr ConvTag(Flags flags)  // NOLINT\n      : tag_(0xc0 | static_cast<uint8_t>(flags)) {}\n  constexpr ConvTag() : tag_(0xFF) {}\n\n  constexpr bool is_conv() const { return (tag_ & 0x80) == 0; }\n  constexpr bool is_length() const { return (tag_ & 0xC0) == 0x80; }\n  constexpr bool is_flags() const { return (tag_ & 0xE0) == 0xC0; }\n\n  constexpr FormatConversionChar as_conv() const {\n    assert(is_conv());\n    assert(!is_length());\n    assert(!is_flags());\n    return static_cast<FormatConversionChar>(tag_);\n  }\n  constexpr LengthMod as_length() const {\n    assert(!is_conv());\n    assert(is_length());\n    assert(!is_flags());\n    return static_cast<LengthMod>(tag_ & 0x3F);\n  }\n  constexpr Flags as_flags() const {\n    assert(!is_conv());\n    assert(!is_length());\n    assert(is_flags());\n    return static_cast<Flags>(tag_ & 0x1F);\n  }\n\n private:\n  uint8_t tag_;\n};\n\nstruct ConvTagHolder {\n  using CC = FormatConversionCharInternal;\n  using LM = LengthMod;\n\n  // Abbreviations to fit in the table below.\n  static constexpr auto kFSign = Flags::kSignCol;\n  static constexpr auto kFAlt = Flags::kAlt;\n  static constexpr auto kFPos = Flags::kShowPos;\n  static constexpr auto kFLeft = Flags::kLeft;\n  static constexpr auto kFZero = Flags::kZero;\n\n  static constexpr ConvTag value[256] = {\n      {},     {},    {},    {},    {},    {},     {},    {},     // 00-07\n      {},     {},    {},    {},    {},    {},     {},    {},     // 08-0f\n      {},     {},    {},    {},    {},    {},     {},    {},     // 10-17\n      {},     {},    {},    {},    {},    {},     {},    {},     // 18-1f\n      kFSign, {},    {},    kFAlt, {},    {},     {},    {},     //  !\"#$%&'\n      {},     {},    {},    kFPos, {},    kFLeft, {},    {},     // ()*+,-./\n      kFZero, {},    {},    {},    {},    {},     {},    {},     // 01234567\n      {},     {},    {},    {},    {},    {},     {},    {},     // 89:;<=>?\n      {},     CC::A, {},    {},    {},    CC::E,  CC::F, CC::G,  // @ABCDEFG\n      {},     {},    {},    {},    LM::L, {},     {},    {},     // HIJKLMNO\n      {},     {},    {},    {},    {},    {},     {},    {},     // PQRSTUVW\n      CC::X,  {},    {},    {},    {},    {},     {},    {},     // XYZ[\\]^_\n      {},     CC::a, {},    CC::c, CC::d, CC::e,  CC::f, CC::g,  // `abcdefg\n      LM::h,  CC::i, LM::j, {},    LM::l, {},     CC::n, CC::o,  // hijklmno\n      CC::p,  LM::q, {},    CC::s, LM::t, CC::u,  CC::v, {},     // pqrstuvw\n      CC::x,  {},    LM::z, {},    {},    {},     {},    {},     // xyz{|}!\n      {},     {},    {},    {},    {},    {},     {},    {},     // 80-87\n      {},     {},    {},    {},    {},    {},     {},    {},     // 88-8f\n      {},     {},    {},    {},    {},    {},     {},    {},     // 90-97\n      {},     {},    {},    {},    {},    {},     {},    {},     // 98-9f\n      {},     {},    {},    {},    {},    {},     {},    {},     // a0-a7\n      {},     {},    {},    {},    {},    {},     {},    {},     // a8-af\n      {},     {},    {},    {},    {},    {},     {},    {},     // b0-b7\n      {},     {},    {},    {},    {},    {},     {},    {},     // b8-bf\n      {},     {},    {},    {},    {},    {},     {},    {},     // c0-c7\n      {},     {},    {},    {},    {},    {},     {},    {},     // c8-cf\n      {},     {},    {},    {},    {},    {},     {},    {},     // d0-d7\n      {},     {},    {},    {},    {},    {},     {},    {},     // d8-df\n      {},     {},    {},    {},    {},    {},     {},    {},     // e0-e7\n      {},     {},    {},    {},    {},    {},     {},    {},     // e8-ef\n      {},     {},    {},    {},    {},    {},     {},    {},     // f0-f7\n      {},     {},    {},    {},    {},    {},     {},    {},     // f8-ff\n  };\n};\n\n// Keep a single table for all the conversion chars and length modifiers.\nconstexpr ConvTag GetTagForChar(char c) {\n  return ConvTagHolder::value[static_cast<unsigned char>(c)];\n}\n\nconstexpr bool CheckFastPathSetting(const UnboundConversion& conv) {\n  bool width_precision_needed =\n      conv.width.value() >= 0 || conv.precision.value() >= 0;\n  if (width_precision_needed && conv.flags == Flags::kBasic) {\n#if defined(__clang__)\n    // Some compilers complain about this in constexpr even when not executed,\n    // so only enable the error dump in clang.\n    fprintf(stderr,\n            \"basic=%d left=%d show_pos=%d sign_col=%d alt=%d zero=%d \"\n            \"width=%d precision=%d\\n\",\n            conv.flags == Flags::kBasic ? 1 : 0,\n            FlagsContains(conv.flags, Flags::kLeft) ? 1 : 0,\n            FlagsContains(conv.flags, Flags::kShowPos) ? 1 : 0,\n            FlagsContains(conv.flags, Flags::kSignCol) ? 1 : 0,\n            FlagsContains(conv.flags, Flags::kAlt) ? 1 : 0,\n            FlagsContains(conv.flags, Flags::kZero) ? 1 : 0, conv.width.value(),\n            conv.precision.value());\n#endif  // defined(__clang__)\n    return false;\n  }\n  return true;\n}\n\nconstexpr int ParseDigits(char& c, const char*& pos, const char* const end) {\n  int digits = c - '0';\n  // We do not want to overflow `digits` so we consume at most digits10\n  // digits. If there are more digits the parsing will fail later on when the\n  // digit doesn't match the expected characters.\n  int num_digits = std::numeric_limits<int>::digits10;\n  for (;;) {\n    if (ABSL_PREDICT_FALSE(pos == end)) break;\n    c = *pos++;\n    if ('0' > c || c > '9') break;\n    --num_digits;\n    if (ABSL_PREDICT_FALSE(!num_digits)) break;\n    digits = 10 * digits + c - '0';\n  }\n  return digits;\n}\n\ntemplate <bool is_positional>\nconstexpr const char* ConsumeConversion(const char* pos, const char* const end,\n                                        UnboundConversion* conv,\n                                        int* next_arg) {\n  const char* const original_pos = pos;\n  char c = 0;\n  // Read the next char into `c` and update `pos`. Returns false if there are\n  // no more chars to read.\n#define ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR()          \\\n  do {                                                  \\\n    if (ABSL_PREDICT_FALSE(pos == end)) return nullptr; \\\n    c = *pos++;                                         \\\n  } while (0)\n\n  if (is_positional) {\n    ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n    if (ABSL_PREDICT_FALSE(c < '1' || c > '9')) return nullptr;\n    conv->arg_position = ParseDigits(c, pos, end);\n    assert(conv->arg_position > 0);\n    if (ABSL_PREDICT_FALSE(c != '$')) return nullptr;\n  }\n\n  ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n\n  // We should start with the basic flag on.\n  assert(conv->flags == Flags::kBasic);\n\n  // Any non alpha character makes this conversion not basic.\n  // This includes flags (-+ #0), width (1-9, *) or precision (.).\n  // All conversion characters and length modifiers are alpha characters.\n  if (c < 'A') {\n    while (c <= '0') {\n      auto tag = GetTagForChar(c);\n      if (tag.is_flags()) {\n        conv->flags = conv->flags | tag.as_flags();\n        ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n      } else {\n        break;\n      }\n    }\n\n    if (c <= '9') {\n      if (c >= '0') {\n        int maybe_width = ParseDigits(c, pos, end);\n        if (!is_positional && c == '$') {\n          if (ABSL_PREDICT_FALSE(*next_arg != 0)) return nullptr;\n          // Positional conversion.\n          *next_arg = -1;\n          return ConsumeConversion<true>(original_pos, end, conv, next_arg);\n        }\n        conv->flags = conv->flags | Flags::kNonBasic;\n        conv->width.set_value(maybe_width);\n      } else if (c == '*') {\n        conv->flags = conv->flags | Flags::kNonBasic;\n        ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n        if (is_positional) {\n          if (ABSL_PREDICT_FALSE(c < '1' || c > '9')) return nullptr;\n          conv->width.set_from_arg(ParseDigits(c, pos, end));\n          if (ABSL_PREDICT_FALSE(c != '$')) return nullptr;\n          ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n        } else {\n          conv->width.set_from_arg(++*next_arg);\n        }\n      }\n    }\n\n    if (c == '.') {\n      conv->flags = conv->flags | Flags::kNonBasic;\n      ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n      if ('0' <= c && c <= '9') {\n        conv->precision.set_value(ParseDigits(c, pos, end));\n      } else if (c == '*') {\n        ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n        if (is_positional) {\n          if (ABSL_PREDICT_FALSE(c < '1' || c > '9')) return nullptr;\n          conv->precision.set_from_arg(ParseDigits(c, pos, end));\n          if (c != '$') return nullptr;\n          ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n        } else {\n          conv->precision.set_from_arg(++*next_arg);\n        }\n      } else {\n        conv->precision.set_value(0);\n      }\n    }\n  }\n\n  auto tag = GetTagForChar(c);\n\n  if (ABSL_PREDICT_FALSE(c == 'v' && conv->flags != Flags::kBasic)) {\n    return nullptr;\n  }\n\n  if (ABSL_PREDICT_FALSE(!tag.is_conv())) {\n    if (ABSL_PREDICT_FALSE(!tag.is_length())) return nullptr;\n\n    // It is a length modifier.\n    LengthMod length_mod = tag.as_length();\n    ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n    if (c == 'h' && length_mod == LengthMod::h) {\n      conv->length_mod = LengthMod::hh;\n      ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n    } else if (c == 'l' && length_mod == LengthMod::l) {\n      conv->length_mod = LengthMod::ll;\n      ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR();\n    } else {\n      conv->length_mod = length_mod;\n    }\n    tag = GetTagForChar(c);\n\n    if (ABSL_PREDICT_FALSE(c == 'v')) return nullptr;\n    if (ABSL_PREDICT_FALSE(!tag.is_conv())) return nullptr;\n\n    // `wchar_t` args are marked non-basic so `Bind()` will copy the length mod.\n    if (conv->length_mod == LengthMod::l && c == 'c') {\n      conv->flags = conv->flags | Flags::kNonBasic;\n    }\n  }\n#undef ABSL_FORMAT_PARSER_INTERNAL_GET_CHAR\n\n  assert(CheckFastPathSetting(*conv));\n  (void)(&CheckFastPathSetting);\n\n  conv->conv = tag.as_conv();\n  if (!is_positional) conv->arg_position = ++*next_arg;\n  return pos;\n}\n\n// Consume conversion spec prefix (not including '%') of [p, end) if valid.\n// Examples of valid specs would be e.g.: \"s\", \"d\", \"-12.6f\".\n// If valid, it returns the first character following the conversion spec,\n// and the spec part is broken down and returned in 'conv'.\n// If invalid, returns nullptr.\nconstexpr const char* ConsumeUnboundConversion(const char* p, const char* end,\n                                               UnboundConversion* conv,\n                                               int* next_arg) {\n  if (*next_arg < 0) return ConsumeConversion<true>(p, end, conv, next_arg);\n  return ConsumeConversion<false>(p, end, conv, next_arg);\n}\n\n}  // namespace str_format_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06356",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_format/constexpr_parser.h",
  "source_line": 28,
  "validation_status": "validated"
}