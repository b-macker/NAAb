{
  "code": "{\n  friend class DirectoryLookup;\n\n  friend ConstSearchDirIterator;\n  friend SearchDirIterator;\n\n  /// Header-search options used to initialize this header search.\n  std::shared_ptr<HeaderSearchOptions> HSOpts;\n\n  /// Mapping from SearchDir to HeaderSearchOptions::UserEntries indices.\n  llvm::DenseMap<unsigned, unsigned> SearchDirToHSEntry;\n\n  DiagnosticsEngine &Diags;\n  FileManager &FileMgr;\n\n  /// \\#include search path information.  Requests for \\#include \"x\" search the\n  /// directory of the \\#including file first, then each directory in SearchDirs\n  /// consecutively. Requests for <x> search the current dir first, then each\n  /// directory in SearchDirs, starting at AngledDirIdx, consecutively.  If\n  /// NoCurDirSearch is true, then the check for the file in the current\n  /// directory is suppressed.\n  std::vector<DirectoryLookup> SearchDirs;\n  /// Whether the DirectoryLookup at the corresponding index in SearchDirs has\n  /// been successfully used to lookup a file.\n  std::vector<bool> SearchDirsUsage;\n  unsigned AngledDirIdx = 0;\n  unsigned SystemDirIdx = 0;\n  bool NoCurDirSearch = false;\n\n  /// Maps HeaderMap keys to SearchDir indices. When HeaderMaps are used\n  /// heavily, SearchDirs can start with thousands of HeaderMaps, so this Index\n  /// lets us avoid scanning them all to find a match.\n  llvm::StringMap<unsigned, llvm::BumpPtrAllocator> SearchDirHeaderMapIndex;\n\n  /// The index of the first SearchDir that isn't a header map.\n  unsigned FirstNonHeaderMapSearchDirIdx = 0;\n\n  /// \\#include prefixes for which the 'system header' property is\n  /// overridden.\n  ///\n  /// For a \\#include \"x\" or \\#include \\<x> directive, the last string in this\n  /// list which is a prefix of 'x' determines whether the file is treated as\n  /// a system header.\n  std::vector<std::pair<std::string, bool>> SystemHeaderPrefixes;\n\n  /// The hash used for module cache paths.\n  std::string ModuleHash;\n\n  /// The path to the module cache.\n  std::string ModuleCachePath;\n\n  /// All of the preprocessor-specific data about files that are\n  /// included, indexed by the FileEntry's UID.\n  mutable std::vector<HeaderFileInfo> FileInfo;\n\n  /// Keeps track of each lookup performed by LookupFile.\n  struct LookupFileCacheInfo {\n    // The requesting module for the lookup we cached.\n    const Module *RequestingModule = nullptr;\n\n    /// Starting search directory iterator that the cached search was performed\n    /// from. If there is a hit and this value doesn't match the current query,\n    /// the cache has to be ignored.\n    ConstSearchDirIterator StartIt = nullptr;\n\n    /// The search directory iterator that satisfied the query.\n    ConstSearchDirIterator HitIt = nullptr;\n\n    /// This is non-null if the original filename was mapped to a framework\n    /// include via a headermap.\n    const char *MappedName = nullptr;\n\n    /// Default constructor -- Initialize all members with zero.\n    LookupFileCacheInfo() = default;\n\n    void reset(const Module *NewRequestingModule,\n               ConstSearchDirIterator NewStartIt) {\n      RequestingModule = NewRequestingModule;\n      StartIt = NewStartIt;\n      MappedName = nullptr;\n    }\n  };\n  llvm::StringMap<LookupFileCacheInfo, llvm::BumpPtrAllocator> LookupFileCache;\n\n  /// Collection mapping a framework or subframework\n  /// name like \"Carbon\" to the Carbon.framework directory.\n  llvm::StringMap<FrameworkCacheEntry, llvm::BumpPtrAllocator> FrameworkMap;\n\n  /// Maps include file names (including the quotes or\n  /// angle brackets) to other include file names.  This is used to support the\n  /// include_alias pragma for Microsoft compatibility.\n  using IncludeAliasMap =\n      llvm::StringMap<std::string, llvm::BumpPtrAllocator>;\n  std::unique_ptr<IncludeAliasMap> IncludeAliases;\n\n  /// This is a mapping from FileEntry -> HeaderMap, uniquing headermaps.\n  std::vector<std::pair<const FileEntry *, std::unique_ptr<HeaderMap>>> HeaderMaps;\n\n  /// The mapping between modules and headers.\n  mutable ModuleMap ModMap;\n\n  /// Describes whether a given directory has a module map in it.\n  llvm::DenseMap<const DirectoryEntry *, bool> DirectoryHasModuleMap;\n\n  /// Set of module map files we've already loaded, and a flag indicating\n  /// whether they were valid or not.\n  llvm::DenseMap<const FileEntry *, bool> LoadedModuleMaps;\n\n  // A map of discovered headers with their associated include file name.\n  llvm::DenseMap<const FileEntry *, llvm::SmallString<64>> IncludeNames;\n\n  /// Uniqued set of framework names, which is used to track which\n  /// headers were included as framework headers.\n  llvm::StringSet<llvm::BumpPtrAllocator> FrameworkNames;\n\n  /// Entity used to resolve the identifier IDs of controlling\n  /// macros into IdentifierInfo pointers, and keep the identifire up to date,\n  /// as needed.\n  ExternalPreprocessorSource *ExternalLookup = nullptr;\n\n  /// Entity used to look up stored header file information.\n  ExternalHeaderFileInfoSource *ExternalSource = nullptr;\n\n  /// Scan all of the header maps at the beginning of SearchDirs and\n  /// map their keys to the SearchDir index of their header map.\n  void indexInitialHeaderMaps();\n\npublic:\n  HeaderSearch(std::shared_ptr<HeaderSearchOptions> HSOpts,\n               SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n               const LangOptions &LangOpts, const TargetInfo *Target);\n  HeaderSearch(const HeaderSearch &) = delete;\n  HeaderSearch &operator=(const HeaderSearch &) = delete;\n\n  /// Retrieve the header-search options with which this header search\n  /// was initialized.\n  HeaderSearchOptions &getHeaderSearchOpts() const { return *HSOpts; }\n\n  FileManager &getFileMgr() const { return FileMgr; }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Interface for setting the file search paths.\n  void SetSearchPaths(std::vector<DirectoryLookup> dirs, unsigned angledDirIdx,\n                      unsigned systemDirIdx, bool noCurDirSearch,\n                      llvm::DenseMap<unsigned, unsigned> searchDirToHSEntry);\n\n  /// Add an additional search path.\n  void AddSearchPath(const DirectoryLookup &dir, bool isAngled);\n\n  /// Add an additional system search path.\n  void AddSystemSearchPath(const DirectoryLookup &dir) {\n    SearchDirs.push_back(dir);\n    SearchDirsUsage.push_back(false);\n  }\n\n  /// Set the list of system header prefixes.\n  void SetSystemHeaderPrefixes(ArrayRef<std::pair<std::string, bool>> P) {\n    SystemHeaderPrefixes.assign(P.begin(), P.end());\n  }\n\n  /// Checks whether the map exists or not.\n  bool HasIncludeAliasMap() const { return (bool)IncludeAliases; }\n\n  /// Map the source include name to the dest include name.\n  ///\n  /// The Source should include the angle brackets or quotes, the dest\n  /// should not.  This allows for distinction between <> and \"\" headers.\n  void AddIncludeAlias(StringRef Source, StringRef Dest) {\n    if (!IncludeAliases)\n      IncludeAliases.reset(new IncludeAliasMap);\n    (*IncludeAliases)[Source] = std::string(Dest);\n  }\n\n  /// Maps one header file name to a different header\n  /// file name, for use with the include_alias pragma.  Note that the source\n  /// file name should include the angle brackets or quotes.  Returns StringRef\n  /// as null if the header cannot be mapped.\n  StringRef MapHeaderToIncludeAlias(StringRef Source) {\n    assert(IncludeAliases && \"Trying to map headers when there's no map\");\n\n    // Do any filename replacements before anything else\n    IncludeAliasMap::const_iterator Iter = IncludeAliases->find(Source);\n    if (Iter != IncludeAliases->end())\n      return Iter->second;\n    return {};\n  }\n\n  /// Set the hash to use for module cache paths.\n  void setModuleHash(StringRef Hash) { ModuleHash = std::string(Hash); }\n\n  /// Set the path to the module cache.\n  void setModuleCachePath(StringRef CachePath) {\n    ModuleCachePath = std::string(CachePath);\n  }\n\n  /// Retrieve the module hash.\n  StringRef getModuleHash() const { return ModuleHash; }\n\n  /// Retrieve the path to the module cache.\n  StringRef getModuleCachePath() const { return ModuleCachePath; }\n\n  /// Consider modules when including files from this directory.\n  void setDirectoryHasModuleMap(const DirectoryEntry* Dir) {\n    DirectoryHasModuleMap[Dir] = true;\n  }\n\n  /// Forget everything we know about headers so far.\n  void ClearFileInfo() {\n    FileInfo.clear();\n  }\n\n  void SetExternalLookup(ExternalPreprocessorSource *EPS) {\n    ExternalLookup = EPS;\n  }\n\n  ExternalPreprocessorSource *getExternalLookup() const {\n    return ExternalLookup;\n  }\n\n  /// Set the external source of header information.\n  void SetExternalSource(ExternalHeaderFileInfoSource *ES) {\n    ExternalSource = ES;\n  }\n\n  /// Set the target information for the header search, if not\n  /// already known.\n  void setTarget(const TargetInfo &Target);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file,\n  /// return null on failure.\n  ///\n  /// \\returns If successful, this returns 'UsedDir', the DirectoryLookup member\n  /// the file was found in, or null if not applicable.\n  ///\n  /// \\param IncludeLoc Used for diagnostics if valid.\n  ///\n  /// \\param isAngled indicates whether the file reference is a <> reference.\n  ///\n  /// \\param CurDir If non-null, the file was found in the specified directory\n  /// search location.  This is used to implement \\#include_next.\n  ///\n  /// \\param Includers Indicates where the \\#including file(s) are, in case\n  /// relative searches are needed. In reverse order of inclusion.\n  ///\n  /// \\param SearchPath If non-null, will be set to the search path relative\n  /// to which the file was found. If the include path is absolute, SearchPath\n  /// will be set to an empty string.\n  ///\n  /// \\param RelativePath If non-null, will be set to the path relative to\n  /// SearchPath at which the file was found. This only differs from the\n  /// Filename for framework includes.\n  ///\n  /// \\param SuggestedModule If non-null, and the file found is semantically\n  /// part of a known module, this will be set to the module that should\n  /// be imported instead of preprocessing/parsing the file found.\n  ///\n  /// \\param IsMapped If non-null, and the search involved header maps, set to\n  /// true.\n  ///\n  /// \\param IsFrameworkFound If non-null, will be set to true if a framework is\n  /// found in any of searched SearchDirs. Will be set to false if a framework\n  /// is found only through header maps. Doesn't guarantee the requested file is\n  /// found.\n  OptionalFileEntryRef LookupFile(\n      StringRef Filename, SourceLocation IncludeLoc, bool isAngled,\n      ConstSearchDirIterator FromDir, ConstSearchDirIterator *CurDir,\n      ArrayRef<std::pair<const FileEntry *, DirectoryEntryRef>> Includers,\n      SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,\n      Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,\n      bool *IsMapped, bool *IsFrameworkFound, bool SkipCache = false,\n      bool BuildSystemModule = false, bool OpenFile = true,\n      bool CacheFailures = true);\n\n  /// Look up a subframework for the specified \\#include file.\n  ///\n  /// For example, if \\#include'ing <HIToolbox/HIToolbox.h> from\n  /// within \".../Carbon.framework/Headers/Carbon.h\", check to see if\n  /// HIToolbox is a subframework within Carbon.framework.  If so, return\n  /// the FileEntry for the designated file, otherwise return null.\n  OptionalFileEntryRef LookupSubframeworkHeader(\n      StringRef Filename, const FileEntry *ContextFileEnt,\n      SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,\n      Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule);\n\n  /// Look up the specified framework name in our framework cache.\n  /// \\returns The DirectoryEntry it is in if we know, null otherwise.\n  FrameworkCacheEntry &LookupFrameworkCache(StringRef FWName) {\n    return FrameworkMap[FWName];\n  }\n\n  /// Mark the specified file as a target of a \\#include,\n  /// \\#include_next, or \\#import directive.\n  ///\n  /// \\return false if \\#including the file will have no effect or true\n  /// if we should include it.\n  bool ShouldEnterIncludeFile(Preprocessor &PP, const FileEntry *File,\n                              bool isImport, bool ModulesEnabled, Module *M,\n                              bool &IsFirstIncludeOfFile);\n\n  /// Return whether the specified file is a normal header,\n  /// a system header, or a C++ friendly system header.\n  SrcMgr::CharacteristicKind getFileDirFlavor(const FileEntry *File) {\n    return (SrcMgr::CharacteristicKind)getFileInfo(File).DirInfo;\n  }\n\n  /// Mark the specified file as a \"once only\" file due to\n  /// \\#pragma once.\n  void MarkFileIncludeOnce(const FileEntry *File) {\n    HeaderFileInfo &FI = getFileInfo(File);\n    FI.isPragmaOnce = true;\n  }\n\n  /// Mark the specified file as a system header, e.g. due to\n  /// \\#pragma GCC system_header.\n  void MarkFileSystemHeader(const FileEntry *File) {\n    getFileInfo(File).DirInfo = SrcMgr::C_System;\n  }\n\n  /// Mark the specified file as part of a module.\n  void MarkFileModuleHeader(const FileEntry *FE,\n                            ModuleMap::ModuleHeaderRole Role,\n                            bool isCompilingModuleHeader);\n\n  /// Mark the specified file as having a controlling macro.\n  ///\n  /// This is used by the multiple-include optimization to eliminate\n  /// no-op \\#includes.\n  void SetFileControllingMacro(const FileEntry *File,\n                               const IdentifierInfo *ControllingMacro) {\n    getFileInfo(File).ControllingMacro = ControllingMacro;\n  }\n\n  /// Determine whether this file is intended to be safe from\n  /// multiple inclusions, e.g., it has \\#pragma once or a controlling\n  /// macro.\n  ///\n  /// This routine does not consider the effect of \\#import\n  bool isFileMultipleIncludeGuarded(const FileEntry *File) const;\n\n  /// Determine whether the given file is known to have ever been \\#imported.\n  bool hasFileBeenImported(const FileEntry *File) const {\n    const HeaderFileInfo *FI = getExistingFileInfo(File);\n    return FI && FI->isImport;\n  }\n\n  /// Determine which HeaderSearchOptions::UserEntries have been successfully\n  /// used so far and mark their index with 'true' in the resulting bit vector.\n  /// Note: implicit module maps don't contribute to entry usage.\n  std::vector<bool> computeUserEntryUsage() const;\n\n  /// This method returns a HeaderMap for the specified\n  /// FileEntry, uniquing them through the 'HeaderMaps' datastructure.\n  const HeaderMap *CreateHeaderMap(const FileEntry *FE);\n\n  /// Get filenames for all registered header maps.\n  void getHeaderMapFileNames(SmallVectorImpl<std::string> &Names) const;\n\n  /// Retrieve the name of the cached module file that should be used\n  /// to load the given module.\n  ///\n  /// \\param Module The module whose module file name will be returned.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileName(Module *Module);\n\n  /// Retrieve the name of the prebuilt module file that should be used\n  /// to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param FileMapOnly If true, then only look in the explicit module name\n  //  to file name map and skip the directory search.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getPrebuiltModuleFileName(StringRef ModuleName,\n                                        bool FileMapOnly = false);\n\n  /// Retrieve the name of the prebuilt module file that should be used\n  /// to load the given module.\n  ///\n  /// \\param Module The module whose module file name will be returned.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getPrebuiltImplicitModuleFileName(Module *Module);\n\n  /// Retrieve the name of the (to-be-)cached module file that should\n  /// be used to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param ModuleMapPath A path that when combined with \\c ModuleName\n  /// uniquely identifies this module. See Module::ModuleMap.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileName(StringRef ModuleName,\n                                      StringRef ModuleMapPath);\n\n  /// Lookup a module Search for a module with the given name.\n  ///\n  /// \\param ModuleName The name of the module we're looking for.\n  ///\n  /// \\param ImportLoc Location of the module include/import.\n  ///\n  /// \\param AllowSearch Whether we are allowed to search in the various\n  /// search directories to produce a module definition. If not, this lookup\n  /// will only return an already-known module.\n  ///\n  /// \\param AllowExtraModuleMapSearch Whether we allow to search modulemaps\n  /// in subdirectories.\n  ///\n  /// \\returns The module with the given name.\n  Module *lookupModule(StringRef ModuleName,\n                       SourceLocation ImportLoc = SourceLocation(),\n                       bool AllowSearch = true,\n                       bool AllowExtraModuleMapSearch = false);\n\n  /// Try to find a module map file in the given directory, returning\n  /// \\c nullopt if none is found.\n  OptionalFileEntryRef lookupModuleMapFile(DirectoryEntryRef Dir,\n                                           bool IsFramework);\n\n  /// Determine whether there is a module map that may map the header\n  /// with the given file name to a (sub)module.\n  /// Always returns false if modules are disabled.\n  ///\n  /// \\param Filename The name of the file.\n  ///\n  /// \\param Root The \"root\" directory, at which we should stop looking for\n  /// module maps.\n  ///\n  /// \\param IsSystem Whether the directories we're looking at are system\n  /// header directories.\n  bool hasModuleMap(StringRef Filename, const DirectoryEntry *Root,\n                    bool IsSystem);\n\n  /// Retrieve the module that corresponds to the given file, if any.\n  ///\n  /// \\param File The header that we wish to map to a module.\n  /// \\param AllowTextual Whether we want to find textual headers too.\n  ModuleMap::KnownHeader findModuleForHeader(FileEntryRef File,\n                                             bool AllowTextual = false,\n                                             bool AllowExcluded = false) const;\n\n  /// Retrieve all the modules corresponding to the given file.\n  ///\n  /// \\param AllowCreation Whether to allow inference of a new submodule, or to\n  ///        only return existing known modules.\n  ///\n  /// \\ref findModuleForHeader should typically be used instead of this.\n  ArrayRef<ModuleMap::KnownHeader>\n  findAllModulesForHeader(FileEntryRef File) const;\n\n  /// Like \\ref findAllModulesForHeader, but do not attempt to infer module\n  /// ownership from umbrella headers if we've not already done so.\n  ArrayRef<ModuleMap::KnownHeader>\n  findResolvedModulesForHeader(const FileEntry *File) const;\n\n  /// Read the contents of the given module map file.\n  ///\n  /// \\param File The module map file.\n  /// \\param IsSystem Whether this file is in a system header directory.\n  /// \\param ID If the module map file is already mapped (perhaps as part of\n  ///        processing a preprocessed module), the ID of the file.\n  /// \\param Offset [inout] An offset within ID to start parsing. On exit,\n  ///        filled by the end of the parsed contents (either EOF or the\n  ///        location of an end-of-module-map pragma).\n  /// \\param OriginalModuleMapFile The original path to the module map file,\n  ///        used to resolve paths within the module (this is required when\n  ///        building the module from preprocessed source).\n  /// \\returns true if an error occurred, false otherwise.\n  bool loadModuleMapFile(FileEntryRef File, bool IsSystem, FileID ID = FileID(),\n                         unsigned *Offset = nullptr,\n                         StringRef OriginalModuleMapFile = StringRef());\n\n  /// Collect the set of all known, top-level modules.\n  ///\n  /// \\param Modules Will be filled with the set of known, top-level modules.\n  void collectAllModules(SmallVectorImpl<Module *> &Modules);\n\n  /// Load all known, top-level system modules.\n  void loadTopLevelSystemModules();\n\nprivate:\n  /// Lookup a module with the given module name and search-name.\n  ///\n  /// \\param ModuleName The name of the module we're looking for.\n  ///\n  /// \\param SearchName The \"search-name\" to derive filesystem paths from\n  /// when looking for the module map; this is usually equal to ModuleName,\n  /// but for compatibility with some buggy frameworks, additional attempts\n  /// may be made to find the module under a related-but-different search-name.\n  ///\n  /// \\param ImportLoc Location of the module include/import.\n  ///\n  /// \\param AllowExtraModuleMapSearch Whether we allow to search modulemaps\n  /// in subdirectories.\n  ///\n  /// \\returns The module named ModuleName.\n  Module *lookupModule(StringRef ModuleName, StringRef SearchName,\n                       SourceLocation ImportLoc,\n                       bool AllowExtraModuleMapSearch = false);\n\n  /// Retrieve the name of the (to-be-)cached module file that should\n  /// be used to load a module with the given name.\n  ///\n  /// \\param ModuleName The module whose module file name will be returned.\n  ///\n  /// \\param ModuleMapPath A path that when combined with \\c ModuleName\n  /// uniquely identifies this module. See Module::ModuleMap.\n  ///\n  /// \\param CachePath A path to the module cache.\n  ///\n  /// \\returns The name of the module file that corresponds to this module,\n  /// or an empty string if this module does not correspond to any module file.\n  std::string getCachedModuleFileNameImpl(StringRef ModuleName,\n                                          StringRef ModuleMapPath,\n                                          StringRef CachePath);\n\n  /// Retrieve a module with the given name, which may be part of the\n  /// given framework.\n  ///\n  /// \\param Name The name of the module to retrieve.\n  ///\n  /// \\param Dir The framework directory (e.g., ModuleName.framework).\n  ///\n  /// \\param IsSystem Whether the framework directory is part of the system\n  /// frameworks.\n  ///\n  /// \\returns The module, if found; otherwise, null.\n  Module *loadFrameworkModule(StringRef Name, DirectoryEntryRef Dir,\n                              bool IsSystem);\n\n  /// Load all of the module maps within the immediate subdirectories\n  /// of the given search directory.\n  void loadSubdirectoryModuleMaps(DirectoryLookup &SearchDir);\n\n  /// Find and suggest a usable module for the given file.\n  ///\n  /// \\return \\c true if the file can be used, \\c false if we are not permitted to\n  ///         find this file due to requirements from \\p RequestingModule.\n  bool findUsableModuleForHeader(FileEntryRef File, const DirectoryEntry *Root,\n                                 Module *RequestingModule,\n                                 ModuleMap::KnownHeader *SuggestedModule,\n                                 bool IsSystemHeaderDir);\n\n  /// Find and suggest a usable module for the given file, which is part of\n  /// the specified framework.\n  ///\n  /// \\return \\c true if the file can be used, \\c false if we are not permitted to\n  ///         find this file due to requirements from \\p RequestingModule.\n  bool findUsableModuleForFrameworkHeader(\n      FileEntryRef File, StringRef FrameworkName, Module *RequestingModule,\n      ModuleMap::KnownHeader *SuggestedModule, bool IsSystemFramework);\n\n  /// Look up the file with the specified name and determine its owning\n  /// module.\n  OptionalFileEntryRef\n  getFileAndSuggestModule(StringRef FileName, SourceLocation IncludeLoc,\n                          const DirectoryEntry *Dir, bool IsSystemHeaderDir,\n                          Module *RequestingModule,\n                          ModuleMap::KnownHeader *SuggestedModule,\n                          bool OpenFile = true, bool CacheFailures = true);\n\n  /// Cache the result of a successful lookup at the given include location\n  /// using the search path at \\c HitIt.\n  void cacheLookupSuccess(LookupFileCacheInfo &CacheLookup,\n                          ConstSearchDirIterator HitIt,\n                          SourceLocation IncludeLoc);\n\n  /// Note that a lookup at the given include location was successful using the\n  /// search path at index `HitIdx`.\n  void noteLookupUsage(unsigned HitIdx, SourceLocation IncludeLoc);\n\npublic:\n  /// Retrieve the module map.\n  ModuleMap &getModuleMap() { return ModMap; }\n\n  /// Retrieve the module map.\n  const ModuleMap &getModuleMap() const { return ModMap; }\n\n  unsigned header_file_size() const { return FileInfo.size(); }\n\n  /// Return the HeaderFileInfo structure for the specified FileEntry,\n  /// in preparation for updating it in some way.\n  HeaderFileInfo &getFileInfo(const FileEntry *FE);\n\n  /// Return the HeaderFileInfo structure for the specified FileEntry,\n  /// if it has ever been filled in.\n  /// \\param WantExternal Whether the caller wants purely-external header file\n  ///        info (where \\p External is true).\n  const HeaderFileInfo *getExistingFileInfo(const FileEntry *FE,\n                                            bool WantExternal = true) const;\n\n  SearchDirIterator search_dir_begin() { return {*this, 0}; }\n  SearchDirIterator search_dir_end() { return {*this, SearchDirs.size()}; }\n  SearchDirRange search_dir_range() {\n    return {search_dir_begin(), search_dir_end()};\n  }\n\n  ConstSearchDirIterator search_dir_begin() const { return quoted_dir_begin(); }\n  ConstSearchDirIterator search_dir_nth(size_t n) const {\n    assert(n < SearchDirs.size());\n    return {*this, n};\n  }\n  ConstSearchDirIterator search_dir_end() const { return system_dir_end(); }\n  ConstSearchDirRange search_dir_range() const {\n    return {search_dir_begin(), search_dir_end()};\n  }\n\n  unsigned search_dir_size() const { return SearchDirs.size(); }\n\n  ConstSearchDirIterator quoted_dir_begin() const { return {*this, 0}; }\n  ConstSearchDirIterator quoted_dir_end() const { return angled_dir_begin(); }\n\n  ConstSearchDirIterator angled_dir_begin() const {\n    return {*this, AngledDirIdx};\n  }\n  ConstSearchDirIterator angled_dir_end() const { return system_dir_begin(); }\n\n  ConstSearchDirIterator system_dir_begin() const {\n    return {*this, SystemDirIdx};\n  }\n  ConstSearchDirIterator system_dir_end() const {\n    return {*this, SearchDirs.size()};\n  }\n\n  /// Get the index of the given search directory.\n  unsigned searchDirIdx(const DirectoryLookup &DL) const;\n\n  /// Retrieve a uniqued framework name.\n  StringRef getUniqueFrameworkName(StringRef Framework);\n\n  /// Retrieve the include name for the header.\n  ///\n  /// \\param File The entry for a given header.\n  /// \\returns The name of how the file was included when the header's location\n  /// was resolved.\n  StringRef getIncludeNameForHeader(const FileEntry *File) const;\n\n  /// Suggest a path by which the specified file could be found, for use in\n  /// diagnostics to suggest a #include. Returned path will only contain forward\n  /// slashes as separators. MainFile is the absolute path of the file that we\n  /// are generating the diagnostics for. It will try to shorten the path using\n  /// MainFile location, if none of the include search directories were prefix\n  /// of File.\n  ///\n  /// \\param IsSystem If non-null, filled in to indicate whether the suggested\n  ///        path is relative to a system header directory.\n  std::string suggestPathToFileForDiagnostics(const FileEntry *File,\n                                              llvm::StringRef MainFile,\n                                              bool *IsSystem = nullptr) const;\n\n  /// Suggest a path by which the specified file could be found, for use in\n  /// diagnostics to suggest a #include. Returned path will only contain forward\n  /// slashes as separators. MainFile is the absolute path of the file that we\n  /// are generating the diagnostics for. It will try to shorten the path using\n  /// MainFile location, if none of the include search directories were prefix\n  /// of File.\n  ///\n  /// \\param WorkingDir If non-empty, this will be prepended to search directory\n  /// paths that are relative.\n  std::string suggestPathToFileForDiagnostics(llvm::StringRef File,\n                                              llvm::StringRef WorkingDir,\n                                              llvm::StringRef MainFile,\n                                              bool *IsSystem = nullptr) const;\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\nprivate:\n  /// Describes what happened when we tried to load a module map file.\n  enum LoadModuleMapResult {\n    /// The module map file had already been loaded.\n    LMM_AlreadyLoaded,\n\n    /// The module map file was loaded by this invocation.\n    LMM_NewlyLoaded,\n\n    /// There is was directory with the given name.\n    LMM_NoDirectory,\n\n    /// There was either no module map file or the module map file was\n    /// invalid.\n    LMM_InvalidModuleMap\n  };\n\n  LoadModuleMapResult loadModuleMapFileImpl(FileEntryRef File, bool IsSystem,\n                                            DirectoryEntryRef Dir,\n                                            FileID ID = FileID(),\n                                            unsigned *Offset = nullptr);\n\n  /// Try to load the module map file in the given directory.\n  ///\n  /// \\param DirName The name of the directory where we will look for a module\n  /// map file.\n  /// \\param IsSystem Whether this is a system header directory.\n  /// \\param IsFramework Whether this is a framework directory.\n  ///\n  /// \\returns The result of attempting to load the module map file from the\n  /// named directory.\n  LoadModuleMapResult loadModuleMapFile(StringRef DirName, bool IsSystem,\n                                        bool IsFramework);\n\n  /// Try to load the module map file in the given directory.\n  ///\n  /// \\param Dir The directory where we will look for a module map file.\n  /// \\param IsSystem Whether this is a system header directory.\n  /// \\param IsFramework Whether this is a framework directory.\n  ///\n  /// \\returns The result of attempting to load the module map file from the\n  /// named directory.\n  LoadModuleMapResult loadModuleMapFile(DirectoryEntryRef Dir, bool IsSystem,\n                                        bool IsFramework);\n}",
  "id": "BLOCK-CPP-18603",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/HeaderSearch.h",
  "source_line": 223,
  "validation_status": "validated"
}