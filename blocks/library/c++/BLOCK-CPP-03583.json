{
  "code": "#include <memory>\n#include <string>\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/fast_type_id.h\"\n#include \"absl/flags/internal/commandlineflag.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/types/optional.h\"\n\nusing namespace absl;\nusing namespace flags_internal;\nusing namespace flags_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03583_execute() {\n    {\n    if (IsRetired() || !IsOfType<T>()) {\n      return absl::nullopt;\n    }\n\n    // Implementation notes:\n    //\n    // We are wrapping a union around the value of `T` to serve three purposes:\n    //\n    //  1. `U.value` has correct size and alignment for a value of type `T`\n    //  2. The `U.value` constructor is not invoked since U's constructor does\n    //     not do it explicitly.\n    //  3. The `U.value` destructor is invoked since U's destructor does it\n    //     explicitly. This makes `U` a kind of RAII wrapper around non default\n    //     constructible value of T, which is destructed when we leave the\n    //     scope. We do need to destroy U.value, which is constructed by\n    //     CommandLineFlag::Read even though we left it in a moved-from state\n    //     after std::move.\n    //\n    // All of this serves to avoid requiring `T` being default constructible.\n    union U {\n      T value;\n      U() {}\n      ~U() { value.~T(); }\n    };\n    U u;\n\n    Read(&u.value);\n    // allow retired flags to be \"read\", so we can report invalid access.\n    if (IsRetired()) {\n      return absl::nullopt;\n    }\n    return std::move(u.value);\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03583",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/commandlineflag.h",
  "source_line": 82,
  "validation_status": "validated"
}