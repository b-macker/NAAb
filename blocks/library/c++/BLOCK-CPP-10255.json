{
  "code": "{\n    /// A field designator, e.g., \".x\".\n    struct FieldDesignatorInfo {\n      /// Refers to the field that is being initialized. The low bit\n      /// of this field determines whether this is actually a pointer\n      /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n      /// initially constructed, a field designator will store an\n      /// IdentifierInfo*. After semantic analysis has resolved that\n      /// name, the field designator will instead store a FieldDecl*.\n      uintptr_t NameOrField;\n\n      /// The location of the '.' in the designated initializer.\n      SourceLocation DotLoc;\n\n      /// The location of the field name in the designated initializer.\n      SourceLocation FieldLoc;\n\n      FieldDesignatorInfo(const IdentifierInfo *II, SourceLocation DotLoc,\n                          SourceLocation FieldLoc)\n          : NameOrField(reinterpret_cast<uintptr_t>(II) | 0x1), DotLoc(DotLoc),\n            FieldLoc(FieldLoc) {}\n    };\n\n    /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10...15]\".\n    struct ArrayOrRangeDesignatorInfo {\n      /// Location of the first index expression within the designated\n      /// initializer expression's list of subexpressions.\n      unsigned Index;\n\n      /// The location of the '[' starting the array range designator.\n      SourceLocation LBracketLoc;\n\n      /// The location of the ellipsis separating the start and end\n      /// indices. Only valid for GNU array-range designators.\n      SourceLocation EllipsisLoc;\n\n      /// The location of the ']' terminating the array range designator.\n      SourceLocation RBracketLoc;\n\n      ArrayOrRangeDesignatorInfo(unsigned Index, SourceLocation LBracketLoc,\n                                 SourceLocation RBracketLoc)\n          : Index(Index), LBracketLoc(LBracketLoc), RBracketLoc(RBracketLoc) {}\n\n      ArrayOrRangeDesignatorInfo(unsigned Index,\n                                 SourceLocation LBracketLoc,\n                                 SourceLocation EllipsisLoc,\n                                 SourceLocation RBracketLoc)\n          : Index(Index), LBracketLoc(LBracketLoc), EllipsisLoc(EllipsisLoc),\n            RBracketLoc(RBracketLoc) {}\n    };\n\n    /// The kind of designator this describes.\n    enum DesignatorKind {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    };\n\n    DesignatorKind Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignatorInfo FieldInfo;\n\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignatorInfo ArrayOrRangeInfo;\n    };\n\n    Designator(DesignatorKind Kind) : Kind(Kind) {}\n\n  public:\n    Designator() {}\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    //===------------------------------------------------------------------===//\n    // FieldDesignatorInfo\n\n    /// Creates a field designator.\n    static Designator CreateFieldDesignator(const IdentifierInfo *FieldName,\n                                            SourceLocation DotLoc,\n                                            SourceLocation FieldLoc) {\n      Designator D(FieldDesignator);\n      new (&D.FieldInfo) FieldDesignatorInfo(FieldName, DotLoc, FieldLoc);\n      return D;\n    }\n\n    const IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getFieldDecl() const {\n      assert(isFieldDesignator() && \"Only valid on a field designator\");\n      if (FieldInfo.NameOrField & 0x01)\n        return nullptr;\n      return reinterpret_cast<FieldDecl *>(FieldInfo.NameOrField);\n    }\n\n    void setFieldDecl(FieldDecl *FD) {\n      assert(isFieldDesignator() && \"Only valid on a field designator\");\n      FieldInfo.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(isFieldDesignator() && \"Only valid on a field designator\");\n      return FieldInfo.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(isFieldDesignator() && \"Only valid on a field designator\");\n      return FieldInfo.FieldLoc;\n    }\n\n    //===------------------------------------------------------------------===//\n    // ArrayOrRangeDesignator\n\n    /// Creates an array designator.\n    static Designator CreateArrayDesignator(unsigned Index,\n                                            SourceLocation LBracketLoc,\n                                            SourceLocation RBracketLoc) {\n      Designator D(ArrayDesignator);\n      new (&D.ArrayOrRangeInfo) ArrayOrRangeDesignatorInfo(Index, LBracketLoc,\n                                                           RBracketLoc);\n      return D;\n    }\n\n    /// Creates a GNU array-range designator.\n    static Designator CreateArrayRangeDesignator(unsigned Index,\n                                                 SourceLocation LBracketLoc,\n                                                 SourceLocation EllipsisLoc,\n                                                 SourceLocation RBracketLoc) {\n      Designator D(ArrayRangeDesignator);\n      new (&D.ArrayOrRangeInfo) ArrayOrRangeDesignatorInfo(Index, LBracketLoc,\n                                                           EllipsisLoc,\n                                                           RBracketLoc);\n      return D;\n    }\n\n    unsigned getArrayIndex() const {\n      assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRangeInfo.Index;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRangeInfo.LBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(isArrayRangeDesignator() &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRangeInfo.EllipsisLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((isArrayDesignator() || isArrayRangeDesignator()) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRangeInfo.RBracketLoc;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (isFieldDesignator())\n        return getDotLoc().isInvalid() ? getFieldLoc() : getDotLoc();\n      return getLBracketLoc();\n    }\n\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return isFieldDesignator() ? getFieldLoc() : getRBracketLoc();\n    }\n\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  }",
  "id": "BLOCK-CPP-10255",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Expr.h",
  "source_line": 5116,
  "validation_status": "validated"
}