{
  "code": "{\n  // The actual object stored in the container.\n  using slot_type = typename Policy::slot_type;\n  using reference = decltype(Policy::element(std::declval<slot_type*>()));\n  using value_type = typename std::remove_reference<reference>::type;\n\n  // PRECONDITION: `slot` is UNINITIALIZED\n  // POSTCONDITION: `slot` is INITIALIZED\n  template <class Alloc, class... Args>\n  static void construct(Alloc* alloc, slot_type* slot, Args&&... args) {\n    Policy::construct(alloc, slot, std::forward<Args>(args)...);\n  }\n\n  // PRECONDITION: `slot` is INITIALIZED\n  // POSTCONDITION: `slot` is UNINITIALIZED\n  template <class Alloc>\n  static void destroy(Alloc* alloc, slot_type* slot) {\n    Policy::destroy(alloc, slot);\n  }\n\n  // Transfers the `old_slot` to `new_slot`. Any memory allocated by the\n  // allocator inside `old_slot` to `new_slot` can be transferred.\n  //\n  // OPTIONAL: defaults to:\n  //\n  //     clone(new_slot, std::move(*old_slot));\n  //     destroy(old_slot);\n  //\n  // PRECONDITION: `new_slot` is UNINITIALIZED and `old_slot` is INITIALIZED\n  // POSTCONDITION: `new_slot` is INITIALIZED and `old_slot` is\n  //                UNINITIALIZED\n  template <class Alloc>\n  static void transfer(Alloc* alloc, slot_type* new_slot, slot_type* old_slot) {\n    transfer_impl(alloc, new_slot, old_slot, Rank0{});\n  }\n\n  // PRECONDITION: `slot` is INITIALIZED\n  // POSTCONDITION: `slot` is INITIALIZED\n  // Note: we use remove_const_t so that the two overloads have different args\n  // in the case of sets with explicitly const value_types.\n  template <class P = Policy>\n  static auto element(absl::remove_const_t<slot_type>* slot)\n      -> decltype(P::element(slot)) {\n    return P::element(slot);\n  }\n  template <class P = Policy>\n  static auto element(const slot_type* slot) -> decltype(P::element(slot)) {\n    return P::element(slot);\n  }\n\n  static constexpr bool transfer_uses_memcpy() {\n    return std::is_same<decltype(transfer_impl<std::allocator<char>>(\n                            nullptr, nullptr, nullptr, Rank0{})),\n                        std::true_type>::value;\n  }\n\n private:\n  // To rank the overloads below for overload resolution. Rank0 is preferred.\n  struct Rank2 {};\n  struct Rank1 : Rank2 {};\n  struct Rank0 : Rank1 {};\n\n  // Use auto -> decltype as an enabler.\n  // P::transfer returns std::true_type if transfer uses memcpy (e.g. in\n  // node_slot_policy).\n  template <class Alloc, class P = Policy>\n  static auto transfer_impl(Alloc* alloc, slot_type* new_slot,\n                            slot_type* old_slot, Rank0)\n      -> decltype(P::transfer(alloc, new_slot, old_slot)) {\n    return P::transfer(alloc, new_slot, old_slot);\n  }\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606\n  // This overload returns true_type for the trait below.\n  // The conditional_t is to make the enabler type dependent.\n  template <class Alloc,\n            typename = std::enable_if_t<absl::is_trivially_relocatable<\n                std::conditional_t<false, Alloc, value_type>>::value>>\n  static std::true_type transfer_impl(Alloc*, slot_type* new_slot,\n                                      slot_type* old_slot, Rank1) {\n    // TODO(b/247130232): remove casts after fixing warnings.\n    // TODO(b/251814870): remove casts after fixing warnings.\n    std::memcpy(\n        static_cast<void*>(std::launder(\n            const_cast<std::remove_const_t<value_type>*>(&element(new_slot)))),\n        static_cast<const void*>(&element(old_slot)), sizeof(value_type));\n    return {};\n  }\n#endif\n\n  template <class Alloc>\n  static void transfer_impl(Alloc* alloc, slot_type* new_slot,\n                            slot_type* old_slot, Rank2) {\n    construct(alloc, new_slot, std::move(element(old_slot)));\n    destroy(alloc, old_slot);\n  }\n}",
  "id": "BLOCK-CPP-04951",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/common_policy_traits.h",
  "source_line": 32,
  "validation_status": "validated"
}