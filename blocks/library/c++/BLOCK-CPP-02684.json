{
  "code": "{\n\nstatic uint64_t Mix(uint64_t v0, uint64_t v1) {\n  absl::uint128 p = v0;\n  p *= v1;\n  return absl::Uint128Low64(p) ^ absl::Uint128High64(p);\n}\n\nuint64_t LowLevelHash(const void* data, size_t len, uint64_t seed,\n                      const uint64_t salt[5]) {\n  // Prefetch the cacheline that data resides in.\n  PrefetchToLocalCache(data);\n  const uint8_t* ptr = static_cast<const uint8_t*>(data);\n  uint64_t starting_length = static_cast<uint64_t>(len);\n  uint64_t current_state = seed ^ salt[0];\n\n  if (len > 64) {\n    // If we have more than 64 bytes, we're going to handle chunks of 64\n    // bytes at a time. We're going to build up two separate hash states\n    // which we will then hash together.\n    uint64_t duplicated_state = current_state;\n\n    do {\n      // Always prefetch the next cacheline.\n      PrefetchToLocalCache(ptr + ABSL_CACHELINE_SIZE);\n\n      uint64_t a = absl::base_internal::UnalignedLoad64(ptr);\n      uint64_t b = absl::base_internal::UnalignedLoad64(ptr + 8);\n      uint64_t c = absl::base_internal::UnalignedLoad64(ptr + 16);\n      uint64_t d = absl::base_internal::UnalignedLoad64(ptr + 24);\n      uint64_t e = absl::base_internal::UnalignedLoad64(ptr + 32);\n      uint64_t f = absl::base_internal::UnalignedLoad64(ptr + 40);\n      uint64_t g = absl::base_internal::UnalignedLoad64(ptr + 48);\n      uint64_t h = absl::base_internal::UnalignedLoad64(ptr + 56);\n\n      uint64_t cs0 = Mix(a ^ salt[1], b ^ current_state);\n      uint64_t cs1 = Mix(c ^ salt[2], d ^ current_state);\n      current_state = (cs0 ^ cs1);\n\n      uint64_t ds0 = Mix(e ^ salt[3], f ^ duplicated_state);\n      uint64_t ds1 = Mix(g ^ salt[4], h ^ duplicated_state);\n      duplicated_state = (ds0 ^ ds1);\n\n      ptr += 64;\n      len -= 64;\n    } while (len > 64);\n\n    current_state = current_state ^ duplicated_state;\n  }\n\n  // We now have a data `ptr` with at most 64 bytes and the current state\n  // of the hashing state machine stored in current_state.\n  while (len > 16) {\n    uint64_t a = absl::base_internal::UnalignedLoad64(ptr);\n    uint64_t b = absl::base_internal::UnalignedLoad64(ptr + 8);\n\n    current_state = Mix(a ^ salt[1], b ^ current_state);\n\n    ptr += 16;\n    len -= 16;\n  }\n\n  // We now have a data `ptr` with at most 16 bytes.\n  uint64_t a = 0;\n  uint64_t b = 0;\n  if (len > 8) {\n    // When we have at least 9 and at most 16 bytes, set A to the first 64\n    // bits of the input and B to the last 64 bits of the input. Yes, they will\n    // overlap in the middle if we are working with less than the full 16\n    // bytes.\n    a = absl::base_internal::UnalignedLoad64(ptr);\n    b = absl::base_internal::UnalignedLoad64(ptr + len - 8);\n  } else if (len > 3) {\n    // If we have at least 4 and at most 8 bytes, set A to the first 32\n    // bits and B to the last 32 bits.\n    a = absl::base_internal::UnalignedLoad32(ptr);\n    b = absl::base_internal::UnalignedLoad32(ptr + len - 4);\n  } else if (len > 0) {\n    // If we have at least 1 and at most 3 bytes, read all of the provided\n    // bits into A, with some adjustments.\n    a = static_cast<uint64_t>((ptr[0] << 16) | (ptr[len >> 1] << 8) |\n                              ptr[len - 1]);\n    b = 0;\n  } else {\n    a = 0;\n    b = 0;\n  }\n\n  uint64_t w = Mix(a ^ salt[1], b ^ current_state);\n  uint64_t z = salt[1] ^ starting_length;\n  return Mix(w, z);\n}\n\n}",
  "id": "BLOCK-CPP-02684",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/internal/low_level_hash.cc",
  "source_line": 23,
  "validation_status": "validated"
}