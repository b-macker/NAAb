{
  "code": "{\npublic:\n  /// A visitor interface to visit all BoundNodes results for a\n  /// BoundNodesTree.\n  class Visitor {\n  public:\n    virtual ~Visitor() = default;\n\n    /// Called multiple times during a single call to VisitMatches(...).\n    ///\n    /// 'BoundNodesView' contains the bound nodes for a single match.\n    virtual void visitMatch(const BoundNodes& BoundNodesView) = 0;\n  };\n\n  /// Add a binding from an id to a node.\n  void setBinding(StringRef Id, const DynTypedNode &DynNode) {\n    if (Bindings.empty())\n      Bindings.emplace_back();\n    for (BoundNodesMap &Binding : Bindings)\n      Binding.addNode(Id, DynNode);\n  }\n\n  /// Adds a branch in the tree.\n  void addMatch(const BoundNodesTreeBuilder &Bindings);\n\n  /// Visits all matches that this BoundNodesTree represents.\n  ///\n  /// The ownership of 'ResultVisitor' remains at the caller.\n  void visitMatches(Visitor* ResultVisitor);\n\n  template <typename ExcludePredicate>\n  bool removeBindings(const ExcludePredicate &Predicate) {\n    llvm::erase_if(Bindings, Predicate);\n    return !Bindings.empty();\n  }\n\n  /// Imposes an order on BoundNodesTreeBuilders.\n  bool operator<(const BoundNodesTreeBuilder &Other) const {\n    return Bindings < Other.Bindings;\n  }\n\n  /// Returns \\c true if this \\c BoundNodesTreeBuilder can be compared,\n  /// i.e. all stored node maps have memoization data.\n  bool isComparable() const {\n    for (const BoundNodesMap &NodesMap : Bindings) {\n      if (!NodesMap.isComparable())\n        return false;\n    }\n    return true;\n  }\n\nprivate:\n  SmallVector<BoundNodesMap, 1> Bindings;\n}",
  "id": "BLOCK-CPP-15253",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchersInternal.h",
  "source_line": 279,
  "validation_status": "validated"
}