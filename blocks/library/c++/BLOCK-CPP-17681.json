{
  "code": "{\npublic:\n  using size_type = ActionList::size_type;\n  using input_iterator = ActionList::iterator;\n  using input_const_iterator = ActionList::const_iterator;\n  using input_range = llvm::iterator_range<input_iterator>;\n  using input_const_range = llvm::iterator_range<input_const_iterator>;\n\n  enum ActionClass {\n    InputClass = 0,\n    BindArchClass,\n    OffloadClass,\n    PreprocessJobClass,\n    PrecompileJobClass,\n    ExtractAPIJobClass,\n    AnalyzeJobClass,\n    MigrateJobClass,\n    CompileJobClass,\n    BackendJobClass,\n    AssembleJobClass,\n    LinkJobClass,\n    IfsMergeJobClass,\n    LipoJobClass,\n    DsymutilJobClass,\n    VerifyDebugInfoJobClass,\n    VerifyPCHJobClass,\n    OffloadBundlingJobClass,\n    OffloadUnbundlingJobClass,\n    OffloadPackagerJobClass,\n    LinkerWrapperJobClass,\n    StaticLibJobClass,\n    BinaryAnalyzeJobClass,\n\n    JobClassFirst = PreprocessJobClass,\n    JobClassLast = BinaryAnalyzeJobClass\n  };\n\n  // The offloading kind determines if this action is binded to a particular\n  // programming model. Each entry reserves one bit. We also have a special kind\n  // to designate the host offloading tool chain.\n  enum OffloadKind {\n    OFK_None = 0x00,\n\n    // The host offloading tool chain.\n    OFK_Host = 0x01,\n\n    // The device offloading tool chains - one bit for each programming model.\n    OFK_Cuda = 0x02,\n    OFK_OpenMP = 0x04,\n    OFK_HIP = 0x08,\n  };\n\n  static const char *getClassName(ActionClass AC);\n\nprivate:\n  ActionClass Kind;\n\n  /// The output type of this action.\n  types::ID Type;\n\n  ActionList Inputs;\n\n  /// Flag that is set to true if this action can be collapsed with others\n  /// actions that depend on it. This is true by default and set to false when\n  /// the action is used by two different tool chains, which is enabled by the\n  /// offloading support implementation.\n  bool CanBeCollapsedWithNextDependentAction = true;\n\nprotected:\n  ///\n  /// Offload information.\n  ///\n\n  /// The host offloading kind - a combination of kinds encoded in a mask.\n  /// Multiple programming models may be supported simultaneously by the same\n  /// host.\n  unsigned ActiveOffloadKindMask = 0u;\n\n  /// Offloading kind of the device.\n  OffloadKind OffloadingDeviceKind = OFK_None;\n\n  /// The Offloading architecture associated with this action.\n  const char *OffloadingArch = nullptr;\n\n  /// The Offloading toolchain associated with this device action.\n  const ToolChain *OffloadingToolChain = nullptr;\n\n  Action(ActionClass Kind, types::ID Type) : Action(Kind, ActionList(), Type) {}\n  Action(ActionClass Kind, Action *Input, types::ID Type)\n      : Action(Kind, ActionList({Input}), Type) {}\n  Action(ActionClass Kind, Action *Input)\n      : Action(Kind, ActionList({Input}), Input->getType()) {}\n  Action(ActionClass Kind, const ActionList &Inputs, types::ID Type)\n      : Kind(Kind), Type(Type), Inputs(Inputs) {}\n\npublic:\n  virtual ~Action();\n\n  const char *getClassName() const { return Action::getClassName(getKind()); }\n\n  ActionClass getKind() const { return Kind; }\n  types::ID getType() const { return Type; }\n\n  ActionList &getInputs() { return Inputs; }\n  const ActionList &getInputs() const { return Inputs; }\n\n  size_type size() const { return Inputs.size(); }\n\n  input_iterator input_begin() { return Inputs.begin(); }\n  input_iterator input_end() { return Inputs.end(); }\n  input_range inputs() { return input_range(input_begin(), input_end()); }\n  input_const_iterator input_begin() const { return Inputs.begin(); }\n  input_const_iterator input_end() const { return Inputs.end(); }\n  input_const_range inputs() const {\n    return input_const_range(input_begin(), input_end());\n  }\n\n  /// Mark this action as not legal to collapse.\n  void setCannotBeCollapsedWithNextDependentAction() {\n    CanBeCollapsedWithNextDependentAction = false;\n  }\n\n  /// Return true if this function can be collapsed with others.\n  bool isCollapsingWithNextDependentActionLegal() const {\n    return CanBeCollapsedWithNextDependentAction;\n  }\n\n  /// Return a string containing the offload kind of the action.\n  std::string getOffloadingKindPrefix() const;\n\n  /// Return a string that can be used as prefix in order to generate unique\n  /// files for each offloading kind. By default, no prefix is used for\n  /// non-device kinds, except if \\a CreatePrefixForHost is set.\n  static std::string\n  GetOffloadingFileNamePrefix(OffloadKind Kind,\n                              StringRef NormalizedTriple,\n                              bool CreatePrefixForHost = false);\n\n  /// Return a string containing a offload kind name.\n  static StringRef GetOffloadKindName(OffloadKind Kind);\n\n  /// Set the device offload info of this action and propagate it to its\n  /// dependences.\n  void propagateDeviceOffloadInfo(OffloadKind OKind, const char *OArch,\n                                  const ToolChain *OToolChain);\n\n  /// Append the host offload info of this action and propagate it to its\n  /// dependences.\n  void propagateHostOffloadInfo(unsigned OKinds, const char *OArch);\n\n  void setHostOffloadInfo(unsigned OKinds, const char *OArch) {\n    ActiveOffloadKindMask |= OKinds;\n    OffloadingArch = OArch;\n  }\n\n  /// Set the offload info of this action to be the same as the provided action,\n  /// and propagate it to its dependences.\n  void propagateOffloadInfo(const Action *A);\n\n  unsigned getOffloadingHostActiveKinds() const {\n    return ActiveOffloadKindMask;\n  }\n\n  OffloadKind getOffloadingDeviceKind() const { return OffloadingDeviceKind; }\n  const char *getOffloadingArch() const { return OffloadingArch; }\n  const ToolChain *getOffloadingToolChain() const {\n    return OffloadingToolChain;\n  }\n\n  /// Check if this action have any offload kinds. Note that host offload kinds\n  /// are only set if the action is a dependence to a host offload action.\n  bool isHostOffloading(unsigned int OKind) const {\n    return ActiveOffloadKindMask & OKind;\n  }\n  bool isDeviceOffloading(OffloadKind OKind) const {\n    return OffloadingDeviceKind == OKind;\n  }\n  bool isOffloading(OffloadKind OKind) const {\n    return isHostOffloading(OKind) || isDeviceOffloading(OKind);\n  }\n}",
  "id": "BLOCK-CPP-17681",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/Action.h",
  "source_line": 47,
  "validation_status": "validated"
}