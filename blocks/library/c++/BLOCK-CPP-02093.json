{
  "code": "{\n  // Delicate annotation dance.\n  // We are currently inside of read/write lock/unlock operation.\n  // All memory accesses are ignored inside of mutex operations + for unlock\n  // operation tsan considers that we've already released the mutex.\n  bool res = false;\n#ifdef ABSL_INTERNAL_HAVE_TSAN_INTERFACE\n  const uint32_t flags = read_lock ? __tsan_mutex_read_lock : 0;\n  const uint32_t tryflags = flags | (trylock ? __tsan_mutex_try_lock : 0);\n#endif\n  if (locking) {\n    // For lock we pretend that we have finished the operation,\n    // evaluate the predicate, then unlock the mutex and start locking it again\n    // to match the annotation at the end of outer lock operation.\n    // Note: we can't simply do POST_LOCK, Eval, PRE_LOCK, because then tsan\n    // will think the lock acquisition is recursive which will trigger\n    // deadlock detector.\n    ABSL_TSAN_MUTEX_POST_LOCK(mu, tryflags, 0);\n    res = cond->Eval();\n    // There is no \"try\" version of Unlock, so use flags instead of tryflags.\n    ABSL_TSAN_MUTEX_PRE_UNLOCK(mu, flags);\n    ABSL_TSAN_MUTEX_POST_UNLOCK(mu, flags);\n    ABSL_TSAN_MUTEX_PRE_LOCK(mu, tryflags);\n  } else {\n    // Similarly, for unlock we pretend that we have unlocked the mutex,\n    // lock the mutex, evaluate the predicate, and start unlocking it again\n    // to match the annotation at the end of outer unlock operation.\n    ABSL_TSAN_MUTEX_POST_UNLOCK(mu, flags);\n    ABSL_TSAN_MUTEX_PRE_LOCK(mu, flags);\n    ABSL_TSAN_MUTEX_POST_LOCK(mu, flags, 0);\n    res = cond->Eval();\n    ABSL_TSAN_MUTEX_PRE_UNLOCK(mu, flags);\n  }\n  // Prevent unused param warnings in non-TSAN builds.\n  static_cast<void>(mu);\n  static_cast<void>(trylock);\n  static_cast<void>(read_lock);\n  return res;\n}",
  "id": "BLOCK-CPP-02093",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/mutex.cc",
  "source_line": 1828,
  "validation_status": "validated"
}