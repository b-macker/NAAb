{
  "code": "#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-22359_execute() {\n    {\n\nclass AnalyzerOptions;\n\nnamespace ento {\n\nclass CheckerManager;\n\n/// Initialization functions perform any necessary setup for a checker.\n/// They should include a call to CheckerManager::registerChecker.\nusing RegisterCheckerFn = void (*)(CheckerManager &);\nusing ShouldRegisterFunction = bool (*)(const CheckerManager &);\n\n/// Specifies a command line option. It may either belong to a checker or a\n/// package.\nstruct CmdLineOption {\n  StringRef OptionType;\n  StringRef OptionName;\n  StringRef DefaultValStr;\n  StringRef Description;\n  StringRef DevelopmentStatus;\n  bool IsHidden;\n\n  CmdLineOption(StringRef OptionType, StringRef OptionName,\n                StringRef DefaultValStr, StringRef Description,\n                StringRef DevelopmentStatus, bool IsHidden)\n      : OptionType(OptionType), OptionName(OptionName),\n        DefaultValStr(DefaultValStr), Description(Description),\n        DevelopmentStatus(DevelopmentStatus), IsHidden(IsHidden) {\n\n    assert((OptionType == \"bool\" || OptionType == \"string\" ||\n            OptionType == \"int\") &&\n           \"Unknown command line option type!\");\n\n    assert((OptionType != \"bool\" ||\n            (DefaultValStr == \"true\" || DefaultValStr == \"false\")) &&\n           \"Invalid value for boolean command line option! Maybe incorrect \"\n           \"parameters to the addCheckerOption or addPackageOption method?\");\n\n    int Tmp;\n    assert((OptionType != \"int\" || !DefaultValStr.getAsInteger(0, Tmp)) &&\n           \"Invalid value for integer command line option! Maybe incorrect \"\n           \"parameters to the addCheckerOption or addPackageOption method?\");\n    (void)Tmp;\n\n    assert((DevelopmentStatus == \"alpha\" || DevelopmentStatus == \"beta\" ||\n            DevelopmentStatus == \"released\") &&\n           \"Invalid development status!\");\n  }\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dumpToStream(llvm::raw_ostream &Out) const;\n};\n\nusing CmdLineOptionList = llvm::SmallVector<CmdLineOption, 0>;\n\nstruct CheckerInfo;\n\nusing CheckerInfoList = std::vector<CheckerInfo>;\nusing CheckerInfoListRange = llvm::iterator_range<CheckerInfoList::iterator>;\nusing ConstCheckerInfoList = llvm::SmallVector<const CheckerInfo *, 0>;\nusing CheckerInfoSet = llvm::SetVector<const CheckerInfo *>;\n\n/// Specifies a checker. Note that this isn't what we call a checker object,\n/// it merely contains everything required to create one.\nstruct CheckerInfo {\n  enum class StateFromCmdLine {\n    // This checker wasn't explicitly enabled or disabled.\n    State_Unspecified,\n    // This checker was explicitly disabled.\n    State_Disabled,\n    // This checker was explicitly enabled.\n    State_Enabled\n  };\n\n  RegisterCheckerFn Initialize = nullptr;\n  ShouldRegisterFunction ShouldRegister = nullptr;\n  StringRef FullName;\n  StringRef Desc;\n  StringRef DocumentationUri;\n  CmdLineOptionList CmdLineOptions;\n  bool IsHidden = false;\n  StateFromCmdLine State = StateFromCmdLine::State_Unspecified;\n\n  ConstCheckerInfoList Dependencies;\n  ConstCheckerInfoList WeakDependencies;\n\n  bool isEnabled(const CheckerManager &mgr) const {\n    return State == StateFromCmdLine::State_Enabled && ShouldRegister(mgr);\n  }\n\n  bool isDisabled(const CheckerManager &mgr) const {\n    return State == StateFromCmdLine::State_Disabled || !ShouldRegister(mgr);\n  }\n\n  // Since each checker must have a different full name, we can identify\n  // CheckerInfo objects by them.\n  bool operator==(const CheckerInfo &Rhs) const {\n    return FullName == Rhs.FullName;\n  }\n\n  CheckerInfo(RegisterCheckerFn Fn, ShouldRegisterFunction sfn, StringRef Name,\n              StringRef Desc, StringRef DocsUri, bool IsHidden)\n      : Initialize(Fn), ShouldRegister(sfn), FullName(Name), Desc(Desc),\n        DocumentationUri(DocsUri), IsHidden(IsHidden) {}\n\n  // Used for lower_bound.\n  explicit CheckerInfo(StringRef FullName) : FullName(FullName) {}\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dumpToStream(llvm::raw_ostream &Out) const;\n};\n\nusing StateFromCmdLine = CheckerInfo::StateFromCmdLine;\n\n/// Specifies a package. Each package option is implicitly an option for all\n/// checkers within the package.\nstruct PackageInfo {\n  StringRef FullName;\n  CmdLineOptionList CmdLineOptions;\n\n  // Since each package must have a different full name, we can identify\n  // CheckerInfo objects by them.\n  bool operator==(const PackageInfo &Rhs) const {\n    return FullName == Rhs.FullName;\n  }\n\n  explicit PackageInfo(StringRef FullName) : FullName(FullName) {}\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dumpToStream(llvm::raw_ostream &Out) const;\n};\n\nusing PackageInfoList = llvm::SmallVector<PackageInfo, 0>;\n\nnamespace checker_registry {\n\ntemplate <class T> struct FullNameLT {\n  bool operator()(const T &Lhs, const T &Rhs) {\n    return Lhs.FullName < Rhs.FullName;\n  }\n};\n\nusing PackageNameLT = FullNameLT<PackageInfo>;\nusing CheckerNameLT = FullNameLT<CheckerInfo>;\n\ntemplate <class CheckerOrPackageInfoList>\nstd::conditional_t<std::is_const<CheckerOrPackageInfoList>::value,\n                   typename CheckerOrPackageInfoList::const_iterator,\n                   typename CheckerOrPackageInfoList::iterator>\nbinaryFind(CheckerOrPackageInfoList &Collection, StringRef FullName) {\n\n  using CheckerOrPackage = typename CheckerOrPackageInfoList::value_type;\n  using CheckerOrPackageFullNameLT = FullNameLT<CheckerOrPackage>;\n\n  assert(llvm::is_sorted(Collection, CheckerOrPackageFullNameLT{}) &&\n         \"In order to efficiently gather checkers/packages, this function \"\n         \"expects them to be already sorted!\");\n\n  return llvm::lower_bound(Collection, CheckerOrPackage(FullName),\n                           CheckerOrPackageFullNameLT{});\n}\n} // namespace checker_registry\n\nstruct CheckerRegistryData {\npublic:\n  CheckerInfoSet EnabledCheckers;\n\n  CheckerInfoList Checkers;\n  PackageInfoList Packages;\n  /// Used for counting how many checkers belong to a certain package in the\n  /// \\c Checkers field. For convenience purposes.\n  llvm::StringMap<size_t> PackageSizes;\n\n  /// Contains all (FullName, CmdLineOption) pairs. Similarly to dependencies,\n  /// we only modify the actual CheckerInfo and PackageInfo objects once all\n  /// of them have been added.\n  llvm::SmallVector<std::pair<StringRef, CmdLineOption>, 0> PackageOptions;\n  llvm::SmallVector<std::pair<StringRef, CmdLineOption>, 0> CheckerOptions;\n\n  llvm::SmallVector<std::pair<StringRef, StringRef>, 0> Dependencies;\n  llvm::SmallVector<std::pair<StringRef, StringRef>, 0> WeakDependencies;\n\n  CheckerInfoListRange getMutableCheckersForCmdLineArg(StringRef CmdLineArg);\n\n  /// Prints the name and description of all checkers in this registry.\n  /// This output is not intended to be machine-parseable.\n  void printCheckerWithDescList(const AnalyzerOptions &AnOpts, raw_ostream &Out,\n                                size_t MaxNameChars = 30) const;\n  void printEnabledCheckerList(raw_ostream &Out) const;\n  void printCheckerOptionList(const AnalyzerOptions &AnOpts,\n                              raw_ostream &Out) const;\n};\n\n} // namespace ento\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-22359",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h",
  "source_line": 29,
  "validation_status": "validated"
}