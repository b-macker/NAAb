{
  "code": "{\n  void anchor() override;\n\nprotected:\n  CXXMethodDecl(Kind DK, ASTContext &C, CXXRecordDecl *RD,\n                SourceLocation StartLoc, const DeclarationNameInfo &NameInfo,\n                QualType T, TypeSourceInfo *TInfo, StorageClass SC,\n                bool UsesFPIntrin, bool isInline,\n                ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n                Expr *TrailingRequiresClause = nullptr)\n      : FunctionDecl(DK, C, RD, StartLoc, NameInfo, T, TInfo, SC, UsesFPIntrin,\n                     isInline, ConstexprKind, TrailingRequiresClause) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n  }\n\npublic:\n  static CXXMethodDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         StorageClass SC, bool UsesFPIntrin, bool isInline,\n         ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n         Expr *TrailingRequiresClause = nullptr);\n\n  static CXXMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  bool isStatic() const;\n  bool isInstance() const { return !isStatic(); }\n\n  /// Returns true if the given operator is implicitly static in a record\n  /// context.\n  static bool isStaticOverloadedOperator(OverloadedOperatorKind OOK) {\n    // [class.free]p1:\n    // Any allocation function for a class T is a static member\n    // (even if not explicitly declared static).\n    // [class.free]p6 Any deallocation function for a class X is a static member\n    // (even if not explicitly declared static).\n    return OOK == OO_New || OOK == OO_Array_New || OOK == OO_Delete ||\n           OOK == OO_Array_Delete;\n  }\n\n  bool isConst() const { return getType()->castAs<FunctionType>()->isConst(); }\n  bool isVolatile() const { return getType()->castAs<FunctionType>()->isVolatile(); }\n\n  bool isVirtual() const {\n    CXXMethodDecl *CD = const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n\n    // Member function is virtual if it is marked explicitly so, or if it is\n    // declared in __interface -- then it is automatically pure virtual.\n    if (CD->isVirtualAsWritten() || CD->isPure())\n      return true;\n\n    return CD->size_overridden_methods() != 0;\n  }\n\n  /// If it's possible to devirtualize a call to this method, return the called\n  /// function. Otherwise, return null.\n\n  /// \\param Base The object on which this virtual function is called.\n  /// \\param IsAppleKext True if we are compiling for Apple kext.\n  CXXMethodDecl *getDevirtualizedMethod(const Expr *Base, bool IsAppleKext);\n\n  const CXXMethodDecl *getDevirtualizedMethod(const Expr *Base,\n                                              bool IsAppleKext) const {\n    return const_cast<CXXMethodDecl *>(this)->getDevirtualizedMethod(\n        Base, IsAppleKext);\n  }\n\n  /// Determine whether this is a usual deallocation function (C++\n  /// [basic.stc.dynamic.deallocation]p2), which is an overloaded delete or\n  /// delete[] operator with a particular signature. Populates \\p PreventedBy\n  /// with the declarations of the functions of the same kind if they were the\n  /// reason for this function returning false. This is used by\n  /// Sema::isUsualDeallocationFunction to reconsider the answer based on the\n  /// context.\n  bool isUsualDeallocationFunction(\n      SmallVectorImpl<const FunctionDecl *> &PreventedBy) const;\n\n  /// Determine whether this is a copy-assignment operator, regardless\n  /// of whether it was declared implicitly or explicitly.\n  bool isCopyAssignmentOperator() const;\n\n  /// Determine whether this is a move assignment operator.\n  bool isMoveAssignmentOperator() const;\n\n  CXXMethodDecl *getCanonicalDecl() override {\n    return cast<CXXMethodDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXMethodDecl *getCanonicalDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXMethodDecl *getMostRecentDecl() {\n    return cast<CXXMethodDecl>(\n            static_cast<FunctionDecl *>(this)->getMostRecentDecl());\n  }\n  const CXXMethodDecl *getMostRecentDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getMostRecentDecl();\n  }\n\n  void addOverriddenMethod(const CXXMethodDecl *MD);\n\n  using method_iterator = const CXXMethodDecl *const *;\n\n  method_iterator begin_overridden_methods() const;\n  method_iterator end_overridden_methods() const;\n  unsigned size_overridden_methods() const;\n\n  using overridden_method_range = llvm::iterator_range<\n      llvm::TinyPtrVector<const CXXMethodDecl *>::const_iterator>;\n\n  overridden_method_range overridden_methods() const;\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(FunctionDecl::getParent());\n  }\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  CXXRecordDecl *getParent() {\n    return const_cast<CXXRecordDecl *>(\n             cast<CXXRecordDecl>(FunctionDecl::getParent()));\n  }\n\n  /// Return the type of the \\c this pointer.\n  ///\n  /// Should only be called for instance (i.e., non-static) methods. Note\n  /// that for the call operator of a lambda closure type, this returns the\n  /// desugared 'this' type (a pointer to the closure type), not the captured\n  /// 'this' type.\n  QualType getThisType() const;\n\n  /// Return the type of the object pointed by \\c this.\n  ///\n  /// See getThisType() for usage restriction.\n  QualType getThisObjectType() const;\n\n  static QualType getThisType(const FunctionProtoType *FPT,\n                              const CXXRecordDecl *Decl);\n\n  static QualType getThisObjectType(const FunctionProtoType *FPT,\n                                    const CXXRecordDecl *Decl);\n\n  Qualifiers getMethodQualifiers() const {\n    return getType()->castAs<FunctionProtoType>()->getMethodQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this method.\n  ///\n  /// In the following example, \\c f() has an lvalue ref-qualifier, \\c g()\n  /// has an rvalue ref-qualifier, and \\c h() has no ref-qualifier.\n  /// @code\n  /// struct X {\n  ///   void f() &;\n  ///   void g() &&;\n  ///   void h();\n  /// };\n  /// @endcode\n  RefQualifierKind getRefQualifier() const {\n    return getType()->castAs<FunctionProtoType>()->getRefQualifier();\n  }\n\n  bool hasInlineBody() const;\n\n  /// Determine whether this is a lambda closure type's static member\n  /// function that is used for the result of the lambda's conversion to\n  /// function pointer (for a lambda with no captures).\n  ///\n  /// The function itself, if used, will have a placeholder body that will be\n  /// supplied by IR generation to either forward to the function call operator\n  /// or clone the function call operator.\n  bool isLambdaStaticInvoker() const;\n\n  /// Find the method in \\p RD that corresponds to this one.\n  ///\n  /// Find if \\p RD or one of the classes it inherits from override this method.\n  /// If so, return it. \\p RD is assumed to be a subclass of the class defining\n  /// this method (or be the class itself), unless \\p MayBeBase is set to true.\n  CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false);\n\n  const CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n              ->getCorrespondingMethodInClass(RD, MayBeBase);\n  }\n\n  /// Find if \\p RD declares a function that overrides this function, and if so,\n  /// return it. Does not search base classes.\n  CXXMethodDecl *getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                                       bool MayBeBase = false);\n  const CXXMethodDecl *\n  getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                        bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n        ->getCorrespondingMethodDeclaredInClass(RD, MayBeBase);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXMethod && K <= lastCXXMethod;\n  }\n}",
  "id": "BLOCK-CPP-08703",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 2035,
  "validation_status": "validated"
}