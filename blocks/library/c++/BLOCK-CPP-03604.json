{
  "code": "{\n\n// Overloads of `AbslParseFlag()` and `AbslUnparseFlag()` for fundamental types.\nbool AbslParseFlag(absl::string_view, bool*, std::string*);\nbool AbslParseFlag(absl::string_view, short*, std::string*);           // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned short*, std::string*);  // NOLINT\nbool AbslParseFlag(absl::string_view, int*, std::string*);             // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned int*, std::string*);    // NOLINT\nbool AbslParseFlag(absl::string_view, long*, std::string*);            // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned long*, std::string*);   // NOLINT\nbool AbslParseFlag(absl::string_view, long long*, std::string*);       // NOLINT\nbool AbslParseFlag(absl::string_view, unsigned long long*,             // NOLINT\n                   std::string*);\nbool AbslParseFlag(absl::string_view, absl::int128*, std::string*);    // NOLINT\nbool AbslParseFlag(absl::string_view, absl::uint128*, std::string*);   // NOLINT\nbool AbslParseFlag(absl::string_view, float*, std::string*);\nbool AbslParseFlag(absl::string_view, double*, std::string*);\nbool AbslParseFlag(absl::string_view, std::string*, std::string*);\nbool AbslParseFlag(absl::string_view, std::vector<std::string>*, std::string*);\n\ntemplate <typename T>\nbool AbslParseFlag(absl::string_view text, absl::optional<T>* f,\n                   std::string* err) {\n  if (text.empty()) {\n    *f = absl::nullopt;\n    return true;\n  }\n  T value;\n  if (!absl::ParseFlag(text, &value, err)) return false;\n\n  *f = std::move(value);\n  return true;\n}\n\n#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)\ntemplate <typename T>\nbool AbslParseFlag(absl::string_view text, std::optional<T>* f,\n                   std::string* err) {\n  if (text.empty()) {\n    *f = std::nullopt;\n    return true;\n  }\n  T value;\n  if (!absl::ParseFlag(text, &value, err)) return false;\n\n  *f = std::move(value);\n  return true;\n}\n#endif\n\ntemplate <typename T>\nbool InvokeParseFlag(absl::string_view input, T* dst, std::string* err) {\n  // Comment on next line provides a good compiler error message if T\n  // does not have AbslParseFlag(absl::string_view, T*, std::string*).\n  return AbslParseFlag(input, dst, err);  // Is T missing AbslParseFlag?\n}\n\n// Strings and std:: containers do not have the same overload resolution\n// considerations as fundamental types. Naming these 'AbslUnparseFlag' means we\n// can avoid the need for additional specializations of Unparse (below).\nstd::string AbslUnparseFlag(absl::string_view v);\nstd::string AbslUnparseFlag(const std::vector<std::string>&);\n\ntemplate <typename T>\nstd::string AbslUnparseFlag(const absl::optional<T>& f) {\n  return f.has_value() ? absl::UnparseFlag(*f) : \"\";\n}\n\n#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)\ntemplate <typename T>\nstd::string AbslUnparseFlag(const std::optional<T>& f) {\n  return f.has_value() ? absl::UnparseFlag(*f) : \"\";\n}\n#endif\n\ntemplate <typename T>\nstd::string Unparse(const T& v) {\n  // Comment on next line provides a good compiler error message if T does not\n  // have UnparseFlag.\n  return AbslUnparseFlag(v);  // Is T missing AbslUnparseFlag?\n}\n\n// Overloads for builtin types.\nstd::string Unparse(bool v);\nstd::string Unparse(short v);               // NOLINT\nstd::string Unparse(unsigned short v);      // NOLINT\nstd::string Unparse(int v);                 // NOLINT\nstd::string Unparse(unsigned int v);        // NOLINT\nstd::string Unparse(long v);                // NOLINT\nstd::string Unparse(unsigned long v);       // NOLINT\nstd::string Unparse(long long v);           // NOLINT\nstd::string Unparse(unsigned long long v);  // NOLINT\nstd::string Unparse(absl::int128 v);\nstd::string Unparse(absl::uint128 v);\nstd::string Unparse(float v);\nstd::string Unparse(double v);\n\n}",
  "id": "BLOCK-CPP-03604",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/marshalling.h",
  "source_line": 224,
  "validation_status": "validated"
}