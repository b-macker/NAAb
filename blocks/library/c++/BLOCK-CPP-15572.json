{
  "code": "{\npublic:\n  //===--------------------------------------------------------------------===//\n  // CFG Construction & Manipulation.\n  //===--------------------------------------------------------------------===//\n\n  class BuildOptions {\n    std::bitset<Stmt::lastStmtConstant> alwaysAddMask;\n\n  public:\n    using ForcedBlkExprs = llvm::DenseMap<const Stmt *, const CFGBlock *>;\n\n    ForcedBlkExprs **forcedBlkExprs = nullptr;\n    CFGCallback *Observer = nullptr;\n    bool PruneTriviallyFalseEdges = true;\n    bool AddEHEdges = false;\n    bool AddInitializers = false;\n    bool AddImplicitDtors = false;\n    bool AddLifetime = false;\n    bool AddLoopExit = false;\n    bool AddTemporaryDtors = false;\n    bool AddScopes = false;\n    bool AddStaticInitBranches = false;\n    bool AddCXXNewAllocator = false;\n    bool AddCXXDefaultInitExprInCtors = false;\n    bool AddCXXDefaultInitExprInAggregates = false;\n    bool AddRichCXXConstructors = false;\n    bool MarkElidedCXXConstructors = false;\n    bool AddVirtualBaseBranches = false;\n    bool OmitImplicitValueInitializers = false;\n\n    BuildOptions() = default;\n\n    bool alwaysAdd(const Stmt *stmt) const {\n      return alwaysAddMask[stmt->getStmtClass()];\n    }\n\n    BuildOptions &setAlwaysAdd(Stmt::StmtClass stmtClass, bool val = true) {\n      alwaysAddMask[stmtClass] = val;\n      return *this;\n    }\n\n    BuildOptions &setAllAlwaysAdd() {\n      alwaysAddMask.set();\n      return *this;\n    }\n  };\n\n  /// Builds a CFG from an AST.\n  static std::unique_ptr<CFG> buildCFG(const Decl *D, Stmt *AST, ASTContext *C,\n                                       const BuildOptions &BO);\n\n  /// Create a new block in the CFG. The CFG owns the block; the caller should\n  /// not directly free it.\n  CFGBlock *createBlock();\n\n  /// Set the entry block of the CFG. This is typically used only during CFG\n  /// construction. Most CFG clients expect that the entry block has no\n  /// predecessors and contains no statements.\n  void setEntry(CFGBlock *B) { Entry = B; }\n\n  /// Set the block used for indirect goto jumps. This is typically used only\n  /// during CFG construction.\n  void setIndirectGotoBlock(CFGBlock *B) { IndirectGotoBlock = B; }\n\n  //===--------------------------------------------------------------------===//\n  // Block Iterators\n  //===--------------------------------------------------------------------===//\n\n  using CFGBlockListTy = BumpVector<CFGBlock *>;\n  using iterator = CFGBlockListTy::iterator;\n  using const_iterator = CFGBlockListTy::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  CFGBlock &                front()                { return *Blocks.front(); }\n  CFGBlock &                back()                 { return *Blocks.back(); }\n\n  iterator                  begin()                { return Blocks.begin(); }\n  iterator                  end()                  { return Blocks.end(); }\n  const_iterator            begin()       const    { return Blocks.begin(); }\n  const_iterator            end()         const    { return Blocks.end(); }\n\n  iterator nodes_begin() { return iterator(Blocks.begin()); }\n  iterator nodes_end() { return iterator(Blocks.end()); }\n\n  llvm::iterator_range<iterator> nodes() { return {begin(), end()}; }\n  llvm::iterator_range<const_iterator> const_nodes() const {\n    return {begin(), end()};\n  }\n\n  const_iterator nodes_begin() const { return const_iterator(Blocks.begin()); }\n  const_iterator nodes_end() const { return const_iterator(Blocks.end()); }\n\n  reverse_iterator          rbegin()               { return Blocks.rbegin(); }\n  reverse_iterator          rend()                 { return Blocks.rend(); }\n  const_reverse_iterator    rbegin()      const    { return Blocks.rbegin(); }\n  const_reverse_iterator    rend()        const    { return Blocks.rend(); }\n\n  llvm::iterator_range<reverse_iterator> reverse_nodes() {\n    return {rbegin(), rend()};\n  }\n  llvm::iterator_range<const_reverse_iterator> const_reverse_nodes() const {\n    return {rbegin(), rend()};\n  }\n\n  CFGBlock &                getEntry()             { return *Entry; }\n  const CFGBlock &          getEntry()    const    { return *Entry; }\n  CFGBlock &                getExit()              { return *Exit; }\n  const CFGBlock &          getExit()     const    { return *Exit; }\n\n  CFGBlock *       getIndirectGotoBlock() { return IndirectGotoBlock; }\n  const CFGBlock * getIndirectGotoBlock() const { return IndirectGotoBlock; }\n\n  using try_block_iterator = std::vector<const CFGBlock *>::const_iterator;\n  using try_block_range = llvm::iterator_range<try_block_iterator>;\n\n  try_block_iterator try_blocks_begin() const {\n    return TryDispatchBlocks.begin();\n  }\n\n  try_block_iterator try_blocks_end() const {\n    return TryDispatchBlocks.end();\n  }\n\n  try_block_range try_blocks() const {\n    return try_block_range(try_blocks_begin(), try_blocks_end());\n  }\n\n  void addTryDispatchBlock(const CFGBlock *block) {\n    TryDispatchBlocks.push_back(block);\n  }\n\n  /// Records a synthetic DeclStmt and the DeclStmt it was constructed from.\n  ///\n  /// The CFG uses synthetic DeclStmts when a single AST DeclStmt contains\n  /// multiple decls.\n  void addSyntheticDeclStmt(const DeclStmt *Synthetic,\n                            const DeclStmt *Source) {\n    assert(Synthetic->isSingleDecl() && \"Can handle single declarations only\");\n    assert(Synthetic != Source && \"Don't include original DeclStmts in map\");\n    assert(!SyntheticDeclStmts.count(Synthetic) && \"Already in map\");\n    SyntheticDeclStmts[Synthetic] = Source;\n  }\n\n  using synthetic_stmt_iterator =\n      llvm::DenseMap<const DeclStmt *, const DeclStmt *>::const_iterator;\n  using synthetic_stmt_range = llvm::iterator_range<synthetic_stmt_iterator>;\n\n  /// Iterates over synthetic DeclStmts in the CFG.\n  ///\n  /// Each element is a (synthetic statement, source statement) pair.\n  ///\n  /// \\sa addSyntheticDeclStmt\n  synthetic_stmt_iterator synthetic_stmt_begin() const {\n    return SyntheticDeclStmts.begin();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_iterator synthetic_stmt_end() const {\n    return SyntheticDeclStmts.end();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_range synthetic_stmts() const {\n    return synthetic_stmt_range(synthetic_stmt_begin(), synthetic_stmt_end());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Member templates useful for various batch operations over CFGs.\n  //===--------------------------------------------------------------------===//\n\n  template <typename Callback> void VisitBlockStmts(Callback &O) const {\n    for (const_iterator I = begin(), E = end(); I != E; ++I)\n      for (CFGBlock::const_iterator BI = (*I)->begin(), BE = (*I)->end();\n           BI != BE; ++BI) {\n        if (std::optional<CFGStmt> stmt = BI->getAs<CFGStmt>())\n          O(const_cast<Stmt *>(stmt->getStmt()));\n      }\n  }\n\n  //===--------------------------------------------------------------------===//\n  // CFG Introspection.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the total number of BlockIDs allocated (which start at 0).\n  unsigned getNumBlockIDs() const { return NumBlockIDs; }\n\n  /// Return the total number of CFGBlocks within the CFG This is simply a\n  /// renaming of the getNumBlockIDs(). This is necessary because the dominator\n  /// implementation needs such an interface.\n  unsigned size() const { return NumBlockIDs; }\n\n  /// Returns true if the CFG has no branches. Usually it boils down to the CFG\n  /// having exactly three blocks (entry, the actual code, exit), but sometimes\n  /// more blocks appear due to having control flow that can be fully\n  /// resolved in compile time.\n  bool isLinear() const;\n\n  //===--------------------------------------------------------------------===//\n  // CFG Debugging: Pretty-Printing and Visualization.\n  //===--------------------------------------------------------------------===//\n\n  void viewCFG(const LangOptions &LO) const;\n  void print(raw_ostream &OS, const LangOptions &LO, bool ShowColors) const;\n  void dump(const LangOptions &LO, bool ShowColors) const;\n\n  //===--------------------------------------------------------------------===//\n  // Internal: constructors and data.\n  //===--------------------------------------------------------------------===//\n\n  CFG() : Blocks(BlkBVC, 10) {}\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return BlkBVC.getAllocator();\n  }\n\n  BumpVectorContext &getBumpVectorContext() {\n    return BlkBVC;\n  }\n\nprivate:\n  CFGBlock *Entry = nullptr;\n  CFGBlock *Exit = nullptr;\n\n  // Special block to contain collective dispatch for indirect gotos\n  CFGBlock* IndirectGotoBlock = nullptr;\n\n  unsigned  NumBlockIDs = 0;\n\n  BumpVectorContext BlkBVC;\n\n  CFGBlockListTy Blocks;\n\n  /// C++ 'try' statements are modeled with an indirect dispatch block.\n  /// This is the collection of such blocks present in the CFG.\n  std::vector<const CFGBlock *> TryDispatchBlocks;\n\n  /// Collects DeclStmts synthesized for this CFG and maps each one back to its\n  /// source DeclStmt.\n  llvm::DenseMap<const DeclStmt *, const DeclStmt *> SyntheticDeclStmts;\n}",
  "id": "BLOCK-CPP-15572",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CFG.h",
  "source_line": 1178,
  "validation_status": "validated"
}