{
  "code": "#include \"absl/synchronization/mutex.h\"\n#include <windows.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <sched.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <algorithm>\n#include <atomic>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <thread>  // NOLINT(build/c++11)\n#include \"absl/base/attributes.h\"\n#include \"absl/base/call_once.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/dynamic_annotations.h\"\n#include \"absl/base/internal/atomic_hook.h\"\n#include \"absl/base/internal/cycleclock.h\"\n#include \"absl/base/internal/hide_ptr.h\"\n#include \"absl/base/internal/low_level_alloc.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/internal/spinlock.h\"\n#include \"absl/base/internal/sysinfo.h\"\n#include \"absl/base/internal/thread_identity.h\"\n#include \"absl/base/internal/tsan_mutex_interface.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/debugging/stacktrace.h\"\n#include \"absl/debugging/symbolize.h\"\n#include \"absl/synchronization/internal/graphcycles.h\"\n#include \"absl/synchronization/internal/per_thread_sem.h\"\n#include \"absl/time/time.h\"\n\nusing namespace absl;\nusing namespace synchronization_internal;\nusing namespace synchronization_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02104_execute() {\n    {\n  // This thread might be transferred to the Mutex queue by Fer() when\n  // we are woken.  To make sure that is what happens, Enqueue() doesn't\n  // call CondVarEnqueue() again but instead uses its normal code.  We\n  // must do this before we queue ourselves so that cv_word will be null\n  // when seen by the dequeuer, who may wish immediately to requeue\n  // this thread on another queue.\n  std::atomic<intptr_t>* cv_word = waitp->cv_word;\n  waitp->cv_word = nullptr;\n\n  intptr_t v = cv_word->load(std::memory_order_relaxed);\n  int c = 0;\n  while ((v & kCvSpin) != 0 ||  // acquire spinlock\n         !cv_word->compare_exchange_weak(v, v | kCvSpin,\n                                         std::memory_order_acquire,\n                                         std::memory_order_relaxed)) {\n    c = synchronization_internal::MutexDelay(c, GENTLE);\n    v = cv_word->load(std::memory_order_relaxed);\n  }\n  ABSL_RAW_CHECK(waitp->thread->waitp == nullptr, \"waiting when shouldn't be\");\n  waitp->thread->waitp = waitp;  // prepare ourselves for waiting\n  PerThreadSynch* h = reinterpret_cast<PerThreadSynch*>(v & ~kCvLow);\n  if (h == nullptr) {  // add this thread to waiter list\n    waitp->thread->next = waitp->thread;\n  } else {\n    waitp->thread->next = h->next;\n    h->next = waitp->thread;\n  }\n  waitp->thread->state.store(PerThreadSynch::kQueued,\n                             std::memory_order_relaxed);\n  cv_word->store((v & kCvEvent) | reinterpret_cast<intptr_t>(waitp->thread),\n                 std::memory_order_release);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02104",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/mutex.cc",
  "source_line": 2557,
  "validation_status": "validated"
}