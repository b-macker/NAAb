{
  "code": "#include <cmath>         // std::signbit\n#include <cstdint>       // uint32_t\n#include <cstring>       // std::memcpy\n#include <limits>        // std::numeric_limits\n#include <memory>        // std::uninitialized_copy\n#include <stdexcept>     // std::runtime_error\n#include <system_error>  // std::system_error\n#include \"core.h\"\n\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail;\nusing namespace detail_exported;\nusing namespace detail_exported;\nusing namespace dragonbox;\nusing namespace dragonbox;\nusing namespace digits;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01358_execute() {\n    {\n  const fp one(1ULL << -value.e, value.e);\n  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be\n  // zero because it contains a product of two 64-bit numbers with MSB set (due\n  // to normalization) - 1, shifted right by at most 60 bits.\n  auto integral = static_cast<uint32_t>(value.f >> -one.e);\n  FMT_ASSERT(integral != 0, \"\");\n  FMT_ASSERT(integral == value.f >> -one.e, \"\");\n  // The fractional part of scaled value (p2 in Grisu) c = value % one.\n  uint64_t fractional = value.f & (one.f - 1);\n  exp = count_digits(integral);  // kappa in Grisu.\n  // Non-fixed formats require at least one digit and no precision adjustment.\n  if (handler.fixed) {\n    adjust_precision(handler.precision, exp + handler.exp10);\n    // Check if precision is satisfied just by leading zeros, e.g.\n    // format(\"{:.2f}\", 0.001) gives \"0.00\" without generating any digits.\n    if (handler.precision <= 0) {\n      if (handler.precision < 0) return digits::done;\n      // Divide by 10 to prevent overflow.\n      uint64_t divisor = data::power_of_10_64[exp - 1] << -one.e;\n      auto dir = get_round_direction(divisor, value.f / 10, error * 10);\n      if (dir == round_direction::unknown) return digits::error;\n      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';\n      return digits::done;\n    }\n  }\n  // Generate digits for the integral part. This can produce up to 10 digits.\n  do {\n    uint32_t digit = 0;\n    auto divmod_integral = [&](uint32_t divisor) {\n      digit = integral / divisor;\n      integral %= divisor;\n    };\n    // This optimization by Milo Yip reduces the number of integer divisions by\n    // one per iteration.\n    switch (exp) {\n    case 10:\n      divmod_integral(1000000000);\n      break;\n    case 9:\n      divmod_integral(100000000);\n      break;\n    case 8:\n      divmod_integral(10000000);\n      break;\n    case 7:\n      divmod_integral(1000000);\n      break;\n    case 6:\n      divmod_integral(100000);\n      break;\n    case 5:\n      divmod_integral(10000);\n      break;\n    case 4:\n      divmod_integral(1000);\n      break;\n    case 3:\n      divmod_integral(100);\n      break;\n    case 2:\n      divmod_integral(10);\n      break;\n    case 1:\n      digit = integral;\n      integral = 0;\n      break;\n    default:\n      FMT_ASSERT(false, \"invalid number of digits\");\n    }\n    --exp;\n    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;\n    auto result = handler.on_digit(static_cast<char>('0' + digit),\n                                   data::power_of_10_64[exp] << -one.e,\n                                   remainder, error, true);\n    if (result != digits::more) return result;\n  } while (exp > 0);\n  // Generate digits for the fractional part.\n  for (;;) {\n    fractional *= 10;\n    error *= 10;\n    char digit = static_cast<char>('0' + (fractional >> -one.e));\n    fractional &= one.f - 1;\n    --exp;\n    auto result = handler.on_digit(digit, one.f, fractional, error, false);\n    if (result != digits::more) return result;\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01358",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 2615,
  "validation_status": "validated"
}