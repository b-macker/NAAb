{
  "code": "{\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n}",
  "id": "BLOCK-CPP-09388",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 2186,
  "validation_status": "validated"
}