{
  "code": "{\n  using OutputIt = buffer_appender<Char>;\n  auto out = OutputIt(buf);\n  auto context = basic_printf_context<OutputIt, Char>(out, args);\n  auto parse_ctx = basic_printf_parse_context<Char>(format);\n\n  // Returns the argument with specified index or, if arg_index is -1, the next\n  // argument.\n  auto get_arg = [&](int arg_index) {\n    if (arg_index < 0)\n      arg_index = parse_ctx.next_arg_id();\n    else\n      parse_ctx.check_arg_id(--arg_index);\n    return detail::get_arg(context, arg_index);\n  };\n\n  const Char* start = parse_ctx.begin();\n  const Char* end = parse_ctx.end();\n  auto it = start;\n  while (it != end) {\n    if (!detail::find<false, Char>(it, end, '%', it)) {\n      it = end;  // detail::find leaves it == nullptr if it doesn't find '%'\n      break;\n    }\n    Char c = *it++;\n    if (it != end && *it == c) {\n      out = detail::write(\n          out, basic_string_view<Char>(start, detail::to_unsigned(it - start)));\n      start = ++it;\n      continue;\n    }\n    out = detail::write(out, basic_string_view<Char>(\n                                 start, detail::to_unsigned(it - 1 - start)));\n\n    basic_format_specs<Char> specs;\n    specs.align = align::right;\n\n    // Parse argument index, flags and width.\n    int arg_index = parse_header(it, end, specs, get_arg);\n    if (arg_index == 0) parse_ctx.on_error(\"argument not found\");\n\n    // Parse precision.\n    if (it != end && *it == '.') {\n      ++it;\n      c = it != end ? *it : 0;\n      if ('0' <= c && c <= '9') {\n        specs.precision = parse_nonnegative_int(it, end, 0);\n      } else if (c == '*') {\n        ++it;\n        specs.precision = static_cast<int>(\n            visit_format_arg(detail::printf_precision_handler(), get_arg(-1)));\n      } else {\n        specs.precision = 0;\n      }\n    }\n\n    auto arg = get_arg(arg_index);\n    // For d, i, o, u, x, and X conversion specifiers, if a precision is\n    // specified, the '0' flag is ignored\n    if (specs.precision >= 0 && arg.is_integral())\n      specs.fill[0] =\n          ' ';  // Ignore '0' flag for non-numeric types or if '-' present.\n    if (specs.precision >= 0 && arg.type() == detail::type::cstring_type) {\n      auto str = visit_format_arg(detail::get_cstring<Char>(), arg);\n      auto str_end = str + specs.precision;\n      auto nul = std::find(str, str_end, Char());\n      arg = detail::make_arg<basic_printf_context<OutputIt, Char>>(\n          basic_string_view<Char>(\n              str, detail::to_unsigned(nul != str_end ? nul - str\n                                                      : specs.precision)));\n    }\n    if (specs.alt && visit_format_arg(detail::is_zero_int(), arg))\n      specs.alt = false;\n    if (specs.fill[0] == '0') {\n      if (arg.is_arithmetic() && specs.align != align::left)\n        specs.align = align::numeric;\n      else\n        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'\n                              // flag is also present.\n    }\n\n    // Parse length and convert the argument to the required type.\n    c = it != end ? *it++ : 0;\n    Char t = it != end ? *it : 0;\n    using detail::convert_arg;\n    switch (c) {\n    case 'h':\n      if (t == 'h') {\n        ++it;\n        t = it != end ? *it : 0;\n        convert_arg<signed char>(arg, t);\n      } else {\n        convert_arg<short>(arg, t);\n      }\n      break;\n    case 'l':\n      if (t == 'l') {\n        ++it;\n        t = it != end ? *it : 0;\n        convert_arg<long long>(arg, t);\n      } else {\n        convert_arg<long>(arg, t);\n      }\n      break;\n    case 'j':\n      convert_arg<intmax_t>(arg, t);\n      break;\n    case 'z':\n      convert_arg<size_t>(arg, t);\n      break;\n    case 't':\n      convert_arg<std::ptrdiff_t>(arg, t);\n      break;\n    case 'L':\n      // printf produces garbage when 'L' is omitted for long double, no\n      // need to do the same.\n      break;\n    default:\n      --it;\n      convert_arg<void>(arg, c);\n    }\n\n    // Parse type.\n    if (it == end) FMT_THROW(format_error(\"invalid format string\"));\n    char type = static_cast<char>(*it++);\n    if (arg.is_integral()) {\n      // Normalize type.\n      switch (type) {\n      case 'i':\n      case 'u':\n        type = 'd';\n        break;\n      case 'c':\n        visit_format_arg(\n            detail::char_converter<basic_printf_context<OutputIt, Char>>(arg),\n            arg);\n        break;\n      }\n    }\n    specs.type = parse_presentation_type(type);\n    if (specs.type == presentation_type::none)\n      parse_ctx.on_error(\"invalid type specifier\");\n\n    start = it;\n\n    // Format argument.\n    out = visit_format_arg(\n        detail::printf_arg_formatter<OutputIt, Char>(out, specs, context), arg);\n  }\n  detail::write(out, basic_string_view<Char>(start, to_unsigned(it - start)));\n}",
  "id": "BLOCK-CPP-01530",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/printf.h",
  "source_line": 368,
  "validation_status": "validated"
}