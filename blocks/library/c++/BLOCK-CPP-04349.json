{
  "code": "#include <sys/time.h>\n#include <chrono>  // NOLINT(build/c++11)\n#include <cmath>\n#include <cstdint>\n#include <ctime>\n#include <limits>\n#include <ostream>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/config.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/time/civil_time.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n\nusing namespace absl;\nusing namespace time_internal;\nusing namespace time_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-04349_execute() {\n    {\n      const uint64_t unsigned_value =\n          (static_cast<uint64_t>(hi_) << 32) | static_cast<uint64_t>(lo_);\n      // `static_cast<int64_t>(unsigned_value)` is implementation-defined\n      // before c++20. On all supported platforms the behaviour is that mandated\n      // by c++20, i.e. \"If the destination type is signed, [...] the result is\n      // the unique value of the destination type equal to the source value\n      // modulo 2^n, where n is the number of bits used to represent the\n      // destination type.\"\n      static_assert(\n          (static_cast<int64_t>((std::numeric_limits<uint64_t>::max)()) ==\n           int64_t{-1}) &&\n              (static_cast<int64_t>(static_cast<uint64_t>(\n                                        (std::numeric_limits<int64_t>::max)()) +\n                                    1) ==\n               (std::numeric_limits<int64_t>::min)()),\n          \"static_cast<int64_t>(uint64_t) does not have c++20 semantics\");\n      return static_cast<int64_t>(unsigned_value);\n    }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-04349",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/time.h",
  "source_line": 258,
  "validation_status": "validated"
}