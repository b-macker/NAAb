{
  "code": "{\n  void anchor() override;\n\nprotected:\n  // Construct a template decl with name, parameters, and templated element.\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params, NamedDecl *Decl);\n\n  // Construct a template decl with the given name and parameters.\n  // Used when there is no templated element (e.g., for tt-params).\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params)\n      : TemplateDecl(DK, DC, L, Name, Params, nullptr) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief Get the total constraint-expression associated with this template,\n  /// including constraint-expressions derived from the requires-clause,\n  /// trailing requires-clause (for functions and methods) and constrained\n  /// template parameters.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  /// Get the underlying, templated declaration.\n  NamedDecl *getTemplatedDecl() const { return TemplatedDecl; }\n\n  // Should a specialization behave like an alias for another type.\n  bool isTypeAlias() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstTemplate && K <= lastTemplate;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       TemplatedDecl->getSourceRange().getEnd());\n  }\n\nprotected:\n  NamedDecl *TemplatedDecl;\n  TemplateParameterList *TemplateParams;\n\npublic:\n  void setTemplateParameters(TemplateParameterList *TParams) {\n    TemplateParams = TParams;\n  }\n\n  /// Initialize the underlying templated declaration.\n  void init(NamedDecl *NewTemplatedDecl) {\n    if (TemplatedDecl)\n      assert(TemplatedDecl == NewTemplatedDecl && \"Inconsistent TemplatedDecl\");\n    else\n      TemplatedDecl = NewTemplatedDecl;\n  }\n}",
  "id": "BLOCK-CPP-09357",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 409,
  "validation_status": "validated"
}