{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// implicit_cast()\n//\n// Performs an implicit conversion between types following the language\n// rules for implicit conversion; if an implicit conversion is otherwise\n// allowed by the language in the given context, this function performs such an\n// implicit conversion.\n//\n// Example:\n//\n//   // If the context allows implicit conversion:\n//   From from;\n//   To to = from;\n//\n//   // Such code can be replaced by:\n//   implicit_cast<To>(from);\n//\n// An `implicit_cast()` may also be used to annotate numeric type conversions\n// that, although safe, may produce compiler warnings (such as `long` to `int`).\n// Additionally, an `implicit_cast()` is also useful within return statements to\n// indicate a specific implicit conversion is being undertaken.\n//\n// Example:\n//\n//   return implicit_cast<double>(size_in_bytes) / capacity_;\n//\n// Annotating code with `implicit_cast()` allows you to explicitly select\n// particular overloads and template instantiations, while providing a safer\n// cast than `reinterpret_cast()` or `static_cast()`.\n//\n// Additionally, an `implicit_cast()` can be used to allow upcasting within a\n// type hierarchy where incorrect use of `static_cast()` could accidentally\n// allow downcasting.\n//\n// Finally, an `implicit_cast()` can be used to perform implicit conversions\n// from unrelated types that otherwise couldn't be implicitly cast directly;\n// C++ will normally only implicitly cast \"one step\" in such conversions.\n//\n// That is, if C is a type which can be implicitly converted to B, with B being\n// a type that can be implicitly converted to A, an `implicit_cast()` can be\n// used to convert C to B (which the compiler can then implicitly convert to A\n// using language rules).\n//\n// Example:\n//\n//   // Assume an object C is convertible to B, which is implicitly convertible\n//   // to A\n//   A a = implicit_cast<B>(C);\n//\n// Such implicit cast chaining may be useful within template logic.\ntemplate <typename To>\nconstexpr To implicit_cast(typename absl::internal::type_identity_t<To> to) {\n  return to;\n}\n\n// bit_cast()\n//\n// Creates a value of the new type `Dest` whose representation is the same as\n// that of the argument, which is of (deduced) type `Source` (a \"bitwise cast\";\n// every bit in the value representation of the result is equal to the\n// corresponding bit in the object representation of the source). Source and\n// destination types must be of the same size, and both types must be trivially\n// copyable.\n//\n// As with most casts, use with caution. A `bit_cast()` might be needed when you\n// need to treat a value as the value of some other type, for example, to access\n// the individual bits of an object which are not normally accessible through\n// the object's type, such as for working with the binary representation of a\n// floating point value:\n//\n//   float f = 3.14159265358979;\n//   int i = bit_cast<int>(f);\n//   // i = 0x40490fdb\n//\n// Reinterpreting and accessing a value directly as a different type (as shown\n// below) usually results in undefined behavior.\n//\n// Example:\n//\n//   // WRONG\n//   float f = 3.14159265358979;\n//   int i = reinterpret_cast<int&>(f);    // Wrong\n//   int j = *reinterpret_cast<int*>(&f);  // Equally wrong\n//   int k = *bit_cast<int*>(&f);          // Equally wrong\n//\n// Reinterpret-casting results in undefined behavior according to the ISO C++\n// specification, section [basic.lval]. Roughly, this section says: if an object\n// in memory has one type, and a program accesses it with a different type, the\n// result is undefined behavior for most \"different type\".\n//\n// Using bit_cast on a pointer and then dereferencing it is no better than using\n// reinterpret_cast. You should only use bit_cast on the value itself.\n//\n// Such casting results in type punning: holding an object in memory of one type\n// and reading its bits back using a different type. A `bit_cast()` avoids this\n// issue by copying the object representation to a new value, which avoids\n// introducing this undefined behavior (since the original value is never\n// accessed in the wrong way).\n//\n// The requirements of `absl::bit_cast` are more strict than that of\n// `std::bit_cast` unless compiler support is available. Specifically, without\n// compiler support, this implementation also requires `Dest` to be\n// default-constructible. In C++20, `absl::bit_cast` is replaced by\n// `std::bit_cast`.\n#if defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806L\n\nusing std::bit_cast;\n\n#else  // defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806L\n\ntemplate <\n    typename Dest, typename Source,\n    typename std::enable_if<sizeof(Dest) == sizeof(Source) &&\n                                std::is_trivially_copyable<Source>::value &&\n                                std::is_trivially_copyable<Dest>::value\n#if !ABSL_HAVE_BUILTIN(__builtin_bit_cast)\n                                && std::is_default_constructible<Dest>::value\n#endif  // !ABSL_HAVE_BUILTIN(__builtin_bit_cast)\n                            ,\n                            int>::type = 0>\n#if ABSL_HAVE_BUILTIN(__builtin_bit_cast)\ninline constexpr Dest bit_cast(const Source& source) {\n  return __builtin_bit_cast(Dest, source);\n}\n#else  // ABSL_HAVE_BUILTIN(__builtin_bit_cast)\ninline Dest bit_cast(const Source& source) {\n  Dest dest;\n  memcpy(static_cast<void*>(std::addressof(dest)),\n         static_cast<const void*>(std::addressof(source)), sizeof(dest));\n  return dest;\n}\n#endif  // ABSL_HAVE_BUILTIN(__builtin_bit_cast)\n\n#endif  // defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806L\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03420",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/casts.h",
  "source_line": 40,
  "validation_status": "validated"
}