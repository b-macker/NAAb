{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace strings_internal {\n\n//\n// Formatter objects\n//\n// The following are implementation classes for standard Formatter objects. The\n// factory functions that users will call to create and use these formatters are\n// defined and documented in strings/join.h.\n//\n\n// The default formatter. Converts alpha-numeric types to strings.\nstruct AlphaNumFormatterImpl {\n  // This template is needed in order to support passing in a dereferenced\n  // vector<bool>::iterator\n  template <typename T>\n  void operator()(std::string* out, const T& t) const {\n    StrAppend(out, AlphaNum(t));\n  }\n\n  void operator()(std::string* out, const AlphaNum& t) const {\n    StrAppend(out, t);\n  }\n};\n\n// A type that's used to overload the JoinAlgorithm() function (defined below)\n// for ranges that do not require additional formatting (e.g., a range of\n// strings).\n\nstruct NoFormatter : public AlphaNumFormatterImpl {};\n\n// Formats types to strings using the << operator.\nclass StreamFormatterImpl {\n public:\n  // The method isn't const because it mutates state. Making it const will\n  // render StreamFormatterImpl thread-hostile.\n  template <typename T>\n  void operator()(std::string* out, const T& t) {\n    // The stream is created lazily to avoid paying the relatively high cost\n    // of its construction when joining an empty range.\n    if (strm_) {\n      strm_->clear();  // clear the bad, fail and eof bits in case they were set\n      strm_->str(out);\n    } else {\n      strm_.reset(new strings_internal::OStringStream(out));\n    }\n    *strm_ << t;\n  }\n\n private:\n  std::unique_ptr<strings_internal::OStringStream> strm_;\n};\n\n// Formats a std::pair<>. The 'first' member is formatted using f1_ and the\n// 'second' member is formatted using f2_. sep_ is the separator.\ntemplate <typename F1, typename F2>\nclass PairFormatterImpl {\n public:\n  PairFormatterImpl(F1 f1, absl::string_view sep, F2 f2)\n      : f1_(std::move(f1)), sep_(sep), f2_(std::move(f2)) {}\n\n  template <typename T>\n  void operator()(std::string* out, const T& p) {\n    f1_(out, p.first);\n    out->append(sep_);\n    f2_(out, p.second);\n  }\n\n  template <typename T>\n  void operator()(std::string* out, const T& p) const {\n    f1_(out, p.first);\n    out->append(sep_);\n    f2_(out, p.second);\n  }\n\n private:\n  F1 f1_;\n  std::string sep_;\n  F2 f2_;\n};\n\n// Wraps another formatter and dereferences the argument to operator() then\n// passes the dereferenced argument to the wrapped formatter. This can be\n// useful, for example, to join a std::vector<int*>.\ntemplate <typename Formatter>\nclass DereferenceFormatterImpl {\n public:\n  DereferenceFormatterImpl() : f_() {}\n  explicit DereferenceFormatterImpl(Formatter&& f)\n      : f_(std::forward<Formatter>(f)) {}\n\n  template <typename T>\n  void operator()(std::string* out, const T& t) {\n    f_(out, *t);\n  }\n\n  template <typename T>\n  void operator()(std::string* out, const T& t) const {\n    f_(out, *t);\n  }\n\n private:\n  Formatter f_;\n};\n\n// DefaultFormatter<T> is a traits class that selects a default Formatter to use\n// for the given type T. The ::Type member names the Formatter to use. This is\n// used by the strings::Join() functions that do NOT take a Formatter argument,\n// in which case a default Formatter must be chosen.\n//\n// AlphaNumFormatterImpl is the default in the base template, followed by\n// specializations for other types.\ntemplate <typename ValueType>\nstruct DefaultFormatter {\n  typedef AlphaNumFormatterImpl Type;\n};\ntemplate <>\nstruct DefaultFormatter<const char*> {\n  typedef AlphaNumFormatterImpl Type;\n};\ntemplate <>\nstruct DefaultFormatter<char*> {\n  typedef AlphaNumFormatterImpl Type;\n};\ntemplate <>\nstruct DefaultFormatter<std::string> {\n  typedef NoFormatter Type;\n};\ntemplate <>\nstruct DefaultFormatter<absl::string_view> {\n  typedef NoFormatter Type;\n};\ntemplate <typename ValueType>\nstruct DefaultFormatter<ValueType*> {\n  typedef DereferenceFormatterImpl<typename DefaultFormatter<ValueType>::Type>\n      Type;\n};\n\ntemplate <typename ValueType>\nstruct DefaultFormatter<std::unique_ptr<ValueType>>\n    : public DefaultFormatter<ValueType*> {};\n\n//\n// JoinAlgorithm() functions\n//\n\n// The main joining algorithm. This simply joins the elements in the given\n// iterator range, each separated by the given separator, into an output string,\n// and formats each element using the provided Formatter object.\ntemplate <typename Iterator, typename Formatter>\nstd::string JoinAlgorithm(Iterator start, Iterator end, absl::string_view s,\n                          Formatter&& f) {\n  std::string result;\n  absl::string_view sep(\"\");\n  for (Iterator it = start; it != end; ++it) {\n    result.append(sep.data(), sep.size());\n    f(&result, *it);\n    sep = s;\n  }\n  return result;\n}\n\n// A joining algorithm that's optimized for a forward iterator range of\n// string-like objects that do not need any additional formatting. This is to\n// optimize the common case of joining, say, a std::vector<string> or a\n// std::vector<absl::string_view>.\n//\n// This is an overload of the previous JoinAlgorithm() function. Here the\n// Formatter argument is of type NoFormatter. Since NoFormatter is an internal\n// type, this overload is only invoked when strings::Join() is called with a\n// range of string-like objects (e.g., std::string, absl::string_view), and an\n// explicit Formatter argument was NOT specified.\n//\n// The optimization is that the needed space will be reserved in the output\n// string to avoid the need to resize while appending. To do this, the iterator\n// range will be traversed twice: once to calculate the total needed size, and\n// then again to copy the elements and delimiters to the output string.\ntemplate <typename Iterator,\n          typename = typename std::enable_if<std::is_convertible<\n              typename std::iterator_traits<Iterator>::iterator_category,\n              std::forward_iterator_tag>::value>::type>\nstd::string JoinAlgorithm(Iterator start, Iterator end, absl::string_view s,\n                          NoFormatter) {\n  std::string result;\n  if (start != end) {\n    // Sums size\n    auto&& start_value = *start;\n    size_t result_size = start_value.size();\n    for (Iterator it = start; ++it != end;) {\n      result_size += s.size();\n      result_size += (*it).size();\n    }\n\n    if (result_size > 0) {\n      STLStringResizeUninitialized(&result, result_size);\n\n      // Joins strings\n      char* result_buf = &*result.begin();\n\n      memcpy(result_buf, start_value.data(), start_value.size());\n      result_buf += start_value.size();\n      for (Iterator it = start; ++it != end;) {\n        memcpy(result_buf, s.data(), s.size());\n        result_buf += s.size();\n        auto&& value = *it;\n        memcpy(result_buf, value.data(), value.size());\n        result_buf += value.size();\n      }\n    }\n  }\n\n  return result;\n}\n\n// JoinTupleLoop implements a loop over the elements of a std::tuple, which\n// are heterogeneous. The primary template matches the tuple interior case. It\n// continues the iteration after appending a separator (for nonzero indices)\n// and formatting an element of the tuple. The specialization for the I=N case\n// matches the end-of-tuple, and terminates the iteration.\ntemplate <size_t I, size_t N>\nstruct JoinTupleLoop {\n  template <typename Tup, typename Formatter>\n  void operator()(std::string* out, const Tup& tup, absl::string_view sep,\n                  Formatter&& fmt) {\n    if (I > 0) out->append(sep.data(), sep.size());\n    fmt(out, std::get<I>(tup));\n    JoinTupleLoop<I + 1, N>()(out, tup, sep, fmt);\n  }\n};\ntemplate <size_t N>\nstruct JoinTupleLoop<N, N> {\n  template <typename Tup, typename Formatter>\n  void operator()(std::string*, const Tup&, absl::string_view, Formatter&&) {}\n};\n\ntemplate <typename... T, typename Formatter>\nstd::string JoinAlgorithm(const std::tuple<T...>& tup, absl::string_view sep,\n                          Formatter&& fmt) {\n  std::string result;\n  JoinTupleLoop<0, sizeof...(T)>()(&result, tup, sep, fmt);\n  return result;\n}\n\ntemplate <typename Iterator>\nstd::string JoinRange(Iterator first, Iterator last,\n                      absl::string_view separator) {\n  // No formatter was explicitly given, so a default must be chosen.\n  typedef typename std::iterator_traits<Iterator>::value_type ValueType;\n  typedef typename DefaultFormatter<ValueType>::Type Formatter;\n  return JoinAlgorithm(first, last, separator, Formatter());\n}\n\ntemplate <typename Range, typename Formatter>\nstd::string JoinRange(const Range& range, absl::string_view separator,\n                      Formatter&& fmt) {\n  using std::begin;\n  using std::end;\n  return JoinAlgorithm(begin(range), end(range), separator, fmt);\n}\n\ntemplate <typename Range>\nstd::string JoinRange(const Range& range, absl::string_view separator) {\n  using std::begin;\n  using std::end;\n  return JoinRange(begin(range), end(range), separator);\n}\n\n}  // namespace strings_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06248",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_join_internal.h",
  "source_line": 45,
  "validation_status": "validated"
}