{
  "code": "{\n///   static int b;\n/// #pragma omp threadprivate(b)\n/// };\n/// \\endcode\n///\nclass OMPThreadPrivateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n\n  virtual void anchor();\n\n  OMPThreadPrivateDecl(DeclContext *DC = nullptr,\n                       SourceLocation L = SourceLocation())\n      : OMPDeclarativeDirective<Decl>(OMPThreadPrivate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::ArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::MutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPThreadPrivateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      ArrayRef<Expr *> VL);\n  static OMPThreadPrivateDecl *CreateDeserialized(ASTContext &C,\n                                                  unsigned ID, unsigned N);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPThreadPrivate; }\n};\n\n/// This represents '#pragma omp declare reduction ...' directive.\n/// For example, in the following, declared reduction 'foo' for types 'int' and\n/// 'float':\n///\n/// \\code\n/// #pragma omp declare reduction (foo : int,float : omp_out += omp_in)\n///                     initializer (omp_priv = 0)\n/// \\endcode\n///\n/// Here 'omp_out += omp_in' is a combiner and 'omp_priv = 0' is an initializer.\nclass OMPDeclareReductionDecl final : public ValueDecl, public DeclContext {\n  // This class stores some data in DeclContext::OMPDeclareReductionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  enum InitKind {\n    CallInit,   // Initialized by function call.\n    DirectInit, // omp_priv(<expr>)\n    CopyInit    // omp_priv = <expr>\n  };\n\nprivate:\n  friend class ASTDeclReader;\n  /// Combiner for declare reduction construct.\n  Expr *Combiner = nullptr;\n  /// Initializer for declare reduction construct.\n  Expr *Initializer = nullptr;\n  /// In parameter of the combiner.\n  Expr *In = nullptr;\n  /// Out parameter of the combiner.\n  Expr *Out = nullptr;\n  /// Priv parameter of the initializer.\n  Expr *Priv = nullptr;\n  /// Orig parameter of the initializer.\n  Expr *Orig = nullptr;\n\n  /// Reference to the previous declare reduction construct in the same\n  /// scope with the same name. Required for proper templates instantiation if\n  /// the declare reduction construct is declared inside compound statement.\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareReductionDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                          DeclarationName Name, QualType Ty,\n                          OMPDeclareReductionDecl *PrevDeclInScope);\n\n  void setPrevDeclInScope(OMPDeclareReductionDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Create declare reduction node.\n  static OMPDeclareReductionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation L, DeclarationName Name,\n         QualType T, OMPDeclareReductionDecl *PrevDeclInScope);\n  /// Create deserialized declare reduction node.\n  static OMPDeclareReductionDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Get combiner expression of the declare reduction construct.\n  Expr *getCombiner() { return Combiner; }\n  const Expr *getCombiner() const { return Combiner; }\n  /// Get In variable of the combiner.\n  Expr *getCombinerIn() { return In; }\n  const Expr *getCombinerIn() const { return In; }\n  /// Get Out variable of the combiner.\n  Expr *getCombinerOut() { return Out; }\n  const Expr *getCombinerOut() const { return Out; }\n  /// Set combiner expression for the declare reduction construct.\n  void setCombiner(Expr *E) { Combiner = E; }\n  /// Set combiner In and Out vars.\n  void setCombinerData(Expr *InE, Expr *OutE) {\n    In = InE;\n    Out = OutE;\n  }\n\n  /// Get initializer expression (if specified) of the declare reduction\n  /// construct.\n  Expr *getInitializer() { return Initializer; }\n  const Expr *getInitializer() const { return Initializer; }\n  /// Get initializer kind.\n  InitKind getInitializerKind() const {\n    return static_cast<InitKind>(OMPDeclareReductionDeclBits.InitializerKind);\n  }\n  /// Get Orig variable of the initializer.\n  Expr *getInitOrig() { return Orig; }\n  const Expr *getInitOrig() const { return Orig; }\n  /// Get Priv variable of the initializer.\n  Expr *getInitPriv() { return Priv; }\n  const Expr *getInitPriv() const { return Priv; }\n  /// Set initializer expression for the declare reduction construct.\n  void setInitializer(Expr *E, InitKind IK) {\n    Initializer = E;\n    OMPDeclareReductionDeclBits.InitializerKind = IK;\n  }\n  /// Set initializer Orig and Priv vars.\n  void setInitializerData(Expr *OrigE, Expr *PrivE) {\n    Orig = OrigE;\n    Priv = PrivE;\n  }\n\n  /// Get reference to previous declare reduction construct in the same\n  /// scope with the same name.\n  OMPDeclareReductionDecl *getPrevDeclInScope();\n  const OMPDeclareReductionDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareReduction; }\n  static DeclContext *castToDeclContext(const OMPDeclareReductionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareReductionDecl *>(D));\n  }\n  static OMPDeclareReductionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareReductionDecl *>(\n        const_cast<DeclContext *>(DC));\n  }\n};\n\n/// This represents '#pragma omp declare mapper ...' directive. Map clauses are\n/// allowed to use with this directive. The following example declares a user\n/// defined mapper for the type 'struct vec'. This example instructs the fields\n/// 'len' and 'data' should be mapped when mapping instances of 'struct vec'.\n///\n/// \\code\n/// #pragma omp declare mapper(mid: struct vec v) map(v.len, v.data[0:N])\n/// \\endcode\nclass OMPDeclareMapperDecl final : public OMPDeclarativeDirective<ValueDecl>,\n                                   public DeclContext {\n  friend class OMPDeclarativeDirective<ValueDecl>;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Mapper variable, which is 'v' in the example above\n  Expr *MapperVarRef = nullptr;\n\n  /// Name of the mapper variable\n  DeclarationName VarName;\n\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareMapperDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n                       QualType Ty, DeclarationName VarName,\n                       OMPDeclareMapperDecl *PrevDeclInScope)\n      : OMPDeclarativeDirective<ValueDecl>(OMPDeclareMapper, DC, L, Name, Ty),\n        DeclContext(OMPDeclareMapper), VarName(VarName),\n        PrevDeclInScope(PrevDeclInScope) {}\n\n  void setPrevDeclInScope(OMPDeclareMapperDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Creates declare mapper node.\n  static OMPDeclareMapperDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L, DeclarationName Name,\n                                      QualType T, DeclarationName VarName,\n                                      ArrayRef<OMPClause *> Clauses,\n                                      OMPDeclareMapperDecl *PrevDeclInScope);\n  /// Creates deserialized declare mapper node.\n  static OMPDeclareMapperDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                  unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range =\n      llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  /// Get the variable declared in the mapper\n  Expr *getMapperVarRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getMapperVarRef() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Set the variable declared in the mapper\n  void setMapperVarRef(Expr *MapperVarRefE) {\n    Data->getChildren()[0] = MapperVarRefE;\n  }\n\n  /// Get the name of the variable declared in the mapper\n  DeclarationName getVarName() { return VarName; }\n\n  /// Get reference to previous declare mapper construct in the same\n  /// scope with the same name.\n  OMPDeclareMapperDecl *getPrevDeclInScope();\n  const OMPDeclareMapperDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareMapper; }\n  static DeclContext *castToDeclContext(const OMPDeclareMapperDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareMapperDecl *>(D));\n  }\n  static OMPDeclareMapperDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareMapperDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Pseudo declaration for capturing expressions. Also is used for capturing of\n/// non-static data members in non-static member functions.\n///\n/// Clang supports capturing of variables only, but OpenMP 4.5 allows to\n/// privatize non-static members of current class in non-static member\n/// functions. This pseudo-declaration allows properly handle this kind of\n/// capture by wrapping captured expression into a variable-like declaration.\nclass OMPCapturedExprDecl final : public VarDecl {\n  friend class ASTDeclReader;\n  void anchor() override;\n\n  OMPCapturedExprDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                      QualType Type, TypeSourceInfo *TInfo,\n                      SourceLocation StartLoc)\n      : VarDecl(OMPCapturedExpr, C, DC, StartLoc, StartLoc, Id, Type, TInfo,\n                SC_None) {\n    setImplicit();\n  }\n\npublic:\n  static OMPCapturedExprDecl *Create(ASTContext &C, DeclContext *DC,\n                                     IdentifierInfo *Id, QualType T,\n                                     SourceLocation StartLoc);\n\n  static OMPCapturedExprDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPCapturedExpr; }\n};\n\n/// This represents '#pragma omp requires...' directive.\n/// For example\n///\n/// \\code\n/// #pragma omp requires unified_address\n/// \\endcode\n///\nclass OMPRequiresDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPRequiresDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPRequires, DC, L) {}\n\npublic:\n  /// Create requires node.\n  static OMPRequiresDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<OMPClause *> CL);\n  /// Create deserialized requires node.\n  static OMPRequiresDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPRequires; }\n};\n\n/// This represents '#pragma omp allocate ...' directive.\n/// For example, in the following, the default allocator is used for both 'a'\n/// and 'A::b':\n///\n/// \\code\n/// int a;\n/// #pragma omp allocate(a)\n/// struct A {\n///   static int b;\n/// #pragma omp allocate(b)\n/// };\n/// \\endcode\n///\nclass OMPAllocateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPAllocateDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPAllocate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::ArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::MutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPAllocateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<Expr *> VL,\n                                 ArrayRef<OMPClause *> CL);\n  static OMPAllocateDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned NVars, unsigned NClauses);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPAllocate; }\n};\n\n}",
  "id": "BLOCK-CPP-09139",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclOpenMP.h",
  "source_line": 104,
  "validation_status": "validated"
}