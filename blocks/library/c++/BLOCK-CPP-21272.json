{
  "code": "{\nnamespace ast_matchers {\nnamespace dynamic {\n\nclass Diagnostics;\n\n/// Matcher expression parser.\nclass Parser {\npublic:\n  /// Interface to connect the parser with the registry and more.\n  ///\n  /// The parser uses the Sema instance passed into\n  /// parseMatcherExpression() to handle all matcher tokens. The simplest\n  /// processor implementation would simply call into the registry to create\n  /// the matchers.\n  /// However, a more complex processor might decide to intercept the matcher\n  /// creation and do some extra work. For example, it could apply some\n  /// transformation to the matcher by adding some id() nodes, or could detect\n  /// specific matcher nodes for more efficient lookup.\n  class Sema {\n  public:\n    virtual ~Sema();\n\n    /// Process a matcher expression.\n    ///\n    /// All the arguments passed here have already been processed.\n    ///\n    /// \\param Ctor A matcher constructor looked up by lookupMatcherCtor.\n    ///\n    /// \\param NameRange The location of the name in the matcher source.\n    ///   Useful for error reporting.\n    ///\n    /// \\param BindID The ID to use to bind the matcher, or a null \\c StringRef\n    ///   if no ID is specified.\n    ///\n    /// \\param Args The argument list for the matcher.\n    ///\n    /// \\return The matcher objects constructed by the processor, or a null\n    ///   matcher if an error occurred. In that case, \\c Error will contain a\n    ///   description of the error.\n    virtual VariantMatcher actOnMatcherExpression(MatcherCtor Ctor,\n                                                  SourceRange NameRange,\n                                                  StringRef BindID,\n                                                  ArrayRef<ParserValue> Args,\n                                                  Diagnostics *Error) = 0;\n\n    /// Look up a matcher by name.\n    ///\n    /// \\param MatcherName The matcher name found by the parser.\n    ///\n    /// \\return The matcher constructor, or std::optional<MatcherCtor>() if not\n    /// found.\n    virtual std::optional<MatcherCtor>\n    lookupMatcherCtor(StringRef MatcherName) = 0;\n\n    virtual bool isBuilderMatcher(MatcherCtor) const = 0;\n\n    virtual ASTNodeKind nodeMatcherType(MatcherCtor) const = 0;\n\n    virtual internal::MatcherDescriptorPtr\n    buildMatcherCtor(MatcherCtor, SourceRange NameRange,\n                     ArrayRef<ParserValue> Args, Diagnostics *Error) const = 0;\n\n    /// Compute the list of completion types for \\p Context.\n    ///\n    /// Each element of \\p Context represents a matcher invocation, going from\n    /// outermost to innermost. Elements are pairs consisting of a reference to\n    /// the matcher constructor and the index of the next element in the\n    /// argument list of that matcher (or for the last element, the index of\n    /// the completion point in the argument list). An empty list requests\n    /// completion for the root matcher.\n    virtual std::vector<ArgKind> getAcceptedCompletionTypes(\n        llvm::ArrayRef<std::pair<MatcherCtor, unsigned>> Context);\n\n    /// Compute the list of completions that match any of\n    /// \\p AcceptedTypes.\n    ///\n    /// \\param AcceptedTypes All types accepted for this completion.\n    ///\n    /// \\return All completions for the specified types.\n    /// Completions should be valid when used in \\c lookupMatcherCtor().\n    /// The matcher constructed from the return of \\c lookupMatcherCtor()\n    /// should be convertible to some type in \\p AcceptedTypes.\n    virtual std::vector<MatcherCompletion>\n    getMatcherCompletions(llvm::ArrayRef<ArgKind> AcceptedTypes);\n  };\n\n  /// Sema implementation that uses the matcher registry to process the\n  ///   tokens.\n  class RegistrySema : public Parser::Sema {\n  public:\n    ~RegistrySema() override;\n\n    std::optional<MatcherCtor>\n    lookupMatcherCtor(StringRef MatcherName) override;\n\n    VariantMatcher actOnMatcherExpression(MatcherCtor Ctor,\n                                          SourceRange NameRange,\n                                          StringRef BindID,\n                                          ArrayRef<ParserValue> Args,\n                                          Diagnostics *Error) override;\n\n    std::vector<ArgKind> getAcceptedCompletionTypes(\n        llvm::ArrayRef<std::pair<MatcherCtor, unsigned>> Context) override;\n\n    bool isBuilderMatcher(MatcherCtor Ctor) const override;\n\n    ASTNodeKind nodeMatcherType(MatcherCtor) const override;\n\n    internal::MatcherDescriptorPtr\n    buildMatcherCtor(MatcherCtor, SourceRange NameRange,\n                     ArrayRef<ParserValue> Args,\n                     Diagnostics *Error) const override;\n\n    std::vector<MatcherCompletion>\n    getMatcherCompletions(llvm::ArrayRef<ArgKind> AcceptedTypes) override;\n  };\n\n  using NamedValueMap = llvm::StringMap<VariantValue>;\n\n  /// Parse a matcher expression.\n  ///\n  /// \\param MatcherCode The matcher expression to parse.\n  ///\n  /// \\param S The Sema instance that will help the parser\n  ///   construct the matchers. If null, it uses the default registry.\n  ///\n  /// \\param NamedValues A map of precomputed named values.  This provides\n  ///   the dictionary for the <NamedValue> rule of the grammar.\n  ///   If null, it is ignored.\n  ///\n  /// \\return The matcher object constructed by the processor, or an empty\n  ///   Optional if an error occurred. In that case, \\c Error will contain a\n  ///   description of the error.\n  ///   The caller takes ownership of the DynTypedMatcher object returned.\n  static std::optional<DynTypedMatcher>\n  parseMatcherExpression(StringRef &MatcherCode, Sema *S,\n                         const NamedValueMap *NamedValues, Diagnostics *Error);\n  static std::optional<DynTypedMatcher>\n  parseMatcherExpression(StringRef &MatcherCode, Sema *S, Diagnostics *Error) {\n    return parseMatcherExpression(MatcherCode, S, nullptr, Error);\n  }\n  static std::optional<DynTypedMatcher>\n  parseMatcherExpression(StringRef &MatcherCode, Diagnostics *Error) {\n    return parseMatcherExpression(MatcherCode, nullptr, Error);\n  }\n\n  /// Parse an expression.\n  ///\n  /// Parses any expression supported by this parser. In general, the\n  /// \\c parseMatcherExpression function is a better approach to get a matcher\n  /// object.\n  ///\n  /// \\param S The Sema instance that will help the parser\n  ///   construct the matchers. If null, it uses the default registry.\n  ///\n  /// \\param NamedValues A map of precomputed named values.  This provides\n  ///   the dictionary for the <NamedValue> rule of the grammar.\n  ///   If null, it is ignored.\n  static bool parseExpression(StringRef &Code, Sema *S,\n                              const NamedValueMap *NamedValues,\n                              VariantValue *Value, Diagnostics *Error);\n  static bool parseExpression(StringRef &Code, Sema *S, VariantValue *Value,\n                              Diagnostics *Error) {\n    return parseExpression(Code, S, nullptr, Value, Error);\n  }\n  static bool parseExpression(StringRef &Code, VariantValue *Value,\n                              Diagnostics *Error) {\n    return parseExpression(Code, nullptr, Value, Error);\n  }\n\n  /// Complete an expression at the given offset.\n  ///\n  /// \\param S The Sema instance that will help the parser\n  ///   construct the matchers. If null, it uses the default registry.\n  ///\n  /// \\param NamedValues A map of precomputed named values.  This provides\n  ///   the dictionary for the <NamedValue> rule of the grammar.\n  ///   If null, it is ignored.\n  ///\n  /// \\return The list of completions, which may be empty if there are no\n  /// available completions or if an error occurred.\n  static std::vector<MatcherCompletion>\n  completeExpression(StringRef &Code, unsigned CompletionOffset, Sema *S,\n                     const NamedValueMap *NamedValues);\n  static std::vector<MatcherCompletion>\n  completeExpression(StringRef &Code, unsigned CompletionOffset, Sema *S) {\n    return completeExpression(Code, CompletionOffset, S, nullptr);\n  }\n  static std::vector<MatcherCompletion>\n  completeExpression(StringRef &Code, unsigned CompletionOffset) {\n    return completeExpression(Code, CompletionOffset, nullptr);\n  }\n\nprivate:\n  class CodeTokenizer;\n  struct ScopedContextEntry;\n  struct TokenInfo;\n\n  Parser(CodeTokenizer *Tokenizer, Sema *S,\n         const NamedValueMap *NamedValues,\n         Diagnostics *Error);\n\n  bool parseBindID(std::string &BindID);\n  bool parseExpressionImpl(VariantValue *Value);\n  bool parseMatcherBuilder(MatcherCtor Ctor, const TokenInfo &NameToken,\n                           const TokenInfo &OpenToken, VariantValue *Value);\n  bool parseMatcherExpressionImpl(const TokenInfo &NameToken,\n                                  const TokenInfo &OpenToken,\n                                  std::optional<MatcherCtor> Ctor,\n                                  VariantValue *Value);\n  bool parseIdentifierPrefixImpl(VariantValue *Value);\n\n  void addCompletion(const TokenInfo &CompToken,\n                     const MatcherCompletion &Completion);\n  void addExpressionCompletions();\n\n  std::vector<MatcherCompletion>\n  getNamedValueCompletions(ArrayRef<ArgKind> AcceptedTypes);\n\n  CodeTokenizer *const Tokenizer;\n  Sema *const S;\n  const NamedValueMap *const NamedValues;\n  Diagnostics *const Error;\n\n  using ContextStackTy = std::vector<std::pair<MatcherCtor, unsigned>>;\n\n  ContextStackTy ContextStack;\n  std::vector<MatcherCompletion> Completions;\n};\n\n} // namespace dynamic\n} // namespace ast_matchers\n}",
  "id": "BLOCK-CPP-21272",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/Dynamic/Parser.h",
  "source_line": 48,
  "validation_status": "validated"
}