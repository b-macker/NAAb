{
  "code": "{\n  static_assert(N > 0, \"`absl::InlinedVector` requires an inlined capacity.\");\n\n  using Storage = inlined_vector_internal::Storage<T, N, A>;\n\n  template <typename TheA>\n  using AllocatorTraits = inlined_vector_internal::AllocatorTraits<TheA>;\n  template <typename TheA>\n  using MoveIterator = inlined_vector_internal::MoveIterator<TheA>;\n  template <typename TheA>\n  using IsMoveAssignOk = inlined_vector_internal::IsMoveAssignOk<TheA>;\n\n  template <typename TheA, typename Iterator>\n  using IteratorValueAdapter =\n      inlined_vector_internal::IteratorValueAdapter<TheA, Iterator>;\n  template <typename TheA>\n  using CopyValueAdapter = inlined_vector_internal::CopyValueAdapter<TheA>;\n  template <typename TheA>\n  using DefaultValueAdapter =\n      inlined_vector_internal::DefaultValueAdapter<TheA>;\n\n  template <typename Iterator>\n  using EnableIfAtLeastForwardIterator = absl::enable_if_t<\n      inlined_vector_internal::IsAtLeastForwardIterator<Iterator>::value, int>;\n  template <typename Iterator>\n  using DisableIfAtLeastForwardIterator = absl::enable_if_t<\n      !inlined_vector_internal::IsAtLeastForwardIterator<Iterator>::value, int>;\n\n  using MemcpyPolicy = typename Storage::MemcpyPolicy;\n  using ElementwiseAssignPolicy = typename Storage::ElementwiseAssignPolicy;\n  using ElementwiseConstructPolicy =\n      typename Storage::ElementwiseConstructPolicy;\n  using MoveAssignmentPolicy = typename Storage::MoveAssignmentPolicy;\n\n public:\n  using allocator_type = A;\n  using value_type = inlined_vector_internal::ValueType<A>;\n  using pointer = inlined_vector_internal::Pointer<A>;\n  using const_pointer = inlined_vector_internal::ConstPointer<A>;\n  using size_type = inlined_vector_internal::SizeType<A>;\n  using difference_type = inlined_vector_internal::DifferenceType<A>;\n  using reference = inlined_vector_internal::Reference<A>;\n  using const_reference = inlined_vector_internal::ConstReference<A>;\n  using iterator = inlined_vector_internal::Iterator<A>;\n  using const_iterator = inlined_vector_internal::ConstIterator<A>;\n  using reverse_iterator = inlined_vector_internal::ReverseIterator<A>;\n  using const_reverse_iterator =\n      inlined_vector_internal::ConstReverseIterator<A>;\n\n  // ---------------------------------------------------------------------------\n  // InlinedVector Constructors and Destructor\n  // ---------------------------------------------------------------------------\n\n  // Creates an empty inlined vector with a value-initialized allocator.\n  InlinedVector() noexcept(noexcept(allocator_type())) : storage_() {}\n\n  // Creates an empty inlined vector with a copy of `allocator`.\n  explicit InlinedVector(const allocator_type& allocator) noexcept\n      : storage_(allocator) {}\n\n  // Creates an inlined vector with `n` copies of `value_type()`.\n  explicit InlinedVector(size_type n,\n                         const allocator_type& allocator = allocator_type())\n      : storage_(allocator) {\n    storage_.Initialize(DefaultValueAdapter<A>(), n);\n  }\n\n  // Creates an inlined vector with `n` copies of `v`.\n  InlinedVector(size_type n, const_reference v,\n                const allocator_type& allocator = allocator_type())\n      : storage_(allocator) {\n    storage_.Initialize(CopyValueAdapter<A>(std::addressof(v)), n);\n  }\n\n  // Creates an inlined vector with copies of the elements of `list`.\n  InlinedVector(std::initializer_list<value_type> list,\n                const allocator_type& allocator = allocator_type())\n      : InlinedVector(list.begin(), list.end(), allocator) {}\n\n  // Creates an inlined vector with elements constructed from the provided\n  // forward iterator range [`first`, `last`).\n  //\n  // NOTE: the `enable_if` prevents ambiguous interpretation between a call to\n  // this constructor with two integral arguments and a call to the above\n  // `InlinedVector(size_type, const_reference)` constructor.\n  template <typename ForwardIterator,\n            EnableIfAtLeastForwardIterator<ForwardIterator> = 0>\n  InlinedVector(ForwardIterator first, ForwardIterator last,\n                const allocator_type& allocator = allocator_type())\n      : storage_(allocator) {\n    storage_.Initialize(IteratorValueAdapter<A, ForwardIterator>(first),\n                        static_cast<size_t>(std::distance(first, last)));\n  }\n\n  // Creates an inlined vector with elements constructed from the provided input\n  // iterator range [`first`, `last`).\n  template <typename InputIterator,\n            DisableIfAtLeastForwardIterator<InputIterator> = 0>\n  InlinedVector(InputIterator first, InputIterator last,\n                const allocator_type& allocator = allocator_type())\n      : storage_(allocator) {\n    std::copy(first, last, std::back_inserter(*this));\n  }\n\n  // Creates an inlined vector by copying the contents of `other` using\n  // `other`'s allocator.\n  InlinedVector(const InlinedVector& other)\n      : InlinedVector(other, other.storage_.GetAllocator()) {}\n\n  // Creates an inlined vector by copying the contents of `other` using the\n  // provided `allocator`.\n  InlinedVector(const InlinedVector& other, const allocator_type& allocator)\n      : storage_(allocator) {\n    // Fast path: if the other vector is empty, there's nothing for us to do.\n    if (other.empty()) {\n      return;\n    }\n\n    // Fast path: if the value type is trivially copy constructible, we know the\n    // allocator doesn't do anything fancy, and there is nothing on the heap\n    // then we know it is legal for us to simply memcpy the other vector's\n    // inlined bytes to form our copy of its elements.\n    if (absl::is_trivially_copy_constructible<value_type>::value &&\n        std::is_same<A, std::allocator<value_type>>::value &&\n        !other.storage_.GetIsAllocated()) {\n      storage_.MemcpyFrom(other.storage_);\n      return;\n    }\n\n    storage_.InitFrom(other.storage_);\n  }\n\n  // Creates an inlined vector by moving in the contents of `other` without\n  // allocating. If `other` contains allocated memory, the newly-created inlined\n  // vector will take ownership of that memory. However, if `other` does not\n  // contain allocated memory, the newly-created inlined vector will perform\n  // element-wise move construction of the contents of `other`.\n  //\n  // NOTE: since no allocation is performed for the inlined vector in either\n  // case, the `noexcept(...)` specification depends on whether moving the\n  // underlying objects can throw. It is assumed assumed that...\n  //  a) move constructors should only throw due to allocation failure.\n  //  b) if `value_type`'s move constructor allocates, it uses the same\n  //     allocation function as the inlined vector's allocator.\n  // Thus, the move constructor is non-throwing if the allocator is non-throwing\n  // or `value_type`'s move constructor is specified as `noexcept`.\n  InlinedVector(InlinedVector&& other) noexcept(\n      absl::allocator_is_nothrow<allocator_type>::value ||\n      std::is_nothrow_move_constructible<value_type>::value)\n      : storage_(other.storage_.GetAllocator()) {\n    // Fast path: if the value type can be trivially relocated (i.e. moved from\n    // and destroyed), and we know the allocator doesn't do anything fancy, then\n    // it's safe for us to simply adopt the contents of the storage for `other`\n    // and remove its own reference to them. It's as if we had individually\n    // move-constructed each value and then destroyed the original.\n    if (absl::is_trivially_relocatable<value_type>::value &&\n        std::is_same<A, std::allocator<value_type>>::value) {\n      storage_.MemcpyFrom(other.storage_);\n      other.storage_.SetInlinedSize(0);\n      return;\n    }\n\n    // Fast path: if the other vector is on the heap, we can simply take over\n    // its allocation.\n    if (other.storage_.GetIsAllocated()) {\n      storage_.SetAllocation({other.storage_.GetAllocatedData(),\n                              other.storage_.GetAllocatedCapacity()});\n      storage_.SetAllocatedSize(other.storage_.GetSize());\n\n      other.storage_.SetInlinedSize(0);\n      return;\n    }\n\n    // Otherwise we must move each element individually.\n    IteratorValueAdapter<A, MoveIterator<A>> other_values(\n        MoveIterator<A>(other.storage_.GetInlinedData()));\n\n    inlined_vector_internal::ConstructElements<A>(\n        storage_.GetAllocator(), storage_.GetInlinedData(), other_values,\n        other.storage_.GetSize());\n\n    storage_.SetInlinedSize(other.storage_.GetSize());\n  }\n\n  // Creates an inlined vector by moving in the contents of `other` with a copy\n  // of `allocator`.\n  //\n  // NOTE: if `other`'s allocator is not equal to `allocator`, even if `other`\n  // contains allocated memory, this move constructor will still allocate. Since\n  // allocation is performed, this constructor can only be `noexcept` if the\n  // specified allocator is also `noexcept`.\n  InlinedVector(\n      InlinedVector&& other,\n      const allocator_type&\n          allocator) noexcept(absl::allocator_is_nothrow<allocator_type>::value)\n      : storage_(allocator) {\n    // Fast path: if the value type can be trivially relocated (i.e. moved from\n    // and destroyed), and we know the allocator doesn't do anything fancy, then\n    // it's safe for us to simply adopt the contents of the storage for `other`\n    // and remove its own reference to them. It's as if we had individually\n    // move-constructed each value and then destroyed the original.\n    if (absl::is_trivially_relocatable<value_type>::value &&\n        std::is_same<A, std::allocator<value_type>>::value) {\n      storage_.MemcpyFrom(other.storage_);\n      other.storage_.SetInlinedSize(0);\n      return;\n    }\n\n    // Fast path: if the other vector is on the heap and shared the same\n    // allocator, we can simply take over its allocation.\n    if ((storage_.GetAllocator() == other.storage_.GetAllocator()) &&\n        other.storage_.GetIsAllocated()) {\n      storage_.SetAllocation({other.storage_.GetAllocatedData(),\n                              other.storage_.GetAllocatedCapacity()});\n      storage_.SetAllocatedSize(other.storage_.GetSize());\n\n      other.storage_.SetInlinedSize(0);\n      return;\n    }\n\n    // Otherwise we must move each element individually.\n    storage_.Initialize(\n        IteratorValueAdapter<A, MoveIterator<A>>(MoveIterator<A>(other.data())),\n        other.size());\n  }\n\n  ~InlinedVector() {}\n\n  // ---------------------------------------------------------------------------\n  // InlinedVector Member Accessors\n  // ---------------------------------------------------------------------------\n\n  // `InlinedVector::empty()`\n  //\n  // Returns whether the inlined vector contains no elements.\n  bool empty() const noexcept { return !size(); }\n\n  // `InlinedVector::size()`\n  //\n  // Returns the number of elements in the inlined vector.\n  size_type size() const noexcept { return storage_.GetSize(); }\n\n  // `InlinedVector::max_size()`\n  //\n  // Returns the maximum number of elements the inlined vector can hold.\n  size_type max_size() const noexcept {\n    // One bit of the size storage is used to indicate whether the inlined\n    // vector contains allocated memory. As a result, the maximum size that the\n    // inlined vector can express is the minimum of the limit of how many\n    // objects we can allocate and std::numeric_limits<size_type>::max() / 2.\n    return (std::min)(AllocatorTraits<A>::max_size(storage_.GetAllocator()),\n                      (std::numeric_limits<size_type>::max)() / 2);\n  }\n\n  // `InlinedVector::capacity()`\n  //\n  // Returns the number of elements that could be stored in the inlined vector\n  // without requiring a reallocation.\n  //\n  // NOTE: for most inlined vectors, `capacity()` should be equal to the\n  // template parameter `N`. For inlined vectors which exceed this capacity,\n  // they will no longer be inlined and `capacity()` will equal the capactity of\n  // the allocated memory.\n  size_type capacity() const noexcept {\n    return storage_.GetIsAllocated() ? storage_.GetAllocatedCapacity()\n                                     : storage_.GetInlinedCapacity();\n  }\n\n  // `InlinedVector::data()`\n  //\n  // Returns a `pointer` to the elements of the inlined vector. This pointer\n  // can be used to access and modify the contained elements.\n  //\n  // NOTE: only elements within [`data()`, `data() + size()`) are valid.\n  pointer data() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return storage_.GetIsAllocated() ? storage_.GetAllocatedData()\n                                     : storage_.GetInlinedData();\n  }\n\n  // Overload of `InlinedVector::data()` that returns a `const_pointer` to the\n  // elements of the inlined vector. This pointer can be used to access but not\n  // modify the contained elements.\n  //\n  // NOTE: only elements within [`data()`, `data() + size()`) are valid.\n  const_pointer data() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return storage_.GetIsAllocated() ? storage_.GetAllocatedData()\n                                     : storage_.GetInlinedData();\n  }\n\n  // `InlinedVector::operator[](...)`\n  //\n  // Returns a `reference` to the `i`th element of the inlined vector.\n  reference operator[](size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(i < size());\n    return data()[i];\n  }\n\n  // Overload of `InlinedVector::operator[](...)` that returns a\n  // `const_reference` to the `i`th element of the inlined vector.\n  const_reference operator[](size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(i < size());\n    return data()[i];\n  }\n\n  // `InlinedVector::at(...)`\n  //\n  // Returns a `reference` to the `i`th element of the inlined vector.\n  //\n  // NOTE: if `i` is not within the required range of `InlinedVector::at(...)`,\n  // in both debug and non-debug builds, `std::out_of_range` will be thrown.\n  reference at(size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ABSL_PREDICT_FALSE(i >= size())) {\n      base_internal::ThrowStdOutOfRange(\n          \"`InlinedVector::at(size_type)` failed bounds check\");\n    }\n    return data()[i];\n  }\n\n  // Overload of `InlinedVector::at(...)` that returns a `const_reference` to\n  // the `i`th element of the inlined vector.\n  //\n  // NOTE: if `i` is not within the required range of `InlinedVector::at(...)`,\n  // in both debug and non-debug builds, `std::out_of_range` will be thrown.\n  const_reference at(size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    if (ABSL_PREDICT_FALSE(i >= size())) {\n      base_internal::ThrowStdOutOfRange(\n          \"`InlinedVector::at(size_type) const` failed bounds check\");\n    }\n    return data()[i];\n  }\n\n  // `InlinedVector::front()`\n  //\n  // Returns a `reference` to the first element of the inlined vector.\n  reference front() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[0];\n  }\n\n  // Overload of `InlinedVector::front()` that returns a `const_reference` to\n  // the first element of the inlined vector.\n  const_reference front() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[0];\n  }\n\n  // `InlinedVector::back()`\n  //\n  // Returns a `reference` to the last element of the inlined vector.\n  reference back() ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[size() - 1];\n  }\n\n  // Overload of `InlinedVector::back()` that returns a `const_reference` to the\n  // last element of the inlined vector.\n  const_reference back() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(!empty());\n    return data()[size() - 1];\n  }\n\n  // `InlinedVector::begin()`\n  //\n  // Returns an `iterator` to the beginning of the inlined vector.\n  iterator begin() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND { return data(); }\n\n  // Overload of `InlinedVector::begin()` that returns a `const_iterator` to\n  // the beginning of the inlined vector.\n  const_iterator begin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return data();\n  }\n\n  // `InlinedVector::end()`\n  //\n  // Returns an `iterator` to the end of the inlined vector.\n  iterator end() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return data() + size();\n  }\n\n  // Overload of `InlinedVector::end()` that returns a `const_iterator` to the\n  // end of the inlined vector.\n  const_iterator end() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return data() + size();\n  }\n\n  // `InlinedVector::cbegin()`\n  //\n  // Returns a `const_iterator` to the beginning of the inlined vector.\n  const_iterator cbegin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return begin();\n  }\n\n  // `InlinedVector::cend()`\n  //\n  // Returns a `const_iterator` to the end of the inlined vector.\n  const_iterator cend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return end();\n  }\n\n  // `InlinedVector::rbegin()`\n  //\n  // Returns a `reverse_iterator` from the end of the inlined vector.\n  reverse_iterator rbegin() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return reverse_iterator(end());\n  }\n\n  // Overload of `InlinedVector::rbegin()` that returns a\n  // `const_reverse_iterator` from the end of the inlined vector.\n  const_reverse_iterator rbegin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return const_reverse_iterator(end());\n  }\n\n  // `InlinedVector::rend()`\n  //\n  // Returns a `reverse_iterator` from the beginning of the inlined vector.\n  reverse_iterator rend() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return reverse_iterator(begin());\n  }\n\n  // Overload of `InlinedVector::rend()` that returns a `const_reverse_iterator`\n  // from the beginning of the inlined vector.\n  const_reverse_iterator rend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return const_reverse_iterator(begin());\n  }\n\n  // `InlinedVector::crbegin()`\n  //\n  // Returns a `const_reverse_iterator` from the end of the inlined vector.\n  const_reverse_iterator crbegin() const noexcept\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return rbegin();\n  }\n\n  // `InlinedVector::crend()`\n  //\n  // Returns a `const_reverse_iterator` from the beginning of the inlined\n  // vector.\n  const_reverse_iterator crend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return rend();\n  }\n\n  // `InlinedVector::get_allocator()`\n  //\n  // Returns a copy of the inlined vector's allocator.\n  allocator_type get_allocator() const { return storage_.GetAllocator(); }\n\n  // ---------------------------------------------------------------------------\n  // InlinedVector Member Mutators\n  // ---------------------------------------------------------------------------\n\n  // `InlinedVector::operator=(...)`\n  //\n  // Replaces the elements of the inlined vector with copies of the elements of\n  // `list`.\n  InlinedVector& operator=(std::initializer_list<value_type> list) {\n    assign(list.begin(), list.end());\n\n    return *this;\n  }\n\n  // Overload of `InlinedVector::operator=(...)` that replaces the elements of\n  // the inlined vector with copies of the elements of `other`.\n  InlinedVector& operator=(const InlinedVector& other) {\n    if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {\n      const_pointer other_data = other.data();\n      assign(other_data, other_data + other.size());\n    }\n\n    return *this;\n  }\n\n  // Overload of `InlinedVector::operator=(...)` that moves the elements of\n  // `other` into the inlined vector.\n  //\n  // NOTE: as a result of calling this overload, `other` is left in a valid but\n  // unspecified state.\n  InlinedVector& operator=(InlinedVector&& other) {\n    if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {\n      MoveAssignment(MoveAssignmentPolicy{}, std::move(other));\n    }\n\n    return *this;\n  }\n\n  // `InlinedVector::assign(...)`\n  //\n  // Replaces the contents of the inlined vector with `n` copies of `v`.\n  void assign(size_type n, const_reference v) {\n    storage_.Assign(CopyValueAdapter<A>(std::addressof(v)), n);\n  }\n\n  // Overload of `InlinedVector::assign(...)` that replaces the contents of the\n  // inlined vector with copies of the elements of `list`.\n  void assign(std::initializer_list<value_type> list) {\n    assign(list.begin(), list.end());\n  }\n\n  // Overload of `InlinedVector::assign(...)` to replace the contents of the\n  // inlined vector with the range [`first`, `last`).\n  //\n  // NOTE: this overload is for iterators that are \"forward\" category or better.\n  template <typename ForwardIterator,\n            EnableIfAtLeastForwardIterator<ForwardIterator> = 0>\n  void assign(ForwardIterator first, ForwardIterator last) {\n    storage_.Assign(IteratorValueAdapter<A, ForwardIterator>(first),\n                    static_cast<size_t>(std::distance(first, last)));\n  }\n\n  // Overload of `InlinedVector::assign(...)` to replace the contents of the\n  // inlined vector with the range [`first`, `last`).\n  //\n  // NOTE: this overload is for iterators that are \"input\" category.\n  template <typename InputIterator,\n            DisableIfAtLeastForwardIterator<InputIterator> = 0>\n  void assign(InputIterator first, InputIterator last) {\n    size_type i = 0;\n    for (; i < size() && first != last; ++i, static_cast<void>(++first)) {\n      data()[i] = *first;\n    }\n\n    erase(data() + i, data() + size());\n    std::copy(first, last, std::back_inserter(*this));\n  }\n\n  // `InlinedVector::resize(...)`\n  //\n  // Resizes the inlined vector to contain `n` elements.\n  //\n  // NOTE: If `n` is smaller than `size()`, extra elements are destroyed. If `n`\n  // is larger than `size()`, new elements are value-initialized.\n  void resize(size_type n) {\n    ABSL_HARDENING_ASSERT(n <= max_size());\n    storage_.Resize(DefaultValueAdapter<A>(), n);\n  }\n\n  // Overload of `InlinedVector::resize(...)` that resizes the inlined vector to\n  // contain `n` elements.\n  //\n  // NOTE: if `n` is smaller than `size()`, extra elements are destroyed. If `n`\n  // is larger than `size()`, new elements are copied-constructed from `v`.\n  void resize(size_type n, const_reference v) {\n    ABSL_HARDENING_ASSERT(n <= max_size());\n    storage_.Resize(CopyValueAdapter<A>(std::addressof(v)), n);\n  }\n\n  // `InlinedVector::insert(...)`\n  //\n  // Inserts a copy of `v` at `pos`, returning an `iterator` to the newly\n  // inserted element.\n  iterator insert(const_iterator pos,\n                  const_reference v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return emplace(pos, v);\n  }\n\n  // Overload of `InlinedVector::insert(...)` that inserts `v` at `pos` using\n  // move semantics, returning an `iterator` to the newly inserted element.\n  iterator insert(const_iterator pos,\n                  value_type&& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return emplace(pos, std::move(v));\n  }\n\n  // Overload of `InlinedVector::insert(...)` that inserts `n` contiguous copies\n  // of `v` starting at `pos`, returning an `iterator` pointing to the first of\n  // the newly inserted elements.\n  iterator insert(const_iterator pos, size_type n,\n                  const_reference v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(pos >= begin());\n    ABSL_HARDENING_ASSERT(pos <= end());\n\n    if (ABSL_PREDICT_TRUE(n != 0)) {\n      value_type dealias = v;\n      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102329#c2\n      // It appears that GCC thinks that since `pos` is a const pointer and may\n      // point to uninitialized memory at this point, a warning should be\n      // issued. But `pos` is actually only used to compute an array index to\n      // write to.\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n      return storage_.Insert(pos, CopyValueAdapter<A>(std::addressof(dealias)),\n                             n);\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n    } else {\n      return const_cast<iterator>(pos);\n    }\n  }\n\n  // Overload of `InlinedVector::insert(...)` that inserts copies of the\n  // elements of `list` starting at `pos`, returning an `iterator` pointing to\n  // the first of the newly inserted elements.\n  iterator insert(const_iterator pos, std::initializer_list<value_type> list)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert(pos, list.begin(), list.end());\n  }\n\n  // Overload of `InlinedVector::insert(...)` that inserts the range [`first`,\n  // `last`) starting at `pos`, returning an `iterator` pointing to the first\n  // of the newly inserted elements.\n  //\n  // NOTE: this overload is for iterators that are \"forward\" category or better.\n  template <typename ForwardIterator,\n            EnableIfAtLeastForwardIterator<ForwardIterator> = 0>\n  iterator insert(const_iterator pos, ForwardIterator first,\n                  ForwardIterator last) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(pos >= begin());\n    ABSL_HARDENING_ASSERT(pos <= end());\n\n    if (ABSL_PREDICT_TRUE(first != last)) {\n      return storage_.Insert(\n          pos, IteratorValueAdapter<A, ForwardIterator>(first),\n          static_cast<size_type>(std::distance(first, last)));\n    } else {\n      return const_cast<iterator>(pos);\n    }\n  }\n\n  // Overload of `InlinedVector::insert(...)` that inserts the range [`first`,\n  // `last`) starting at `pos`, returning an `iterator` pointing to the first\n  // of the newly inserted elements.\n  //\n  // NOTE: this overload is for iterators that are \"input\" category.\n  template <typename InputIterator,\n            DisableIfAtLeastForwardIterator<InputIterator> = 0>\n  iterator insert(const_iterator pos, InputIterator first,\n                  InputIterator last) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(pos >= begin());\n    ABSL_HARDENING_ASSERT(pos <= end());\n\n    size_type index = static_cast<size_type>(std::distance(cbegin(), pos));\n    for (size_type i = index; first != last; ++i, static_cast<void>(++first)) {\n      insert(data() + i, *first);\n    }\n\n    return iterator(data() + index);\n  }\n\n  // `InlinedVector::emplace(...)`\n  //\n  // Constructs and inserts an element using `args...` in the inlined vector at\n  // `pos`, returning an `iterator` pointing to the newly emplaced element.\n  template <typename... Args>\n  iterator emplace(const_iterator pos,\n                   Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(pos >= begin());\n    ABSL_HARDENING_ASSERT(pos <= end());\n\n    value_type dealias(std::forward<Args>(args)...);\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102329#c2\n    // It appears that GCC thinks that since `pos` is a const pointer and may\n    // point to uninitialized memory at this point, a warning should be\n    // issued. But `pos` is actually only used to compute an array index to\n    // write to.\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n    return storage_.Insert(pos,\n                           IteratorValueAdapter<A, MoveIterator<A>>(\n                               MoveIterator<A>(std::addressof(dealias))),\n                           1);\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n  }\n\n  // `InlinedVector::emplace_back(...)`\n  //\n  // Constructs and inserts an element using `args...` in the inlined vector at\n  // `end()`, returning a `reference` to the newly emplaced element.\n  template <typename... Args>\n  reference emplace_back(Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return storage_.EmplaceBack(std::forward<Args>(args)...);\n  }\n\n  // `InlinedVector::push_back(...)`\n  //\n  // Inserts a copy of `v` in the inlined vector at `end()`.\n  void push_back(const_reference v) { static_cast<void>(emplace_back(v)); }\n\n  // Overload of `InlinedVector::push_back(...)` for inserting `v` at `end()`\n  // using move semantics.\n  void push_back(value_type&& v) {\n    static_cast<void>(emplace_back(std::move(v)));\n  }\n\n  // `InlinedVector::pop_back()`\n  //\n  // Destroys the element at `back()`, reducing the size by `1`.\n  void pop_back() noexcept {\n    ABSL_HARDENING_ASSERT(!empty());\n\n    AllocatorTraits<A>::destroy(storage_.GetAllocator(), data() + (size() - 1));\n    storage_.SubtractSize(1);\n  }\n\n  // `InlinedVector::erase(...)`\n  //\n  // Erases the element at `pos`, returning an `iterator` pointing to where the\n  // erased element was located.\n  //\n  // NOTE: may return `end()`, which is not dereferenceable.\n  iterator erase(const_iterator pos) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(pos >= begin());\n    ABSL_HARDENING_ASSERT(pos < end());\n\n    return storage_.Erase(pos, pos + 1);\n  }\n\n  // Overload of `InlinedVector::erase(...)` that erases every element in the\n  // range [`from`, `to`), returning an `iterator` pointing to where the first\n  // erased element was located.\n  //\n  // NOTE: may return `end()`, which is not dereferenceable.\n  iterator erase(const_iterator from,\n                 const_iterator to) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    ABSL_HARDENING_ASSERT(from >= begin());\n    ABSL_HARDENING_ASSERT(from <= to);\n    ABSL_HARDENING_ASSERT(to <= end());\n\n    if (ABSL_PREDICT_TRUE(from != to)) {\n      return storage_.Erase(from, to);\n    } else {\n      return const_cast<iterator>(from);\n    }\n  }\n\n  // `InlinedVector::clear()`\n  //\n  // Destroys all elements in the inlined vector, setting the size to `0` and\n  // deallocating any held memory.\n  void clear() noexcept {\n    inlined_vector_internal::DestroyAdapter<A>::DestroyElements(\n        storage_.GetAllocator(), data(), size());\n    storage_.DeallocateIfAllocated();\n\n    storage_.SetInlinedSize(0);\n  }\n\n  // `InlinedVector::reserve(...)`\n  //\n  // Ensures that there is enough room for at least `n` elements.\n  void reserve(size_type n) { storage_.Reserve(n); }\n\n  // `InlinedVector::shrink_to_fit()`\n  //\n  // Attempts to reduce memory usage by moving elements to (or keeping elements\n  // in) the smallest available buffer sufficient for containing `size()`\n  // elements.\n  //\n  // If `size()` is sufficiently small, the elements will be moved into (or kept\n  // in) the inlined space.\n  void shrink_to_fit() {\n    if (storage_.GetIsAllocated()) {\n      storage_.ShrinkToFit();\n    }\n  }\n\n  // `InlinedVector::swap(...)`\n  //\n  // Swaps the contents of the inlined vector with `other`.\n  void swap(InlinedVector& other) {\n    if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {\n      storage_.Swap(std::addressof(other.storage_));\n    }\n  }\n\n private:\n  template <typename H, typename TheT, size_t TheN, typename TheA>\n  friend H AbslHashValue(H h, const absl::InlinedVector<TheT, TheN, TheA>& a);\n\n  void MoveAssignment(MemcpyPolicy, InlinedVector&& other) {\n    // Assumption check: we shouldn't be told to use memcpy to implement move\n    // assignment unless we have trivially destructible elements and an\n    // allocator that does nothing fancy.\n    static_assert(absl::is_trivially_destructible<value_type>::value, \"\");\n    static_assert(std::is_same<A, std::allocator<value_type>>::value, \"\");\n\n    // Throw away our existing heap allocation, if any. There is no need to\n    // destroy the existing elements one by one because we know they are\n    // trivially destructible.\n    storage_.DeallocateIfAllocated();\n\n    // Adopt the other vector's inline elements or heap allocation.\n    storage_.MemcpyFrom(other.storage_);\n    other.storage_.SetInlinedSize(0);\n  }\n\n  // Destroy our existing elements, if any, and adopt the heap-allocated\n  // elements of the other vector.\n  //\n  // REQUIRES: other.storage_.GetIsAllocated()\n  void DestroyExistingAndAdopt(InlinedVector&& other) {\n    ABSL_HARDENING_ASSERT(other.storage_.GetIsAllocated());\n\n    inlined_vector_internal::DestroyAdapter<A>::DestroyElements(\n        storage_.GetAllocator(), data(), size());\n    storage_.DeallocateIfAllocated();\n\n    storage_.MemcpyFrom(other.storage_);\n    other.storage_.SetInlinedSize(0);\n  }\n\n  void MoveAssignment(ElementwiseAssignPolicy, InlinedVector&& other) {\n    // Fast path: if the other vector is on the heap then we don't worry about\n    // actually move-assigning each element. Instead we only throw away our own\n    // existing elements and adopt the heap allocation of the other vector.\n    if (other.storage_.GetIsAllocated()) {\n      DestroyExistingAndAdopt(std::move(other));\n      return;\n    }\n\n    storage_.Assign(IteratorValueAdapter<A, MoveIterator<A>>(\n                        MoveIterator<A>(other.storage_.GetInlinedData())),\n                    other.size());\n  }\n\n  void MoveAssignment(ElementwiseConstructPolicy, InlinedVector&& other) {\n    // Fast path: if the other vector is on the heap then we don't worry about\n    // actually move-assigning each element. Instead we only throw away our own\n    // existing elements and adopt the heap allocation of the other vector.\n    if (other.storage_.GetIsAllocated()) {\n      DestroyExistingAndAdopt(std::move(other));\n      return;\n    }\n\n    inlined_vector_internal::DestroyAdapter<A>::DestroyElements(\n        storage_.GetAllocator(), data(), size());\n    storage_.DeallocateIfAllocated();\n\n    IteratorValueAdapter<A, MoveIterator<A>> other_values(\n        MoveIterator<A>(other.storage_.GetInlinedData()));\n    inlined_vector_internal::ConstructElements<A>(\n        storage_.GetAllocator(), storage_.GetInlinedData(), other_values,\n        other.storage_.GetSize());\n    storage_.SetInlinedSize(other.storage_.GetSize());\n  }\n\n  Storage storage_;\n}",
  "id": "BLOCK-CPP-03551",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/inlined_vector.h",
  "source_line": 70,
  "validation_status": "validated"
}