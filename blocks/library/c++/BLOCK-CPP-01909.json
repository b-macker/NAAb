{
  "code": "{\nnamespace {\n\n// Accounting mode for analyzing memory usage.\nenum class Mode { kFairShare, kTotal, kTotalMorePrecise };\n\n// CordRepRef holds a `const CordRep*` reference in rep, and depending on mode,\n// holds a 'fraction' representing a cumulative inverse refcount weight.\ntemplate <Mode mode>\nstruct CordRepRef {\n  // Instantiates a CordRepRef instance.\n  explicit CordRepRef(absl::Nonnull<const CordRep*> r) : rep(r) {}\n\n  // Creates a child reference holding the provided child.\n  // Overloaded to add cumulative reference count for kFairShare.\n  CordRepRef Child(absl::Nonnull<const CordRep*> child) const {\n    return CordRepRef(child);\n  }\n\n  absl::Nonnull<const CordRep*> rep;\n};\n\n// RawUsage holds the computed total number of bytes.\ntemplate <Mode mode>\nstruct RawUsage {\n  size_t total = 0;\n\n  // Add 'size' to total, ignoring the CordRepRef argument.\n  void Add(size_t size, CordRepRef<mode>) { total += size; }\n};\n\n// Overloaded representation of RawUsage that tracks the set of objects\n// counted, and avoids double-counting objects referenced more than once\n// by the same Cord.\ntemplate <>\nstruct RawUsage<Mode::kTotalMorePrecise> {\n  size_t total = 0;\n  // TODO(b/289250880): Replace this with a flat_hash_set.\n  std::unordered_set<absl::Nonnull<const CordRep*>> counted;\n\n  void Add(size_t size, CordRepRef<Mode::kTotalMorePrecise> repref) {\n    if (counted.insert(repref.rep).second) {\n      total += size;\n    }\n  }\n};\n\n// Returns n / refcount avoiding a div for the common refcount == 1.\ntemplate <typename refcount_t>\ndouble MaybeDiv(double d, refcount_t refcount) {\n  return refcount == 1 ? d : d / refcount;\n}\n\n// Overloaded 'kFairShare' specialization for CordRepRef. This class holds a\n// `fraction` value which represents a cumulative inverse refcount weight.\n// For example, a top node with a reference count of 2 will have a fraction\n// value of 1/2 = 0.5, representing the 'fair share' of memory it references.\n// A node below such a node with a reference count of 5 then has a fraction of\n// 0.5 / 5 = 0.1 representing the fair share of memory below that node, etc.\ntemplate <>\nstruct CordRepRef<Mode::kFairShare> {\n  // Creates a CordRepRef with the provided rep and top (parent) fraction.\n  explicit CordRepRef(absl::Nonnull<const CordRep*> r, double frac = 1.0)\n      : rep(r), fraction(MaybeDiv(frac, r->refcount.Get())) {}\n\n  // Returns a CordRepRef with a fraction of `this->fraction / child.refcount`\n  CordRepRef Child(absl::Nonnull<const CordRep*> child) const {\n    return CordRepRef(child, fraction);\n  }\n\n  absl::Nonnull<const CordRep*> rep;\n  double fraction;\n};\n\n// Overloaded 'kFairShare' specialization for RawUsage\ntemplate <>\nstruct RawUsage<Mode::kFairShare> {\n  double total = 0;\n\n  // Adds `size` multiplied by `rep.fraction` to the total size.\n  void Add(size_t size, CordRepRef<Mode::kFairShare> rep) {\n    total += static_cast<double>(size) * rep.fraction;\n  }\n};\n\n// Computes the estimated memory size of the provided data edge.\n// External reps are assumed 'heap allocated at their exact size'.\ntemplate <Mode mode>\nvoid AnalyzeDataEdge(CordRepRef<mode> rep, RawUsage<mode>& raw_usage) {\n  assert(IsDataEdge(rep.rep));\n\n  // Consume all substrings\n  if (rep.rep->tag == SUBSTRING) {\n    raw_usage.Add(sizeof(CordRepSubstring), rep);\n    rep = rep.Child(rep.rep->substring()->child);\n  }\n\n  // Consume FLAT / EXTERNAL\n  const size_t size =\n      rep.rep->tag >= FLAT\n          ? rep.rep->flat()->AllocatedSize()\n          : rep.rep->length + sizeof(CordRepExternalImpl<intptr_t>);\n  raw_usage.Add(size, rep);\n}\n\n// Computes the memory size of the provided Btree tree.\ntemplate <Mode mode>\nvoid AnalyzeBtree(CordRepRef<mode> rep, RawUsage<mode>& raw_usage) {\n  raw_usage.Add(sizeof(CordRepBtree), rep);\n  const CordRepBtree* tree = rep.rep->btree();\n  if (tree->height() > 0) {\n    for (CordRep* edge : tree->Edges()) {\n      AnalyzeBtree(rep.Child(edge), raw_usage);\n    }\n  } else {\n    for (CordRep* edge : tree->Edges()) {\n      AnalyzeDataEdge(rep.Child(edge), raw_usage);\n    }\n  }\n}\n\ntemplate <Mode mode>\nsize_t GetEstimatedUsage(absl::Nonnull<const CordRep*> rep) {\n  // Zero initialized memory usage totals.\n  RawUsage<mode> raw_usage;\n\n  // Capture top level node and refcount into a CordRepRef.\n  CordRepRef<mode> repref(rep);\n\n  // Consume the top level CRC node if present.\n  if (repref.rep->tag == CRC) {\n    raw_usage.Add(sizeof(CordRepCrc), repref);\n    if (repref.rep->crc()->child == nullptr) {\n      return static_cast<size_t>(raw_usage.total);\n    }\n    repref = repref.Child(repref.rep->crc()->child);\n  }\n\n  if (IsDataEdge(repref.rep)) {\n    AnalyzeDataEdge(repref, raw_usage);\n  } else if (repref.rep->tag == BTREE) {\n    AnalyzeBtree(repref, raw_usage);\n  } else {\n    assert(false);\n  }\n\n  return static_cast<size_t>(raw_usage.total);\n}\n\n}  // namespace\n\nsize_t GetEstimatedMemoryUsage(absl::Nonnull<const CordRep*> rep) {\n  return GetEstimatedUsage<Mode::kTotal>(rep);\n}\n\nsize_t GetEstimatedFairShareMemoryUsage(absl::Nonnull<const CordRep*> rep) {\n  return GetEstimatedUsage<Mode::kFairShare>(rep);\n}\n\nsize_t GetMorePreciseMemoryUsage(absl::Nonnull<const CordRep*> rep) {\n  return GetEstimatedUsage<Mode::kTotalMorePrecise>(rep);\n}\n\n}",
  "id": "BLOCK-CPP-01909",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/cord_analysis.cc",
  "source_line": 31,
  "validation_status": "validated"
}