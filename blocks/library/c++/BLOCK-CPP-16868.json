{
  "code": "{\n  friend class ASTReader;\n  friend class ASTWriter;\n  friend class SourceManager;\n  friend struct llvm::FoldingSetTrait<SourceLocation, void>;\n\npublic:\n  using UIntTy = uint32_t;\n  using IntTy = int32_t;\n\nprivate:\n  UIntTy ID = 0;\n\n  enum : UIntTy { MacroIDBit = 1ULL << (8 * sizeof(UIntTy) - 1) };\n\npublic:\n  bool isFileID() const  { return (ID & MacroIDBit) == 0; }\n  bool isMacroID() const { return (ID & MacroIDBit) != 0; }\n\n  /// Return true if this is a valid SourceLocation object.\n  ///\n  /// Invalid SourceLocations are often used when events have no corresponding\n  /// location in the source (e.g. a diagnostic is required for a command line\n  /// option).\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\nprivate:\n  /// Return the offset into the manager's global input view.\n  UIntTy getOffset() const { return ID & ~MacroIDBit; }\n\n  static SourceLocation getFileLoc(UIntTy ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = ID;\n    return L;\n  }\n\n  static SourceLocation getMacroLoc(UIntTy ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = MacroIDBit | ID;\n    return L;\n  }\n\npublic:\n  /// Return a source location with the specified offset from this\n  /// SourceLocation.\n  SourceLocation getLocWithOffset(IntTy Offset) const {\n    assert(((getOffset()+Offset) & MacroIDBit) == 0 && \"offset overflow\");\n    SourceLocation L;\n    L.ID = ID+Offset;\n    return L;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) 32-bit integer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromRawEncoding, it\n  /// should not be inspected directly.\n  UIntTy getRawEncoding() const { return ID; }\n\n  /// Turn a raw encoding of a SourceLocation object into\n  /// a real SourceLocation.\n  ///\n  /// \\see getRawEncoding.\n  static SourceLocation getFromRawEncoding(UIntTy Encoding) {\n    SourceLocation X;\n    X.ID = Encoding;\n    return X;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) pointer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromPtrEncoding, it\n  /// should not be inspected directly.\n  void* getPtrEncoding() const {\n    // Double cast to avoid a warning \"cast to pointer from integer of different\n    // size\".\n    return (void*)(uintptr_t)getRawEncoding();\n  }\n\n  /// Turn a pointer encoding of a SourceLocation object back\n  /// into a real SourceLocation.\n  static SourceLocation getFromPtrEncoding(const void *Encoding) {\n    return getFromRawEncoding((SourceLocation::UIntTy)(uintptr_t)Encoding);\n  }\n\n  static bool isPairOfFileLocations(SourceLocation Start, SourceLocation End) {\n    return Start.isValid() && Start.isFileID() && End.isValid() &&\n           End.isFileID();\n  }\n\n  unsigned getHashValue() const;\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n}",
  "id": "BLOCK-CPP-16868",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceLocation.h",
  "source_line": 86,
  "validation_status": "validated"
}