{
  "code": "{\nclass ASTMergeAction;\nclass CompilerInstance;\n\n/// Abstract base class for actions which can be performed by the frontend.\nclass FrontendAction {\n  FrontendInputFile CurrentInput;\n  std::unique_ptr<ASTUnit> CurrentASTUnit;\n  CompilerInstance *Instance;\n  friend class ASTMergeAction;\n  friend class WrapperFrontendAction;\n\nprivate:\n  std::unique_ptr<ASTConsumer> CreateWrappedASTConsumer(CompilerInstance &CI,\n                                                        StringRef InFile);\n\nprotected:\n  /// @name Implementation Action Interface\n  /// @{\n\n  /// Prepare to execute the action on the given CompilerInstance.\n  ///\n  /// This is called before executing the action on any inputs, and can modify\n  /// the configuration as needed (including adjusting the input list).\n  virtual bool PrepareToExecuteAction(CompilerInstance &CI) { return true; }\n\n  /// Create the AST consumer object for this action, if supported.\n  ///\n  /// This routine is called as part of BeginSourceFile(), which will\n  /// fail if the AST consumer cannot be created. This will not be called if the\n  /// action has indicated that it only uses the preprocessor.\n  ///\n  /// \\param CI - The current compiler instance, provided as a convenience, see\n  /// getCompilerInstance().\n  ///\n  /// \\param InFile - The current input file, provided as a convenience, see\n  /// getCurrentFile().\n  ///\n  /// \\return The new AST consumer, or null on failure.\n  virtual std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                         StringRef InFile) = 0;\n\n  /// Callback before starting processing a single input, giving the\n  /// opportunity to modify the CompilerInvocation or do some other action\n  /// before BeginSourceFileAction is called.\n  ///\n  /// \\return True on success; on failure BeginSourceFileAction(),\n  /// ExecuteAction() and EndSourceFileAction() will not be called.\n  virtual bool BeginInvocation(CompilerInstance &CI) { return true; }\n\n  /// Callback at the start of processing a single input.\n  ///\n  /// \\return True on success; on failure ExecutionAction() and\n  /// EndSourceFileAction() will not be called.\n  virtual bool BeginSourceFileAction(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Callback to run the program action, using the initialized\n  /// compiler instance.\n  ///\n  /// This is guaranteed to only be called between BeginSourceFileAction()\n  /// and EndSourceFileAction().\n  virtual void ExecuteAction() = 0;\n\n  /// Callback at the end of processing a single input.\n  ///\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual void EndSourceFileAction() {}\n\n  /// Callback at the end of processing a single input, to determine\n  /// if the output files should be erased or not.\n  ///\n  /// By default it returns true if a compiler error occurred.\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual bool shouldEraseOutputFiles();\n\n  /// @}\n\npublic:\n  FrontendAction();\n  virtual ~FrontendAction();\n\n  /// @name Compiler Instance Access\n  /// @{\n\n  CompilerInstance &getCompilerInstance() const {\n    assert(Instance && \"Compiler instance not registered!\");\n    return *Instance;\n  }\n\n  void setCompilerInstance(CompilerInstance *Value) { Instance = Value; }\n\n  /// @}\n  /// @name Current File Information\n  /// @{\n\n  bool isCurrentFileAST() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return (bool)CurrentASTUnit;\n  }\n\n  const FrontendInputFile &getCurrentInput() const {\n    return CurrentInput;\n  }\n\n  StringRef getCurrentFile() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getFile();\n  }\n\n  StringRef getCurrentFileOrBufferName() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.isFile()\n               ? CurrentInput.getFile()\n               : CurrentInput.getBuffer().getBufferIdentifier();\n  }\n\n  InputKind getCurrentFileKind() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getKind();\n  }\n\n  ASTUnit &getCurrentASTUnit() const {\n    assert(CurrentASTUnit && \"No current AST unit!\");\n    return *CurrentASTUnit;\n  }\n\n  Module *getCurrentModule() const;\n\n  std::unique_ptr<ASTUnit> takeCurrentASTUnit() {\n    return std::move(CurrentASTUnit);\n  }\n\n  void setCurrentInput(const FrontendInputFile &CurrentInput,\n                       std::unique_ptr<ASTUnit> AST = nullptr);\n\n  /// @}\n  /// @name Supported Modes\n  /// @{\n\n  /// Is this action invoked on a model file?\n  ///\n  /// Model files are incomplete translation units that relies on type\n  /// information from another translation unit. Check ParseModelFileAction for\n  /// details.\n  virtual bool isModelParsingAction() const { return false; }\n\n  /// Does this action only use the preprocessor?\n  ///\n  /// If so no AST context will be created and this action will be invalid\n  /// with AST file inputs.\n  virtual bool usesPreprocessorOnly() const = 0;\n\n  /// For AST-based actions, the kind of translation unit we're handling.\n  virtual TranslationUnitKind getTranslationUnitKind() { return TU_Complete; }\n\n  /// Does this action support use with PCH?\n  virtual bool hasPCHSupport() const { return true; }\n\n  /// Does this action support use with AST files?\n  virtual bool hasASTFileSupport() const { return true; }\n\n  /// Does this action support use with IR files?\n  virtual bool hasIRSupport() const { return false; }\n\n  /// Does this action support use with code completion?\n  virtual bool hasCodeCompletionSupport() const { return false; }\n\n  /// @}\n  /// @name Public Action Interface\n  /// @{\n\n  /// Prepare the action to execute on the given compiler instance.\n  bool PrepareToExecute(CompilerInstance &CI) {\n    return PrepareToExecuteAction(CI);\n  }\n\n  /// Prepare the action for processing the input file \\p Input.\n  ///\n  /// This is run after the options and frontend have been initialized,\n  /// but prior to executing any per-file processing.\n  ///\n  /// \\param CI - The compiler instance this action is being run from. The\n  /// action may store and use this object up until the matching EndSourceFile\n  /// action.\n  ///\n  /// \\param Input - The input filename and kind. Some input kinds are handled\n  /// specially, for example AST inputs, since the AST file itself contains\n  /// several objects which would normally be owned by the\n  /// CompilerInstance. When processing AST input files, these objects should\n  /// generally not be initialized in the CompilerInstance -- they will\n  /// automatically be shared with the AST file in between\n  /// BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\return True on success; on failure the compilation of this file should\n  /// be aborted and neither Execute() nor EndSourceFile() should be called.\n  bool BeginSourceFile(CompilerInstance &CI, const FrontendInputFile &Input);\n\n  /// Set the source manager's main input file, and run the action.\n  llvm::Error Execute();\n\n  /// Perform any per-file post processing, deallocate per-file\n  /// objects, and run statistics and output file cleanup code.\n  virtual void EndSourceFile();\n\n  /// @}\n};\n\n/// Abstract base class to use for AST consumer-based frontend actions.\nclass ASTFrontendAction : public FrontendAction {\nprotected:\n  /// Implement the ExecuteAction interface by running Sema on\n  /// the already-initialized AST consumer.\n  ///\n  /// This will also take care of instantiating a code completion consumer if\n  /// the user requested it and the action supports it.\n  void ExecuteAction() override;\n\npublic:\n  ASTFrontendAction() {}\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\nclass PluginASTAction : public ASTFrontendAction {\n  virtual void anchor();\npublic:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override = 0;\n\n  /// Parse the given plugin command line arguments.\n  ///\n  /// \\param CI - The compiler instance, for use in reporting diagnostics.\n  /// \\return True if the parsing succeeded; otherwise the plugin will be\n  /// destroyed and no action run. The plugin is responsible for using the\n  /// CompilerInstance's Diagnostic object to report errors.\n  virtual bool ParseArgs(const CompilerInstance &CI,\n                         const std::vector<std::string> &arg) = 0;\n\n  enum ActionType {\n    CmdlineBeforeMainAction, ///< Execute the action before the main action if\n                             ///< on the command line\n    CmdlineAfterMainAction,  ///< Execute the action after the main action if on\n                             ///< the command line\n    ReplaceAction,           ///< Replace the main action\n    AddBeforeMainAction,     ///< Execute the action before the main action\n    AddAfterMainAction       ///< Execute the action after the main action\n  };\n  /// Get the action type for this plugin\n  ///\n  /// \\return The action type. By default we use CmdlineAfterMainAction.\n  virtual ActionType getActionType() { return CmdlineAfterMainAction; }\n};\n\n/// Abstract base class to use for preprocessor-based frontend actions.\nclass PreprocessorFrontendAction : public FrontendAction {\nprotected:\n  /// Provide a default implementation which returns aborts;\n  /// this method should never be called by FrontendAction clients.\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n/// A frontend action which simply wraps some other runtime-specified\n/// frontend action.\n///\n/// Deriving from this class allows an action to inject custom logic around\n/// some existing action's behavior. It implements every virtual method in\n/// the FrontendAction interface by forwarding to the wrapped action.\nclass WrapperFrontendAction : public FrontendAction {\nprotected:\n  std::unique_ptr<FrontendAction> WrappedAction;\n\n  bool PrepareToExecuteAction(CompilerInstance &CI) override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n  bool BeginInvocation(CompilerInstance &CI) override;\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n  void ExecuteAction() override;\n  void EndSourceFile() override;\n  void EndSourceFileAction() override;\n  bool shouldEraseOutputFiles() override;\n\npublic:\n  /// Construct a WrapperFrontendAction from an existing action, taking\n  /// ownership of it.\n  WrapperFrontendAction(std::unique_ptr<FrontendAction> WrappedAction);\n\n  bool usesPreprocessorOnly() const override;\n  TranslationUnitKind getTranslationUnitKind() override;\n  bool hasPCHSupport() const override;\n  bool hasASTFileSupport() const override;\n  bool hasIRSupport() const override;\n  bool hasCodeCompletionSupport() const override;\n};\n\n}",
  "id": "BLOCK-CPP-18310",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/FrontendAction.h",
  "source_line": 31,
  "validation_status": "validated"
}