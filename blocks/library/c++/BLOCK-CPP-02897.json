{
  "code": "#include \"absl/strings/internal/cord_rep_btree_navigator.h\"\n#include <cassert>\n#include \"absl/strings/internal/cord_data_edge.h\"\n#include \"absl/strings/internal/cord_internal.h\"\n#include \"absl/strings/internal/cord_rep_btree.h\"\n\nusing namespace absl;\nusing namespace cord_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-02897_execute() {\n    {\n\nusing ReadResult = CordRepBtreeNavigator::ReadResult;\n\nnamespace {\n\n// Returns a `CordRepSubstring` from `rep` starting at `offset` of size `n`.\n// If `rep` is already a `CordRepSubstring` instance, an adjusted instance is\n// created based on the old offset and new offset.\n// Adopts a reference on `rep`. Rep must be a valid data edge. Returns\n// nullptr if `n == 0`, `rep` if `n == rep->length`.\n// Requires `offset < rep->length` and `offset + n <= rep->length`.\n// TODO(192061034): move to utility library in internal and optimize for small\n// substrings of larger reps.\ninline CordRep* Substring(CordRep* rep, size_t offset, size_t n) {\n  assert(n <= rep->length);\n  assert(offset < rep->length);\n  assert(offset <= rep->length - n);\n  assert(IsDataEdge(rep));\n\n  if (n == 0) return nullptr;\n  if (n == rep->length) return CordRep::Ref(rep);\n\n  if (rep->tag == SUBSTRING) {\n    offset += rep->substring()->start;\n    rep = rep->substring()->child;\n  }\n\n  assert(rep->IsExternal() || rep->IsFlat());\n  CordRepSubstring* substring = new CordRepSubstring();\n  substring->length = n;\n  substring->tag = SUBSTRING;\n  substring->start = offset;\n  substring->child = CordRep::Ref(rep);\n  return substring;\n}\n\ninline CordRep* Substring(CordRep* rep, size_t offset) {\n  return Substring(rep, offset, rep->length - offset);\n}\n\n}  // namespace\n\nCordRepBtreeNavigator::Position CordRepBtreeNavigator::Skip(size_t n) {\n  int height = 0;\n  size_t index = index_[0];\n  CordRepBtree* node = node_[0];\n  CordRep* edge = node->Edge(index);\n\n  // Overall logic: Find an edge of at least the length we need to skip.\n  // We consume all edges which are smaller (i.e., must be 100% skipped).\n  // If we exhausted all edges on the current level, we move one level\n  // up the tree, and repeat until we either find the edge, or until we hit\n  // the top of the tree meaning the skip exceeds tree->length.\n  while (n >= edge->length) {\n    n -= edge->length;\n    while (++index == node->end()) {\n      if (++height > height_) return {nullptr, n};\n      node = node_[height];\n      index = index_[height];\n    }\n    edge = node->Edge(index);\n  }\n\n  // If we moved up the tree, descend down to the leaf level, consuming all\n  // edges that must be skipped.\n  while (height > 0) {\n    node = edge->btree();\n    index_[height] = static_cast<uint8_t>(index);\n    node_[--height] = node;\n    index = node->begin();\n    edge = node->Edge(index);\n    while (n >= edge->length) {\n      n -= edge->length;\n      ++index;\n      assert(index != node->end());\n      edge = node->Edge(index);\n    }\n  }\n  index_[0] = static_cast<uint8_t>(index);\n  return {edge, n};\n}\n\nReadResult CordRepBtreeNavigator::Read(size_t edge_offset, size_t n) {\n  int height = 0;\n  size_t length = edge_offset + n;\n  size_t index = index_[0];\n  CordRepBtree* node = node_[0];\n  CordRep* edge = node->Edge(index);\n  assert(edge_offset < edge->length);\n\n  if (length < edge->length) {\n    return {Substring(edge, edge_offset, n), length};\n  }\n\n  // Similar to 'Skip', we consume all edges that are inside the 'length' of\n  // data that needs to be read. If we exhaust the current level, we move one\n  // level up the tree and repeat until we hit the final edge that must be\n  // (partially) read. We consume all edges into `subtree`.\n  CordRepBtree* subtree = CordRepBtree::New(Substring(edge, edge_offset));\n  size_t subtree_end = 1;\n  do {\n    length -= edge->length;\n    while (++index == node->end()) {\n      index_[height] = static_cast<uint8_t>(index);\n      if (++height > height_) {\n        subtree->set_end(subtree_end);\n        if (length == 0) return {subtree, 0};\n        CordRep::Unref(subtree);\n        return {nullptr, length};\n      }\n      if (length != 0) {\n        subtree->set_end(subtree_end);\n        subtree = CordRepBtree::New(subtree);\n        subtree_end = 1;\n      }\n      node = node_[height];\n      index = index_[height];\n    }\n    edge = node->Edge(index);\n    if (length >= edge->length) {\n      subtree->length += edge->length;\n      subtree->edges_[subtree_end++] = CordRep::Ref(edge);\n    }\n  } while (length >= edge->length);\n  CordRepBtree* tree = subtree;\n  subtree->length += length;\n\n  // If we moved up the tree, descend down to the leaf level, consuming all\n  // edges that must be read, adding 'down' nodes to `subtree`.\n  while (height > 0) {\n    node = edge->btree();\n    index_[height] = static_cast<uint8_t>(index);\n    node_[--height] = node;\n    index = node->begin();\n    edge = node->Edge(index);\n\n    if (length != 0) {\n      CordRepBtree* right = CordRepBtree::New(height);\n      right->length = length;\n      subtree->edges_[subtree_end++] = right;\n      subtree->set_end(subtree_end);\n      subtree = right;\n      subtree_end = 0;\n      while (length >= edge->length) {\n        subtree->edges_[subtree_end++] = CordRep::Ref(edge);\n        length -= edge->length;\n        edge = node->Edge(++index);\n      }\n    }\n  }\n  // Add any (partial) edge still remaining at the leaf level.\n  if (length != 0) {\n    subtree->edges_[subtree_end++] = Substring(edge, 0, length);\n  }\n  subtree->set_end(subtree_end);\n  index_[0] = static_cast<uint8_t>(index);\n  return {tree, length};\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-02897",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree_navigator.cc",
  "source_line": 25,
  "validation_status": "validated"
}