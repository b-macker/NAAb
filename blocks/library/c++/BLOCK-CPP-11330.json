{
  "code": "#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <utility>\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-11330_execute() {\n    {\n  /// Enumeration describing\n  enum StoredSpecifierKind {\n    StoredIdentifier = 0,\n    StoredDecl = 1,\n    StoredTypeSpec = 2,\n    StoredTypeSpecWithTemplate = 3\n  };\n\n  /// The nested name specifier that precedes this nested name\n  /// specifier.\n  ///\n  /// The pointer is the nested-name-specifier that precedes this\n  /// one. The integer stores one of the first four values of type\n  /// SpecifierKind.\n  llvm::PointerIntPair<NestedNameSpecifier *, 2, StoredSpecifierKind> Prefix;\n\n  /// The last component in the nested name specifier, which\n  /// can be an identifier, a declaration, or a type.\n  ///\n  /// When the pointer is NULL, this specifier represents the global\n  /// specifier '::'. Otherwise, the pointer is one of\n  /// IdentifierInfo*, Namespace*, or Type*, depending on the kind of\n  /// specifier as encoded within the prefix.\n  void* Specifier = nullptr;\n\npublic:\n  /// The kind of specifier that completes this nested name\n  /// specifier.\n  enum SpecifierKind {\n    /// An identifier, stored as an IdentifierInfo*.\n    Identifier,\n\n    /// A namespace, stored as a NamespaceDecl*.\n    Namespace,\n\n    /// A namespace alias, stored as a NamespaceAliasDecl*.\n    NamespaceAlias,\n\n    /// A type, stored as a Type*.\n    TypeSpec,\n\n    /// A type that was preceded by the 'template' keyword,\n    /// stored as a Type*.\n    TypeSpecWithTemplate,\n\n    /// The global specifier '::'. There is no stored value.\n    Global,\n\n    /// Microsoft's '__super' specifier, stored as a CXXRecordDecl* of\n    /// the class it appeared in.\n    Super\n  };\n\nprivate:\n  /// Builds the global specifier.\n  NestedNameSpecifier() : Prefix(nullptr, StoredIdentifier) {}\n\n  /// Copy constructor used internally to clone nested name\n  /// specifiers.\n  NestedNameSpecifier(const NestedNameSpecifier &Other) = default;\n\n  /// Either find or insert the given nested name specifier\n  /// mockup in the given context.\n  static NestedNameSpecifier *FindOrInsert(const ASTContext &Context,\n                                           const NestedNameSpecifier &Mockup);\n\npublic:\n  NestedNameSpecifier &operator=(const NestedNameSpecifier &) = delete;\n\n  /// Builds a specifier combining a prefix and an identifier.\n  ///\n  /// The prefix must be dependent, since nested name specifiers\n  /// referencing an identifier are only permitted when the identifier\n  /// cannot be resolved.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     IdentifierInfo *II);\n\n  /// Builds a nested name specifier that names a namespace.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     const NamespaceDecl *NS);\n\n  /// Builds a nested name specifier that names a namespace alias.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     NamespaceAliasDecl *Alias);\n\n  /// Builds a nested name specifier that names a type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     bool Template, const Type *T);\n\n  /// Builds a specifier that consists of just an identifier.\n  ///\n  /// The nested-name-specifier is assumed to be dependent, but has no\n  /// prefix because the prefix is implied by something outside of the\n  /// nested name specifier, e.g., in \"x->Base::f\", the \"x\" has a dependent\n  /// type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     IdentifierInfo *II);\n\n  /// Returns the nested name specifier representing the global\n  /// scope.\n  static NestedNameSpecifier *GlobalSpecifier(const ASTContext &Context);\n\n  /// Returns the nested name specifier representing the __super scope\n  /// for the given CXXRecordDecl.\n  static NestedNameSpecifier *SuperSpecifier(const ASTContext &Context,\n                                             CXXRecordDecl *RD);\n\n  /// Return the prefix of this nested name specifier.\n  ///\n  /// The prefix contains all of the parts of the nested name\n  /// specifier that precede this current specifier. For example, for a\n  /// nested name specifier that represents \"foo::bar::\", the current\n  /// specifier will contain \"bar::\" and the prefix will contain\n  /// \"foo::\".\n  NestedNameSpecifier *getPrefix() const { return Prefix.getPointer(); }\n\n  /// Determine what kind of nested name specifier is stored.\n  SpecifierKind getKind() const;\n\n  /// Retrieve the identifier stored in this nested name\n  /// specifier.\n  IdentifierInfo *getAsIdentifier() const {\n    if (Prefix.getInt() == StoredIdentifier)\n      return (IdentifierInfo *)Specifier;\n\n    return nullptr;\n  }\n\n  /// Retrieve the namespace stored in this nested name\n  /// specifier.\n  NamespaceDecl *getAsNamespace() const;\n\n  /// Retrieve the namespace alias stored in this nested name\n  /// specifier.\n  NamespaceAliasDecl *getAsNamespaceAlias() const;\n\n  /// Retrieve the record declaration stored in this nested name\n  /// specifier.\n  CXXRecordDecl *getAsRecordDecl() const;\n\n  /// Retrieve the type stored in this nested name specifier.\n  const Type *getAsType() const {\n    if (Prefix.getInt() == StoredTypeSpec ||\n        Prefix.getInt() == StoredTypeSpecWithTemplate)\n      return (const Type *)Specifier;\n\n    return nullptr;\n  }\n\n  NestedNameSpecifierDependence getDependence() const;\n\n  /// Whether this nested name specifier refers to a dependent\n  /// type or not.\n  bool isDependent() const;\n\n  /// Whether this nested name specifier involves a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this nested-name-specifier contains an unexpanded\n  /// parameter pack (for C++11 variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  /// Whether this nested name specifier contains an error.\n  bool containsErrors() const;\n\n  /// Print this nested name specifier to the given output stream. If\n  /// `ResolveTemplateArguments` is true, we'll print actual types, e.g.\n  /// `ns::SomeTemplate<int, MyClass>` instead of\n  /// `ns::SomeTemplate<Container::value_type, T>`.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool ResolveTemplateArguments = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Prefix.getOpaqueValue());\n    ID.AddPointer(Specifier);\n  }\n\n  /// Dump the nested name specifier to standard output to aid\n  /// in debugging.\n  void dump(const LangOptions &LO) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS) const;\n  void dump(llvm::raw_ostream &OS, const LangOptions &LO) const;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-11330",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/NestedNameSpecifier.h",
  "source_line": 50,
  "validation_status": "validated"
}