{
  "code": "{\n\ntemplate<typename T> class CanProxy;\ntemplate<typename T> struct CanProxyAdaptor;\nclass CXXRecordDecl;\nclass EnumDecl;\nclass Expr;\nclass IdentifierInfo;\nclass ObjCInterfaceDecl;\nclass RecordDecl;\nclass TagDecl;\nclass TemplateTypeParmDecl;\n\n//----------------------------------------------------------------------------//\n// Canonical, qualified type template\n//----------------------------------------------------------------------------//\n\n/// Represents a canonical, potentially-qualified type.\n///\n/// The CanQual template is a lightweight smart pointer that provides access\n/// to the canonical representation of a type, where all typedefs and other\n/// syntactic sugar has been eliminated. A CanQualType may also have various\n/// qualifiers (const, volatile, restrict) attached to it.\n///\n/// The template type parameter @p T is one of the Type classes (PointerType,\n/// BuiltinType, etc.). The type stored within @c CanQual<T> will be of that\n/// type (or some subclass of that type). The typedef @c CanQualType is just\n/// a shorthand for @c CanQual<Type>.\n///\n/// An instance of @c CanQual<T> can be implicitly converted to a\n/// @c CanQual<U> when T is derived from U, which essentially provides an\n/// implicit upcast. For example, @c CanQual<LValueReferenceType> can be\n/// converted to @c CanQual<ReferenceType>. Note that any @c CanQual type can\n/// be implicitly converted to a QualType, but the reverse operation requires\n/// a call to ASTContext::getCanonicalType().\ntemplate<typename T = Type>\nclass CanQual {\n  /// The actual, canonical type.\n  QualType Stored;\n\npublic:\n  /// Constructs a NULL canonical type.\n  CanQual() = default;\n\n  /// Converting constructor that permits implicit upcasting of\n  /// canonical type pointers.\n  template <typename U>\n  CanQual(const CanQual<U> &Other,\n          std::enable_if_t<std::is_base_of<T, U>::value, int> = 0);\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type.\n  ///\n  /// The underlying pointer must not be nullptr.\n  const T *getTypePtr() const { return cast<T>(Stored.getTypePtr()); }\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type, or nullptr.\n  const T *getTypePtrOrNull() const {\n    return cast_or_null<T>(Stored.getTypePtrOrNull());\n  }\n\n  /// Implicit conversion to a qualified type.\n  operator QualType() const { return Stored; }\n\n  /// Implicit conversion to bool.\n  explicit operator bool() const { return !isNull(); }\n\n  bool isNull() const {\n    return Stored.isNull();\n  }\n\n  SplitQualType split() const { return Stored.split(); }\n\n  /// Retrieve a canonical type pointer with a different static type,\n  /// upcasting or downcasting as needed.\n  ///\n  /// The getAs() function is typically used to try to downcast to a\n  /// more specific (canonical) type in the type system. For example:\n  ///\n  /// @code\n  /// void f(CanQual<Type> T) {\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {\n  ///     // look at Ptr's pointee type\n  ///   }\n  /// }\n  /// @endcode\n  ///\n  /// \\returns A proxy pointer to the same type, but with the specified\n  /// static type (@p U). If the dynamic type is not the specified static type\n  /// or a derived class thereof, a NULL canonical type.\n  template<typename U> CanProxy<U> getAs() const;\n\n  template<typename U> CanProxy<U> castAs() const;\n\n  /// Overloaded arrow operator that produces a canonical type\n  /// proxy.\n  CanProxy<T> operator->() const;\n\n  /// Retrieve all qualifiers.\n  Qualifiers getQualifiers() const { return Stored.getLocalQualifiers(); }\n\n  /// Retrieve the const/volatile/restrict qualifiers.\n  unsigned getCVRQualifiers() const { return Stored.getLocalCVRQualifiers(); }\n\n  /// Determines whether this type has any qualifiers\n  bool hasQualifiers() const { return Stored.hasLocalQualifiers(); }\n\n  bool isConstQualified() const {\n    return Stored.isLocalConstQualified();\n  }\n\n  bool isVolatileQualified() const {\n    return Stored.isLocalVolatileQualified();\n  }\n\n  bool isRestrictQualified() const {\n    return Stored.isLocalRestrictQualified();\n  }\n\n  /// Determines if this canonical type is furthermore\n  /// canonical as a parameter.  The parameter-canonicalization\n  /// process decays arrays to pointers and drops top-level qualifiers.\n  bool isCanonicalAsParam() const {\n    return Stored.isCanonicalAsParam();\n  }\n\n  /// Retrieve the unqualified form of this type.\n  CanQual<T> getUnqualifiedType() const;\n\n  /// Retrieves a version of this type with const applied.\n  /// Note that this does not always yield a canonical type.\n  QualType withConst() const {\n    return Stored.withConst();\n  }\n\n  /// Determines whether this canonical type is more qualified than\n  /// the @p Other canonical type.\n  bool isMoreQualifiedThan(CanQual<T> Other) const {\n    return Stored.isMoreQualifiedThan(Other.Stored);\n  }\n\n  /// Determines whether this canonical type is at least as qualified as\n  /// the @p Other canonical type.\n  bool isAtLeastAsQualifiedAs(CanQual<T> Other) const {\n    return Stored.isAtLeastAsQualifiedAs(Other.Stored);\n  }\n\n  /// If the canonical type is a reference type, returns the type that\n  /// it refers to; otherwise, returns the type itself.\n  CanQual<Type> getNonReferenceType() const;\n\n  /// Retrieve the internal representation of this canonical type.\n  void *getAsOpaquePtr() const { return Stored.getAsOpaquePtr(); }\n\n  /// Construct a canonical type from its internal representation.\n  static CanQual<T> getFromOpaquePtr(void *Ptr);\n\n  /// Builds a canonical type from a QualType.\n  ///\n  /// This routine is inherently unsafe, because it requires the user to\n  /// ensure that the given type is a canonical type with the correct\n  // (dynamic) type.\n  static CanQual<T> CreateUnsafe(QualType Other);\n\n  void dump() const { Stored.dump(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n};\n\ntemplate<typename T, typename U>\ninline bool operator==(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() == y.getAsOpaquePtr();\n}\n\ntemplate<typename T, typename U>\ninline bool operator!=(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() != y.getAsOpaquePtr();\n}\n\n/// Represents a canonical, potentially-qualified type.\nusing CanQualType = CanQual<Type>;\n\ninline CanQualType Type::getCanonicalTypeUnqualified() const {\n  return CanQualType::CreateUnsafe(getCanonicalTypeInternal());\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             CanQualType T) {\n  DB << static_cast<QualType>(T);\n  return DB;\n}\n\n//----------------------------------------------------------------------------//\n// Internal proxy classes used by canonical types\n//----------------------------------------------------------------------------//\n\n#define LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(Accessor)                    \\\nCanQualType Accessor() const {                                           \\\nreturn CanQualType::CreateUnsafe(this->getTypePtr()->Accessor());      \\\n}\n\n#define LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type, Accessor)             \\\nType Accessor() const { return this->getTypePtr()->Accessor(); }\n\n/// Base class of all canonical proxy types, which is responsible for\n/// storing the underlying canonical type and providing basic conversions.\ntemplate<typename T>\nclass CanProxyBase {\nprotected:\n  CanQual<T> Stored;\n\npublic:\n  /// Retrieve the pointer to the underlying Type\n  const T *getTypePtr() const { return Stored.getTypePtr(); }\n\n  /// Implicit conversion to the underlying pointer.\n  ///\n  /// Also provides the ability to use canonical type proxies in a Boolean\n  // context,e.g.,\n  /// @code\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) { ... }\n  /// @endcode\n  operator const T*() const { return this->Stored.getTypePtrOrNull(); }\n\n  /// Try to convert the given canonical type to a specific structural\n  /// type.\n  template<typename U> CanProxy<U> getAs() const {\n    return this->Stored.template getAs<U>();\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type::TypeClass, getTypeClass)\n\n  // Type predicates\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessBuiltinType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteOrObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariablyModifiedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isEnumeralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBooleanType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isWideCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArithmeticType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDerivedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isScalarType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAggregateType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isMemberFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureOrClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnionType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isNullPtrType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDependentType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isOverloadableType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArrayType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasObjCPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasSignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasUnsignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasFloatingRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isConstantSizeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSpecifierType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(CXXRecordDecl*, getAsCXXRecordDecl)\n\n  /// Retrieve the proxy-adaptor type.\n  ///\n  /// This arrow operator is used when CanProxyAdaptor has been specialized\n  /// for the given type T. In that case, we reference members of the\n  /// CanProxyAdaptor specialization. Otherwise, this operator will be hidden\n  /// by the arrow operator in the primary CanProxyAdaptor template.\n  const CanProxyAdaptor<T> *operator->() const {\n    return static_cast<const CanProxyAdaptor<T> *>(this);\n  }\n};\n\n/// Replaceable canonical proxy adaptor class that provides the link\n/// between a canonical type and the accessors of the type.\n///\n/// The CanProxyAdaptor is a replaceable class template that is instantiated\n/// as part of each canonical proxy type. The primary template merely provides\n/// redirection to the underlying type (T), e.g., @c PointerType. One can\n/// provide specializations of this class template for each underlying type\n/// that provide accessors returning canonical types (@c CanQualType) rather\n/// than the more typical @c QualType, to propagate the notion of \"canonical\"\n/// through the system.\ntemplate<typename T>\nstruct CanProxyAdaptor : CanProxyBase<T> {};\n\n/// Canonical proxy type returned when retrieving the members of a\n/// canonical type or as the result of the @c CanQual<T>::getAs member\n/// function.\n///\n/// The CanProxy type mainly exists as a proxy through which operator-> will\n/// look to either map down to a raw T* (e.g., PointerType*) or to a proxy\n/// type that provides canonical-type access to the fields of the type.\ntemplate<typename T>\nclass CanProxy : public CanProxyAdaptor<T> {\npublic:\n  /// Build a NULL proxy.\n  CanProxy() = default;\n\n  /// Build a proxy to the given canonical type.\n  CanProxy(CanQual<T> Stored) { this->Stored = Stored; }\n\n  /// Implicit conversion to the stored canonical type.\n  operator CanQual<T>() const { return this->Stored; }\n};\n\n}",
  "id": "BLOCK-CPP-07525",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CanonicalType.h",
  "source_line": 29,
  "validation_status": "validated"
}