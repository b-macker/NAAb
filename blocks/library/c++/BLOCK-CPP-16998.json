{
  "code": "{\n\n//===----------------------------------------------------------------------===//\n// Line Table Implementation\n//===----------------------------------------------------------------------===//\n\nstruct LineEntry {\n  /// The offset in this file that the line entry occurs at.\n  unsigned FileOffset;\n\n  /// The presumed line number of this line entry: \\#line 4.\n  unsigned LineNo;\n\n  /// The ID of the filename identified by this line entry:\n  /// \\#line 4 \"foo.c\".  This is -1 if not specified.\n  int FilenameID;\n\n  /// Set the 0 if no flags, 1 if a system header,\n  SrcMgr::CharacteristicKind FileKind;\n\n  /// The offset of the virtual include stack location,\n  /// which is manipulated by GNU linemarker directives.\n  ///\n  /// If this is 0 then there is no virtual \\#includer.\n  unsigned IncludeOffset;\n\n  static LineEntry get(unsigned Offs, unsigned Line, int Filename,\n                       SrcMgr::CharacteristicKind FileKind,\n                       unsigned IncludeOffset) {\n    LineEntry E;\n    E.FileOffset = Offs;\n    E.LineNo = Line;\n    E.FilenameID = Filename;\n    E.FileKind = FileKind;\n    E.IncludeOffset = IncludeOffset;\n    return E;\n  }\n};\n\n// needed for FindNearestLineEntry (upper_bound of LineEntry)\ninline bool operator<(const LineEntry &lhs, const LineEntry &rhs) {\n  // FIXME: should check the other field?\n  return lhs.FileOffset < rhs.FileOffset;\n}\n\ninline bool operator<(const LineEntry &E, unsigned Offset) {\n  return E.FileOffset < Offset;\n}\n\ninline bool operator<(unsigned Offset, const LineEntry &E) {\n  return Offset < E.FileOffset;\n}\n\n/// Used to hold and unique data used to represent \\#line information.\nclass LineTableInfo {\n  /// Map used to assign unique IDs to filenames in \\#line directives.\n  ///\n  /// This allows us to unique the filenames that\n  /// frequently reoccur and reference them with indices.  FilenameIDs holds\n  /// the mapping from string -> ID, and FilenamesByID holds the mapping of ID\n  /// to string.\n  llvm::StringMap<unsigned, llvm::BumpPtrAllocator> FilenameIDs;\n  std::vector<llvm::StringMapEntry<unsigned>*> FilenamesByID;\n\n  /// Map from FileIDs to a list of line entries (sorted by the offset\n  /// at which they occur in the file).\n  std::map<FileID, std::vector<LineEntry>> LineEntries;\n\npublic:\n  void clear() {\n    FilenameIDs.clear();\n    FilenamesByID.clear();\n    LineEntries.clear();\n  }\n\n  unsigned getLineTableFilenameID(StringRef Str);\n\n  StringRef getFilename(unsigned ID) const {\n    assert(ID < FilenamesByID.size() && \"Invalid FilenameID\");\n    return FilenamesByID[ID]->getKey();\n  }\n\n  unsigned getNumFilenames() const { return FilenamesByID.size(); }\n\n  void AddLineNote(FileID FID, unsigned Offset,\n                   unsigned LineNo, int FilenameID,\n                   unsigned EntryExit, SrcMgr::CharacteristicKind FileKind);\n\n\n  /// Find the line entry nearest to FID that is before it.\n  ///\n  /// If there is no line entry before \\p Offset in \\p FID, returns null.\n  const LineEntry *FindNearestLineEntry(FileID FID, unsigned Offset);\n\n  // Low-level access\n  using iterator = std::map<FileID, std::vector<LineEntry>>::iterator;\n\n  iterator begin() { return LineEntries.begin(); }\n  iterator end() { return LineEntries.end(); }\n\n  /// Add a new line entry that has already been encoded into\n  /// the internal representation of the line table.\n  void AddEntry(FileID FID, const std::vector<LineEntry> &Entries);\n};\n\n}",
  "id": "BLOCK-CPP-16998",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceManagerInternals.h",
  "source_line": 26,
  "validation_status": "validated"
}