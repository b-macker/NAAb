{
  "code": "{\n\nSPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items,\n                                       size_t threads_n,\n                                       std::function<void()> on_thread_start,\n                                       std::function<void()> on_thread_stop)\n    : q_(q_max_items) {\n    if (threads_n == 0 || threads_n > 1000) {\n        throw_spdlog_ex(\n            \"spdlog::thread_pool(): invalid threads_n param (valid \"\n            \"range is 1-1000)\");\n    }\n    for (size_t i = 0; i < threads_n; i++) {\n        threads_.emplace_back([this, on_thread_start, on_thread_stop] {\n            on_thread_start();\n            this->thread_pool::worker_loop_();\n            on_thread_stop();\n        });\n    }\n}\n\nSPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items,\n                                       size_t threads_n,\n                                       std::function<void()> on_thread_start)\n    : thread_pool(q_max_items, threads_n, on_thread_start, [] {}) {}\n\nSPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items, size_t threads_n)\n    : thread_pool(\n          q_max_items, threads_n, [] {}, [] {}) {}\n\n// message all threads to terminate gracefully join them\nSPDLOG_INLINE thread_pool::~thread_pool() {\n    SPDLOG_TRY {\n        for (size_t i = 0; i < threads_.size(); i++) {\n            post_async_msg_(async_msg(async_msg_type::terminate), async_overflow_policy::block);\n        }\n\n        for (auto &t : threads_) {\n            t.join();\n        }\n    }\n    SPDLOG_CATCH_STD\n}\n\nvoid SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr,\n                                         const details::log_msg &msg,\n                                         async_overflow_policy overflow_policy) {\n    async_msg async_m(std::move(worker_ptr), async_msg_type::log, msg);\n    post_async_msg_(std::move(async_m), overflow_policy);\n}\n\nvoid SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr,\n                                           async_overflow_policy overflow_policy) {\n    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);\n}\n\nsize_t SPDLOG_INLINE thread_pool::overrun_counter() { return q_.overrun_counter(); }\n\nvoid SPDLOG_INLINE thread_pool::reset_overrun_counter() { q_.reset_overrun_counter(); }\n\nsize_t SPDLOG_INLINE thread_pool::discard_counter() { return q_.discard_counter(); }\n\nvoid SPDLOG_INLINE thread_pool::reset_discard_counter() { q_.reset_discard_counter(); }\n\nsize_t SPDLOG_INLINE thread_pool::queue_size() { return q_.size(); }\n\nvoid SPDLOG_INLINE thread_pool::post_async_msg_(async_msg &&new_msg,\n                                                async_overflow_policy overflow_policy) {\n    if (overflow_policy == async_overflow_policy::block) {\n        q_.enqueue(std::move(new_msg));\n    } else if (overflow_policy == async_overflow_policy::overrun_oldest) {\n        q_.enqueue_nowait(std::move(new_msg));\n    } else {\n        assert(overflow_policy == async_overflow_policy::discard_new);\n        q_.enqueue_if_have_room(std::move(new_msg));\n    }\n}\n\nvoid SPDLOG_INLINE thread_pool::worker_loop_() {\n    while (process_next_msg_()) {\n    }\n}\n\n// process next message in the queue\n// return true if this thread should still be active (while no terminate msg\n// was received)\nbool SPDLOG_INLINE thread_pool::process_next_msg_() {\n    async_msg incoming_async_msg;\n    q_.dequeue(incoming_async_msg);\n\n    switch (incoming_async_msg.msg_type) {\n        case async_msg_type::log: {\n            incoming_async_msg.worker_ptr->backend_sink_it_(incoming_async_msg);\n            return true;\n        }\n        case async_msg_type::flush: {\n            incoming_async_msg.worker_ptr->backend_flush_();\n            return true;\n        }\n\n        case async_msg_type::terminate: {\n            return false;\n        }\n\n        default: {\n            assert(false);\n        }\n    }\n\n    return true;\n}\n\n}",
  "id": "BLOCK-CPP-00326",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/thread_pool-inl.h",
  "source_line": 14,
  "validation_status": "validated"
}