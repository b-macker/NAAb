{
  "code": "{\n\ntemplate <typename T>\nclass mpmc_blocking_queue {\npublic:\n    using item_type = T;\n    explicit mpmc_blocking_queue(size_t max_items)\n        : q_(max_items) {}\n\n#ifndef __MINGW32__\n    // try to enqueue and block if no room left\n    void enqueue(T &&item) {\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            pop_cv_.wait(lock, [this] { return !this->q_.full(); });\n            q_.push_back(std::move(item));\n        }\n        push_cv_.notify_one();\n    }\n\n    // enqueue immediately. overrun oldest message in the queue if no room left.\n    void enqueue_nowait(T &&item) {\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            q_.push_back(std::move(item));\n        }\n        push_cv_.notify_one();\n    }\n\n    void enqueue_if_have_room(T &&item) {\n        bool pushed = false;\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            if (!q_.full()) {\n                q_.push_back(std::move(item));\n                pushed = true;\n            }\n        }\n\n        if (pushed) {\n            push_cv_.notify_one();\n        } else {\n            ++discard_counter_;\n        }\n    }\n\n    // dequeue with a timeout.\n    // Return true, if succeeded dequeue item, false otherwise\n    bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration) {\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this->q_.empty(); })) {\n                return false;\n            }\n            popped_item = std::move(q_.front());\n            q_.pop_front();\n        }\n        pop_cv_.notify_one();\n        return true;\n    }\n\n    // blocking dequeue without a timeout.\n    void dequeue(T &popped_item) {\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n            popped_item = std::move(q_.front());\n            q_.pop_front();\n        }\n        pop_cv_.notify_one();\n    }\n\n#else\n    // apparently mingw deadlocks if the mutex is released before cv.notify_one(),\n    // so release the mutex at the very end each function.\n\n    // try to enqueue and block if no room left\n    void enqueue(T &&item) {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        pop_cv_.wait(lock, [this] { return !this->q_.full(); });\n        q_.push_back(std::move(item));\n        push_cv_.notify_one();\n    }\n\n    // enqueue immediately. overrun oldest message in the queue if no room left.\n    void enqueue_nowait(T &&item) {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        q_.push_back(std::move(item));\n        push_cv_.notify_one();\n    }\n\n    void enqueue_if_have_room(T &&item) {\n        bool pushed = false;\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        if (!q_.full()) {\n            q_.push_back(std::move(item));\n            pushed = true;\n        }\n\n        if (pushed) {\n            push_cv_.notify_one();\n        } else {\n            ++discard_counter_;\n        }\n    }\n\n    // dequeue with a timeout.\n    // Return true, if succeeded dequeue item, false otherwise\n    bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration) {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this->q_.empty(); })) {\n            return false;\n        }\n        popped_item = std::move(q_.front());\n        q_.pop_front();\n        pop_cv_.notify_one();\n        return true;\n    }\n\n    // blocking dequeue without a timeout.\n    void dequeue(T &popped_item) {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n        popped_item = std::move(q_.front());\n        q_.pop_front();\n        pop_cv_.notify_one();\n    }\n\n#endif\n\n    size_t overrun_counter() {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        return q_.overrun_counter();\n    }\n\n    size_t discard_counter() { return discard_counter_.load(std::memory_order_relaxed); }\n\n    size_t size() {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        return q_.size();\n    }\n\n    void reset_overrun_counter() {\n        std::unique_lock<std::mutex> lock(queue_mutex_);\n        q_.reset_overrun_counter();\n    }\n\n    void reset_discard_counter() { discard_counter_.store(0, std::memory_order_relaxed); }\n\nprivate:\n    std::mutex queue_mutex_;\n    std::condition_variable push_cv_;\n    std::condition_variable pop_cv_;\n    spdlog::details::circular_q<T> q_;\n    std::atomic<size_t> discard_counter_{0};\n};\n}",
  "id": "BLOCK-CPP-00259",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/mpmc_blocking_q.h",
  "source_line": 20,
  "validation_status": "validated"
}