{
  "code": "{\n public:\n  using DelimiterType = Delimiter;\n  using PredicateType = Predicate;\n  using const_iterator = strings_internal::SplitIterator<Splitter>;\n  using value_type = typename std::iterator_traits<const_iterator>::value_type;\n\n  Splitter(StringType input_text, Delimiter d, Predicate p)\n      : text_(std::move(input_text)),\n        delimiter_(std::move(d)),\n        predicate_(std::move(p)) {}\n\n  absl::string_view text() const { return text_; }\n  const Delimiter& delimiter() const { return delimiter_; }\n  const Predicate& predicate() const { return predicate_; }\n\n  // Range functions that iterate the split substrings as absl::string_view\n  // objects. These methods enable a Splitter to be used in a range-based for\n  // loop.\n  const_iterator begin() const { return {const_iterator::kInitState, this}; }\n  const_iterator end() const { return {const_iterator::kEndState, this}; }\n\n  // An implicit conversion operator that is restricted to only those containers\n  // that the splitter is convertible to.\n  template <\n      typename Container,\n      std::enable_if_t<ShouldUseLifetimeBound<StringType, Container>::value &&\n                           SplitterIsConvertibleTo<Container>::value,\n                       std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator Container() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ConvertToContainer<Container, typename Container::value_type,\n                              HasMappedType<Container>::value>()(*this);\n  }\n\n  template <\n      typename Container,\n      std::enable_if_t<!ShouldUseLifetimeBound<StringType, Container>::value &&\n                           SplitterIsConvertibleTo<Container>::value,\n                       std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator Container() const {\n    return ConvertToContainer<Container, typename Container::value_type,\n                              HasMappedType<Container>::value>()(*this);\n  }\n\n  // Returns a pair with its .first and .second members set to the first two\n  // strings returned by the begin() iterator. Either/both of .first and .second\n  // will be constructed with empty strings if the iterator doesn't have a\n  // corresponding value.\n  template <typename First, typename Second,\n            std::enable_if_t<\n                ShouldUseLifetimeBoundForPair<StringType, First, Second>::value,\n                std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator std::pair<First, Second>() const ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return ConvertToPair<First, Second>();\n  }\n\n  template <typename First, typename Second,\n            std::enable_if_t<!ShouldUseLifetimeBoundForPair<StringType, First,\n                                                            Second>::value,\n                             std::nullptr_t> = nullptr>\n  // NOLINTNEXTLINE(google-explicit-constructor)\n  operator std::pair<First, Second>() const {\n    return ConvertToPair<First, Second>();\n  }\n\n private:\n  template <typename First, typename Second>\n  std::pair<First, Second> ConvertToPair() const {\n    absl::string_view first, second;\n    auto it = begin();\n    if (it != end()) {\n      first = *it;\n      if (++it != end()) {\n        second = *it;\n      }\n    }\n    return {First(first), Second(second)};\n  }\n\n  // ConvertToContainer is a functor converting a Splitter to the requested\n  // Container of ValueType. It is specialized below to optimize splitting to\n  // certain combinations of Container and ValueType.\n  //\n  // This base template handles the generic case of storing the split results in\n  // the requested non-map-like container and converting the split substrings to\n  // the requested type.\n  template <typename Container, typename ValueType, bool is_map = false>\n  struct ConvertToContainer {\n    Container operator()(const Splitter& splitter) const {\n      Container c;\n      auto it = std::inserter(c, c.end());\n      for (const auto& sp : splitter) {\n        *it++ = ValueType(sp);\n      }\n      return c;\n    }\n  };\n\n  // Partial specialization for a std::vector<absl::string_view>.\n  //\n  // Optimized for the common case of splitting to a\n  // std::vector<absl::string_view>. In this case we first split the results to\n  // a small array of absl::string_view on the stack, to reduce reallocations.\n  template <typename A>\n  struct ConvertToContainer<std::vector<absl::string_view, A>,\n                            absl::string_view, false> {\n    std::vector<absl::string_view, A> operator()(\n        const Splitter& splitter) const {\n      struct raw_view {\n        const char* data;\n        size_t size;\n        operator absl::string_view() const {  // NOLINT(runtime/explicit)\n          return {data, size};\n        }\n      };\n      std::vector<absl::string_view, A> v;\n      std::array<raw_view, 16> ar;\n      for (auto it = splitter.begin(); !it.at_end();) {\n        size_t index = 0;\n        do {\n          ar[index].data = it->data();\n          ar[index].size = it->size();\n          ++it;\n        } while (++index != ar.size() && !it.at_end());\n        v.insert(v.end(), ar.begin(), ar.begin() + index);\n      }\n      return v;\n    }\n  };\n\n  // Partial specialization for a std::vector<std::string>.\n  //\n  // Optimized for the common case of splitting to a std::vector<std::string>.\n  // In this case we first split the results to a std::vector<absl::string_view>\n  // so the returned std::vector<std::string> can have space reserved to avoid\n  // std::string moves.\n  template <typename A>\n  struct ConvertToContainer<std::vector<std::string, A>, std::string, false> {\n    std::vector<std::string, A> operator()(const Splitter& splitter) const {\n      const std::vector<absl::string_view> v = splitter;\n      return std::vector<std::string, A>(v.begin(), v.end());\n    }\n  };\n\n  // Partial specialization for containers of pairs (e.g., maps).\n  //\n  // The algorithm is to insert a new pair into the map for each even-numbered\n  // item, with the even-numbered item as the key with a default-constructed\n  // value. Each odd-numbered item will then be assigned to the last pair's\n  // value.\n  template <typename Container, typename First, typename Second>\n  struct ConvertToContainer<Container, std::pair<const First, Second>, true> {\n    using iterator = typename Container::iterator;\n\n    Container operator()(const Splitter& splitter) const {\n      Container m;\n      iterator it;\n      bool insert = true;\n      for (const absl::string_view sv : splitter) {\n        if (insert) {\n          it = InsertOrEmplace(&m, sv);\n        } else {\n          it->second = Second(sv);\n        }\n        insert = !insert;\n      }\n      return m;\n    }\n\n    // Inserts the key and an empty value into the map, returning an iterator to\n    // the inserted item. We use emplace() if available, otherwise insert().\n    template <typename M>\n    static absl::enable_if_t<HasEmplace<M>::value, iterator> InsertOrEmplace(\n        M* m, absl::string_view key) {\n      // Use piecewise_construct to support old versions of gcc in which pair\n      // constructor can't otherwise construct string from string_view.\n      return ToIter(m->emplace(std::piecewise_construct, std::make_tuple(key),\n                               std::tuple<>()));\n    }\n    template <typename M>\n    static absl::enable_if_t<!HasEmplace<M>::value, iterator> InsertOrEmplace(\n        M* m, absl::string_view key) {\n      return ToIter(m->insert(std::make_pair(First(key), Second(\"\"))));\n    }\n\n    static iterator ToIter(std::pair<iterator, bool> pair) {\n      return pair.first;\n    }\n    static iterator ToIter(iterator iter) { return iter; }\n  };\n\n  StringType text_;\n  Delimiter delimiter_;\n  Predicate predicate_;\n}",
  "id": "BLOCK-CPP-06265",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/str_split_internal.h",
  "source_line": 277,
  "validation_status": "validated"
}