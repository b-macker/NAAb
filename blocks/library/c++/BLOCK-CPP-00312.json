{
  "code": "{\nclass tcp_client {\n    SOCKET socket_ = INVALID_SOCKET;\n\n    static void init_winsock_() {\n        WSADATA wsaData;\n        auto rv = WSAStartup(MAKEWORD(2, 2), &wsaData);\n        if (rv != 0) {\n            throw_winsock_error_(\"WSAStartup failed\", ::WSAGetLastError());\n        }\n    }\n\n    static void throw_winsock_error_(const std::string &msg, int last_error) {\n        char buf[512];\n        ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL,\n                         last_error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf,\n                         (sizeof(buf) / sizeof(char)), NULL);\n\n        throw_spdlog_ex(fmt_lib::format(\"tcp_sink - {}: {}\", msg, buf));\n    }\n\npublic:\n    tcp_client() { init_winsock_(); }\n\n    ~tcp_client() {\n        close();\n        ::WSACleanup();\n    }\n\n    bool is_connected() const { return socket_ != INVALID_SOCKET; }\n\n    void close() {\n        ::closesocket(socket_);\n        socket_ = INVALID_SOCKET;\n    }\n\n    SOCKET fd() const { return socket_; }\n\n    // try to connect or throw on failure\n    void connect(const std::string &host, int port) {\n        if (is_connected()) {\n            close();\n        }\n        struct addrinfo hints {};\n        ZeroMemory(&hints, sizeof(hints));\n\n        hints.ai_family = AF_UNSPEC;      // To work with IPv4, IPv6, and so on\n        hints.ai_socktype = SOCK_STREAM;  // TCP\n        hints.ai_flags = AI_NUMERICSERV;  // port passed as as numeric value\n        hints.ai_protocol = 0;\n\n        auto port_str = std::to_string(port);\n        struct addrinfo *addrinfo_result;\n        auto rv = ::getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrinfo_result);\n        int last_error = 0;\n        if (rv != 0) {\n            last_error = ::WSAGetLastError();\n            WSACleanup();\n            throw_winsock_error_(\"getaddrinfo failed\", last_error);\n        }\n\n        // Try each address until we successfully connect(2).\n\n        for (auto *rp = addrinfo_result; rp != nullptr; rp = rp->ai_next) {\n            socket_ = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n            if (socket_ == INVALID_SOCKET) {\n                last_error = ::WSAGetLastError();\n                WSACleanup();\n                continue;\n            }\n            if (::connect(socket_, rp->ai_addr, (int)rp->ai_addrlen) == 0) {\n                break;\n            } else {\n                last_error = ::WSAGetLastError();\n                close();\n            }\n        }\n        ::freeaddrinfo(addrinfo_result);\n        if (socket_ == INVALID_SOCKET) {\n            WSACleanup();\n            throw_winsock_error_(\"connect failed\", last_error);\n        }\n\n        // set TCP_NODELAY\n        int enable_flag = 1;\n        ::setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&enable_flag),\n                     sizeof(enable_flag));\n    }\n\n    // Send exactly n_bytes of the given data.\n    // On error close the connection and throw.\n    void send(const char *data, size_t n_bytes) {\n        size_t bytes_sent = 0;\n        while (bytes_sent < n_bytes) {\n            const int send_flags = 0;\n            auto write_result =\n                ::send(socket_, data + bytes_sent, (int)(n_bytes - bytes_sent), send_flags);\n            if (write_result == SOCKET_ERROR) {\n                int last_error = ::WSAGetLastError();\n                close();\n                throw_winsock_error_(\"send failed\", last_error);\n            }\n\n            if (write_result == 0)  // (probably should not happen but in any case..)\n            {\n                break;\n            }\n            bytes_sent += static_cast<size_t>(write_result);\n        }\n    }\n};\n}",
  "id": "BLOCK-CPP-00312",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/tcp_client-windows.h",
  "source_line": 23,
  "validation_status": "validated"
}