{
  "code": "{\n public:\n  // EdgeType identifies `front` and `back` enum values.\n  // Various implementations in CordRepBtree such as `Add` and `Edge` are\n  // generic and templated on operating on either of the boundary edges.\n  // For more information on the possible edges contained in a CordRepBtree\n  // instance see the documentation for `edges_`.\n  enum class EdgeType { kFront, kBack };\n\n  // Convenience constants into `EdgeType`\n  static constexpr EdgeType kFront = EdgeType::kFront;\n  static constexpr EdgeType kBack = EdgeType::kBack;\n\n  // Maximum number of edges: based on experiments and performance data, we can\n  // pick suitable values resulting in optimum cacheline aligned values. The\n  // preferred values are based on 64-bit systems where we aim to align this\n  // class onto 64 bytes, i.e.:  6 = 64 bytes, 14 = 128 bytes, etc.\n  // TODO(b/192061034): experiment with alternative sizes.\n  static constexpr size_t kMaxCapacity = 6;\n\n  // Reasonable maximum height of the btree. We can expect a fill ratio of at\n  // least 50%: trees are always expanded at the front or back. Concatenating\n  // trees will then typically fold at the top most node, where the lower nodes\n  // are at least at capacity on one side of joined inputs. At a lower fill\n  // rate of 4 edges per node, we have capacity for ~16 million leaf nodes.\n  // We will fail / abort if an application ever exceeds this height, which\n  // should be extremely rare (near impossible) and be an indication of an\n  // application error: we do not assume it reasonable for any application to\n  // operate correctly with such monster trees.\n  // Another compelling reason for the number `12` is that any contextual stack\n  // required for navigation or insertion requires 12 words and 12 bytes, which\n  // fits inside 2 cache lines with some room to spare, and is reasonable as a\n  // local stack variable compared to Cord's current near 400 bytes stack use.\n  // The maximum `height` value of a node is then `kMaxDepth - 1` as node height\n  // values start with a value of 0 for leaf nodes.\n  static constexpr size_t kMaxDepth = 12;\n  // See comments on height() for why this is an int and not a size_t.\n  static constexpr int kMaxHeight = static_cast<int>(kMaxDepth - 1);\n\n  // `Action` defines the action for unwinding changes done at the btree's leaf\n  // level that need to be propagated up to the parent node(s). Each operation\n  // on a node has an effect / action defined as follows:\n  // - kSelf\n  //   The operation (add / update, etc) was performed directly on the node as\n  //   the node is private to the current thread (i.e.: not shared directly or\n  //   indirectly through a refcount > 1). Changes can be propagated directly to\n  //   all parent nodes as all parent nodes are also then private to the current\n  //   thread.\n  // - kCopied\n  //   The operation (add / update, etc) was performed on a copy of the original\n  //   node, as the node is (potentially) directly or indirectly shared with\n  //   other threads. Changes need to be propagated into the parent nodes where\n  //   the old down pointer must be unreffed and replaced with this new copy.\n  //   Such changes to parent nodes may themselves require a copy if the parent\n  //   node is also shared. A kCopied action can propagate all the way to the\n  //   top node where we then must unref the `tree` input provided by the\n  //   caller, and return the new copy.\n  // - kPopped\n  //   The operation (typically add) could not be satisfied due to insufficient\n  //   capacity in the targeted node, and a new 'leg' was created that needs to\n  //   be added into the parent node. For example, adding a FLAT inside a leaf\n  //   node that is at capacity will create a new leaf node containing that\n  //   FLAT, that needs to be 'popped' up the btree. Such 'pop' actions can\n  //   cascade up the tree if parent nodes are also at capacity. A 'Popped'\n  //   action propagating all the way to the top of the tree will result in\n  //   the tree becoming one level higher than the current tree through a final\n  //   `CordRepBtree::New(tree, popped)` call, resulting in a new top node\n  //   referencing the old tree and the new (fully popped upwards) 'leg'.\n  enum Action { kSelf, kCopied, kPopped };\n\n  // Result of an operation on a node. See the `Action` enum for details.\n  struct OpResult {\n    CordRepBtree* tree;\n    Action action;\n  };\n\n  // Return value of the CopyPrefix and CopySuffix methods which can\n  // return a node or data edge at any height inside the tree.\n  // A height of 0 defines the lowest (leaf) node, a height of -1 identifies\n  // `edge` as being a plain data node: EXTERNAL / FLAT or SUBSTRING thereof.\n  struct CopyResult {\n    CordRep* edge;\n    int height;\n  };\n\n  // Logical position inside a node:\n  // - index: index of the edge.\n  // - n: size or offset value depending on context.\n  struct Position {\n    size_t index;\n    size_t n;\n  };\n\n  // Creates a btree from the given input. Adopts a ref of `rep`.\n  // If the input `rep` is itself a btree, i.e., `IsBtree()`, then this\n  // function immediately returns `rep->btree()`. If the input is a valid data\n  // edge (see IsDataEdge()), then a new leaf node is returned containing `rep`\n  // as the sole data edge. Else, the input is assumed to be a (legacy) concat\n  // tree, and the input is consumed and transformed into a btree().\n  static CordRepBtree* Create(CordRep* rep);\n\n  // Destroys the provided tree. Should only be called by cord internal API's,\n  // typically after a ref_count.Decrement() on the last reference count.\n  static void Destroy(CordRepBtree* tree);\n\n  // Destruction\n  static void Delete(CordRepBtree* tree) { delete tree; }\n\n  // Use CordRep::Unref() as we overload for absl::Span<CordRep* const>.\n  using CordRep::Unref;\n\n  // Unrefs all edges in `edges` which are assumed to be 'likely one'.\n  static void Unref(absl::Span<CordRep* const> edges);\n\n  // Appends / Prepends an existing CordRep instance to this tree.\n  // The below methods accept three types of input:\n  // 1) `rep` is a data node (See `IsDataNode` for valid data edges).\n  // `rep` is appended or prepended to this tree 'as is'.\n  // 2) `rep` is a BTREE.\n  // `rep` is merged into `tree` respecting the Append/Prepend order.\n  // 3) `rep` is some other (legacy) type.\n  // `rep` is converted in place and added to `tree`\n  // Requires `tree` and `rep` to be not null.\n  static CordRepBtree* Append(CordRepBtree* tree, CordRep* rep);\n  static CordRepBtree* Prepend(CordRepBtree* tree, CordRep* rep);\n\n  // Append/Prepend the data in `data` to this tree.\n  // The `extra` parameter defines how much extra capacity should be allocated\n  // for any additional FLAT being allocated. This is an optimization hint from\n  // the caller. For example, a caller may need to add 2 string_views of data\n  // \"abc\" and \"defghi\" which are not consecutive. The caller can in this case\n  // invoke `AddData(tree, \"abc\", 6)`, and any newly added flat is allocated\n  // where possible with at least 6 bytes of extra capacity beyond `length`.\n  // This helps avoiding data getting fragmented over multiple flats.\n  // There is no limit on the size of `data`. If `data` can not be stored inside\n  // a single flat, then the function will iteratively add flats until all data\n  // has been consumed and appended or prepended to the tree.\n  static CordRepBtree* Append(CordRepBtree* tree, string_view data,\n                              size_t extra = 0);\n  static CordRepBtree* Prepend(CordRepBtree* tree, string_view data,\n                               size_t extra = 0);\n\n  // Returns a new tree, containing `n` bytes of data from this instance\n  // starting at offset `offset`. Where possible, the returned tree shares\n  // (re-uses) data edges and nodes with this instance to minimize the\n  // combined memory footprint of both trees.\n  // Requires `offset + n <= length`. Returns `nullptr` if `n` is zero.\n  CordRep* SubTree(size_t offset, size_t n);\n\n  // Removes `n` trailing bytes from `tree`, and returns the resulting tree\n  // or data edge. Returns `tree` if n is zero, and nullptr if n == length.\n  // This function is logically identical to:\n  //   result = tree->SubTree(0, tree->length - n);\n  //   Unref(tree);\n  //   return result;\n  // However, the actual implementation will as much as possible perform 'in\n  // place' modifications on the tree on all nodes and edges that are mutable.\n  // For example, in a fully privately owned tree with the last edge being a\n  // flat of length 12, RemoveSuffix(1) will simply set the length of that data\n  // edge to 11, and reduce the length of all nodes on the edge path by 1.\n  static CordRep* RemoveSuffix(CordRepBtree* tree, size_t n);\n\n  // Returns the character at the given offset.\n  char GetCharacter(size_t offset) const;\n\n  // Returns true if this node holds a single data edge, and if so, sets\n  // `fragment` to reference the contained data. `fragment` is an optional\n  // output parameter and allowed to be null.\n  bool IsFlat(absl::string_view* fragment) const;\n\n  // Returns true if the data of `n` bytes starting at offset `offset`\n  // is contained in a single data edge, and if so, sets fragment to reference\n  // the contained data. `fragment` is an optional output parameter and allowed\n  // to be null.\n  bool IsFlat(size_t offset, size_t n, absl::string_view* fragment) const;\n\n  // Returns a span (mutable range of bytes) of up to `size` bytes into the\n  // last FLAT data edge inside this tree under the following conditions:\n  // - none of the nodes down into the FLAT node are shared.\n  // - the last data edge in this tree is a non-shared FLAT.\n  // - the referenced FLAT has additional capacity available.\n  // If all these conditions are met, a non-empty span is returned, and the\n  // length of the flat node and involved tree nodes have been increased by\n  // `span.length()`. The caller is responsible for immediately assigning values\n  // to all uninitialized data reference by the returned span.\n  // Requires `this->refcount.IsOne()`: this function forces the caller to do\n  // this fast path check on the top level node, as this is the most commonly\n  // shared node of a cord tree.\n  Span<char> GetAppendBuffer(size_t size);\n\n  // Extracts the right-most data edge from this tree iff:\n  // - the tree and all internal edges to the right-most node are not shared.\n  // - the right-most node is a FLAT node and not shared.\n  // - the right-most node has at least the desired extra capacity.\n  //\n  // Returns {tree, nullptr} if any of the above conditions are not met.\n  // This method effectively removes data from the tree. The intent of this\n  // method is to allow applications appending small string data to use\n  // pre-existing capacity, and add the modified rep back to the tree.\n  //\n  // Simplified such code would look similar to this:\n  //   void MyTreeBuilder::Append(string_view data) {\n  //     ExtractResult result = CordRepBtree::ExtractAppendBuffer(tree_, 1);\n  //     if (CordRep* rep = result.extracted) {\n  //       size_t available = rep->Capacity() - rep->length;\n  //       size_t n = std::min(data.size(), n);\n  //       memcpy(rep->Data(), data.data(), n);\n  //       rep->length += n;\n  //       data.remove_prefix(n);\n  //       if (!result.tree->IsBtree()) {\n  //         tree_ = CordRepBtree::Create(result.tree);\n  //       }\n  //       tree_ = CordRepBtree::Append(tree_, rep);\n  //     }\n  //     ...\n  //     // Remaining edge in `result.tree`.\n  //   }\n  static ExtractResult ExtractAppendBuffer(CordRepBtree* tree,\n                                           size_t extra_capacity = 1);\n\n  // Returns the `height` of the tree. The height of a tree is limited to\n  // kMaxHeight. `height` is implemented as an `int` as in some places we\n  // use negative (-1) values for 'data edges'.\n  int height() const { return static_cast<int>(storage[0]); }\n\n  // Properties: begin, back, end, front/back boundary indexes.\n  size_t begin() const { return static_cast<size_t>(storage[1]); }\n  size_t back() const { return static_cast<size_t>(storage[2]) - 1; }\n  size_t end() const { return static_cast<size_t>(storage[2]); }\n  size_t index(EdgeType edge) const {\n    return edge == kFront ? begin() : back();\n  }\n\n  // Properties: size and capacity.\n  // `capacity` contains the current capacity of this instance, where\n  // `kMaxCapacity` contains the maximum capacity of a btree node.\n  // For now, `capacity` and `kMaxCapacity` return the same value, but this may\n  // change in the future if we see benefit in dynamically sizing 'small' nodes\n  // to 'large' nodes for large data trees.\n  size_t size() const { return end() - begin(); }\n  size_t capacity() const { return kMaxCapacity; }\n\n  // Edge access\n  inline CordRep* Edge(size_t index) const;\n  inline CordRep* Edge(EdgeType edge_type) const;\n  inline absl::Span<CordRep* const> Edges() const;\n  inline absl::Span<CordRep* const> Edges(size_t begin, size_t end) const;\n\n  // Returns reference to the data edge at `index`.\n  // Requires this instance to be a leaf node, and `index` to be valid index.\n  inline absl::string_view Data(size_t index) const;\n\n  // Diagnostics: returns true if `tree` is valid and internally consistent.\n  // If `shallow` is false, then the provided top level node and all child nodes\n  // below it are recursively checked. If `shallow` is true, only the provided\n  // node in `tree` and the cumulative length, type and height of the direct\n  // child nodes of `tree` are checked. The value of `shallow` is ignored if the\n  // internal `cord_btree_exhaustive_validation` diagnostics variable is true,\n  // in which case the performed validations works as if `shallow` were false.\n  // This function is intended for debugging and testing purposes only.\n  static bool IsValid(const CordRepBtree* tree, bool shallow = false);\n\n  // Diagnostics: asserts that the provided tree is valid.\n  // `AssertValid()` performs a shallow validation by default. `shallow` can be\n  // set to false in which case an exhaustive validation is performed. This\n  // function is implemented in terms of calling `IsValid()` and asserting the\n  // return value to be true. See `IsValid()` for more information.\n  // This function is intended for debugging and testing purposes only.\n  static CordRepBtree* AssertValid(CordRepBtree* tree, bool shallow = true);\n  static const CordRepBtree* AssertValid(const CordRepBtree* tree,\n                                         bool shallow = true);\n\n  // Diagnostics: dump the contents of this tree to `stream`.\n  // This function is intended for debugging and testing purposes only.\n  static void Dump(const CordRep* rep, std::ostream& stream);\n  static void Dump(const CordRep* rep, absl::string_view label,\n                   std::ostream& stream);\n  static void Dump(const CordRep* rep, absl::string_view label,\n                   bool include_contents, std::ostream& stream);\n\n  // Adds the edge `edge` to this node if possible. `owned` indicates if the\n  // current node is potentially shared or not with other threads. Returns:\n  // - {kSelf, <this>}\n  //   The edge was directly added to this node.\n  // - {kCopied, <node>}\n  //   The edge was added to a copy of this node.\n  // - {kPopped, New(edge, height())}\n  //   A new leg with the edge was created as this node has no extra capacity.\n  template <EdgeType edge_type>\n  inline OpResult AddEdge(bool owned, CordRep* edge, size_t delta);\n\n  // Replaces the front or back edge with the provided new edge. Returns:\n  // - {kSelf, <this>}\n  //   The edge was directly set in this node. The old edge is unreffed.\n  // - {kCopied, <node>}\n  //   A copy of this node was created with the new edge value.\n  // In both cases, the function adopts a reference on `edge`.\n  template <EdgeType edge_type>\n  OpResult SetEdge(bool owned, CordRep* edge, size_t delta);\n\n  // Creates a new empty node at the specified height.\n  static CordRepBtree* New(int height = 0);\n\n  // Creates a new node containing `rep`, with the height being computed\n  // automatically based on the type of `rep`.\n  static CordRepBtree* New(CordRep* rep);\n\n  // Creates a new node containing both `front` and `back` at height\n  // `front.height() + 1`. Requires `back.height() == front.height()`.\n  static CordRepBtree* New(CordRepBtree* front, CordRepBtree* back);\n\n  // Creates a fully balanced tree from the provided tree by rebuilding a new\n  // tree from all data edges in the input. This function is automatically\n  // invoked internally when the tree exceeds the maximum height.\n  static CordRepBtree* Rebuild(CordRepBtree* tree);\n\n private:\n  CordRepBtree() = default;\n  ~CordRepBtree() = default;\n\n  // Initializes the main properties `tag`, `begin`, `end`, `height`.\n  inline void InitInstance(int height, size_t begin = 0, size_t end = 0);\n\n  // Direct property access begin / end\n  void set_begin(size_t begin) { storage[1] = static_cast<uint8_t>(begin); }\n  void set_end(size_t end) { storage[2] = static_cast<uint8_t>(end); }\n\n  // Decreases the value of `begin` by `n`, and returns the new value. Notice\n  // how this returns the new value unlike atomic::fetch_add which returns the\n  // old value. This is because this is used to prepend edges at 'begin - 1'.\n  size_t sub_fetch_begin(size_t n) {\n    storage[1] -= static_cast<uint8_t>(n);\n    return storage[1];\n  }\n\n  // Increases the value of `end` by `n`, and returns the previous value. This\n  // function is typically used to append edges at 'end'.\n  size_t fetch_add_end(size_t n) {\n    const uint8_t current = storage[2];\n    storage[2] = static_cast<uint8_t>(current + n);\n    return current;\n  }\n\n  // Returns the index of the last edge starting on, or before `offset`, with\n  // `n` containing the relative offset of `offset` inside that edge.\n  // Requires `offset` < length.\n  Position IndexOf(size_t offset) const;\n\n  // Returns the index of the last edge starting before `offset`, with `n`\n  // containing the relative offset of `offset` inside that edge.\n  // This function is useful to find the edges for some span of bytes ending at\n  // `offset` (i.e., `n` bytes). For example:\n  //\n  //   Position pos = IndexBefore(n)\n  //   edges = Edges(begin(), pos.index)     // All full edges (may be empty)\n  //   last = Sub(Edge(pos.index), 0, pos.n) // Last partial edge (may be empty)\n  //\n  // Requires 0 < `offset` <= length.\n  Position IndexBefore(size_t offset) const;\n\n  // Returns the index of the edge ending at (or on) length `length`, and the\n  // number of bytes inside that edge up to `length`. For example, if we have a\n  // Node with 2 edges, one of 10 and one of 20 long, then IndexOfLength(27)\n  // will return {1, 17}, and IndexOfLength(10) will return {0, 10}.\n  Position IndexOfLength(size_t n) const;\n\n  // Identical to the above function except starting from the position `front`.\n  // This function is equivalent to `IndexBefore(front.n + offset)`, with\n  // the difference that this function is optimized to start at `front.index`.\n  Position IndexBefore(Position front, size_t offset) const;\n\n  // Returns the index of the edge directly beyond the edge containing offset\n  // `offset`, with `n` containing the distance of that edge from `offset`.\n  // This function is useful for iteratively finding suffix nodes and remaining\n  // partial bytes in left-most suffix nodes as for example in CopySuffix.\n  // Requires `offset` < length.\n  Position IndexBeyond(size_t offset) const;\n\n  // Creates a new leaf node containing as much data as possible from `data`.\n  // The data is added either forwards or reversed depending on `edge_type`.\n  // Callers must check the length of the returned node to determine if all data\n  // was copied or not.\n  // See the `Append/Prepend` function for the meaning and purpose of `extra`.\n  template <EdgeType edge_type>\n  static CordRepBtree* NewLeaf(absl::string_view data, size_t extra);\n\n  // Creates a raw copy of this Btree node with the specified length, copying\n  // all properties, but without adding any references to existing edges.\n  CordRepBtree* CopyRaw(size_t new_length) const;\n\n  // Creates a full copy of this Btree node, adding a reference on all edges.\n  CordRepBtree* Copy() const;\n\n  // Creates a partial copy of this Btree node, copying all edges up to `end`,\n  // adding a reference on each copied edge, and sets the length of the newly\n  // created copy to `new_length`.\n  CordRepBtree* CopyBeginTo(size_t end, size_t new_length) const;\n\n  // Returns a tree containing the edges [tree->begin(), end) and length\n  // of `new_length`. This method consumes a reference on the provided\n  // tree, and logically performs the following operation:\n  //   result = tree->CopyBeginTo(end, new_length);\n  //   CordRep::Unref(tree);\n  //   return result;\n  static CordRepBtree* ConsumeBeginTo(CordRepBtree* tree, size_t end,\n                                      size_t new_length);\n\n  // Creates a partial copy of this Btree node, copying all edges starting at\n  // `begin`, adding a reference on each copied edge, and sets the length of\n  // the newly created copy to `new_length`.\n  CordRepBtree* CopyToEndFrom(size_t begin, size_t new_length) const;\n\n  // Extracts and returns the front edge from the provided tree.\n  // This method consumes a reference on the provided tree, and logically\n  // performs the following operation:\n  //   edge = CordRep::Ref(tree->Edge(kFront));\n  //   CordRep::Unref(tree);\n  //   return edge;\n  static CordRep* ExtractFront(CordRepBtree* tree);\n\n  // Returns a tree containing the result of appending `right` to `left`.\n  static CordRepBtree* MergeTrees(CordRepBtree* left, CordRepBtree* right);\n\n  // Fallback functions for `Create()`, `Append()` and `Prepend()` which\n  // deal with legacy / non conforming input, i.e.: CONCAT trees.\n  static CordRepBtree* CreateSlow(CordRep* rep);\n  static CordRepBtree* AppendSlow(CordRepBtree*, CordRep* rep);\n  static CordRepBtree* PrependSlow(CordRepBtree*, CordRep* rep);\n\n  // Recursively rebuilds `tree` into `stack`. If 'consume` is set to true, the\n  // function will consume a reference on `tree`. `stack` is a null terminated\n  // array containing the new tree's state, with the current leaf node at\n  // stack[0], and parent nodes above that, or null for 'top of tree'.\n  static void Rebuild(CordRepBtree** stack, CordRepBtree* tree, bool consume);\n\n  // Aligns existing edges to start at index 0, to allow for a new edge to be\n  // added to the back of the current edges.\n  inline void AlignBegin();\n\n  // Aligns existing edges to end at `capacity`, to allow for a new edge to be\n  // added in front of the current edges.\n  inline void AlignEnd();\n\n  // Adds the provided edge to this node.\n  // Requires this node to have capacity for the edge. Realigns / moves\n  // existing edges as needed to prepend or append the new edge.\n  template <EdgeType edge_type>\n  inline void Add(CordRep* rep);\n\n  // Adds the provided edges to this node.\n  // Requires this node to have capacity for the edges. Realigns / moves\n  // existing edges as needed to prepend or append the new edges.\n  template <EdgeType edge_type>\n  inline void Add(absl::Span<CordRep* const>);\n\n  // Adds data from `data` to this node until either all data has been consumed,\n  // or there is no more capacity for additional flat nodes inside this node.\n  // Requires the current node to be a leaf node, data to be non empty, and the\n  // current node to have capacity for at least one more data edge.\n  // Returns any remaining data from `data` that was not added, which is\n  // depending on the edge type (front / back) either the remaining prefix of\n  // suffix of the input.\n  // See the `Append/Prepend` function for the meaning and purpose of `extra`.\n  template <EdgeType edge_type>\n  absl::string_view AddData(absl::string_view data, size_t extra);\n\n  // Replace the front or back edge with the provided value.\n  // Adopts a reference on `edge` and unrefs the old edge.\n  template <EdgeType edge_type>\n  inline void SetEdge(CordRep* edge);\n\n  // Returns a partial copy of the current tree containing the first `n` bytes\n  // of data. `CopyResult` contains both the resulting edge and its height. The\n  // resulting tree may be less high than the current tree, or even be a single\n  // matching data edge if `allow_folding` is set to true.\n  // For example, if `n == 1`, then the result will be the single data edge, and\n  // height will be set to -1 (one below the owning leaf node). If n == 0, this\n  // function returns null. Requires `n <= length`\n  CopyResult CopyPrefix(size_t n, bool allow_folding = true);\n\n  // Returns a partial copy of the current tree containing all data starting\n  // after `offset`. `CopyResult` contains both the resulting edge and its\n  // height. The resulting tree may be less high than the current tree, or even\n  // be a single matching data edge. For example, if `n == length - 1`, then the\n  // result will be a single data edge, and height will be set to -1 (one below\n  // the owning leaf node).\n  // Requires `offset < length`\n  CopyResult CopySuffix(size_t offset);\n\n  // Returns a OpResult value of {this, kSelf} or {Copy(), kCopied}\n  // depending on the value of `owned`.\n  inline OpResult ToOpResult(bool owned);\n\n  // Adds `rep` to the specified tree, returning the modified tree.\n  template <EdgeType edge_type>\n  static CordRepBtree* AddCordRep(CordRepBtree* tree, CordRep* rep);\n\n  // Adds `data` to the specified tree, returning the modified tree.\n  // See the `Append/Prepend` function for the meaning and purpose of `extra`.\n  template <EdgeType edge_type>\n  static CordRepBtree* AddData(CordRepBtree* tree, absl::string_view data,\n                               size_t extra = 0);\n\n  // Merges `src` into `dst` with `src` being added either before (kFront) or\n  // after (kBack) `dst`. Requires the height of `dst` to be greater than or\n  // equal to the height of `src`.\n  template <EdgeType edge_type>\n  static CordRepBtree* Merge(CordRepBtree* dst, CordRepBtree* src);\n\n  // Fallback version of GetAppendBuffer for large trees: GetAppendBuffer()\n  // implements an inlined version for trees of limited height (3 levels),\n  // GetAppendBufferSlow implements the logic for large trees.\n  Span<char> GetAppendBufferSlow(size_t size);\n\n  // `edges_` contains all edges starting from this instance.\n  // These are explicitly `child` edges only, a cord btree (or any cord tree in\n  // that respect) does not store `parent` pointers anywhere: multiple trees /\n  // parents can reference the same shared child edge. The type of these edges\n  // depends on the height of the node. `Leaf nodes` (height == 0) contain `data\n  // edges` (external or flat nodes, or sub-strings thereof). All other nodes\n  // (height > 0) contain pointers to BTREE nodes with a height of `height - 1`.\n  CordRep* edges_[kMaxCapacity];\n\n  friend class CordRepBtreeTestPeer;\n  friend class CordRepBtreeNavigator;\n}",
  "id": "BLOCK-CPP-06133",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree.h",
  "source_line": 71,
  "validation_status": "validated"
}