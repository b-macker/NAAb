{
  "code": "{\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, const ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n}",
  "id": "BLOCK-CPP-09393",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclTemplate.h",
  "source_line": 3040,
  "validation_status": "validated"
}