{
  "code": "{\n  /// The FileID's of the cached query.\n  ///\n  /// If these match up with a subsequent query, the result can be reused.\n  FileID LQueryFID, RQueryFID;\n\n  /// The relative order of FileIDs that the CommonFID *immediately* includes.\n  ///\n  /// This is used to compare macro expansion locations.\n  bool LChildBeforeRChild;\n\n  /// The file found in common between the two \\#include traces, i.e.,\n  /// the nearest common ancestor of the \\#include tree.\n  FileID CommonFID;\n\n  /// The offset of the previous query in CommonFID.\n  ///\n  /// Usually, this represents the location of the \\#include for QueryFID, but\n  /// if LQueryFID is a parent of RQueryFID (or vice versa) then these can be a\n  /// random token in the parent.\n  unsigned LCommonOffset, RCommonOffset;\n\npublic:\n  InBeforeInTUCacheEntry() = default;\n  InBeforeInTUCacheEntry(FileID L, FileID R) : LQueryFID(L), RQueryFID(R) {\n    assert(L != R);\n  }\n\n  /// Return true if the currently cached values match up with\n  /// the specified LHS/RHS query.\n  ///\n  /// If not, we can't use the cache.\n  bool isCacheValid() const {\n    return CommonFID.isValid();\n  }\n\n  /// If the cache is valid, compute the result given the\n  /// specified offsets in the LHS/RHS FileID's.\n  bool getCachedResult(unsigned LOffset, unsigned ROffset) const {\n    // If one of the query files is the common file, use the offset.  Otherwise,\n    // use the #include loc in the common file.\n    if (LQueryFID != CommonFID) LOffset = LCommonOffset;\n    if (RQueryFID != CommonFID) ROffset = RCommonOffset;\n\n    // It is common for multiple macro expansions to be \"included\" from the same\n    // location (expansion location), in which case use the order of the FileIDs\n    // to determine which came first. This will also take care the case where\n    // one of the locations points at the inclusion/expansion point of the other\n    // in which case its FileID will come before the other.\n    if (LOffset == ROffset)\n      return LChildBeforeRChild;\n\n    return LOffset < ROffset;\n  }\n\n  /// Set up a new query.\n  /// If it matches the old query, we can keep the cached answer.\n  void setQueryFIDs(FileID LHS, FileID RHS) {\n    assert(LHS != RHS);\n    if (LQueryFID != LHS || RQueryFID != RHS) {\n      LQueryFID = LHS;\n      RQueryFID = RHS;\n      CommonFID = FileID();\n    }\n  }\n\n  void setCommonLoc(FileID commonFID, unsigned lCommonOffset,\n                    unsigned rCommonOffset, bool LParentBeforeRParent) {\n    CommonFID = commonFID;\n    LCommonOffset = lCommonOffset;\n    RCommonOffset = rCommonOffset;\n    LChildBeforeRChild = LParentBeforeRParent;\n  }\n}",
  "id": "BLOCK-CPP-16985",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/SourceManager.h",
  "source_line": 546,
  "validation_status": "validated"
}