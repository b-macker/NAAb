{
  "code": "{\n\nclass DiagnosticsEngine;\nclass Preprocessor;\nclass Token;\nclass SourceLocation;\nclass TargetInfo;\nclass SourceManager;\nclass LangOptions;\n\n/// Copy characters from Input to Buf, expanding any UCNs.\nvoid expandUCNs(SmallVectorImpl<char> &Buf, StringRef Input);\n\n/// NumericLiteralParser - This performs strict semantic analysis of the content\n/// of a ppnumber, classifying it as either integer, floating, or erroneous,\n/// determines the radix of the value and can convert it to a useful value.\nclass NumericLiteralParser {\n  const SourceManager &SM;\n  const LangOptions &LangOpts;\n  DiagnosticsEngine &Diags;\n\n  const char *const ThisTokBegin;\n  const char *const ThisTokEnd;\n  const char *DigitsBegin, *SuffixBegin; // markers\n  const char *s; // cursor\n\n  unsigned radix;\n\n  bool saw_exponent, saw_period, saw_ud_suffix, saw_fixed_point_suffix;\n\n  SmallString<32> UDSuffixBuf;\n\npublic:\n  NumericLiteralParser(StringRef TokSpelling, SourceLocation TokLoc,\n                       const SourceManager &SM, const LangOptions &LangOpts,\n                       const TargetInfo &Target, DiagnosticsEngine &Diags);\n  bool hadError : 1;\n  bool isUnsigned : 1;\n  bool isLong : 1;          // This is *not* set for long long.\n  bool isLongLong : 1;\n  bool isSizeT : 1;         // 1z, 1uz (C++23)\n  bool isHalf : 1;          // 1.0h\n  bool isFloat : 1;         // 1.0f\n  bool isImaginary : 1;     // 1.0i\n  bool isFloat16 : 1;       // 1.0f16\n  bool isFloat128 : 1;      // 1.0q\n  bool isFract : 1;         // 1.0hr/r/lr/uhr/ur/ulr\n  bool isAccum : 1;         // 1.0hk/k/lk/uhk/uk/ulk\n  bool isBitInt : 1;        // 1wb, 1uwb (C2x)\n  uint8_t MicrosoftInteger; // Microsoft suffix extension i8, i16, i32, or i64.\n\n\n  bool isFixedPointLiteral() const {\n    return (saw_period || saw_exponent) && saw_fixed_point_suffix;\n  }\n\n  bool isIntegerLiteral() const {\n    return !saw_period && !saw_exponent && !isFixedPointLiteral();\n  }\n  bool isFloatingLiteral() const {\n    return (saw_period || saw_exponent) && !isFixedPointLiteral();\n  }\n\n  bool hasUDSuffix() const {\n    return saw_ud_suffix;\n  }\n  StringRef getUDSuffix() const {\n    assert(saw_ud_suffix);\n    return UDSuffixBuf;\n  }\n  unsigned getUDSuffixOffset() const {\n    assert(saw_ud_suffix);\n    return SuffixBegin - ThisTokBegin;\n  }\n\n  static bool isValidUDSuffix(const LangOptions &LangOpts, StringRef Suffix);\n\n  unsigned getRadix() const { return radix; }\n\n  /// GetIntegerValue - Convert this numeric literal value to an APInt that\n  /// matches Val's input width.  If there is an overflow (i.e., if the unsigned\n  /// value read is larger than the APInt's bits will hold), set Val to the low\n  /// bits of the result and return true.  Otherwise, return false.\n  bool GetIntegerValue(llvm::APInt &Val);\n\n  /// GetFloatValue - Convert this numeric literal to a floating value, using\n  /// the specified APFloat fltSemantics (specifying float, double, etc).\n  /// The optional bool isExact (passed-by-reference) has its value\n  /// set to true if the returned APFloat can represent the number in the\n  /// literal exactly, and false otherwise.\n  llvm::APFloat::opStatus GetFloatValue(llvm::APFloat &Result);\n\n  /// GetFixedPointValue - Convert this numeric literal value into a\n  /// scaled integer that represents this value. Returns true if an overflow\n  /// occurred when calculating the integral part of the scaled integer or\n  /// calculating the digit sequence of the exponent.\n  bool GetFixedPointValue(llvm::APInt &StoreVal, unsigned Scale);\n\n  /// Get the digits that comprise the literal. This excludes any prefix or\n  /// suffix associated with the literal.\n  StringRef getLiteralDigits() const {\n    assert(!hadError && \"cannot reliably get the literal digits with an error\");\n    return StringRef(DigitsBegin, SuffixBegin - DigitsBegin);\n  }\n\nprivate:\n\n  void ParseNumberStartingWithZero(SourceLocation TokLoc);\n  void ParseDecimalOrOctalCommon(SourceLocation TokLoc);\n\n  static bool isDigitSeparator(char C) { return C == '\\''; }\n\n  /// Determine whether the sequence of characters [Start, End) contains\n  /// any real digits (not digit separators).\n  bool containsDigits(const char *Start, const char *End) {\n    return Start != End && (Start + 1 != End || !isDigitSeparator(Start[0]));\n  }\n\n  enum CheckSeparatorKind { CSK_BeforeDigits, CSK_AfterDigits };\n\n  /// Ensure that we don't have a digit separator here.\n  void checkSeparator(SourceLocation TokLoc, const char *Pos,\n                      CheckSeparatorKind IsAfterDigits);\n\n  /// SkipHexDigits - Read and skip over any hex digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipHexDigits(const char *ptr) {\n    while (ptr != ThisTokEnd && (isHexDigit(*ptr) || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipOctalDigits - Read and skip over any octal digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipOctalDigits(const char *ptr) {\n    while (ptr != ThisTokEnd &&\n           ((*ptr >= '0' && *ptr <= '7') || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipDigits - Read and skip over any digits, up to End.\n  /// Return a pointer to the first non-hex digit or End.\n  const char *SkipDigits(const char *ptr) {\n    while (ptr != ThisTokEnd && (isDigit(*ptr) || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n  /// SkipBinaryDigits - Read and skip over any binary digits, up to End.\n  /// Return a pointer to the first non-binary digit or End.\n  const char *SkipBinaryDigits(const char *ptr) {\n    while (ptr != ThisTokEnd &&\n           (*ptr == '0' || *ptr == '1' || isDigitSeparator(*ptr)))\n      ptr++;\n    return ptr;\n  }\n\n};\n\n/// CharLiteralParser - Perform interpretation and semantic analysis of a\n/// character literal.\nclass CharLiteralParser {\n  uint64_t Value;\n  tok::TokenKind Kind;\n  bool IsMultiChar;\n  bool HadError;\n  SmallString<32> UDSuffixBuf;\n  unsigned UDSuffixOffset;\npublic:\n  CharLiteralParser(const char *begin, const char *end,\n                    SourceLocation Loc, Preprocessor &PP,\n                    tok::TokenKind kind);\n\n  bool hadError() const { return HadError; }\n  bool isOrdinary() const { return Kind == tok::char_constant; }\n  bool isWide() const { return Kind == tok::wide_char_constant; }\n  bool isUTF8() const { return Kind == tok::utf8_char_constant; }\n  bool isUTF16() const { return Kind == tok::utf16_char_constant; }\n  bool isUTF32() const { return Kind == tok::utf32_char_constant; }\n  bool isMultiChar() const { return IsMultiChar; }\n  uint64_t getValue() const { return Value; }\n  StringRef getUDSuffix() const { return UDSuffixBuf; }\n  unsigned getUDSuffixOffset() const {\n    assert(!UDSuffixBuf.empty() && \"no ud-suffix\");\n    return UDSuffixOffset;\n  }\n};\n\nenum class StringLiteralEvalMethod {\n  Evaluated,\n  Unevaluated,\n};\n\n/// StringLiteralParser - This decodes string escape characters and performs\n/// wide string analysis and Translation Phase #6 (concatenation of string\n/// literals) (C99 5.1.1.2p1).\nclass StringLiteralParser {\n  const SourceManager &SM;\n  const LangOptions &Features;\n  const TargetInfo &Target;\n  DiagnosticsEngine *Diags;\n\n  unsigned MaxTokenLength;\n  unsigned SizeBound;\n  unsigned CharByteWidth;\n  tok::TokenKind Kind;\n  SmallString<512> ResultBuf;\n  char *ResultPtr; // cursor\n  SmallString<32> UDSuffixBuf;\n  unsigned UDSuffixToken;\n  unsigned UDSuffixOffset;\n  StringLiteralEvalMethod EvalMethod;\n\npublic:\n  StringLiteralParser(ArrayRef<Token> StringToks, Preprocessor &PP,\n                      StringLiteralEvalMethod StringMethod =\n                          StringLiteralEvalMethod::Evaluated);\n  StringLiteralParser(ArrayRef<Token> StringToks, const SourceManager &sm,\n                      const LangOptions &features, const TargetInfo &target,\n                      DiagnosticsEngine *diags = nullptr)\n      : SM(sm), Features(features), Target(target), Diags(diags),\n        MaxTokenLength(0), SizeBound(0), CharByteWidth(0), Kind(tok::unknown),\n        ResultPtr(ResultBuf.data()),\n        EvalMethod(StringLiteralEvalMethod::Evaluated), hadError(false),\n        Pascal(false) {\n    init(StringToks);\n  }\n\n  bool hadError;\n  bool Pascal;\n\n  StringRef GetString() const {\n    return StringRef(ResultBuf.data(), GetStringLength());\n  }\n  unsigned GetStringLength() const { return ResultPtr-ResultBuf.data(); }\n\n  unsigned GetNumStringChars() const {\n    return GetStringLength() / CharByteWidth;\n  }\n  /// getOffsetOfStringByte - This function returns the offset of the\n  /// specified byte of the string data represented by Token.  This handles\n  /// advancing over escape sequences in the string.\n  ///\n  /// If the Diagnostics pointer is non-null, then this will do semantic\n  /// checking of the string literal and emit errors and warnings.\n  unsigned getOffsetOfStringByte(const Token &TheTok, unsigned ByteNo) const;\n\n  bool isOrdinary() const { return Kind == tok::string_literal; }\n  bool isWide() const { return Kind == tok::wide_string_literal; }\n  bool isUTF8() const { return Kind == tok::utf8_string_literal; }\n  bool isUTF16() const { return Kind == tok::utf16_string_literal; }\n  bool isUTF32() const { return Kind == tok::utf32_string_literal; }\n  bool isPascal() const { return Pascal; }\n  bool isUnevaluated() const {\n    return EvalMethod == StringLiteralEvalMethod::Unevaluated;\n  }\n\n  StringRef getUDSuffix() const { return UDSuffixBuf; }\n\n  /// Get the index of a token containing a ud-suffix.\n  unsigned getUDSuffixToken() const {\n    assert(!UDSuffixBuf.empty() && \"no ud-suffix\");\n    return UDSuffixToken;\n  }\n  /// Get the spelling offset of the first byte of the ud-suffix.\n  unsigned getUDSuffixOffset() const {\n    assert(!UDSuffixBuf.empty() && \"no ud-suffix\");\n    return UDSuffixOffset;\n  }\n\n  static bool isValidUDSuffix(const LangOptions &LangOpts, StringRef Suffix);\n\nprivate:\n  void init(ArrayRef<Token> StringToks);\n  bool CopyStringFragment(const Token &Tok, const char *TokBegin,\n                          StringRef Fragment);\n  void DiagnoseLexingError(SourceLocation Loc);\n};\n\n}",
  "id": "BLOCK-CPP-18682",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Lex/LiteralSupport.h",
  "source_line": 26,
  "validation_status": "validated"
}