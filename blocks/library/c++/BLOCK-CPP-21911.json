{
  "code": "{\npublic:\n  /// Supplements `Environment` with non-standard comparison and join\n  /// operations.\n  class ValueModel {\n  public:\n    virtual ~ValueModel() = default;\n\n    /// Returns:\n    ///   `Same`: `Val1` is equivalent to `Val2`, according to the model.\n    ///   `Different`: `Val1` is distinct from `Val2`, according to the model.\n    ///   `Unknown`: The model can't determine a relationship between `Val1` and\n    ///    `Val2`.\n    ///\n    /// Requirements:\n    ///\n    ///  `Val1` and `Val2` must be distinct.\n    ///\n    ///  `Val1` and `Val2` must model values of type `Type`.\n    ///\n    ///  `Val1` and `Val2` must be assigned to the same storage location in\n    ///  `Env1` and `Env2` respectively.\n    virtual ComparisonResult compare(QualType Type, const Value &Val1,\n                                     const Environment &Env1, const Value &Val2,\n                                     const Environment &Env2) {\n      // FIXME: Consider adding QualType to StructValue and removing the Type\n      // argument here.\n      return ComparisonResult::Unknown;\n    }\n\n    /// Modifies `MergedVal` to approximate both `Val1` and `Val2`. This could\n    /// be a strict lattice join or a more general widening operation.\n    ///\n    /// If this function returns true, `MergedVal` will be assigned to a storage\n    /// location of type `Type` in `MergedEnv`.\n    ///\n    /// `Env1` and `Env2` can be used to query child values and path condition\n    /// implications of `Val1` and `Val2` respectively.\n    ///\n    /// Requirements:\n    ///\n    ///  `Val1` and `Val2` must be distinct.\n    ///\n    ///  `Val1`, `Val2`, and `MergedVal` must model values of type `Type`.\n    ///\n    ///  `Val1` and `Val2` must be assigned to the same storage location in\n    ///  `Env1` and `Env2` respectively.\n    virtual bool merge(QualType Type, const Value &Val1,\n                       const Environment &Env1, const Value &Val2,\n                       const Environment &Env2, Value &MergedVal,\n                       Environment &MergedEnv) {\n      return true;\n    }\n\n    /// This function may widen the current value -- replace it with an\n    /// approximation that can reach a fixed point more quickly than iterated\n    /// application of the transfer function alone. The previous value is\n    /// provided to inform the choice of widened value. The function must also\n    /// serve as a comparison operation, by indicating whether the widened value\n    /// is equivalent to the previous value.\n    ///\n    /// Returns either:\n    ///\n    ///   `nullptr`, if this value is not of interest to the model, or\n    ///\n    ///   `&Prev`, if the widened value is equivalent to `Prev`, or\n    ///\n    ///   A non-null value that approximates `Current`. `Prev` is available to\n    ///   inform the chosen approximation.\n    ///\n    /// `PrevEnv` and `CurrentEnv` can be used to query child values and path\n    /// condition implications of `Prev` and `Current`, respectively.\n    ///\n    /// Requirements:\n    ///\n    ///  `Prev` and `Current` must model values of type `Type`.\n    ///\n    ///  `Prev` and `Current` must be assigned to the same storage location in\n    ///  `PrevEnv` and `CurrentEnv`, respectively.\n    virtual Value *widen(QualType Type, Value &Prev, const Environment &PrevEnv,\n                         Value &Current, Environment &CurrentEnv) {\n      // The default implementation reduces to just comparison, since comparison\n      // is required by the API, even if no widening is performed.\n      switch (compare(Type, Prev, PrevEnv, Current, CurrentEnv)) {\n        case ComparisonResult::Same:\n          return &Prev;\n        case ComparisonResult::Different:\n          return &Current;\n        case ComparisonResult::Unknown:\n          return nullptr;\n      }\n      llvm_unreachable(\"all cases in switch covered\");\n    }\n  };\n\n  /// Creates an environment that uses `DACtx` to store objects that encompass\n  /// the state of a program.\n  explicit Environment(DataflowAnalysisContext &DACtx);\n\n  // Copy-constructor is private, Environments should not be copied. See fork().\n  Environment &operator=(const Environment &Other) = delete;\n\n  Environment(Environment &&Other) = default;\n  Environment &operator=(Environment &&Other) = default;\n\n  /// Creates an environment that uses `DACtx` to store objects that encompass\n  /// the state of a program.\n  ///\n  /// If `DeclCtx` is a function, initializes the environment with symbolic\n  /// representations of the function parameters.\n  ///\n  /// If `DeclCtx` is a non-static member function, initializes the environment\n  /// with a symbolic representation of the `this` pointee.\n  Environment(DataflowAnalysisContext &DACtx, const DeclContext &DeclCtx);\n\n  /// Returns a new environment that is a copy of this one.\n  ///\n  /// The state of the program is initially the same, but can be mutated without\n  /// affecting the original.\n  ///\n  /// However the original should not be further mutated, as this may interfere\n  /// with the fork. (In practice, values are stored independently, but the\n  /// forked flow condition references the original).\n  Environment fork() const;\n\n  /// Creates and returns an environment to use for an inline analysis  of the\n  /// callee. Uses the storage location from each argument in the `Call` as the\n  /// storage location for the corresponding parameter in the callee.\n  ///\n  /// Requirements:\n  ///\n  ///  The callee of `Call` must be a `FunctionDecl`.\n  ///\n  ///  The body of the callee must not reference globals.\n  ///\n  ///  The arguments of `Call` must map 1:1 to the callee's parameters.\n  Environment pushCall(const CallExpr *Call) const;\n  Environment pushCall(const CXXConstructExpr *Call) const;\n\n  /// Moves gathered information back into `this` from a `CalleeEnv` created via\n  /// `pushCall`.\n  void popCall(const CallExpr *Call, const Environment &CalleeEnv);\n  void popCall(const CXXConstructExpr *Call, const Environment &CalleeEnv);\n\n  /// Returns true if and only if the environment is equivalent to `Other`, i.e\n  /// the two environments:\n  ///  - have the same mappings from declarations to storage locations,\n  ///  - have the same mappings from expressions to storage locations,\n  ///  - have the same or equivalent (according to `Model`) values assigned to\n  ///    the same storage locations.\n  ///\n  /// Requirements:\n  ///\n  ///  `Other` and `this` must use the same `DataflowAnalysisContext`.\n  bool equivalentTo(const Environment &Other,\n                    Environment::ValueModel &Model) const;\n\n  /// Joins two environments by taking the intersection of storage locations and\n  /// values that are stored in them. Distinct values that are assigned to the\n  /// same storage locations in `EnvA` and `EnvB` are merged using `Model`.\n  ///\n  /// Requirements:\n  ///\n  ///  `EnvA` and `EnvB` must use the same `DataflowAnalysisContext`.\n  static Environment join(const Environment &EnvA, const Environment &EnvB,\n                          Environment::ValueModel &Model);\n\n  /// Widens the environment point-wise, using `PrevEnv` as needed to inform the\n  /// approximation.\n  ///\n  /// Requirements:\n  ///\n  ///  `PrevEnv` must be the immediate previous version of the environment.\n  ///  `PrevEnv` and `this` must use the same `DataflowAnalysisContext`.\n  LatticeJoinEffect widen(const Environment &PrevEnv,\n                          Environment::ValueModel &Model);\n\n  // FIXME: Rename `createOrGetStorageLocation` to `getOrCreateStorageLocation`,\n  // `getStableStorageLocation`, or something more appropriate.\n\n  /// Creates a storage location appropriate for `Type`. Does not assign a value\n  /// to the returned storage location in the environment.\n  ///\n  /// Requirements:\n  ///\n  ///  `Type` must not be null.\n  StorageLocation &createStorageLocation(QualType Type);\n\n  /// Creates a storage location for `D`. Does not assign the returned storage\n  /// location to `D` in the environment. Does not assign a value to the\n  /// returned storage location in the environment.\n  StorageLocation &createStorageLocation(const VarDecl &D);\n\n  /// Creates a storage location for `E`. Does not assign the returned storage\n  /// location to `E` in the environment. Does not assign a value to the\n  /// returned storage location in the environment.\n  StorageLocation &createStorageLocation(const Expr &E);\n\n  /// Assigns `Loc` as the storage location of `D` in the environment.\n  ///\n  /// Requirements:\n  ///\n  ///  `D` must not already have a storage location in the environment.\n  ///\n  ///  If `D` has reference type, `Loc` must refer directly to the referenced\n  ///  object (if any), not to a `ReferenceValue`, and it is not permitted to\n  ///  later change `Loc` to refer to a `ReferenceValue.`\n  void setStorageLocation(const ValueDecl &D, StorageLocation &Loc);\n\n  /// Returns the storage location assigned to `D` in the environment, or null\n  /// if `D` isn't assigned a storage location in the environment.\n  ///\n  /// Note that if `D` has reference type, the storage location that is returned\n  /// refers directly to the referenced object, not a `ReferenceValue`.\n  StorageLocation *getStorageLocation(const ValueDecl &D) const;\n\n  /// Assigns `Loc` as the storage location of `E` in the environment.\n  ///\n  /// This function is deprecated; prefer `setStorageLocationStrict()`.\n  /// For details, see https://discourse.llvm.org/t/70086.\n  ///\n  /// Requirements:\n  ///\n  ///  `E` must not be assigned a storage location in the environment.\n  void setStorageLocation(const Expr &E, StorageLocation &Loc);\n\n  /// Assigns `Loc` as the storage location of the glvalue `E` in the\n  /// environment.\n  ///\n  /// This function is the preferred alternative to\n  /// `setStorageLocation(const Expr &, StorageLocation &)`. Once the migration\n  /// to strict handling of value categories is complete (see\n  /// https://discourse.llvm.org/t/70086), `setStorageLocation()` will be\n  /// removed and this function will be renamed to `setStorageLocation()`.\n  ///\n  /// Requirements:\n  ///\n  ///  `E` must not be assigned a storage location in the environment.\n  ///  `E` must be a glvalue or a `BuiltinType::BuiltinFn`\n  void setStorageLocationStrict(const Expr &E, StorageLocation &Loc);\n\n  /// Returns the storage location assigned to `E` in the environment, applying\n  /// the `SP` policy for skipping past indirections, or null if `E` isn't\n  /// assigned a storage location in the environment.\n  ///\n  /// This function is deprecated; prefer `getStorageLocationStrict()`.\n  /// For details, see https://discourse.llvm.org/t/70086.\n  StorageLocation *getStorageLocation(const Expr &E, SkipPast SP) const;\n\n  /// Returns the storage location assigned to the glvalue `E` in the\n  /// environment, or null if `E` isn't assigned a storage location in the\n  /// environment.\n  ///\n  /// If the storage location for `E` is associated with a\n  /// `ReferenceValue RefVal`, returns `RefVal.getReferentLoc()` instead.\n  ///\n  /// This function is the preferred alternative to\n  /// `getStorageLocation(const Expr &, SkipPast)`. Once the migration\n  /// to strict handling of value categories is complete (see\n  /// https://discourse.llvm.org/t/70086), `getStorageLocation()` will be\n  /// removed and this function will be renamed to `getStorageLocation()`.\n  ///\n  /// Requirements:\n  ///  `E` must be a glvalue or a `BuiltinType::BuiltinFn`\n  StorageLocation *getStorageLocationStrict(const Expr &E) const;\n\n  /// Returns the storage location assigned to the `this` pointee in the\n  /// environment or null if the `this` pointee has no assigned storage location\n  /// in the environment.\n  AggregateStorageLocation *getThisPointeeStorageLocation() const;\n\n  /// Returns the location of the result object for a record-type prvalue.\n  ///\n  /// In C++, prvalues of record type serve only a limited purpose: They can\n  /// only be used to initialize a result object (e.g. a variable or a\n  /// temporary). This function returns the location of that result object.\n  ///\n  /// When creating a prvalue of record type, we already need the storage\n  /// location of the result object to pass in `this`, even though prvalues are\n  /// otherwise not associated with storage locations.\n  ///\n  /// FIXME: Currently, this simply returns a stable storage location for `E`,\n  /// but this doesn't do the right thing in scenarios like the following:\n  /// ```\n  /// MyClass c = some_condition()? MyClass(foo) : MyClass(bar);\n  /// ```\n  /// Here, `MyClass(foo)` and `MyClass(bar)` will have two different storage\n  /// locations, when in fact their storage locations should be the same.\n  /// Eventually, we want to propagate storage locations from result objects\n  /// down to the prvalues that initialize them, similar to the way that this is\n  /// done in Clang's CodeGen.\n  ///\n  /// Requirements:\n  ///  `E` must be a prvalue of record type.\n  AggregateStorageLocation &getResultObjectLocation(const Expr &RecordPRValue);\n\n  /// Returns the return value of the current function. This can be null if:\n  /// - The function has a void return type\n  /// - No return value could be determined for the function, for example\n  ///   because it calls a function without a body.\n  ///\n  /// Requirements:\n  ///  The current function must have a non-reference return type.\n  Value *getReturnValue() const {\n    assert(getCurrentFunc() != nullptr &&\n           !getCurrentFunc()->getReturnType()->isReferenceType());\n    return ReturnVal;\n  }\n\n  /// Returns the storage location for the reference returned by the current\n  /// function. This can be null if function doesn't return a single consistent\n  /// reference.\n  ///\n  /// Requirements:\n  ///  The current function must have a reference return type.\n  StorageLocation *getReturnStorageLocation() const {\n    assert(getCurrentFunc() != nullptr &&\n           getCurrentFunc()->getReturnType()->isReferenceType());\n    return ReturnLoc;\n  }\n\n  /// Sets the return value of the current function.\n  ///\n  /// Requirements:\n  ///  The current function must have a non-reference return type.\n  void setReturnValue(Value *Val) {\n    assert(getCurrentFunc() != nullptr &&\n           !getCurrentFunc()->getReturnType()->isReferenceType());\n    ReturnVal = Val;\n  }\n\n  /// Sets the storage location for the reference returned by the current\n  /// function.\n  ///\n  /// Requirements:\n  ///  The current function must have a reference return type.\n  void setReturnStorageLocation(StorageLocation *Loc) {\n    assert(getCurrentFunc() != nullptr &&\n           getCurrentFunc()->getReturnType()->isReferenceType());\n    ReturnLoc = Loc;\n  }\n\n  /// Returns a pointer value that represents a null pointer. Calls with\n  /// `PointeeType` that are canonically equivalent will return the same result.\n  PointerValue &getOrCreateNullPointerValue(QualType PointeeType);\n\n  /// Creates a value appropriate for `Type`, if `Type` is supported, otherwise\n  /// returns null.\n  ///\n  /// If `Type` is a pointer or reference type, creates all the necessary\n  /// storage locations and values for indirections until it finds a\n  /// non-pointer/non-reference type.\n  ///\n  /// If `Type` is a class, struct, or union type, calls `setValue()` to\n  /// associate the `StructValue` with its storage location\n  /// (`StructValue::getAggregateLoc()`).\n  ///\n  /// If `Type` is one of the following types, this function will always return\n  /// a non-null pointer:\n  /// - `bool`\n  /// - Any integer type\n  /// - Any class, struct, or union type\n  ///\n  /// Requirements:\n  ///\n  ///  `Type` must not be null.\n  Value *createValue(QualType Type);\n\n  /// Creates an object (i.e. a storage location with an associated value) of\n  /// type `Ty`. If `InitExpr` is non-null and has a value associated with it,\n  /// initializes the object with this value. Otherwise, initializes the object\n  /// with a value created using `createValue()`.\n  StorageLocation &createObject(QualType Ty, const Expr *InitExpr = nullptr) {\n    return createObjectInternal(nullptr, Ty, InitExpr);\n  }\n\n  /// Creates an object for the variable declaration `D`. If `D` has an\n  /// initializer and this initializer is associated with a value, initializes\n  /// the object with this value.  Otherwise, initializes the object with a\n  /// value created using `createValue()`. Uses the storage location returned by\n  /// `DataflowAnalysisContext::getStableStorageLocation(D)`.\n  StorageLocation &createObject(const VarDecl &D) {\n    return createObjectInternal(&D, D.getType(), D.getInit());\n  }\n\n  /// Creates an object for the variable declaration `D`. If `InitExpr` is\n  /// non-null and has a value associated with it, initializes the object with\n  /// this value. Otherwise, initializes the object with a value created using\n  /// `createValue()`.  Uses the storage location returned by\n  /// `DataflowAnalysisContext::getStableStorageLocation(D)`.\n  StorageLocation &createObject(const VarDecl &D, const Expr *InitExpr) {\n    return createObjectInternal(&D, D.getType(), InitExpr);\n  }\n\n  /// Assigns `Val` as the value of `Loc` in the environment.\n  void setValue(const StorageLocation &Loc, Value &Val);\n\n  /// Clears any association between `Loc` and a value in the environment.\n  void clearValue(const StorageLocation &Loc) { LocToVal.erase(&Loc); }\n\n  /// Assigns `Val` as the value of the prvalue `E` in the environment.\n  ///\n  /// If `E` is not yet associated with a storage location, associates it with\n  /// a newly created storage location. In any case, associates the storage\n  /// location of `E` with `Val`.\n  ///\n  /// Once the migration to strict handling of value categories is complete\n  /// (see https://discourse.llvm.org/t/70086), this function will be renamed to\n  /// `setValue()`. At this point, prvalue expressions will be associated\n  /// directly with `Value`s, and the legacy behavior of associating prvalue\n  /// expressions with storage locations (as described above) will be\n  /// eliminated.\n  ///\n  /// Requirements:\n  ///\n  ///  `E` must be a prvalue\n  ///  `Val` must not be a `ReferenceValue`\n  ///  If `Val` is a `StructValue`, its `AggregateStorageLocation` must be the\n  ///  same as that of any `StructValue` that has already been associated with\n  ///  `E`. This is to guarantee that the result object initialized by a prvalue\n  ///  `StructValue` has a durable storage location.\n  void setValueStrict(const Expr &E, Value &Val);\n\n  /// Returns the value assigned to `Loc` in the environment or null if `Loc`\n  /// isn't assigned a value in the environment.\n  Value *getValue(const StorageLocation &Loc) const;\n\n  /// Equivalent to `getValue(getStorageLocation(D, SP), SkipPast::None)` if `D`\n  /// is assigned a storage location in the environment, otherwise returns null.\n  Value *getValue(const ValueDecl &D) const;\n\n  /// Equivalent to `getValue(getStorageLocation(E, SP), SkipPast::None)` if `E`\n  /// is assigned a storage location in the environment, otherwise returns null.\n  ///\n  /// This function is deprecated; prefer `getValueStrict()`. For details, see\n  /// https://discourse.llvm.org/t/70086.\n  Value *getValue(const Expr &E, SkipPast SP) const;\n\n  /// Returns the `Value` assigned to the prvalue `E` in the environment, or\n  /// null if `E` isn't assigned a value in the environment.\n  ///\n  /// This function is the preferred alternative to\n  /// `getValue(const Expr &, SkipPast)`. Once the migration to strict handling\n  /// of value categories is complete (see https://discourse.llvm.org/t/70086),\n  /// `getValue()` will be removed and this function will be renamed to\n  /// `getValue()`.\n  ///\n  /// Requirements:\n  ///\n  ///  `E` must be a prvalue\n  Value *getValueStrict(const Expr &E) const;\n\n  // FIXME: should we deprecate the following & call arena().create() directly?\n\n  /// Creates a `T` (some subclass of `Value`), forwarding `args` to the\n  /// constructor, and returns a reference to it.\n  ///\n  /// The analysis context takes ownership of the created object. The object\n  /// will be destroyed when the analysis context is destroyed.\n  template <typename T, typename... Args>\n  std::enable_if_t<std::is_base_of<Value, T>::value, T &>\n  create(Args &&...args) {\n    return arena().create<T>(std::forward<Args>(args)...);\n  }\n\n  /// Returns a symbolic integer value that models an integer literal equal to\n  /// `Value`\n  IntegerValue &getIntLiteralValue(llvm::APInt Value) const {\n    return arena().makeIntLiteral(Value);\n  }\n\n  /// Returns a symbolic boolean value that models a boolean literal equal to\n  /// `Value`\n  AtomicBoolValue &getBoolLiteralValue(bool Value) const {\n    return cast<AtomicBoolValue>(\n        arena().makeBoolValue(arena().makeLiteral(Value)));\n  }\n\n  /// Returns an atomic boolean value.\n  BoolValue &makeAtomicBoolValue() const {\n    return arena().makeAtomValue();\n  }\n\n  /// Returns a unique instance of boolean Top.\n  BoolValue &makeTopBoolValue() const {\n    return arena().makeTopValue();\n  }\n\n  /// Returns a boolean value that represents the conjunction of `LHS` and\n  /// `RHS`. Subsequent calls with the same arguments, regardless of their\n  /// order, will return the same result. If the given boolean values represent\n  /// the same value, the result will be the value itself.\n  BoolValue &makeAnd(BoolValue &LHS, BoolValue &RHS) const {\n    return arena().makeBoolValue(\n        arena().makeAnd(LHS.formula(), RHS.formula()));\n  }\n\n  /// Returns a boolean value that represents the disjunction of `LHS` and\n  /// `RHS`. Subsequent calls with the same arguments, regardless of their\n  /// order, will return the same result. If the given boolean values represent\n  /// the same value, the result will be the value itself.\n  BoolValue &makeOr(BoolValue &LHS, BoolValue &RHS) const {\n    return arena().makeBoolValue(\n        arena().makeOr(LHS.formula(), RHS.formula()));\n  }\n\n  /// Returns a boolean value that represents the negation of `Val`. Subsequent\n  /// calls with the same argument will return the same result.\n  BoolValue &makeNot(BoolValue &Val) const {\n    return arena().makeBoolValue(arena().makeNot(Val.formula()));\n  }\n\n  /// Returns a boolean value represents `LHS` => `RHS`. Subsequent calls with\n  /// the same arguments, will return the same result. If the given boolean\n  /// values represent the same value, the result will be a value that\n  /// represents the true boolean literal.\n  BoolValue &makeImplication(BoolValue &LHS, BoolValue &RHS) const {\n    return arena().makeBoolValue(\n        arena().makeImplies(LHS.formula(), RHS.formula()));\n  }\n\n  /// Returns a boolean value represents `LHS` <=> `RHS`. Subsequent calls with\n  /// the same arguments, regardless of their order, will return the same\n  /// result. If the given boolean values represent the same value, the result\n  /// will be a value that represents the true boolean literal.\n  BoolValue &makeIff(BoolValue &LHS, BoolValue &RHS) const {\n    return arena().makeBoolValue(\n        arena().makeEquals(LHS.formula(), RHS.formula()));\n  }\n\n  /// Returns a boolean variable that identifies the flow condition (FC).\n  ///\n  /// The flow condition is a set of facts that are necessarily true when the\n  /// program reaches the current point, expressed as boolean formulas.\n  /// The flow condition token is equivalent to the AND of these facts.\n  ///\n  /// These may e.g. constrain the value of certain variables. A pointer\n  /// variable may have a consistent modeled PointerValue throughout, but at a\n  /// given point the Environment may tell us that the value must be non-null.\n  ///\n  /// The FC is necessary but not sufficient for this point to be reachable.\n  /// In particular, where the FC token appears in flow conditions of successor\n  /// environments, it means \"point X may have been reached\", not\n  /// \"point X was reached\".\n  Atom getFlowConditionToken() const { return FlowConditionToken; }\n\n  /// Record a fact that must be true if this point in the program is reached.\n  void addToFlowCondition(const Formula &);\n\n  /// Returns true if the formula is always true when this point is reached.\n  /// Returns false if the formula may be false, or if the flow condition isn't\n  /// sufficiently precise to prove that it is true.\n  bool flowConditionImplies(const Formula &) const;\n\n  /// Returns the `DeclContext` of the block being analysed, if any. Otherwise,\n  /// returns null.\n  const DeclContext *getDeclCtx() const { return CallStack.back(); }\n\n  /// Returns the function currently being analyzed, or null if the code being\n  /// analyzed isn't part of a function.\n  const FunctionDecl *getCurrentFunc() const {\n    return dyn_cast<FunctionDecl>(getDeclCtx());\n  }\n\n  /// Returns whether this `Environment` can be extended to analyze the given\n  /// `Callee` (i.e. if `pushCall` can be used), with recursion disallowed and a\n  /// given `MaxDepth`.\n  bool canDescend(unsigned MaxDepth, const DeclContext *Callee) const;\n\n  /// Returns the `DataflowAnalysisContext` used by the environment.\n  DataflowAnalysisContext &getDataflowAnalysisContext() const { return *DACtx; }\n\n  Arena &arena() const { return DACtx->arena(); }\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dump(raw_ostream &OS) const;\n\nprivate:\n  // The copy-constructor is for use in fork() only.\n  Environment(const Environment &) = default;\n\n  /// Creates a value appropriate for `Type`, if `Type` is supported, otherwise\n  /// return null.\n  ///\n  /// Recursively initializes storage locations and values until it sees a\n  /// self-referential pointer or reference type. `Visited` is used to track\n  /// which types appeared in the reference/pointer chain in order to avoid\n  /// creating a cyclic dependency with self-referential pointers/references.\n  ///\n  /// Requirements:\n  ///\n  ///  `Type` must not be null.\n  Value *createValueUnlessSelfReferential(QualType Type,\n                                          llvm::DenseSet<QualType> &Visited,\n                                          int Depth, int &CreatedValuesCount);\n\n  /// Creates a storage location for `Ty`. Also creates and associates a value\n  /// with the storage location, unless values of this type are not supported or\n  /// we hit one of the limits at which we stop producing values (controlled by\n  /// `Visited`, `Depth`, and `CreatedValuesCount`).\n  StorageLocation &createLocAndMaybeValue(QualType Ty,\n                                          llvm::DenseSet<QualType> &Visited,\n                                          int Depth, int &CreatedValuesCount);\n\n  /// Shared implementation of `createObject()` overloads.\n  /// `D` and `InitExpr` may be null.\n  StorageLocation &createObjectInternal(const VarDecl *D, QualType Ty,\n                                        const Expr *InitExpr);\n\n  StorageLocation &skip(StorageLocation &Loc, SkipPast SP) const;\n  const StorageLocation &skip(const StorageLocation &Loc, SkipPast SP) const;\n\n  /// Shared implementation of `pushCall` overloads. Note that unlike\n  /// `pushCall`, this member is invoked on the environment of the callee, not\n  /// of the caller.\n  void pushCallInternal(const FunctionDecl *FuncDecl,\n                        ArrayRef<const Expr *> Args);\n\n  /// Assigns storage locations and values to all global variables, fields\n  /// and functions referenced in `FuncDecl`. `FuncDecl` must have a body.\n  void initFieldsGlobalsAndFuncs(const FunctionDecl *FuncDecl);\n\n  // `DACtx` is not null and not owned by this object.\n  DataflowAnalysisContext *DACtx;\n\n  // FIXME: move the fields `CallStack`, `ReturnVal`, `ReturnLoc` and\n  // `ThisPointeeLoc` into a separate call-context object, shared between\n  // environments in the same call.\n  // https://github.com/llvm/llvm-project/issues/59005\n\n  // `DeclContext` of the block being analysed if provided.\n  std::vector<const DeclContext *> CallStack;\n\n  // Value returned by the function (if it has non-reference return type).\n  Value *ReturnVal = nullptr;\n  // Storage location of the reference returned by the function (if it has\n  // reference return type).\n  StorageLocation *ReturnLoc = nullptr;\n  // The storage location of the `this` pointee. Should only be null if the\n  // function being analyzed is only a function and not a method.\n  AggregateStorageLocation *ThisPointeeLoc = nullptr;\n\n  // Maps from program declarations and statements to storage locations that are\n  // assigned to them. Unlike the maps in `DataflowAnalysisContext`, these\n  // include only storage locations that are in scope for a particular basic\n  // block.\n  llvm::DenseMap<const ValueDecl *, StorageLocation *> DeclToLoc;\n  llvm::DenseMap<const Expr *, StorageLocation *> ExprToLoc;\n  // We preserve insertion order so that join/widen process values in\n  // deterministic sequence. This in turn produces deterministic SAT formulas.\n  llvm::MapVector<const StorageLocation *, Value *> LocToVal;\n\n  Atom FlowConditionToken;\n}",
  "id": "BLOCK-CPP-21911",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h",
  "source_line": 66,
  "validation_status": "validated"
}