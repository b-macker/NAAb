{
  "code": "{\n private:\n  using unsigned_type =\n      typename random_internal::make_unsigned_bits<IntType>::type;\n\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = log_uniform_int_distribution;\n\n    explicit param_type(\n        result_type min = 0,\n        result_type max = (std::numeric_limits<result_type>::max)(),\n        result_type base = 2)\n        : min_(min),\n          max_(max),\n          base_(base),\n          range_(static_cast<unsigned_type>(max_) -\n                 static_cast<unsigned_type>(min_)),\n          log_range_(0) {\n      assert(max_ >= min_);\n      assert(base_ > 1);\n\n      if (base_ == 2) {\n        // Determine where the first set bit is on range(), giving a log2(range)\n        // value which can be used to construct bounds.\n        log_range_ = (std::min)(random_internal::BitWidth(range()),\n                                std::numeric_limits<unsigned_type>::digits);\n      } else {\n        // NOTE: Computing the logN(x) introduces error from 2 sources:\n        // 1. Conversion of int to double loses precision for values >=\n        // 2^53, which may cause some log() computations to operate on\n        // different values.\n        // 2. The error introduced by the division will cause the result\n        // to differ from the expected value.\n        //\n        // Thus a result which should equal K may equal K +/- epsilon,\n        // which can eliminate some values depending on where the bounds fall.\n        const double inv_log_base = 1.0 / std::log(static_cast<double>(base_));\n        const double log_range = std::log(static_cast<double>(range()) + 0.5);\n        log_range_ = static_cast<int>(std::ceil(inv_log_base * log_range));\n      }\n    }\n\n    result_type(min)() const { return min_; }\n    result_type(max)() const { return max_; }\n    result_type base() const { return base_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.min_ == b.min_ && a.max_ == b.max_ && a.base_ == b.base_;\n    }\n\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class log_uniform_int_distribution;\n\n    int log_range() const { return log_range_; }\n    unsigned_type range() const { return range_; }\n\n    result_type min_;\n    result_type max_;\n    result_type base_;\n    unsigned_type range_;  // max - min\n    int log_range_;        // ceil(logN(range_))\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::log_uniform_int_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  log_uniform_int_distribution() : log_uniform_int_distribution(0) {}\n\n  explicit log_uniform_int_distribution(\n      result_type min,\n      result_type max = (std::numeric_limits<result_type>::max)(),\n      result_type base = 2)\n      : param_(min, max, base) {}\n\n  explicit log_uniform_int_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  // generating functions\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p) {\n    return static_cast<result_type>((p.min)() + Generate(g, p));\n  }\n\n  result_type(min)() const { return (param_.min)(); }\n  result_type(max)() const { return (param_.max)(); }\n  result_type base() const { return param_.base(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  friend bool operator==(const log_uniform_int_distribution& a,\n                         const log_uniform_int_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const log_uniform_int_distribution& a,\n                         const log_uniform_int_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  // Returns a log-uniform variate in the range [0, p.range()]. The caller\n  // should add min() to shift the result to the correct range.\n  template <typename URNG>\n  unsigned_type Generate(URNG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  param_type param_;\n}",
  "id": "BLOCK-CPP-03872",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/log_uniform_int_distribution.h",
  "source_line": 43,
  "validation_status": "validated"
}