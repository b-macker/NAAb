{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\n// CordzInfo tracks a profiled Cord. Each of these objects can be in two places.\n// If a Cord is alive, the CordzInfo will be in the global_cordz_infos map, and\n// can also be retrieved via the linked list starting with\n// global_cordz_infos_head and continued via the cordz_info_next() method. When\n// a Cord has reached the end of its lifespan, the CordzInfo object will be\n// migrated out of the global_cordz_infos list and the global_cordz_infos_map,\n// and will either be deleted or appended to the global_delete_queue. If it is\n// placed on the global_delete_queue, the CordzInfo object will be cleaned in\n// the destructor of a CordzSampleToken object.\nclass ABSL_LOCKABLE CordzInfo : public CordzHandle {\n public:\n  using MethodIdentifier = CordzUpdateTracker::MethodIdentifier;\n\n  // TrackCord creates a CordzInfo instance which tracks important metrics of\n  // a sampled cord, and stores the created CordzInfo instance into `cord'. All\n  // CordzInfo instances are placed in a global list which is used to discover\n  // and snapshot all actively tracked cords. Callers are responsible for\n  // calling UntrackCord() before the tracked Cord instance is deleted, or to\n  // stop tracking the sampled Cord. Callers are also responsible for guarding\n  // changes to the 'tree' value of a Cord (InlineData.tree) through the Lock()\n  // and Unlock() calls. Any change resulting in a new tree value for the cord\n  // requires a call to SetCordRep() before the old tree has been unreffed\n  // and/or deleted. `method` identifies the Cord public API method initiating\n  // the cord to be sampled.\n  // Requires `cord` to hold a tree, and `cord.cordz_info()` to be null.\n  static void TrackCord(InlineData& cord, MethodIdentifier method);\n\n  // Identical to TrackCord(), except that this function fills the\n  // `parent_stack` and `parent_method` properties of the returned CordzInfo\n  // instance from the provided `src` instance if `src` is sampled.\n  // This function should be used for sampling 'copy constructed' and 'copy\n  // assigned' cords. This function allows 'cord` to be already sampled, in\n  // which case the CordzInfo will be newly created from `src`.\n  static void TrackCord(InlineData& cord, const InlineData& src,\n                        MethodIdentifier method);\n\n  // Maybe sample the cord identified by 'cord' for method 'method'.\n  // Uses `cordz_should_profile` to randomly pick cords to be sampled, and if\n  // so, invokes `TrackCord` to start sampling `cord`.\n  static void MaybeTrackCord(InlineData& cord, MethodIdentifier method);\n\n  // Maybe sample the cord identified by 'cord' for method 'method'.\n  // `src` identifies a 'parent' cord which is assigned to `cord`, typically the\n  // input cord for a copy constructor, or an assign method such as `operator=`\n  // `cord` will be sampled if (and only if) `src` is sampled.\n  // If `cord` is currently being sampled and `src` is not being sampled, then\n  // this function will stop sampling the cord and reset the cord's cordz_info.\n  //\n  // Previously this function defined that `cord` will be sampled if either\n  // `src` is sampled, or if `cord` is randomly picked for sampling. However,\n  // this can cause issues, as there may be paths where some cord is assigned an\n  // indirect copy of it's own value. As such a 'string of copies' would then\n  // remain sampled (`src.is_profiled`), then assigning such a cord back to\n  // 'itself' creates a cycle where the cord will converge to 'always sampled`.\n  //\n  // For example:\n  //\n  //   Cord x;\n  //   for (...) {\n  //     // Copy ctor --> y.is_profiled := x.is_profiled | random(...)\n  //     Cord y = x;\n  //     ...\n  //     // Assign x = y --> x.is_profiled = y.is_profiled | random(...)\n  //     //              ==> x.is_profiled |= random(...)\n  //     //              ==> x converges to 'always profiled'\n  //     x = y;\n  //   }\n  static void MaybeTrackCord(InlineData& cord, const InlineData& src,\n                             MethodIdentifier method);\n\n  // Stops tracking changes for a sampled cord, and deletes the provided info.\n  // This function must be called before the sampled cord instance is deleted,\n  // and before the root cordrep of the sampled cord is unreffed.\n  // This function may extend the lifetime of the cordrep in cases where the\n  // CordInfo instance is being held by a concurrent collection thread.\n  void Untrack();\n\n  // Invokes UntrackCord() on `info` if `info` is not null.\n  static void MaybeUntrackCord(CordzInfo* info);\n\n  CordzInfo() = delete;\n  CordzInfo(const CordzInfo&) = delete;\n  CordzInfo& operator=(const CordzInfo&) = delete;\n\n  // Retrieves the oldest existing CordzInfo.\n  static CordzInfo* Head(const CordzSnapshot& snapshot)\n      ABSL_NO_THREAD_SAFETY_ANALYSIS;\n\n  // Retrieves the next oldest existing CordzInfo older than 'this' instance.\n  CordzInfo* Next(const CordzSnapshot& snapshot) const\n      ABSL_NO_THREAD_SAFETY_ANALYSIS;\n\n  // Locks this instance for the update identified by `method`.\n  // Increases the count for `method` in `update_tracker`.\n  void Lock(MethodIdentifier method) ABSL_EXCLUSIVE_LOCK_FUNCTION(mutex_);\n\n  // Unlocks this instance. If the contained `rep` has been set to null\n  // indicating the Cord has been cleared or is otherwise no longer sampled,\n  // then this method will delete this CordzInfo instance.\n  void Unlock() ABSL_UNLOCK_FUNCTION(mutex_);\n\n  // Asserts that this CordzInfo instance is locked.\n  void AssertHeld() ABSL_ASSERT_EXCLUSIVE_LOCK(mutex_);\n\n  // Updates the `rep` property of this instance. This methods is invoked by\n  // Cord logic each time the root node of a sampled Cord changes, and before\n  // the old root reference count is deleted. This guarantees that collection\n  // code can always safely take a reference on the tracked cord.\n  // Requires a lock to be held through the `Lock()` method.\n  // TODO(b/117940323): annotate with ABSL_EXCLUSIVE_LOCKS_REQUIRED once all\n  // Cord code is in a state where this can be proven true by the compiler.\n  void SetCordRep(CordRep* rep);\n\n  // Returns the current `rep` property of this instance with a reference\n  // added, or null if this instance represents a cord that has since been\n  // deleted or untracked.\n  CordRep* RefCordRep() const ABSL_LOCKS_EXCLUDED(mutex_);\n\n  // Returns the current value of `rep_` for testing purposes only.\n  CordRep* GetCordRepForTesting() const ABSL_NO_THREAD_SAFETY_ANALYSIS {\n    return rep_;\n  }\n\n  // Sets the current value of `rep_` for testing purposes only.\n  void SetCordRepForTesting(CordRep* rep) ABSL_NO_THREAD_SAFETY_ANALYSIS {\n    rep_ = rep;\n  }\n\n  // Returns the stack trace for where the cord was first sampled. Cords are\n  // potentially sampled when they promote from an inlined cord to a tree or\n  // ring representation, which is not necessarily the location where the cord\n  // was first created. Some cords are created as inlined cords, and only as\n  // data is added do they become a non-inlined cord. However, typically the\n  // location represents reasonably well where the cord is 'created'.\n  absl::Span<void* const> GetStack() const;\n\n  // Returns the stack trace for a sampled cord's 'parent stack trace'. This\n  // value may be set if the cord is sampled (promoted) after being created\n  // from, or being assigned the value of an existing (sampled) cord.\n  absl::Span<void* const> GetParentStack() const;\n\n  // Retrieves the CordzStatistics associated with this Cord. The statistics\n  // are only updated when a Cord goes through a mutation, such as an Append\n  // or RemovePrefix.\n  CordzStatistics GetCordzStatistics() const;\n\n private:\n  using SpinLock = absl::base_internal::SpinLock;\n  using SpinLockHolder = ::absl::base_internal::SpinLockHolder;\n\n  // Global cordz info list. CordzInfo stores a pointer to the global list\n  // instance to harden against ODR violations.\n  struct List {\n    constexpr explicit List(absl::ConstInitType)\n        : mutex(absl::kConstInit,\n                absl::base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL) {}\n\n    SpinLock mutex;\n    std::atomic<CordzInfo*> head ABSL_GUARDED_BY(mutex){nullptr};\n  };\n\n  static constexpr size_t kMaxStackDepth = 64;\n\n  explicit CordzInfo(CordRep* rep, const CordzInfo* src,\n                     MethodIdentifier method);\n  ~CordzInfo() override;\n\n  // Sets `rep_` without holding a lock.\n  void UnsafeSetCordRep(CordRep* rep) ABSL_NO_THREAD_SAFETY_ANALYSIS;\n\n  void Track();\n\n  // Returns the parent method from `src`, which is either `parent_method_` or\n  // `method_` depending on `parent_method_` being kUnknown.\n  // Returns kUnknown if `src` is null.\n  static MethodIdentifier GetParentMethod(const CordzInfo* src);\n\n  // Fills the provided stack from `src`, copying either `parent_stack_` or\n  // `stack_` depending on `parent_stack_` being empty, returning the size of\n  // the parent stack.\n  // Returns 0 if `src` is null.\n  static size_t FillParentStack(const CordzInfo* src, void** stack);\n\n  void ODRCheck() const {\n#ifndef NDEBUG\n    ABSL_RAW_CHECK(list_ == &global_list_, \"ODR violation in Cord\");\n#endif\n  }\n\n  // Non-inlined implementation of `MaybeTrackCord`, which is executed if\n  // either `src` is sampled or `cord` is sampled, and either untracks or\n  // tracks `cord` as documented per `MaybeTrackCord`.\n  static void MaybeTrackCordImpl(InlineData& cord, const InlineData& src,\n                                 MethodIdentifier method);\n\n  ABSL_CONST_INIT static List global_list_;\n  List* const list_ = &global_list_;\n\n  // ci_prev_ and ci_next_ require the global list mutex to be held.\n  // Unfortunately we can't use thread annotations such that the thread safety\n  // analysis understands that list_ and global_list_ are one and the same.\n  std::atomic<CordzInfo*> ci_prev_{nullptr};\n  std::atomic<CordzInfo*> ci_next_{nullptr};\n\n  mutable absl::Mutex mutex_;\n  CordRep* rep_ ABSL_GUARDED_BY(mutex_);\n\n  void* stack_[kMaxStackDepth];\n  void* parent_stack_[kMaxStackDepth];\n  const size_t stack_depth_;\n  const size_t parent_stack_depth_;\n  const MethodIdentifier method_;\n  const MethodIdentifier parent_method_;\n  CordzUpdateTracker update_tracker_;\n  const absl::Time create_time_;\n};\n\ninline ABSL_ATTRIBUTE_ALWAYS_INLINE void CordzInfo::MaybeTrackCord(\n    InlineData& cord, MethodIdentifier method) {\n  if (ABSL_PREDICT_FALSE(cordz_should_profile())) {\n    TrackCord(cord, method);\n  }\n}\n\ninline ABSL_ATTRIBUTE_ALWAYS_INLINE void CordzInfo::MaybeTrackCord(\n    InlineData& cord, const InlineData& src, MethodIdentifier method) {\n  if (ABSL_PREDICT_FALSE(InlineData::is_either_profiled(cord, src))) {\n    MaybeTrackCordImpl(cord, src, method);\n  }\n}\n\ninline ABSL_ATTRIBUTE_ALWAYS_INLINE void CordzInfo::MaybeUntrackCord(\n    CordzInfo* info) {\n  if (ABSL_PREDICT_FALSE(info)) {\n    info->Untrack();\n  }\n}\n\ninline void CordzInfo::AssertHeld() ABSL_ASSERT_EXCLUSIVE_LOCK(mutex_) {\n#ifndef NDEBUG\n  mutex_.AssertHeld();\n#endif\n}\n\ninline void CordzInfo::SetCordRep(CordRep* rep) {\n  AssertHeld();\n  rep_ = rep;\n}\n\ninline void CordzInfo::UnsafeSetCordRep(CordRep* rep) { rep_ = rep; }\n\ninline CordRep* CordzInfo::RefCordRep() const ABSL_LOCKS_EXCLUDED(mutex_) {\n  MutexLock lock(&mutex_);\n  return rep_ ? CordRep::Ref(rep_) : nullptr;\n}\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-06183",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_info.h",
  "source_line": 34,
  "validation_status": "validated"
}