{
  "code": "{\n public:\n  // Forwards arguments to the T's constructor: calls T(args...).\n  template <typename... Ts,\n            // Disable this overload when it might collide with copy/move.\n            typename std::enable_if<!std::is_same<void(std::decay_t<Ts>&...),\n                                                  void(NoDestructor&)>::value,\n                                    int>::type = 0>\n  explicit constexpr NoDestructor(Ts&&... args)\n      : impl_(std::forward<Ts>(args)...) {}\n\n  // Forwards copy and move construction for T. Enables usage like this:\n  //   static NoDestructor<std::array<string, 3>> x{{{\"1\", \"2\", \"3\"}}};\n  //   static NoDestructor<std::vector<int>> x{{1, 2, 3}};\n  explicit constexpr NoDestructor(const T& x) : impl_(x) {}\n  explicit constexpr NoDestructor(T&& x)\n      : impl_(std::move(x)) {}\n\n  // No copying.\n  NoDestructor(const NoDestructor&) = delete;\n  NoDestructor& operator=(const NoDestructor&) = delete;\n\n  // Pretend to be a smart pointer to T with deep constness.\n  // Never returns a null pointer.\n  T& operator*() { return *get(); }\n  T* operator->() { return get(); }\n  T* get() { return impl_.get(); }\n  const T& operator*() const { return *get(); }\n  const T* operator->() const { return get(); }\n  const T* get() const { return impl_.get(); }\n\n private:\n  class DirectImpl {\n   public:\n    template <typename... Args>\n    explicit constexpr DirectImpl(Args&&... args)\n        : value_(std::forward<Args>(args)...) {}\n    const T* get() const { return &value_; }\n    T* get() { return &value_; }\n\n   private:\n    T value_;\n  };\n\n  class PlacementImpl {\n   public:\n    template <typename... Args>\n    explicit PlacementImpl(Args&&... args) {\n      new (&space_) T(std::forward<Args>(args)...);\n    }\n    const T* get() const {\n      return Launder(reinterpret_cast<const T*>(&space_));\n    }\n    T* get() { return Launder(reinterpret_cast<T*>(&space_)); }\n\n   private:\n    template <typename P>\n    static P* Launder(P* p) {\n#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606L\n      return std::launder(p);\n#elif ABSL_HAVE_BUILTIN(__builtin_launder)\n      return __builtin_launder(p);\n#else\n      // When `std::launder` or equivalent are not available, we rely on\n      // undefined behavior, which works as intended on Abseil's officially\n      // supported platforms as of Q3 2023.\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#endif\n      return p;\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n#endif\n    }\n\n    alignas(T) unsigned char space_[sizeof(T)];\n  };\n\n  // If the object is trivially destructible we use a member directly to avoid\n  // potential once-init runtime initialization. It somewhat defeats the\n  // purpose of NoDestructor in this case, but this makes the class more\n  // friendly to generic code.\n  std::conditional_t<std::is_trivially_destructible<T>::value, DirectImpl,\n                     PlacementImpl>\n      impl_;\n}",
  "id": "BLOCK-CPP-03437",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/no_destructor.h",
  "source_line": 117,
  "validation_status": "validated"
}