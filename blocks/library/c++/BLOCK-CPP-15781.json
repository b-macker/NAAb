{
  "code": "{\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for SARIF and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n\n    /// Used for HTML, shows both \"arrows\" and control notes.\n    Everything\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() >= Extensive; }\n  bool shouldAddControlNotes() const {\n    return getGenerationScheme() == Minimal ||\n           getGenerationScheme() == Everything;\n  }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n}",
  "id": "BLOCK-CPP-15781",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/PathDiagnostic.h",
  "source_line": 92,
  "validation_status": "validated"
}