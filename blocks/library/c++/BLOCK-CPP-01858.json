{
  "code": "#include \"absl/strings/charconv.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <system_error>  // NOLINT(build/c++11)\n#include \"absl/base/casts.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/strings/internal/charconv_bigint.h\"\n#include \"absl/strings/internal/charconv_parse.h\"\n\nusing namespace absl;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\nusing namespace it;\nusing namespace std;\nusing namespace std;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01858_execute() {\n    {\n  from_chars_result result;\n  result.ptr = first;  // overwritten on successful parse\n  result.ec = std::errc();\n\n  bool negative = false;\n  if (first != last && *first == '-') {\n    ++first;\n    negative = true;\n  }\n  // If the `hex` flag is *not* set, then we will accept a 0x prefix and try\n  // to parse a hexadecimal float.\n  if ((fmt_flags & chars_format::hex) == chars_format{} && last - first >= 2 &&\n      *first == '0' && (first[1] == 'x' || first[1] == 'X')) {\n    const char* hex_first = first + 2;\n    strings_internal::ParsedFloat hex_parse =\n        strings_internal::ParseFloat<16>(hex_first, last, fmt_flags);\n    if (hex_parse.end == nullptr ||\n        hex_parse.type != strings_internal::FloatType::kNumber) {\n      // Either we failed to parse a hex float after the \"0x\", or we read\n      // \"0xinf\" or \"0xnan\" which we don't want to match.\n      //\n      // However, a string that begins with \"0x\" also begins with \"0\", which\n      // is normally a valid match for the number zero.  So we want these\n      // strings to match zero unless fmt_flags is `scientific`.  (This flag\n      // means an exponent is required, which the string \"0\" does not have.)\n      if (fmt_flags == chars_format::scientific) {\n        result.ec = std::errc::invalid_argument;\n      } else {\n        result.ptr = first + 1;\n        value = negative ? -0.0 : 0.0;\n      }\n      return result;\n    }\n    // We matched a value.\n    result.ptr = hex_parse.end;\n    if (HandleEdgeCase(hex_parse, negative, &value)) {\n      return result;\n    }\n    CalculatedFloat calculated =\n        CalculateFromParsedHexadecimal<FloatType>(hex_parse);\n    EncodeResult(calculated, negative, &result, &value);\n    return result;\n  }\n  // Otherwise, we choose the number base based on the flags.\n  if ((fmt_flags & chars_format::hex) == chars_format::hex) {\n    strings_internal::ParsedFloat hex_parse =\n        strings_internal::ParseFloat<16>(first, last, fmt_flags);\n    if (hex_parse.end == nullptr) {\n      result.ec = std::errc::invalid_argument;\n      return result;\n    }\n    result.ptr = hex_parse.end;\n    if (HandleEdgeCase(hex_parse, negative, &value)) {\n      return result;\n    }\n    CalculatedFloat calculated =\n        CalculateFromParsedHexadecimal<FloatType>(hex_parse);\n    EncodeResult(calculated, negative, &result, &value);\n    return result;\n  } else {\n    strings_internal::ParsedFloat decimal_parse =\n        strings_internal::ParseFloat<10>(first, last, fmt_flags);\n    if (decimal_parse.end == nullptr) {\n      result.ec = std::errc::invalid_argument;\n      return result;\n    }\n    result.ptr = decimal_parse.end;\n    if (HandleEdgeCase(decimal_parse, negative, &value)) {\n      return result;\n    }\n    // A nullptr subrange_begin means that the decimal_parse.mantissa is exact\n    // (not truncated), a precondition of the Eisel-Lemire algorithm.\n    if ((decimal_parse.subrange_begin == nullptr) &&\n        EiselLemire<FloatType>(decimal_parse, negative, &value, &result.ec)) {\n      return result;\n    }\n    CalculatedFloat calculated =\n        CalculateFromParsedDecimal<FloatType>(decimal_parse);\n    EncodeResult(calculated, negative, &result, &value);\n    return result;\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01858",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/charconv.cc",
  "source_line": 863,
  "validation_status": "validated"
}