{
  "code": "{\n  bigint numerator;    // 2 * R in (FPP)^2.\n  bigint denominator;  // 2 * S in (FPP)^2.\n  // lower and upper are differences between value and corresponding boundaries.\n  bigint lower;             // (M^- in (FPP)^2).\n  bigint upper_store;       // upper's value if different from lower.\n  bigint* upper = nullptr;  // (M^+ in (FPP)^2).\n  // Shift numerator and denominator by an extra bit or two (if lower boundary\n  // is closer) to make lower and upper integers. This eliminates multiplication\n  // by 2 during later computations.\n  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;\n  int shift = is_predecessor_closer ? 2 : 1;\n  if (value.e >= 0) {\n    numerator = value.f;\n    numerator <<= value.e + shift;\n    lower = 1;\n    lower <<= value.e;\n    if (is_predecessor_closer) {\n      upper_store = 1;\n      upper_store <<= value.e + 1;\n      upper = &upper_store;\n    }\n    denominator.assign_pow10(exp10);\n    denominator <<= shift;\n  } else if (exp10 < 0) {\n    numerator.assign_pow10(-exp10);\n    lower.assign(numerator);\n    if (is_predecessor_closer) {\n      upper_store.assign(numerator);\n      upper_store <<= 1;\n      upper = &upper_store;\n    }\n    numerator *= value.f;\n    numerator <<= shift;\n    denominator = 1;\n    denominator <<= shift - value.e;\n  } else {\n    numerator = value.f;\n    numerator <<= shift;\n    denominator.assign_pow10(exp10);\n    denominator <<= shift - value.e;\n    lower = 1;\n    if (is_predecessor_closer) {\n      upper_store = 1ULL << 1;\n      upper = &upper_store;\n    }\n  }\n  int even = static_cast<int>((value.f & 1) == 0);\n  if (!upper) upper = &lower;\n  if ((flags & dragon::fixup) != 0) {\n    if (add_compare(numerator, *upper, denominator) + even <= 0) {\n      --exp10;\n      numerator *= 10;\n      if (num_digits < 0) {\n        lower *= 10;\n        if (upper != &lower) *upper *= 10;\n      }\n    }\n    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);\n  }\n  // Invariant: value == (numerator / denominator) * pow(10, exp10).\n  if (num_digits < 0) {\n    // Generate the shortest representation.\n    num_digits = 0;\n    char* data = buf.data();\n    for (;;) {\n      int digit = numerator.divmod_assign(denominator);\n      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.\n      // numerator + upper >[=] pow10:\n      bool high = add_compare(numerator, *upper, denominator) + even > 0;\n      data[num_digits++] = static_cast<char>('0' + digit);\n      if (low || high) {\n        if (!low) {\n          ++data[num_digits - 1];\n        } else if (high) {\n          int result = add_compare(numerator, numerator, denominator);\n          // Round half to even.\n          if (result > 0 || (result == 0 && (digit % 2) != 0))\n            ++data[num_digits - 1];\n        }\n        buf.try_resize(to_unsigned(num_digits));\n        exp10 -= num_digits - 1;\n        return;\n      }\n      numerator *= 10;\n      lower *= 10;\n      if (upper != &lower) *upper *= 10;\n    }\n  }\n  // Generate the given number of digits.\n  exp10 -= num_digits - 1;\n  if (num_digits == 0) {\n    denominator *= 10;\n    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';\n    buf.push_back(digit);\n    return;\n  }\n  buf.try_resize(to_unsigned(num_digits));\n  for (int i = 0; i < num_digits - 1; ++i) {\n    int digit = numerator.divmod_assign(denominator);\n    buf[i] = static_cast<char>('0' + digit);\n    numerator *= 10;\n  }\n  int digit = numerator.divmod_assign(denominator);\n  auto result = add_compare(numerator, numerator, denominator);\n  if (result > 0 || (result == 0 && (digit % 2) != 0)) {\n    if (digit == 9) {\n      const auto overflow = '0' + 10;\n      buf[num_digits - 1] = overflow;\n      // Propagate the carry.\n      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {\n        buf[i] = '0';\n        ++buf[i - 1];\n      }\n      if (buf[0] == overflow) {\n        buf[0] = '1';\n        ++exp10;\n      }\n      return;\n    }\n    ++digit;\n  }\n  buf[num_digits - 1] = static_cast<char>('0' + digit);\n}",
  "id": "BLOCK-CPP-01375",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/fmt/bundled/format.h",
  "source_line": 2970,
  "validation_status": "validated"
}