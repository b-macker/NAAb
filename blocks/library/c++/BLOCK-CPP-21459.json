{
  "code": "#include \"clang/AST/Decl.h\"\n#include \"clang/Analysis/Analyses/PostOrderCFGView.h\"\n#include \"clang/Analysis/Analyses/ThreadSafetyTIL.h\"\n#include \"clang/Analysis/Analyses/ThreadSafetyTraverse.h\"\n#include \"clang/Analysis/Analyses/ThreadSafetyUtil.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace threadSafety;\nusing namespace sx;\nusing namespace sx;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21459_execute() {\n    {\nprivate:\n  /// The capability expression and whether it's negated.\n  llvm::PointerIntPair<const til::SExpr *, 1, bool> CapExpr;\n\n  /// The kind of capability as specified by @ref CapabilityAttr::getName.\n  StringRef CapKind;\n\npublic:\n  CapabilityExpr() : CapExpr(nullptr, false) {}\n  CapabilityExpr(const til::SExpr *E, StringRef Kind, bool Neg)\n      : CapExpr(E, Neg), CapKind(Kind) {}\n\n  // Don't allow implicitly-constructed StringRefs since we'll capture them.\n  template <typename T> CapabilityExpr(const til::SExpr *, T, bool) = delete;\n\n  const til::SExpr *sexpr() const { return CapExpr.getPointer(); }\n  StringRef getKind() const { return CapKind; }\n  bool negative() const { return CapExpr.getInt(); }\n\n  CapabilityExpr operator!() const {\n    return CapabilityExpr(CapExpr.getPointer(), CapKind, !CapExpr.getInt());\n  }\n\n  bool equals(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::equals(sexpr(), other.sexpr());\n  }\n\n  bool matches(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::matches(sexpr(), other.sexpr());\n  }\n\n  bool matchesUniv(const CapabilityExpr &CapE) const {\n    return isUniversal() || matches(CapE);\n  }\n\n  bool partiallyMatches(const CapabilityExpr &other) const {\n    return (negative() == other.negative()) &&\n           sx::partiallyMatches(sexpr(), other.sexpr());\n  }\n\n  const ValueDecl* valueDecl() const {\n    if (negative() || sexpr() == nullptr)\n      return nullptr;\n    if (const auto *P = dyn_cast<til::Project>(sexpr()))\n      return P->clangDecl();\n    if (const auto *P = dyn_cast<til::LiteralPtr>(sexpr()))\n      return P->clangDecl();\n    return nullptr;\n  }\n\n  std::string toString() const {\n    if (negative())\n      return \"!\" + sx::toString(sexpr());\n    return sx::toString(sexpr());\n  }\n\n  bool shouldIgnore() const { return sexpr() == nullptr; }\n\n  bool isInvalid() const { return sexpr() && isa<til::Undefined>(sexpr()); }\n\n  bool isUniversal() const { return sexpr() && isa<til::Wildcard>(sexpr()); }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21459",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h",
  "source_line": 272,
  "validation_status": "validated"
}