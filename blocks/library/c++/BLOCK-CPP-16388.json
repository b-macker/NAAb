{
  "code": "#include \"clang/Basic/CustomizableOptional.h\"\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n#include <optional>\n#include <utility>\n\nusing namespace llvm;\nusing namespace vfs;\nusing namespace vfs;\nusing namespace llvm;\nusing namespace clang;\nusing namespace optional_detail;\nusing namespace optional_detail;\nusing namespace optional_detail;\nusing namespace optional_detail;\nusing namespace clang;\nusing namespace llvm;\nusing namespace llvm;\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16388_execute() {\n    {\n\n/// Wrapper around OptionalFileEntryRef that degrades to 'const FileEntry*',\n/// facilitating incremental patches to propagate FileEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an OptionalFileEntryRef to degrade to a 'const FileEntry*'. The purpose\n/// is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// OptionalFileEntryRef MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getFileEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n/// FileEntry::getName have been deleted, delete this class and replace\n/// instances with OptionalFileEntryRef.\nclass OptionalFileEntryRefDegradesToFileEntryPtr : public OptionalFileEntryRef {\npublic:\n  OptionalFileEntryRefDegradesToFileEntryPtr() = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr(std::nullopt_t) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(FileEntryRef Ref)\n      : OptionalFileEntryRef(Ref) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(OptionalFileEntryRef MaybeRef)\n      : OptionalFileEntryRef(MaybeRef) {}\n\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(std::nullopt_t) {\n    OptionalFileEntryRef::operator=(std::nullopt);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(FileEntryRef Ref) {\n    OptionalFileEntryRef::operator=(Ref);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRef MaybeRef) {\n    OptionalFileEntryRef::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const FileEntry *' to allow  FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this class and replace\n  /// instances with OptionalFileEntryRef\n  operator const FileEntry *() const {\n    return has_value() ? &(*this)->getFileEntry() : nullptr;\n  }\n};\n\nstatic_assert(\n    std::is_trivially_copyable<\n        OptionalFileEntryRefDegradesToFileEntryPtr>::value,\n    \"OptionalFileEntryRefDegradesToFileEntryPtr should be trivially copyable\");\n\ninline bool operator==(const FileEntry *LHS, const OptionalFileEntryRef &RHS) {\n  return LHS == (RHS ? &RHS->getFileEntry() : nullptr);\n}\ninline bool operator==(const OptionalFileEntryRef &LHS, const FileEntry *RHS) {\n  return (LHS ? &LHS->getFileEntry() : nullptr) == RHS;\n}\ninline bool operator!=(const FileEntry *LHS, const OptionalFileEntryRef &RHS) {\n  return !(LHS == RHS);\n}\ninline bool operator!=(const OptionalFileEntryRef &LHS, const FileEntry *RHS) {\n  return !(LHS == RHS);\n}\n\n/// Cached information about one file (either on disk\n/// or in the virtual file system).\n///\n/// If the 'File' member is valid, then this FileEntry has an open file\n/// descriptor for the file.\nclass FileEntry {\n  friend class FileManager;\n  friend class FileEntryTestHelper;\n  FileEntry();\n  FileEntry(const FileEntry &) = delete;\n  FileEntry &operator=(const FileEntry &) = delete;\n\n  std::string RealPathName;   // Real path to the file; could be empty.\n  off_t Size = 0;             // File size in bytes.\n  time_t ModTime = 0;         // Modification time of file.\n  const DirectoryEntry *Dir = nullptr; // Directory file lives in.\n  llvm::sys::fs::UniqueID UniqueID;\n  unsigned UID = 0; // A unique (small) ID for the file.\n  bool IsNamedPipe = false;\n\n  /// The open file, if it is owned by the \\p FileEntry.\n  mutable std::unique_ptr<llvm::vfs::File> File;\n\n  /// The file content, if it is owned by the \\p FileEntry.\n  std::unique_ptr<llvm::MemoryBuffer> Content;\n\n  // First access name for this FileEntry.\n  //\n  // This is Optional only to allow delayed construction (FileEntryRef has no\n  // default constructor). It should always have a value in practice.\n  //\n  // TODO: remove this once everyone that needs a name uses FileEntryRef.\n  OptionalFileEntryRef LastRef;\n\npublic:\n  ~FileEntry();\n  StringRef getName() const { return LastRef->getName(); }\n  FileEntryRef getLastRef() const { return *LastRef; }\n\n  StringRef tryGetRealPathName() const { return RealPathName; }\n  off_t getSize() const { return Size; }\n  unsigned getUID() const { return UID; }\n  const llvm::sys::fs::UniqueID &getUniqueID() const { return UniqueID; }\n  time_t getModificationTime() const { return ModTime; }\n\n  /// Return the directory the file lives in.\n  const DirectoryEntry *getDir() const { return Dir; }\n\n  /// Check whether the file is a named pipe (and thus can't be opened by\n  /// the native FileManager methods).\n  bool isNamedPipe() const { return IsNamedPipe; }\n\n  void closeFile() const;\n};\n\noff_t FileEntryRef::getSize() const { return getFileEntry().getSize(); }\n\nunsigned FileEntryRef::getUID() const { return getFileEntry().getUID(); }\n\nconst llvm::sys::fs::UniqueID &FileEntryRef::getUniqueID() const {\n  return getFileEntry().getUniqueID();\n}\n\ntime_t FileEntryRef::getModificationTime() const {\n  return getFileEntry().getModificationTime();\n}\n\nbool FileEntryRef::isNamedPipe() const { return getFileEntry().isNamedPipe(); }\n\nvoid FileEntryRef::closeFile() const { getFileEntry().closeFile(); }\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16388",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/FileEntry.h",
  "source_line": 282,
  "validation_status": "validated"
}