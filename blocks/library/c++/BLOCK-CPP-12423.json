{
  "code": "{\n\nclass ASTContext;\nclass Decl;\n\n// Some notes on redeclarables:\n//\n//  - Every redeclarable is on a circular linked list.\n//\n//  - Every decl has a pointer to the first element of the chain _and_ a\n//    DeclLink that may point to one of 3 possible states:\n//      - the \"previous\" (temporal) element in the chain\n//      - the \"latest\" (temporal) element in the chain\n//      - the \"uninitialized-latest\" value (when newly-constructed)\n//\n//  - The first element is also often called the canonical element. Every\n//    element has a pointer to it so that \"getCanonical\" can be fast.\n//\n//  - Most links in the chain point to previous, except the link out of\n//    the first; it points to latest.\n//\n//  - Elements are called \"first\", \"previous\", \"latest\" or\n//    \"most-recent\" when referring to temporal order: order of addition\n//    to the chain.\n//\n//  - It's easiest to just ignore the implementation of DeclLink when making\n//    sense of the redeclaration chain.\n//\n//  - There's also a \"definition\" link for several types of\n//    redeclarable, where only one definition should exist at any given\n//    time (and the defn pointer is stored in the decl's \"data\" which\n//    is copied to every element on the chain when it's changed).\n//\n//    Here is some ASCII art:\n//\n//      \"first\"                                     \"latest\"\n//      \"canonical\"                                 \"most recent\"\n//      +------------+         first                +--------------+\n//      |            | <--------------------------- |              |\n//      |            |                              |              |\n//      |            |                              |              |\n//      |            |       +--------------+       |              |\n//      |            | first |              |       |              |\n//      |            | <---- |              |       |              |\n//      |            |       |              |       |              |\n//      | @class A   |  link | @interface A |  link | @class A     |\n//      | seen first | <---- | seen second  | <---- | seen third   |\n//      |            |       |              |       |              |\n//      +------------+       +--------------+       +--------------+\n//      | data       | defn  | data         |  defn | data         |\n//      |            | ----> |              | <---- |              |\n//      +------------+       +--------------+       +--------------+\n//        |                     |     ^                  ^\n//        |                     |defn |                  |\n//        | link                +-----+                  |\n//        +-->-------------------------------------------+\n\n/// Provides common interface for the Decls that can be redeclared.\ntemplate<typename decl_type>\nclass Redeclarable {\nprotected:\n  class DeclLink {\n    /// A pointer to a known latest declaration, either statically known or\n    /// generationally updated as decls are added by an external source.\n    using KnownLatest =\n        LazyGenerationalUpdatePtr<const Decl *, Decl *,\n                                  &ExternalASTSource::CompleteRedeclChain>;\n\n    /// We store a pointer to the ASTContext in the UninitializedLatest\n    /// pointer, but to avoid circular type dependencies when we steal the low\n    /// bits of this pointer, we use a raw void* here.\n    using UninitializedLatest = const void *;\n\n    using Previous = Decl *;\n\n    /// A pointer to either an uninitialized latest declaration (where either\n    /// we've not yet set the previous decl or there isn't one), or to a known\n    /// previous declaration.\n    using NotKnownLatest = llvm::PointerUnion<Previous, UninitializedLatest>;\n\n    mutable llvm::PointerUnion<NotKnownLatest, KnownLatest> Link;\n\n  public:\n    enum PreviousTag { PreviousLink };\n    enum LatestTag { LatestLink };\n\n    DeclLink(LatestTag, const ASTContext &Ctx)\n        : Link(NotKnownLatest(reinterpret_cast<UninitializedLatest>(&Ctx))) {}\n    DeclLink(PreviousTag, decl_type *D) : Link(NotKnownLatest(Previous(D))) {}\n\n    bool isFirst() const {\n      return Link.is<KnownLatest>() ||\n             // FIXME: 'template' is required on the next line due to an\n             // apparent clang bug.\n             Link.get<NotKnownLatest>().template is<UninitializedLatest>();\n    }\n\n    decl_type *getPrevious(const decl_type *D) const {\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        if (NKL.is<Previous>())\n          return static_cast<decl_type*>(NKL.get<Previous>());\n\n        // Allocate the generational 'most recent' cache now, if needed.\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           const_cast<decl_type *>(D));\n      }\n\n      return static_cast<decl_type*>(Link.get<KnownLatest>().get(D));\n    }\n\n    void setPrevious(decl_type *D) {\n      assert(!isFirst() && \"decl became non-canonical unexpectedly\");\n      Link = Previous(D);\n    }\n\n    void setLatest(decl_type *D) {\n      assert(isFirst() && \"decl became canonical unexpectedly\");\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           D);\n      } else {\n        auto Latest = Link.get<KnownLatest>();\n        Latest.set(D);\n        Link = Latest;\n      }\n    }\n\n    void markIncomplete() { Link.get<KnownLatest>().markIncomplete(); }\n\n    Decl *getLatestNotUpdated() const {\n      assert(isFirst() && \"expected a canonical decl\");\n      if (Link.is<NotKnownLatest>())\n        return nullptr;\n      return Link.get<KnownLatest>().getNotUpdated();\n    }\n  };\n\n  static DeclLink PreviousDeclLink(decl_type *D) {\n    return DeclLink(DeclLink::PreviousLink, D);\n  }\n\n  static DeclLink LatestDeclLink(const ASTContext &Ctx) {\n    return DeclLink(DeclLink::LatestLink, Ctx);\n  }\n\n  /// Points to the next redeclaration in the chain.\n  ///\n  /// If isFirst() is false, this is a link to the previous declaration\n  /// of this same Decl. If isFirst() is true, this is the first\n  /// declaration and Link points to the latest declaration. For example:\n  ///\n  ///  #1 int f(int x, int y = 1); // <pointer to #3, true>\n  ///  #2 int f(int x = 0, int y); // <pointer to #1, false>\n  ///  #3 int f(int x, int y) { return x + y; } // <pointer to #2, false>\n  ///\n  /// If there is only one declaration, it is <pointer to self, true>\n  DeclLink RedeclLink;\n\n  decl_type *First;\n\n  decl_type *getNextRedeclaration() const {\n    return RedeclLink.getPrevious(static_cast<const decl_type *>(this));\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class IncrementalParser;\n\n  Redeclarable(const ASTContext &Ctx)\n      : RedeclLink(LatestDeclLink(Ctx)),\n        First(static_cast<decl_type *>(this)) {}\n\n  /// Return the previous declaration of this declaration or NULL if this\n  /// is the first declaration.\n  decl_type *getPreviousDecl() {\n    if (!RedeclLink.isFirst())\n      return getNextRedeclaration();\n    return nullptr;\n  }\n  const decl_type *getPreviousDecl() const {\n    return const_cast<decl_type *>(\n                 static_cast<const decl_type*>(this))->getPreviousDecl();\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() { return First; }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const { return First; }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const { return RedeclLink.isFirst(); }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  decl_type *getMostRecentDecl() {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  const decl_type *getMostRecentDecl() const {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Set the previous declaration. If PrevDecl is NULL, set this as the\n  /// first and only declaration.\n  void setPreviousDecl(decl_type *PrevDecl);\n\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    decl_type *Current = nullptr;\n    decl_type *Starter = nullptr;\n    bool PassedFirst = false;\n\n  public:\n    using value_type = decl_type *;\n    using reference = decl_type *;\n    using pointer = decl_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(decl_type *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Make sure we don't infinitely loop on an invalid redecl chain. This\n      // should never happen.\n      if (Current->isFirstDecl()) {\n        if (PassedFirst) {\n          assert(0 && \"Passed first decl twice, invalid redecl chain!\");\n          Current = nullptr;\n          return *this;\n        }\n        PassedFirst = true;\n      }\n\n      // Get either previous decl or latest decl.\n      decl_type *Next = Current->getNextRedeclaration();\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecl_iterator(const_cast<decl_type *>(\n                            static_cast<const decl_type *>(this))),\n                        redecl_iterator());\n  }\n\n  redecl_iterator redecls_begin() const { return redecls().begin(); }\n  redecl_iterator redecls_end() const { return redecls().end(); }\n};\n\n/// Get the primary declaration for a declaration from an AST file. That\n/// will be the first-loaded declaration.\nDecl *getPrimaryMergedDecl(Decl *D);\n\n/// Provides common interface for the Decls that cannot be redeclared,\n/// but can be merged if the same declaration is brought in from multiple\n/// modules.\ntemplate<typename decl_type>\nclass Mergeable {\npublic:\n  Mergeable() = default;\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() {\n    auto *D = static_cast<decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const {\n    const auto *D = static_cast<const decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Returns true if this is the first declaration.\n  bool isFirstDecl() const { return getFirstDecl() == this; }\n};\n\n/// A wrapper class around a pointer that always points to its canonical\n/// declaration.\n///\n/// CanonicalDeclPtr<decl_type> behaves just like decl_type*, except we call\n/// decl_type::getCanonicalDecl() on construction.\n///\n/// This is useful for hashtables that you want to be keyed on a declaration's\n/// canonical decl -- if you use CanonicalDeclPtr as the key, you don't need to\n/// remember to call getCanonicalDecl() everywhere.\ntemplate <typename decl_type> class CanonicalDeclPtr {\npublic:\n  CanonicalDeclPtr() = default;\n  CanonicalDeclPtr(decl_type *Ptr)\n      : Ptr(Ptr ? Ptr->getCanonicalDecl() : nullptr) {}\n  CanonicalDeclPtr(const CanonicalDeclPtr &) = default;\n  CanonicalDeclPtr &operator=(const CanonicalDeclPtr &) = default;\n\n  operator decl_type *() { return Ptr; }\n  operator const decl_type *() const { return Ptr; }\n\n  decl_type *operator->() { return Ptr; }\n  const decl_type *operator->() const { return Ptr; }\n\n  decl_type &operator*() { return *Ptr; }\n  const decl_type &operator*() const { return *Ptr; }\n\n  friend bool operator==(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n  friend bool operator!=(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\nprivate:\n  friend struct llvm::DenseMapInfo<CanonicalDeclPtr<decl_type>>;\n  friend struct llvm::PointerLikeTypeTraits<CanonicalDeclPtr<decl_type>>;\n\n  decl_type *Ptr = nullptr;\n};\n\n}",
  "id": "BLOCK-CPP-12423",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Redeclarable.h",
  "source_line": 25,
  "validation_status": "validated"
}