{
  "code": "{\n    friend class raw_hash_set;\n\n   public:\n    using iterator_category = std::forward_iterator_tag;\n    using value_type = typename raw_hash_set::value_type;\n    using reference =\n        absl::conditional_t<PolicyTraits::constant_iterators::value,\n                            const value_type&, value_type&>;\n    using pointer = absl::remove_reference_t<reference>*;\n    using difference_type = typename raw_hash_set::difference_type;\n\n    iterator() {}\n\n    // PRECONDITION: not an end() iterator.\n    reference operator*() const {\n      AssertIsFull(ctrl_, generation(), generation_ptr(), \"operator*()\");\n      return unchecked_deref();\n    }\n\n    // PRECONDITION: not an end() iterator.\n    pointer operator->() const {\n      AssertIsFull(ctrl_, generation(), generation_ptr(), \"operator->\");\n      return &operator*();\n    }\n\n    // PRECONDITION: not an end() iterator.\n    iterator& operator++() {\n      AssertIsFull(ctrl_, generation(), generation_ptr(), \"operator++\");\n      ++ctrl_;\n      ++slot_;\n      skip_empty_or_deleted();\n      return *this;\n    }\n    // PRECONDITION: not an end() iterator.\n    iterator operator++(int) {\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    friend bool operator==(const iterator& a, const iterator& b) {\n      AssertIsValidForComparison(a.ctrl_, a.generation(), a.generation_ptr());\n      AssertIsValidForComparison(b.ctrl_, b.generation(), b.generation_ptr());\n      AssertSameContainer(a.ctrl_, b.ctrl_, a.slot_, b.slot_,\n                          a.generation_ptr(), b.generation_ptr());\n      return a.ctrl_ == b.ctrl_;\n    }\n    friend bool operator!=(const iterator& a, const iterator& b) {\n      return !(a == b);\n    }\n\n   private:\n    iterator(ctrl_t* ctrl, slot_type* slot,\n             const GenerationType* generation_ptr)\n        : HashSetIteratorGenerationInfo(generation_ptr),\n          ctrl_(ctrl),\n          slot_(slot) {\n      // This assumption helps the compiler know that any non-end iterator is\n      // not equal to any end iterator.\n      ABSL_ASSUME(ctrl != nullptr);\n    }\n    // For end() iterators.\n    explicit iterator(const GenerationType* generation_ptr)\n        : HashSetIteratorGenerationInfo(generation_ptr), ctrl_(nullptr) {}\n\n    // Fixes up `ctrl_` to point to a full by advancing it and `slot_` until\n    // they reach one.\n    //\n    // If a sentinel is reached, we null `ctrl_` out instead.\n    void skip_empty_or_deleted() {\n      while (IsEmptyOrDeleted(*ctrl_)) {\n        uint32_t shift =\n            GroupEmptyOrDeleted{ctrl_}.CountLeadingEmptyOrDeleted();\n        ctrl_ += shift;\n        slot_ += shift;\n      }\n      if (ABSL_PREDICT_FALSE(*ctrl_ == ctrl_t::kSentinel)) ctrl_ = nullptr;\n    }\n\n    ctrl_t* control() const { return ctrl_; }\n    slot_type* slot() const { return slot_; }\n\n    // We use EmptyGroup() for default-constructed iterators so that they can\n    // be distinguished from end iterators, which have nullptr ctrl_.\n    ctrl_t* ctrl_ = EmptyGroup();\n    // To avoid uninitialized member warnings, put slot_ in an anonymous union.\n    // The member is not initialized on singleton and end iterators.\n    union {\n      slot_type* slot_;\n    };\n\n    // An equality check which skips ABSL Hardening iterator invalidation\n    // checks.\n    // Should be used when the lifetimes of the iterators are well-enough\n    // understood to prove that they cannot be invalid.\n    bool unchecked_equals(const iterator& b) { return ctrl_ == b.control(); }\n\n    // Dereferences the iterator without ABSL Hardening iterator invalidation\n    // checks.\n    reference unchecked_deref() const { return PolicyTraits::element(slot_); }\n  }",
  "id": "BLOCK-CPP-05343",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_set.h",
  "source_line": 1929,
  "validation_status": "validated"
}