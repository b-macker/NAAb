{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace base_internal {\n\n#if ABSL_THREAD_IDENTITY_MODE != ABSL_THREAD_IDENTITY_MODE_USE_CPP11\nnamespace {\n// Used to co-ordinate one-time creation of our pthread_key\nabsl::once_flag init_thread_identity_key_once;\npthread_key_t thread_identity_pthread_key;\nstd::atomic<bool> pthread_key_initialized(false);\n\nvoid AllocateThreadIdentityKey(ThreadIdentityReclaimerFunction reclaimer) {\n  pthread_key_create(&thread_identity_pthread_key, reclaimer);\n  pthread_key_initialized.store(true, std::memory_order_release);\n}\n}  // namespace\n#endif\n\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \\\n    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n// The actual TLS storage for a thread's currently associated ThreadIdentity.\n// This is referenced by inline accessors in the header.\n// \"protected\" visibility ensures that if multiple instances of Abseil code\n// exist within a process (via dlopen() or similar), references to\n// thread_identity_ptr from each instance of the code will refer to\n// *different* instances of this ptr.\n// Apple platforms have the visibility attribute, but issue a compile warning\n// that protected visibility is unsupported.\nABSL_CONST_INIT  // Must come before __attribute__((visibility(\"protected\")))\n#if ABSL_HAVE_ATTRIBUTE(visibility) && !defined(__APPLE__)\n    __attribute__((visibility(\"protected\")))\n#endif  // ABSL_HAVE_ATTRIBUTE(visibility) && !defined(__APPLE__)\n#if ABSL_PER_THREAD_TLS\n    // Prefer __thread to thread_local as benchmarks indicate it is a bit\n    // faster.\n    ABSL_PER_THREAD_TLS_KEYWORD ThreadIdentity* thread_identity_ptr = nullptr;\n#elif defined(ABSL_HAVE_THREAD_LOCAL)\n    thread_local ThreadIdentity* thread_identity_ptr = nullptr;\n#endif  // ABSL_PER_THREAD_TLS\n#endif  // TLS or CPP11\n\nvoid SetCurrentThreadIdentity(ThreadIdentity* identity,\n                              ThreadIdentityReclaimerFunction reclaimer) {\n  assert(CurrentThreadIdentityIfPresent() == nullptr);\n  // Associate our destructor.\n  // NOTE: This call to pthread_setspecific is currently the only immovable\n  // barrier to CurrentThreadIdentity() always being async signal safe.\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\n  // NOTE: Not async-safe.  But can be open-coded.\n  absl::call_once(init_thread_identity_key_once, AllocateThreadIdentityKey,\n                  reclaimer);\n\n#if defined(__wasi__) || defined(__EMSCRIPTEN__) || defined(__MINGW32__) || \\\n    defined(__hexagon__)\n  // Emscripten, WASI and MinGW pthread implementations does not support\n  // signals. See\n  // https://kripken.github.io/emscripten-site/docs/porting/pthreads.html for\n  // more information.\n  pthread_setspecific(thread_identity_pthread_key,\n                      reinterpret_cast<void*>(identity));\n#else\n  // We must mask signals around the call to setspecific as with current glibc,\n  // a concurrent getspecific (needed for GetCurrentThreadIdentityIfPresent())\n  // may zero our value.\n  //\n  // While not officially async-signal safe, getspecific within a signal handler\n  // is otherwise OK.\n  sigset_t all_signals;\n  sigset_t curr_signals;\n  sigfillset(&all_signals);\n  pthread_sigmask(SIG_SETMASK, &all_signals, &curr_signals);\n  pthread_setspecific(thread_identity_pthread_key,\n                      reinterpret_cast<void*>(identity));\n  pthread_sigmask(SIG_SETMASK, &curr_signals, nullptr);\n#endif  // !__EMSCRIPTEN__ && !__MINGW32__\n\n#elif ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS\n  // NOTE: Not async-safe.  But can be open-coded.\n  absl::call_once(init_thread_identity_key_once, AllocateThreadIdentityKey,\n                  reclaimer);\n  pthread_setspecific(thread_identity_pthread_key,\n                      reinterpret_cast<void*>(identity));\n  thread_identity_ptr = identity;\n#elif ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n  thread_local std::unique_ptr<ThreadIdentity, ThreadIdentityReclaimerFunction>\n      holder(identity, reclaimer);\n  thread_identity_ptr = identity;\n#else\n#error Unimplemented ABSL_THREAD_IDENTITY_MODE\n#endif\n}\n\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \\\n    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n\n// Please see the comment on `CurrentThreadIdentityIfPresent` in\n// thread_identity.h. When we cannot expose thread_local variables in\n// headers, we opt for the correct-but-slower option of not inlining this\n// function.\n#ifndef ABSL_INTERNAL_INLINE_CURRENT_THREAD_IDENTITY_IF_PRESENT\nThreadIdentity* CurrentThreadIdentityIfPresent() { return thread_identity_ptr; }\n#endif\n#endif\n\nvoid ClearCurrentThreadIdentity() {\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \\\n    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11\n  thread_identity_ptr = nullptr;\n#elif ABSL_THREAD_IDENTITY_MODE == \\\n    ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\n  // pthread_setspecific expected to clear value on destruction\n  assert(CurrentThreadIdentityIfPresent() == nullptr);\n#endif\n}\n\n#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC\nThreadIdentity* CurrentThreadIdentityIfPresent() {\n  bool initialized = pthread_key_initialized.load(std::memory_order_acquire);\n  if (!initialized) {\n    return nullptr;\n  }\n  return reinterpret_cast<ThreadIdentity*>(\n      pthread_getspecific(thread_identity_pthread_key));\n}\n#endif\n\n}  // namespace base_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02376",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/base/internal/thread_identity.cc",
  "source_line": 35,
  "validation_status": "validated"
}