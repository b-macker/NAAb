{
  "code": "{\n  friend class AttributeFactory;\n  friend class ParsedAttributes;\n  AttributeFactory &Factory;\n  llvm::SmallVector<ParsedAttr *> Attrs;\n\n  void *allocate(size_t size) {\n    return Factory.allocate(size);\n  }\n\n  ParsedAttr *add(ParsedAttr *attr) {\n    Attrs.push_back(attr);\n    return attr;\n  }\n\n  void remove(ParsedAttr *attr) {\n    assert(llvm::is_contained(Attrs, attr) &&\n           \"Can't take attribute from a pool that doesn't own it!\");\n    Attrs.erase(llvm::find(Attrs, attr));\n  }\n\n  void takePool(AttributePool &pool);\n\npublic:\n  /// Create a new pool for a factory.\n  AttributePool(AttributeFactory &factory) : Factory(factory) {}\n\n  AttributePool(const AttributePool &) = delete;\n  // The copy assignment operator is defined as deleted pending further\n  // motivation.\n  AttributePool &operator=(const AttributePool &) = delete;\n\n  ~AttributePool() { Factory.reclaimPool(*this); }\n\n  /// Move the given pool's allocations to this pool.\n  AttributePool(AttributePool &&pool) = default;\n\n  // The move assignment operator is defined as deleted pending further\n  // motivation.\n  AttributePool &operator=(AttributePool &&pool) = delete;\n\n  AttributeFactory &getFactory() const { return Factory; }\n\n  void clear() {\n    Factory.reclaimPool(*this);\n    Attrs.clear();\n  }\n\n  /// Take the given pool's allocations and add them to this pool.\n  void takeAllFrom(AttributePool &pool) {\n    takePool(pool);\n    pool.Attrs.clear();\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs, ParsedAttr::Form form,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    size_t temp =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0, 0);\n    (void)temp;\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0,\n                                                           0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       args, numArgs, form, ellipsisLoc));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Form form, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    void *memory = allocate(AttributeFactory::AvailabilityAllocSize);\n    return add(new (memory) ParsedAttr(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, form, strict, ReplacementExpr));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Form form) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(3, 0, 0, 0, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       Param1, Param2, Param3, form));\n  }\n\n  ParsedAttr *\n  createTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Form form) {\n    void *memory = allocate(AttributeFactory::TypeTagForDatatypeAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       argumentKind, matchingCType,\n                                       layoutCompatible, mustBeNull, form));\n  }\n\n  ParsedAttr *createTypeAttribute(IdentifierInfo *attrName,\n                                  SourceRange attrRange,\n                                  IdentifierInfo *scopeName,\n                                  SourceLocation scopeLoc, ParsedType typeArg,\n                                  ParsedAttr::Form formUsed,\n                                  SourceLocation ellipsisLoc) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 1, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       typeArg, formUsed, ellipsisLoc));\n  }\n\n  ParsedAttr *\n  createPropertyAttribute(IdentifierInfo *attrName, SourceRange attrRange,\n                          IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                          IdentifierInfo *getterId, IdentifierInfo *setterId,\n                          ParsedAttr::Form formUsed) {\n    void *memory = allocate(AttributeFactory::PropertyAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       getterId, setterId, formUsed));\n  }\n}",
  "id": "BLOCK-CPP-20154",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/ParsedAttr.h",
  "source_line": 672,
  "validation_status": "validated"
}