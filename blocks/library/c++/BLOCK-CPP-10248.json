{
  "code": "{\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_PRValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n}",
  "id": "BLOCK-CPP-10248",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/Expr.h",
  "source_line": 4376,
  "validation_status": "validated"
}