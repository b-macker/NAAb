{
  "code": "{\n\nclass ObjCInterfaceDecl;\nclass ObjCPropertyDecl;\n\nnamespace sema {\n\n/// A declaration being accessed, together with information about how\n/// it was accessed.\nclass AccessedEntity {\npublic:\n  /// A member declaration found through lookup.  The target is the\n  /// member.\n  enum MemberNonce { Member };\n\n  /// A hierarchy (base-to-derived or derived-to-base) conversion.\n  /// The target is the base class.\n  enum BaseNonce { Base };\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 MemberNonce _, CXXRecordDecl *NamingClass,\n                 DeclAccessPair FoundDecl, QualType BaseObjectType)\n      : Access(FoundDecl.getAccess()), IsMember(true),\n        Target(FoundDecl.getDecl()), NamingClass(NamingClass),\n        BaseObjectType(BaseObjectType), Diag(0, Allocator) {}\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 BaseNonce _, CXXRecordDecl *BaseClass,\n                 CXXRecordDecl *DerivedClass, AccessSpecifier Access)\n      : Access(Access), IsMember(false), Target(BaseClass),\n        NamingClass(DerivedClass), Diag(0, Allocator) {}\n\n  bool isMemberAccess() const { return IsMember; }\n\n  bool isQuiet() const { return Diag.getDiagID() == 0; }\n\n  AccessSpecifier getAccess() const { return AccessSpecifier(Access); }\n\n  // These apply to member decls...\n  NamedDecl *getTargetDecl() const { return Target; }\n  CXXRecordDecl *getNamingClass() const { return NamingClass; }\n\n  // ...and these apply to hierarchy conversions.\n  CXXRecordDecl *getBaseClass() const {\n    assert(!IsMember); return cast<CXXRecordDecl>(Target);\n  }\n  CXXRecordDecl *getDerivedClass() const { return NamingClass; }\n\n  /// Retrieves the base object type, important when accessing\n  /// an instance member.\n  QualType getBaseObjectType() const { return BaseObjectType; }\n\n  /// Sets a diagnostic to be performed.  The diagnostic is given\n  /// four (additional) arguments:\n  ///   %0 - 0 if the entity was private, 1 if protected\n  ///   %1 - the DeclarationName of the entity\n  ///   %2 - the TypeDecl type of the naming class\n  ///   %3 - the TypeDecl type of the declaring class\n  void setDiag(const PartialDiagnostic &PDiag) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    Diag = PDiag;\n  }\n  PartialDiagnostic &setDiag(unsigned DiagID) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    assert(DiagID && \"creating null diagnostic\");\n    Diag.Reset(DiagID);\n    return Diag;\n  }\n  const PartialDiagnostic &getDiag() const {\n    return Diag;\n  }\n\nprivate:\n  unsigned Access : 2;\n  unsigned IsMember : 1;\n  NamedDecl *Target;\n  CXXRecordDecl *NamingClass;\n  QualType BaseObjectType;\n  PartialDiagnostic Diag;\n};\n\n/// A diagnostic message which has been conditionally emitted pending\n/// the complete parsing of the current declaration.\nclass DelayedDiagnostic {\npublic:\n  enum DDKind : unsigned char { Availability, Access, ForbiddenType };\n\n  DDKind Kind;\n  bool Triggered;\n\n  SourceLocation Loc;\n\n  void Destroy();\n\n  static DelayedDiagnostic makeAvailability(AvailabilityResult AR,\n                                            ArrayRef<SourceLocation> Locs,\n                                            const NamedDecl *ReferringDecl,\n                                            const NamedDecl *OffendingDecl,\n                                            const ObjCInterfaceDecl *UnknownObjCClass,\n                                            const ObjCPropertyDecl  *ObjCProperty,\n                                            StringRef Msg,\n                                            bool ObjCPropertyAccess);\n\n  static DelayedDiagnostic makeAccess(SourceLocation Loc,\n                                      const AccessedEntity &Entity) {\n    DelayedDiagnostic DD;\n    DD.Kind = Access;\n    DD.Triggered = false;\n    DD.Loc = Loc;\n    new (&DD.getAccessData()) AccessedEntity(Entity);\n    return DD;\n  }\n\n  static DelayedDiagnostic makeForbiddenType(SourceLocation loc,\n                                             unsigned diagnostic,\n                                             QualType type,\n                                             unsigned argument) {\n    DelayedDiagnostic DD;\n    DD.Kind = ForbiddenType;\n    DD.Triggered = false;\n    DD.Loc = loc;\n    DD.ForbiddenTypeData.Diagnostic = diagnostic;\n    DD.ForbiddenTypeData.OperandType = type.getAsOpaquePtr();\n    DD.ForbiddenTypeData.Argument = argument;\n    return DD;\n  }\n\n  AccessedEntity &getAccessData() {\n    assert(Kind == Access && \"Not an access diagnostic.\");\n    return *reinterpret_cast<AccessedEntity*>(AccessData);\n  }\n  const AccessedEntity &getAccessData() const {\n    assert(Kind == Access && \"Not an access diagnostic.\");\n    return *reinterpret_cast<const AccessedEntity*>(AccessData);\n  }\n\n  const NamedDecl *getAvailabilityReferringDecl() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return AvailabilityData.ReferringDecl;\n  }\n\n  const NamedDecl *getAvailabilityOffendingDecl() const {\n    return AvailabilityData.OffendingDecl;\n  }\n\n  StringRef getAvailabilityMessage() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return StringRef(AvailabilityData.Message, AvailabilityData.MessageLen);\n  }\n\n  ArrayRef<SourceLocation> getAvailabilitySelectorLocs() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return llvm::ArrayRef(AvailabilityData.SelectorLocs,\n                          AvailabilityData.NumSelectorLocs);\n  }\n\n  AvailabilityResult getAvailabilityResult() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return AvailabilityData.AR;\n  }\n\n  /// The diagnostic ID to emit.  Used like so:\n  ///   Diag(diag.Loc, diag.getForbiddenTypeDiagnostic())\n  ///     << diag.getForbiddenTypeOperand()\n  ///     << diag.getForbiddenTypeArgument();\n  unsigned getForbiddenTypeDiagnostic() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return ForbiddenTypeData.Diagnostic;\n  }\n\n  unsigned getForbiddenTypeArgument() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return ForbiddenTypeData.Argument;\n  }\n\n  QualType getForbiddenTypeOperand() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return QualType::getFromOpaquePtr(ForbiddenTypeData.OperandType);\n  }\n\n  const ObjCInterfaceDecl *getUnknownObjCClass() const {\n    return AvailabilityData.UnknownObjCClass;\n  }\n\n  const ObjCPropertyDecl *getObjCProperty() const {\n    return AvailabilityData.ObjCProperty;\n  }\n\n  bool getObjCPropertyAccess() const {\n    return AvailabilityData.ObjCPropertyAccess;\n  }\n\nprivate:\n  struct AD {\n    const NamedDecl *ReferringDecl;\n    const NamedDecl *OffendingDecl;\n    const ObjCInterfaceDecl *UnknownObjCClass;\n    const ObjCPropertyDecl  *ObjCProperty;\n    const char *Message;\n    size_t MessageLen;\n    SourceLocation *SelectorLocs;\n    size_t NumSelectorLocs;\n    AvailabilityResult AR;\n    bool ObjCPropertyAccess;\n  };\n\n  struct FTD {\n    unsigned Diagnostic;\n    unsigned Argument;\n    void *OperandType;\n  };\n\n  union {\n    struct AD AvailabilityData;\n    struct FTD ForbiddenTypeData;\n\n    /// Access control.\n    char AccessData[sizeof(AccessedEntity)];\n  };\n};\n\n/// A collection of diagnostics which were delayed.\nclass DelayedDiagnosticPool {\n  const DelayedDiagnosticPool *Parent;\n  SmallVector<DelayedDiagnostic, 4> Diagnostics;\n\npublic:\n  DelayedDiagnosticPool(const DelayedDiagnosticPool *parent) : Parent(parent) {}\n\n  DelayedDiagnosticPool(const DelayedDiagnosticPool &) = delete;\n  DelayedDiagnosticPool &operator=(const DelayedDiagnosticPool &) = delete;\n\n  DelayedDiagnosticPool(DelayedDiagnosticPool &&Other)\n      : Parent(Other.Parent), Diagnostics(std::move(Other.Diagnostics)) {\n    Other.Diagnostics.clear();\n  }\n\n  DelayedDiagnosticPool &operator=(DelayedDiagnosticPool &&Other) {\n    Parent = Other.Parent;\n    Diagnostics = std::move(Other.Diagnostics);\n    Other.Diagnostics.clear();\n    return *this;\n  }\n\n  ~DelayedDiagnosticPool() {\n    for (SmallVectorImpl<DelayedDiagnostic>::iterator\n           i = Diagnostics.begin(), e = Diagnostics.end(); i != e; ++i)\n      i->Destroy();\n  }\n\n  const DelayedDiagnosticPool *getParent() const { return Parent; }\n\n  /// Does this pool, or any of its ancestors, contain any diagnostics?\n  bool empty() const {\n    return (Diagnostics.empty() && (!Parent || Parent->empty()));\n  }\n\n  /// Add a diagnostic to this pool.\n  void add(const DelayedDiagnostic &diag) {\n    Diagnostics.push_back(diag);\n  }\n\n  /// Steal the diagnostics from the given pool.\n  void steal(DelayedDiagnosticPool &pool) {\n    if (pool.Diagnostics.empty()) return;\n\n    if (Diagnostics.empty()) {\n      Diagnostics = std::move(pool.Diagnostics);\n    } else {\n      Diagnostics.append(pool.pool_begin(), pool.pool_end());\n    }\n    pool.Diagnostics.clear();\n  }\n\n  using pool_iterator = SmallVectorImpl<DelayedDiagnostic>::const_iterator;\n\n  pool_iterator pool_begin() const { return Diagnostics.begin(); }\n  pool_iterator pool_end() const { return Diagnostics.end(); }\n  bool pool_empty() const { return Diagnostics.empty(); }\n};\n\n} // namespace clang\n\n/// Add a diagnostic to the current delay pool.\ninline void Sema::DelayedDiagnostics::add(const sema::DelayedDiagnostic &diag) {\n  assert(shouldDelayDiagnostics() && \"trying to delay without pool\");\n  CurPool->add(diag);\n}\n\n}",
  "id": "BLOCK-CPP-19760",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DelayedDiagnostic.h",
  "source_line": 41,
  "validation_status": "validated"
}