{
  "code": "{\n public:\n  using result_type = IntType;\n\n  class param_type {\n   public:\n    using distribution_type = zipf_distribution;\n\n    // Preconditions: k > 0, v > 0, q > 1\n    // The precondidtions are validated when NDEBUG is not defined via\n    // a pair of assert() directives.\n    // If NDEBUG is defined and either or both of these parameters take invalid\n    // values, the behavior of the class is undefined.\n    explicit param_type(result_type k = (std::numeric_limits<IntType>::max)(),\n                        double q = 2.0, double v = 1.0);\n\n    result_type k() const { return k_; }\n    double q() const { return q_; }\n    double v() const { return v_; }\n\n    friend bool operator==(const param_type& a, const param_type& b) {\n      return a.k_ == b.k_ && a.q_ == b.q_ && a.v_ == b.v_;\n    }\n    friend bool operator!=(const param_type& a, const param_type& b) {\n      return !(a == b);\n    }\n\n   private:\n    friend class zipf_distribution;\n    inline double h(double x) const;\n    inline double hinv(double x) const;\n    inline double compute_s() const;\n    inline double pow_negative_q(double x) const;\n\n    // Parameters here are exactly the same as the parameters of Algorithm ZRI\n    // in the paper.\n    IntType k_;\n    double q_;\n    double v_;\n\n    double one_minus_q_;  // 1-q\n    double s_;\n    double one_minus_q_inv_;  // 1 / 1-q\n    double hxm_;              // h(k + 0.5)\n    double hx0_minus_hxm_;    // h(x0) - h(k + 0.5)\n\n    static_assert(random_internal::IsIntegral<IntType>::value,\n                  \"Class-template absl::zipf_distribution<> must be \"\n                  \"parameterized using an integral type.\");\n  };\n\n  zipf_distribution()\n      : zipf_distribution((std::numeric_limits<IntType>::max)()) {}\n\n  explicit zipf_distribution(result_type k, double q = 2.0, double v = 1.0)\n      : param_(k, q, v) {}\n\n  explicit zipf_distribution(const param_type& p) : param_(p) {}\n\n  void reset() {}\n\n  template <typename URBG>\n  result_type operator()(URBG& g) {  // NOLINT(runtime/references)\n    return (*this)(g, param_);\n  }\n\n  template <typename URBG>\n  result_type operator()(URBG& g,  // NOLINT(runtime/references)\n                         const param_type& p);\n\n  result_type k() const { return param_.k(); }\n  double q() const { return param_.q(); }\n  double v() const { return param_.v(); }\n\n  param_type param() const { return param_; }\n  void param(const param_type& p) { param_ = p; }\n\n  result_type(min)() const { return 0; }\n  result_type(max)() const { return k(); }\n\n  friend bool operator==(const zipf_distribution& a,\n                         const zipf_distribution& b) {\n    return a.param_ == b.param_;\n  }\n  friend bool operator!=(const zipf_distribution& a,\n                         const zipf_distribution& b) {\n    return a.param_ != b.param_;\n  }\n\n private:\n  param_type param_;\n}",
  "id": "BLOCK-CPP-03938",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/zipf_distribution.h",
  "source_line": 51,
  "validation_status": "validated"
}