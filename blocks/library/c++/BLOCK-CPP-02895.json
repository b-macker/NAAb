{
  "code": "{\n  // Returns true if the node at 'depth' is not shared, i.e. has a refcount\n  // of one and all of its parent nodes have a refcount of one.\n  inline bool owned(int depth) const { return depth < share_depth; }\n\n  // Returns the node at 'depth'.\n  inline CordRepBtree* node(int depth) const { return stack[depth]; }\n\n  // Builds a `depth` levels deep stack starting at `tree` recording which nodes\n  // are private in the form of the 'share depth' where nodes are shared.\n  inline CordRepBtree* BuildStack(CordRepBtree* tree, int depth) {\n    assert(depth <= tree->height());\n    int current_depth = 0;\n    while (current_depth < depth && tree->refcount.IsOne()) {\n      stack[current_depth++] = tree;\n      tree = tree->Edge(edge_type)->btree();\n    }\n    share_depth = current_depth + (tree->refcount.IsOne() ? 1 : 0);\n    while (current_depth < depth) {\n      stack[current_depth++] = tree;\n      tree = tree->Edge(edge_type)->btree();\n    }\n    return tree;\n  }\n\n  // Builds a stack with the invariant that all nodes are private owned / not\n  // shared. This is used in iterative updates where a previous propagation\n  // guaranteed all nodes are owned / private.\n  inline void BuildOwnedStack(CordRepBtree* tree, int height) {\n    assert(height <= CordRepBtree::kMaxHeight);\n    int depth = 0;\n    while (depth < height) {\n      assert(tree->refcount.IsOne());\n      stack[depth++] = tree;\n      tree = tree->Edge(edge_type)->btree();\n    }\n    assert(tree->refcount.IsOne());\n    share_depth = depth + 1;\n  }\n\n  // Processes the final 'top level' result action for the tree.\n  // See the 'Action' enum for the various action implications.\n  static inline CordRepBtree* Finalize(CordRepBtree* tree, OpResult result) {\n    switch (result.action) {\n      case CordRepBtree::kPopped:\n        tree = edge_type == kBack ? CordRepBtree::New(tree, result.tree)\n                                  : CordRepBtree::New(result.tree, tree);\n        if (ABSL_PREDICT_FALSE(tree->height() > CordRepBtree::kMaxHeight)) {\n          tree = CordRepBtree::Rebuild(tree);\n          ABSL_RAW_CHECK(tree->height() <= CordRepBtree::kMaxHeight,\n                         \"Max height exceeded\");\n        }\n        return tree;\n      case CordRepBtree::kCopied:\n        CordRep::Unref(tree);\n        ABSL_FALLTHROUGH_INTENDED;\n      case CordRepBtree::kSelf:\n        return result.tree;\n    }\n    ABSL_UNREACHABLE();\n    return result.tree;\n  }\n\n  // Propagate the action result in 'result' up into all nodes of the stack\n  // starting at depth 'depth'. 'length' contains the extra length of data that\n  // was added at the lowest level, and is updated into all nodes of the stack.\n  // See the 'Action' enum for the various action implications.\n  // If 'propagate' is true, then any copied node values are updated into the\n  // stack, which is used for iterative processing on the same stack.\n  template <bool propagate = false>\n  inline CordRepBtree* Unwind(CordRepBtree* tree, int depth, size_t length,\n                              OpResult result) {\n    // TODO(mvels): revisit the below code to check if 3 loops with 3\n    // (incremental) conditions is faster than 1 loop with a switch.\n    // Benchmarking and perf recordings indicate the loop with switch is\n    // fastest, likely because of indirect jumps on the tight case values and\n    // dense branches. But it's worth considering 3 loops, as the `action`\n    // transitions are mono directional. E.g.:\n    //   while (action == kPopped) {\n    //     ...\n    //   }\n    //   while (action == kCopied) {\n    //     ...\n    //   }\n    //   ...\n    // We also  found that an \"if () do {}\" loop here seems faster, possibly\n    // because it allows the branch predictor more granular heuristics on\n    // 'single leaf' (`depth` == 0) and 'single depth' (`depth` == 1) cases\n    // which appear to be the most common use cases.\n    if (depth != 0) {\n      do {\n        CordRepBtree* node = stack[--depth];\n        const bool owned = depth < share_depth;\n        switch (result.action) {\n          case CordRepBtree::kPopped:\n            assert(!propagate);\n            result = node->AddEdge<edge_type>(owned, result.tree, length);\n            break;\n          case CordRepBtree::kCopied:\n            result = node->SetEdge<edge_type>(owned, result.tree, length);\n            if (propagate) stack[depth] = result.tree;\n            break;\n          case CordRepBtree::kSelf:\n            node->length += length;\n            while (depth > 0) {\n              node = stack[--depth];\n              node->length += length;\n            }\n            return node;\n        }\n      } while (depth > 0);\n    }\n    return Finalize(tree, result);\n  }\n\n  // Invokes `Unwind` with `propagate=true` to update the stack node values.\n  inline CordRepBtree* Propagate(CordRepBtree* tree, int depth, size_t length,\n                                 OpResult result) {\n    return Unwind</*propagate=*/true>(tree, depth, length, result);\n  }\n\n  // `share_depth` contains the depth at which the nodes in the stack become\n  // shared. I.e., if the top most level is shared (i.e.: `!refcount.IsOne()`),\n  // then `share_depth` is 0. If the 2nd node is shared (and implicitly all\n  // nodes below that) then `share_depth` is 1, etc. A `share_depth` greater\n  // than the depth of the stack indicates that none of the nodes in the stack\n  // are shared.\n  int share_depth;\n\n  NodeStack stack;\n}",
  "id": "BLOCK-CPP-02895",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_btree.cc",
  "source_line": 229,
  "validation_status": "validated"
}