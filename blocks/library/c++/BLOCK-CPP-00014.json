{
  "code": "{\nnamespace level {\n\n#if __cplusplus >= 201703L\nconstexpr\n#endif\n    static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;\n\nstatic const char *short_level_names[] SPDLOG_SHORT_LEVEL_NAMES;\n\nSPDLOG_INLINE const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT {\n    return level_string_views[l];\n}\n\nSPDLOG_INLINE const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT {\n    return short_level_names[l];\n}\n\nSPDLOG_INLINE spdlog::level::level_enum from_str(const std::string &name) SPDLOG_NOEXCEPT {\n    auto it = std::find(std::begin(level_string_views), std::end(level_string_views), name);\n    if (it != std::end(level_string_views))\n        return static_cast<level::level_enum>(std::distance(std::begin(level_string_views), it));\n\n    // check also for \"warn\" and \"err\" before giving up..\n    if (name == \"warn\") {\n        return level::warn;\n    }\n    if (name == \"err\") {\n        return level::err;\n    }\n    return level::off;\n}\n}  // namespace level\n\nSPDLOG_INLINE spdlog_ex::spdlog_ex(std::string msg)\n    : msg_(std::move(msg)) {}\n\nSPDLOG_INLINE spdlog_ex::spdlog_ex(const std::string &msg, int last_errno) {\n#ifdef SPDLOG_USE_STD_FORMAT\n    msg_ = std::system_error(std::error_code(last_errno, std::generic_category()), msg).what();\n#else\n    memory_buf_t outbuf;\n    fmt::format_system_error(outbuf, last_errno, msg.c_str());\n    msg_ = fmt::to_string(outbuf);\n#endif\n}\n\nSPDLOG_INLINE const char *spdlog_ex::what() const SPDLOG_NOEXCEPT { return msg_.c_str(); }\n\nSPDLOG_INLINE void throw_spdlog_ex(const std::string &msg, int last_errno) {\n    SPDLOG_THROW(spdlog_ex(msg, last_errno));\n}\n\nSPDLOG_INLINE void throw_spdlog_ex(std::string msg) { SPDLOG_THROW(spdlog_ex(std::move(msg))); }\n\n}",
  "id": "BLOCK-CPP-00014",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/common-inl.h",
  "source_line": 13,
  "validation_status": "validated"
}