{
  "code": "{\n///    public:\n///     virtual void x(); // matches x\n///   };\n/// \\endcode\n///\n/// Example:\n/// \\code\n///   class Base {};\n///   class DirectlyDerived : virtual Base {}; // matches Base\n///   class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base\n/// \\endcode\n///\n/// Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>\nAST_POLYMORPHIC_MATCHER(isVirtual,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXMethodDecl,\n                                                        CXXBaseSpecifier)) {\n  return Node.isVirtual();\n}\n\n/// Matches if the given method declaration has an explicit \"virtual\".\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     void x();\n///   };\n/// \\endcode\n///   matches A::x but not B::x\nAST_MATCHER(CXXMethodDecl, isVirtualAsWritten) {\n  return Node.isVirtualAsWritten();\n}\n\nAST_MATCHER(CXXConstructorDecl, isInheritingConstructor) {\n  return Node.isInheritingConstructor();\n}\n\n/// Matches if the given method or class declaration is final.\n///\n/// Given:\n/// \\code\n///   class A final {};\n///\n///   struct B {\n///     virtual void f();\n///   };\n///\n///   struct C : B {\n///     void f() final;\n///   };\n/// \\endcode\n/// matches A and C::f, but not B, C, or B::f\nAST_POLYMORPHIC_MATCHER(isFinal,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl,\n                                                        CXXMethodDecl)) {\n  return Node.template hasAttr<FinalAttr>();\n}\n\n/// Matches if the given method declaration is pure.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x() = 0;\n///   };\n/// \\endcode\n///   matches A::x\nAST_MATCHER(CXXMethodDecl, isPure) {\n  return Node.isPure();\n}\n\n/// Matches if the given method declaration is const.\n///\n/// Given\n/// \\code\n/// struct A {\n///   void foo() const;\n///   void bar();\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isConst()) matches A::foo() but not A::bar()\nAST_MATCHER(CXXMethodDecl, isConst) {\n  return Node.isConst();\n}\n\n/// Matches if the given method declaration declares a copy assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isCopyAssignmentOperator()) matches the first method but not\n/// the second one.\nAST_MATCHER(CXXMethodDecl, isCopyAssignmentOperator) {\n  return Node.isCopyAssignmentOperator();\n}\n\n/// Matches if the given method declaration declares a move assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not\n/// the first one.\nAST_MATCHER(CXXMethodDecl, isMoveAssignmentOperator) {\n  return Node.isMoveAssignmentOperator();\n}\n\n/// Matches if the given method declaration overrides another method.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     virtual void x();\n///   };\n/// \\endcode\n///   matches B::x\nAST_MATCHER(CXXMethodDecl, isOverride) {\n  return Node.size_overridden_methods() > 0 || Node.hasAttr<OverrideAttr>();\n}\n\n/// Matches method declarations that are user-provided.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &) = default; // #2\n///     S(S &&) = delete; // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXMethodDecl, isUserProvided) {\n  return Node.isUserProvided();\n}\n\n/// Matches member expressions that are called with '->' as opposed\n/// to '.'.\n///\n/// Member calls on the implicit this pointer match as called with '->'.\n///\n/// Given\n/// \\code\n///   class Y {\n///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }\n///     template <class T> void f() { this->f<T>(); f<T>(); }\n///     int a;\n///     static int b;\n///   };\n///   template <class T>\n///   class Z {\n///     void x() { this->m; }\n///   };\n/// \\endcode\n/// memberExpr(isArrow())\n///   matches this->x, x, y.x, a, this->b\n/// cxxDependentScopeMemberExpr(isArrow())\n///   matches this->m\n/// unresolvedMemberExpr(isArrow())\n///   matches this->f<T>, f<T>\nAST_POLYMORPHIC_MATCHER(\n    isArrow, AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                             CXXDependentScopeMemberExpr)) {\n  return Node.isArrow();\n}\n\n/// Matches QualType nodes that are of integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isInteger())))\n/// matches \"a(int)\", \"b(long)\", but not \"c(double)\".\nAST_MATCHER(QualType, isInteger) {\n    return Node->isIntegerType();\n}\n\n/// Matches QualType nodes that are of unsigned integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isUnsignedInteger())))\n/// matches \"b(unsigned long)\", but not \"a(int)\" and \"c(double)\".\nAST_MATCHER(QualType, isUnsignedInteger) {\n    return Node->isUnsignedIntegerType();\n}\n\n/// Matches QualType nodes that are of signed integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isSignedInteger())))\n/// matches \"a(int)\", but not \"b(unsigned long)\" and \"c(double)\".\nAST_MATCHER(QualType, isSignedInteger) {\n    return Node->isSignedIntegerType();\n}\n\n/// Matches QualType nodes that are of character type.\n///\n/// Given\n/// \\code\n///   void a(char);\n///   void b(wchar_t);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isAnyCharacter())))\n/// matches \"a(char)\", \"b(wchar_t)\", but not \"c(double)\".\nAST_MATCHER(QualType, isAnyCharacter) {\n    return Node->isAnyCharacterType();\n}\n\n/// Matches QualType nodes that are of any pointer type; this includes\n/// the Objective-C object pointer type, which is different despite being\n/// syntactically similar.\n///\n/// Given\n/// \\code\n///   int *i = nullptr;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n///\n///   int j;\n/// \\endcode\n/// varDecl(hasType(isAnyPointer()))\n///   matches \"int *i\" and \"Foo *f\", but not \"int j\".\nAST_MATCHER(QualType, isAnyPointer) {\n  return Node->isAnyPointerType();\n}\n\n/// Matches QualType nodes that are const-qualified, i.e., that\n/// include \"top-level\" const.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int const);\n///   void c(const int);\n///   void d(const int*);\n///   void e(int const) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isConstQualified())))\n///   matches \"void b(int const)\", \"void c(const int)\" and\n///   \"void e(int const) {}\". It does not match d as there\n///   is no top-level const on the parameter type \"const int *\".\nAST_MATCHER(QualType, isConstQualified) {\n  return Node.isConstQualified();\n}\n\n/// Matches QualType nodes that are volatile-qualified, i.e., that\n/// include \"top-level\" volatile.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int volatile);\n///   void c(volatile int);\n///   void d(volatile int*);\n///   void e(int volatile) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isVolatileQualified())))\n///   matches \"void b(int volatile)\", \"void c(volatile int)\" and\n///   \"void e(int volatile) {}\". It does not match d as there\n///   is no top-level volatile on the parameter type \"volatile int *\".\nAST_MATCHER(QualType, isVolatileQualified) {\n  return Node.isVolatileQualified();\n}\n\n/// Matches QualType nodes that have local CV-qualifiers attached to\n/// the node, not hidden within a typedef.\n///\n/// Given\n/// \\code\n///   typedef const int const_int;\n///   const_int i;\n///   int *const j;\n///   int *volatile k;\n///   int m;\n/// \\endcode\n/// \\c varDecl(hasType(hasLocalQualifiers())) matches only \\c j and \\c k.\n/// \\c i is const-qualified but the qualifier is not local.\nAST_MATCHER(QualType, hasLocalQualifiers) {\n  return Node.hasLocalQualifiers();\n}\n\n/// Matches a member expression where the member is matched by a\n/// given matcher.\n///\n/// Given\n/// \\code\n///   struct { int first, second; } first, second;\n///   int i(second.first);\n///   int j(first.second);\n/// \\endcode\n/// memberExpr(member(hasName(\"first\")))\n///   matches second.first\n///   but not first.second (because the member name there is \"second\").\nAST_MATCHER_P(MemberExpr, member,\n              internal::Matcher<ValueDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n}\n\n/// Matches a member expression where the object expression is matched by a\n/// given matcher. Implicit object expressions are included; that is, it matches\n/// use of implicit `this`.\n///\n/// Given\n/// \\code\n///   struct X {\n///     int m;\n///     int f(X x) { x.m; return m; }\n///   };\n/// \\endcode\n/// memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.m`, but not `m`; however,\n/// memberExpr(hasObjectExpression(hasType(pointsTo(\n//      cxxRecordDecl(hasName(\"X\"))))))\n///   matches `m` (aka. `this->m`), but not `x.m`.\nAST_POLYMORPHIC_MATCHER_P(\n    hasObjectExpression,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                    CXXDependentScopeMemberExpr),\n    internal::Matcher<Expr>, InnerMatcher) {\n  if (const auto *E = dyn_cast<UnresolvedMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  if (const auto *E = dyn_cast<CXXDependentScopeMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  return InnerMatcher.matches(*Node.getBase(), Finder, Builder);\n}\n\n/// Matches any using shadow declaration.\n///\n/// Given\n/// \\code\n///   namespace X { void b(); }\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasName(\"b\"))))\n///   matches \\code using X::b \\endcode\nAST_MATCHER_P(BaseUsingDecl, hasAnyUsingShadowDecl,\n              internal::Matcher<UsingShadowDecl>, InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.shadow_begin(),\n                                    Node.shadow_end(), Finder,\n                                    Builder) != Node.shadow_end();\n}\n\n/// Matches a using shadow declaration where the target declaration is\n/// matched by the given matcher.\n///\n/// Given\n/// \\code\n///   namespace X { int a; void b(); }\n///   using X::a;\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))\n///   matches \\code using X::b \\endcode\n///   but not \\code using X::a \\endcode\nAST_MATCHER_P(UsingShadowDecl, hasTargetDecl,\n              internal::Matcher<NamedDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getTargetDecl(), Finder, Builder);\n}\n\n/// Matches template instantiations of function, class, or static\n/// member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template <typename T> class X {}; class A {}; X<A> x;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; template class X<A>;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; extern template class X<A>;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   matches the template instantiation of X<A>.\n///\n/// But given\n/// \\code\n///   template <typename T>  class X {}; class A {};\n///   template <> class X<A> {}; X<A> x;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   does not match, as X<A> is an explicit template specialization.\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isTemplateInstantiation,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ImplicitInstantiation ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDefinition ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDeclaration);\n}\n\n/// Matches declarations that are template instantiations or are inside\n/// template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { T i; }\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// functionDecl(isInstantiated())\n///   matches 'A(int) {...};' and 'A(unsigned) {...}'.\nAST_MATCHER_FUNCTION(internal::Matcher<Decl>, isInstantiated) {\n  auto IsInstantiation = decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                                    functionDecl(isTemplateInstantiation())));\n  return decl(anyOf(IsInstantiation, hasAncestor(IsInstantiation)));\n}\n\n/// Matches statements inside of a template instantiation.\n///\n/// Given\n/// \\code\n///   int j;\n///   template<typename T> void A(T t) { T i; j += 42;}\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// declStmt(isInTemplateInstantiation())\n///   matches 'int i;' and 'unsigned i'.\n/// unless(stmt(isInTemplateInstantiation()))\n///   will NOT match j += 42; as it's shared between the template definition and\n///   instantiation.\nAST_MATCHER_FUNCTION(internal::Matcher<Stmt>, isInTemplateInstantiation) {\n  return stmt(\n      hasAncestor(decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                             functionDecl(isTemplateInstantiation())))));\n}\n\n/// Matches explicit template specializations of function, class, or\n/// static member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { }\n///   template<> void A(int N) { }\n/// \\endcode\n/// functionDecl(isExplicitTemplateSpecialization())\n///   matches the specialization A<int>().\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isExplicitTemplateSpecialization,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ExplicitSpecialization);\n}\n\n/// Matches \\c TypeLocs for which the given inner\n/// QualType-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(internal::BindableMatcher<TypeLoc>, loc,\n                                internal::Matcher<QualType>, InnerMatcher, 0) {\n  return internal::BindableMatcher<TypeLoc>(\n      new internal::TypeLocTypeMatcher(InnerMatcher));\n}\n\n/// Matches `QualifiedTypeLoc`s in the clang AST.\n///\n/// Given\n/// \\code\n///   const int x = 0;\n/// \\endcode\n/// qualifiedTypeLoc()\n///   matches `const int`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, QualifiedTypeLoc>\n    qualifiedTypeLoc;\n\n/// Matches `QualifiedTypeLoc`s that have an unqualified `TypeLoc` matching\n/// `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   int* const x;\n///   const int y;\n/// \\endcode\n/// qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc()))\n///   matches the `TypeLoc` of the variable declaration of `x`, but not `y`.\nAST_MATCHER_P(QualifiedTypeLoc, hasUnqualifiedLoc, internal::Matcher<TypeLoc>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getUnqualifiedLoc(), Finder, Builder);\n}\n\n/// Matches a function declared with the specified return `TypeLoc`.\n///\n/// Given\n/// \\code\n///   int f() { return 5; }\n///   void g() {}\n/// \\endcode\n/// functionDecl(hasReturnTypeLoc(loc(asString(\"int\"))))\n///   matches the declaration of `f`, but not `g`.\nAST_MATCHER_P(FunctionDecl, hasReturnTypeLoc, internal::Matcher<TypeLoc>,\n              ReturnMatcher) {\n  auto Loc = Node.getFunctionTypeLoc();\n  return Loc && ReturnMatcher.matches(Loc.getReturnLoc(), Finder, Builder);\n}\n\n/// Matches pointer `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   int* x;\n/// \\endcode\n/// pointerTypeLoc()\n///   matches `int*`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, PointerTypeLoc>\n    pointerTypeLoc;\n\n/// Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching\n/// `PointeeMatcher`.\n///\n/// Given\n/// \\code\n///   int* x;\n/// \\endcode\n/// pointerTypeLoc(hasPointeeLoc(loc(asString(\"int\"))))\n///   matches `int*`.\nAST_MATCHER_P(PointerTypeLoc, hasPointeeLoc, internal::Matcher<TypeLoc>,\n              PointeeMatcher) {\n  return PointeeMatcher.matches(Node.getPointeeLoc(), Finder, Builder);\n}\n\n/// Matches reference `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   int x = 3;\n///   int& l = x;\n///   int&& r = 3;\n/// \\endcode\n/// referenceTypeLoc()\n///   matches `int&` and `int&&`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, ReferenceTypeLoc>\n    referenceTypeLoc;\n\n/// Matches reference `TypeLoc`s that have a referent `TypeLoc` matching\n/// `ReferentMatcher`.\n///\n/// Given\n/// \\code\n///   int x = 3;\n///   int& xx = x;\n/// \\endcode\n/// referenceTypeLoc(hasReferentLoc(loc(asString(\"int\"))))\n///   matches `int&`.\nAST_MATCHER_P(ReferenceTypeLoc, hasReferentLoc, internal::Matcher<TypeLoc>,\n              ReferentMatcher) {\n  return ReferentMatcher.matches(Node.getPointeeLoc(), Finder, Builder);\n}\n\n/// Matches template specialization `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   template <typename T> class C {};\n///   C<char> var;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(typeLoc())))\n///   matches `C<char> var`.\nextern const internal::VariadicDynCastAllOfMatcher<\n    TypeLoc, TemplateSpecializationTypeLoc>\n    templateSpecializationTypeLoc;\n\n/// Matches template specialization `TypeLoc`s that have at least one\n/// `TemplateArgumentLoc` matching the given `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template<typename T> class A {};\n///   A<int> a;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(\n///   hasTypeLoc(loc(asString(\"int\")))))))\n///   matches `A<int> a`.\nAST_MATCHER_P(TemplateSpecializationTypeLoc, hasAnyTemplateArgumentLoc,\n              internal::Matcher<TemplateArgumentLoc>, InnerMatcher) {\n  for (unsigned Index = 0, N = Node.getNumArgs(); Index < N; ++Index) {\n    clang::ast_matchers::internal::BoundNodesTreeBuilder Result(*Builder);\n    if (InnerMatcher.matches(Node.getArgLoc(Index), Finder, &Result)) {\n      *Builder = std::move(Result);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Matches template specialization `TypeLoc`s where the n'th\n/// `TemplateArgumentLoc` matches the given `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template<typename T, typename U> class A {};\n///   A<double, int> b;\n///   A<int, double> c;\n/// \\endcode\n/// varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,\n///   hasTypeLoc(loc(asString(\"double\")))))))\n///   matches `A<double, int> b`, but not `A<int, double> c`.\nAST_POLYMORPHIC_MATCHER_P2(\n    hasTemplateArgumentLoc,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(DeclRefExpr, TemplateSpecializationTypeLoc),\n    unsigned, Index, internal::Matcher<TemplateArgumentLoc>, InnerMatcher) {\n  return internal::MatchTemplateArgLocAt(Node, Index, InnerMatcher, Finder,\n                                         Builder);\n}\n\n/// Matches C or C++ elaborated `TypeLoc`s.\n///\n/// Given\n/// \\code\n///   struct s {};\n///   struct s ss;\n/// \\endcode\n/// elaboratedTypeLoc()\n///   matches the `TypeLoc` of the variable declaration of `ss`.\nextern const internal::VariadicDynCastAllOfMatcher<TypeLoc, ElaboratedTypeLoc>\n    elaboratedTypeLoc;\n\n/// Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching\n/// `InnerMatcher`.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C {};\n///   class C<int> c;\n///\n///   class D {};\n///   class D d;\n/// \\endcode\n/// elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()));\n///   matches the `TypeLoc` of the variable declaration of `c`, but not `d`.\nAST_MATCHER_P(ElaboratedTypeLoc, hasNamedTypeLoc, internal::Matcher<TypeLoc>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getNamedTypeLoc(), Finder, Builder);\n}\n\n/// Matches type \\c bool.\n///\n/// Given\n/// \\code\n///  struct S { bool func(); };\n/// \\endcode\n/// functionDecl(returns(booleanType()))\n///   matches \"bool func();\"\nAST_MATCHER(Type, booleanType) {\n  return Node.isBooleanType();\n}\n\n/// Matches type \\c void.\n///\n/// Given\n/// \\code\n///  struct S { void func(); };\n/// \\endcode\n/// functionDecl(returns(voidType()))\n///   matches \"void func();\"\nAST_MATCHER(Type, voidType) {\n  return Node.isVoidType();\n}\n\ntemplate <typename NodeType>\nusing AstTypeMatcher = internal::VariadicDynCastAllOfMatcher<Type, NodeType>;\n\n/// Matches builtin Types.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a;\n///   int b;\n///   float c;\n///   bool d;\n/// \\endcode\n/// builtinType()\n///   matches \"int b\", \"float c\" and \"bool d\"\nextern const AstTypeMatcher<BuiltinType> builtinType;\n\n/// Matches all kinds of arrays.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[4];\n///   void f() { int c[a[0]]; }\n/// \\endcode\n/// arrayType()\n///   matches \"int a[]\", \"int b[4]\" and \"int c[a[0]]\";\nextern const AstTypeMatcher<ArrayType> arrayType;\n\n/// Matches C99 complex types.\n///\n/// Given\n/// \\code\n///   _Complex float f;\n/// \\endcode\n/// complexType()\n///   matches \"_Complex float f\"\nextern const AstTypeMatcher<ComplexType> complexType;\n\n/// Matches any real floating-point type (float, double, long double).\n///\n/// Given\n/// \\code\n///   int i;\n///   float f;\n/// \\endcode\n/// realFloatingPointType()\n///   matches \"float f\" but not \"int i\"\nAST_MATCHER(Type, realFloatingPointType) {\n  return Node.isRealFloatingType();\n}\n\n/// Matches arrays and C99 complex types that have a specific element\n/// type.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a[7];\n///   int b[7];\n/// \\endcode\n/// arrayType(hasElementType(builtinType()))\n///   matches \"int b[7]\"\n///\n/// Usable as: Matcher<ArrayType>, Matcher<ComplexType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasElementType, getElement,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(ArrayType,\n                                                                  ComplexType));\n\n/// Matches C arrays with a specified constant size.\n///\n/// Given\n/// \\code\n///   void() {\n///     int a[2];\n///     int b[] = { 2, 3 };\n///     int c[b[0]];\n///   }\n/// \\endcode\n/// constantArrayType()\n///   matches \"int a[2]\"\nextern const AstTypeMatcher<ConstantArrayType> constantArrayType;\n\n/// Matches nodes that have the specified size.\n///\n/// Given\n/// \\code\n///   int a[42];\n///   int b[2 * 21];\n///   int c[41], d[43];\n///   char *s = \"abcd\";\n///   wchar_t *ws = L\"abcd\";\n///   char *w = \"a\";\n/// \\endcode\n/// constantArrayType(hasSize(42))\n///   matches \"int a[42]\" and \"int b[2 * 21]\"\n/// stringLiteral(hasSize(4))\n///   matches \"abcd\", L\"abcd\"\nAST_POLYMORPHIC_MATCHER_P(hasSize,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ConstantArrayType,\n                                                          StringLiteral),\n                          unsigned, N) {\n  return internal::HasSizeMatcher<NodeType>::hasSize(Node, N);\n}\n\n/// Matches C++ arrays whose size is a value-dependent expression.\n///\n/// Given\n/// \\code\n///   template<typename T, int Size>\n///   class array {\n///     T data[Size];\n///   };\n/// \\endcode\n/// dependentSizedArrayType\n///   matches \"T data[Size]\"\nextern const AstTypeMatcher<DependentSizedArrayType> dependentSizedArrayType;\n\n/// Matches C arrays with unspecified size.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[42];\n///   void f(int c[]) { int d[a[0]]; };\n/// \\endcode\n/// incompleteArrayType()\n///   matches \"int a[]\" and \"int c[]\"\nextern const AstTypeMatcher<IncompleteArrayType> incompleteArrayType;\n\n/// Matches C arrays with a specified size that is not an\n/// integer-constant-expression.\n///\n/// Given\n/// \\code\n///   void f() {\n///     int a[] = { 2, 3 }\n///     int b[42];\n///     int c[a[0]];\n///   }\n/// \\endcode\n/// variableArrayType()\n///   matches \"int c[a[0]]\"\nextern const AstTypeMatcher<VariableArrayType> variableArrayType;\n\n/// Matches \\c VariableArrayType nodes that have a specific size\n/// expression.\n///\n/// Given\n/// \\code\n///   void f(int b) {\n///     int a[b];\n///   }\n/// \\endcode\n/// variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(\n///   varDecl(hasName(\"b\")))))))\n///   matches \"int a[b]\"\nAST_MATCHER_P(VariableArrayType, hasSizeExpr,\n              internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getSizeExpr(), Finder, Builder);\n}\n\n/// Matches atomic types.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n/// \\endcode\n/// atomicType()\n///   matches \"_Atomic(int) i\"\nextern const AstTypeMatcher<AtomicType> atomicType;\n\n/// Matches atomic types with a specific value type.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n///   _Atomic(float) f;\n/// \\endcode\n/// atomicType(hasValueType(isInteger()))\n///  matches \"_Atomic(int) i\"\n///\n/// Usable as: Matcher<AtomicType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasValueType, getValue,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(AtomicType));\n\n/// Matches types nodes representing C++11 auto types.\n///\n/// Given:\n/// \\code\n///   auto n = 4;\n///   int v[] = { 2, 3 }\n///   for (auto i : v) { }\n/// \\endcode\n/// autoType()\n///   matches \"auto n\" and \"auto i\"\nextern const AstTypeMatcher<AutoType> autoType;\n\n/// Matches types nodes representing C++11 decltype(<expr>) types.\n///\n/// Given:\n/// \\code\n///   short i = 1;\n///   int j = 42;\n///   decltype(i + j) result = i + j;\n/// \\endcode\n/// decltypeType()\n///   matches \"decltype(i + j)\"\nextern const AstTypeMatcher<DecltypeType> decltypeType;\n\n/// Matches \\c AutoType nodes where the deduced type is a specific type.\n///\n/// Note: There is no \\c TypeLoc for the deduced type and thus no\n/// \\c getDeducedLoc() matcher.\n///\n/// Given\n/// \\code\n///   auto a = 1;\n///   auto b = 2.0;\n/// \\endcode\n/// autoType(hasDeducedType(isInteger()))\n///   matches \"auto a\"\n///\n/// Usable as: Matcher<AutoType>\nAST_TYPE_TRAVERSE_MATCHER(hasDeducedType, getDeducedType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(AutoType));\n\n/// Matches \\c DecltypeType or \\c UsingType nodes to find the underlying type.\n///\n/// Given\n/// \\code\n///   decltype(1) a = 1;\n///   decltype(2.0) b = 2.0;\n/// \\endcode\n/// decltypeType(hasUnderlyingType(isInteger()))\n///   matches the type of \"a\"\n///\n/// Usable as: Matcher<DecltypeType>, Matcher<UsingType>\nAST_TYPE_TRAVERSE_MATCHER(hasUnderlyingType, getUnderlyingType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(DecltypeType,\n                                                          UsingType));\n\n/// Matches \\c FunctionType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionType()\n///   matches \"int (*f)(int)\" and the type of \"g\".\nextern const AstTypeMatcher<FunctionType> functionType;\n\n/// Matches \\c FunctionProtoType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionProtoType()\n///   matches \"int (*f)(int)\" and the type of \"g\" in C++ mode.\n///   In C mode, \"g\" is not matched because it does not contain a prototype.\nextern const AstTypeMatcher<FunctionProtoType> functionProtoType;\n\n/// Matches \\c ParenType nodes.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int *array_of_ptrs[4];\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType()))) matches \\c ptr_to_array but not\n/// \\c array_of_ptrs.\nextern const AstTypeMatcher<ParenType> parenType;\n\n/// Matches \\c ParenType nodes where the inner type is a specific type.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int (*ptr_to_func)(int);\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches\n/// \\c ptr_to_func but not \\c ptr_to_array.\n///\n/// Usable as: Matcher<ParenType>\nAST_TYPE_TRAVERSE_MATCHER(innerType, getInnerType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ParenType));\n\n/// Matches block pointer types, i.e. types syntactically represented as\n/// \"void (^)(int)\".\n///\n/// The \\c pointee is always required to be a \\c FunctionType.\nextern const AstTypeMatcher<BlockPointerType> blockPointerType;\n\n/// Matches member pointer types.\n/// Given\n/// \\code\n///   struct A { int i; }\n///   A::* ptr = A::i;\n/// \\endcode\n/// memberPointerType()\n///   matches \"A::* ptr\"\nextern const AstTypeMatcher<MemberPointerType> memberPointerType;\n\n/// Matches pointer types, but does not match Objective-C object pointer\n/// types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int c = 5;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"int *a\", but does not match \"Foo *f\".\nextern const AstTypeMatcher<PointerType> pointerType;\n\n/// Matches an Objective-C object pointer type, which is different from\n/// a pointer type, despite being syntactically similar.\n///\n/// Given\n/// \\code\n///   int *a;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"Foo *f\", but does not match \"int *a\".\nextern const AstTypeMatcher<ObjCObjectPointerType> objcObjectPointerType;\n\n/// Matches both lvalue and rvalue reference types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c referenceType() matches the types of \\c b, \\c c, \\c d, \\c e, and \\c f.\nextern const AstTypeMatcher<ReferenceType> referenceType;\n\n/// Matches lvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c lValueReferenceType() matches the types of \\c b, \\c d, and \\c e. \\c e is\n/// matched since the type is deduced as int& by reference collapsing rules.\nextern const AstTypeMatcher<LValueReferenceType> lValueReferenceType;\n\n/// Matches rvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c rValueReferenceType() matches the types of \\c c and \\c f. \\c e is not\n/// matched as it is deduced to int& by reference collapsing rules.\nextern const AstTypeMatcher<RValueReferenceType> rValueReferenceType;\n\n/// Narrows PointerType (and similar) matchers to those where the\n/// \\c pointee matches a given matcher.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int const *b;\n///   float const *f;\n/// \\endcode\n/// pointerType(pointee(isConstQualified(), isInteger()))\n///   matches \"int const *b\"\n///\n/// Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,\n///   Matcher<PointerType>, Matcher<ReferenceType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(\n    pointee, getPointee,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BlockPointerType, MemberPointerType,\n                                    PointerType, ReferenceType));\n\n/// Matches typedef types.\n///\n/// Given\n/// \\code\n///   typedef int X;\n/// \\endcode\n/// typedefType()\n///   matches \"typedef int X\"\nextern const AstTypeMatcher<TypedefType> typedefType;\n\n/// Matches enum types.\n///\n/// Given\n/// \\code\n///   enum C { Green };\n///   enum class S { Red };\n///\n///   C c;\n///   S s;\n/// \\endcode\n//\n/// \\c enumType() matches the type of the variable declarations of both \\c c and\n/// \\c s.\nextern const AstTypeMatcher<EnumType> enumType;\n\n/// Matches template specialization types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { };\n///\n///   template class C<int>;  // A\n///   C<char> var;            // B\n/// \\endcode\n///\n/// \\c templateSpecializationType() matches the type of the explicit\n/// instantiation in \\c A and the type of the variable declaration in \\c B.\nextern const AstTypeMatcher<TemplateSpecializationType>\n    templateSpecializationType;\n\n/// Matches C++17 deduced template specialization types, e.g. deduced class\n/// template types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { public: C(T); };\n///\n///   C c(123);\n/// \\endcode\n/// \\c deducedTemplateSpecializationType() matches the type in the declaration\n/// of the variable \\c c.\nextern const AstTypeMatcher<DeducedTemplateSpecializationType>\n    deducedTemplateSpecializationType;\n\n/// Matches types nodes representing unary type transformations.\n///\n/// Given:\n/// \\code\n///   typedef __underlying_type(T) type;\n/// \\endcode\n/// unaryTransformType()\n///   matches \"__underlying_type(T)\"\nextern const AstTypeMatcher<UnaryTransformType> unaryTransformType;\n\n/// Matches record types (e.g. structs, classes).\n///\n/// Given\n/// \\code\n///   class C {};\n///   struct S {};\n///\n///   C c;\n///   S s;\n/// \\endcode\n///\n/// \\c recordType() matches the type of the variable declarations of both \\c c\n/// and \\c s.\nextern const AstTypeMatcher<RecordType> recordType;\n\n/// Matches tag types (record and enum types).\n///\n/// Given\n/// \\code\n///   enum E {};\n///   class C {};\n///\n///   E e;\n///   C c;\n/// \\endcode\n///\n/// \\c tagType() matches the type of the variable declarations of both \\c e\n/// and \\c c.\nextern const AstTypeMatcher<TagType> tagType;\n\n/// Matches types specified with an elaborated type keyword or with a\n/// qualified name.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   class C {};\n///\n///   class C c;\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType() matches the type of the variable declarations of both\n/// \\c c and \\c d.\nextern const AstTypeMatcher<ElaboratedType> elaboratedType;\n\n/// Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,\n/// matches \\c InnerMatcher if the qualifier exists.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(\"N\"))))\n/// matches the type of the variable declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, hasQualifier,\n              internal::Matcher<NestedNameSpecifier>, InnerMatcher) {\n  if (const NestedNameSpecifier *Qualifier = Node.getQualifier())\n    return InnerMatcher.matches(*Qualifier, Finder, Builder);\n\n  return false;\n}\n\n/// Matches ElaboratedTypes whose named type matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(namesType(recordType(\n/// hasDeclaration(namedDecl(hasName(\"D\")))))) matches the type of the variable\n/// declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, namesType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getNamedType(), Finder, Builder);\n}\n\n/// Matches types specified through a using declaration.\n///\n/// Given\n/// \\code\n///   namespace a { struct S {}; }\n///   using a::S;\n///   S s;\n/// \\endcode\n///\n/// \\c usingType() matches the type of the variable declaration of \\c s.\nextern const AstTypeMatcher<UsingType> usingType;\n\n/// Matches types that represent the result of substituting a type for a\n/// template type parameter.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   void F(T t) {\n///     int i = 1 + t;\n///   }\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType() matches the type of 't' but not '1'\nextern const AstTypeMatcher<SubstTemplateTypeParmType>\n    substTemplateTypeParmType;\n\n/// Matches template type parameter substitutions that have a replacement\n/// type that matches the provided matcher.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   double F(T t);\n///   int i;\n///   double j = F(i);\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType(hasReplacementType(type())) matches int\nAST_TYPE_TRAVERSE_MATCHER(\n    hasReplacementType, getReplacementType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(SubstTemplateTypeParmType));\n\n/// Matches template type parameter types.\n///\n/// Example matches T, but not int.\n///     (matcher = templateTypeParmType())\n/// \\code\n///   template <typename T> void f(int i);\n/// \\endcode\nextern const AstTypeMatcher<TemplateTypeParmType> templateTypeParmType;\n\n/// Matches injected class name types.\n///\n/// Example matches S s, but not S<T> s.\n///     (matcher = parmVarDecl(hasType(injectedClassNameType())))\n/// \\code\n///   template <typename T> struct S {\n///     void f(S s);\n///     void g(S<T> s);\n///   };\n/// \\endcode\nextern const AstTypeMatcher<InjectedClassNameType> injectedClassNameType;\n\n/// Matches decayed type\n/// Example matches i[] in declaration of f.\n///     (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType())))))\n/// Example matches i[1].\n///     (matcher = expr(hasType(decayedType(hasDecayedType(pointerType())))))\n/// \\code\n///   void f(int i[]) {\n///     i[1] = 0;\n///   }\n/// \\endcode\nextern const AstTypeMatcher<DecayedType> decayedType;\n\n/// Matches the decayed type, whoes decayed type matches \\c InnerMatcher\nAST_MATCHER_P(DecayedType, hasDecayedType, internal::Matcher<QualType>,\n              InnerType) {\n  return InnerType.matches(Node.getDecayedType(), Finder, Builder);\n}\n\n/// Matches declarations whose declaration context, interpreted as a\n/// Decl, matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n/// \\endcode\n///\n/// \\c cxxRcordDecl(hasDeclContext(namedDecl(hasName(\"M\")))) matches the\n/// declaration of \\c class \\c D.\nAST_MATCHER_P(Decl, hasDeclContext, internal::Matcher<Decl>, InnerMatcher) {\n  const DeclContext *DC = Node.getDeclContext();\n  if (!DC) return false;\n  return InnerMatcher.matches(*Decl::castFromDeclContext(DC), Finder, Builder);\n}\n\n/// Matches nested name specifiers.\n///\n/// Given\n/// \\code\n///   namespace ns {\n///     struct A { static void f(); };\n///     void A::f() {}\n///     void g() { A::f(); }\n///   }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier()\n///   matches \"ns::\" and both \"A::\"\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifier>\n    nestedNameSpecifier;\n\n/// Same as \\c nestedNameSpecifier but matches \\c NestedNameSpecifierLoc.\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifierLoc>\n    nestedNameSpecifierLoc;\n\n/// Matches \\c NestedNameSpecifierLocs for which the given inner\n/// NestedNameSpecifier-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(\n    internal::BindableMatcher<NestedNameSpecifierLoc>, loc,\n    internal::Matcher<NestedNameSpecifier>, InnerMatcher, 1) {\n  return internal::BindableMatcher<NestedNameSpecifierLoc>(\n      new internal::LocMatcher<NestedNameSpecifierLoc, NestedNameSpecifier>(\n          InnerMatcher));\n}\n\n/// Matches nested name specifiers that specify a type matching the\n/// given \\c QualType matcher without qualifiers.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(specifiesType(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))\n/// ))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (!Node.getAsType())\n    return false;\n  return InnerMatcher.matches(QualType(Node.getAsType(), 0), Finder, Builder);\n}\n\n/// Matches nested name specifier locs that specify a type matching the\n/// given \\c TypeLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))))))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifierLoc, specifiesTypeLoc,\n              internal::Matcher<TypeLoc>, InnerMatcher) {\n  return Node && Node.getNestedNameSpecifier()->getAsType() &&\n         InnerMatcher.matches(Node.getTypeLoc(), Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifier.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(hasPrefix(specifiesType(asString(\"struct A\")))) and\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifier, hasPrefix,\n                       internal::Matcher<NestedNameSpecifier>, InnerMatcher,\n                       0) {\n  const NestedNameSpecifier *NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(*NextNode, Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifierLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(\"struct A\")))))\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifierLoc, hasPrefix,\n                       internal::Matcher<NestedNameSpecifierLoc>, InnerMatcher,\n                       1) {\n  NestedNameSpecifierLoc NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(NextNode, Finder, Builder);\n}\n\n/// Matches nested name specifiers that specify a namespace matching the\n/// given namespace matcher.\n///\n/// Given\n/// \\code\n///   namespace ns { struct A {}; }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier(specifiesNamespace(hasName(\"ns\")))\n///   matches \"ns::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesNamespace,\n              internal::Matcher<NamespaceDecl>, InnerMatcher) {\n  if (!Node.getAsNamespace())\n    return false;\n  return InnerMatcher.matches(*Node.getAsNamespace(), Finder, Builder);\n}\n\n/// Matches attributes.\n/// Attributes may be attached with a variety of different syntaxes (including\n/// keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,\n/// and ``#pragma``s). They may also be implicit.\n///\n/// Given\n/// \\code\n///   struct [[nodiscard]] Foo{};\n///   void bar(int * __attribute__((nonnull)) );\n///   __declspec(noinline) void baz();\n///\n///   #pragma omp declare simd\n///   int min();\n/// \\endcode\n/// attr()\n///   matches \"nodiscard\", \"nonnull\", \"noinline\", and the whole \"#pragma\" line.\nextern const internal::VariadicAllOfMatcher<Attr> attr;\n\n/// Overloads for the \\c equalsNode matcher.\n/// FIXME: Implement for other node types.\n/// @{\n\n/// Matches if a node equals another node.\n///\n/// \\c Decl has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Decl, equalsNode, const Decl*, Other, 0) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Stmt has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Stmt, equalsNode, const Stmt*, Other, 1) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Type has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Type, equalsNode, const Type*, Other, 2) {\n    return &Node == Other;\n}\n\n/// @}\n\n/// Matches each case or default statement belonging to the given switch\n/// statement. This matcher may produce multiple matches.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }\n/// \\endcode\n/// switchStmt(forEachSwitchCase(caseStmt().bind(\"c\"))).bind(\"s\")\n///   matches four times, with \"c\" binding each of \"case 1:\", \"case 2:\",\n/// \"case 3:\" and \"case 4:\", and \"s\" respectively binding \"switch (1)\",\n/// \"switch (1)\", \"switch (2)\" and \"switch (2)\".\nAST_MATCHER_P(SwitchStmt, forEachSwitchCase, internal::Matcher<SwitchCase>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  // FIXME: getSwitchCaseList() does not necessarily guarantee a stable\n  // iteration order. We should use the more general iterating matchers once\n  // they are capable of expressing this matcher (for example, it should ignore\n  // case statements belonging to nested switch statements).\n  bool Matched = false;\n  for (const SwitchCase *SC = Node.getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    BoundNodesTreeBuilder CaseBuilder(*Builder);\n    bool CaseMatched = InnerMatcher.matches(*SC, Finder, &CaseBuilder);\n    if (CaseMatched) {\n      Matched = true;\n      Result.addMatch(CaseBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches each constructor initializer in a constructor definition.\n///\n/// Given\n/// \\code\n///   class A { A() : i(42), j(42) {} int i; int j; };\n/// \\endcode\n/// cxxConstructorDecl(forEachConstructorInitializer(\n///   forField(decl().bind(\"x\"))\n/// ))\n///   will trigger two matches, binding for 'i' and 'j' respectively.\nAST_MATCHER_P(CXXConstructorDecl, forEachConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *I : Node.inits()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() && !I->isWritten())\n      continue;\n    BoundNodesTreeBuilder InitBuilder(*Builder);\n    if (InnerMatcher.matches(*I, Finder, &InitBuilder)) {\n      Matched = true;\n      Result.addMatch(InitBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches constructor declarations that are copy constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3.\nAST_MATCHER(CXXConstructorDecl, isCopyConstructor) {\n  return Node.isCopyConstructor();\n}\n\n/// Matches constructor declarations that are move constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isMoveConstructor) {\n  return Node.isMoveConstructor();\n}\n\n/// Matches constructor declarations that are default constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXConstructorDecl, isDefaultConstructor) {\n  return Node.isDefaultConstructor();\n}\n\n/// Matches constructors that delegate to another constructor.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(int) {} // #2\n///     S(S &&) : S() {} // #3\n///   };\n///   S::S() : S(0) {} // #4\n/// \\endcode\n/// cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not\n/// #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isDelegatingConstructor) {\n  return Node.isDelegatingConstructor();\n}\n\n/// Matches constructor, conversion function, and deduction guide declarations\n/// that have an explicit specifier if this explicit specifier is resolved to\n/// true.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.\n/// cxxConversionDecl(isExplicit()) will match #4, but not #3.\n/// cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5.\nAST_POLYMORPHIC_MATCHER(isExplicit, AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                        CXXConstructorDecl, CXXConversionDecl,\n                                        CXXDeductionGuideDecl)) {\n  return Node.isExplicit();\n}\n\n/// Matches the expression in an explicit specifier if present in the given\n/// declaration.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.\n/// cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.\n/// cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6.\nAST_MATCHER_P(FunctionDecl, hasExplicitSpecifier, internal::Matcher<Expr>,\n              InnerMatcher) {\n  ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(&Node);\n  if (!ES.getExpr())\n    return false;\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  return InnerMatcher.matches(*ES.getExpr(), Finder, Builder);\n}\n\n/// Matches functions, variables and namespace declarations that are marked with\n/// the inline keyword.\n///\n/// Given\n/// \\code\n///   inline void f();\n///   void g();\n///   namespace n {\n///   inline namespace m {}\n///   }\n///   inline int Foo = 5;\n/// \\endcode\n/// functionDecl(isInline()) will match ::f().\n/// namespaceDecl(isInline()) will match n::m.\n/// varDecl(isInline()) will match Foo;\nAST_POLYMORPHIC_MATCHER(isInline, AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,\n                                                                  FunctionDecl,\n                                                                  VarDecl)) {\n  // This is required because the spelling of the function used to determine\n  // whether inline is specified or not differs between the polymorphic types.\n  if (const auto *FD = dyn_cast<FunctionDecl>(&Node))\n    return FD->isInlineSpecified();\n  if (const auto *NSD = dyn_cast<NamespaceDecl>(&Node))\n    return NSD->isInline();\n  if (const auto *VD = dyn_cast<VarDecl>(&Node))\n    return VD->isInline();\n  llvm_unreachable(\"Not a valid polymorphic type\");\n}\n\n/// Matches anonymous namespace declarations.\n///\n/// Given\n/// \\code\n///   namespace n {\n///   namespace {} // #1\n///   }\n/// \\endcode\n/// namespaceDecl(isAnonymous()) will match #1 but not ::n.\nAST_MATCHER(NamespaceDecl, isAnonymous) {\n  return Node.isAnonymousNamespace();\n}\n\n/// Matches declarations in the namespace `std`, but not in nested namespaces.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace std {\n///       class vector {};\n///     }\n///   }\n///   namespace std {\n///     inline namespace __1 {\n///       class vector {}; // #1\n///       namespace experimental {\n///         class vector {};\n///       }\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInStdNamespace()) will match only #1.\nAST_MATCHER(Decl, isInStdNamespace) { return Node.isInStdNamespace(); }\n\n/// Matches declarations in an anonymous namespace.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace {\n///       class vector {}; // #1\n///     }\n///   }\n///   namespace {\n///     class vector {}; // #2\n///     namespace foo {\n///       class vector{}; // #3\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInAnonymousNamespace()) will match\n/// #1, #2 and #3.\nAST_MATCHER(Decl, isInAnonymousNamespace) {\n  return Node.isInAnonymousNamespace();\n}\n\n/// If the given case statement does not use the GNU case range\n/// extension, matches the constant given in the statement.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }\n/// \\endcode\n/// caseStmt(hasCaseConstant(integerLiteral()))\n///   matches \"case 1:\"\nAST_MATCHER_P(CaseStmt, hasCaseConstant, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (Node.getRHS())\n    return false;\n\n  return InnerMatcher.matches(*Node.getLHS(), Finder, Builder);\n}\n\n/// Matches declaration that has a given attribute.\n///\n/// Given\n/// \\code\n///   __attribute__((device)) void f() { ... }\n/// \\endcode\n/// decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of\n/// f. If the matcher is used from clang-query, attr::Kind parameter should be\n/// passed as a quoted string. e.g., hasAttr(\"attr::CUDADevice\").\nAST_MATCHER_P(Decl, hasAttr, attr::Kind, AttrKind) {\n  for (const auto *Attr : Node.attrs()) {\n    if (Attr->getKind() == AttrKind)\n      return true;\n  }\n  return false;\n}\n\n/// Matches the return value expression of a return statement\n///\n/// Given\n/// \\code\n///   return a + b;\n/// \\endcode\n/// hasReturnValue(binaryOperator())\n///   matches 'return a + b'\n/// with binaryOperator()\n///   matching 'a + b'\nAST_MATCHER_P(ReturnStmt, hasReturnValue, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (const auto *RetValue = Node.getRetValue())\n    return InnerMatcher.matches(*RetValue, Finder, Builder);\n  return false;\n}\n\n/// Matches CUDA kernel call expression.\n///\n/// Example matches,\n/// \\code\n///   kernel<<<i,j>>>();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CUDAKernelCallExpr>\n    cudaKernelCallExpr;\n\n/// Matches expressions that resolve to a null pointer constant, such as\n/// GNU's __null, C++11's nullptr, or C's NULL macro.\n///\n/// Given:\n/// \\code\n///   void *v1 = NULL;\n///   void *v2 = nullptr;\n///   void *v3 = __null; // GNU extension\n///   char *cp = (char *)0;\n///   int *ip = 0;\n///   int i = 0;\n/// \\endcode\n/// expr(nullPointerConstant())\n///   matches the initializer for v1, v2, v3, cp, and ip. Does not match the\n///   initializer for i.\nAST_MATCHER_FUNCTION(internal::Matcher<Expr>, nullPointerConstant) {\n  return anyOf(\n      gnuNullExpr(), cxxNullPtrLiteralExpr(),\n      integerLiteral(equals(0), hasParent(expr(hasType(pointerType())))));\n}\n\n/// Matches the DecompositionDecl the binding belongs to.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   bindingDecl(hasName(\"f\"),\n///                 forDecomposition(decompositionDecl())\n/// \\endcode\n/// matches 'f' in 'auto &[f, s, t]'.\nAST_MATCHER_P(BindingDecl, forDecomposition, internal::Matcher<ValueDecl>,\n              InnerMatcher) {\n  if (const ValueDecl *VD = Node.getDecomposedDecl())\n    return InnerMatcher.matches(*VD, Finder, Builder);\n  return false;\n}\n\n/// Matches the Nth binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasBinding(0,\n///   bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P2(DecompositionDecl, hasBinding, unsigned, N,\n               internal::Matcher<BindingDecl>, InnerMatcher) {\n  if (Node.bindings().size() <= N)\n    return false;\n  return InnerMatcher.matches(*Node.bindings()[N], Finder, Builder);\n}\n\n/// Matches any binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasAnyBinding(bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P(DecompositionDecl, hasAnyBinding, internal::Matcher<BindingDecl>,\n              InnerMatcher) {\n  return llvm::any_of(Node.bindings(), [&](const auto *Binding) {\n    return InnerMatcher.matches(*Binding, Finder, Builder);\n  });\n}\n\n/// Matches declaration of the function the statement belongs to.\n///\n/// Deprecated. Use forCallable() to correctly handle the situation when\n/// the declaration is not a function (but a block or an Objective-C method).\n/// forFunction() not only fails to take non-functions into account but also\n/// may match the wrong declaration in their presence.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forFunction(hasName(\"operator=\")))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\nAST_MATCHER_P(Stmt, forFunction, internal::Matcher<FunctionDecl>,\n              InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches declaration of the function, method, or block the statement\n/// belongs to.\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forCallable(functionDecl(hasName(\"operator=\"))))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\n///\n/// Given:\n/// \\code\n/// -(void) foo {\n///   int x = 1;\n///   dispatch_sync(queue, ^{ int y = 2; });\n/// }\n/// \\endcode\n/// declStmt(forCallable(objcMethodDecl()))\n///   matches 'int x = 1'\n///   but does not match 'int y = 2'.\n/// whereas declStmt(forCallable(blockDecl()))\n///   matches 'int y = 2'\n///   but does not match 'int x = 1'.\nAST_MATCHER_P(Stmt, forCallable, internal::Matcher<Decl>, InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while (!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if (const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if (InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if (InnerMatcher.matches(*LambdaExprNode->getCallOperator(), Finder,\n                               Builder)) {\n        return true;\n      }\n    } else if (const auto *ObjCMethodDeclNode = CurNode.get<ObjCMethodDecl>()) {\n      if (InnerMatcher.matches(*ObjCMethodDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if (const auto *BlockDeclNode = CurNode.get<BlockDecl>()) {\n      if (InnerMatcher.matches(*BlockDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else {\n      llvm::append_range(Stack, Finder->getASTContext().getParents(CurNode));\n    }\n  }\n  return false;\n}\n\n/// Matches a declaration that has external formal linkage.\n///\n/// Example matches only z (matcher = varDecl(hasExternalFormalLinkage()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\n///\n/// Example matches f() because it has external formal linkage despite being\n/// unique to the translation unit as though it has internal likage\n/// (matcher = functionDecl(hasExternalFormalLinkage()))\n///\n/// \\code\n/// namespace {\n/// void f() {}\n/// }\n/// \\endcode\nAST_MATCHER(NamedDecl, hasExternalFormalLinkage) {\n  return Node.hasExternalFormalLinkage();\n}\n\n/// Matches a declaration that has default arguments.\n///\n/// Example matches y (matcher = parmVarDecl(hasDefaultArgument()))\n/// \\code\n/// void x(int val) {}\n/// void y(int val = 0) {}\n/// \\endcode\n///\n/// Deprecated. Use hasInitializer() instead to be able to\n/// match on the contents of the default argument.  For example:\n///\n/// \\code\n/// void x(int val = 7) {}\n/// void y(int val = 42) {}\n/// \\endcode\n/// parmVarDecl(hasInitializer(integerLiteral(equals(42))))\n///   matches the parameter of y\n///\n/// A matcher such as\n///   parmVarDecl(hasInitializer(anything()))\n/// is equivalent to parmVarDecl(hasDefaultArgument()).\nAST_MATCHER(ParmVarDecl, hasDefaultArgument) {\n  return Node.hasDefaultArg();\n}\n\n/// Matches array new expressions.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(isArray())\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER(CXXNewExpr, isArray) {\n  return Node.isArray();\n}\n\n/// Matches placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage, 16) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16))))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,\n               internal::Matcher<Expr>, InnerMatcher) {\n  return Node.getNumPlacementArgs() > Index &&\n         InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder);\n}\n\n/// Matches any placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasAnyPlacementArg(anything()))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return llvm::any_of(Node.placement_arguments(), [&](const Expr *Arg) {\n    return InnerMatcher.matches(*Arg, Finder, Builder);\n  });\n}\n\n/// Matches array new expressions with a given array size.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(hasArraySize(integerLiteral(equals(10))))\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher<Expr>, InnerMatcher) {\n  return Node.isArray() && *Node.getArraySize() &&\n         InnerMatcher.matches(**Node.getArraySize(), Finder, Builder);\n}\n\n/// Matches a class declaration that is defined.\n///\n/// Example matches x (matcher = cxxRecordDecl(hasDefinition()))\n/// \\code\n/// class x {};\n/// class y;\n/// \\endcode\nAST_MATCHER(CXXRecordDecl, hasDefinition) {\n  return Node.hasDefinition();\n}\n\n/// Matches C++11 scoped enum declaration.\n///\n/// Example matches Y (matcher = enumDecl(isScoped()))\n/// \\code\n/// enum X {};\n/// enum class Y {};\n/// \\endcode\nAST_MATCHER(EnumDecl, isScoped) {\n  return Node.isScoped();\n}\n\n/// Matches a function declared with a trailing return type.\n///\n/// Example matches Y (matcher = functionDecl(hasTrailingReturn()))\n/// \\code\n/// int X() {}\n/// auto Y() -> int {}\n/// \\endcode\nAST_MATCHER(FunctionDecl, hasTrailingReturn) {\n  if (const auto *F = Node.getType()->getAs<FunctionProtoType>())\n    return F->hasTrailingReturn();\n  return false;\n}\n\n/// Matches expressions that match InnerMatcher that are possibly wrapped in an\n/// elidable constructor and other corresponding bookkeeping nodes.\n///\n/// In C++17, elidable copy constructors are no longer being generated in the\n/// AST as it is not permitted by the standard. They are, however, part of the\n/// AST in C++14 and earlier. So, a matcher must abstract over these differences\n/// to work in all language modes. This matcher skips elidable constructor-call\n/// AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and\n/// various implicit nodes inside the constructor calls, all of which will not\n/// appear in the C++17 AST.\n///\n/// Given\n///\n/// \\code\n/// struct H {};\n/// H G();\n/// void f() {\n///   H D = G();\n/// }\n/// \\endcode\n///\n/// ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``\n/// matches ``H D = G()`` in C++11 through C++17 (and beyond).\nAST_MATCHER_P(Expr, ignoringElidableConstructorCall,\n              ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  // E tracks the node that we are examining.\n  const Expr *E = &Node;\n  // If present, remove an outer `ExprWithCleanups` corresponding to the\n  // underlying `CXXConstructExpr`. This check won't cover all cases of added\n  // `ExprWithCleanups` corresponding to `CXXConstructExpr` nodes (because the\n  // EWC is placed on the outermost node of the expression, which this may not\n  // be), but, it still improves the coverage of this matcher.\n  if (const auto *CleanupsExpr = dyn_cast<ExprWithCleanups>(&Node))\n    E = CleanupsExpr->getSubExpr();\n  if (const auto *CtorExpr = dyn_cast<CXXConstructExpr>(E)) {\n    if (CtorExpr->isElidable()) {\n      if (const auto *MaterializeTemp =\n              dyn_cast<MaterializeTemporaryExpr>(CtorExpr->getArg(0))) {\n        return InnerMatcher.matches(*MaterializeTemp->getSubExpr(), Finder,\n                                    Builder);\n      }\n    }\n  }\n  return InnerMatcher.matches(Node, Finder, Builder);\n}\n\n//----------------------------------------------------------------------------//\n// OpenMP handling.\n//----------------------------------------------------------------------------//\n\n/// Matches any ``#pragma omp`` executable directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective()`` matches ``omp parallel``,\n/// ``omp parallel default(none)`` and ``omp taskyield``.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OMPExecutableDirective>\n    ompExecutableDirective;\n\n/// Matches standalone OpenMP directives,\n/// i.e., directives that can't have a structured block.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   {}\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective(isStandaloneDirective()))`` matches\n/// ``omp taskyield``.\nAST_MATCHER(OMPExecutableDirective, isStandaloneDirective) {\n  return Node.isStandaloneDirective();\n}\n\n/// Matches the structured-block of the OpenMP executable directive\n///\n/// Prerequisite: the executable directive must not be standalone directive.\n/// If it is, it will never match.\n///\n/// Given\n///\n/// \\code\n///    #pragma omp parallel\n///    ;\n///    #pragma omp parallel\n///    {}\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``\nAST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  if (Node.isStandaloneDirective())\n    return false; // Standalone directives have no structured blocks.\n  return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder);\n}\n\n/// Matches any clause in an OpenMP directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasAnyClause(anything()))`` matches\n/// ``omp parallel default(none)``.\nAST_MATCHER_P(OMPExecutableDirective, hasAnyClause,\n              internal::Matcher<OMPClause>, InnerMatcher) {\n  ArrayRef<OMPClause *> Clauses = Node.clauses();\n  return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(),\n                                    Clauses.end(), Finder,\n                                    Builder) != Clauses.end();\n}\n\n/// Matches OpenMP ``default`` clause.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n///   #pragma omp parallel\n/// \\endcode\n///\n/// ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,\n/// `` default(private)`` and ``default(firstprivate)``\nextern const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>\n    ompDefaultClause;\n\n/// Matches if the OpenMP ``default`` clause has ``none`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isNoneKind())`` matches only ``default(none)``.\nAST_MATCHER(OMPDefaultClause, isNoneKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``shared`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isSharedKind())`` matches only ``default(shared)``.\nAST_MATCHER(OMPDefaultClause, isSharedKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``private`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isPrivateKind())`` matches only\n/// ``default(private)``.\nAST_MATCHER(OMPDefaultClause, isPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_private;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``firstprivate`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isFirstPrivateKind())`` matches only\n/// ``default(firstprivate)``.\nAST_MATCHER(OMPDefaultClause, isFirstPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate;\n}\n\n/// Matches if the OpenMP directive is allowed to contain the specified OpenMP\n/// clause kind.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel for\n///   #pragma omp          for\n/// \\endcode\n///\n/// `ompExecutableDirective(isAllowedToContainClause(OMPC_default))`` matches\n/// ``omp parallel`` and ``omp parallel for``.\n///\n/// If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter\n/// should be passed as a quoted string. e.g.,\n/// ``isAllowedToContainClauseKind(\"OMPC_default\").``\nAST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,\n              OpenMPClauseKind, CKind) {\n  return llvm::omp::isAllowedClauseForDirective(\n      Node.getDirectiveKind(), CKind,\n      Finder->getASTContext().getLangOpts().OpenMP);\n}\n\n//----------------------------------------------------------------------------//\n// End OpenMP handling.\n//----------------------------------------------------------------------------//\n\n}",
  "id": "BLOCK-CPP-15019",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchers.h",
  "source_line": 6118,
  "validation_status": "validated"
}