{
  "code": "{\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\n///\n/// Example matches f() because it has external formal linkage despite being\n/// unique to the translation unit as though it has internal likage\n/// (matcher = functionDecl(hasExternalFormalLinkage()))\n///\n/// \\code\n/// namespace {\n/// void f() {}\n/// }\n/// \\endcode\nAST_MATCHER(NamedDecl, hasExternalFormalLinkage) {\n  return Node.hasExternalFormalLinkage();\n}\n\n/// Matches a declaration that has default arguments.\n///\n/// Example matches y (matcher = parmVarDecl(hasDefaultArgument()))\n/// \\code\n/// void x(int val) {}\n/// void y(int val = 0) {}\n/// \\endcode\n///\n/// Deprecated. Use hasInitializer() instead to be able to\n/// match on the contents of the default argument.  For example:\n///\n/// \\code\n/// void x(int val = 7) {}\n/// void y(int val = 42) {}\n/// \\endcode\n/// parmVarDecl(hasInitializer(integerLiteral(equals(42))))\n///   matches the parameter of y\n///\n/// A matcher such as\n///   parmVarDecl(hasInitializer(anything()))\n/// is equivalent to parmVarDecl(hasDefaultArgument()).\nAST_MATCHER(ParmVarDecl, hasDefaultArgument) {\n  return Node.hasDefaultArg();\n}\n\n/// Matches array new expressions.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(isArray())\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER(CXXNewExpr, isArray) {\n  return Node.isArray();\n}\n\n/// Matches placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage, 16) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16))))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,\n               internal::Matcher<Expr>, InnerMatcher) {\n  return Node.getNumPlacementArgs() > Index &&\n         InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder);\n}\n\n/// Matches any placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasAnyPlacementArg(anything()))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return llvm::any_of(Node.placement_arguments(), [&](const Expr *Arg) {\n    return InnerMatcher.matches(*Arg, Finder, Builder);\n  });\n}\n\n/// Matches array new expressions with a given array size.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(hasArraySize(integerLiteral(equals(10))))\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher<Expr>, InnerMatcher) {\n  return Node.isArray() && *Node.getArraySize() &&\n         InnerMatcher.matches(**Node.getArraySize(), Finder, Builder);\n}\n\n/// Matches a class declaration that is defined.\n///\n/// Example matches x (matcher = cxxRecordDecl(hasDefinition()))\n/// \\code\n/// class x {};\n/// class y;\n/// \\endcode\nAST_MATCHER(CXXRecordDecl, hasDefinition) {\n  return Node.hasDefinition();\n}\n\n/// Matches C++11 scoped enum declaration.\n///\n/// Example matches Y (matcher = enumDecl(isScoped()))\n/// \\code\n/// enum X {};\n/// enum class Y {};\n/// \\endcode\nAST_MATCHER(EnumDecl, isScoped) {\n  return Node.isScoped();\n}\n\n/// Matches a function declared with a trailing return type.\n///\n/// Example matches Y (matcher = functionDecl(hasTrailingReturn()))\n/// \\code\n/// int X() {}\n/// auto Y() -> int {}\n/// \\endcode\nAST_MATCHER(FunctionDecl, hasTrailingReturn) {\n  if (const auto *F = Node.getType()->getAs<FunctionProtoType>())\n    return F->hasTrailingReturn();\n  return false;\n}\n\n/// Matches expressions that match InnerMatcher that are possibly wrapped in an\n/// elidable constructor and other corresponding bookkeeping nodes.\n///\n/// In C++17, elidable copy constructors are no longer being generated in the\n/// AST as it is not permitted by the standard. They are, however, part of the\n/// AST in C++14 and earlier. So, a matcher must abstract over these differences\n/// to work in all language modes. This matcher skips elidable constructor-call\n/// AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and\n/// various implicit nodes inside the constructor calls, all of which will not\n/// appear in the C++17 AST.\n///\n/// Given\n///\n/// \\code\n/// struct H {};\n/// H G();\n/// void f() {\n///   H D = G();\n/// }\n/// \\endcode\n///\n/// ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``\n/// matches ``H D = G()`` in C++11 through C++17 (and beyond).\nAST_MATCHER_P(Expr, ignoringElidableConstructorCall,\n              ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  // E tracks the node that we are examining.\n  const Expr *E = &Node;\n  // If present, remove an outer `ExprWithCleanups` corresponding to the\n  // underlying `CXXConstructExpr`. This check won't cover all cases of added\n  // `ExprWithCleanups` corresponding to `CXXConstructExpr` nodes (because the\n  // EWC is placed on the outermost node of the expression, which this may not\n  // be), but, it still improves the coverage of this matcher.\n  if (const auto *CleanupsExpr = dyn_cast<ExprWithCleanups>(&Node))\n    E = CleanupsExpr->getSubExpr();\n  if (const auto *CtorExpr = dyn_cast<CXXConstructExpr>(E)) {\n    if (CtorExpr->isElidable()) {\n      if (const auto *MaterializeTemp =\n              dyn_cast<MaterializeTemporaryExpr>(CtorExpr->getArg(0))) {\n        return InnerMatcher.matches(*MaterializeTemp->getSubExpr(), Finder,\n                                    Builder);\n      }\n    }\n  }\n  return InnerMatcher.matches(Node, Finder, Builder);\n}\n\n//----------------------------------------------------------------------------//\n// OpenMP handling.\n//----------------------------------------------------------------------------//\n\n/// Matches any ``#pragma omp`` executable directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective()`` matches ``omp parallel``,\n/// ``omp parallel default(none)`` and ``omp taskyield``.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OMPExecutableDirective>\n    ompExecutableDirective;\n\n/// Matches standalone OpenMP directives,\n/// i.e., directives that can't have a structured block.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   {}\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective(isStandaloneDirective()))`` matches\n/// ``omp taskyield``.\nAST_MATCHER(OMPExecutableDirective, isStandaloneDirective) {\n  return Node.isStandaloneDirective();\n}\n\n/// Matches the structured-block of the OpenMP executable directive\n///\n/// Prerequisite: the executable directive must not be standalone directive.\n/// If it is, it will never match.\n///\n/// Given\n///\n/// \\code\n///    #pragma omp parallel\n///    ;\n///    #pragma omp parallel\n///    {}\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``\nAST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  if (Node.isStandaloneDirective())\n    return false; // Standalone directives have no structured blocks.\n  return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder);\n}\n\n/// Matches any clause in an OpenMP directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasAnyClause(anything()))`` matches\n/// ``omp parallel default(none)``.\nAST_MATCHER_P(OMPExecutableDirective, hasAnyClause,\n              internal::Matcher<OMPClause>, InnerMatcher) {\n  ArrayRef<OMPClause *> Clauses = Node.clauses();\n  return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(),\n                                    Clauses.end(), Finder,\n                                    Builder) != Clauses.end();\n}\n\n/// Matches OpenMP ``default`` clause.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n///   #pragma omp parallel\n/// \\endcode\n///\n/// ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,\n/// `` default(private)`` and ``default(firstprivate)``\nextern const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>\n    ompDefaultClause;\n\n/// Matches if the OpenMP ``default`` clause has ``none`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isNoneKind())`` matches only ``default(none)``.\nAST_MATCHER(OMPDefaultClause, isNoneKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``shared`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isSharedKind())`` matches only ``default(shared)``.\nAST_MATCHER(OMPDefaultClause, isSharedKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``private`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isPrivateKind())`` matches only\n/// ``default(private)``.\nAST_MATCHER(OMPDefaultClause, isPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_private;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``firstprivate`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(private)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isFirstPrivateKind())`` matches only\n/// ``default(firstprivate)``.\nAST_MATCHER(OMPDefaultClause, isFirstPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate;\n}\n\n/// Matches if the OpenMP directive is allowed to contain the specified OpenMP\n/// clause kind.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel for\n///   #pragma omp          for\n/// \\endcode\n///\n/// `ompExecutableDirective(isAllowedToContainClause(OMPC_default))`` matches\n/// ``omp parallel`` and ``omp parallel for``.\n///\n/// If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter\n/// should be passed as a quoted string. e.g.,\n/// ``isAllowedToContainClauseKind(\"OMPC_default\").``\nAST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,\n              OpenMPClauseKind, CKind) {\n  return llvm::omp::isAllowedClauseForDirective(\n      Node.getDirectiveKind(), CKind,\n      Finder->getASTContext().getLangOpts().OpenMP);\n}\n\n//----------------------------------------------------------------------------//\n// End OpenMP handling.\n//----------------------------------------------------------------------------//\n\n}",
  "id": "BLOCK-CPP-14876",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/ASTMatchers/ASTMatchers.h",
  "source_line": 8183,
  "validation_status": "validated"
}