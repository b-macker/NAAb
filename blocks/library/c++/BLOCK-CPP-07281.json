{
  "code": "{\npublic:\n  /// Creates a \\c DynTypedNode from \\c Node.\n  template <typename T>\n  static DynTypedNode create(const T &Node) {\n    return BaseConverter<T>::create(Node);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Returns NULL if the stored node does not have a type that is\n  /// convertible to \\c T.\n  ///\n  /// For types that have identity via their pointer in the AST\n  /// (like \\c Stmt, \\c Decl, \\c Type and \\c NestedNameSpecifier) the returned\n  /// pointer points to the referenced AST node.\n  /// For other types (like \\c QualType) the value is stored directly\n  /// in the \\c DynTypedNode, and the returned pointer points at\n  /// the storage inside DynTypedNode. For those nodes, do not\n  /// use the pointer outside the scope of the DynTypedNode.\n  template <typename T> const T *get() const {\n    return BaseConverter<T>::get(NodeKind, &Storage);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Similar to \\c get(), but asserts that the type is what we are expecting.\n  template <typename T>\n  const T &getUnchecked() const {\n    return BaseConverter<T>::getUnchecked(NodeKind, &Storage);\n  }\n\n  ASTNodeKind getNodeKind() const { return NodeKind; }\n\n  /// Returns a pointer that identifies the stored AST node.\n  ///\n  /// Note that this is not supported by all AST nodes. For AST nodes\n  /// that don't have a pointer-defined identity inside the AST, this\n  /// method returns NULL.\n  const void *getMemoizationData() const {\n    return NodeKind.hasPointerIdentity()\n               ? *reinterpret_cast<void *const *>(&Storage)\n               : nullptr;\n  }\n\n  /// Prints the node to the given output stream.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &PP) const;\n\n  /// Dumps the node to the given output stream.\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  /// For nodes which represent textual entities in the source code,\n  /// return their SourceRange.  For all other nodes, return SourceRange().\n  SourceRange getSourceRange() const;\n\n  /// @{\n  /// Imposes an order on \\c DynTypedNode.\n  ///\n  /// Supports comparison of nodes that support memoization.\n  /// FIXME: Implement comparison for other node types (currently\n  /// only Stmt, Decl, Type and NestedNameSpecifier return memoization data).\n  bool operator<(const DynTypedNode &Other) const {\n    if (!NodeKind.isSame(Other.NodeKind))\n      return NodeKind < Other.NodeKind;\n\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>().getAsOpaquePtr() <\n             Other.getUnchecked<QualType>().getAsOpaquePtr();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isBaseOf(NodeKind)) {\n      auto TLA = getUnchecked<TypeLoc>();\n      auto TLB = Other.getUnchecked<TypeLoc>();\n      return std::make_pair(TLA.getType().getAsOpaquePtr(),\n                            TLA.getOpaqueData()) <\n             std::make_pair(TLB.getType().getAsOpaquePtr(),\n                            TLB.getOpaqueData());\n    }\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n            NodeKind)) {\n      auto NNSLA = getUnchecked<NestedNameSpecifierLoc>();\n      auto NNSLB = Other.getUnchecked<NestedNameSpecifierLoc>();\n      return std::make_pair(NNSLA.getNestedNameSpecifier(),\n                            NNSLA.getOpaqueData()) <\n             std::make_pair(NNSLB.getNestedNameSpecifier(),\n                            NNSLB.getOpaqueData());\n    }\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() < Other.getMemoizationData();\n  }\n  bool operator==(const DynTypedNode &Other) const {\n    // DynTypedNode::create() stores the exact kind of the node in NodeKind.\n    // If they contain the same node, their NodeKind must be the same.\n    if (!NodeKind.isSame(Other.NodeKind))\n      return false;\n\n    // FIXME: Implement for other types.\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>() == Other.getUnchecked<QualType>();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isBaseOf(NodeKind))\n      return getUnchecked<TypeLoc>() == Other.getUnchecked<TypeLoc>();\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(NodeKind))\n      return getUnchecked<NestedNameSpecifierLoc>() ==\n             Other.getUnchecked<NestedNameSpecifierLoc>();\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() == Other.getMemoizationData();\n  }\n  bool operator!=(const DynTypedNode &Other) const {\n    return !operator==(Other);\n  }\n  /// @}\n\n  /// Hooks for using DynTypedNode as a key in a DenseMap.\n  struct DenseMapInfo {\n    static inline DynTypedNode getEmptyKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      return Node;\n    }\n    static inline DynTypedNode getTombstoneKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return Node;\n    }\n    static unsigned getHashValue(const DynTypedNode &Val) {\n      // FIXME: Add hashing support for the remaining types.\n      if (ASTNodeKind::getFromNodeKind<TypeLoc>().isBaseOf(Val.NodeKind)) {\n        auto TL = Val.getUnchecked<TypeLoc>();\n        return llvm::hash_combine(TL.getType().getAsOpaquePtr(),\n                                  TL.getOpaqueData());\n      }\n\n      if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n              Val.NodeKind)) {\n        auto NNSL = Val.getUnchecked<NestedNameSpecifierLoc>();\n        return llvm::hash_combine(NNSL.getNestedNameSpecifier(),\n                                  NNSL.getOpaqueData());\n      }\n\n      assert(Val.getMemoizationData());\n      return llvm::hash_value(Val.getMemoizationData());\n    }\n    static bool isEqual(const DynTypedNode &LHS, const DynTypedNode &RHS) {\n      auto Empty = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      auto TombStone = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, Empty) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, Empty)) ||\n             (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, TombStone) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, TombStone)) ||\n             LHS == RHS;\n    }\n  };\n\nprivate:\n  /// Takes care of converting from and to \\c T.\n  template <typename T, typename EnablerT = void> struct BaseConverter;\n\n  /// Converter that uses dyn_cast<T> from a stored BaseT*.\n  template <typename T, typename BaseT> struct DynCastPtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind));\n      return *cast<T>(static_cast<const BaseT *>(\n          *reinterpret_cast<const void *const *>(Storage)));\n    }\n    static DynTypedNode create(const BaseT &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNode(Node);\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T* (by pointer).\n  template <typename T> struct PtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *static_cast<const T *>(\n          *reinterpret_cast<const void *const *>(Storage));\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T (by value).\n  template <typename T> struct ValueConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return reinterpret_cast<const T *>(Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *reinterpret_cast<const T *>(Storage);\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) T(Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores nodes by value. It must be possible to dynamically\n  /// cast the stored node within a type hierarchy without breaking (especially\n  /// through slicing).\n  template <typename T, typename BaseT,\n            typename = std::enable_if_t<(sizeof(T) == sizeof(BaseT))>>\n  struct DynCastValueConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind));\n      return *static_cast<const T *>(reinterpret_cast<const BaseT *>(Storage));\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNode(Node);\n      new (&Result.Storage) T(Node);\n      return Result;\n    }\n  };\n\n  ASTNodeKind NodeKind;\n\n  /// Stores the data of the node.\n  ///\n  /// Note that we can store \\c Decls, \\c Stmts, \\c Types,\n  /// \\c NestedNameSpecifiers and \\c CXXCtorInitializer by pointer as they are\n  /// guaranteed to be unique pointers pointing to dedicated storage in the AST.\n  /// \\c QualTypes, \\c NestedNameSpecifierLocs, \\c TypeLocs,\n  /// \\c TemplateArguments and \\c TemplateArgumentLocs on the other hand do not\n  /// have storage or unique pointers and thus need to be stored by value.\n  llvm::AlignedCharArrayUnion<const void *, TemplateArgument,\n                              TemplateArgumentLoc, NestedNameSpecifierLoc,\n                              QualType, TypeLoc, ObjCProtocolLoc>\n      Storage;\n}",
  "id": "BLOCK-CPP-07281",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ASTTypeTraits.h",
  "source_line": 255,
  "validation_status": "validated"
}