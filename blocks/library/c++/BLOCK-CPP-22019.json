{
  "code": "#include <optional>\n#include <utility>\n#include <vector>\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/FlowSensitive/ControlFlowContext.h\"\n#include \"clang/Analysis/FlowSensitive/DataflowAnalysisContext.h\"\n#include \"clang/Analysis/FlowSensitive/DataflowEnvironment.h\"\n#include \"clang/Analysis/FlowSensitive/DataflowLattice.h\"\n#include \"llvm/ADT/Any.h\"\n#include \"llvm/Support/Error.h\"\n\nusing namespace clang;\nusing namespace dataflow;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-22019_execute() {\n    {\n\nstruct DataflowAnalysisOptions {\n  /// Options for the built-in model, or empty to not apply them.\n  // FIXME: Remove this option once the framework supports composing analyses\n  // (at which point the built-in transfer functions can be simply a standalone\n  // analysis).\n  std::optional<DataflowAnalysisContext::Options> BuiltinOpts =\n      DataflowAnalysisContext::Options{};\n};\n\n/// Type-erased lattice element container.\n///\n/// Requirements:\n///\n///  The type of the object stored in the container must be a bounded\n///  join-semilattice.\nstruct TypeErasedLattice {\n  llvm::Any Value;\n};\n\n/// Type-erased base class for dataflow analyses built on a single lattice type.\nclass TypeErasedDataflowAnalysis : public Environment::ValueModel {\n  DataflowAnalysisOptions Options;\n\npublic:\n  TypeErasedDataflowAnalysis() : Options({}) {}\n\n  TypeErasedDataflowAnalysis(DataflowAnalysisOptions Options)\n      : Options(Options) {}\n\n  virtual ~TypeErasedDataflowAnalysis() {}\n\n  /// Returns the `ASTContext` that is used by the analysis.\n  virtual ASTContext &getASTContext() = 0;\n\n  /// Returns a type-erased lattice element that models the initial state of a\n  /// basic block.\n  virtual TypeErasedLattice typeErasedInitialElement() = 0;\n\n  /// Joins two type-erased lattice elements by computing their least upper\n  /// bound. Places the join result in the left element and returns an effect\n  /// indicating whether any changes were made to it.\n  virtual TypeErasedLattice joinTypeErased(const TypeErasedLattice &,\n                                           const TypeErasedLattice &) = 0;\n\n  /// Chooses a lattice element that approximates the current element at a\n  /// program point, given the previous element at that point. Places the\n  /// widened result in the current element (`Current`). Widening is optional --\n  /// it is only needed to either accelerate convergence (for lattices with\n  /// non-trivial height) or guarantee convergence (for lattices with infinite\n  /// height).\n  ///\n  /// Returns an indication of whether any changes were made to `Current` in\n  /// order to widen. This saves a separate call to `isEqualTypeErased` after\n  /// the widening.\n  virtual LatticeJoinEffect\n  widenTypeErased(TypeErasedLattice &Current,\n                  const TypeErasedLattice &Previous) = 0;\n\n  /// Returns true if and only if the two given type-erased lattice elements are\n  /// equal.\n  virtual bool isEqualTypeErased(const TypeErasedLattice &,\n                                 const TypeErasedLattice &) = 0;\n\n  /// Applies the analysis transfer function for a given control flow graph\n  /// element and type-erased lattice element.\n  virtual void transferTypeErased(const CFGElement &, TypeErasedLattice &,\n                                  Environment &) = 0;\n\n  /// Applies the analysis transfer function for a given edge from a CFG block\n  /// of a conditional statement.\n  /// @param Stmt The condition which is responsible for the split in the CFG.\n  /// @param Branch True if the edge goes to the basic block where the\n  /// condition is true.\n  // FIXME: Change `Stmt` argument to a reference.\n  virtual void transferBranchTypeErased(bool Branch, const Stmt *,\n                                        TypeErasedLattice &, Environment &) = 0;\n\n  /// If the built-in model is enabled, returns the options to be passed to\n  /// them. Otherwise returns empty.\n  const std::optional<DataflowAnalysisContext::Options> &\n  builtinOptions() const {\n    return Options.BuiltinOpts;\n  }\n};\n\n/// Type-erased model of the program at a given program point.\nstruct TypeErasedDataflowAnalysisState {\n  /// Type-erased model of a program property.\n  TypeErasedLattice Lattice;\n\n  /// Model of the state of the program (store and heap).\n  Environment Env;\n\n  TypeErasedDataflowAnalysisState(TypeErasedLattice Lattice, Environment Env)\n      : Lattice(std::move(Lattice)), Env(std::move(Env)) {}\n\n  TypeErasedDataflowAnalysisState fork() const {\n    return TypeErasedDataflowAnalysisState(Lattice, Env.fork());\n  }\n};\n\n/// Transfers the state of a basic block by evaluating each of its elements in\n/// the context of `Analysis` and the states of its predecessors that are\n/// available in `BlockStates`. `PostVisitCFG` (if provided) will be applied to\n/// each element in the block, after it is evaluated.\n///\n/// Requirements:\n///\n///   All predecessors of `Block` except those with loop back edges must have\n///   already been transferred. States in `BlockStates` that are set to\n///   `std::nullopt` represent basic blocks that are not evaluated yet.\nTypeErasedDataflowAnalysisState transferBlock(\n    const ControlFlowContext &CFCtx,\n    llvm::ArrayRef<std::optional<TypeErasedDataflowAnalysisState>> BlockStates,\n    const CFGBlock &Block, const Environment &InitEnv,\n    TypeErasedDataflowAnalysis &Analysis,\n    std::function<void(const CFGElement &,\n                       const TypeErasedDataflowAnalysisState &)>\n        PostVisitCFG = nullptr);\n\n/// Performs dataflow analysis and returns a mapping from basic block IDs to\n/// dataflow analysis states that model the respective basic blocks. Indices of\n/// the returned vector correspond to basic block IDs. Returns an error if the\n/// dataflow analysis cannot be performed successfully. Otherwise, calls\n/// `PostVisitCFG` on each CFG element with the final analysis results at that\n/// program point.\nllvm::Expected<std::vector<std::optional<TypeErasedDataflowAnalysisState>>>\nrunTypeErasedDataflowAnalysis(\n    const ControlFlowContext &CFCtx, TypeErasedDataflowAnalysis &Analysis,\n    const Environment &InitEnv,\n    std::function<void(const CFGElement &,\n                       const TypeErasedDataflowAnalysisState &)>\n        PostVisitCFG = nullptr);\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-22019",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h",
  "source_line": 32,
  "validation_status": "validated"
}