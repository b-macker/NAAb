{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace cord_internal {\n\nnamespace {\n\nstruct Queue {\n  Queue() = default;\n\n  absl::Mutex mutex;\n  std::atomic<CordzHandle*> dq_tail ABSL_GUARDED_BY(mutex){nullptr};\n\n  // Returns true if this delete queue is empty. This method does not acquire\n  // the lock, but does a 'load acquire' observation on the delete queue tail.\n  // It is used inside Delete() to check for the presence of a delete queue\n  // without holding the lock. The assumption is that the caller is in the\n  // state of 'being deleted', and can not be newly discovered by a concurrent\n  // 'being constructed' snapshot instance. Practically, this means that any\n  // such discovery (`find`, 'first' or 'next', etc) must have proper 'happens\n  // before / after' semantics and atomic fences.\n  bool IsEmpty() const ABSL_NO_THREAD_SAFETY_ANALYSIS {\n    return dq_tail.load(std::memory_order_acquire) == nullptr;\n  }\n};\n\nstatic Queue* GlobalQueue() {\n  static Queue* global_queue = new Queue;\n  return global_queue;\n}\n\n}  // namespace\n\nCordzHandle::CordzHandle(bool is_snapshot) : is_snapshot_(is_snapshot) {\n  Queue* global_queue = GlobalQueue();\n  if (is_snapshot) {\n    MutexLock lock(&global_queue->mutex);\n    CordzHandle* dq_tail =\n        global_queue->dq_tail.load(std::memory_order_acquire);\n    if (dq_tail != nullptr) {\n      dq_prev_ = dq_tail;\n      dq_tail->dq_next_ = this;\n    }\n    global_queue->dq_tail.store(this, std::memory_order_release);\n  }\n}\n\nCordzHandle::~CordzHandle() {\n  Queue* global_queue = GlobalQueue();\n  if (is_snapshot_) {\n    std::vector<CordzHandle*> to_delete;\n    {\n      MutexLock lock(&global_queue->mutex);\n      CordzHandle* next = dq_next_;\n      if (dq_prev_ == nullptr) {\n        // We were head of the queue, delete every CordzHandle until we reach\n        // either the end of the list, or a snapshot handle.\n        while (next && !next->is_snapshot_) {\n          to_delete.push_back(next);\n          next = next->dq_next_;\n        }\n      } else {\n        // Another CordzHandle existed before this one, don't delete anything.\n        dq_prev_->dq_next_ = next;\n      }\n      if (next) {\n        next->dq_prev_ = dq_prev_;\n      } else {\n        global_queue->dq_tail.store(dq_prev_, std::memory_order_release);\n      }\n    }\n    for (CordzHandle* handle : to_delete) {\n      delete handle;\n    }\n  }\n}\n\nbool CordzHandle::SafeToDelete() const {\n  return is_snapshot_ || GlobalQueue()->IsEmpty();\n}\n\nvoid CordzHandle::Delete(CordzHandle* handle) {\n  assert(handle);\n  if (handle) {\n    Queue* const queue = GlobalQueue();\n    if (!handle->SafeToDelete()) {\n      MutexLock lock(&queue->mutex);\n      CordzHandle* dq_tail = queue->dq_tail.load(std::memory_order_acquire);\n      if (dq_tail != nullptr) {\n        handle->dq_prev_ = dq_tail;\n        dq_tail->dq_next_ = handle;\n        queue->dq_tail.store(handle, std::memory_order_release);\n        return;\n      }\n    }\n    delete handle;\n  }\n}\n\nstd::vector<const CordzHandle*> CordzHandle::DiagnosticsGetDeleteQueue() {\n  std::vector<const CordzHandle*> handles;\n  Queue* global_queue = GlobalQueue();\n  MutexLock lock(&global_queue->mutex);\n  CordzHandle* dq_tail = global_queue->dq_tail.load(std::memory_order_acquire);\n  for (const CordzHandle* p = dq_tail; p; p = p->dq_prev_) {\n    handles.push_back(p);\n  }\n  return handles;\n}\n\nbool CordzHandle::DiagnosticsHandleIsSafeToInspect(\n    const CordzHandle* handle) const {\n  if (!is_snapshot_) return false;\n  if (handle == nullptr) return true;\n  if (handle->is_snapshot_) return false;\n  bool snapshot_found = false;\n  Queue* global_queue = GlobalQueue();\n  MutexLock lock(&global_queue->mutex);\n  for (const CordzHandle* p = global_queue->dq_tail; p; p = p->dq_prev_) {\n    if (p == handle) return !snapshot_found;\n    if (p == this) snapshot_found = true;\n  }\n  ABSL_ASSERT(snapshot_found);  // Assert that 'this' is in delete queue.\n  return true;\n}\n\nstd::vector<const CordzHandle*>\nCordzHandle::DiagnosticsGetSafeToInspectDeletedHandles() {\n  std::vector<const CordzHandle*> handles;\n  if (!is_snapshot()) {\n    return handles;\n  }\n\n  Queue* global_queue = GlobalQueue();\n  MutexLock lock(&global_queue->mutex);\n  for (const CordzHandle* p = dq_next_; p != nullptr; p = p->dq_next_) {\n    if (!p->is_snapshot()) {\n      handles.push_back(p);\n    }\n  }\n  return handles;\n}\n\n}  // namespace cord_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02913",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_handle.cc",
  "source_line": 21,
  "validation_status": "validated"
}