{
  "code": "{\nnamespace details {\nnamespace fmt_helper {\n\ninline void append_string_view(spdlog::string_view_t view, memory_buf_t &dest) {\n    auto *buf_ptr = view.data();\n    dest.append(buf_ptr, buf_ptr + view.size());\n}\n\n#ifdef SPDLOG_USE_STD_FORMAT\ntemplate <typename T>\ninline void append_int(T n, memory_buf_t &dest) {\n    // Buffer should be large enough to hold all digits (digits10 + 1) and a sign\n    SPDLOG_CONSTEXPR const auto BUF_SIZE = std::numeric_limits<T>::digits10 + 2;\n    char buf[BUF_SIZE];\n\n    auto [ptr, ec] = std::to_chars(buf, buf + BUF_SIZE, n, 10);\n    if (ec == std::errc()) {\n        dest.append(buf, ptr);\n    } else {\n        throw_spdlog_ex(\"Failed to format int\", static_cast<int>(ec));\n    }\n}\n#else\ntemplate <typename T>\ninline void append_int(T n, memory_buf_t &dest) {\n    fmt::format_int i(n);\n    dest.append(i.data(), i.data() + i.size());\n}\n#endif\n\ntemplate <typename T>\nSPDLOG_CONSTEXPR_FUNC unsigned int count_digits_fallback(T n) {\n    // taken from fmt: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/format.h#L899-L912\n    unsigned int count = 1;\n    for (;;) {\n        // Integer division is slow so do it for a group of four digits instead\n        // of for every digit. The idea comes from the talk by Alexandrescu\n        // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n        if (n < 10) return count;\n        if (n < 100) return count + 1;\n        if (n < 1000) return count + 2;\n        if (n < 10000) return count + 3;\n        n /= 10000u;\n        count += 4;\n    }\n}\n\ntemplate <typename T>\ninline unsigned int count_digits(T n) {\n    using count_type =\n        typename std::conditional<(sizeof(T) > sizeof(uint32_t)), uint64_t, uint32_t>::type;\n#ifdef SPDLOG_USE_STD_FORMAT\n    return count_digits_fallback(static_cast<count_type>(n));\n#else\n    return static_cast<unsigned int>(fmt::\n    // fmt 7.0.0 renamed the internal namespace to detail.\n    // See: https://github.com/fmtlib/fmt/issues/1538\n    #if FMT_VERSION < 70000\n                                         internal\n    #else\n                                         detail\n    #endif\n                                     ::count_digits(static_cast<count_type>(n)));\n#endif\n}\n\ninline void pad2(int n, memory_buf_t &dest) {\n    if (n >= 0 && n < 100)  // 0-99\n    {\n        dest.push_back(static_cast<char>('0' + n / 10));\n        dest.push_back(static_cast<char>('0' + n % 10));\n    } else  // unlikely, but just in case, let fmt deal with it\n    {\n        fmt_lib::format_to(std::back_inserter(dest), SPDLOG_FMT_STRING(\"{:02}\"), n);\n    }\n}\n\ntemplate <typename T>\ninline void pad_uint(T n, unsigned int width, memory_buf_t &dest) {\n    static_assert(std::is_unsigned<T>::value, \"pad_uint must get unsigned T\");\n    for (auto digits = count_digits(n); digits < width; digits++) {\n        dest.push_back('0');\n    }\n    append_int(n, dest);\n}\n\ntemplate <typename T>\ninline void pad3(T n, memory_buf_t &dest) {\n    static_assert(std::is_unsigned<T>::value, \"pad3 must get unsigned T\");\n    if (n < 1000) {\n        dest.push_back(static_cast<char>(n / 100 + '0'));\n        n = n % 100;\n        dest.push_back(static_cast<char>((n / 10) + '0'));\n        dest.push_back(static_cast<char>((n % 10) + '0'));\n    } else {\n        append_int(n, dest);\n    }\n}\n\ntemplate <typename T>\ninline void pad6(T n, memory_buf_t &dest) {\n    pad_uint(n, 6, dest);\n}\n\ntemplate <typename T>\ninline void pad9(T n, memory_buf_t &dest) {\n    pad_uint(n, 9, dest);\n}\n\n// return fraction of a second of the given time_point.\n// e.g.\n// fraction<std::milliseconds>(tp) -> will return the millis part of the second\ntemplate <typename ToDuration>\ninline ToDuration time_fraction(log_clock::time_point tp) {\n    using std::chrono::duration_cast;\n    using std::chrono::seconds;\n    auto duration = tp.time_since_epoch();\n    auto secs = duration_cast<seconds>(duration);\n    return duration_cast<ToDuration>(duration) - duration_cast<ToDuration>(secs);\n}\n\n}  // namespace fmt_helper\n}  // namespace details\n}",
  "id": "BLOCK-CPP-00230",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/spdlog/include/spdlog/details/fmt_helper.h",
  "source_line": 17,
  "validation_status": "validated"
}