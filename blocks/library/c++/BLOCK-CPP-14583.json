{
  "code": "{\n\n#define DISPATCH(CLASS) \\\n  return static_cast<ImplClass*>(this)-> \\\n           Visit##CLASS(static_cast<const CLASS*>(T))\n\n/// An operation on a type.\n///\n/// \\tparam ImplClass Class implementing the operation. Must be inherited from\n///         TypeVisitor.\n/// \\tparam RetTy %Type of result produced by the operation.\n///\n/// The class implements polymorphic operation on an object of type derived\n/// from Type. The operation is performed by calling method Visit. It then\n/// dispatches the call to function \\c VisitFooType, if actual argument type\n/// is \\c FooType.\n///\n/// The class implements static polymorphism using Curiously Recurring\n/// Template Pattern. It is designed to be a base class for some concrete\n/// class:\n///\n/// \\code\n///     class SomeVisitor : public TypeVisitor<SomeVisitor,sometype> { ... };\n///     ...\n///     Type *atype = ...\n///     ...\n///     SomeVisitor avisitor;\n///     sometype result = avisitor.Visit(atype);\n/// \\endcode\n///\n/// Actual treatment is made by methods of the derived class, TypeVisitor only\n/// dispatches call to the appropriate method. If the implementation class\n/// \\c ImplClass provides specific action for some type, say\n/// \\c ConstantArrayType, it should define method\n/// <tt>VisitConstantArrayType(const ConstantArrayType*)</tt>. Otherwise\n/// \\c TypeVisitor dispatches call to the method that handles parent type. In\n/// this example handlers are tried in the sequence:\n///\n/// \\li <tt>ImplClass::VisitConstantArrayType(const ConstantArrayType*)</tt>\n/// \\li <tt>ImplClass::VisitArrayType(const ArrayType*)</tt>\n/// \\li <tt>ImplClass::VisitType(const Type*)</tt>\n/// \\li <tt>TypeVisitor::VisitType(const Type*)</tt>\n///\n/// The first function of this sequence that is defined will handle object of\n/// type \\c ConstantArrayType.\ntemplate<typename ImplClass, typename RetTy=void>\nclass TypeVisitor {\npublic:\n\n  /// Performs the operation associated with this visitor object.\n  RetTy Visit(const Type *T) {\n    // Top switch stmt: dispatch to VisitFooType for each FooType.\n    switch (T->getTypeClass()) {\n#define ABSTRACT_TYPE(CLASS, PARENT)\n#define TYPE(CLASS, PARENT) case Type::CLASS: DISPATCH(CLASS##Type);\n#include \"clang/AST/TypeNodes.inc\"\n    }\n    llvm_unreachable(\"Unknown type class!\");\n  }\n\n  // If the implementation chooses not to implement a certain visit method, fall\n  // back on superclass.\n#define TYPE(CLASS, PARENT) RetTy Visit##CLASS##Type(const CLASS##Type *T) { \\\n  DISPATCH(PARENT);                                                          \\\n}\n#include \"clang/AST/TypeNodes.inc\"\n\n  /// Method called if \\c ImpClass doesn't provide specific handler\n  /// for some type class.\n  RetTy VisitType(const Type*) { return RetTy(); }\n};\n\n#undef DISPATCH\n\n}",
  "id": "BLOCK-CPP-14583",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TypeVisitor.h",
  "source_line": 18,
  "validation_status": "validated"
}