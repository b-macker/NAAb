{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// -----------------------------------------------------------------------------\n// `absl::Hash`\n// -----------------------------------------------------------------------------\n//\n// `absl::Hash<T>` is a convenient general-purpose hash functor for any type `T`\n// satisfying any of the following conditions (in order):\n//\n//  * T is an arithmetic or pointer type\n//  * T defines an overload for `AbslHashValue(H, const T&)` for an arbitrary\n//    hash state `H`.\n//  - T defines a specialization of `std::hash<T>`\n//\n// `absl::Hash` intrinsically supports the following types:\n//\n//   * All integral types (including bool)\n//   * All enum types\n//   * All floating-point types (although hashing them is discouraged)\n//   * All pointer types, including nullptr_t\n//   * std::pair<T1, T2>, if T1 and T2 are hashable\n//   * std::tuple<Ts...>, if all the Ts... are hashable\n//   * std::unique_ptr and std::shared_ptr\n//   * All string-like types including:\n//     * absl::Cord\n//     * std::string (as well as any instance of std::basic_string that\n//       uses one of {char, wchar_t, char16_t, char32_t} and its associated\n//       std::char_traits)\n//     * std::string_view (as well as any instance of std::basic_string_view\n//       that uses one of {char, wchar_t, char16_t, char32_t} and its associated\n//       std::char_traits)\n//  * All the standard sequence containers (provided the elements are hashable)\n//  * All the standard associative containers (provided the elements are\n//    hashable)\n//  * absl types such as the following:\n//    * absl::string_view\n//    * absl::uint128\n//    * absl::Time, absl::Duration, and absl::TimeZone\n//  * absl containers (provided the elements are hashable) such as the\n//    following:\n//    * absl::flat_hash_set, absl::node_hash_set, absl::btree_set\n//    * absl::flat_hash_map, absl::node_hash_map, absl::btree_map\n//    * absl::btree_multiset, absl::btree_multimap\n//    * absl::InlinedVector\n//    * absl::FixedArray\n//\n// When absl::Hash is used to hash an unordered container with a custom hash\n// functor, the elements are hashed using default absl::Hash semantics, not\n// the custom hash functor.  This is consistent with the behavior of\n// operator==() on unordered containers, which compares elements pairwise with\n// operator==() rather than the custom equality functor.  It is usually a\n// mistake to use either operator==() or absl::Hash on unordered collections\n// that use functors incompatible with operator==() equality.\n//\n// Note: the list above is not meant to be exhaustive. Additional type support\n// may be added, in which case the above list will be updated.\n//\n// -----------------------------------------------------------------------------\n// absl::Hash Invocation Evaluation\n// -----------------------------------------------------------------------------\n//\n// When invoked, `absl::Hash<T>` searches for supplied hash functions in the\n// following order:\n//\n//   * Natively supported types out of the box (see above)\n//   * Types for which an `AbslHashValue()` overload is provided (such as\n//     user-defined types). See \"Adding Type Support to `absl::Hash`\" below.\n//   * Types which define a `std::hash<T>` specialization\n//\n// The fallback to legacy hash functions exists mainly for backwards\n// compatibility. If you have a choice, prefer defining an `AbslHashValue`\n// overload instead of specializing any legacy hash functors.\n//\n// -----------------------------------------------------------------------------\n// The Hash State Concept, and using `HashState` for Type Erasure\n// -----------------------------------------------------------------------------\n//\n// The `absl::Hash` framework relies on the Concept of a \"hash state.\" Such a\n// hash state is used in several places:\n//\n// * Within existing implementations of `absl::Hash<T>` to store the hashed\n//   state of an object. Note that it is up to the implementation how it stores\n//   such state. A hash table, for example, may mix the state to produce an\n//   integer value; a testing framework may simply hold a vector of that state.\n// * Within implementations of `AbslHashValue()` used to extend user-defined\n//   types. (See \"Adding Type Support to absl::Hash\" below.)\n// * Inside a `HashState`, providing type erasure for the concept of a hash\n//   state, which you can use to extend the `absl::Hash` framework for types\n//   that are otherwise difficult to extend using `AbslHashValue()`. (See the\n//   `HashState` class below.)\n//\n// The \"hash state\" concept contains three member functions for mixing hash\n// state:\n//\n// * `H::combine(state, values...)`\n//\n//   Combines an arbitrary number of values into a hash state, returning the\n//   updated state. Note that the existing hash state is move-only and must be\n//   passed by value.\n//\n//   Each of the value types T must be hashable by H.\n//\n//   NOTE:\n//\n//     state = H::combine(std::move(state), value1, value2, value3);\n//\n//   must be guaranteed to produce the same hash expansion as\n//\n//     state = H::combine(std::move(state), value1);\n//     state = H::combine(std::move(state), value2);\n//     state = H::combine(std::move(state), value3);\n//\n// * `H::combine_contiguous(state, data, size)`\n//\n//    Combines a contiguous array of `size` elements into a hash state,\n//    returning the updated state. Note that the existing hash state is\n//    move-only and must be passed by value.\n//\n//    NOTE:\n//\n//      state = H::combine_contiguous(std::move(state), data, size);\n//\n//    need NOT be guaranteed to produce the same hash expansion as a loop\n//    (it may perform internal optimizations). If you need this guarantee, use a\n//    loop instead.\n//\n// * `H::combine_unordered(state, begin, end)`\n//\n//    Combines a set of elements denoted by an iterator pair into a hash\n//    state, returning the updated state.  Note that the existing hash\n//    state is move-only and must be passed by value.\n//\n//    Unlike the other two methods, the hashing is order-independent.\n//    This can be used to hash unordered collections.\n//\n// -----------------------------------------------------------------------------\n// Adding Type Support to `absl::Hash`\n// -----------------------------------------------------------------------------\n//\n// To add support for your user-defined type, add a proper `AbslHashValue()`\n// overload as a free (non-member) function. The overload will take an\n// existing hash state and should combine that state with state from the type.\n//\n// Example:\n//\n//   template <typename H>\n//   H AbslHashValue(H state, const MyType& v) {\n//     return H::combine(std::move(state), v.field1, ..., v.fieldN);\n//   }\n//\n// where `(field1, ..., fieldN)` are the members you would use on your\n// `operator==` to define equality.\n//\n// Notice that `AbslHashValue` is not a class member, but an ordinary function.\n// An `AbslHashValue` overload for a type should only be declared in the same\n// file and namespace as said type. The proper `AbslHashValue` implementation\n// for a given type will be discovered via ADL.\n//\n// Note: unlike `std::hash', `absl::Hash` should never be specialized. It must\n// only be extended by adding `AbslHashValue()` overloads.\n//\ntemplate <typename T>\nusing Hash = absl::hash_internal::Hash<T>;\n\n// HashOf\n//\n// absl::HashOf() is a helper that generates a hash from the values of its\n// arguments.  It dispatches to absl::Hash directly, as follows:\n//  * HashOf(t) == absl::Hash<T>{}(t)\n//  * HashOf(a, b, c) == HashOf(std::make_tuple(a, b, c))\n//\n// HashOf(a1, a2, ...) == HashOf(b1, b2, ...) is guaranteed when\n//  * The argument lists have pairwise identical C++ types\n//  * a1 == b1 && a2 == b2 && ...\n//\n// The requirement that the arguments match in both type and value is critical.\n// It means that `a == b` does not necessarily imply `HashOf(a) == HashOf(b)` if\n// `a` and `b` have different types. For example, `HashOf(2) != HashOf(2.0)`.\ntemplate <int&... ExplicitArgumentBarrier, typename... Types>\nsize_t HashOf(const Types&... values) {\n  auto tuple = std::tie(values...);\n  return absl::Hash<decltype(tuple)>{}(tuple);\n}\n\n// HashState\n//\n// A type erased version of the hash state concept, for use in user-defined\n// `AbslHashValue` implementations that can't use templates (such as PImpl\n// classes, virtual functions, etc.). The type erasure adds overhead so it\n// should be avoided unless necessary.\n//\n// Note: This wrapper will only erase calls to\n//     combine_contiguous(H, const unsigned char*, size_t)\n//     RunCombineUnordered(H, CombinerF)\n//\n// All other calls will be handled internally and will not invoke overloads\n// provided by the wrapped class.\n//\n// Users of this class should still define a template `AbslHashValue` function,\n// but can use `absl::HashState::Create(&state)` to erase the type of the hash\n// state and dispatch to their private hashing logic.\n//\n// This state can be used like any other hash state. In particular, you can call\n// `HashState::combine()` and `HashState::combine_contiguous()` on it.\n//\n// Example:\n//\n//   class Interface {\n//    public:\n//     template <typename H>\n//     friend H AbslHashValue(H state, const Interface& value) {\n//       state = H::combine(std::move(state), std::type_index(typeid(*this)));\n//       value.HashValue(absl::HashState::Create(&state));\n//       return state;\n//     }\n//    private:\n//     virtual void HashValue(absl::HashState state) const = 0;\n//   };\n//\n//   class Impl : Interface {\n//    private:\n//     void HashValue(absl::HashState state) const override {\n//       absl::HashState::combine(std::move(state), v1_, v2_);\n//     }\n//     int v1_;\n//     std::string v2_;\n//   };\nclass HashState : public hash_internal::HashStateBase<HashState> {\n public:\n  // HashState::Create()\n  //\n  // Create a new `HashState` instance that wraps `state`. All calls to\n  // `combine()` and `combine_contiguous()` on the new instance will be\n  // redirected to the original `state` object. The `state` object must outlive\n  // the `HashState` instance.\n  template <typename T>\n  static HashState Create(T* state) {\n    HashState s;\n    s.Init(state);\n    return s;\n  }\n\n  HashState(const HashState&) = delete;\n  HashState& operator=(const HashState&) = delete;\n  HashState(HashState&&) = default;\n  HashState& operator=(HashState&&) = default;\n\n  // HashState::combine()\n  //\n  // Combines an arbitrary number of values into a hash state, returning the\n  // updated state.\n  using HashState::HashStateBase::combine;\n\n  // HashState::combine_contiguous()\n  //\n  // Combines a contiguous array of `size` elements into a hash state, returning\n  // the updated state.\n  static HashState combine_contiguous(HashState hash_state,\n                                      const unsigned char* first, size_t size) {\n    hash_state.combine_contiguous_(hash_state.state_, first, size);\n    return hash_state;\n  }\n  using HashState::HashStateBase::combine_contiguous;\n\n private:\n  HashState() = default;\n\n  friend class HashState::HashStateBase;\n\n  template <typename T>\n  static void CombineContiguousImpl(void* p, const unsigned char* first,\n                                    size_t size) {\n    T& state = *static_cast<T*>(p);\n    state = T::combine_contiguous(std::move(state), first, size);\n  }\n\n  template <typename T>\n  void Init(T* state) {\n    state_ = state;\n    combine_contiguous_ = &CombineContiguousImpl<T>;\n    run_combine_unordered_ = &RunCombineUnorderedImpl<T>;\n  }\n\n  template <typename HS>\n  struct CombineUnorderedInvoker {\n    template <typename T, typename ConsumerT>\n    void operator()(T inner_state, ConsumerT inner_cb) {\n      f(HashState::Create(&inner_state),\n        [&](HashState& inner_erased) { inner_cb(inner_erased.Real<T>()); });\n    }\n\n    absl::FunctionRef<void(HS, absl::FunctionRef<void(HS&)>)> f;\n  };\n\n  template <typename T>\n  static HashState RunCombineUnorderedImpl(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>\n          f) {\n    // Note that this implementation assumes that inner_state and outer_state\n    // are the same type.  This isn't true in the SpyHash case, but SpyHash\n    // types are move-convertible to each other, so this still works.\n    T& real_state = state.Real<T>();\n    real_state = T::RunCombineUnordered(\n        std::move(real_state), CombineUnorderedInvoker<HashState>{f});\n    return state;\n  }\n\n  template <typename CombinerT>\n  static HashState RunCombineUnordered(HashState state, CombinerT combiner) {\n    auto* run = state.run_combine_unordered_;\n    return run(std::move(state), std::ref(combiner));\n  }\n\n  // Do not erase an already erased state.\n  void Init(HashState* state) {\n    state_ = state->state_;\n    combine_contiguous_ = state->combine_contiguous_;\n    run_combine_unordered_ = state->run_combine_unordered_;\n  }\n\n  template <typename T>\n  T& Real() {\n    return *static_cast<T*>(state_);\n  }\n\n  void* state_;\n  void (*combine_contiguous_)(void*, const unsigned char*, size_t);\n  HashState (*run_combine_unordered_)(\n      HashState state,\n      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>);\n};\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03650",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/hash/hash.h",
  "source_line": 87,
  "validation_status": "validated"
}