{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace container_internal {\ntemplate <typename T>\nstruct NodeHashSetPolicy;\n}  // namespace container_internal\n\n// -----------------------------------------------------------------------------\n// absl::node_hash_set\n// -----------------------------------------------------------------------------\n//\n// An `absl::node_hash_set<T>` is an unordered associative container which\n// has been optimized for both speed and memory footprint in most common use\n// cases. Its interface is similar to that of `std::unordered_set<T>` with the\n// following notable differences:\n//\n// * Supports heterogeneous lookup, through `find()`, `operator[]()` and\n//   `insert()`, provided that the set is provided a compatible heterogeneous\n//   hashing function and equality operator.\n// * Contains a `capacity()` member function indicating the number of element\n//   slots (open, deleted, and empty) within the hash set.\n// * Returns `void` from the `erase(iterator)` overload.\n//\n// By default, `node_hash_set` uses the `absl::Hash` hashing framework.\n// All fundamental and Abseil types that support the `absl::Hash` framework have\n// a compatible equality operator for comparing insertions into `node_hash_set`.\n// If your type is not yet supported by the `absl::Hash` framework, see\n// absl/hash/hash.h for information on extending Abseil hashing to user-defined\n// types.\n//\n// Using `absl::node_hash_set` at interface boundaries in dynamically loaded\n// libraries (e.g. .dll, .so) is unsupported due to way `absl::Hash` values may\n// be randomized across dynamically loaded libraries.\n//\n// Example:\n//\n//   // Create a node hash set of three strings\n//   absl::node_hash_set<std::string> ducks =\n//     {\"huey\", \"dewey\", \"louie\"};\n//\n//  // Insert a new element into the node hash set\n//  ducks.insert(\"donald\");\n//\n//  // Force a rehash of the node hash set\n//  ducks.rehash(0);\n//\n//  // See if \"dewey\" is present\n//  if (ducks.contains(\"dewey\")) {\n//    std::cout << \"We found dewey!\" << std::endl;\n//  }\ntemplate <class T, class Hash = absl::container_internal::hash_default_hash<T>,\n          class Eq = absl::container_internal::hash_default_eq<T>,\n          class Alloc = std::allocator<T>>\nclass node_hash_set\n    : public absl::container_internal::raw_hash_set<\n          absl::container_internal::NodeHashSetPolicy<T>, Hash, Eq, Alloc> {\n  using Base = typename node_hash_set::raw_hash_set;\n\n public:\n  // Constructors and Assignment Operators\n  //\n  // A node_hash_set supports the same overload set as `std::unordered_set`\n  // for construction and assignment:\n  //\n  // *  Default constructor\n  //\n  //    // No allocation for the table's elements is made.\n  //    absl::node_hash_set<std::string> set1;\n  //\n  // * Initializer List constructor\n  //\n  //   absl::node_hash_set<std::string> set2 =\n  //       {{\"huey\"}, {\"dewey\"}, {\"louie\"}};\n  //\n  // * Copy constructor\n  //\n  //   absl::node_hash_set<std::string> set3(set2);\n  //\n  // * Copy assignment operator\n  //\n  //  // Hash functor and Comparator are copied as well\n  //  absl::node_hash_set<std::string> set4;\n  //  set4 = set3;\n  //\n  // * Move constructor\n  //\n  //   // Move is guaranteed efficient\n  //   absl::node_hash_set<std::string> set5(std::move(set4));\n  //\n  // * Move assignment operator\n  //\n  //   // May be efficient if allocators are compatible\n  //   absl::node_hash_set<std::string> set6;\n  //   set6 = std::move(set5);\n  //\n  // * Range constructor\n  //\n  //   std::vector<std::string> v = {\"a\", \"b\"};\n  //   absl::node_hash_set<std::string> set7(v.begin(), v.end());\n  node_hash_set() {}\n  using Base::Base;\n\n  // node_hash_set::begin()\n  //\n  // Returns an iterator to the beginning of the `node_hash_set`.\n  using Base::begin;\n\n  // node_hash_set::cbegin()\n  //\n  // Returns a const iterator to the beginning of the `node_hash_set`.\n  using Base::cbegin;\n\n  // node_hash_set::cend()\n  //\n  // Returns a const iterator to the end of the `node_hash_set`.\n  using Base::cend;\n\n  // node_hash_set::end()\n  //\n  // Returns an iterator to the end of the `node_hash_set`.\n  using Base::end;\n\n  // node_hash_set::capacity()\n  //\n  // Returns the number of element slots (assigned, deleted, and empty)\n  // available within the `node_hash_set`.\n  //\n  // NOTE: this member function is particular to `absl::node_hash_set` and is\n  // not provided in the `std::unordered_set` API.\n  using Base::capacity;\n\n  // node_hash_set::empty()\n  //\n  // Returns whether or not the `node_hash_set` is empty.\n  using Base::empty;\n\n  // node_hash_set::max_size()\n  //\n  // Returns the largest theoretical possible number of elements within a\n  // `node_hash_set` under current memory constraints. This value can be thought\n  // of the largest value of `std::distance(begin(), end())` for a\n  // `node_hash_set<T>`.\n  using Base::max_size;\n\n  // node_hash_set::size()\n  //\n  // Returns the number of elements currently within the `node_hash_set`.\n  using Base::size;\n\n  // node_hash_set::clear()\n  //\n  // Removes all elements from the `node_hash_set`. Invalidates any references,\n  // pointers, or iterators referring to contained elements.\n  //\n  // NOTE: this operation may shrink the underlying buffer. To avoid shrinking\n  // the underlying buffer call `erase(begin(), end())`.\n  using Base::clear;\n\n  // node_hash_set::erase()\n  //\n  // Erases elements within the `node_hash_set`. Erasing does not trigger a\n  // rehash. Overloads are listed below.\n  //\n  // void erase(const_iterator pos):\n  //\n  //   Erases the element at `position` of the `node_hash_set`, returning\n  //   `void`.\n  //\n  //   NOTE: this return behavior is different than that of STL containers in\n  //   general and `std::unordered_set` in particular.\n  //\n  // iterator erase(const_iterator first, const_iterator last):\n  //\n  //   Erases the elements in the open interval [`first`, `last`), returning an\n  //   iterator pointing to `last`. The special case of calling\n  //   `erase(begin(), end())` resets the reserved growth such that if\n  //   `reserve(N)` has previously been called and there has been no intervening\n  //   call to `clear()`, then after calling `erase(begin(), end())`, it is safe\n  //   to assume that inserting N elements will not cause a rehash.\n  //\n  // size_type erase(const key_type& key):\n  //\n  //   Erases the element with the matching key, if it exists, returning the\n  //   number of elements erased (0 or 1).\n  using Base::erase;\n\n  // node_hash_set::insert()\n  //\n  // Inserts an element of the specified value into the `node_hash_set`,\n  // returning an iterator pointing to the newly inserted element, provided that\n  // an element with the given key does not already exist. If rehashing occurs\n  // due to the insertion, all iterators are invalidated. Overloads are listed\n  // below.\n  //\n  // std::pair<iterator,bool> insert(const T& value):\n  //\n  //   Inserts a value into the `node_hash_set`. Returns a pair consisting of an\n  //   iterator to the inserted element (or to the element that prevented the\n  //   insertion) and a bool denoting whether the insertion took place.\n  //\n  // std::pair<iterator,bool> insert(T&& value):\n  //\n  //   Inserts a moveable value into the `node_hash_set`. Returns a pair\n  //   consisting of an iterator to the inserted element (or to the element that\n  //   prevented the insertion) and a bool denoting whether the insertion took\n  //   place.\n  //\n  // iterator insert(const_iterator hint, const T& value):\n  // iterator insert(const_iterator hint, T&& value):\n  //\n  //   Inserts a value, using the position of `hint` as a non-binding suggestion\n  //   for where to begin the insertion search. Returns an iterator to the\n  //   inserted element, or to the existing element that prevented the\n  //   insertion.\n  //\n  // void insert(InputIterator first, InputIterator last):\n  //\n  //   Inserts a range of values [`first`, `last`).\n  //\n  //   NOTE: Although the STL does not specify which element may be inserted if\n  //   multiple keys compare equivalently, for `node_hash_set` we guarantee the\n  //   first match is inserted.\n  //\n  // void insert(std::initializer_list<T> ilist):\n  //\n  //   Inserts the elements within the initializer list `ilist`.\n  //\n  //   NOTE: Although the STL does not specify which element may be inserted if\n  //   multiple keys compare equivalently within the initializer list, for\n  //   `node_hash_set` we guarantee the first match is inserted.\n  using Base::insert;\n\n  // node_hash_set::emplace()\n  //\n  // Inserts an element of the specified value by constructing it in-place\n  // within the `node_hash_set`, provided that no element with the given key\n  // already exists.\n  //\n  // The element may be constructed even if there already is an element with the\n  // key in the container, in which case the newly constructed element will be\n  // destroyed immediately.\n  //\n  // If rehashing occurs due to the insertion, all iterators are invalidated.\n  using Base::emplace;\n\n  // node_hash_set::emplace_hint()\n  //\n  // Inserts an element of the specified value by constructing it in-place\n  // within the `node_hash_set`, using the position of `hint` as a non-binding\n  // suggestion for where to begin the insertion search, and only inserts\n  // provided that no element with the given key already exists.\n  //\n  // The element may be constructed even if there already is an element with the\n  // key in the container, in which case the newly constructed element will be\n  // destroyed immediately.\n  //\n  // If rehashing occurs due to the insertion, all iterators are invalidated.\n  using Base::emplace_hint;\n\n  // node_hash_set::extract()\n  //\n  // Extracts the indicated element, erasing it in the process, and returns it\n  // as a C++17-compatible node handle. Overloads are listed below.\n  //\n  // node_type extract(const_iterator position):\n  //\n  //   Extracts the element at the indicated position and returns a node handle\n  //   owning that extracted data.\n  //\n  // node_type extract(const key_type& x):\n  //\n  //   Extracts the element with the key matching the passed key value and\n  //   returns a node handle owning that extracted data. If the `node_hash_set`\n  //   does not contain an element with a matching key, this function returns an\n  // empty node handle.\n  using Base::extract;\n\n  // node_hash_set::merge()\n  //\n  // Extracts elements from a given `source` node hash set into this\n  // `node_hash_set`. If the destination `node_hash_set` already contains an\n  // element with an equivalent key, that element is not extracted.\n  using Base::merge;\n\n  // node_hash_set::swap(node_hash_set& other)\n  //\n  // Exchanges the contents of this `node_hash_set` with those of the `other`\n  // node hash set, avoiding invocation of any move, copy, or swap operations on\n  // individual elements.\n  //\n  // All iterators and references on the `node_hash_set` remain valid, excepting\n  // for the past-the-end iterator, which is invalidated.\n  //\n  // `swap()` requires that the node hash set's hashing and key equivalence\n  // functions be Swappable, and are exchanged using unqualified calls to\n  // non-member `swap()`. If the set's allocator has\n  // `std::allocator_traits<allocator_type>::propagate_on_container_swap::value`\n  // set to `true`, the allocators are also exchanged using an unqualified call\n  // to non-member `swap()`; otherwise, the allocators are not swapped.\n  using Base::swap;\n\n  // node_hash_set::rehash(count)\n  //\n  // Rehashes the `node_hash_set`, setting the number of slots to be at least\n  // the passed value. If the new number of slots increases the load factor more\n  // than the current maximum load factor\n  // (`count` < `size()` / `max_load_factor()`), then the new number of slots\n  // will be at least `size()` / `max_load_factor()`.\n  //\n  // To force a rehash, pass rehash(0).\n  //\n  // NOTE: unlike behavior in `std::unordered_set`, references are also\n  // invalidated upon a `rehash()`.\n  using Base::rehash;\n\n  // node_hash_set::reserve(count)\n  //\n  // Sets the number of slots in the `node_hash_set` to the number needed to\n  // accommodate at least `count` total elements without exceeding the current\n  // maximum load factor, and may rehash the container if needed.\n  using Base::reserve;\n\n  // node_hash_set::contains()\n  //\n  // Determines whether an element comparing equal to the given `key` exists\n  // within the `node_hash_set`, returning `true` if so or `false` otherwise.\n  using Base::contains;\n\n  // node_hash_set::count(const Key& key) const\n  //\n  // Returns the number of elements comparing equal to the given `key` within\n  // the `node_hash_set`. note that this function will return either `1` or `0`\n  // since duplicate elements are not allowed within a `node_hash_set`.\n  using Base::count;\n\n  // node_hash_set::equal_range()\n  //\n  // Returns a closed range [first, last], defined by a `std::pair` of two\n  // iterators, containing all elements with the passed key in the\n  // `node_hash_set`.\n  using Base::equal_range;\n\n  // node_hash_set::find()\n  //\n  // Finds an element with the passed `key` within the `node_hash_set`.\n  using Base::find;\n\n  // node_hash_set::bucket_count()\n  //\n  // Returns the number of \"buckets\" within the `node_hash_set`. Note that\n  // because a node hash set contains all elements within its internal storage,\n  // this value simply equals the current capacity of the `node_hash_set`.\n  using Base::bucket_count;\n\n  // node_hash_set::load_factor()\n  //\n  // Returns the current load factor of the `node_hash_set` (the average number\n  // of slots occupied with a value within the hash set).\n  using Base::load_factor;\n\n  // node_hash_set::max_load_factor()\n  //\n  // Manages the maximum load factor of the `node_hash_set`. Overloads are\n  // listed below.\n  //\n  // float node_hash_set::max_load_factor()\n  //\n  //   Returns the current maximum load factor of the `node_hash_set`.\n  //\n  // void node_hash_set::max_load_factor(float ml)\n  //\n  //   Sets the maximum load factor of the `node_hash_set` to the passed value.\n  //\n  //   NOTE: This overload is provided only for API compatibility with the STL;\n  //   `node_hash_set` will ignore any set load factor and manage its rehashing\n  //   internally as an implementation detail.\n  using Base::max_load_factor;\n\n  // node_hash_set::get_allocator()\n  //\n  // Returns the allocator function associated with this `node_hash_set`.\n  using Base::get_allocator;\n\n  // node_hash_set::hash_function()\n  //\n  // Returns the hashing function used to hash the keys within this\n  // `node_hash_set`.\n  using Base::hash_function;\n\n  // node_hash_set::key_eq()\n  //\n  // Returns the function used for comparing keys equality.\n  using Base::key_eq;\n};\n\n// erase_if(node_hash_set<>, Pred)\n//\n// Erases all elements that satisfy the predicate `pred` from the container `c`.\n// Returns the number of erased elements.\ntemplate <typename T, typename H, typename E, typename A, typename Predicate>\ntypename node_hash_set<T, H, E, A>::size_type erase_if(\n    node_hash_set<T, H, E, A>& c, Predicate pred) {\n  return container_internal::EraseIf(pred, &c);\n}\n\nnamespace container_internal {\n\ntemplate <class T>\nstruct NodeHashSetPolicy\n    : absl::container_internal::node_slot_policy<T&, NodeHashSetPolicy<T>> {\n  using key_type = T;\n  using init_type = T;\n  using constant_iterators = std::true_type;\n\n  template <class Allocator, class... Args>\n  static T* new_element(Allocator* alloc, Args&&... args) {\n    using ValueAlloc =\n        typename absl::allocator_traits<Allocator>::template rebind_alloc<T>;\n    ValueAlloc value_alloc(*alloc);\n    T* res = absl::allocator_traits<ValueAlloc>::allocate(value_alloc, 1);\n    absl::allocator_traits<ValueAlloc>::construct(value_alloc, res,\n                                                  std::forward<Args>(args)...);\n    return res;\n  }\n\n  template <class Allocator>\n  static void delete_element(Allocator* alloc, T* elem) {\n    using ValueAlloc =\n        typename absl::allocator_traits<Allocator>::template rebind_alloc<T>;\n    ValueAlloc value_alloc(*alloc);\n    absl::allocator_traits<ValueAlloc>::destroy(value_alloc, elem);\n    absl::allocator_traits<ValueAlloc>::deallocate(value_alloc, elem, 1);\n  }\n\n  template <class F, class... Args>\n  static decltype(absl::container_internal::DecomposeValue(\n      std::declval<F>(), std::declval<Args>()...))\n  apply(F&& f, Args&&... args) {\n    return absl::container_internal::DecomposeValue(\n        std::forward<F>(f), std::forward<Args>(args)...);\n  }\n\n  static size_t element_space_used(const T*) { return sizeof(T); }\n};\n}  // namespace container_internal\n\nnamespace container_algorithm_internal {\n\n// Specialization of trait in absl/algorithm/container.h\ntemplate <class Key, class Hash, class KeyEqual, class Allocator>\nstruct IsUnorderedContainer<absl::node_hash_set<Key, Hash, KeyEqual, Allocator>>\n    : std::true_type {};\n\n}  // namespace container_algorithm_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-03561",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/node_hash_set.h",
  "source_line": 47,
  "validation_status": "validated"
}