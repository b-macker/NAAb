{
  "code": "{\n\n// CordzUpdateTracker tracks counters for Cord update methods.\n//\n// The purpose of CordzUpdateTracker is to track the number of calls to methods\n// updating Cord data for sampled cords. The class internally uses 'lossy'\n// atomic operations: Cord is thread-compatible, so there is no need to\n// synchronize updates. However, Cordz collection threads may call 'Value()' at\n// any point, so the class needs to provide thread safe access.\n//\n// This class is thread-safe. But as per above comments, all non-const methods\n// should be used single-threaded only: updates are thread-safe but lossy.\nclass CordzUpdateTracker {\n public:\n  // Tracked update methods.\n  enum MethodIdentifier {\n    kUnknown,\n    kAppendCord,\n    kAppendCordBuffer,\n    kAppendExternalMemory,\n    kAppendString,\n    kAssignCord,\n    kAssignString,\n    kClear,\n    kConstructorCord,\n    kConstructorString,\n    kCordReader,\n    kFlatten,\n    kGetAppendBuffer,\n    kGetAppendRegion,\n    kMakeCordFromExternal,\n    kMoveAppendCord,\n    kMoveAssignCord,\n    kMovePrependCord,\n    kPrependCord,\n    kPrependCordBuffer,\n    kPrependString,\n    kRemovePrefix,\n    kRemoveSuffix,\n    kSetExpectedChecksum,\n    kSubCord,\n\n    // kNumMethods defines the number of entries: must be the last entry.\n    kNumMethods,\n  };\n\n  // Constructs a new instance. All counters are zero-initialized.\n  constexpr CordzUpdateTracker() noexcept : values_{} {}\n\n  // Copy constructs a new instance.\n  CordzUpdateTracker(const CordzUpdateTracker& rhs) noexcept { *this = rhs; }\n\n  // Assigns the provided value to this instance.\n  CordzUpdateTracker& operator=(const CordzUpdateTracker& rhs) noexcept {\n    for (int i = 0; i < kNumMethods; ++i) {\n      values_[i].store(rhs.values_[i].load(std::memory_order_relaxed),\n                       std::memory_order_relaxed);\n    }\n    return *this;\n  }\n\n  // Returns the value for the specified method.\n  int64_t Value(MethodIdentifier method) const {\n    return values_[method].load(std::memory_order_relaxed);\n  }\n\n  // Increases the value for the specified method by `n`\n  void LossyAdd(MethodIdentifier method, int64_t n = 1) {\n    auto& value = values_[method];\n    value.store(value.load(std::memory_order_relaxed) + n,\n                std::memory_order_relaxed);\n  }\n\n  // Adds all the values from `src` to this instance\n  void LossyAdd(const CordzUpdateTracker& src) {\n    for (int i = 0; i < kNumMethods; ++i) {\n      MethodIdentifier method = static_cast<MethodIdentifier>(i);\n      if (int64_t value = src.Value(method)) {\n        LossyAdd(method, value);\n      }\n    }\n  }\n\n private:\n  // Until C++20 std::atomic is not constexpr default-constructible, so we need\n  // a wrapper for this class to be constexpr constructible.\n  class Counter : public std::atomic<int64_t> {\n   public:\n    constexpr Counter() noexcept : std::atomic<int64_t>(0) {}\n  };\n\n  Counter values_[kNumMethods];\n};\n\n}",
  "id": "BLOCK-CPP-06204",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cordz_update_tracker.h",
  "source_line": 25,
  "validation_status": "validated"
}