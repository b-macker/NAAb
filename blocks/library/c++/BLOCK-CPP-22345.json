{
  "code": "{\n  ASTContext *Context = nullptr;\n  const LangOptions LangOpts;\n  const AnalyzerOptions &AOptions;\n  const Preprocessor *PP = nullptr;\n  CheckerNameRef CurrentCheckerName;\n  DiagnosticsEngine &Diags;\n  std::unique_ptr<CheckerRegistryData> RegistryData;\n\npublic:\n  // These constructors are defined in the Frontend library, because\n  // CheckerRegistry, a crucial component of the initialization is in there.\n  // CheckerRegistry cannot be moved to the Core library, because the checker\n  // registration functions are defined in the Checkers library, and the library\n  // dependencies look like this: Core -> Checkers -> Frontend.\n\n  CheckerManager(\n      ASTContext &Context, AnalyzerOptions &AOptions, const Preprocessor &PP,\n      ArrayRef<std::string> plugins,\n      ArrayRef<std::function<void(CheckerRegistry &)>> checkerRegistrationFns);\n\n  /// Constructs a CheckerManager that ignores all non TblGen-generated\n  /// checkers. Useful for unit testing, unless the checker infrastructure\n  /// itself is tested.\n  CheckerManager(ASTContext &Context, AnalyzerOptions &AOptions,\n                 const Preprocessor &PP)\n      : CheckerManager(Context, AOptions, PP, {}, {}) {}\n\n  /// Constructs a CheckerManager without requiring an AST. No checker\n  /// registration will take place. Only useful when one needs to print the\n  /// help flags through CheckerRegistryData, and the AST is unavailable.\n  CheckerManager(AnalyzerOptions &AOptions, const LangOptions &LangOpts,\n                 DiagnosticsEngine &Diags, ArrayRef<std::string> plugins);\n\n  ~CheckerManager();\n\n  void setCurrentCheckerName(CheckerNameRef name) { CurrentCheckerName = name; }\n  CheckerNameRef getCurrentCheckerName() const { return CurrentCheckerName; }\n\n  bool hasPathSensitiveCheckers() const;\n\n  void finishedCheckerRegistration();\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const AnalyzerOptions &getAnalyzerOptions() const { return AOptions; }\n  const Preprocessor &getPreprocessor() const {\n    assert(PP);\n    return *PP;\n  }\n  const CheckerRegistryData &getCheckerRegistryData() const {\n    return *RegistryData;\n  }\n  DiagnosticsEngine &getDiagnostics() const { return Diags; }\n  ASTContext &getASTContext() const {\n    assert(Context);\n    return *Context;\n  }\n\n  /// Emits an error through a DiagnosticsEngine about an invalid user supplied\n  /// checker option value.\n  void reportInvalidCheckerOptionValue(const CheckerBase *C,\n                                       StringRef OptionName,\n                                       StringRef ExpectedValueDesc) const;\n\n  using CheckerRef = CheckerBase *;\n  using CheckerTag = const void *;\n  using CheckerDtor = CheckerFn<void ()>;\n\n//===----------------------------------------------------------------------===//\n// Checker registration.\n//===----------------------------------------------------------------------===//\n\n  /// Used to register checkers.\n  /// All arguments are automatically passed through to the checker\n  /// constructor.\n  ///\n  /// \\returns a pointer to the checker object.\n  template <typename CHECKER, typename... AT>\n  CHECKER *registerChecker(AT &&... Args) {\n    CheckerTag tag = getTag<CHECKER>();\n    CheckerRef &ref = CheckerTags[tag];\n    assert(!ref && \"Checker already registered, use getChecker!\");\n\n    CHECKER *checker = new CHECKER(std::forward<AT>(Args)...);\n    checker->Name = CurrentCheckerName;\n    CheckerDtors.push_back(CheckerDtor(checker, destruct<CHECKER>));\n    CHECKER::_register(checker, *this);\n    ref = checker;\n    return checker;\n  }\n\n  template <typename CHECKER>\n  CHECKER *getChecker() {\n    CheckerTag tag = getTag<CHECKER>();\n    assert(CheckerTags.count(tag) != 0 &&\n           \"Requested checker is not registered! Maybe you should add it as a \"\n           \"dependency in Checkers.td?\");\n    return static_cast<CHECKER *>(CheckerTags[tag]);\n  }\n\n//===----------------------------------------------------------------------===//\n// Functions for running checkers for AST traversing.\n//===----------------------------------------------------------------------===//\n\n  /// Run checkers handling Decls.\n  void runCheckersOnASTDecl(const Decl *D, AnalysisManager& mgr,\n                            BugReporter &BR);\n\n  /// Run checkers handling Decls containing a Stmt body.\n  void runCheckersOnASTBody(const Decl *D, AnalysisManager& mgr,\n                            BugReporter &BR);\n\n//===----------------------------------------------------------------------===//\n// Functions for running checkers for path-sensitive checking.\n//===----------------------------------------------------------------------===//\n\n  /// Run checkers for pre-visiting Stmts.\n  ///\n  /// The notification is performed for every explored CFGElement, which does\n  /// not include the control flow statements such as IfStmt.\n  ///\n  /// \\sa runCheckersForBranchCondition, runCheckersForPostStmt\n  void runCheckersForPreStmt(ExplodedNodeSet &Dst,\n                             const ExplodedNodeSet &Src,\n                             const Stmt *S,\n                             ExprEngine &Eng) {\n    runCheckersForStmt(/*isPreVisit=*/true, Dst, Src, S, Eng);\n  }\n\n  /// Run checkers for post-visiting Stmts.\n  ///\n  /// The notification is performed for every explored CFGElement, which does\n  /// not include the control flow statements such as IfStmt.\n  ///\n  /// \\sa runCheckersForBranchCondition, runCheckersForPreStmt\n  void runCheckersForPostStmt(ExplodedNodeSet &Dst,\n                              const ExplodedNodeSet &Src,\n                              const Stmt *S,\n                              ExprEngine &Eng,\n                              bool wasInlined = false) {\n    runCheckersForStmt(/*isPreVisit=*/false, Dst, Src, S, Eng, wasInlined);\n  }\n\n  /// Run checkers for visiting Stmts.\n  void runCheckersForStmt(bool isPreVisit,\n                          ExplodedNodeSet &Dst, const ExplodedNodeSet &Src,\n                          const Stmt *S, ExprEngine &Eng,\n                          bool wasInlined = false);\n\n  /// Run checkers for pre-visiting obj-c messages.\n  void runCheckersForPreObjCMessage(ExplodedNodeSet &Dst,\n                                    const ExplodedNodeSet &Src,\n                                    const ObjCMethodCall &msg,\n                                    ExprEngine &Eng) {\n    runCheckersForObjCMessage(ObjCMessageVisitKind::Pre, Dst, Src, msg, Eng);\n  }\n\n  /// Run checkers for post-visiting obj-c messages.\n  void runCheckersForPostObjCMessage(ExplodedNodeSet &Dst,\n                                     const ExplodedNodeSet &Src,\n                                     const ObjCMethodCall &msg,\n                                     ExprEngine &Eng,\n                                     bool wasInlined = false) {\n    runCheckersForObjCMessage(ObjCMessageVisitKind::Post, Dst, Src, msg, Eng,\n                              wasInlined);\n  }\n\n  /// Run checkers for visiting an obj-c message to nil.\n  void runCheckersForObjCMessageNil(ExplodedNodeSet &Dst,\n                                    const ExplodedNodeSet &Src,\n                                    const ObjCMethodCall &msg,\n                                    ExprEngine &Eng) {\n    runCheckersForObjCMessage(ObjCMessageVisitKind::MessageNil, Dst, Src, msg,\n                              Eng);\n  }\n\n  /// Run checkers for visiting obj-c messages.\n  void runCheckersForObjCMessage(ObjCMessageVisitKind visitKind,\n                                 ExplodedNodeSet &Dst,\n                                 const ExplodedNodeSet &Src,\n                                 const ObjCMethodCall &msg, ExprEngine &Eng,\n                                 bool wasInlined = false);\n\n  /// Run checkers for pre-visiting obj-c messages.\n  void runCheckersForPreCall(ExplodedNodeSet &Dst, const ExplodedNodeSet &Src,\n                             const CallEvent &Call, ExprEngine &Eng) {\n    runCheckersForCallEvent(/*isPreVisit=*/true, Dst, Src, Call, Eng);\n  }\n\n  /// Run checkers for post-visiting obj-c messages.\n  void runCheckersForPostCall(ExplodedNodeSet &Dst, const ExplodedNodeSet &Src,\n                              const CallEvent &Call, ExprEngine &Eng,\n                              bool wasInlined = false) {\n    runCheckersForCallEvent(/*isPreVisit=*/false, Dst, Src, Call, Eng,\n                            wasInlined);\n  }\n\n  /// Run checkers for visiting obj-c messages.\n  void runCheckersForCallEvent(bool isPreVisit, ExplodedNodeSet &Dst,\n                               const ExplodedNodeSet &Src,\n                               const CallEvent &Call, ExprEngine &Eng,\n                               bool wasInlined = false);\n\n  /// Run checkers for load/store of a location.\n  void runCheckersForLocation(ExplodedNodeSet &Dst,\n                              const ExplodedNodeSet &Src,\n                              SVal location,\n                              bool isLoad,\n                              const Stmt *NodeEx,\n                              const Stmt *BoundEx,\n                              ExprEngine &Eng);\n\n  /// Run checkers for binding of a value to a location.\n  void runCheckersForBind(ExplodedNodeSet &Dst,\n                          const ExplodedNodeSet &Src,\n                          SVal location, SVal val,\n                          const Stmt *S, ExprEngine &Eng,\n                          const ProgramPoint &PP);\n\n  /// Run checkers for end of analysis.\n  void runCheckersForEndAnalysis(ExplodedGraph &G, BugReporter &BR,\n                                 ExprEngine &Eng);\n\n  /// Run checkers on beginning of function.\n  void runCheckersForBeginFunction(ExplodedNodeSet &Dst,\n                                   const BlockEdge &L,\n                                   ExplodedNode *Pred,\n                                   ExprEngine &Eng);\n\n  /// Run checkers on end of function.\n  void runCheckersForEndFunction(NodeBuilderContext &BC,\n                                 ExplodedNodeSet &Dst,\n                                 ExplodedNode *Pred,\n                                 ExprEngine &Eng,\n                                 const ReturnStmt *RS);\n\n  /// Run checkers for branch condition.\n  void runCheckersForBranchCondition(const Stmt *condition,\n                                     ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                                     ExprEngine &Eng);\n\n  /// Run checkers between C++ operator new and constructor calls.\n  void runCheckersForNewAllocator(const CXXAllocatorCall &Call,\n                                  ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                                  ExprEngine &Eng, bool wasInlined = false);\n\n  /// Run checkers for live symbols.\n  ///\n  /// Allows modifying SymbolReaper object. For example, checkers can explicitly\n  /// register symbols of interest as live. These symbols will not be marked\n  /// dead and removed.\n  void runCheckersForLiveSymbols(ProgramStateRef state,\n                                 SymbolReaper &SymReaper);\n\n  /// Run checkers for dead symbols.\n  ///\n  /// Notifies checkers when symbols become dead. For example, this allows\n  /// checkers to aggressively clean up/reduce the checker state and produce\n  /// precise diagnostics.\n  void runCheckersForDeadSymbols(ExplodedNodeSet &Dst,\n                                 const ExplodedNodeSet &Src,\n                                 SymbolReaper &SymReaper, const Stmt *S,\n                                 ExprEngine &Eng,\n                                 ProgramPoint::Kind K);\n\n  /// Run checkers for region changes.\n  ///\n  /// This corresponds to the check::RegionChanges callback.\n  /// \\param state The current program state.\n  /// \\param invalidated A set of all symbols potentially touched by the change.\n  /// \\param ExplicitRegions The regions explicitly requested for invalidation.\n  ///   For example, in the case of a function call, these would be arguments.\n  /// \\param Regions The transitive closure of accessible regions,\n  ///   i.e. all regions that may have been touched by this change.\n  /// \\param Call The call expression wrapper if the regions are invalidated\n  ///   by a call.\n  ProgramStateRef\n  runCheckersForRegionChanges(ProgramStateRef state,\n                              const InvalidatedSymbols *invalidated,\n                              ArrayRef<const MemRegion *> ExplicitRegions,\n                              ArrayRef<const MemRegion *> Regions,\n                              const LocationContext *LCtx,\n                              const CallEvent *Call);\n\n  /// Run checkers when pointers escape.\n  ///\n  /// This notifies the checkers about pointer escape, which occurs whenever\n  /// the analyzer cannot track the symbol any more. For example, as a\n  /// result of assigning a pointer into a global or when it's passed to a\n  /// function call the analyzer cannot model.\n  ///\n  /// \\param State The state at the point of escape.\n  /// \\param Escaped The list of escaped symbols.\n  /// \\param Call The corresponding CallEvent, if the symbols escape as\n  ///        parameters to the given call.\n  /// \\param Kind The reason of pointer escape.\n  /// \\param ITraits Information about invalidation for a particular\n  ///        region/symbol.\n  /// \\returns Checkers can modify the state by returning a new one.\n  ProgramStateRef\n  runCheckersForPointerEscape(ProgramStateRef State,\n                              const InvalidatedSymbols &Escaped,\n                              const CallEvent *Call,\n                              PointerEscapeKind Kind,\n                              RegionAndSymbolInvalidationTraits *ITraits);\n\n  /// Run checkers for handling assumptions on symbolic values.\n  ProgramStateRef runCheckersForEvalAssume(ProgramStateRef state,\n                                           SVal Cond, bool Assumption);\n\n  /// Run checkers for evaluating a call.\n  ///\n  /// Warning: Currently, the CallEvent MUST come from a CallExpr!\n  void runCheckersForEvalCall(ExplodedNodeSet &Dst, const ExplodedNodeSet &Src,\n                              const CallEvent &CE, ExprEngine &Eng,\n                              const EvalCallOptions &CallOpts);\n\n  /// Run checkers for the entire Translation Unit.\n  void runCheckersOnEndOfTranslationUnit(const TranslationUnitDecl *TU,\n                                         AnalysisManager &mgr,\n                                         BugReporter &BR);\n\n  /// Run checkers for debug-printing a ProgramState.\n  ///\n  /// Unlike most other callbacks, any checker can simply implement the virtual\n  /// method CheckerBase::printState if it has custom data to print.\n  ///\n  /// \\param Out   The output stream\n  /// \\param State The state being printed\n  /// \\param NL    The preferred representation of a newline.\n  /// \\param Space The preferred space between the left side and the message.\n  /// \\param IsDot Whether the message will be printed in 'dot' format.\n  void runCheckersForPrintStateJson(raw_ostream &Out, ProgramStateRef State,\n                                    const char *NL = \"\\n\",\n                                    unsigned int Space = 0,\n                                    bool IsDot = false) const;\n\n  //===----------------------------------------------------------------------===//\n  // Internal registration functions for AST traversing.\n  //===----------------------------------------------------------------------===//\n\n  // Functions used by the registration mechanism, checkers should not touch\n  // these directly.\n\n  using CheckDeclFunc =\n      CheckerFn<void (const Decl *, AnalysisManager&, BugReporter &)>;\n\n  using HandlesDeclFunc = bool (*)(const Decl *D);\n\n  void _registerForDecl(CheckDeclFunc checkfn, HandlesDeclFunc isForDeclFn);\n\n  void _registerForBody(CheckDeclFunc checkfn);\n\n//===----------------------------------------------------------------------===//\n// Internal registration functions for path-sensitive checking.\n//===----------------------------------------------------------------------===//\n\n  using CheckStmtFunc = CheckerFn<void (const Stmt *, CheckerContext &)>;\n\n  using CheckObjCMessageFunc =\n      CheckerFn<void (const ObjCMethodCall &, CheckerContext &)>;\n\n  using CheckCallFunc =\n      CheckerFn<void (const CallEvent &, CheckerContext &)>;\n\n  using CheckLocationFunc =\n      CheckerFn<void (const SVal &location, bool isLoad, const Stmt *S,\n                      CheckerContext &)>;\n\n  using CheckBindFunc =\n      CheckerFn<void (const SVal &location, const SVal &val, const Stmt *S,\n                      CheckerContext &)>;\n\n  using CheckEndAnalysisFunc =\n      CheckerFn<void (ExplodedGraph &, BugReporter &, ExprEngine &)>;\n\n  using CheckBeginFunctionFunc = CheckerFn<void (CheckerContext &)>;\n\n  using CheckEndFunctionFunc =\n      CheckerFn<void (const ReturnStmt *, CheckerContext &)>;\n\n  using CheckBranchConditionFunc =\n      CheckerFn<void (const Stmt *, CheckerContext &)>;\n\n  using CheckNewAllocatorFunc =\n      CheckerFn<void(const CXXAllocatorCall &Call, CheckerContext &)>;\n\n  using CheckDeadSymbolsFunc =\n      CheckerFn<void (SymbolReaper &, CheckerContext &)>;\n\n  using CheckLiveSymbolsFunc = CheckerFn<void (ProgramStateRef,SymbolReaper &)>;\n\n  using CheckRegionChangesFunc =\n      CheckerFn<ProgramStateRef (ProgramStateRef,\n                                 const InvalidatedSymbols *symbols,\n                                 ArrayRef<const MemRegion *> ExplicitRegions,\n                                 ArrayRef<const MemRegion *> Regions,\n                                 const LocationContext *LCtx,\n                                 const CallEvent *Call)>;\n\n  using CheckPointerEscapeFunc =\n      CheckerFn<ProgramStateRef (ProgramStateRef,\n                                 const InvalidatedSymbols &Escaped,\n                                 const CallEvent *Call, PointerEscapeKind Kind,\n                                 RegionAndSymbolInvalidationTraits *ITraits)>;\n\n  using EvalAssumeFunc =\n      CheckerFn<ProgramStateRef (ProgramStateRef, const SVal &cond,\n                                 bool assumption)>;\n\n  using EvalCallFunc = CheckerFn<bool (const CallEvent &, CheckerContext &)>;\n\n  using CheckEndOfTranslationUnit =\n      CheckerFn<void (const TranslationUnitDecl *, AnalysisManager &,\n                      BugReporter &)>;\n\n  using HandlesStmtFunc = bool (*)(const Stmt *D);\n\n  void _registerForPreStmt(CheckStmtFunc checkfn,\n                           HandlesStmtFunc isForStmtFn);\n  void _registerForPostStmt(CheckStmtFunc checkfn,\n                            HandlesStmtFunc isForStmtFn);\n\n  void _registerForPreObjCMessage(CheckObjCMessageFunc checkfn);\n  void _registerForPostObjCMessage(CheckObjCMessageFunc checkfn);\n\n  void _registerForObjCMessageNil(CheckObjCMessageFunc checkfn);\n\n  void _registerForPreCall(CheckCallFunc checkfn);\n  void _registerForPostCall(CheckCallFunc checkfn);\n\n  void _registerForLocation(CheckLocationFunc checkfn);\n\n  void _registerForBind(CheckBindFunc checkfn);\n\n  void _registerForEndAnalysis(CheckEndAnalysisFunc checkfn);\n\n  void _registerForBeginFunction(CheckBeginFunctionFunc checkfn);\n  void _registerForEndFunction(CheckEndFunctionFunc checkfn);\n\n  void _registerForBranchCondition(CheckBranchConditionFunc checkfn);\n\n  void _registerForNewAllocator(CheckNewAllocatorFunc checkfn);\n\n  void _registerForLiveSymbols(CheckLiveSymbolsFunc checkfn);\n\n  void _registerForDeadSymbols(CheckDeadSymbolsFunc checkfn);\n\n  void _registerForRegionChanges(CheckRegionChangesFunc checkfn);\n\n  void _registerForPointerEscape(CheckPointerEscapeFunc checkfn);\n\n  void _registerForConstPointerEscape(CheckPointerEscapeFunc checkfn);\n\n  void _registerForEvalAssume(EvalAssumeFunc checkfn);\n\n  void _registerForEvalCall(EvalCallFunc checkfn);\n\n  void _registerForEndOfTranslationUnit(CheckEndOfTranslationUnit checkfn);\n\n//===----------------------------------------------------------------------===//\n// Internal registration functions for events.\n//===----------------------------------------------------------------------===//\n\n  using EventTag = void *;\n  using CheckEventFunc = CheckerFn<void (const void *event)>;\n\n  template <typename EVENT>\n  void _registerListenerForEvent(CheckEventFunc checkfn) {\n    EventInfo &info = Events[&EVENT::Tag];\n    info.Checkers.push_back(checkfn);\n  }\n\n  template <typename EVENT>\n  void _registerDispatcherForEvent() {\n    EventInfo &info = Events[&EVENT::Tag];\n    info.HasDispatcher = true;\n  }\n\n  template <typename EVENT>\n  void _dispatchEvent(const EVENT &event) const {\n    EventsTy::const_iterator I = Events.find(&EVENT::Tag);\n    if (I == Events.end())\n      return;\n    const EventInfo &info = I->second;\n    for (const auto &Checker : info.Checkers)\n      Checker(&event);\n  }\n\n//===----------------------------------------------------------------------===//\n// Implementation details.\n//===----------------------------------------------------------------------===//\n\nprivate:\n  template <typename CHECKER>\n  static void destruct(void *obj) { delete static_cast<CHECKER *>(obj); }\n\n  template <typename T>\n  static void *getTag() { static int tag; return &tag; }\n\n  llvm::DenseMap<CheckerTag, CheckerRef> CheckerTags;\n\n  std::vector<CheckerDtor> CheckerDtors;\n\n  struct DeclCheckerInfo {\n    CheckDeclFunc CheckFn;\n    HandlesDeclFunc IsForDeclFn;\n  };\n  std::vector<DeclCheckerInfo> DeclCheckers;\n\n  std::vector<CheckDeclFunc> BodyCheckers;\n\n  using CachedDeclCheckers = SmallVector<CheckDeclFunc, 4>;\n  using CachedDeclCheckersMapTy = llvm::DenseMap<unsigned, CachedDeclCheckers>;\n  CachedDeclCheckersMapTy CachedDeclCheckersMap;\n\n  struct StmtCheckerInfo {\n    CheckStmtFunc CheckFn;\n    HandlesStmtFunc IsForStmtFn;\n    bool IsPreVisit;\n  };\n  std::vector<StmtCheckerInfo> StmtCheckers;\n\n  using CachedStmtCheckers = SmallVector<CheckStmtFunc, 4>;\n  using CachedStmtCheckersMapTy = llvm::DenseMap<unsigned, CachedStmtCheckers>;\n  CachedStmtCheckersMapTy CachedStmtCheckersMap;\n\n  const CachedStmtCheckers &getCachedStmtCheckersFor(const Stmt *S,\n                                                     bool isPreVisit);\n\n  /// Returns the checkers that have registered for callbacks of the\n  /// given \\p Kind.\n  const std::vector<CheckObjCMessageFunc> &\n  getObjCMessageCheckers(ObjCMessageVisitKind Kind) const;\n\n  std::vector<CheckObjCMessageFunc> PreObjCMessageCheckers;\n  std::vector<CheckObjCMessageFunc> PostObjCMessageCheckers;\n  std::vector<CheckObjCMessageFunc> ObjCMessageNilCheckers;\n\n  std::vector<CheckCallFunc> PreCallCheckers;\n  std::vector<CheckCallFunc> PostCallCheckers;\n\n  std::vector<CheckLocationFunc> LocationCheckers;\n\n  std::vector<CheckBindFunc> BindCheckers;\n\n  std::vector<CheckEndAnalysisFunc> EndAnalysisCheckers;\n\n  std::vector<CheckBeginFunctionFunc> BeginFunctionCheckers;\n  std::vector<CheckEndFunctionFunc> EndFunctionCheckers;\n\n  std::vector<CheckBranchConditionFunc> BranchConditionCheckers;\n\n  std::vector<CheckNewAllocatorFunc> NewAllocatorCheckers;\n\n  std::vector<CheckLiveSymbolsFunc> LiveSymbolsCheckers;\n\n  std::vector<CheckDeadSymbolsFunc> DeadSymbolsCheckers;\n\n  std::vector<CheckRegionChangesFunc> RegionChangesCheckers;\n\n  std::vector<CheckPointerEscapeFunc> PointerEscapeCheckers;\n\n  std::vector<EvalAssumeFunc> EvalAssumeCheckers;\n\n  std::vector<EvalCallFunc> EvalCallCheckers;\n\n  std::vector<CheckEndOfTranslationUnit> EndOfTranslationUnitCheckers;\n\n  struct EventInfo {\n    SmallVector<CheckEventFunc, 4> Checkers;\n    bool HasDispatcher = false;\n\n    EventInfo() = default;\n  };\n\n  using EventsTy = llvm::DenseMap<EventTag, EventInfo>;\n  EventsTy Events;\n}",
  "id": "BLOCK-CPP-22345",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h",
  "source_line": 126,
  "validation_status": "validated"
}