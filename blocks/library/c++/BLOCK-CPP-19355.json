{
  "code": "{\n    /// Flags used to rank candidate template names when there is more than one\n    /// '<' in a scope.\n    enum Priority : unsigned short {\n      /// A non-dependent name that is a potential typo for a template name.\n      PotentialTypo = 0x0,\n      /// A dependent name that might instantiate to a template-name.\n      DependentName = 0x2,\n\n      /// A space appears before the '<' token.\n      SpaceBeforeLess = 0x0,\n      /// No space before the '<' token\n      NoSpaceBeforeLess = 0x1,\n\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue*/ DependentName)\n    };\n\n    struct Loc {\n      Expr *TemplateName;\n      SourceLocation LessLoc;\n      AngleBracketTracker::Priority Priority;\n      unsigned short ParenCount, BracketCount, BraceCount;\n\n      bool isActive(Parser &P) const {\n        return P.ParenCount == ParenCount && P.BracketCount == BracketCount &&\n               P.BraceCount == BraceCount;\n      }\n\n      bool isActiveOrNested(Parser &P) const {\n        return isActive(P) || P.ParenCount > ParenCount ||\n               P.BracketCount > BracketCount || P.BraceCount > BraceCount;\n      }\n    };\n\n    SmallVector<Loc, 8> Locs;\n\n    /// Add an expression that might have been intended to be a template name.\n    /// In the case of ambiguity, we arbitrarily select the innermost such\n    /// expression, for example in 'foo < bar < baz', 'bar' is the current\n    /// candidate. No attempt is made to track that 'foo' is also a candidate\n    /// for the case where we see a second suspicious '>' token.\n    void add(Parser &P, Expr *TemplateName, SourceLocation LessLoc,\n             Priority Prio) {\n      if (!Locs.empty() && Locs.back().isActive(P)) {\n        if (Locs.back().Priority <= Prio) {\n          Locs.back().TemplateName = TemplateName;\n          Locs.back().LessLoc = LessLoc;\n          Locs.back().Priority = Prio;\n        }\n      } else {\n        Locs.push_back({TemplateName, LessLoc, Prio,\n                        P.ParenCount, P.BracketCount, P.BraceCount});\n      }\n    }\n\n    /// Mark the current potential missing template location as having been\n    /// handled (this happens if we pass a \"corresponding\" '>' or '>>' token\n    /// or leave a bracket scope).\n    void clear(Parser &P) {\n      while (!Locs.empty() && Locs.back().isActiveOrNested(P))\n        Locs.pop_back();\n    }\n\n    /// Get the current enclosing expression that might hve been intended to be\n    /// a template name.\n    Loc *getCurrent(Parser &P) {\n      if (!Locs.empty() && Locs.back().isActive(P))\n        return &Locs.back();\n      return nullptr;\n    }\n  }",
  "id": "BLOCK-CPP-19355",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Parse/Parser.h",
  "source_line": 326,
  "validation_status": "validated"
}