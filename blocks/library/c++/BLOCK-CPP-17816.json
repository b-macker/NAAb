{
  "code": "#include \"clang/Driver/Multilib.h\"\n\nusing namespace clang;\nusing namespace driver;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17816_execute() {\n    {\n\n/// This corresponds to a single GCC multilib, or a segment of one controlled\n/// by a command line flag. This class can be used to create a Multilib, and\n/// contains helper functions to mutate it before creating a Multilib instance\n/// with makeMultilib().\nclass MultilibBuilder {\npublic:\n  using flags_list = std::vector<std::string>;\n\nprivate:\n  std::string GCCSuffix;\n  std::string OSSuffix;\n  std::string IncludeSuffix;\n  flags_list Flags;\n\npublic:\n  MultilibBuilder(StringRef GCCSuffix, StringRef OSSuffix,\n                  StringRef IncludeSuffix);\n\n  /// Initializes GCCSuffix, OSSuffix & IncludeSuffix to the same value.\n  MultilibBuilder(StringRef Suffix = {});\n\n  /// Get the detected GCC installation path suffix for the multi-arch\n  /// target variant. Always starts with a '/', unless empty\n  const std::string &gccSuffix() const {\n    assert(GCCSuffix.empty() ||\n           (StringRef(GCCSuffix).front() == '/' && GCCSuffix.size() > 1));\n    return GCCSuffix;\n  }\n\n  /// Set the GCC installation path suffix.\n  MultilibBuilder &gccSuffix(StringRef S);\n\n  /// Get the detected os path suffix for the multi-arch\n  /// target variant. Always starts with a '/', unless empty\n  const std::string &osSuffix() const {\n    assert(OSSuffix.empty() ||\n           (StringRef(OSSuffix).front() == '/' && OSSuffix.size() > 1));\n    return OSSuffix;\n  }\n\n  /// Set the os path suffix.\n  MultilibBuilder &osSuffix(StringRef S);\n\n  /// Get the include directory suffix. Always starts with a '/', unless\n  /// empty\n  const std::string &includeSuffix() const {\n    assert(IncludeSuffix.empty() || (StringRef(IncludeSuffix).front() == '/' &&\n                                     IncludeSuffix.size() > 1));\n    return IncludeSuffix;\n  }\n\n  /// Set the include directory suffix\n  MultilibBuilder &includeSuffix(StringRef S);\n\n  /// Get the flags that indicate or contraindicate this multilib's use\n  /// All elements begin with either '-' or '!'\n  const flags_list &flags() const { return Flags; }\n  flags_list &flags() { return Flags; }\n\n  /// Add a flag to the flags list\n  /// \\p Flag must be a flag accepted by the driver.\n  /// \\p Disallow defines whether the flag is negated and therefore disallowed.\n  MultilibBuilder &flag(StringRef Flag, bool Disallow = false);\n\n  Multilib makeMultilib() const;\n\n  /// Check whether any of the 'against' flags contradict the 'for' flags.\n  bool isValid() const;\n\n  /// Check whether the default is selected\n  bool isDefault() const {\n    return GCCSuffix.empty() && OSSuffix.empty() && IncludeSuffix.empty();\n  }\n};\n\n/// This class can be used to create a MultilibSet, and contains helper\n/// functions to add combinations of multilibs before creating a MultilibSet\n/// instance with makeMultilibSet().\nclass MultilibSetBuilder {\npublic:\n  using multilib_list = std::vector<MultilibBuilder>;\n\n  MultilibSetBuilder() = default;\n\n  /// Add an optional Multilib segment\n  MultilibSetBuilder &Maybe(const MultilibBuilder &M);\n\n  /// Add a set of mutually incompatible Multilib segments\n  MultilibSetBuilder &Either(const MultilibBuilder &M1,\n                             const MultilibBuilder &M2);\n  MultilibSetBuilder &Either(const MultilibBuilder &M1,\n                             const MultilibBuilder &M2,\n                             const MultilibBuilder &M3);\n  MultilibSetBuilder &Either(const MultilibBuilder &M1,\n                             const MultilibBuilder &M2,\n                             const MultilibBuilder &M3,\n                             const MultilibBuilder &M4);\n  MultilibSetBuilder &Either(const MultilibBuilder &M1,\n                             const MultilibBuilder &M2,\n                             const MultilibBuilder &M3,\n                             const MultilibBuilder &M4,\n                             const MultilibBuilder &M5);\n  MultilibSetBuilder &Either(ArrayRef<MultilibBuilder> Ms);\n\n  /// Filter out those Multilibs whose gccSuffix matches the given expression\n  MultilibSetBuilder &FilterOut(const char *Regex);\n\n  MultilibSet makeMultilibSet() const;\n\nprivate:\n  multilib_list Multilibs;\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17816",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Driver/MultilibBuilder.h",
  "source_line": 16,
  "validation_status": "validated"
}