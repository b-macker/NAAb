{
  "code": "{\npublic:\n  /// The kind of initialization being performed.\n  enum InitKind {\n    /// Direct initialization\n    IK_Direct,\n\n    /// Direct list-initialization\n    IK_DirectList,\n\n    /// Copy initialization\n    IK_Copy,\n\n    /// Default initialization\n    IK_Default,\n\n    /// Value initialization\n    IK_Value\n  };\n\nprivate:\n  /// The context of the initialization.\n  enum InitContext {\n    /// Normal context\n    IC_Normal,\n\n    /// Normal context, but allows explicit conversion functionss\n    IC_ExplicitConvs,\n\n    /// Implicit context (value initialization)\n    IC_Implicit,\n\n    /// Static cast context\n    IC_StaticCast,\n\n    /// C-style cast context\n    IC_CStyleCast,\n\n    /// Functional cast context\n    IC_FunctionalCast\n  };\n\n  /// The kind of initialization being performed.\n  InitKind Kind : 8;\n\n  /// The context of the initialization.\n  InitContext Context : 8;\n\n  /// The source locations involved in the initialization.\n  SourceLocation Locations[3];\n\n  InitializationKind(InitKind Kind, InitContext Context, SourceLocation Loc1,\n                     SourceLocation Loc2, SourceLocation Loc3)\n      : Kind(Kind), Context(Context) {\n    Locations[0] = Loc1;\n    Locations[1] = Loc2;\n    Locations[2] = Loc3;\n  }\n\npublic:\n  /// Create a direct initialization.\n  static InitializationKind CreateDirect(SourceLocation InitLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation RParenLoc) {\n    return InitializationKind(IK_Direct, IC_Normal,\n                              InitLoc, LParenLoc, RParenLoc);\n  }\n\n  static InitializationKind CreateDirectList(SourceLocation InitLoc) {\n    return InitializationKind(IK_DirectList, IC_Normal, InitLoc, InitLoc,\n                              InitLoc);\n  }\n\n  static InitializationKind CreateDirectList(SourceLocation InitLoc,\n                                             SourceLocation LBraceLoc,\n                                             SourceLocation RBraceLoc) {\n    return InitializationKind(IK_DirectList, IC_Normal, InitLoc, LBraceLoc,\n                              RBraceLoc);\n  }\n\n  /// Create a direct initialization due to a cast that isn't a C-style\n  /// or functional cast.\n  static InitializationKind CreateCast(SourceRange TypeRange) {\n    return InitializationKind(IK_Direct, IC_StaticCast, TypeRange.getBegin(),\n                              TypeRange.getBegin(), TypeRange.getEnd());\n  }\n\n  /// Create a direct initialization for a C-style cast.\n  static InitializationKind CreateCStyleCast(SourceLocation StartLoc,\n                                             SourceRange TypeRange,\n                                             bool InitList) {\n    // C++ cast syntax doesn't permit init lists, but C compound literals are\n    // exactly that.\n    return InitializationKind(InitList ? IK_DirectList : IK_Direct,\n                              IC_CStyleCast, StartLoc, TypeRange.getBegin(),\n                              TypeRange.getEnd());\n  }\n\n  /// Create a direct initialization for a functional cast.\n  static InitializationKind CreateFunctionalCast(SourceRange TypeRange,\n                                                 bool InitList) {\n    return InitializationKind(InitList ? IK_DirectList : IK_Direct,\n                              IC_FunctionalCast, TypeRange.getBegin(),\n                              TypeRange.getBegin(), TypeRange.getEnd());\n  }\n\n  /// Create a copy initialization.\n  static InitializationKind CreateCopy(SourceLocation InitLoc,\n                                       SourceLocation EqualLoc,\n                                       bool AllowExplicitConvs = false) {\n    return InitializationKind(IK_Copy,\n                              AllowExplicitConvs? IC_ExplicitConvs : IC_Normal,\n                              InitLoc, EqualLoc, EqualLoc);\n  }\n\n  /// Create a default initialization.\n  static InitializationKind CreateDefault(SourceLocation InitLoc) {\n    return InitializationKind(IK_Default, IC_Normal, InitLoc, InitLoc, InitLoc);\n  }\n\n  /// Create a value initialization.\n  static InitializationKind CreateValue(SourceLocation InitLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation RParenLoc,\n                                        bool isImplicit = false) {\n    return InitializationKind(IK_Value, isImplicit ? IC_Implicit : IC_Normal,\n                              InitLoc, LParenLoc, RParenLoc);\n  }\n\n  /// Create an initialization from an initializer (which, for direct\n  /// initialization from a parenthesized list, will be a ParenListExpr).\n  static InitializationKind CreateForInit(SourceLocation Loc, bool DirectInit,\n                                          Expr *Init) {\n    if (!Init) return CreateDefault(Loc);\n    if (!DirectInit)\n      return CreateCopy(Loc, Init->getBeginLoc());\n    if (isa<InitListExpr>(Init))\n      return CreateDirectList(Loc, Init->getBeginLoc(), Init->getEndLoc());\n    return CreateDirect(Loc, Init->getBeginLoc(), Init->getEndLoc());\n  }\n\n  /// Determine the initialization kind.\n  InitKind getKind() const {\n    return Kind;\n  }\n\n  /// Determine whether this initialization is an explicit cast.\n  bool isExplicitCast() const {\n    return Context >= IC_StaticCast;\n  }\n\n  /// Determine whether this initialization is a static cast.\n  bool isStaticCast() const { return Context == IC_StaticCast; }\n\n  /// Determine whether this initialization is a C-style cast.\n  bool isCStyleOrFunctionalCast() const {\n    return Context >= IC_CStyleCast;\n  }\n\n  /// Determine whether this is a C-style cast.\n  bool isCStyleCast() const {\n    return Context == IC_CStyleCast;\n  }\n\n  /// Determine whether this is a functional-style cast.\n  bool isFunctionalCast() const {\n    return Context == IC_FunctionalCast;\n  }\n\n  /// Determine whether this initialization is an implicit\n  /// value-initialization, e.g., as occurs during aggregate\n  /// initialization.\n  bool isImplicitValueInit() const { return Context == IC_Implicit; }\n\n  /// Retrieve the location at which initialization is occurring.\n  SourceLocation getLocation() const { return Locations[0]; }\n\n  /// Retrieve the source range that covers the initialization.\n  SourceRange getRange() const {\n    return SourceRange(Locations[0], Locations[2]);\n  }\n\n  /// Retrieve the location of the equal sign for copy initialization\n  /// (if present).\n  SourceLocation getEqualLoc() const {\n    assert(Kind == IK_Copy && \"Only copy initialization has an '='\");\n    return Locations[1];\n  }\n\n  bool isCopyInit() const { return Kind == IK_Copy; }\n\n  /// Retrieve whether this initialization allows the use of explicit\n  ///        constructors.\n  bool AllowExplicit() const { return !isCopyInit(); }\n\n  /// Retrieve whether this initialization allows the use of explicit\n  /// conversion functions when binding a reference. If the reference is the\n  /// first parameter in a copy or move constructor, such conversions are\n  /// permitted even though we are performing copy-initialization.\n  bool allowExplicitConversionFunctionsInRefBinding() const {\n    return !isCopyInit() || Context == IC_ExplicitConvs;\n  }\n\n  /// Determine whether this initialization has a source range containing the\n  /// locations of open and closing parentheses or braces.\n  bool hasParenOrBraceRange() const {\n    return Kind == IK_Direct || Kind == IK_Value || Kind == IK_DirectList;\n  }\n\n  /// Retrieve the source range containing the locations of the open\n  /// and closing parentheses or braces for value, direct, and direct list\n  /// initializations.\n  SourceRange getParenOrBraceRange() const {\n    assert(hasParenOrBraceRange() && \"Only direct, value, and direct-list \"\n                                     \"initialization have parentheses or \"\n                                     \"braces\");\n    return SourceRange(Locations[1], Locations[2]);\n  }\n}",
  "id": "BLOCK-CPP-19877",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Initialization.h",
  "source_line": 580,
  "validation_status": "validated"
}