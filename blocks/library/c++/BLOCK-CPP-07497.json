{
  "code": "{\n\nclass ASTContext;\nclass NamedDecl;\n\n/// Represents an element in a path from a derived class to a\n/// base class.\n///\n/// Each step in the path references the link from a\n/// derived class to one of its direct base classes, along with a\n/// base \"number\" that identifies which base subobject of the\n/// original derived class we are referencing.\nstruct CXXBasePathElement {\n  /// The base specifier that states the link from a derived\n  /// class to a base class, which will be followed by this base\n  /// path element.\n  const CXXBaseSpecifier *Base;\n\n  /// The record decl of the class that the base is a base of.\n  const CXXRecordDecl *Class;\n\n  /// Identifies which base class subobject (of type\n  /// \\c Base->getType()) this base path element refers to.\n  ///\n  /// This value is only valid if \\c !Base->isVirtual(), because there\n  /// is no base numbering for the zero or one virtual bases of a\n  /// given type.\n  int SubobjectNumber;\n};\n\n/// Represents a path from a specific derived class\n/// (which is not represented as part of the path) to a particular\n/// (direct or indirect) base class subobject.\n///\n/// Individual elements in the path are described by the \\c CXXBasePathElement\n/// structure, which captures both the link from a derived class to one of its\n/// direct bases and identification describing which base class\n/// subobject is being used.\nclass CXXBasePath : public SmallVector<CXXBasePathElement, 4> {\npublic:\n  /// The access along this inheritance path.  This is only\n  /// calculated when recording paths.  AS_none is a special value\n  /// used to indicate a path which permits no legal access.\n  AccessSpecifier Access = AS_public;\n\n  CXXBasePath() = default;\n\n  /// The declarations found inside this base class subobject.\n  DeclContext::lookup_iterator Decls;\n\n  void clear() {\n    SmallVectorImpl<CXXBasePathElement>::clear();\n    Access = AS_public;\n  }\n};\n\n/// BasePaths - Represents the set of paths from a derived class to\n/// one of its (direct or indirect) bases. For example, given the\n/// following class hierarchy:\n///\n/// @code\n/// class A { };\n/// class B : public A { };\n/// class C : public A { };\n/// class D : public B, public C{ };\n/// @endcode\n///\n/// There are two potential BasePaths to represent paths from D to a\n/// base subobject of type A. One path is (D,0) -> (B,0) -> (A,0)\n/// and another is (D,0)->(C,0)->(A,1). These two paths actually\n/// refer to two different base class subobjects of the same type,\n/// so the BasePaths object refers to an ambiguous path. On the\n/// other hand, consider the following class hierarchy:\n///\n/// @code\n/// class A { };\n/// class B : public virtual A { };\n/// class C : public virtual A { };\n/// class D : public B, public C{ };\n/// @endcode\n///\n/// Here, there are two potential BasePaths again, (D, 0) -> (B, 0)\n/// -> (A,v) and (D, 0) -> (C, 0) -> (A, v), but since both of them\n/// refer to the same base class subobject of type A (the virtual\n/// one), there is no ambiguity.\nclass CXXBasePaths {\n  friend class CXXRecordDecl;\n\n  /// The type from which this search originated.\n  const CXXRecordDecl *Origin = nullptr;\n\n  /// Paths - The actual set of paths that can be taken from the\n  /// derived class to the same base class.\n  std::list<CXXBasePath> Paths;\n\n  /// ClassSubobjects - Records the class subobjects for each class\n  /// type that we've seen. The first element IsVirtBase says\n  /// whether we found a path to a virtual base for that class type,\n  /// while NumberOfNonVirtBases contains the number of non-virtual base\n  /// class subobjects for that class type. The key of the map is\n  /// the cv-unqualified canonical type of the base class subobject.\n  struct IsVirtBaseAndNumberNonVirtBases {\n    unsigned IsVirtBase : 1;\n    unsigned NumberOfNonVirtBases : 31;\n  };\n  llvm::SmallDenseMap<QualType, IsVirtBaseAndNumberNonVirtBases, 8>\n      ClassSubobjects;\n\n  /// VisitedDependentRecords - Records the dependent records that have been\n  /// already visited.\n  llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedDependentRecords;\n\n  /// DetectedVirtual - The base class that is virtual.\n  const RecordType *DetectedVirtual = nullptr;\n\n  /// ScratchPath - A BasePath that is used by Sema::lookupInBases\n  /// to help build the set of paths.\n  CXXBasePath ScratchPath;\n\n  /// FindAmbiguities - Whether Sema::IsDerivedFrom should try find\n  /// ambiguous paths while it is looking for a path from a derived\n  /// type to a base type.\n  bool FindAmbiguities;\n\n  /// RecordPaths - Whether Sema::IsDerivedFrom should record paths\n  /// while it is determining whether there are paths from a derived\n  /// type to a base type.\n  bool RecordPaths;\n\n  /// DetectVirtual - Whether Sema::IsDerivedFrom should abort the search\n  /// if it finds a path that goes across a virtual base. The virtual class\n  /// is also recorded.\n  bool DetectVirtual;\n\n  bool lookupInBases(ASTContext &Context, const CXXRecordDecl *Record,\n                     CXXRecordDecl::BaseMatchesCallback BaseMatches,\n                     bool LookupInDependent = false);\n\npublic:\n  using paths_iterator = std::list<CXXBasePath>::iterator;\n  using const_paths_iterator = std::list<CXXBasePath>::const_iterator;\n  using decl_iterator = NamedDecl **;\n\n  /// BasePaths - Construct a new BasePaths structure to record the\n  /// paths for a derived-to-base search.\n  explicit CXXBasePaths(bool FindAmbiguities = true, bool RecordPaths = true,\n                        bool DetectVirtual = true)\n      : FindAmbiguities(FindAmbiguities), RecordPaths(RecordPaths),\n        DetectVirtual(DetectVirtual) {}\n\n  paths_iterator begin() { return Paths.begin(); }\n  paths_iterator end()   { return Paths.end(); }\n  const_paths_iterator begin() const { return Paths.begin(); }\n  const_paths_iterator end()   const { return Paths.end(); }\n\n  CXXBasePath&       front()       { return Paths.front(); }\n  const CXXBasePath& front() const { return Paths.front(); }\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// Determine whether the path from the most-derived type to the\n  /// given base type is ambiguous (i.e., it refers to multiple subobjects of\n  /// the same base type).\n  bool isAmbiguous(CanQualType BaseType);\n\n  /// Whether we are finding multiple paths to detect ambiguities.\n  bool isFindingAmbiguities() const { return FindAmbiguities; }\n\n  /// Whether we are recording paths.\n  bool isRecordingPaths() const { return RecordPaths; }\n\n  /// Specify whether we should be recording paths or not.\n  void setRecordingPaths(bool RP) { RecordPaths = RP; }\n\n  /// Whether we are detecting virtual bases.\n  bool isDetectingVirtual() const { return DetectVirtual; }\n\n  /// The virtual base discovered on the path (if we are merely\n  /// detecting virtuals).\n  const RecordType* getDetectedVirtual() const {\n    return DetectedVirtual;\n  }\n\n  /// Retrieve the type from which this base-paths search\n  /// began\n  const CXXRecordDecl *getOrigin() const { return Origin; }\n  void setOrigin(const CXXRecordDecl *Rec) { Origin = Rec; }\n\n  /// Clear the base-paths results.\n  void clear();\n\n  /// Swap this data structure's contents with another CXXBasePaths\n  /// object.\n  void swap(CXXBasePaths &Other);\n};\n\n/// Uniquely identifies a virtual method within a class\n/// hierarchy by the method itself and a class subobject number.\nstruct UniqueVirtualMethod {\n  /// The overriding virtual method.\n  CXXMethodDecl *Method = nullptr;\n\n  /// The subobject in which the overriding virtual method\n  /// resides.\n  unsigned Subobject = 0;\n\n  /// The virtual base class subobject of which this overridden\n  /// virtual method is a part. Note that this records the closest\n  /// derived virtual base class subobject.\n  const CXXRecordDecl *InVirtualSubobject = nullptr;\n\n  UniqueVirtualMethod() = default;\n\n  UniqueVirtualMethod(CXXMethodDecl *Method, unsigned Subobject,\n                      const CXXRecordDecl *InVirtualSubobject)\n      : Method(Method), Subobject(Subobject),\n        InVirtualSubobject(InVirtualSubobject) {}\n\n  friend bool operator==(const UniqueVirtualMethod &X,\n                         const UniqueVirtualMethod &Y) {\n    return X.Method == Y.Method && X.Subobject == Y.Subobject &&\n      X.InVirtualSubobject == Y.InVirtualSubobject;\n  }\n\n  friend bool operator!=(const UniqueVirtualMethod &X,\n                         const UniqueVirtualMethod &Y) {\n    return !(X == Y);\n  }\n};\n\n/// The set of methods that override a given virtual method in\n/// each subobject where it occurs.\n///\n/// The first part of the pair is the subobject in which the\n/// overridden virtual function occurs, while the second part of the\n/// pair is the virtual method that overrides it (including the\n/// subobject in which that virtual function occurs).\nclass OverridingMethods {\n  using ValuesT = SmallVector<UniqueVirtualMethod, 4>;\n  using MapType = llvm::MapVector<unsigned, ValuesT>;\n\n  MapType Overrides;\n\npublic:\n  // Iterate over the set of subobjects that have overriding methods.\n  using iterator = MapType::iterator;\n  using const_iterator = MapType::const_iterator;\n\n  iterator begin() { return Overrides.begin(); }\n  const_iterator begin() const { return Overrides.begin(); }\n  iterator end() { return Overrides.end(); }\n  const_iterator end() const { return Overrides.end(); }\n  unsigned size() const { return Overrides.size(); }\n\n  // Iterate over the set of overriding virtual methods in a given\n  // subobject.\n  using overriding_iterator =\n      SmallVectorImpl<UniqueVirtualMethod>::iterator;\n  using overriding_const_iterator =\n      SmallVectorImpl<UniqueVirtualMethod>::const_iterator;\n\n  // Add a new overriding method for a particular subobject.\n  void add(unsigned OverriddenSubobject, UniqueVirtualMethod Overriding);\n\n  // Add all of the overriding methods from \"other\" into overrides for\n  // this method. Used when merging the overrides from multiple base\n  // class subobjects.\n  void add(const OverridingMethods &Other);\n\n  // Replace all overriding virtual methods in all subobjects with the\n  // given virtual method.\n  void replaceAll(UniqueVirtualMethod Overriding);\n};\n\n/// A mapping from each virtual member function to its set of\n/// final overriders.\n///\n/// Within a class hierarchy for a given derived class, each virtual\n/// member function in that hierarchy has one or more \"final\n/// overriders\" (C++ [class.virtual]p2). A final overrider for a\n/// virtual function \"f\" is the virtual function that will actually be\n/// invoked when dispatching a call to \"f\" through the\n/// vtable. Well-formed classes have a single final overrider for each\n/// virtual function; in abstract classes, the final overrider for at\n/// least one virtual function is a pure virtual function. Due to\n/// multiple, virtual inheritance, it is possible for a class to have\n/// more than one final overrider. Although this is an error (per C++\n/// [class.virtual]p2), it is not considered an error here: the final\n/// overrider map can represent multiple final overriders for a\n/// method, and it is up to the client to determine whether they are\n/// problem. For example, the following class \\c D has two final\n/// overriders for the virtual function \\c A::f(), one in \\c C and one\n/// in \\c D:\n///\n/// \\code\n///   struct A { virtual void f(); };\n///   struct B : virtual A { virtual void f(); };\n///   struct C : virtual A { virtual void f(); };\n///   struct D : B, C { };\n/// \\endcode\n///\n/// This data structure contains a mapping from every virtual\n/// function *that does not override an existing virtual function* and\n/// in every subobject where that virtual function occurs to the set\n/// of virtual functions that override it. Thus, the same virtual\n/// function \\c A::f can actually occur in multiple subobjects of type\n/// \\c A due to multiple inheritance, and may be overridden by\n/// different virtual functions in each, as in the following example:\n///\n/// \\code\n///   struct A { virtual void f(); };\n///   struct B : A { virtual void f(); };\n///   struct C : A { virtual void f(); };\n///   struct D : B, C { };\n/// \\endcode\n///\n/// Unlike in the previous example, where the virtual functions \\c\n/// B::f and \\c C::f both overrode \\c A::f in the same subobject of\n/// type \\c A, in this example the two virtual functions both override\n/// \\c A::f but in *different* subobjects of type A. This is\n/// represented by numbering the subobjects in which the overridden\n/// and the overriding virtual member functions are located. Subobject\n/// 0 represents the virtual base class subobject of that type, while\n/// subobject numbers greater than 0 refer to non-virtual base class\n/// subobjects of that type.\nclass CXXFinalOverriderMap\n  : public llvm::MapVector<const CXXMethodDecl *, OverridingMethods> {};\n\n/// A set of all the primary bases for a class.\nclass CXXIndirectPrimaryBaseSet\n  : public llvm::SmallSet<const CXXRecordDecl*, 32> {};\n\ninline bool\ninheritanceModelHasVBPtrOffsetField(MSInheritanceModel Inheritance) {\n  return Inheritance == MSInheritanceModel::Unspecified;\n}\n\n// Only member pointers to functions need a this adjustment, since it can be\n// combined with the field offset for data pointers.\ninline bool inheritanceModelHasNVOffsetField(bool IsMemberFunction,\n                                             MSInheritanceModel Inheritance) {\n  return IsMemberFunction && Inheritance >= MSInheritanceModel::Multiple;\n}\n\ninline bool\ninheritanceModelHasVBTableOffsetField(MSInheritanceModel Inheritance) {\n  return Inheritance >= MSInheritanceModel::Virtual;\n}\n\ninline bool inheritanceModelHasOnlyOneField(bool IsMemberFunction,\n                                            MSInheritanceModel Inheritance) {\n  if (IsMemberFunction)\n    return Inheritance <= MSInheritanceModel::Single;\n  return Inheritance <= MSInheritanceModel::Multiple;\n}\n\n}",
  "id": "BLOCK-CPP-07497",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/CXXInheritance.h",
  "source_line": 32,
  "validation_status": "validated"
}