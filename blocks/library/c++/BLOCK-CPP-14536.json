{
  "code": "{\n  friend class TypeLoc;\n\n  const Derived *asDerived() const {\n    return static_cast<const Derived*>(this);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\npublic:\n  unsigned getLocalDataAlignment() const {\n    return std::max(unsigned(alignof(LocalData)),\n                    asDerived()->getExtraLocalDataAlignment());\n  }\n\n  unsigned getLocalDataSize() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    size += asDerived()->getExtraLocalDataSize();\n    return size;\n  }\n\n  void copyLocal(Derived other) {\n    // Some subclasses have no data to copy.\n    if (asDerived()->getLocalDataSize() == 0) return;\n\n    // Copy the fixed-sized local data.\n    memcpy(getLocalData(), other.getLocalData(), sizeof(LocalData));\n\n    // Copy the variable-sized local data. We need to do this\n    // separately because the padding in the source and the padding in\n    // the destination might be different.\n    memcpy(getExtraLocalData(), other.getExtraLocalData(),\n           asDerived()->getExtraLocalDataSize());\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLoc(asDerived()->getInnerType());\n  }\n\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n\nprotected:\n  unsigned getExtraLocalDataSize() const {\n    return 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return 1;\n  }\n\n  LocalData *getLocalData() const {\n    return static_cast<LocalData*>(Base::Data);\n  }\n\n  /// Gets a pointer past the Info structure; useful for classes with\n  /// local data that can't be captured in the Info (e.g. because it's\n  /// of variable size).\n  void *getExtraLocalData() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    return reinterpret_cast<char *>(Base::Data) + size;\n  }\n\n  void *getNonLocalData() const {\n    auto data = reinterpret_cast<uintptr_t>(Base::Data);\n    data += asDerived()->getLocalDataSize();\n    data = llvm::alignTo(data, getNextTypeAlign());\n    return reinterpret_cast<void*>(data);\n  }\n\n  struct HasNoInnerType {};\n  HasNoInnerType getInnerType() const { return HasNoInnerType(); }\n\n  TypeLoc getInnerTypeLoc() const {\n    return TypeLoc(asDerived()->getInnerType(), getNonLocalData());\n  }\n\nprivate:\n  unsigned getInnerTypeSize() const {\n    return getInnerTypeSize(asDerived()->getInnerType());\n  }\n\n  unsigned getInnerTypeSize(HasNoInnerType _) const {\n    return 0;\n  }\n\n  unsigned getInnerTypeSize(QualType _) const {\n    return getInnerTypeLoc().getFullDataSize();\n  }\n\n  unsigned getNextTypeAlign() const {\n    return getNextTypeAlign(asDerived()->getInnerType());\n  }\n\n  unsigned getNextTypeAlign(HasNoInnerType _) const {\n    return 1;\n  }\n\n  unsigned getNextTypeAlign(QualType T) const {\n    return TypeLoc::getLocalAlignmentForType(T);\n  }\n\n  TypeLoc getNextTypeLoc(HasNoInnerType _) const { return {}; }\n\n  TypeLoc getNextTypeLoc(QualType T) const {\n    return TypeLoc(T, getNonLocalData());\n  }\n}",
  "id": "BLOCK-CPP-14536",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TypeLoc.h",
  "source_line": 365,
  "validation_status": "validated"
}