{
  "code": "{\n  ///     void f();\n  ///   };\n  /// };\n  /// \\endcode\n  ///\n  /// When instantiating X<int>::Y<17>::f, the multi-level template argument\n  /// list will contain a template argument list (int) at depth 0 and a\n  /// template argument list (17) at depth 1.\n  class MultiLevelTemplateArgumentList {\n    /// The template argument list at a certain template depth\n\n    using ArgList = ArrayRef<TemplateArgument>;\n    struct ArgumentListLevel {\n      llvm::PointerIntPair<Decl *, 1, bool> AssociatedDeclAndFinal;\n      ArgList Args;\n    };\n    using ContainerType = SmallVector<ArgumentListLevel, 4>;\n\n    using ArgListsIterator = ContainerType::iterator;\n    using ConstArgListsIterator = ContainerType::const_iterator;\n\n    /// The template argument lists, stored from the innermost template\n    /// argument list (first) to the outermost template argument list (last).\n    ContainerType TemplateArgumentLists;\n\n    /// The number of outer levels of template arguments that are not\n    /// being substituted.\n    unsigned NumRetainedOuterLevels = 0;\n\n    /// The kind of substitution described by this argument list.\n    TemplateSubstitutionKind Kind = TemplateSubstitutionKind::Specialization;\n\n  public:\n    /// Construct an empty set of template argument lists.\n    MultiLevelTemplateArgumentList() = default;\n\n    /// Construct a single-level template argument list.\n    MultiLevelTemplateArgumentList(Decl *D, ArgList Args, bool Final) {\n      addOuterTemplateArguments(D, Args, Final);\n    }\n\n    void setKind(TemplateSubstitutionKind K) { Kind = K; }\n\n    /// Determine the kind of template substitution being performed.\n    TemplateSubstitutionKind getKind() const { return Kind; }\n\n    /// Determine whether we are rewriting template parameters rather than\n    /// substituting for them. If so, we should not leave references to the\n    /// original template parameters behind.\n    bool isRewrite() const {\n      return Kind == TemplateSubstitutionKind::Rewrite;\n    }\n\n    /// Determine the number of levels in this template argument\n    /// list.\n    unsigned getNumLevels() const {\n      return TemplateArgumentLists.size() + NumRetainedOuterLevels;\n    }\n\n    /// Determine the number of substituted levels in this template\n    /// argument list.\n    unsigned getNumSubstitutedLevels() const {\n      return TemplateArgumentLists.size();\n    }\n\n    // Determine the number of substituted args at 'Depth'.\n    unsigned getNumSubsitutedArgs(unsigned Depth) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size();\n    }\n\n    unsigned getNumRetainedOuterLevels() const {\n      return NumRetainedOuterLevels;\n    }\n\n    /// Determine how many of the \\p OldDepth outermost template parameter\n    /// lists would be removed by substituting these arguments.\n    unsigned getNewDepth(unsigned OldDepth) const {\n      if (OldDepth < NumRetainedOuterLevels)\n        return OldDepth;\n      if (OldDepth < getNumLevels())\n        return NumRetainedOuterLevels;\n      return OldDepth - TemplateArgumentLists.size();\n    }\n\n    /// Retrieve the template argument at a given depth and index.\n    const TemplateArgument &operator()(unsigned Depth, unsigned Index) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index <\n             TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1].Args[Index];\n    }\n\n    /// A template-like entity which owns the whole pattern being substituted.\n    /// This will usually own a set of template parameters, or in some\n    /// cases might even be a template parameter itself.\n    std::pair<Decl *, bool> getAssociatedDecl(unsigned Depth) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      auto AD = TemplateArgumentLists[getNumLevels() - Depth - 1]\n                    .AssociatedDeclAndFinal;\n      return {AD.getPointer(), AD.getInt()};\n    }\n\n    /// Determine whether there is a non-NULL template argument at the\n    /// given depth and index.\n    ///\n    /// There must exist a template argument list at the given depth.\n    bool hasTemplateArgument(unsigned Depth, unsigned Index) const {\n      assert(Depth < getNumLevels());\n\n      if (Depth < NumRetainedOuterLevels)\n        return false;\n\n      if (Index >=\n          TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size())\n        return false;\n\n      return !(*this)(Depth, Index).isNull();\n    }\n\n    bool isAnyArgInstantiationDependent() const {\n      for (ArgumentListLevel ListLevel : TemplateArgumentLists)\n        for (const TemplateArgument &TA : ListLevel.Args)\n          if (TA.isInstantiationDependent())\n            return true;\n      return false;\n    }\n\n    /// Clear out a specific template argument.\n    void setArgument(unsigned Depth, unsigned Index,\n                     TemplateArgument Arg) {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index <\n             TemplateArgumentLists[getNumLevels() - Depth - 1].Args.size());\n      const_cast<TemplateArgument &>(\n          TemplateArgumentLists[getNumLevels() - Depth - 1].Args[Index]) = Arg;\n    }\n\n    /// Add a new outmost level to the multi-level template argument\n    /// list.\n    /// A 'Final' substitution means that Subst* nodes won't be built\n    /// for the replacements.\n    void addOuterTemplateArguments(Decl *AssociatedDecl, ArgList Args,\n                                   bool Final) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      assert(getKind() == TemplateSubstitutionKind::Specialization);\n      TemplateArgumentLists.push_back(\n          {{AssociatedDecl->getCanonicalDecl(), Final}, Args});\n    }\n\n    void addOuterTemplateArguments(ArgList Args) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      assert(getKind() == TemplateSubstitutionKind::Rewrite);\n      TemplateArgumentLists.push_back({{}, Args});\n    }\n\n    void addOuterTemplateArguments(std::nullopt_t) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      TemplateArgumentLists.push_back({});\n    }\n\n    /// Replaces the current 'innermost' level with the provided argument list.\n    /// This is useful for type deduction cases where we need to get the entire\n    /// list from the AST, but then add the deduced innermost list.\n    void replaceInnermostTemplateArguments(Decl *AssociatedDecl, ArgList Args) {\n      assert((!TemplateArgumentLists.empty() || NumRetainedOuterLevels) &&\n             \"Replacing in an empty list?\");\n\n      if (!TemplateArgumentLists.empty()) {\n        assert((TemplateArgumentLists[0].AssociatedDeclAndFinal.getPointer() ||\n                TemplateArgumentLists[0].AssociatedDeclAndFinal.getPointer() ==\n                    AssociatedDecl) &&\n               \"Trying to change incorrect declaration?\");\n        TemplateArgumentLists[0].Args = Args;\n      } else {\n        --NumRetainedOuterLevels;\n        TemplateArgumentLists.push_back(\n            {{AssociatedDecl, /*Final=*/false}, Args});\n      }\n    }\n\n    /// Add an outermost level that we are not substituting. We have no\n    /// arguments at this level, and do not remove it from the depth of inner\n    /// template parameters that we instantiate.\n    void addOuterRetainedLevel() {\n      ++NumRetainedOuterLevels;\n    }\n    void addOuterRetainedLevels(unsigned Num) {\n      NumRetainedOuterLevels += Num;\n    }\n\n    /// Retrieve the innermost template argument list.\n    const ArgList &getInnermost() const {\n      return TemplateArgumentLists.front().Args;\n    }\n    /// Retrieve the outermost template argument list.\n    const ArgList &getOutermost() const {\n      return TemplateArgumentLists.back().Args;\n    }\n    ArgListsIterator begin() { return TemplateArgumentLists.begin(); }\n    ConstArgListsIterator begin() const {\n      return TemplateArgumentLists.begin();\n    }\n    ArgListsIterator end() { return TemplateArgumentLists.end(); }\n    ConstArgListsIterator end() const { return TemplateArgumentLists.end(); }\n\n    LLVM_DUMP_METHOD void dump() const {\n      LangOptions LO;\n      LO.CPlusPlus = true;\n      LO.Bool = true;\n      PrintingPolicy PP(LO);\n      llvm::errs() << \"NumRetainedOuterLevels: \" << NumRetainedOuterLevels\n                   << \"\\n\";\n      for (unsigned Depth = NumRetainedOuterLevels; Depth < getNumLevels();\n           ++Depth) {\n        llvm::errs() << Depth << \": \";\n        printTemplateArgumentList(\n            llvm::errs(),\n            TemplateArgumentLists[getNumLevels() - Depth - 1].Args, PP);\n        llvm::errs() << \"\\n\";\n      }\n    }\n  };\n\n  /// The context in which partial ordering of function templates occurs.\n  enum TPOC {\n    /// Partial ordering of function templates for a function call.\n    TPOC_Call,\n\n    /// Partial ordering of function templates for a call to a\n    /// conversion function.\n    TPOC_Conversion,\n\n    /// Partial ordering of function templates in other contexts, e.g.,\n    /// taking the address of a function template or matching a function\n    /// template specialization to a function template.\n    TPOC_Other\n  };\n\n  // This is lame but unavoidable in a world without forward\n  // declarations of enums.  The alternatives are to either pollute\n  // Sema.h (by including this file) or sacrifice type safety (by\n  // making Sema.h declare things as enums).\n  class TemplatePartialOrderingContext {\n    TPOC Value;\n\n  public:\n    TemplatePartialOrderingContext(TPOC Value) : Value(Value) {}\n\n    operator TPOC() const { return Value; }\n  };\n\n  /// Captures a template argument whose value has been deduced\n  /// via c++ template argument deduction.\n  class DeducedTemplateArgument : public TemplateArgument {\n    /// For a non-type template argument, whether the value was\n    /// deduced from an array bound.\n    bool DeducedFromArrayBound = false;\n\n  public:\n    DeducedTemplateArgument() = default;\n\n    DeducedTemplateArgument(const TemplateArgument &Arg,\n                            bool DeducedFromArrayBound = false)\n        : TemplateArgument(Arg), DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// Construct an integral non-type template argument that\n    /// has been deduced, possibly from an array bound.\n    DeducedTemplateArgument(ASTContext &Ctx,\n                            const llvm::APSInt &Value,\n                            QualType ValueType,\n                            bool DeducedFromArrayBound)\n        : TemplateArgument(Ctx, Value, ValueType),\n          DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// For a non-type template argument, determine whether the\n    /// template argument was deduced from an array bound.\n    bool wasDeducedFromArrayBound() const { return DeducedFromArrayBound; }\n\n    /// Specify whether the given non-type template argument\n    /// was deduced from an array bound.\n    void setDeducedFromArrayBound(bool Deduced) {\n      DeducedFromArrayBound = Deduced;\n    }\n  };\n\n  /// A stack-allocated class that identifies which local\n  /// variable declaration instantiations are present in this scope.\n  ///\n  /// A new instance of this class type will be created whenever we\n  /// instantiate a new function declaration, which will have its own\n  /// set of parameter declarations.\n  class LocalInstantiationScope {\n  public:\n    /// A set of declarations.\n    using DeclArgumentPack = SmallVector<VarDecl *, 4>;\n\n  private:\n    /// Reference to the semantic analysis that is performing\n    /// this template instantiation.\n    Sema &SemaRef;\n\n    using LocalDeclsMap =\n        llvm::SmallDenseMap<const Decl *,\n                            llvm::PointerUnion<Decl *, DeclArgumentPack *>, 4>;\n\n    /// A mapping from local declarations that occur\n    /// within a template to their instantiations.\n    ///\n    /// This mapping is used during instantiation to keep track of,\n    /// e.g., function parameter and variable declarations. For example,\n    /// given:\n    ///\n    /// \\code\n    ///   template<typename T> T add(T x, T y) { return x + y; }\n    /// \\endcode\n    ///\n    /// when we instantiate add<int>, we will introduce a mapping from\n    /// the ParmVarDecl for 'x' that occurs in the template to the\n    /// instantiated ParmVarDecl for 'x'.\n    ///\n    /// For a parameter pack, the local instantiation scope may contain a\n    /// set of instantiated parameters. This is stored as a DeclArgumentPack\n    /// pointer.\n    LocalDeclsMap LocalDecls;\n\n    /// The set of argument packs we've allocated.\n    SmallVector<DeclArgumentPack *, 1> ArgumentPacks;\n\n    /// The outer scope, which contains local variable\n    /// definitions from some other instantiation (that may not be\n    /// relevant to this particular scope).\n    LocalInstantiationScope *Outer;\n\n    /// Whether we have already exited this scope.\n    bool Exited = false;\n\n    /// Whether to combine this scope with the outer scope, such that\n    /// lookup will search our outer scope.\n    bool CombineWithOuterScope;\n\n    /// If non-NULL, the template parameter pack that has been\n    /// partially substituted per C++0x [temp.arg.explicit]p9.\n    NamedDecl *PartiallySubstitutedPack = nullptr;\n\n    /// If \\c PartiallySubstitutedPack is non-null, the set of\n    /// explicitly-specified template arguments in that pack.\n    const TemplateArgument *ArgsInPartiallySubstitutedPack;\n\n    /// If \\c PartiallySubstitutedPack, the number of\n    /// explicitly-specified template arguments in\n    /// ArgsInPartiallySubstitutedPack.\n    unsigned NumArgsInPartiallySubstitutedPack;\n\n  public:\n    LocalInstantiationScope(Sema &SemaRef, bool CombineWithOuterScope = false)\n        : SemaRef(SemaRef), Outer(SemaRef.CurrentInstantiationScope),\n          CombineWithOuterScope(CombineWithOuterScope) {\n      SemaRef.CurrentInstantiationScope = this;\n    }\n\n    LocalInstantiationScope(const LocalInstantiationScope &) = delete;\n    LocalInstantiationScope &\n    operator=(const LocalInstantiationScope &) = delete;\n\n    ~LocalInstantiationScope() {\n      Exit();\n    }\n\n    const Sema &getSema() const { return SemaRef; }\n\n    /// Exit this local instantiation scope early.\n    void Exit() {\n      if (Exited)\n        return;\n\n      for (unsigned I = 0, N = ArgumentPacks.size(); I != N; ++I)\n        delete ArgumentPacks[I];\n\n      SemaRef.CurrentInstantiationScope = Outer;\n      Exited = true;\n    }\n\n    /// Clone this scope, and all outer scopes, down to the given\n    /// outermost scope.\n    LocalInstantiationScope *cloneScopes(LocalInstantiationScope *Outermost) {\n      if (this == Outermost) return this;\n\n      // Save the current scope from SemaRef since the LocalInstantiationScope\n      // will overwrite it on construction\n      LocalInstantiationScope *oldScope = SemaRef.CurrentInstantiationScope;\n\n      LocalInstantiationScope *newScope =\n        new LocalInstantiationScope(SemaRef, CombineWithOuterScope);\n\n      newScope->Outer = nullptr;\n      if (Outer)\n        newScope->Outer = Outer->cloneScopes(Outermost);\n\n      newScope->PartiallySubstitutedPack = PartiallySubstitutedPack;\n      newScope->ArgsInPartiallySubstitutedPack = ArgsInPartiallySubstitutedPack;\n      newScope->NumArgsInPartiallySubstitutedPack =\n        NumArgsInPartiallySubstitutedPack;\n\n      for (LocalDeclsMap::iterator I = LocalDecls.begin(), E = LocalDecls.end();\n           I != E; ++I) {\n        const Decl *D = I->first;\n        llvm::PointerUnion<Decl *, DeclArgumentPack *> &Stored =\n          newScope->LocalDecls[D];\n        if (I->second.is<Decl *>()) {\n          Stored = I->second.get<Decl *>();\n        } else {\n          DeclArgumentPack *OldPack = I->second.get<DeclArgumentPack *>();\n          DeclArgumentPack *NewPack = new DeclArgumentPack(*OldPack);\n          Stored = NewPack;\n          newScope->ArgumentPacks.push_back(NewPack);\n        }\n      }\n      // Restore the saved scope to SemaRef\n      SemaRef.CurrentInstantiationScope = oldScope;\n      return newScope;\n    }\n\n    /// deletes the given scope, and all outer scopes, down to the\n    /// given outermost scope.\n    static void deleteScopes(LocalInstantiationScope *Scope,\n                             LocalInstantiationScope *Outermost) {\n      while (Scope && Scope != Outermost) {\n        LocalInstantiationScope *Out = Scope->Outer;\n        delete Scope;\n        Scope = Out;\n      }\n    }\n\n    /// Find the instantiation of the declaration D within the current\n    /// instantiation scope.\n    ///\n    /// \\param D The declaration whose instantiation we are searching for.\n    ///\n    /// \\returns A pointer to the declaration or argument pack of declarations\n    /// to which the declaration \\c D is instantiated, if found. Otherwise,\n    /// returns NULL.\n    llvm::PointerUnion<Decl *, DeclArgumentPack *> *\n    findInstantiationOf(const Decl *D);\n\n    void InstantiatedLocal(const Decl *D, Decl *Inst);\n    void InstantiatedLocalPackArg(const Decl *D, VarDecl *Inst);\n    void MakeInstantiatedLocalArgPack(const Decl *D);\n\n    /// Note that the given parameter pack has been partially substituted\n    /// via explicit specification of template arguments\n    /// (C++0x [temp.arg.explicit]p9).\n    ///\n    /// \\param Pack The parameter pack, which will always be a template\n    /// parameter pack.\n    ///\n    /// \\param ExplicitArgs The explicitly-specified template arguments provided\n    /// for this parameter pack.\n    ///\n    /// \\param NumExplicitArgs The number of explicitly-specified template\n    /// arguments provided for this parameter pack.\n    void SetPartiallySubstitutedPack(NamedDecl *Pack,\n                                     const TemplateArgument *ExplicitArgs,\n                                     unsigned NumExplicitArgs);\n\n    /// Reset the partially-substituted pack when it is no longer of\n    /// interest.\n    void ResetPartiallySubstitutedPack() {\n      assert(PartiallySubstitutedPack && \"No partially-substituted pack\");\n      PartiallySubstitutedPack = nullptr;\n      ArgsInPartiallySubstitutedPack = nullptr;\n      NumArgsInPartiallySubstitutedPack = 0;\n    }\n\n    /// Retrieve the partially-substitued template parameter pack.\n    ///\n    /// If there is no partially-substituted parameter pack, returns NULL.\n    NamedDecl *\n    getPartiallySubstitutedPack(const TemplateArgument **ExplicitArgs = nullptr,\n                                unsigned *NumExplicitArgs = nullptr) const;\n\n    /// Determine whether D is a pack expansion created in this scope.\n    bool isLocalPackExpansion(const Decl *D);\n  };\n\n  class TemplateDeclInstantiator\n    : public DeclVisitor<TemplateDeclInstantiator, Decl *>\n  {\n    Sema &SemaRef;\n    Sema::ArgumentPackSubstitutionIndexRAII SubstIndex;\n    DeclContext *Owner;\n    const MultiLevelTemplateArgumentList &TemplateArgs;\n    Sema::LateInstantiatedAttrVec* LateAttrs = nullptr;\n    LocalInstantiationScope *StartingScope = nullptr;\n    bool EvaluateConstraints = true;\n\n    /// A list of out-of-line class template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing class's instantiation is complete.\n    SmallVector<std::pair<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>, 4>\n      OutOfLinePartialSpecs;\n\n    /// A list of out-of-line variable template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing variable's instantiation is complete.\n    /// FIXME: Verify that this is needed.\n    SmallVector<\n        std::pair<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>, 4>\n    OutOfLineVarPartialSpecs;\n\n  public:\n    TemplateDeclInstantiator(Sema &SemaRef, DeclContext *Owner,\n                             const MultiLevelTemplateArgumentList &TemplateArgs)\n        : SemaRef(SemaRef),\n          SubstIndex(SemaRef, SemaRef.ArgumentPackSubstitutionIndex),\n          Owner(Owner), TemplateArgs(TemplateArgs) {}\n\n    void setEvaluateConstraints(bool B) {\n      EvaluateConstraints = B;\n    }\n    bool getEvaluateConstraints() {\n      return EvaluateConstraints;\n    }\n\n// Define all the decl visitors using DeclNodes.inc\n#define DECL(DERIVED, BASE) \\\n    Decl *Visit ## DERIVED ## Decl(DERIVED ## Decl *D);\n#define ABSTRACT_DECL(DECL)\n\n// Decls which never appear inside a class or function.\n#define OBJCCONTAINER(DERIVED, BASE)\n#define FILESCOPEASM(DERIVED, BASE)\n#define TOPLEVELSTMT(DERIVED, BASE)\n#define IMPORT(DERIVED, BASE)\n#define EXPORT(DERIVED, BASE)\n#define LINKAGESPEC(DERIVED, BASE)\n#define OBJCCOMPATIBLEALIAS(DERIVED, BASE)\n#define OBJCMETHOD(DERIVED, BASE)\n#define OBJCTYPEPARAM(DERIVED, BASE)\n#define OBJCIVAR(DERIVED, BASE)\n#define OBJCPROPERTY(DERIVED, BASE)\n#define OBJCPROPERTYIMPL(DERIVED, BASE)\n#define EMPTY(DERIVED, BASE)\n#define LIFETIMEEXTENDEDTEMPORARY(DERIVED, BASE)\n\n    // Decls which use special-case instantiation code.\n#define BLOCK(DERIVED, BASE)\n#define CAPTURED(DERIVED, BASE)\n#define IMPLICITPARAM(DERIVED, BASE)\n\n#include \"clang/AST/DeclNodes.inc\"\n\n    enum class RewriteKind { None, RewriteSpaceshipAsEqualEqual };\n\n    void adjustForRewrite(RewriteKind RK, FunctionDecl *Orig, QualType &T,\n                          TypeSourceInfo *&TInfo,\n                          DeclarationNameInfo &NameInfo);\n\n    // A few supplemental visitor functions.\n    Decl *VisitCXXMethodDecl(CXXMethodDecl *D,\n                             TemplateParameterList *TemplateParams,\n                             std::optional<const ASTTemplateArgumentListInfo *>\n                                 ClassScopeSpecializationArgs = std::nullopt,\n                             RewriteKind RK = RewriteKind::None);\n    Decl *VisitFunctionDecl(FunctionDecl *D,\n                            TemplateParameterList *TemplateParams,\n                            RewriteKind RK = RewriteKind::None);\n    Decl *VisitDecl(Decl *D);\n    Decl *VisitVarDecl(VarDecl *D, bool InstantiatingVarTemplate,\n                       ArrayRef<BindingDecl *> *Bindings = nullptr);\n    Decl *VisitBaseUsingDecls(BaseUsingDecl *D, BaseUsingDecl *Inst,\n                              LookupResult *Lookup);\n\n    // Enable late instantiation of attributes.  Late instantiated attributes\n    // will be stored in LA.\n    void enableLateAttributeInstantiation(Sema::LateInstantiatedAttrVec *LA) {\n      LateAttrs = LA;\n      StartingScope = SemaRef.CurrentInstantiationScope;\n    }\n\n    // Disable late instantiation of attributes.\n    void disableLateAttributeInstantiation() {\n      LateAttrs = nullptr;\n      StartingScope = nullptr;\n    }\n\n    LocalInstantiationScope *getStartingScope() const { return StartingScope; }\n\n    using delayed_partial_spec_iterator = SmallVectorImpl<std::pair<\n      ClassTemplateDecl *, ClassTemplatePartialSpecializationDecl *>>::iterator;\n\n    using delayed_var_partial_spec_iterator = SmallVectorImpl<std::pair<\n        VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>>::iterator;\n\n    /// Return an iterator to the beginning of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_begin() {\n      return OutOfLinePartialSpecs.begin();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_begin() {\n      return OutOfLineVarPartialSpecs.begin();\n    }\n\n    /// Return an iterator to the end of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_end() {\n      return OutOfLinePartialSpecs.end();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_end() {\n      return OutOfLineVarPartialSpecs.end();\n    }\n\n    // Helper functions for instantiating methods.\n    TypeSourceInfo *SubstFunctionType(FunctionDecl *D,\n                             SmallVectorImpl<ParmVarDecl *> &Params);\n    bool InitFunctionInstantiation(FunctionDecl *New, FunctionDecl *Tmpl);\n    bool InitMethodInstantiation(CXXMethodDecl *New, CXXMethodDecl *Tmpl);\n\n    bool SubstDefaultedFunction(FunctionDecl *New, FunctionDecl *Tmpl);\n\n    TemplateParameterList *\n      SubstTemplateParams(TemplateParameterList *List);\n\n    bool SubstQualifier(const DeclaratorDecl *OldDecl,\n                        DeclaratorDecl *NewDecl);\n    bool SubstQualifier(const TagDecl *OldDecl,\n                        TagDecl *NewDecl);\n\n    Decl *VisitVarTemplateSpecializationDecl(\n        VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n        const TemplateArgumentListInfo &TemplateArgsInfo,\n        ArrayRef<TemplateArgument> Converted,\n        VarTemplateSpecializationDecl *PrevDecl = nullptr);\n\n    Decl *InstantiateTypedefNameDecl(TypedefNameDecl *D, bool IsTypeAlias);\n    ClassTemplatePartialSpecializationDecl *\n    InstantiateClassTemplatePartialSpecialization(\n                                              ClassTemplateDecl *ClassTemplate,\n                           ClassTemplatePartialSpecializationDecl *PartialSpec);\n    VarTemplatePartialSpecializationDecl *\n    InstantiateVarTemplatePartialSpecialization(\n        VarTemplateDecl *VarTemplate,\n        VarTemplatePartialSpecializationDecl *PartialSpec);\n    void InstantiateEnumDefinition(EnumDecl *Enum, EnumDecl *Pattern);\n\n  private:\n    template<typename T>\n    Decl *instantiateUnresolvedUsingDecl(T *D,\n                                         bool InstantiatingPackElement = false);\n  };\n\n}",
  "id": "BLOCK-CPP-20699",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/Template.h",
  "source_line": 67,
  "validation_status": "validated"
}