{
  "code": "{\npublic:\n  /// A member declaration found through lookup.  The target is the\n  /// member.\n  enum MemberNonce { Member };\n\n  /// A hierarchy (base-to-derived or derived-to-base) conversion.\n  /// The target is the base class.\n  enum BaseNonce { Base };\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 MemberNonce _, CXXRecordDecl *NamingClass,\n                 DeclAccessPair FoundDecl, QualType BaseObjectType)\n      : Access(FoundDecl.getAccess()), IsMember(true),\n        Target(FoundDecl.getDecl()), NamingClass(NamingClass),\n        BaseObjectType(BaseObjectType), Diag(0, Allocator) {}\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 BaseNonce _, CXXRecordDecl *BaseClass,\n                 CXXRecordDecl *DerivedClass, AccessSpecifier Access)\n      : Access(Access), IsMember(false), Target(BaseClass),\n        NamingClass(DerivedClass), Diag(0, Allocator) {}\n\n  bool isMemberAccess() const { return IsMember; }\n\n  bool isQuiet() const { return Diag.getDiagID() == 0; }\n\n  AccessSpecifier getAccess() const { return AccessSpecifier(Access); }\n\n  // These apply to member decls...\n  NamedDecl *getTargetDecl() const { return Target; }\n  CXXRecordDecl *getNamingClass() const { return NamingClass; }\n\n  // ...and these apply to hierarchy conversions.\n  CXXRecordDecl *getBaseClass() const {\n    assert(!IsMember); return cast<CXXRecordDecl>(Target);\n  }\n  CXXRecordDecl *getDerivedClass() const { return NamingClass; }\n\n  /// Retrieves the base object type, important when accessing\n  /// an instance member.\n  QualType getBaseObjectType() const { return BaseObjectType; }\n\n  /// Sets a diagnostic to be performed.  The diagnostic is given\n  /// four (additional) arguments:\n  ///   %0 - 0 if the entity was private, 1 if protected\n  ///   %1 - the DeclarationName of the entity\n  ///   %2 - the TypeDecl type of the naming class\n  ///   %3 - the TypeDecl type of the declaring class\n  void setDiag(const PartialDiagnostic &PDiag) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    Diag = PDiag;\n  }\n  PartialDiagnostic &setDiag(unsigned DiagID) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    assert(DiagID && \"creating null diagnostic\");\n    Diag.Reset(DiagID);\n    return Diag;\n  }\n  const PartialDiagnostic &getDiag() const {\n    return Diag;\n  }\n\nprivate:\n  unsigned Access : 2;\n  unsigned IsMember : 1;\n  NamedDecl *Target;\n  CXXRecordDecl *NamingClass;\n  QualType BaseObjectType;\n  PartialDiagnostic Diag;\n}",
  "id": "BLOCK-CPP-19755",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Sema/DelayedDiagnostic.h",
  "source_line": 50,
  "validation_status": "validated"
}