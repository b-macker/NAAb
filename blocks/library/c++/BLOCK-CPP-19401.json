{
  "code": "{\n  // TODO: move ParsingClassDefinition here.\n  // TODO: move TentativeParsingAction here.\n\n  /// A RAII object used to temporarily suppress access-like\n  /// checking.  Access-like checks are those associated with\n  /// controlling the use of a declaration, like C++ access control\n  /// errors and deprecation warnings.  They are contextually\n  /// dependent, in that they can only be resolved with full\n  /// information about what's being declared.  They are also\n  /// suppressed in certain contexts, like the template arguments of\n  /// an explicit instantiation.  However, those suppression contexts\n  /// cannot necessarily be fully determined in advance;  for\n  /// example, something starting like this:\n  ///   template <> class std::vector<A::PrivateType>\n  /// might be the entirety of an explicit instantiation:\n  ///   template <> class std::vector<A::PrivateType>;\n  /// or just an elaborated type specifier:\n  ///   template <> class std::vector<A::PrivateType> make_vector<>();\n  /// Therefore this class collects all the diagnostics and permits\n  /// them to be re-delayed in a new context.\n  class SuppressAccessChecks {\n    Sema &S;\n    sema::DelayedDiagnosticPool DiagnosticPool;\n    Sema::ParsingDeclState State;\n    bool Active;\n\n  public:\n    /// Begin suppressing access-like checks\n    SuppressAccessChecks(Parser &P, bool activate = true)\n        : S(P.getActions()), DiagnosticPool(nullptr) {\n      if (activate) {\n        State = S.PushParsingDeclaration(DiagnosticPool);\n        Active = true;\n      } else {\n        Active = false;\n      }\n    }\n    SuppressAccessChecks(SuppressAccessChecks &&Other)\n      : S(Other.S), DiagnosticPool(std::move(Other.DiagnosticPool)),\n        State(Other.State), Active(Other.Active) {\n      Other.Active = false;\n    }\n    void operator=(SuppressAccessChecks &&Other) = delete;\n\n    void done() {\n      assert(Active && \"trying to end an inactive suppression\");\n      S.PopParsingDeclaration(State, nullptr);\n      Active = false;\n    }\n\n    void redelay() {\n      assert(!Active && \"redelaying without having ended first\");\n      if (!DiagnosticPool.pool_empty())\n        S.redelayDiagnostics(DiagnosticPool);\n      assert(DiagnosticPool.pool_empty());\n    }\n\n    ~SuppressAccessChecks() {\n      if (Active) done();\n    }\n  };\n\n  /// RAII object used to inform the actions that we're\n  /// currently parsing a declaration.  This is active when parsing a\n  /// variable's initializer, but not when parsing the body of a\n  /// class or function definition.\n  class ParsingDeclRAIIObject {\n    Sema &Actions;\n    sema::DelayedDiagnosticPool DiagnosticPool;\n    Sema::ParsingDeclState State;\n    bool Popped;\n\n    ParsingDeclRAIIObject(const ParsingDeclRAIIObject &) = delete;\n    void operator=(const ParsingDeclRAIIObject &) = delete;\n\n  public:\n    enum NoParent_t { NoParent };\n    ParsingDeclRAIIObject(Parser &P, NoParent_t _)\n        : Actions(P.getActions()), DiagnosticPool(nullptr) {\n      push();\n    }\n\n    /// Creates a RAII object whose pool is optionally parented by another.\n    ParsingDeclRAIIObject(Parser &P,\n                          const sema::DelayedDiagnosticPool *parentPool)\n        : Actions(P.getActions()), DiagnosticPool(parentPool) {\n      push();\n    }\n\n    /// Creates a RAII object and, optionally, initialize its\n    /// diagnostics pool by stealing the diagnostics from another\n    /// RAII object (which is assumed to be the current top pool).\n    ParsingDeclRAIIObject(Parser &P, ParsingDeclRAIIObject *other)\n        : Actions(P.getActions()),\n          DiagnosticPool(other ? other->DiagnosticPool.getParent() : nullptr) {\n      if (other) {\n        DiagnosticPool.steal(other->DiagnosticPool);\n        other->abort();\n      }\n      push();\n    }\n\n    ~ParsingDeclRAIIObject() {\n      abort();\n    }\n\n    sema::DelayedDiagnosticPool &getDelayedDiagnosticPool() {\n      return DiagnosticPool;\n    }\n    const sema::DelayedDiagnosticPool &getDelayedDiagnosticPool() const {\n      return DiagnosticPool;\n    }\n\n    /// Resets the RAII object for a new declaration.\n    void reset() {\n      abort();\n      push();\n    }\n\n    /// Signals that the context was completed without an appropriate\n    /// declaration being parsed.\n    void abort() {\n      pop(nullptr);\n    }\n\n    void complete(Decl *D) {\n      assert(!Popped && \"ParsingDeclaration has already been popped!\");\n      pop(D);\n    }\n\n    /// Unregister this object from Sema, but remember all the\n    /// diagnostics that were emitted into it.\n    void abortAndRemember() {\n      pop(nullptr);\n    }\n\n  private:\n    void push() {\n      State = Actions.PushParsingDeclaration(DiagnosticPool);\n      Popped = false;\n    }\n\n    void pop(Decl *D) {\n      if (!Popped) {\n        Actions.PopParsingDeclaration(State, D);\n        Popped = true;\n      }\n    }\n  };\n\n  /// A class for parsing a DeclSpec.\n  class ParsingDeclSpec : public DeclSpec {\n    ParsingDeclRAIIObject ParsingRAII;\n\n  public:\n    ParsingDeclSpec(Parser &P)\n      : DeclSpec(P.getAttrFactory()),\n        ParsingRAII(P, ParsingDeclRAIIObject::NoParent) {}\n    ParsingDeclSpec(Parser &P, ParsingDeclRAIIObject *RAII)\n      : DeclSpec(P.getAttrFactory()),\n        ParsingRAII(P, RAII) {}\n\n    const sema::DelayedDiagnosticPool &getDelayedDiagnosticPool() const {\n      return ParsingRAII.getDelayedDiagnosticPool();\n    }\n\n    void complete(Decl *D) {\n      ParsingRAII.complete(D);\n    }\n\n    void abort() {\n      ParsingRAII.abort();\n    }\n  };\n\n  /// A class for parsing a declarator.\n  class ParsingDeclarator : public Declarator {\n    ParsingDeclRAIIObject ParsingRAII;\n\n  public:\n    ParsingDeclarator(Parser &P, const ParsingDeclSpec &DS,\n                      const ParsedAttributes &DeclarationAttrs,\n                      DeclaratorContext C)\n        : Declarator(DS, DeclarationAttrs, C),\n          ParsingRAII(P, &DS.getDelayedDiagnosticPool()) {}\n\n    const ParsingDeclSpec &getDeclSpec() const {\n      return static_cast<const ParsingDeclSpec&>(Declarator::getDeclSpec());\n    }\n\n    ParsingDeclSpec &getMutableDeclSpec() const {\n      return const_cast<ParsingDeclSpec&>(getDeclSpec());\n    }\n\n    void clear() {\n      Declarator::clear();\n      ParsingRAII.reset();\n    }\n\n    void complete(Decl *D) {\n      ParsingRAII.complete(D);\n    }\n  };\n\n  /// A class for parsing a field declarator.\n  class ParsingFieldDeclarator : public FieldDeclarator {\n    ParsingDeclRAIIObject ParsingRAII;\n\n  public:\n    ParsingFieldDeclarator(Parser &P, const ParsingDeclSpec &DS,\n                           const ParsedAttributes &DeclarationAttrs)\n        : FieldDeclarator(DS, DeclarationAttrs),\n          ParsingRAII(P, &DS.getDelayedDiagnosticPool()) {}\n\n    const ParsingDeclSpec &getDeclSpec() const {\n      return static_cast<const ParsingDeclSpec&>(D.getDeclSpec());\n    }\n\n    ParsingDeclSpec &getMutableDeclSpec() const {\n      return const_cast<ParsingDeclSpec&>(getDeclSpec());\n    }\n\n    void complete(Decl *D) {\n      ParsingRAII.complete(D);\n    }\n  };\n\n  /// ExtensionRAIIObject - This saves the state of extension warnings when\n  /// constructed and disables them.  When destructed, it restores them back to\n  /// the way they used to be.  This is used to handle __extension__ in the\n  /// parser.\n  class ExtensionRAIIObject {\n    ExtensionRAIIObject(const ExtensionRAIIObject &) = delete;\n    void operator=(const ExtensionRAIIObject &) = delete;\n\n    DiagnosticsEngine &Diags;\n  public:\n    ExtensionRAIIObject(DiagnosticsEngine &diags) : Diags(diags) {\n      Diags.IncrementAllExtensionsSilenced();\n    }\n\n    ~ExtensionRAIIObject() {\n      Diags.DecrementAllExtensionsSilenced();\n    }\n  };\n\n  /// ColonProtectionRAIIObject - This sets the Parser::ColonIsSacred bool and\n  /// restores it when destroyed.  This says that \"foo:\" should not be\n  /// considered a possible typo for \"foo::\" for error recovery purposes.\n  class ColonProtectionRAIIObject {\n    Parser &P;\n    bool OldVal;\n  public:\n    ColonProtectionRAIIObject(Parser &p, bool Value = true)\n      : P(p), OldVal(P.ColonIsSacred) {\n      P.ColonIsSacred = Value;\n    }\n\n    /// restore - This can be used to restore the state early, before the dtor\n    /// is run.\n    void restore() {\n      P.ColonIsSacred = OldVal;\n    }\n\n    ~ColonProtectionRAIIObject() {\n      restore();\n    }\n  };\n\n  /// Activates OpenMP parsing mode to preseve OpenMP specific annotation\n  /// tokens.\n  class ParsingOpenMPDirectiveRAII {\n    Parser &P;\n    bool OldVal;\n\n  public:\n    ParsingOpenMPDirectiveRAII(Parser &P, bool Value = true)\n        : P(P), OldVal(P.OpenMPDirectiveParsing) {\n      P.OpenMPDirectiveParsing = Value;\n    }\n\n    /// This can be used to restore the state early, before the dtor\n    /// is run.\n    void restore() { P.OpenMPDirectiveParsing = OldVal; }\n\n    ~ParsingOpenMPDirectiveRAII() { restore(); }\n  };\n\n  /// RAII object that makes '>' behave either as an operator\n  /// or as the closing angle bracket for a template argument list.\n  class GreaterThanIsOperatorScope {\n    bool &GreaterThanIsOperator;\n    bool OldGreaterThanIsOperator;\n  public:\n    GreaterThanIsOperatorScope(bool &GTIO, bool Val)\n    : GreaterThanIsOperator(GTIO), OldGreaterThanIsOperator(GTIO) {\n      GreaterThanIsOperator = Val;\n    }\n\n    ~GreaterThanIsOperatorScope() {\n      GreaterThanIsOperator = OldGreaterThanIsOperator;\n    }\n  };\n\n  class InMessageExpressionRAIIObject {\n    bool &InMessageExpression;\n    bool OldValue;\n\n  public:\n    InMessageExpressionRAIIObject(Parser &P, bool Value)\n      : InMessageExpression(P.InMessageExpression),\n        OldValue(P.InMessageExpression) {\n      InMessageExpression = Value;\n    }\n\n    ~InMessageExpressionRAIIObject() {\n      InMessageExpression = OldValue;\n    }\n  };\n\n  class OffsetOfStateRAIIObject {\n    Sema::OffsetOfKind &OffsetOfState;\n    Sema::OffsetOfKind OldValue;\n\n  public:\n    OffsetOfStateRAIIObject(Parser &P, Sema::OffsetOfKind Value)\n        : OffsetOfState(P.OffsetOfState), OldValue(P.OffsetOfState) {\n      OffsetOfState = Value;\n    }\n\n    ~OffsetOfStateRAIIObject() { OffsetOfState = OldValue; }\n  };\n\n  /// RAII object that makes sure paren/bracket/brace count is correct\n  /// after declaration/statement parsing, even when there's a parsing error.\n  class ParenBraceBracketBalancer {\n    Parser &P;\n    unsigned short ParenCount, BracketCount, BraceCount;\n  public:\n    ParenBraceBracketBalancer(Parser &p)\n      : P(p), ParenCount(p.ParenCount), BracketCount(p.BracketCount),\n        BraceCount(p.BraceCount) { }\n\n    ~ParenBraceBracketBalancer() {\n      P.AngleBrackets.clear(P);\n      P.ParenCount = ParenCount;\n      P.BracketCount = BracketCount;\n      P.BraceCount = BraceCount;\n    }\n  };\n\n  class PoisonSEHIdentifiersRAIIObject {\n    PoisonIdentifierRAIIObject Ident_AbnormalTermination;\n    PoisonIdentifierRAIIObject Ident_GetExceptionCode;\n    PoisonIdentifierRAIIObject Ident_GetExceptionInfo;\n    PoisonIdentifierRAIIObject Ident__abnormal_termination;\n    PoisonIdentifierRAIIObject Ident__exception_code;\n    PoisonIdentifierRAIIObject Ident__exception_info;\n    PoisonIdentifierRAIIObject Ident___abnormal_termination;\n    PoisonIdentifierRAIIObject Ident___exception_code;\n    PoisonIdentifierRAIIObject Ident___exception_info;\n  public:\n    PoisonSEHIdentifiersRAIIObject(Parser &Self, bool NewValue)\n      : Ident_AbnormalTermination(Self.Ident_AbnormalTermination, NewValue),\n        Ident_GetExceptionCode(Self.Ident_GetExceptionCode, NewValue),\n        Ident_GetExceptionInfo(Self.Ident_GetExceptionInfo, NewValue),\n        Ident__abnormal_termination(Self.Ident__abnormal_termination, NewValue),\n        Ident__exception_code(Self.Ident__exception_code, NewValue),\n        Ident__exception_info(Self.Ident__exception_info, NewValue),\n        Ident___abnormal_termination(Self.Ident___abnormal_termination, NewValue),\n        Ident___exception_code(Self.Ident___exception_code, NewValue),\n        Ident___exception_info(Self.Ident___exception_info, NewValue) {\n    }\n  };\n\n  /// RAII class that helps handle the parsing of an open/close delimiter\n  /// pair, such as braces { ... } or parentheses ( ... ).\n  class BalancedDelimiterTracker : public GreaterThanIsOperatorScope {\n    Parser& P;\n    tok::TokenKind Kind, Close, FinalToken;\n    SourceLocation (Parser::*Consumer)();\n    SourceLocation LOpen, LClose;\n\n    unsigned short &getDepth() {\n      switch (Kind) {\n        case tok::l_brace: return P.BraceCount;\n        case tok::l_square: return P.BracketCount;\n        case tok::l_paren: return P.ParenCount;\n        default: llvm_unreachable(\"Wrong token kind\");\n      }\n    }\n\n    bool diagnoseOverflow();\n    bool diagnoseMissingClose();\n\n  public:\n    BalancedDelimiterTracker(Parser& p, tok::TokenKind k,\n                             tok::TokenKind FinalToken = tok::semi)\n      : GreaterThanIsOperatorScope(p.GreaterThanIsOperator, true),\n        P(p), Kind(k), FinalToken(FinalToken)\n    {\n      switch (Kind) {\n        default: llvm_unreachable(\"Unexpected balanced token\");\n        case tok::l_brace:\n          Close = tok::r_brace;\n          Consumer = &Parser::ConsumeBrace;\n          break;\n        case tok::l_paren:\n          Close = tok::r_paren;\n          Consumer = &Parser::ConsumeParen;\n          break;\n\n        case tok::l_square:\n          Close = tok::r_square;\n          Consumer = &Parser::ConsumeBracket;\n          break;\n      }\n    }\n\n    SourceLocation getOpenLocation() const { return LOpen; }\n    SourceLocation getCloseLocation() const { return LClose; }\n    SourceRange getRange() const { return SourceRange(LOpen, LClose); }\n\n    bool consumeOpen() {\n      if (!P.Tok.is(Kind))\n        return true;\n\n      if (getDepth() < P.getLangOpts().BracketDepth) {\n        LOpen = (P.*Consumer)();\n        return false;\n      }\n\n      return diagnoseOverflow();\n    }\n\n    bool expectAndConsume(unsigned DiagID = diag::err_expected,\n                          const char *Msg = \"\",\n                          tok::TokenKind SkipToTok = tok::unknown);\n    bool consumeClose() {\n      if (P.Tok.is(Close)) {\n        LClose = (P.*Consumer)();\n        return false;\n      } else if (P.Tok.is(tok::semi) && P.NextToken().is(Close)) {\n        SourceLocation SemiLoc = P.ConsumeToken();\n        P.Diag(SemiLoc, diag::err_unexpected_semi)\n            << Close << FixItHint::CreateRemoval(SourceRange(SemiLoc, SemiLoc));\n        LClose = (P.*Consumer)();\n        return false;\n      }\n\n      return diagnoseMissingClose();\n    }\n    void skipToEnd();\n  };\n}",
  "id": "BLOCK-CPP-19401",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Parse/RAIIObjectsForParser.h",
  "source_line": 23,
  "validation_status": "validated"
}