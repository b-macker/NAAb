{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nclass Status;\ntemplate <typename T>\nclass StatusOr;\n\nnamespace status_internal {\nABSL_ATTRIBUTE_PURE_FUNCTION std::string* MakeCheckFailString(\n    const absl::Status* status, const char* prefix);\n}  // namespace status_internal\n\nnamespace log_internal {\n\n// Convert a Status or a StatusOr to its underlying status value.\n//\n// (This implementation does not require a dep on absl::Status to work.)\ninline const absl::Status* AsStatus(const absl::Status& s) { return &s; }\ntemplate <typename T>\nconst absl::Status* AsStatus(const absl::StatusOr<T>& s) {\n  return &s.status();\n}\n\n// A helper class for formatting `expr (V1 vs. V2)` in a `CHECK_XX` statement.\n// See `MakeCheckOpString` for sample usage.\nclass CheckOpMessageBuilder final {\n public:\n  // Inserts `exprtext` and ` (` to the stream.\n  explicit CheckOpMessageBuilder(const char* exprtext);\n  ~CheckOpMessageBuilder() = default;\n  // For inserting the first variable.\n  std::ostream& ForVar1() { return stream_; }\n  // For inserting the second variable (adds an intermediate ` vs. `).\n  std::ostream& ForVar2();\n  // Get the result (inserts the closing `)`).\n  std::string* NewString();\n\n private:\n  std::ostringstream stream_;\n};\n\n// This formats a value for a failing `CHECK_XX` statement.  Ordinarily, it uses\n// the definition for `operator<<`, with a few special cases below.\ntemplate <typename T>\ninline void MakeCheckOpValueString(std::ostream& os, const T& v) {\n  os << log_internal::NullGuard<T>::Guard(v);\n}\n\n// Overloads for char types provide readable values for unprintable characters.\nvoid MakeCheckOpValueString(std::ostream& os, char v);\nvoid MakeCheckOpValueString(std::ostream& os, signed char v);\nvoid MakeCheckOpValueString(std::ostream& os, unsigned char v);\nvoid MakeCheckOpValueString(std::ostream& os, const void* p);\n\nnamespace detect_specialization {\n\n// MakeCheckOpString is being specialized for every T and U pair that is being\n// passed to the CHECK_op macros. However, there is a lot of redundancy in these\n// specializations that creates unnecessary library and binary bloat.\n// The number of instantiations tends to be O(n^2) because we have two\n// independent inputs. This technique works by reducing `n`.\n//\n// Most user-defined types being passed to CHECK_op end up being printed as a\n// builtin type. For example, enums tend to be implicitly converted to its\n// underlying type when calling operator<<, and pointers are printed with the\n// `const void*` overload.\n// To reduce the number of instantiations we coerce these values before calling\n// MakeCheckOpString instead of inside it.\n//\n// To detect if this coercion is needed, we duplicate all the relevant\n// operator<< overloads as specified in the standard, just in a different\n// namespace. If the call to `stream << value` becomes ambiguous, it means that\n// one of these overloads is the one selected by overload resolution. We then\n// do overload resolution again just with our overload set to see which one gets\n// selected. That tells us which type to coerce to.\n// If the augmented call was not ambiguous, it means that none of these were\n// selected and we can't coerce the input.\n//\n// As a secondary step to reduce code duplication, we promote integral types to\n// their 64-bit variant. This does not change the printed value, but reduces the\n// number of instantiations even further. Promoting an integer is very cheap at\n// the call site.\nint64_t operator<<(std::ostream&, short value);           // NOLINT\nint64_t operator<<(std::ostream&, unsigned short value);  // NOLINT\nint64_t operator<<(std::ostream&, int value);\nint64_t operator<<(std::ostream&, unsigned int value);\nint64_t operator<<(std::ostream&, long value);                 // NOLINT\nuint64_t operator<<(std::ostream&, unsigned long value);       // NOLINT\nint64_t operator<<(std::ostream&, long long value);            // NOLINT\nuint64_t operator<<(std::ostream&, unsigned long long value);  // NOLINT\nfloat operator<<(std::ostream&, float value);\ndouble operator<<(std::ostream&, double value);\nlong double operator<<(std::ostream&, long double value);\nbool operator<<(std::ostream&, bool value);\nconst void* operator<<(std::ostream&, const void* value);\nconst void* operator<<(std::ostream&, std::nullptr_t);\n\n// These `char` overloads are specified like this in the standard, so we have to\n// write them exactly the same to ensure the call is ambiguous.\n// If we wrote it in a different way (eg taking std::ostream instead of the\n// template) then one call might have a higher rank than the other and it would\n// not be ambiguous.\ntemplate <typename Traits>\nchar operator<<(std::basic_ostream<char, Traits>&, char);\ntemplate <typename Traits>\nsigned char operator<<(std::basic_ostream<char, Traits>&, signed char);\ntemplate <typename Traits>\nunsigned char operator<<(std::basic_ostream<char, Traits>&, unsigned char);\ntemplate <typename Traits>\nconst char* operator<<(std::basic_ostream<char, Traits>&, const char*);\ntemplate <typename Traits>\nconst signed char* operator<<(std::basic_ostream<char, Traits>&,\n                              const signed char*);\ntemplate <typename Traits>\nconst unsigned char* operator<<(std::basic_ostream<char, Traits>&,\n                                const unsigned char*);\n\n// This overload triggers when the call is not ambiguous.\n// It means that T is being printed with some overload not on this list.\n// We keep the value as `const T&`.\ntemplate <typename T, typename = decltype(std::declval<std::ostream&>()\n                                          << std::declval<const T&>())>\nconst T& Detect(int);\n\n// This overload triggers when the call is ambiguous.\n// It means that T is either one from this list or printed as one from this\n// list. Eg an enum that decays to `int` for printing.\n// We ask the overload set to give us the type we want to convert it to.\ntemplate <typename T>\ndecltype(detect_specialization::operator<<(std::declval<std::ostream&>(),\n                                           std::declval<const T&>()))\nDetect(char);\n\n}  // namespace detect_specialization\n\ntemplate <typename T>\nusing CheckOpStreamType = decltype(detect_specialization::Detect<T>(0));\n\n// Build the error message string.  Specify no inlining for code size.\ntemplate <typename T1, typename T2>\nABSL_ATTRIBUTE_RETURNS_NONNULL std::string* MakeCheckOpString(\n    T1 v1, T2 v2, const char* exprtext) ABSL_ATTRIBUTE_NOINLINE;\n\ntemplate <typename T1, typename T2>\nstd::string* MakeCheckOpString(T1 v1, T2 v2, const char* exprtext) {\n  CheckOpMessageBuilder comb(exprtext);\n  MakeCheckOpValueString(comb.ForVar1(), v1);\n  MakeCheckOpValueString(comb.ForVar2(), v2);\n  return comb.NewString();\n}\n\n// Add a few commonly used instantiations as extern to reduce size of objects\n// files.\n#define ABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(x) \\\n  extern template std::string* MakeCheckOpString(x, x, const char*)\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(bool);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(int64_t);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(uint64_t);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(float);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(double);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(char);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(unsigned char);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const std::string&);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const absl::string_view&);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const char*);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const signed char*);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const unsigned char*);\nABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN(const void*);\n#undef ABSL_LOG_INTERNAL_DEFINE_MAKE_CHECK_OP_STRING_EXTERN\n\n// `ABSL_LOG_INTERNAL_CHECK_OP_IMPL_RESULT` skips formatting the Check_OP result\n// string iff `ABSL_MIN_LOG_LEVEL` exceeds `kFatal`, instead returning an empty\n// string.\n#ifdef ABSL_MIN_LOG_LEVEL\n#define ABSL_LOG_INTERNAL_CHECK_OP_IMPL_RESULT(U1, U2, v1, v2, exprtext) \\\n  ((::absl::LogSeverity::kFatal >=                                       \\\n    static_cast<::absl::LogSeverity>(ABSL_MIN_LOG_LEVEL))                \\\n       ? MakeCheckOpString<U1, U2>(v1, v2, exprtext)                     \\\n       : new std::string())\n#else\n#define ABSL_LOG_INTERNAL_CHECK_OP_IMPL_RESULT(U1, U2, v1, v2, exprtext) \\\n  MakeCheckOpString<U1, U2>(v1, v2, exprtext)\n#endif\n\n// Helper functions for `ABSL_LOG_INTERNAL_CHECK_OP` macro family.  The\n// `(int, int)` override works around the issue that the compiler will not\n// instantiate the template version of the function on values of unnamed enum\n// type.\n#define ABSL_LOG_INTERNAL_CHECK_OP_IMPL(name, op)                        \\\n  template <typename T1, typename T2>                                    \\\n  inline constexpr ::std::string* name##Impl(const T1& v1, const T2& v2, \\\n                                             const char* exprtext) {     \\\n    using U1 = CheckOpStreamType<T1>;                                    \\\n    using U2 = CheckOpStreamType<T2>;                                    \\\n    return ABSL_PREDICT_TRUE(v1 op v2)                                   \\\n               ? nullptr                                                 \\\n               : ABSL_LOG_INTERNAL_CHECK_OP_IMPL_RESULT(U1, U2, v1, v2,  \\\n                                                        exprtext);       \\\n  }                                                                      \\\n  inline constexpr ::std::string* name##Impl(int v1, int v2,             \\\n                                             const char* exprtext) {     \\\n    return name##Impl<int, int>(v1, v2, exprtext);                       \\\n  }\n\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_EQ, ==)\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_NE, !=)\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_LE, <=)\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_LT, <)\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_GE, >=)\nABSL_LOG_INTERNAL_CHECK_OP_IMPL(Check_GT, >)\n#undef ABSL_LOG_INTERNAL_CHECK_OP_IMPL_RESULT\n#undef ABSL_LOG_INTERNAL_CHECK_OP_IMPL\n\nstd::string* CheckstrcmptrueImpl(const char* s1, const char* s2,\n                                 const char* exprtext);\nstd::string* CheckstrcmpfalseImpl(const char* s1, const char* s2,\n                                  const char* exprtext);\nstd::string* CheckstrcasecmptrueImpl(const char* s1, const char* s2,\n                                     const char* exprtext);\nstd::string* CheckstrcasecmpfalseImpl(const char* s1, const char* s2,\n                                      const char* exprtext);\n\n// `CHECK_EQ` and friends want to pass their arguments by reference, however\n// this winds up exposing lots of cases where people have defined and\n// initialized static const data members but never declared them (i.e. in a .cc\n// file), meaning they are not referenceable.  This function avoids that problem\n// for integers (the most common cases) by overloading for every primitive\n// integer type, even the ones we discourage, and returning them by value.\ntemplate <typename T>\ninline constexpr const T& GetReferenceableValue(const T& t) {\n  return t;\n}\ninline constexpr char GetReferenceableValue(char t) { return t; }\ninline constexpr unsigned char GetReferenceableValue(unsigned char t) {\n  return t;\n}\ninline constexpr signed char GetReferenceableValue(signed char t) { return t; }\ninline constexpr short GetReferenceableValue(short t) { return t; }  // NOLINT\ninline constexpr unsigned short GetReferenceableValue(               // NOLINT\n    unsigned short t) {                                              // NOLINT\n  return t;\n}\ninline constexpr int GetReferenceableValue(int t) { return t; }\ninline constexpr unsigned int GetReferenceableValue(unsigned int t) {\n  return t;\n}\ninline constexpr long GetReferenceableValue(long t) { return t; }  // NOLINT\ninline constexpr unsigned long GetReferenceableValue(              // NOLINT\n    unsigned long t) {                                             // NOLINT\n  return t;\n}\ninline constexpr long long GetReferenceableValue(long long t) {  // NOLINT\n  return t;\n}\ninline constexpr unsigned long long GetReferenceableValue(  // NOLINT\n    unsigned long long t) {                                 // NOLINT\n  return t;\n}\n\n}  // namespace log_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-05716",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/log/internal/check_op.h",
  "source_line": 157,
  "validation_status": "validated"
}