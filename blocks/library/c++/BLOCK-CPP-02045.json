{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nnamespace {\n\n// This is significantly faster for case-sensitive matches with very\n// few possible matches.\nabsl::Nullable<const char*> memmatch(absl::Nullable<const char*> phaystack,\n                                     size_t haylen,\n                                     absl::Nullable<const char*> pneedle,\n                                     size_t neelen) {\n  if (0 == neelen) {\n    return phaystack;  // even if haylen is 0\n  }\n  if (haylen < neelen) return nullptr;\n\n  const char* match;\n  const char* hayend = phaystack + haylen - neelen + 1;\n  // A static cast is used here as memchr returns a const void *, and pointer\n  // arithmetic is not allowed on pointers to void.\n  while (\n      (match = static_cast<const char*>(memchr(\n           phaystack, pneedle[0], static_cast<size_t>(hayend - phaystack))))) {\n    if (memcmp(match, pneedle, neelen) == 0)\n      return match;\n    else\n      phaystack = match + 1;\n  }\n  return nullptr;\n}\n\nvoid WritePadding(std::ostream& o, size_t pad) {\n  char fill_buf[32];\n  memset(fill_buf, o.fill(), sizeof(fill_buf));\n  while (pad) {\n    size_t n = std::min(pad, sizeof(fill_buf));\n    o.write(fill_buf, static_cast<std::streamsize>(n));\n    pad -= n;\n  }\n}\n\nclass LookupTable {\n public:\n  // For each character in wanted, sets the index corresponding\n  // to the ASCII code of that character. This is used by\n  // the find_.*_of methods below to tell whether or not a character is in\n  // the lookup table in constant time.\n  explicit LookupTable(string_view wanted) {\n    for (char c : wanted) {\n      table_[Index(c)] = true;\n    }\n  }\n  bool operator[](char c) const { return table_[Index(c)]; }\n\n private:\n  static unsigned char Index(char c) { return static_cast<unsigned char>(c); }\n  bool table_[UCHAR_MAX + 1] = {};\n};\n\n}  // namespace\n\nstd::ostream& operator<<(std::ostream& o, string_view piece) {\n  std::ostream::sentry sentry(o);\n  if (sentry) {\n    size_t lpad = 0;\n    size_t rpad = 0;\n    if (static_cast<size_t>(o.width()) > piece.size()) {\n      size_t pad = static_cast<size_t>(o.width()) - piece.size();\n      if ((o.flags() & o.adjustfield) == o.left) {\n        rpad = pad;\n      } else {\n        lpad = pad;\n      }\n    }\n    if (lpad) WritePadding(o, lpad);\n    o.write(piece.data(), static_cast<std::streamsize>(piece.size()));\n    if (rpad) WritePadding(o, rpad);\n    o.width(0);\n  }\n  return o;\n}\n\nstring_view::size_type string_view::find(string_view s,\n                                         size_type pos) const noexcept {\n  if (empty() || pos > length_) {\n    if (empty() && pos == 0 && s.empty()) return 0;\n    return npos;\n  }\n  const char* result = memmatch(ptr_ + pos, length_ - pos, s.ptr_, s.length_);\n  return result ? static_cast<size_type>(result - ptr_) : npos;\n}\n\nstring_view::size_type string_view::find(char c, size_type pos) const noexcept {\n  if (empty() || pos >= length_) {\n    return npos;\n  }\n  const char* result =\n      static_cast<const char*>(memchr(ptr_ + pos, c, length_ - pos));\n  return result != nullptr ? static_cast<size_type>(result - ptr_) : npos;\n}\n\nstring_view::size_type string_view::rfind(string_view s,\n                                          size_type pos) const noexcept {\n  if (length_ < s.length_) return npos;\n  if (s.empty()) return std::min(length_, pos);\n  const char* last = ptr_ + std::min(length_ - s.length_, pos) + s.length_;\n  const char* result = std::find_end(ptr_, last, s.ptr_, s.ptr_ + s.length_);\n  return result != last ? static_cast<size_type>(result - ptr_) : npos;\n}\n\n// Search range is [0..pos] inclusive.  If pos == npos, search everything.\nstring_view::size_type string_view::rfind(char c,\n                                          size_type pos) const noexcept {\n  // Note: memrchr() is not available on Windows.\n  if (empty()) return npos;\n  for (size_type i = std::min(pos, length_ - 1);; --i) {\n    if (ptr_[i] == c) {\n      return i;\n    }\n    if (i == 0) break;\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_first_of(\n    string_view s, size_type pos) const noexcept {\n  if (empty() || s.empty()) {\n    return npos;\n  }\n  // Avoid the cost of LookupTable() for a single-character search.\n  if (s.length_ == 1) return find_first_of(s.ptr_[0], pos);\n  LookupTable tbl(s);\n  for (size_type i = pos; i < length_; ++i) {\n    if (tbl[ptr_[i]]) {\n      return i;\n    }\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_first_not_of(\n    string_view s, size_type pos) const noexcept {\n  if (empty()) return npos;\n  // Avoid the cost of LookupTable() for a single-character search.\n  if (s.length_ == 1) return find_first_not_of(s.ptr_[0], pos);\n  LookupTable tbl(s);\n  for (size_type i = pos; i < length_; ++i) {\n    if (!tbl[ptr_[i]]) {\n      return i;\n    }\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_first_not_of(\n    char c, size_type pos) const noexcept {\n  if (empty()) return npos;\n  for (; pos < length_; ++pos) {\n    if (ptr_[pos] != c) {\n      return pos;\n    }\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_last_of(string_view s,\n                                                 size_type pos) const noexcept {\n  if (empty() || s.empty()) return npos;\n  // Avoid the cost of LookupTable() for a single-character search.\n  if (s.length_ == 1) return find_last_of(s.ptr_[0], pos);\n  LookupTable tbl(s);\n  for (size_type i = std::min(pos, length_ - 1);; --i) {\n    if (tbl[ptr_[i]]) {\n      return i;\n    }\n    if (i == 0) break;\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_last_not_of(\n    string_view s, size_type pos) const noexcept {\n  if (empty()) return npos;\n  size_type i = std::min(pos, length_ - 1);\n  if (s.empty()) return i;\n  // Avoid the cost of LookupTable() for a single-character search.\n  if (s.length_ == 1) return find_last_not_of(s.ptr_[0], pos);\n  LookupTable tbl(s);\n  for (;; --i) {\n    if (!tbl[ptr_[i]]) {\n      return i;\n    }\n    if (i == 0) break;\n  }\n  return npos;\n}\n\nstring_view::size_type string_view::find_last_not_of(\n    char c, size_type pos) const noexcept {\n  if (empty()) return npos;\n  size_type i = std::min(pos, length_ - 1);\n  for (;; --i) {\n    if (ptr_[i] != c) {\n      return i;\n    }\n    if (i == 0) break;\n  }\n  return npos;\n}\n\n#ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\nconstexpr string_view::size_type string_view::npos;\nconstexpr string_view::size_type string_view::kMaxSize;\n#endif\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02045",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/string_view.cc",
  "source_line": 26,
  "validation_status": "validated"
}