{
  "code": "#include \"absl/strings/numbers.h\"\n#include <algorithm>\n#include <cassert>\n#include <cfloat>  // for DBL_DIG and FLT_DIG\n#include <climits>\n#include <cmath>   // for HUGE_VAL\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iterator>\n#include <limits>\n#include <system_error>  // NOLINT(build/c++11)\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/endian.h\"\n#include \"absl/base/internal/raw_logging.h\"\n#include \"absl/base/nullability.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/numeric/bits.h\"\n#include \"absl/numeric/int128.h\"\n#include \"absl/strings/ascii.h\"\n#include \"absl/strings/charconv.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/string_view.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01969_execute() {\n    {\n  uint64_t bits0_31 = num.second & 0xFFFFFFFF;\n  uint64_t bits32_63 = num.second >> 32;\n  uint64_t bits64_95 = num.first & 0xFFFFFFFF;\n  uint64_t bits96_127 = num.first >> 32;\n\n  // The picture so far: each of these 64-bit values has only the lower 32 bits\n  // filled in.\n  // bits96_127:          [ 00000000 xxxxxxxx ]\n  // bits64_95:                    [ 00000000 xxxxxxxx ]\n  // bits32_63:                             [ 00000000 xxxxxxxx ]\n  // bits0_31:                                       [ 00000000 xxxxxxxx ]\n\n  bits0_31 *= mul;\n  bits32_63 *= mul;\n  bits64_95 *= mul;\n  bits96_127 *= mul;\n\n  // Now the top halves may also have value, though all 64 of their bits will\n  // never be set at the same time, since they are a result of a 32x32 bit\n  // multiply.  This makes the carry calculation slightly easier.\n  // bits96_127:          [ mmmmmmmm | mmmmmmmm ]\n  // bits64_95:                    [ | mmmmmmmm mmmmmmmm | ]\n  // bits32_63:                      |        [ mmmmmmmm | mmmmmmmm ]\n  // bits0_31:                       |                 [ | mmmmmmmm mmmmmmmm ]\n  // eventually:        [ bits128_up | ...bits64_127.... | ..bits0_63... ]\n\n  uint64_t bits0_63 = bits0_31 + (bits32_63 << 32);\n  uint64_t bits64_127 = bits64_95 + (bits96_127 << 32) + (bits32_63 >> 32) +\n                        (bits0_63 < bits0_31);\n  uint64_t bits128_up = (bits96_127 >> 32) + (bits64_127 < bits64_95);\n  if (bits128_up == 0) return {bits64_127, bits0_63};\n\n  auto shift = static_cast<unsigned>(bit_width(bits128_up));\n  uint64_t lo = (bits0_63 >> shift) + (bits64_127 << (64 - shift));\n  uint64_t hi = (bits64_127 >> shift) + (bits128_up << (64 - shift));\n  return {hi, lo};\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01969",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/numbers.cc",
  "source_line": 568,
  "validation_status": "validated"
}