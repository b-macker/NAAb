{
  "code": "{\n\nclass Attr;\n\n/// AttrVec - A vector of Attr, which is how they are stored on the AST.\nusing AttrVec = SmallVector<Attr *, 4>;\n\n/// specific_attr_iterator - Iterates over a subrange of an AttrVec, only\n/// providing attributes that are of a specific type.\ntemplate <typename SpecificAttr, typename Container = AttrVec>\nclass specific_attr_iterator {\n  using Iterator = typename Container::const_iterator;\n\n  /// Current - The current, underlying iterator.\n  /// In order to ensure we don't dereference an invalid iterator unless\n  /// specifically requested, we don't necessarily advance this all the\n  /// way. Instead, we advance it when an operation is requested; if the\n  /// operation is acting on what should be a past-the-end iterator,\n  /// then we offer no guarantees, but this way we do not dereference a\n  /// past-the-end iterator when we move to a past-the-end position.\n  mutable Iterator Current;\n\n  void AdvanceToNext() const {\n    while (!isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\n  void AdvanceToNext(Iterator I) const {\n    while (Current != I && !isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\npublic:\n  using value_type = SpecificAttr *;\n  using reference = SpecificAttr *;\n  using pointer = SpecificAttr *;\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n\n  specific_attr_iterator() = default;\n  explicit specific_attr_iterator(Iterator i) : Current(i) {}\n\n  reference operator*() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n  pointer operator->() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n\n  specific_attr_iterator& operator++() {\n    ++Current;\n    return *this;\n  }\n  specific_attr_iterator operator++(int) {\n    specific_attr_iterator Tmp(*this);\n    ++(*this);\n    return Tmp;\n  }\n\n  friend bool operator==(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    assert((Left.Current == nullptr) == (Right.Current == nullptr));\n    if (Left.Current < Right.Current)\n      Left.AdvanceToNext(Right.Current);\n    else\n      Right.AdvanceToNext(Left.Current);\n    return Left.Current == Right.Current;\n  }\n  friend bool operator!=(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    return !(Left == Right);\n  }\n};\n\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_begin(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.begin());\n}\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_end(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.end());\n}\n\ntemplate <typename SpecificAttr, typename Container>\ninline bool hasSpecificAttr(const Container& container) {\n  return specific_attr_begin<SpecificAttr>(container) !=\n          specific_attr_end<SpecificAttr>(container);\n}\ntemplate <typename SpecificAttr, typename Container>\ninline SpecificAttr *getSpecificAttr(const Container& container) {\n  specific_attr_iterator<SpecificAttr, Container> i =\n      specific_attr_begin<SpecificAttr>(container);\n  if (i != specific_attr_end<SpecificAttr>(container))\n    return *i;\n  else\n    return nullptr;\n}\n\n}",
  "id": "BLOCK-CPP-07448",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/AttrIterator.h",
  "source_line": 23,
  "validation_status": "validated"
}