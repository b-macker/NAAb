{
  "code": "#include \"absl/base/config.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03577_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// GetStackFrames()\n//\n// Records program counter values for up to `max_depth` frames, skipping the\n// most recent `skip_count` stack frames, stores their corresponding values\n// and sizes in `results` and `sizes` buffers, and returns the number of frames\n// stored. (Note that the frame generated for the `absl::GetStackFrames()`\n// routine itself is also skipped.)\n//\n// Example:\n//\n//      main() { foo(); }\n//      foo() { bar(); }\n//      bar() {\n//        void* result[10];\n//        int sizes[10];\n//        int depth = absl::GetStackFrames(result, sizes, 10, 1);\n//      }\n//\n// The current stack frame would consist of three function calls: `bar()`,\n// `foo()`, and then `main()`; however, since the `GetStackFrames()` call sets\n// `skip_count` to `1`, it will skip the frame for `bar()`, the most recently\n// invoked function call. It will therefore return 2 and fill `result` with\n// program counters within the following functions:\n//\n//      result[0]       foo()\n//      result[1]       main()\n//\n// (Note: in practice, a few more entries after `main()` may be added to account\n// for startup processes.)\n//\n// Corresponding stack frame sizes will also be recorded:\n//\n//    sizes[0]       16\n//    sizes[1]       16\n//\n// (Stack frame sizes of `16` above are just for illustration purposes.)\n//\n// Stack frame sizes of 0 or less indicate that those frame sizes couldn't\n// be identified.\n//\n// This routine may return fewer stack frame entries than are\n// available. Also note that `result` and `sizes` must both be non-null.\nextern int GetStackFrames(void** result, int* sizes, int max_depth,\n                          int skip_count);\n\n// GetStackFramesWithContext()\n//\n// Records program counter values obtained from a signal handler. Records\n// program counter values for up to `max_depth` frames, skipping the most recent\n// `skip_count` stack frames, stores their corresponding values and sizes in\n// `results` and `sizes` buffers, and returns the number of frames stored. (Note\n// that the frame generated for the `absl::GetStackFramesWithContext()` routine\n// itself is also skipped.)\n//\n// The `uc` parameter, if non-null, should be a pointer to a `ucontext_t` value\n// passed to a signal handler registered via the `sa_sigaction` field of a\n// `sigaction` struct. (See\n// http://man7.org/linux/man-pages/man2/sigaction.2.html.) The `uc` value may\n// help a stack unwinder to provide a better stack trace under certain\n// conditions. `uc` may safely be null.\n//\n// The `min_dropped_frames` output parameter, if non-null, points to the\n// location to note any dropped stack frames, if any, due to buffer limitations\n// or other reasons. (This value will be set to `0` if no frames were dropped.)\n// The number of total stack frames is guaranteed to be >= skip_count +\n// max_depth + *min_dropped_frames.\nextern int GetStackFramesWithContext(void** result, int* sizes, int max_depth,\n                                     int skip_count, const void* uc,\n                                     int* min_dropped_frames);\n\n// GetStackTrace()\n//\n// Records program counter values for up to `max_depth` frames, skipping the\n// most recent `skip_count` stack frames, stores their corresponding values\n// in `results`, and returns the number of frames\n// stored. Note that this function is similar to `absl::GetStackFrames()`\n// except that it returns the stack trace only, and not stack frame sizes.\n//\n// Example:\n//\n//      main() { foo(); }\n//      foo() { bar(); }\n//      bar() {\n//        void* result[10];\n//        int depth = absl::GetStackTrace(result, 10, 1);\n//      }\n//\n// This produces:\n//\n//      result[0]       foo\n//      result[1]       main\n//           ....       ...\n//\n// `result` must not be null.\nextern int GetStackTrace(void** result, int max_depth, int skip_count);\n\n// GetStackTraceWithContext()\n//\n// Records program counter values obtained from a signal handler. Records\n// program counter values for up to `max_depth` frames, skipping the most recent\n// `skip_count` stack frames, stores their corresponding values in `results`,\n// and returns the number of frames stored. (Note that the frame generated for\n// the `absl::GetStackFramesWithContext()` routine itself is also skipped.)\n//\n// The `uc` parameter, if non-null, should be a pointer to a `ucontext_t` value\n// passed to a signal handler registered via the `sa_sigaction` field of a\n// `sigaction` struct. (See\n// http://man7.org/linux/man-pages/man2/sigaction.2.html.) The `uc` value may\n// help a stack unwinder to provide a better stack trace under certain\n// conditions. `uc` may safely be null.\n//\n// The `min_dropped_frames` output parameter, if non-null, points to the\n// location to note any dropped stack frames, if any, due to buffer limitations\n// or other reasons. (This value will be set to `0` if no frames were dropped.)\n// The number of total stack frames is guaranteed to be >= skip_count +\n// max_depth + *min_dropped_frames.\nextern int GetStackTraceWithContext(void** result, int max_depth,\n                                    int skip_count, const void* uc,\n                                    int* min_dropped_frames);\n\n// SetStackUnwinder()\n//\n// Provides a custom function for unwinding stack frames that will be used in\n// place of the default stack unwinder when invoking the static\n// GetStack{Frames,Trace}{,WithContext}() functions above.\n//\n// The arguments passed to the unwinder function will match the\n// arguments passed to `absl::GetStackFramesWithContext()` except that sizes\n// will be non-null iff the caller is interested in frame sizes.\n//\n// If unwinder is set to null, we revert to the default stack-tracing behavior.\n//\n// *****************************************************************************\n// WARNING\n// *****************************************************************************\n//\n// absl::SetStackUnwinder is not suitable for general purpose use.  It is\n// provided for custom runtimes.\n// Some things to watch out for when calling `absl::SetStackUnwinder()`:\n//\n// (a) The unwinder may be called from within signal handlers and\n// therefore must be async-signal-safe.\n//\n// (b) Even after a custom stack unwinder has been unregistered, other\n// threads may still be in the process of using that unwinder.\n// Therefore do not clean up any state that may be needed by an old\n// unwinder.\n// *****************************************************************************\nextern void SetStackUnwinder(int (*unwinder)(void** pcs, int* sizes,\n                                             int max_depth, int skip_count,\n                                             const void* uc,\n                                             int* min_dropped_frames));\n\n// DefaultStackUnwinder()\n//\n// Records program counter values of up to `max_depth` frames, skipping the most\n// recent `skip_count` stack frames, and stores their corresponding values in\n// `pcs`. (Note that the frame generated for this call itself is also skipped.)\n// This function acts as a generic stack-unwinder; prefer usage of the more\n// specific `GetStack{Trace,Frames}{,WithContext}()` functions above.\n//\n// If you have set your own stack unwinder (with the `SetStackUnwinder()`\n// function above, you can still get the default stack unwinder by calling\n// `DefaultStackUnwinder()`, which will ignore any previously set stack unwinder\n// and use the default one instead.\n//\n// Because this function is generic, only `pcs` is guaranteed to be non-null\n// upon return. It is legal for `sizes`, `uc`, and `min_dropped_frames` to all\n// be null when called.\n//\n// The semantics are the same as the corresponding `GetStack*()` function in the\n// case where `absl::SetStackUnwinder()` was never called. Equivalents are:\n//\n//                       null sizes         |        non-nullptr sizes\n//             |==========================================================|\n//     null uc | GetStackTrace()            | GetStackFrames()            |\n// non-null uc | GetStackTraceWithContext() | GetStackFramesWithContext() |\n//             |==========================================================|\nextern int DefaultStackUnwinder(void** pcs, int* sizes, int max_depth,\n                                int skip_count, const void* uc,\n                                int* min_dropped_frames);\n\nnamespace debugging_internal {\n// Returns true for platforms which are expected to have functioning stack trace\n// implementations. Intended to be used for tests which want to exclude\n// verification of logic known to be broken because stack traces are not\n// working.\nextern bool StackTraceWorksForTest();\n}  // namespace debugging_internal\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03577",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/debugging/stacktrace.h",
  "source_line": 36,
  "validation_status": "validated"
}