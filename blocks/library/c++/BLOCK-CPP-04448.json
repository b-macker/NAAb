{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\nclass any;\n\n// swap()\n//\n// Swaps two `absl::any` values. Equivalent to `x.swap(y) where `x` and `y` are\n// `absl::any` types.\nvoid swap(any& x, any& y) noexcept;\n\n// make_any()\n//\n// Constructs an `absl::any` of type `T` with the given arguments.\ntemplate <typename T, typename... Args>\nany make_any(Args&&... args);\n\n// Overload of `absl::make_any()` for constructing an `absl::any` type from an\n// initializer list.\ntemplate <typename T, typename U, typename... Args>\nany make_any(std::initializer_list<U> il, Args&&... args);\n\n// any_cast()\n//\n// Statically casts the value of a `const absl::any` type to the given type.\n// This function will throw `absl::bad_any_cast` if the stored value type of the\n// `absl::any` does not match the cast.\n//\n// `any_cast()` can also be used to get a reference to the internal storage iff\n// a reference type is passed as its `ValueType`:\n//\n// Example:\n//\n//   absl::any my_any = std::vector<int>();\n//   absl::any_cast<std::vector<int>&>(my_any).push_back(42);\ntemplate <typename ValueType>\nValueType any_cast(const any& operand);\n\n// Overload of `any_cast()` to statically cast the value of a non-const\n// `absl::any` type to the given type. This function will throw\n// `absl::bad_any_cast` if the stored value type of the `absl::any` does not\n// match the cast.\ntemplate <typename ValueType>\nValueType any_cast(any& operand);  // NOLINT(runtime/references)\n\n// Overload of `any_cast()` to statically cast the rvalue of an `absl::any`\n// type. This function will throw `absl::bad_any_cast` if the stored value type\n// of the `absl::any` does not match the cast.\ntemplate <typename ValueType>\nValueType any_cast(any&& operand);\n\n// Overload of `any_cast()` to statically cast the value of a const pointer\n// `absl::any` type to the given pointer type, or `nullptr` if the stored value\n// type of the `absl::any` does not match the cast.\ntemplate <typename ValueType>\nconst ValueType* any_cast(const any* operand) noexcept;\n\n// Overload of `any_cast()` to statically cast the value of a pointer\n// `absl::any` type to the given pointer type, or `nullptr` if the stored value\n// type of the `absl::any` does not match the cast.\ntemplate <typename ValueType>\nValueType* any_cast(any* operand) noexcept;\n\n// -----------------------------------------------------------------------------\n// absl::any\n// -----------------------------------------------------------------------------\n//\n// An `absl::any` object provides the facility to either store an instance of a\n// type, known as the \"contained object\", or no value. An `absl::any` is used to\n// store values of types that are unknown at compile time. The `absl::any`\n// object, when containing a value, must contain a value type; storing a\n// reference type is neither desired nor supported.\n//\n// An `absl::any` can only store a type that is copy-constructible; move-only\n// types are not allowed within an `any` object.\n//\n// Example:\n//\n//   auto a = absl::any(65);                 // Literal, copyable\n//   auto b = absl::any(std::vector<int>()); // Default-initialized, copyable\n//   std::unique_ptr<Foo> my_foo;\n//   auto c = absl::any(std::move(my_foo));  // Error, not copy-constructible\n//\n// Note that `absl::any` makes use of decayed types (`absl::decay_t` in this\n// context) to remove const-volatile qualifiers (known as \"cv qualifiers\"),\n// decay functions to function pointers, etc. We essentially \"decay\" a given\n// type into its essential type.\n//\n// `absl::any` makes use of decayed types when determining the basic type `T` of\n// the value to store in the any's contained object. In the documentation below,\n// we explicitly denote this by using the phrase \"a decayed type of `T`\".\n//\n// Example:\n//\n//   const int a = 4;\n//   absl::any foo(a);  // Decay ensures we store an \"int\", not a \"const int&\".\n//\n//   void my_function() {}\n//   absl::any bar(my_function);  // Decay ensures we store a function pointer.\n//\n// `absl::any` is a C++11 compatible version of the C++17 `std::any` abstraction\n// and is designed to be a drop-in replacement for code compliant with C++17.\nclass any {\n private:\n  template <typename T>\n  struct IsInPlaceType;\n\n public:\n  // Constructors\n\n  // Constructs an empty `absl::any` object (`any::has_value()` will return\n  // `false`).\n  constexpr any() noexcept;\n\n  // Copy constructs an `absl::any` object with a \"contained object\" of the\n  // passed type of `other` (or an empty `absl::any` if `other.has_value()` is\n  // `false`.\n  any(const any& other)\n      : obj_(other.has_value() ? other.obj_->Clone()\n                               : std::unique_ptr<ObjInterface>()) {}\n\n  // Move constructs an `absl::any` object with a \"contained object\" of the\n  // passed type of `other` (or an empty `absl::any` if `other.has_value()` is\n  // `false`).\n  any(any&& other) noexcept = default;\n\n  // Constructs an `absl::any` object with a \"contained object\" of the decayed\n  // type of `T`, which is initialized via `std::forward<T>(value)`.\n  //\n  // This constructor will not participate in overload resolution if the\n  // decayed type of `T` is not copy-constructible.\n  template <\n      typename T, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<!absl::disjunction<\n          std::is_same<any, VT>, IsInPlaceType<VT>,\n          absl::negation<std::is_copy_constructible<VT> > >::value>* = nullptr>\n  any(T&& value) : obj_(new Obj<VT>(in_place, std::forward<T>(value))) {}\n\n  // Constructs an `absl::any` object with a \"contained object\" of the decayed\n  // type of `T`, which is initialized via `std::forward<T>(value)`.\n  template <typename T, typename... Args, typename VT = absl::decay_t<T>,\n            absl::enable_if_t<absl::conjunction<\n                std::is_copy_constructible<VT>,\n                std::is_constructible<VT, Args...>>::value>* = nullptr>\n  explicit any(in_place_type_t<T> /*tag*/, Args&&... args)\n      : obj_(new Obj<VT>(in_place, std::forward<Args>(args)...)) {}\n\n  // Constructs an `absl::any` object with a \"contained object\" of the passed\n  // type `VT` as a decayed type of `T`. `VT` is initialized as if\n  // direct-non-list-initializing an object of type `VT` with the arguments\n  // `initializer_list, std::forward<Args>(args)...`.\n  template <\n      typename T, typename U, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<\n          absl::conjunction<std::is_copy_constructible<VT>,\n                            std::is_constructible<VT, std::initializer_list<U>&,\n                                                  Args...>>::value>* = nullptr>\n  explicit any(in_place_type_t<T> /*tag*/, std::initializer_list<U> ilist,\n               Args&&... args)\n      : obj_(new Obj<VT>(in_place, ilist, std::forward<Args>(args)...)) {}\n\n  // Assignment operators\n\n  // Copy assigns an `absl::any` object with a \"contained object\" of the\n  // passed type.\n  any& operator=(const any& rhs) {\n    any(rhs).swap(*this);\n    return *this;\n  }\n\n  // Move assigns an `absl::any` object with a \"contained object\" of the\n  // passed type. `rhs` is left in a valid but otherwise unspecified state.\n  any& operator=(any&& rhs) noexcept {\n    any(std::move(rhs)).swap(*this);\n    return *this;\n  }\n\n  // Assigns an `absl::any` object with a \"contained object\" of the passed type.\n  template <typename T, typename VT = absl::decay_t<T>,\n            absl::enable_if_t<absl::conjunction<\n                absl::negation<std::is_same<VT, any>>,\n                std::is_copy_constructible<VT>>::value>* = nullptr>\n  any& operator=(T&& rhs) {\n    any tmp(in_place_type_t<VT>(), std::forward<T>(rhs));\n    tmp.swap(*this);\n    return *this;\n  }\n\n  // Modifiers\n\n  // any::emplace()\n  //\n  // Emplaces a value within an `absl::any` object by calling `any::reset()`,\n  // initializing the contained value as if direct-non-list-initializing an\n  // object of type `VT` with the arguments `std::forward<Args>(args)...`, and\n  // returning a reference to the new contained value.\n  //\n  // Note: If an exception is thrown during the call to `VT`'s constructor,\n  // `*this` does not contain a value, and any previously contained value has\n  // been destroyed.\n  template <\n      typename T, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<std::is_copy_constructible<VT>::value &&\n                        std::is_constructible<VT, Args...>::value>* = nullptr>\n  VT& emplace(Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    reset();  // NOTE: reset() is required here even in the world of exceptions.\n    Obj<VT>* const object_ptr =\n        new Obj<VT>(in_place, std::forward<Args>(args)...);\n    obj_ = std::unique_ptr<ObjInterface>(object_ptr);\n    return object_ptr->value;\n  }\n\n  // Overload of `any::emplace()` to emplace a value within an `absl::any`\n  // object by calling `any::reset()`, initializing the contained value as if\n  // direct-non-list-initializing an object of type `VT` with the arguments\n  // `initializer_list, std::forward<Args>(args)...`, and returning a reference\n  // to the new contained value.\n  //\n  // Note: If an exception is thrown during the call to `VT`'s constructor,\n  // `*this` does not contain a value, and any previously contained value has\n  // been destroyed. The function shall not participate in overload resolution\n  // unless `is_copy_constructible_v<VT>` is `true` and\n  // `is_constructible_v<VT, initializer_list<U>&, Args...>` is `true`.\n  template <\n      typename T, typename U, typename... Args, typename VT = absl::decay_t<T>,\n      absl::enable_if_t<std::is_copy_constructible<VT>::value &&\n                        std::is_constructible<VT, std::initializer_list<U>&,\n                                              Args...>::value>* = nullptr>\n  VT& emplace(std::initializer_list<U> ilist,\n              Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    reset();  // NOTE: reset() is required here even in the world of exceptions.\n    Obj<VT>* const object_ptr =\n        new Obj<VT>(in_place, ilist, std::forward<Args>(args)...);\n    obj_ = std::unique_ptr<ObjInterface>(object_ptr);\n    return object_ptr->value;\n  }\n\n  // any::reset()\n  //\n  // Resets the state of the `absl::any` object, destroying the contained object\n  // if present.\n  void reset() noexcept { obj_ = nullptr; }\n\n  // any::swap()\n  //\n  // Swaps the passed value and the value of this `absl::any` object.\n  void swap(any& other) noexcept { obj_.swap(other.obj_); }\n\n  // Observers\n\n  // any::has_value()\n  //\n  // Returns `true` if the `any` object has a contained value, otherwise\n  // returns `false`.\n  bool has_value() const noexcept { return obj_ != nullptr; }\n\n#ifdef ABSL_INTERNAL_HAS_RTTI\n  // Returns: typeid(T) if *this has a contained object of type T, otherwise\n  // typeid(void).\n  const std::type_info& type() const noexcept {\n    if (has_value()) {\n      return obj_->Type();\n    }\n\n    return typeid(void);\n  }\n#endif  // ABSL_INTERNAL_HAS_RTTI\n\n private:\n  // Tagged type-erased abstraction for holding a cloneable object.\n  class ObjInterface {\n   public:\n    virtual ~ObjInterface() = default;\n    virtual std::unique_ptr<ObjInterface> Clone() const = 0;\n    virtual const void* ObjTypeId() const noexcept = 0;\n#ifdef ABSL_INTERNAL_HAS_RTTI\n    virtual const std::type_info& Type() const noexcept = 0;\n#endif  // ABSL_INTERNAL_HAS_RTTI\n  };\n\n  // Hold a value of some queryable type, with an ability to Clone it.\n  template <typename T>\n  class Obj : public ObjInterface {\n   public:\n    template <typename... Args>\n    explicit Obj(in_place_t /*tag*/, Args&&... args)\n        : value(std::forward<Args>(args)...) {}\n\n    std::unique_ptr<ObjInterface> Clone() const final {\n      return std::unique_ptr<ObjInterface>(new Obj(in_place, value));\n    }\n\n    const void* ObjTypeId() const noexcept final { return IdForType<T>(); }\n\n#ifdef ABSL_INTERNAL_HAS_RTTI\n    const std::type_info& Type() const noexcept final { return typeid(T); }\n#endif  // ABSL_INTERNAL_HAS_RTTI\n\n    T value;\n  };\n\n  std::unique_ptr<ObjInterface> CloneObj() const {\n    if (!obj_) return nullptr;\n    return obj_->Clone();\n  }\n\n  template <typename T>\n  constexpr static const void* IdForType() {\n    // Note: This type dance is to make the behavior consistent with typeid.\n    using NormalizedType =\n        typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n\n    return base_internal::FastTypeId<NormalizedType>();\n  }\n\n  const void* GetObjTypeId() const {\n    return obj_ ? obj_->ObjTypeId() : base_internal::FastTypeId<void>();\n  }\n\n  // `absl::any` nonmember functions //\n\n  // Description at the declaration site (top of file).\n  template <typename ValueType>\n  friend ValueType any_cast(const any& operand);\n\n  // Description at the declaration site (top of file).\n  template <typename ValueType>\n  friend ValueType any_cast(any& operand);  // NOLINT(runtime/references)\n\n  // Description at the declaration site (top of file).\n  template <typename T>\n  friend const T* any_cast(const any* operand) noexcept;\n\n  // Description at the declaration site (top of file).\n  template <typename T>\n  friend T* any_cast(any* operand) noexcept;\n\n  std::unique_ptr<ObjInterface> obj_;\n};\n\n// -----------------------------------------------------------------------------\n// Implementation Details\n// -----------------------------------------------------------------------------\n\nconstexpr any::any() noexcept = default;\n\ntemplate <typename T>\nstruct any::IsInPlaceType : std::false_type {};\n\ntemplate <typename T>\nstruct any::IsInPlaceType<in_place_type_t<T>> : std::true_type {};\n\ninline void swap(any& x, any& y) noexcept { x.swap(y); }\n\n// Description at the declaration site (top of file).\ntemplate <typename T, typename... Args>\nany make_any(Args&&... args) {\n  return any(in_place_type_t<T>(), std::forward<Args>(args)...);\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename T, typename U, typename... Args>\nany make_any(std::initializer_list<U> il, Args&&... args) {\n  return any(in_place_type_t<T>(), il, std::forward<Args>(args)...);\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename ValueType>\nValueType any_cast(const any& operand) {\n  using U = typename std::remove_cv<\n      typename std::remove_reference<ValueType>::type>::type;\n  static_assert(std::is_constructible<ValueType, const U&>::value,\n                \"Invalid ValueType\");\n  auto* const result = (any_cast<U>)(&operand);\n  if (result == nullptr) {\n    any_internal::ThrowBadAnyCast();\n  }\n  return static_cast<ValueType>(*result);\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename ValueType>\nValueType any_cast(any& operand) {  // NOLINT(runtime/references)\n  using U = typename std::remove_cv<\n      typename std::remove_reference<ValueType>::type>::type;\n  static_assert(std::is_constructible<ValueType, U&>::value,\n                \"Invalid ValueType\");\n  auto* result = (any_cast<U>)(&operand);\n  if (result == nullptr) {\n    any_internal::ThrowBadAnyCast();\n  }\n  return static_cast<ValueType>(*result);\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename ValueType>\nValueType any_cast(any&& operand) {\n  using U = typename std::remove_cv<\n      typename std::remove_reference<ValueType>::type>::type;\n  static_assert(std::is_constructible<ValueType, U>::value,\n                \"Invalid ValueType\");\n  return static_cast<ValueType>(std::move((any_cast<U&>)(operand)));\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename T>\nconst T* any_cast(const any* operand) noexcept {\n  using U =\n      typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n  return operand && operand->GetObjTypeId() == any::IdForType<U>()\n             ? std::addressof(\n                   static_cast<const any::Obj<U>*>(operand->obj_.get())->value)\n             : nullptr;\n}\n\n// Description at the declaration site (top of file).\ntemplate <typename T>\nT* any_cast(any* operand) noexcept {\n  using U =\n      typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n  return operand && operand->GetObjTypeId() == any::IdForType<U>()\n             ? std::addressof(\n                   static_cast<any::Obj<U>*>(operand->obj_.get())->value)\n             : nullptr;\n}\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04448",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/any.h",
  "source_line": 88,
  "validation_status": "validated"
}