{
  "code": "{\n\nclass FileEntry;\nclass FileManager;\nclass GlobalModuleIndex;\nclass HeaderSearch;\nclass InMemoryModuleCache;\nclass PCHContainerReader;\n\nnamespace serialization {\n\n/// Manages the set of modules loaded by an AST reader.\nclass ModuleManager {\n  /// The chain of AST files, in the order in which we started to load\n  /// them (this order isn't really useful for anything).\n  SmallVector<std::unique_ptr<ModuleFile>, 2> Chain;\n\n  /// The chain of non-module PCH files. The first entry is the one named\n  /// by the user, the last one is the one that doesn't depend on anything\n  /// further.\n  SmallVector<ModuleFile *, 2> PCHChain;\n\n  // The roots of the dependency DAG of AST files. This is used\n  // to implement short-circuiting logic when running DFS over the dependencies.\n  SmallVector<ModuleFile *, 2> Roots;\n\n  /// All loaded modules, indexed by name.\n  llvm::DenseMap<const FileEntry *, ModuleFile *> Modules;\n\n  /// FileManager that handles translating between filenames and\n  /// FileEntry *.\n  FileManager &FileMgr;\n\n  /// Cache of PCM files.\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n\n  /// Knows how to unwrap module containers.\n  const PCHContainerReader &PCHContainerRdr;\n\n  /// Preprocessor's HeaderSearchInfo containing the module map.\n  const HeaderSearch &HeaderSearchInfo;\n\n  /// A lookup of in-memory (virtual file) buffers\n  llvm::DenseMap<const FileEntry *, std::unique_ptr<llvm::MemoryBuffer>>\n      InMemoryBuffers;\n\n  /// The visitation order.\n  SmallVector<ModuleFile *, 4> VisitOrder;\n\n  /// The list of module files that both we and the global module index\n  /// know about.\n  ///\n  /// Either the global index or the module manager may have modules that the\n  /// other does not know about, because the global index can be out-of-date\n  /// (in which case the module manager could have modules it does not) and\n  /// this particular translation unit might not have loaded all of the modules\n  /// known to the global index.\n  SmallVector<ModuleFile *, 4> ModulesInCommonWithGlobalIndex;\n\n  /// The global module index, if one is attached.\n  ///\n  /// The global module index will actually be owned by the ASTReader; this is\n  /// just an non-owning pointer.\n  GlobalModuleIndex *GlobalIndex = nullptr;\n\n  /// State used by the \"visit\" operation to avoid malloc traffic in\n  /// calls to visit().\n  struct VisitState {\n    explicit VisitState(unsigned N) : VisitNumber(N, 0) {\n      Stack.reserve(N);\n    }\n\n    /// The stack used when marking the imports of a particular module\n    /// as not-to-be-visited.\n    SmallVector<ModuleFile *, 4> Stack;\n\n    /// The visit number of each module file, which indicates when\n    /// this module file was last visited.\n    SmallVector<unsigned, 4> VisitNumber;\n\n    /// The next visit number to use to mark visited module files.\n    unsigned NextVisitNumber = 1;\n\n    /// The next visit state.\n    std::unique_ptr<VisitState> NextState;\n  };\n\n  /// The first visit() state in the chain.\n  std::unique_ptr<VisitState> FirstVisitState;\n\n  std::unique_ptr<VisitState> allocateVisitState();\n  void returnVisitState(std::unique_ptr<VisitState> State);\n\npublic:\n  using ModuleIterator = llvm::pointee_iterator<\n      SmallVectorImpl<std::unique_ptr<ModuleFile>>::iterator>;\n  using ModuleConstIterator = llvm::pointee_iterator<\n      SmallVectorImpl<std::unique_ptr<ModuleFile>>::const_iterator>;\n  using ModuleReverseIterator = llvm::pointee_iterator<\n      SmallVectorImpl<std::unique_ptr<ModuleFile>>::reverse_iterator>;\n  using ModuleOffset = std::pair<uint32_t, StringRef>;\n\n  explicit ModuleManager(FileManager &FileMgr, InMemoryModuleCache &ModuleCache,\n                         const PCHContainerReader &PCHContainerRdr,\n                         const HeaderSearch &HeaderSearchInfo);\n\n  /// Forward iterator to traverse all loaded modules.\n  ModuleIterator begin() { return Chain.begin(); }\n\n  /// Forward iterator end-point to traverse all loaded modules\n  ModuleIterator end() { return Chain.end(); }\n\n  /// Const forward iterator to traverse all loaded modules.\n  ModuleConstIterator begin() const { return Chain.begin(); }\n\n  /// Const forward iterator end-point to traverse all loaded modules\n  ModuleConstIterator end() const { return Chain.end(); }\n\n  /// Reverse iterator to traverse all loaded modules.\n  ModuleReverseIterator rbegin() { return Chain.rbegin(); }\n\n  /// Reverse iterator end-point to traverse all loaded modules.\n  ModuleReverseIterator rend() { return Chain.rend(); }\n\n  /// A range covering the PCH and preamble module files loaded.\n  llvm::iterator_range<SmallVectorImpl<ModuleFile *>::const_iterator>\n  pch_modules() const {\n    return llvm::make_range(PCHChain.begin(), PCHChain.end());\n  }\n\n  /// Returns the primary module associated with the manager, that is,\n  /// the first module loaded\n  ModuleFile &getPrimaryModule() { return *Chain[0]; }\n\n  /// Returns the primary module associated with the manager, that is,\n  /// the first module loaded.\n  ModuleFile &getPrimaryModule() const { return *Chain[0]; }\n\n  /// Returns the module associated with the given index\n  ModuleFile &operator[](unsigned Index) const { return *Chain[Index]; }\n\n  /// Returns the module associated with the given file name.\n  ModuleFile *lookupByFileName(StringRef FileName) const;\n\n  /// Returns the module associated with the given module name.\n  ModuleFile *lookupByModuleName(StringRef ModName) const;\n\n  /// Returns the module associated with the given module file.\n  ModuleFile *lookup(const FileEntry *File) const;\n\n  /// Returns the in-memory (virtual file) buffer with the given name\n  std::unique_ptr<llvm::MemoryBuffer> lookupBuffer(StringRef Name);\n\n  /// Number of modules loaded\n  unsigned size() const { return Chain.size(); }\n\n  /// The result of attempting to add a new module.\n  enum AddModuleResult {\n    /// The module file had already been loaded.\n    AlreadyLoaded,\n\n    /// The module file was just loaded in response to this call.\n    NewlyLoaded,\n\n    /// The module file is missing.\n    Missing,\n\n    /// The module file is out-of-date.\n    OutOfDate\n  };\n\n  using ASTFileSignatureReader = ASTFileSignature (*)(StringRef);\n\n  /// Attempts to create a new module and add it to the list of known\n  /// modules.\n  ///\n  /// \\param FileName The file name of the module to be loaded.\n  ///\n  /// \\param Type The kind of module being loaded.\n  ///\n  /// \\param ImportLoc The location at which the module is imported.\n  ///\n  /// \\param ImportedBy The module that is importing this module, or NULL if\n  /// this module is imported directly by the user.\n  ///\n  /// \\param Generation The generation in which this module was loaded.\n  ///\n  /// \\param ExpectedSize The expected size of the module file, used for\n  /// validation. This will be zero if unknown.\n  ///\n  /// \\param ExpectedModTime The expected modification time of the module\n  /// file, used for validation. This will be zero if unknown.\n  ///\n  /// \\param ExpectedSignature The expected signature of the module file, used\n  /// for validation. This will be zero if unknown.\n  ///\n  /// \\param ReadSignature Reads the signature from an AST file without actually\n  /// loading it.\n  ///\n  /// \\param Module A pointer to the module file if the module was successfully\n  /// loaded.\n  ///\n  /// \\param ErrorStr Will be set to a non-empty string if any errors occurred\n  /// while trying to load the module.\n  ///\n  /// \\return A pointer to the module that corresponds to this file name,\n  /// and a value indicating whether the module was loaded.\n  AddModuleResult addModule(StringRef FileName, ModuleKind Type,\n                            SourceLocation ImportLoc,\n                            ModuleFile *ImportedBy, unsigned Generation,\n                            off_t ExpectedSize, time_t ExpectedModTime,\n                            ASTFileSignature ExpectedSignature,\n                            ASTFileSignatureReader ReadSignature,\n                            ModuleFile *&Module,\n                            std::string &ErrorStr);\n\n  /// Remove the modules starting from First (to the end).\n  void removeModules(ModuleIterator First);\n\n  /// Add an in-memory buffer the list of known buffers\n  void addInMemoryBuffer(StringRef FileName,\n                         std::unique_ptr<llvm::MemoryBuffer> Buffer);\n\n  /// Set the global module index.\n  void setGlobalIndex(GlobalModuleIndex *Index);\n\n  /// Notification from the AST reader that the given module file\n  /// has been \"accepted\", and will not (can not) be unloaded.\n  void moduleFileAccepted(ModuleFile *MF);\n\n  /// Visit each of the modules.\n  ///\n  /// This routine visits each of the modules, starting with the\n  /// \"root\" modules that no other loaded modules depend on, and\n  /// proceeding to the leaf modules, visiting each module only once\n  /// during the traversal.\n  ///\n  /// This traversal is intended to support various \"lookup\"\n  /// operations that can find data in any of the loaded modules.\n  ///\n  /// \\param Visitor A visitor function that will be invoked with each\n  /// module. The return value must be convertible to bool; when false, the\n  /// visitation continues to modules that the current module depends on. When\n  /// true, the visitation skips any modules that the current module depends on.\n  ///\n  /// \\param ModuleFilesHit If non-NULL, contains the set of module files\n  /// that we know we need to visit because the global module index told us to.\n  /// Any module that is known to both the global module index and the module\n  /// manager that is *not* in this set can be skipped.\n  void visit(llvm::function_ref<bool(ModuleFile &M)> Visitor,\n             llvm::SmallPtrSetImpl<ModuleFile *> *ModuleFilesHit = nullptr);\n\n  /// Attempt to resolve the given module file name to a file entry.\n  ///\n  /// \\param FileName The name of the module file.\n  ///\n  /// \\param ExpectedSize The size that the module file is expected to have.\n  /// If the actual size differs, the resolver should return \\c true.\n  ///\n  /// \\param ExpectedModTime The modification time that the module file is\n  /// expected to have. If the actual modification time differs, the resolver\n  /// should return \\c true.\n  ///\n  /// \\param File Will be set to the file if there is one, or null\n  /// otherwise.\n  ///\n  /// \\returns True if a file exists but does not meet the size/\n  /// modification time criteria, false if the file is either available and\n  /// suitable, or is missing.\n  bool lookupModuleFile(StringRef FileName, off_t ExpectedSize,\n                        time_t ExpectedModTime, OptionalFileEntryRef &File);\n\n  /// View the graphviz representation of the module graph.\n  void viewGraph();\n\n  InMemoryModuleCache &getModuleCache() const { return *ModuleCache; }\n};\n\n} // namespace serialization\n\n}",
  "id": "BLOCK-CPP-21048",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/ModuleManager.h",
  "source_line": 35,
  "validation_status": "validated"
}