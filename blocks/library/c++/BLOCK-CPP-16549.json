{
  "code": "#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/TargetCXXABI.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/TargetParser/Triple.h\"\n#include <optional>\n#include <string>\n#include <vector>\n#include \"clang/Basic/LangOptions.def\"\n#include \"clang/Basic/LangOptions.def\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-16549_execute() {\n    {\npublic:\n  using Visibility = clang::Visibility;\n  using RoundingMode = llvm::RoundingMode;\n\n  enum GCMode { NonGC, GCOnly, HybridGC };\n  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq };\n\n  // Automatic variables live on the stack, and when trivial they're usually\n  // uninitialized because it's undefined behavior to use them without\n  // initializing them.\n  enum class TrivialAutoVarInitKind { Uninitialized, Zero, Pattern };\n\n  enum SignedOverflowBehaviorTy {\n    // Default C standard behavior.\n    SOB_Undefined,\n\n    // -fwrapv\n    SOB_Defined,\n\n    // -ftrapv\n    SOB_Trapping\n  };\n\n  // FIXME: Unify with TUKind.\n  enum CompilingModuleKind {\n    /// Not compiling a module interface at all.\n    CMK_None,\n\n    /// Compiling a module from a module map.\n    CMK_ModuleMap,\n\n    /// Compiling a module header unit.\n    CMK_HeaderUnit,\n\n    /// Compiling a C++ modules interface unit.\n    CMK_ModuleInterface,\n  };\n\n  enum PragmaMSPointersToMembersKind {\n    PPTMK_BestCase,\n    PPTMK_FullGeneralitySingleInheritance,\n    PPTMK_FullGeneralityMultipleInheritance,\n    PPTMK_FullGeneralityVirtualInheritance\n  };\n\n  using MSVtorDispMode = clang::MSVtorDispMode;\n\n  enum DefaultCallingConvention {\n    DCC_None,\n    DCC_CDecl,\n    DCC_FastCall,\n    DCC_StdCall,\n    DCC_VectorCall,\n    DCC_RegCall\n  };\n\n  enum AddrSpaceMapMangling { ASMM_Target, ASMM_On, ASMM_Off };\n\n  // Corresponds to _MSC_VER\n  enum MSVCMajorVersion {\n    MSVC2010 = 1600,\n    MSVC2012 = 1700,\n    MSVC2013 = 1800,\n    MSVC2015 = 1900,\n    MSVC2017 = 1910,\n    MSVC2017_5 = 1912,\n    MSVC2017_7 = 1914,\n    MSVC2019 = 1920,\n    MSVC2019_5 = 1925,\n    MSVC2019_8 = 1928,\n  };\n\n  enum SYCLMajorVersion {\n    SYCL_None,\n    SYCL_2017,\n    SYCL_2020,\n    // The \"default\" SYCL version to be used when none is specified on the\n    // frontend command line.\n    SYCL_Default = SYCL_2020\n  };\n\n  enum HLSLLangStd {\n    HLSL_Unset = 0,\n    HLSL_2015 = 2015,\n    HLSL_2016 = 2016,\n    HLSL_2017 = 2017,\n    HLSL_2018 = 2018,\n    HLSL_2021 = 2021,\n    HLSL_202x = 2029,\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 6.0.x\n    /// (SVN r321711). This causes determination of whether a type is\n    /// standard-layout to ignore collisions between empty base classes\n    /// and between base classes and member subobjects, which affects\n    /// whether we reuse base class tail padding in some ABIs.\n    Ver6,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 7.0.x\n    /// (SVN r338536). This causes alignof (C++) and _Alignof (C11) to be\n    /// compatible with __alignof (i.e., return the preferred alignment)\n    /// rather than returning the required alignment.\n    Ver7,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 9.0.x\n    /// (SVN r351319). This causes vectors of __int128 to be passed in memory\n    /// instead of passing in multiple scalar registers on x86_64 on Linux and\n    /// NetBSD.\n    Ver9,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 11.0.x\n    /// (git 2e10b7a39b93). This causes clang to pass unions with a 256-bit\n    /// vector member on the stack instead of using registers, to not properly\n    /// mangle substitutions for template names in some cases, and to mangle\n    /// declaration template arguments without a cast to the parameter type\n    /// even when that can lead to mangling collisions.\n    Ver11,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 12.0.x\n    /// (git 8e464dd76bef). This causes clang to mangle lambdas within\n    /// global-scope inline variables incorrectly.\n    Ver12,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 14.0.x.\n    /// This causes clang to:\n    ///   - mangle dependent nested names incorrectly.\n    ///   - make trivial only those defaulted copy constructors with a\n    ///     parameter-type-list equivalent to the parameter-type-list of an\n    ///     implicit declaration.\n    Ver14,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 15.0.x.\n    /// This causes clang to:\n    ///   - Reverse the implementation for DR692, DR1395 and DR1432.\n    ///   - pack non-POD members of packed structs.\n    ///   - consider classes with defaulted special member functions non-pod.\n    Ver15,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum class CoreFoundationABI {\n    /// No interoperability ABI has been specified\n    Unspecified,\n    /// CoreFoundation does not have any language interoperability\n    Standalone,\n    /// Interoperability with the ObjectiveC runtime\n    ObjectiveC,\n    /// Interoperability with the latest known version of the Swift runtime\n    Swift,\n    /// Interoperability with the Swift 5.0 runtime\n    Swift5_0,\n    /// Interoperability with the Swift 4.2 runtime\n    Swift4_2,\n    /// Interoperability with the Swift 4.1 runtime\n    Swift4_1,\n  };\n\n  enum FPModeKind {\n    // Disable the floating point pragma\n    FPM_Off,\n\n    // Enable the floating point pragma\n    FPM_On,\n\n    // Aggressively fuse FP ops (E.g. FMA) disregarding pragmas.\n    FPM_Fast,\n\n    // Aggressively fuse FP ops and honor pragmas.\n    FPM_FastHonorPragmas\n  };\n\n  /// Possible floating point exception behavior.\n  enum FPExceptionModeKind {\n    /// Assume that floating-point exceptions are masked.\n    FPE_Ignore,\n    /// Transformations do not cause new exceptions but may hide some.\n    FPE_MayTrap,\n    /// Strictly preserve the floating-point exception semantics.\n    FPE_Strict,\n    /// Used internally to represent initial unspecified value.\n    FPE_Default\n  };\n\n  /// Possible float expression evaluation method choices.\n  enum FPEvalMethodKind {\n    /// The evaluation method cannot be determined or is inconsistent for this\n    /// target.\n    FEM_Indeterminable = -1,\n    /// Use the declared type for fp arithmetic.\n    FEM_Source = 0,\n    /// Use the type double for fp arithmetic.\n    FEM_Double = 1,\n    /// Use extended type for fp arithmetic.\n    FEM_Extended = 2,\n    /// Used only for FE option processing; this is only used to indicate that\n    /// the user did not specify an explicit evaluation method on the command\n    /// line and so the target should be queried for its default evaluation\n    /// method instead.\n    FEM_UnsetOnCommandLine = 3\n  };\n\n  enum ExcessPrecisionKind { FPP_Standard, FPP_Fast, FPP_None };\n\n  /// Possible exception handling behavior.\n  enum class ExceptionHandlingKind { None, SjLj, WinEH, DwarfCFI, Wasm };\n\n  enum class LaxVectorConversionKind {\n    /// Permit no implicit vector bitcasts.\n    None,\n    /// Permit vector bitcasts between integer vectors with different numbers\n    /// of elements but the same total bit-width.\n    Integer,\n    /// Permit vector bitcasts between all vectors with the same total\n    /// bit-width.\n    All,\n  };\n\n  enum class AltivecSrcCompatKind {\n    // All vector compares produce scalars except vector pixel and vector bool.\n    // The types vector pixel and vector bool return vector results.\n    Mixed,\n    // All vector compares produce vector results as in GCC.\n    GCC,\n    // All vector compares produce scalars as in XL.\n    XL,\n    // Default clang behaviour.\n    Default = Mixed,\n  };\n\n  enum class SignReturnAddressScopeKind {\n    /// No signing for any function.\n    None,\n    /// Sign the return address of functions that spill LR.\n    NonLeaf,\n    /// Sign the return address of all functions,\n    All\n  };\n\n  enum class SignReturnAddressKeyKind {\n    /// Return address signing uses APIA key.\n    AKey,\n    /// Return address signing uses APIB key.\n    BKey\n  };\n\n  enum class ThreadModelKind {\n    /// POSIX Threads.\n    POSIX,\n    /// Single Threaded Environment.\n    Single\n  };\n\n  enum class ExtendArgsKind {\n    /// Integer arguments are sign or zero extended to 32/64 bits\n    /// during default argument promotions.\n    ExtendTo32,\n    ExtendTo64\n  };\n\n  enum class GPUDefaultStreamKind {\n    /// Legacy default stream\n    Legacy,\n    /// Per-thread default stream\n    PerThread,\n  };\n\n  enum class DefaultVisiblityExportMapping {\n    None,\n    /// map only explicit default visibilities to exported\n    Explicit,\n    /// map all default visibilities to exported\n    All,\n  };\n\n  enum class StrictFlexArraysLevelKind {\n    /// Any trailing array member is a FAM.\n    Default = 0,\n    /// Any trailing array member of undefined, 0, or 1 size is a FAM.\n    OneZeroOrIncomplete = 1,\n    /// Any trailing array member of undefined or 0 size is a FAM.\n    ZeroOrIncomplete = 2,\n    /// Any trailing array member of undefined size is a FAM.\n    IncompleteOnly = 3,\n  };\n\npublic:\n  /// The used language standard.\n  LangStandard::Kind LangStd;\n\n  /// Set of enabled sanitizers.\n  SanitizerSet Sanitize;\n  /// Is at least one coverage instrumentation type enabled.\n  bool SanitizeCoverage = false;\n\n  /// Paths to files specifying which objects\n  /// (files, functions, variables) should not be instrumented.\n  std::vector<std::string> NoSanitizeFiles;\n\n  /// Paths to the XRay \"always instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"always instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayAlwaysInstrumentFiles;\n\n  /// Paths to the XRay \"never instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"never instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayNeverInstrumentFiles;\n\n  /// Paths to the XRay attribute list files, specifying which objects\n  /// (files, functions, variables) should be imbued with the appropriate XRay\n  /// attribute(s).\n  std::vector<std::string> XRayAttrListFiles;\n\n  /// Paths to special case list files specifying which entities\n  /// (files, functions) should or should not be instrumented.\n  std::vector<std::string> ProfileListFiles;\n\n  clang::ObjCRuntime ObjCRuntime;\n\n  CoreFoundationABI CFRuntime = CoreFoundationABI::Unspecified;\n\n  std::string ObjCConstantStringClass;\n\n  /// The name of the handler function to be called when -ftrapv is\n  /// specified.\n  ///\n  /// If none is specified, abort (GCC-compatible behaviour).\n  std::string OverflowHandler;\n\n  /// The module currently being compiled as specified by -fmodule-name.\n  std::string ModuleName;\n\n  /// The name of the current module, of which the main source file\n  /// is a part. If CompilingModule is set, we are compiling the interface\n  /// of this module, otherwise we are compiling an implementation file of\n  /// it. This starts as ModuleName in case -fmodule-name is provided and\n  /// changes during compilation to reflect the current module.\n  std::string CurrentModule;\n\n  /// The names of any features to enable in module 'requires' decls\n  /// in addition to the hard-coded list in Module.cpp and the target features.\n  ///\n  /// This list is sorted.\n  std::vector<std::string> ModuleFeatures;\n\n  /// Options for parsing comments.\n  CommentOptions CommentOpts;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  /// A prefix map for __FILE__, __BASE_FILE__ and __builtin_FILE().\n  std::map<std::string, std::string, std::greater<std::string>> MacroPrefixMap;\n\n  /// Triples of the OpenMP targets that the host code codegen should\n  /// take into account in order to generate accurate offloading descriptors.\n  std::vector<llvm::Triple> OMPTargetTriples;\n\n  /// Name of the IR file that contains the result of the OpenMP target\n  /// host code generation.\n  std::string OMPHostIRFile;\n\n  /// The user provided compilation unit ID, if non-empty. This is used to\n  /// externalize static variables which is needed to support accessing static\n  /// device variables in host code for single source offloading languages\n  /// like CUDA/HIP.\n  std::string CUID;\n\n  /// C++ ABI to compile with, if specified by the frontend through -fc++-abi=.\n  /// This overrides the default ABI used by the target.\n  std::optional<TargetCXXABI::Kind> CXXABI;\n\n  /// Indicates whether the front-end is explicitly told that the\n  /// input is a header file (i.e. -x c-header).\n  bool IsHeaderFile = false;\n\n  /// The default stream kind used for HIP kernel launching.\n  GPUDefaultStreamKind GPUDefaultStream;\n\n  /// The seed used by the randomize structure layout feature.\n  std::string RandstructSeed;\n\n  /// Indicates whether to use target's platform-specific file separator when\n  /// __FILE__ macro is used and when concatenating filename with directory or\n  /// to use build environment environment's platform-specific file separator.\n  ///\n  /// The plaform-specific path separator is the backslash(\\) for Windows and\n  /// forward slash (/) elsewhere.\n  bool UseTargetPathSeparator = false;\n\n  // Indicates whether we should keep all nullptr checks for pointers\n  // received as a result of a standard operator new (-fcheck-new)\n  bool CheckNew = false;\n\n  LangOptions();\n\n  /// Set language defaults for the given input language and\n  /// language standard in the given LangOptions object.\n  ///\n  /// \\param Opts - The LangOptions object to set up.\n  /// \\param Lang - The input language.\n  /// \\param T - The target triple.\n  /// \\param Includes - If the language requires extra headers to be implicitly\n  ///                   included, they will be appended to this list.\n  /// \\param LangStd - The input language standard.\n  static void\n  setLangDefaults(LangOptions &Opts, Language Lang, const llvm::Triple &T,\n                  std::vector<std::string> &Includes,\n                  LangStandard::Kind LangStd = LangStandard::lang_unspecified);\n\n  // Define accessors/mutators for language options of enumeration type.\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/LangOptions.def\"\n\n  /// Are we compiling a module?\n  bool isCompilingModule() const {\n    return getCompilingModule() != CMK_None;\n  }\n\n  /// Are we compiling a standard c++ module interface?\n  bool isCompilingModuleInterface() const {\n    return getCompilingModule() == CMK_ModuleInterface;\n  }\n\n  /// Are we compiling a module implementation?\n  bool isCompilingModuleImplementation() const {\n    return !isCompilingModule() && !ModuleName.empty();\n  }\n\n  /// Do we need to track the owning module for a local declaration?\n  bool trackLocalOwningModule() const {\n    return isCompilingModule() || ModulesLocalVisibility;\n  }\n\n  bool isSignedOverflowDefined() const {\n    return getSignedOverflowBehavior() == SOB_Defined;\n  }\n\n  bool isSubscriptPointerArithmetic() const {\n    return ObjCRuntime.isSubscriptPointerArithmetic() &&\n           !ObjCSubscriptingLegacyRuntime;\n  }\n\n  bool isCompatibleWithMSVC(MSVCMajorVersion MajorVersion) const {\n    return MSCompatibilityVersion >= MajorVersion * 100000U;\n  }\n\n  /// Reset all of the options that are not considered when building a\n  /// module.\n  void resetNonModularOptions();\n\n  /// Is this a libc/libm function that is no longer recognized as a\n  /// builtin because a -fno-builtin-* option has been specified?\n  bool isNoBuiltinFunc(StringRef Name) const;\n\n  /// True if any ObjC types may have non-trivial lifetime qualifiers.\n  bool allowsNonTrivialObjCLifetimeQualifiers() const {\n    return ObjCAutoRefCount || ObjCWeak;\n  }\n\n  bool assumeFunctionsAreConvergent() const {\n    return ConvergentFunctions;\n  }\n\n  /// Return the OpenCL C or C++ version as a VersionTuple.\n  VersionTuple getOpenCLVersionTuple() const;\n\n  /// Return the OpenCL version that kernel language is compatible with\n  unsigned getOpenCLCompatibleVersion() const;\n\n  /// Return the OpenCL C or C++ for OpenCL language name and version\n  /// as a string.\n  std::string getOpenCLVersionString() const;\n\n  /// Returns true if functions without prototypes or functions with an\n  /// identifier list (aka K&R C functions) are not allowed.\n  bool requiresStrictPrototypes() const {\n    return CPlusPlus || C2x || DisableKNRFunctions;\n  }\n\n  /// Returns true if implicit function declarations are allowed in the current\n  /// language mode.\n  bool implicitFunctionsAllowed() const {\n    return !requiresStrictPrototypes() && !OpenCL;\n  }\n\n  /// Returns true if implicit int is part of the language requirements.\n  bool isImplicitIntRequired() const { return !CPlusPlus && !C99; }\n\n  /// Returns true if implicit int is supported at all.\n  bool isImplicitIntAllowed() const { return !CPlusPlus && !C2x; }\n\n  /// Check if return address signing is enabled.\n  bool hasSignReturnAddress() const {\n    return getSignReturnAddressScope() != SignReturnAddressScopeKind::None;\n  }\n\n  /// Check if return address signing uses AKey.\n  bool isSignReturnAddressWithAKey() const {\n    return getSignReturnAddressKey() == SignReturnAddressKeyKind::AKey;\n  }\n\n  /// Check if leaf functions are also signed.\n  bool isSignReturnAddressScopeAll() const {\n    return getSignReturnAddressScope() == SignReturnAddressScopeKind::All;\n  }\n\n  bool hasSjLjExceptions() const {\n    return getExceptionHandling() == ExceptionHandlingKind::SjLj;\n  }\n\n  bool hasSEHExceptions() const {\n    return getExceptionHandling() == ExceptionHandlingKind::WinEH;\n  }\n\n  bool hasDWARFExceptions() const {\n    return getExceptionHandling() == ExceptionHandlingKind::DwarfCFI;\n  }\n\n  bool hasWasmExceptions() const {\n    return getExceptionHandling() == ExceptionHandlingKind::Wasm;\n  }\n\n  bool isSYCL() const { return SYCLIsDevice || SYCLIsHost; }\n\n  bool hasDefaultVisibilityExportMapping() const {\n    return getDefaultVisibilityExportMapping() !=\n           DefaultVisiblityExportMapping::None;\n  }\n\n  bool isExplicitDefaultVisibilityExportMapping() const {\n    return getDefaultVisibilityExportMapping() ==\n           DefaultVisiblityExportMapping::Explicit;\n  }\n\n  bool isAllDefaultVisibilityExportMapping() const {\n    return getDefaultVisibilityExportMapping() ==\n           DefaultVisiblityExportMapping::All;\n  }\n\n  /// Remap path prefix according to -fmacro-prefix-path option.\n  void remapPathPrefix(SmallVectorImpl<char> &Path) const;\n\n  RoundingMode getDefaultRoundingMode() const {\n    return RoundingMath ? RoundingMode::Dynamic\n                        : RoundingMode::NearestTiesToEven;\n  }\n\n  FPExceptionModeKind getDefaultExceptionMode() const {\n    FPExceptionModeKind EM = getFPExceptionMode();\n    if (EM == FPExceptionModeKind::FPE_Default)\n      return FPExceptionModeKind::FPE_Ignore;\n    return EM;\n  }\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-16549",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/LangOptions.h",
  "source_line": 82,
  "validation_status": "validated"
}