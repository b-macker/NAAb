{
  "code": "{\n\nclass SarifDocumentWriter;\nclass SourceManager;\n\nnamespace detail {\n\n/// \\internal\n/// An artifact location is SARIF's way of describing the complete location\n/// of an artifact encountered during analysis. The \\c artifactLocation object\n/// typically consists of a URI, and/or an index to reference the artifact it\n/// locates.\n///\n/// This builder makes an additional assumption: that every artifact encountered\n/// by \\c clang will be a physical, top-level artifact. Which is why the static\n/// creation method \\ref SarifArtifactLocation::create takes a mandatory URI\n/// parameter. The official standard states that either a \\c URI or \\c Index\n/// must be available in the object, \\c clang picks the \\c URI as a reasonable\n/// default, because it intends to deal in physical artifacts for now.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317427\">artifactLocation object</a>\n/// 2. \\ref SarifArtifact\nclass SarifArtifactLocation {\nprivate:\n  friend class clang::SarifDocumentWriter;\n\n  std::optional<uint32_t> Index;\n  std::string URI;\n\n  SarifArtifactLocation() = delete;\n  explicit SarifArtifactLocation(const std::string &URI) : URI(URI) {}\n\npublic:\n  static SarifArtifactLocation create(llvm::StringRef URI) {\n    return SarifArtifactLocation{URI.str()};\n  }\n\n  SarifArtifactLocation setIndex(uint32_t Idx) {\n    Index = Idx;\n    return *this;\n  }\n};\n\n/// \\internal\n/// An artifact in SARIF is any object (a sequence of bytes) addressable by\n/// a URI (RFC 3986). The most common type of artifact for clang's use-case\n/// would be source files. SARIF's artifact object is described in detail in\n/// section 3.24.\n//\n/// Since every clang artifact MUST have a location (there being no nested\n/// artifacts), the creation method \\ref SarifArtifact::create requires a\n/// \\ref SarifArtifactLocation object.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317611\">artifact object</a>\nclass SarifArtifact {\nprivate:\n  friend class clang::SarifDocumentWriter;\n\n  std::optional<uint32_t> Offset;\n  std::optional<size_t> Length;\n  std::string MimeType;\n  SarifArtifactLocation Location;\n  llvm::SmallVector<std::string, 4> Roles;\n\n  SarifArtifact() = delete;\n\n  explicit SarifArtifact(const SarifArtifactLocation &Loc) : Location(Loc) {}\n\npublic:\n  static SarifArtifact create(const SarifArtifactLocation &Loc) {\n    return SarifArtifact{Loc};\n  }\n\n  SarifArtifact setOffset(uint32_t ArtifactOffset) {\n    Offset = ArtifactOffset;\n    return *this;\n  }\n\n  SarifArtifact setLength(size_t NumBytes) {\n    Length = NumBytes;\n    return *this;\n  }\n\n  SarifArtifact setRoles(std::initializer_list<llvm::StringRef> ArtifactRoles) {\n    Roles.assign(ArtifactRoles.begin(), ArtifactRoles.end());\n    return *this;\n  }\n\n  SarifArtifact setMimeType(llvm::StringRef ArtifactMimeType) {\n    MimeType = ArtifactMimeType.str();\n    return *this;\n  }\n};\n\n} // namespace detail\n\nenum class ThreadFlowImportance { Important, Essential, Unimportant };\n\n/// The level of severity associated with a \\ref SarifResult.\n///\n/// Of all the levels, \\c None is the only one that is not associated with\n/// a failure.\n///\n/// A typical mapping for clang's DiagnosticKind to SarifResultLevel would look\n/// like:\n/// * \\c None: \\ref clang::DiagnosticsEngine::Level::Remark, \\ref clang::DiagnosticsEngine::Level::Ignored\n/// * \\c Note: \\ref clang::DiagnosticsEngine::Level::Note\n/// * \\c Warning: \\ref clang::DiagnosticsEngine::Level::Warning\n/// * \\c Error could be generated from one of:\n///   - \\ref clang::DiagnosticsEngine::Level::Warning with \\c -Werror\n///   - \\ref clang::DiagnosticsEngine::Level::Error\n///   - \\ref clang::DiagnosticsEngine::Level::Fatal when \\ref clang::DiagnosticsEngine::ErrorsAsFatal is set.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317648\">level property</a>\nenum class SarifResultLevel { None, Note, Warning, Error };\n\n/// A thread flow is a sequence of code locations that specify a possible path\n/// through a single thread of execution.\n/// A thread flow in SARIF is related to a code flow which describes\n/// the progress of one or more programs through one or more thread flows.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317744\">threadFlow object</a>\n/// 2. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317740\">codeFlow object</a>\nclass ThreadFlow {\n  friend class SarifDocumentWriter;\n\n  CharSourceRange Range;\n  ThreadFlowImportance Importance;\n  std::string Message;\n\n  ThreadFlow() = default;\n\npublic:\n  static ThreadFlow create() { return {}; }\n\n  ThreadFlow setRange(const CharSourceRange &ItemRange) {\n    assert(ItemRange.isCharRange() &&\n           \"ThreadFlows require a character granular source range!\");\n    Range = ItemRange;\n    return *this;\n  }\n\n  ThreadFlow setImportance(const ThreadFlowImportance &ItemImportance) {\n    Importance = ItemImportance;\n    return *this;\n  }\n\n  ThreadFlow setMessage(llvm::StringRef ItemMessage) {\n    Message = ItemMessage.str();\n    return *this;\n  }\n};\n\n/// A SARIF Reporting Configuration (\\c reportingConfiguration) object contains\n/// properties for a \\ref SarifRule that can be configured at runtime before\n/// analysis begins.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317852\">reportingConfiguration object</a>\nclass SarifReportingConfiguration {\n  friend class clang::SarifDocumentWriter;\n\n  bool Enabled = true;\n  SarifResultLevel Level = SarifResultLevel::Warning;\n  float Rank = -1.0f;\n\n  SarifReportingConfiguration() = default;\n\npublic:\n  static SarifReportingConfiguration create() { return {}; };\n\n  SarifReportingConfiguration disable() {\n    Enabled = false;\n    return *this;\n  }\n\n  SarifReportingConfiguration enable() {\n    Enabled = true;\n    return *this;\n  }\n\n  SarifReportingConfiguration setLevel(SarifResultLevel TheLevel) {\n    Level = TheLevel;\n    return *this;\n  }\n\n  SarifReportingConfiguration setRank(float TheRank) {\n    assert(TheRank >= 0.0f && \"Rule rank cannot be smaller than 0.0\");\n    assert(TheRank <= 100.0f && \"Rule rank cannot be larger than 100.0\");\n    Rank = TheRank;\n    return *this;\n  }\n};\n\n/// A SARIF rule (\\c reportingDescriptor object) contains information that\n/// describes a reporting item generated by a tool. A reporting item is\n/// either a result of analysis or notification of a condition encountered by\n/// the tool. Rules are arbitrary but are identifiable by a hierarchical\n/// rule-id.\n///\n/// This builder provides an interface to create SARIF \\c reportingDescriptor\n/// objects via the \\ref SarifRule::create static method.\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317836\">reportingDescriptor object</a>\nclass SarifRule {\n  friend class clang::SarifDocumentWriter;\n\n  std::string Name;\n  std::string Id;\n  std::string Description;\n  std::string HelpURI;\n  SarifReportingConfiguration DefaultConfiguration;\n\n  SarifRule() : DefaultConfiguration(SarifReportingConfiguration::create()) {}\n\npublic:\n  static SarifRule create() { return {}; }\n\n  SarifRule setName(llvm::StringRef RuleName) {\n    Name = RuleName.str();\n    return *this;\n  }\n\n  SarifRule setRuleId(llvm::StringRef RuleId) {\n    Id = RuleId.str();\n    return *this;\n  }\n\n  SarifRule setDescription(llvm::StringRef RuleDesc) {\n    Description = RuleDesc.str();\n    return *this;\n  }\n\n  SarifRule setHelpURI(llvm::StringRef RuleHelpURI) {\n    HelpURI = RuleHelpURI.str();\n    return *this;\n  }\n\n  SarifRule\n  setDefaultConfiguration(const SarifReportingConfiguration &Configuration) {\n    DefaultConfiguration = Configuration;\n    return *this;\n  }\n};\n\n/// A SARIF result (also called a \"reporting item\") is a unit of output\n/// produced when one of the tool's \\c reportingDescriptor encounters a match\n/// on the file being analysed by the tool.\n///\n/// This builder provides a \\ref SarifResult::create static method that can be\n/// used to create an empty shell onto which attributes can be added using the\n/// \\c setX(...) methods.\n///\n/// For example:\n/// \\code{.cpp}\n/// SarifResult result = SarifResult::create(...)\n///                         .setRuleId(...)\n///                         .setDiagnosticMessage(...);\n/// \\endcode\n///\n/// Reference:\n/// 1. <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317638\">SARIF<pre>result</pre></a>\nclass SarifResult {\n  friend class clang::SarifDocumentWriter;\n\n  // NOTE:\n  // This type cannot fit all possible indexes representable by JSON, but is\n  // chosen because it is the largest unsigned type that can be safely\n  // converted to an \\c int64_t.\n  uint32_t RuleIdx;\n  std::string RuleId;\n  std::string DiagnosticMessage;\n  llvm::SmallVector<CharSourceRange, 8> Locations;\n  llvm::SmallVector<ThreadFlow, 8> ThreadFlows;\n  std::optional<SarifResultLevel> LevelOverride;\n\n  SarifResult() = delete;\n  explicit SarifResult(uint32_t RuleIdx) : RuleIdx(RuleIdx) {}\n\npublic:\n  static SarifResult create(uint32_t RuleIdx) { return SarifResult{RuleIdx}; }\n\n  SarifResult setIndex(uint32_t Idx) {\n    RuleIdx = Idx;\n    return *this;\n  }\n\n  SarifResult setRuleId(llvm::StringRef Id) {\n    RuleId = Id.str();\n    return *this;\n  }\n\n  SarifResult setDiagnosticMessage(llvm::StringRef Message) {\n    DiagnosticMessage = Message.str();\n    return *this;\n  }\n\n  SarifResult setLocations(llvm::ArrayRef<CharSourceRange> DiagLocs) {\n#ifndef NDEBUG\n    for (const auto &Loc : DiagLocs) {\n      assert(Loc.isCharRange() &&\n             \"SARIF Results require character granular source ranges!\");\n    }\n#endif\n    Locations.assign(DiagLocs.begin(), DiagLocs.end());\n    return *this;\n  }\n  SarifResult setThreadFlows(llvm::ArrayRef<ThreadFlow> ThreadFlowResults) {\n    ThreadFlows.assign(ThreadFlowResults.begin(), ThreadFlowResults.end());\n    return *this;\n  }\n\n  SarifResult setDiagnosticLevel(const SarifResultLevel &TheLevel) {\n    LevelOverride = TheLevel;\n    return *this;\n  }\n};\n\n/// This class handles creating a valid SARIF document given various input\n/// attributes. However, it requires an ordering among certain method calls:\n///\n/// 1. Because every SARIF document must contain at least 1 \\c run, callers\n///    must ensure that \\ref SarifDocumentWriter::createRun is called before\n///    any other methods.\n/// 2. If SarifDocumentWriter::endRun is called, callers MUST call\n///    SarifDocumentWriter::createRun, before invoking any of the result\n///    aggregation methods such as SarifDocumentWriter::appendResult etc.\nclass SarifDocumentWriter {\nprivate:\n  const llvm::StringRef SchemaURI{\n      \"https://docs.oasis-open.org/sarif/sarif/v2.1.0/cos02/schemas/\"\n      \"sarif-schema-2.1.0.json\"};\n  const llvm::StringRef SchemaVersion{\"2.1.0\"};\n\n  /// \\internal\n  /// Return a pointer to the current tool. Asserts that a run exists.\n  llvm::json::Object &getCurrentTool();\n\n  /// \\internal\n  /// Checks if there is a run associated with this document.\n  ///\n  /// \\return true on success\n  bool hasRun() const;\n\n  /// \\internal\n  /// Reset portions of the internal state so that the document is ready to\n  /// receive data for a new run.\n  void reset();\n\n  /// \\internal\n  /// Return a mutable reference to the current run, after asserting it exists.\n  ///\n  /// \\note It is undefined behavior to call this if a run does not exist in\n  /// the SARIF document.\n  llvm::json::Object &getCurrentRun();\n\n  /// Create a code flow object for the given threadflows.\n  /// See \\ref ThreadFlow.\n  ///\n  /// \\note It is undefined behavior to call this if a run does not exist in\n  /// the SARIF document.\n  llvm::json::Object\n  createCodeFlow(const llvm::ArrayRef<ThreadFlow> ThreadFlows);\n\n  /// Add the given threadflows to the ones this SARIF document knows about.\n  llvm::json::Array\n  createThreadFlows(const llvm::ArrayRef<ThreadFlow> ThreadFlows);\n\n  /// Add the given \\ref CharSourceRange to the SARIF document as a physical\n  /// location, with its corresponding artifact.\n  llvm::json::Object createPhysicalLocation(const CharSourceRange &R);\n\npublic:\n  SarifDocumentWriter() = delete;\n\n  /// Create a new empty SARIF document with the given source manager.\n  SarifDocumentWriter(const SourceManager &SourceMgr) : SourceMgr(SourceMgr) {}\n\n  /// Release resources held by this SARIF document.\n  ~SarifDocumentWriter() = default;\n\n  /// Create a new run with which any upcoming analysis will be associated.\n  /// Each run requires specifying the tool that is generating reporting items.\n  void createRun(const llvm::StringRef ShortToolName,\n                 const llvm::StringRef LongToolName,\n                 const llvm::StringRef ToolVersion = CLANG_VERSION_STRING);\n\n  /// If there is a current run, end it.\n  ///\n  /// This method collects various book-keeping required to clear and close\n  /// resources associated with the current run, but may also allocate some\n  /// for the next run.\n  ///\n  /// Calling \\ref endRun before associating a run through \\ref createRun leads\n  /// to undefined behaviour.\n  void endRun();\n\n  /// Associate the given rule with the current run.\n  ///\n  /// Returns an integer rule index for the created rule that is unique within\n  /// the current run, which can then be used to create a \\ref SarifResult\n  /// to add to the current run. Note that a rule must exist before being\n  /// referenced by a result.\n  ///\n  /// \\pre\n  /// There must be a run associated with the document, failing to do so will\n  /// cause undefined behaviour.\n  size_t createRule(const SarifRule &Rule);\n\n  /// Append a new result to the currently in-flight run.\n  ///\n  /// \\pre\n  /// There must be a run associated with the document, failing to do so will\n  /// cause undefined behaviour.\n  /// \\pre\n  /// \\c RuleIdx used to create the result must correspond to a rule known by\n  /// the SARIF document. It must be the value returned by a previous call\n  /// to \\ref createRule.\n  void appendResult(const SarifResult &SarifResult);\n\n  /// Return the SARIF document in its current state.\n  /// Calling this will trigger a copy of the internal state including all\n  /// reported diagnostics, resulting in an expensive call.\n  llvm::json::Object createDocument();\n\nprivate:\n  /// Source Manager to use for the current SARIF document.\n  const SourceManager &SourceMgr;\n\n  /// Flag to track the state of this document:\n  /// A closed document is one on which a new runs must be created.\n  /// This could be a document that is freshly created, or has recently\n  /// finished writing to a previous run.\n  bool Closed = true;\n\n  /// A sequence of SARIF runs.\n  /// Each run object describes a single run of an analysis tool and contains\n  /// the output of that run.\n  ///\n  /// Reference: <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317484\">run object</a>\n  llvm::json::Array Runs;\n\n  /// The list of rules associated with the most recent active run. These are\n  /// defined using the diagnostics passed to the SarifDocument. Each rule\n  /// need not be unique through the result set. E.g. there may be several\n  /// 'syntax' errors throughout code under analysis, each of which has its\n  /// own specific diagnostic message (and consequently, RuleId). Rules are\n  /// also known as \"reportingDescriptor\" objects in SARIF.\n  ///\n  /// Reference: <a href=\"https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317556\">rules property</a>\n  llvm::SmallVector<SarifRule, 32> CurrentRules;\n\n  /// The list of artifacts that have been encountered on the most recent active\n  /// run. An artifact is defined in SARIF as a sequence of bytes addressable\n  /// by a URI. A common example for clang's case would be files named by\n  /// filesystem paths.\n  llvm::StringMap<detail::SarifArtifact> CurrentArtifacts;\n};\n}",
  "id": "BLOCK-CPP-16810",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/Sarif.h",
  "source_line": 48,
  "validation_status": "validated"
}