{
  "code": "{\n\nclass Stmt;\nclass Decl;\nclass VarDecl;\nclass ASTContext;\nclass CompoundStmt;\n\n/// Identifies a list of statements.\n///\n/// Can either identify a single arbitrary Stmt object, a continuous sequence of\n/// child statements inside a CompoundStmt or no statements at all.\nclass StmtSequence {\n  /// If this object identifies a sequence of statements inside a CompoundStmt,\n  /// S points to this CompoundStmt. If this object only identifies a single\n  /// Stmt, then S is a pointer to this Stmt.\n  const Stmt *S;\n\n  /// The declaration that contains the statements.\n  const Decl *D;\n\n  /// If EndIndex is non-zero, then S is a CompoundStmt and this StmtSequence\n  /// instance is representing the CompoundStmt children inside the array\n  /// [StartIndex, EndIndex).\n  unsigned StartIndex;\n  unsigned EndIndex;\n\npublic:\n  /// Constructs a StmtSequence holding multiple statements.\n  ///\n  /// The resulting StmtSequence identifies a continuous sequence of statements\n  /// in the body of the given CompoundStmt. Which statements of the body should\n  /// be identified needs to be specified by providing a start and end index\n  /// that describe a non-empty sub-array in the body of the given CompoundStmt.\n  ///\n  /// \\param Stmt A CompoundStmt that contains all statements in its body.\n  /// \\param D The Decl containing this Stmt.\n  /// \\param StartIndex The inclusive start index in the children array of\n  ///                   \\p Stmt\n  /// \\param EndIndex The exclusive end index in the children array of \\p Stmt.\n  StmtSequence(const CompoundStmt *Stmt, const Decl *D, unsigned StartIndex,\n               unsigned EndIndex);\n\n  /// Constructs a StmtSequence holding a single statement.\n  ///\n  /// \\param Stmt An arbitrary Stmt.\n  /// \\param D The Decl containing this Stmt.\n  StmtSequence(const Stmt *Stmt, const Decl *D);\n\n  /// Constructs an empty StmtSequence.\n  StmtSequence();\n\n  typedef const Stmt *const *iterator;\n\n  /// Returns an iterator pointing to the first statement in this sequence.\n  iterator begin() const;\n\n  /// Returns an iterator pointing behind the last statement in this sequence.\n  iterator end() const;\n\n  /// Returns the first statement in this sequence.\n  ///\n  /// This method should only be called on a non-empty StmtSequence object.\n  const Stmt *front() const {\n    assert(!empty());\n    return begin()[0];\n  }\n\n  /// Returns the last statement in this sequence.\n  ///\n  /// This method should only be called on a non-empty StmtSequence object.\n  const Stmt *back() const {\n    assert(!empty());\n    return begin()[size() - 1];\n  }\n\n  /// Returns the number of statements this object holds.\n  unsigned size() const {\n    if (holdsSequence())\n      return EndIndex - StartIndex;\n    if (S == nullptr)\n      return 0;\n    return 1;\n  }\n\n  /// Returns true if and only if this StmtSequence contains no statements.\n  bool empty() const { return size() == 0; }\n\n  /// Returns the related ASTContext for the stored Stmts.\n  ASTContext &getASTContext() const;\n\n  /// Returns the declaration that contains the stored Stmts.\n  const Decl *getContainingDecl() const {\n    assert(D);\n    return D;\n  }\n\n  /// Returns true if this objects holds a list of statements.\n  bool holdsSequence() const { return EndIndex != 0; }\n\n  /// Returns the start sourcelocation of the first statement in this sequence.\n  ///\n  /// This method should only be called on a non-empty StmtSequence object.\n  SourceLocation getBeginLoc() const;\n\n  /// Returns the end sourcelocation of the last statement in this sequence.\n  ///\n  /// This method should only be called on a non-empty StmtSequence object.\n  SourceLocation getEndLoc() const;\n\n  /// Returns the source range of the whole sequence - from the beginning\n  /// of the first statement to the end of the last statement.\n  SourceRange getSourceRange() const;\n\n  bool operator==(const StmtSequence &Other) const {\n    return std::tie(S, StartIndex, EndIndex) ==\n           std::tie(Other.S, Other.StartIndex, Other.EndIndex);\n  }\n\n  bool operator!=(const StmtSequence &Other) const {\n    return std::tie(S, StartIndex, EndIndex) !=\n           std::tie(Other.S, Other.StartIndex, Other.EndIndex);\n  }\n\n  /// Returns true if and only if this sequence covers a source range that\n  /// contains the source range of the given sequence \\p Other.\n  ///\n  /// This method should only be called on a non-empty StmtSequence object\n  /// and passed a non-empty StmtSequence object.\n  bool contains(const StmtSequence &Other) const;\n};\n\n/// Searches for similar subtrees in the AST.\n///\n/// First, this class needs several declarations with statement bodies which\n/// can be passed via analyzeCodeBody. Afterwards all statements can be\n/// searched for clones by calling findClones with a given list of constraints\n/// that should specify the wanted properties of the clones.\n///\n/// The result of findClones can be further constrained with the constrainClones\n/// method.\n///\n/// This class only searches for clones in executable source code\n/// (e.g. function bodies). Other clones (e.g. cloned comments or declarations)\n/// are not supported.\nclass CloneDetector {\n\npublic:\n  /// A collection of StmtSequences that share an arbitrary property.\n  typedef llvm::SmallVector<StmtSequence, 8> CloneGroup;\n\n  /// Generates and stores search data for all statements in the body of\n  /// the given Decl.\n  void analyzeCodeBody(const Decl *D);\n\n  /// Constrains the given list of clone groups with the given constraint.\n  ///\n  /// The constraint is expected to have a method with the signature\n  ///     `void constrain(std::vector<CloneDetector::CloneGroup> &Sequences)`\n  /// as this is the interface that the CloneDetector uses for applying the\n  /// constraint. The constraint is supposed to directly modify the passed list\n  /// so that all clones in the list fulfill the specific property this\n  /// constraint ensures.\n  template <typename T>\n  static void constrainClones(std::vector<CloneGroup> &CloneGroups, T C) {\n    C.constrain(CloneGroups);\n  }\n\n  /// Constrains the given list of clone groups with the given list of\n  /// constraints.\n  ///\n  /// The constraints are applied in sequence in the order in which they are\n  /// passed to this function.\n  template <typename T1, typename... Ts>\n  static void constrainClones(std::vector<CloneGroup> &CloneGroups, T1 C,\n                              Ts... ConstraintList) {\n    constrainClones(CloneGroups, C);\n    constrainClones(CloneGroups, ConstraintList...);\n  }\n\n  /// Searches for clones in all previously passed statements.\n  /// \\param Result Output parameter to which all created clone groups are\n  ///               added.\n  /// \\param ConstraintList The constraints that should be applied to the\n  //         result.\n  template <typename... Ts>\n  void findClones(std::vector<CloneGroup> &Result, Ts... ConstraintList) {\n    // The initial assumption is that there is only one clone group and every\n    // statement is a clone of the others. This clone group will then be\n    // split up with the help of the constraints.\n    Result.push_back(Sequences);\n\n    constrainClones(Result, ConstraintList...);\n  }\n\nprivate:\n  CloneGroup Sequences;\n};\n\n/// This class is a utility class that contains utility functions for building\n/// custom constraints.\nclass CloneConstraint {\npublic:\n  /// Removes all groups by using a filter function.\n  /// \\param CloneGroups The list of CloneGroups that is supposed to be\n  ///                    filtered.\n  /// \\param Filter The filter function that should return true for all groups\n  ///               that should be removed from the list.\n  static void filterGroups(\n      std::vector<CloneDetector::CloneGroup> &CloneGroups,\n      llvm::function_ref<bool(const CloneDetector::CloneGroup &)> Filter) {\n    llvm::erase_if(CloneGroups, Filter);\n  }\n\n  /// Splits the given CloneGroups until the given Compare function returns true\n  /// for all clones in a single group.\n  /// \\param CloneGroups A list of CloneGroups that should be modified.\n  /// \\param Compare The comparison function that all clones are supposed to\n  ///                pass. Should return true if and only if two clones belong\n  ///                to the same CloneGroup.\n  static void splitCloneGroups(\n      std::vector<CloneDetector::CloneGroup> &CloneGroups,\n      llvm::function_ref<bool(const StmtSequence &, const StmtSequence &)>\n          Compare);\n};\n\n/// This constraint moves clones into clone groups of type II via hashing.\n///\n/// Clones with different hash values are moved into separate clone groups.\n/// Collisions are possible, and this constraint does nothing to address this\n/// them. Add the slower RecursiveCloneTypeIIVerifyConstraint later in the\n/// constraint chain, not necessarily immediately, to eliminate hash collisions\n/// through a more detailed analysis.\nclass RecursiveCloneTypeIIHashConstraint {\npublic:\n  void constrain(std::vector<CloneDetector::CloneGroup> &Sequences);\n};\n\n/// This constraint moves clones into clone groups of type II by comparing them.\n///\n/// Clones that aren't type II clones are moved into separate clone groups.\n/// In contrast to the RecursiveCloneTypeIIHashConstraint, all clones in a clone\n/// group are guaranteed to be type II clones of each other, but it is too\n/// slow to efficiently handle large amounts of clones.\nclass RecursiveCloneTypeIIVerifyConstraint {\npublic:\n  void constrain(std::vector<CloneDetector::CloneGroup> &Sequences);\n};\n\n/// Ensures that every clone has at least the given complexity.\n///\n/// Complexity is here defined as the total amount of children of a statement.\n/// This constraint assumes the first statement in the group is representative\n/// for all other statements in the group in terms of complexity.\nclass MinComplexityConstraint {\n  unsigned MinComplexity;\n\npublic:\n  MinComplexityConstraint(unsigned MinComplexity)\n      : MinComplexity(MinComplexity) {}\n\n  /// Calculates the complexity of the given StmtSequence.\n  /// \\param Limit The limit of complexity we probe for. After reaching\n  ///              this limit during calculation, this method is exiting\n  ///              early to improve performance and returns this limit.\n  size_t calculateStmtComplexity(const StmtSequence &Seq, std::size_t Limit,\n                                 const std::string &ParentMacroStack = \"\");\n\n  void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {\n    CloneConstraint::filterGroups(\n        CloneGroups, [this](const CloneDetector::CloneGroup &A) {\n          if (!A.empty())\n            return calculateStmtComplexity(A.front(), MinComplexity) <\n                   MinComplexity;\n          else\n            return false;\n        });\n  }\n};\n\n/// Ensures that all clone groups contain at least the given amount of clones.\nclass MinGroupSizeConstraint {\n  unsigned MinGroupSize;\n\npublic:\n  MinGroupSizeConstraint(unsigned MinGroupSize = 2)\n      : MinGroupSize(MinGroupSize) {}\n\n  void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {\n    CloneConstraint::filterGroups(CloneGroups,\n                                  [this](const CloneDetector::CloneGroup &A) {\n                                    return A.size() < MinGroupSize;\n                                  });\n  }\n};\n\n/// Ensures that no clone group fully contains another clone group.\nstruct OnlyLargestCloneConstraint {\n  void constrain(std::vector<CloneDetector::CloneGroup> &Result);\n};\n\nstruct FilenamePatternConstraint {\n  StringRef IgnoredFilesPattern;\n  std::shared_ptr<llvm::Regex> IgnoredFilesRegex;\n\n  FilenamePatternConstraint(StringRef IgnoredFilesPattern)\n      : IgnoredFilesPattern(IgnoredFilesPattern) {\n    IgnoredFilesRegex = std::make_shared<llvm::Regex>(\"^(\" +\n        IgnoredFilesPattern.str() + \"$)\");\n  }\n\n  bool isAutoGenerated(const CloneDetector::CloneGroup &Group);\n\n  void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {\n    CloneConstraint::filterGroups(\n        CloneGroups, [this](const CloneDetector::CloneGroup &Group) {\n          return isAutoGenerated(Group);\n        });\n  }\n};\n\n/// Analyzes the pattern of the referenced variables in a statement.\nclass VariablePattern {\n\n  /// Describes an occurrence of a variable reference in a statement.\n  struct VariableOccurence {\n    /// The index of the associated VarDecl in the Variables vector.\n    size_t KindID;\n    /// The statement in the code where the variable was referenced.\n    const Stmt *Mention;\n\n    VariableOccurence(size_t KindID, const Stmt *Mention)\n        : KindID(KindID), Mention(Mention) {}\n  };\n\n  /// All occurrences of referenced variables in the order of appearance.\n  std::vector<VariableOccurence> Occurences;\n  /// List of referenced variables in the order of appearance.\n  /// Every item in this list is unique.\n  std::vector<const VarDecl *> Variables;\n\n  /// Adds a new variable referenced to this pattern.\n  /// \\param VarDecl The declaration of the variable that is referenced.\n  /// \\param Mention The SourceRange where this variable is referenced.\n  void addVariableOccurence(const VarDecl *VarDecl, const Stmt *Mention);\n\n  /// Adds each referenced variable from the given statement.\n  void addVariables(const Stmt *S);\n\npublic:\n  /// Creates an VariablePattern object with information about the given\n  /// StmtSequence.\n  VariablePattern(const StmtSequence &Sequence) {\n    for (const Stmt *S : Sequence)\n      addVariables(S);\n  }\n\n  /// Describes two clones that reference their variables in a different pattern\n  /// which could indicate a programming error.\n  struct SuspiciousClonePair {\n    /// Utility class holding the relevant information about a single\n    /// clone in this pair.\n    struct SuspiciousCloneInfo {\n      /// The variable which referencing in this clone was against the pattern.\n      const VarDecl *Variable;\n      /// Where the variable was referenced.\n      const Stmt *Mention;\n      /// The variable that should have been referenced to follow the pattern.\n      /// If Suggestion is a nullptr then it's not possible to fix the pattern\n      /// by referencing a different variable in this clone.\n      const VarDecl *Suggestion;\n      SuspiciousCloneInfo(const VarDecl *Variable, const Stmt *Mention,\n                          const VarDecl *Suggestion)\n          : Variable(Variable), Mention(Mention), Suggestion(Suggestion) {}\n      SuspiciousCloneInfo() {}\n    };\n    /// The first clone in the pair which always has a suggested variable.\n    SuspiciousCloneInfo FirstCloneInfo;\n    /// This other clone in the pair which can have a suggested variable.\n    SuspiciousCloneInfo SecondCloneInfo;\n  };\n\n  /// Counts the differences between this pattern and the given one.\n  /// \\param Other The given VariablePattern to compare with.\n  /// \\param FirstMismatch Output parameter that will be filled with information\n  ///        about the first difference between the two patterns. This parameter\n  ///        can be a nullptr, in which case it will be ignored.\n  /// \\return Returns the number of differences between the pattern this object\n  ///         is following and the given VariablePattern.\n  ///\n  /// For example, the following statements all have the same pattern and this\n  /// function would return zero:\n  ///\n  ///   if (a < b) return a; return b;\n  ///   if (x < y) return x; return y;\n  ///   if (u2 < u1) return u2; return u1;\n  ///\n  /// But the following statement has a different pattern (note the changed\n  /// variables in the return statements) and would have two differences when\n  /// compared with one of the statements above.\n  ///\n  ///   if (a < b) return b; return a;\n  ///\n  /// This function should only be called if the related statements of the given\n  /// pattern and the statements of this objects are clones of each other.\n  unsigned countPatternDifferences(\n      const VariablePattern &Other,\n      VariablePattern::SuspiciousClonePair *FirstMismatch = nullptr);\n};\n\n/// Ensures that all clones reference variables in the same pattern.\nstruct MatchingVariablePatternConstraint {\n  void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups);\n};\n\n}",
  "id": "BLOCK-CPP-15643",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CloneDetection.h",
  "source_line": 21,
  "validation_status": "validated"
}