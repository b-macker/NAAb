{
  "code": "{\n  char* d = dest;\n  const char* p = source.data();\n  const char* end = p + source.size();\n  const char* last_byte = end - 1;\n\n  // Small optimization for case where source = dest and there's no escaping\n  while (p == d && p < end && *p != '\\\\') p++, d++;\n\n  while (p < end) {\n    if (*p != '\\\\') {\n      *d++ = *p++;\n    } else {\n      if (++p > last_byte) {  // skip past the '\\\\'\n        if (error) *error = \"String cannot end with \\\\\";\n        return false;\n      }\n      switch (*p) {\n        case 'a':  *d++ = '\\a';  break;\n        case 'b':  *d++ = '\\b';  break;\n        case 'f':  *d++ = '\\f';  break;\n        case 'n':  *d++ = '\\n';  break;\n        case 'r':  *d++ = '\\r';  break;\n        case 't':  *d++ = '\\t';  break;\n        case 'v':  *d++ = '\\v';  break;\n        case '\\\\': *d++ = '\\\\';  break;\n        case '?':  *d++ = '\\?';  break;    // \\?  Who knew?\n        case '\\'': *d++ = '\\'';  break;\n        case '\"':  *d++ = '\\\"';  break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7': {\n          // octal digit: 1 to 3 digits\n          const char* octal_start = p;\n          unsigned int ch = static_cast<unsigned int>(*p - '0');  // digit 1\n          if (p < last_byte && is_octal_digit(p[1]))\n            ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  // digit 2\n          if (p < last_byte && is_octal_digit(p[1]))\n            ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  // digit 3\n          if (ch > 0xff) {\n            if (error) {\n              *error = \"Value of \\\\\" +\n                       std::string(octal_start,\n                                   static_cast<size_t>(p + 1 - octal_start)) +\n                       \" exceeds 0xff\";\n            }\n            return false;\n          }\n          if ((ch == 0) && leave_nulls_escaped) {\n            // Copy the escape sequence for the null character\n            const size_t octal_size = static_cast<size_t>(p + 1 - octal_start);\n            *d++ = '\\\\';\n            memmove(d, octal_start, octal_size);\n            d += octal_size;\n            break;\n          }\n          *d++ = static_cast<char>(ch);\n          break;\n        }\n        case 'x':\n        case 'X': {\n          if (p >= last_byte) {\n            if (error) *error = \"String cannot end with \\\\x\";\n            return false;\n          } else if (!absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {\n            if (error) *error = \"\\\\x cannot be followed by a non-hex digit\";\n            return false;\n          }\n          unsigned int ch = 0;\n          const char* hex_start = p;\n          while (p < last_byte &&\n                 absl::ascii_isxdigit(static_cast<unsigned char>(p[1])))\n            // Arbitrarily many hex digits\n            ch = (ch << 4) + hex_digit_to_int(*++p);\n          if (ch > 0xFF) {\n            if (error) {\n              *error = \"Value of \\\\\" +\n                       std::string(hex_start,\n                                   static_cast<size_t>(p + 1 - hex_start)) +\n                       \" exceeds 0xff\";\n            }\n            return false;\n          }\n          if ((ch == 0) && leave_nulls_escaped) {\n            // Copy the escape sequence for the null character\n            const size_t hex_size = static_cast<size_t>(p + 1 - hex_start);\n            *d++ = '\\\\';\n            memmove(d, hex_start, hex_size);\n            d += hex_size;\n            break;\n          }\n          *d++ = static_cast<char>(ch);\n          break;\n        }\n        case 'u': {\n          // \\uhhhh => convert 4 hex digits to UTF-8\n          char32_t rune = 0;\n          const char* hex_start = p;\n          if (p + 4 >= end) {\n            if (error) {\n              *error = \"\\\\u must be followed by 4 hex digits: \\\\\" +\n                       std::string(hex_start,\n                                   static_cast<size_t>(p + 1 - hex_start));\n            }\n            return false;\n          }\n          for (int i = 0; i < 4; ++i) {\n            // Look one char ahead.\n            if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {\n              rune = (rune << 4) + hex_digit_to_int(*++p);  // Advance p.\n            } else {\n              if (error) {\n                *error = \"\\\\u must be followed by 4 hex digits: \\\\\" +\n                         std::string(hex_start,\n                                     static_cast<size_t>(p + 1 - hex_start));\n              }\n              return false;\n            }\n          }\n          if ((rune == 0) && leave_nulls_escaped) {\n            // Copy the escape sequence for the null character\n            *d++ = '\\\\';\n            memmove(d, hex_start, 5);  // u0000\n            d += 5;\n            break;\n          }\n          if (IsSurrogate(rune, absl::string_view(hex_start, 5), error)) {\n            return false;\n          }\n          d += strings_internal::EncodeUTF8Char(d, rune);\n          break;\n        }\n        case 'U': {\n          // \\Uhhhhhhhh => convert 8 hex digits to UTF-8\n          char32_t rune = 0;\n          const char* hex_start = p;\n          if (p + 8 >= end) {\n            if (error) {\n              *error = \"\\\\U must be followed by 8 hex digits: \\\\\" +\n                       std::string(hex_start,\n                                   static_cast<size_t>(p + 1 - hex_start));\n            }\n            return false;\n          }\n          for (int i = 0; i < 8; ++i) {\n            // Look one char ahead.\n            if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {\n              // Don't change rune until we're sure this\n              // is within the Unicode limit, but do advance p.\n              uint32_t newrune = (rune << 4) + hex_digit_to_int(*++p);\n              if (newrune > 0x10FFFF) {\n                if (error) {\n                  *error = \"Value of \\\\\" +\n                           std::string(hex_start,\n                                       static_cast<size_t>(p + 1 - hex_start)) +\n                           \" exceeds Unicode limit (0x10FFFF)\";\n                }\n                return false;\n              } else {\n                rune = newrune;\n              }\n            } else {\n              if (error) {\n                *error = \"\\\\U must be followed by 8 hex digits: \\\\\" +\n                         std::string(hex_start,\n                                     static_cast<size_t>(p + 1 - hex_start));\n              }\n              return false;\n            }\n          }\n          if ((rune == 0) && leave_nulls_escaped) {\n            // Copy the escape sequence for the null character\n            *d++ = '\\\\';\n            memmove(d, hex_start, 9);  // U00000000\n            d += 9;\n            break;\n          }\n          if (IsSurrogate(rune, absl::string_view(hex_start, 9), error)) {\n            return false;\n          }\n          d += strings_internal::EncodeUTF8Char(d, rune);\n          break;\n        }\n        default: {\n          if (error) *error = std::string(\"Unknown escape sequence: \\\\\") + *p;\n          return false;\n        }\n      }\n      p++;                                 // read past letter we escaped\n    }\n  }\n  *dest_len = d - dest;\n  return true;\n}",
  "id": "BLOCK-CPP-01914",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/escaping.cc",
  "source_line": 85,
  "validation_status": "validated"
}