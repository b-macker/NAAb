{
  "code": "{\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class ASTRecordWriter;\n  friend class ASTWriter;\n  friend class DeclContext;\n  friend class LambdaExpr;\n  friend class ODRDiagsEmitter;\n\n  friend void FunctionDecl::setPure(bool);\n  friend void TagDecl::startDefinition();\n\n  /// Values used in DefinitionData fields to represent special members.\n  enum SpecialMemberFlags {\n    SMF_DefaultConstructor = 0x1,\n    SMF_CopyConstructor = 0x2,\n    SMF_MoveConstructor = 0x4,\n    SMF_CopyAssignment = 0x8,\n    SMF_MoveAssignment = 0x10,\n    SMF_Destructor = 0x20,\n    SMF_All = 0x3f\n  };\n\npublic:\n  enum LambdaDependencyKind {\n    LDK_Unknown = 0,\n    LDK_AlwaysDependent,\n    LDK_NeverDependent,\n  };\n\nprivate:\n  struct DefinitionData {\n    #define FIELD(Name, Width, Merge) \\\n    unsigned Name : Width;\n    #include \"CXXRecordDeclDefinitionBits.def\"\n\n    /// Whether this class describes a C++ lambda.\n    unsigned IsLambda : 1;\n\n    /// Whether we are currently parsing base specifiers.\n    unsigned IsParsingBaseSpecifiers : 1;\n\n    /// True when visible conversion functions are already computed\n    /// and are available.\n    unsigned ComputedVisibleConversions : 1;\n\n    unsigned HasODRHash : 1;\n\n    /// A hash of parts of the class to help in ODR checking.\n    unsigned ODRHash = 0;\n\n    /// The number of base class specifiers in Bases.\n    unsigned NumBases = 0;\n\n    /// The number of virtual base class specifiers in VBases.\n    unsigned NumVBases = 0;\n\n    /// Base classes of this class.\n    ///\n    /// FIXME: This is wasted space for a union.\n    LazyCXXBaseSpecifiersPtr Bases;\n\n    /// direct and indirect virtual base classes of this class.\n    LazyCXXBaseSpecifiersPtr VBases;\n\n    /// The conversion functions of this C++ class (but not its\n    /// inherited conversion functions).\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl.\n    LazyASTUnresolvedSet Conversions;\n\n    /// The conversion functions of this C++ class and all those\n    /// inherited conversion functions that are visible in this class.\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl or a\n    /// FunctionTemplateDecl.\n    LazyASTUnresolvedSet VisibleConversions;\n\n    /// The declaration which defines this record.\n    CXXRecordDecl *Definition;\n\n    /// The first friend declaration in this class, or null if there\n    /// aren't any.\n    ///\n    /// This is actually currently stored in reverse order.\n    LazyDeclPtr FirstFriend;\n\n    DefinitionData(CXXRecordDecl *D);\n\n    /// Retrieve the set of direct base classes.\n    CXXBaseSpecifier *getBases() const {\n      if (!Bases.isOffset())\n        return Bases.get(nullptr);\n      return getBasesSlowCase();\n    }\n\n    /// Retrieve the set of virtual base classes.\n    CXXBaseSpecifier *getVBases() const {\n      if (!VBases.isOffset())\n        return VBases.get(nullptr);\n      return getVBasesSlowCase();\n    }\n\n    ArrayRef<CXXBaseSpecifier> bases() const {\n      return llvm::ArrayRef(getBases(), NumBases);\n    }\n\n    ArrayRef<CXXBaseSpecifier> vbases() const {\n      return llvm::ArrayRef(getVBases(), NumVBases);\n    }\n\n  private:\n    CXXBaseSpecifier *getBasesSlowCase() const;\n    CXXBaseSpecifier *getVBasesSlowCase() const;\n  };\n\n  struct DefinitionData *DefinitionData;\n\n  /// Describes a C++ closure type (generated by a lambda expression).\n  struct LambdaDefinitionData : public DefinitionData {\n    using Capture = LambdaCapture;\n\n    /// Whether this lambda is known to be dependent, even if its\n    /// context isn't dependent.\n    ///\n    /// A lambda with a non-dependent context can be dependent if it occurs\n    /// within the default argument of a function template, because the\n    /// lambda will have been created with the enclosing context as its\n    /// declaration context, rather than function. This is an unfortunate\n    /// artifact of having to parse the default arguments before.\n    unsigned DependencyKind : 2;\n\n    /// Whether this lambda is a generic lambda.\n    unsigned IsGenericLambda : 1;\n\n    /// The Default Capture.\n    unsigned CaptureDefault : 2;\n\n    /// The number of captures in this lambda is limited 2^NumCaptures.\n    unsigned NumCaptures : 15;\n\n    /// The number of explicit captures in this lambda.\n    unsigned NumExplicitCaptures : 12;\n\n    /// Has known `internal` linkage.\n    unsigned HasKnownInternalLinkage : 1;\n\n    /// The number used to indicate this lambda expression for name\n    /// mangling in the Itanium C++ ABI.\n    unsigned ManglingNumber : 31;\n\n    /// The index of this lambda within its context declaration. This is not in\n    /// general the same as the mangling number.\n    unsigned IndexInContext;\n\n    /// The declaration that provides context for this lambda, if the\n    /// actual DeclContext does not suffice. This is used for lambdas that\n    /// occur within default arguments of function parameters within the class\n    /// or within a data member initializer.\n    LazyDeclPtr ContextDecl;\n\n    /// The lists of captures, both explicit and implicit, for this\n    /// lambda. One list is provided for each merged copy of the lambda.\n    /// The first list corresponds to the canonical definition.\n    /// The destructor is registered by AddCaptureList when necessary.\n    llvm::TinyPtrVector<Capture*> Captures;\n\n    /// The type of the call method.\n    TypeSourceInfo *MethodTyInfo;\n\n    LambdaDefinitionData(CXXRecordDecl *D, TypeSourceInfo *Info, unsigned DK,\n                         bool IsGeneric, LambdaCaptureDefault CaptureDefault)\n        : DefinitionData(D), DependencyKind(DK), IsGenericLambda(IsGeneric),\n          CaptureDefault(CaptureDefault), NumCaptures(0),\n          NumExplicitCaptures(0), HasKnownInternalLinkage(0), ManglingNumber(0),\n          IndexInContext(0), MethodTyInfo(Info) {\n      IsLambda = true;\n\n      // C++1z [expr.prim.lambda]p4:\n      //   This class type is not an aggregate type.\n      Aggregate = false;\n      PlainOldData = false;\n    }\n\n    // Add a list of captures.\n    void AddCaptureList(ASTContext &Ctx, Capture *CaptureList);\n  };\n\n  struct DefinitionData *dataPtr() const {\n    // Complete the redecl chain (if necessary).\n    getMostRecentDecl();\n    return DefinitionData;\n  }\n\n  struct DefinitionData &data() const {\n    auto *DD = dataPtr();\n    assert(DD && \"queried property of class with no definition\");\n    return *DD;\n  }\n\n  struct LambdaDefinitionData &getLambdaData() const {\n    // No update required: a merged definition cannot change any lambda\n    // properties.\n    auto *DD = DefinitionData;\n    assert(DD && DD->IsLambda && \"queried lambda property of non-lambda class\");\n    return static_cast<LambdaDefinitionData&>(*DD);\n  }\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be null. For record\n  /// declarations that describe a class template, this will be a\n  /// pointer to a ClassTemplateDecl. For member\n  /// classes of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member class that was\n  /// instantiated or specialized.\n  llvm::PointerUnion<ClassTemplateDecl *, MemberSpecializationInfo *>\n      TemplateOrInstantiation;\n\n  /// Called from setBases and addedMember to notify the class that a\n  /// direct or virtual base class or a member of class type has been added.\n  void addedClassSubobject(CXXRecordDecl *Base);\n\n  /// Notify the class that member has been added.\n  ///\n  /// This routine helps maintain information about the class based on which\n  /// members have been added. It will be invoked by DeclContext::addDecl()\n  /// whenever a member is added to this record.\n  void addedMember(Decl *D);\n\n  void markedVirtualFunctionPure();\n\n  /// Get the head of our list of friend declarations, possibly\n  /// deserializing the friends from an external AST source.\n  FriendDecl *getFirstFriend() const;\n\n  /// Determine whether this class has an empty base class subobject of type X\n  /// or of one of the types that might be at offset 0 within X (per the C++\n  /// \"standard layout\" rules).\n  bool hasSubobjectAtOffsetZeroOfEmptyBaseType(ASTContext &Ctx,\n                                               const CXXRecordDecl *X);\n\nprotected:\n  CXXRecordDecl(Kind K, TagKind TK, const ASTContext &C, DeclContext *DC,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, CXXRecordDecl *PrevDecl);\n\npublic:\n  /// Iterator that traverses the base classes of a class.\n  using base_class_iterator = CXXBaseSpecifier *;\n\n  /// Iterator that traverses the base classes of a class.\n  using base_class_const_iterator = const CXXBaseSpecifier *;\n\n  CXXRecordDecl *getCanonicalDecl() override {\n    return cast<CXXRecordDecl>(RecordDecl::getCanonicalDecl());\n  }\n\n  const CXXRecordDecl *getCanonicalDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXRecordDecl *getPreviousDecl() {\n    return cast_or_null<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getPreviousDecl());\n  }\n\n  const CXXRecordDecl *getPreviousDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getPreviousDecl();\n  }\n\n  CXXRecordDecl *getMostRecentDecl() {\n    return cast<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getMostRecentDecl());\n  }\n\n  const CXXRecordDecl *getMostRecentDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  CXXRecordDecl *getMostRecentNonInjectedDecl() {\n    CXXRecordDecl *Recent =\n        static_cast<CXXRecordDecl *>(this)->getMostRecentDecl();\n    while (Recent->isInjectedClassName()) {\n      // FIXME: Does injected class name need to be in the redeclarations chain?\n      assert(Recent->getPreviousDecl());\n      Recent = Recent->getPreviousDecl();\n    }\n    return Recent;\n  }\n\n  const CXXRecordDecl *getMostRecentNonInjectedDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentNonInjectedDecl();\n  }\n\n  CXXRecordDecl *getDefinition() const {\n    // We only need an update if we don't already know which\n    // declaration is the definition.\n    auto *DD = DefinitionData ? DefinitionData : dataPtr();\n    return DD ? DD->Definition : nullptr;\n  }\n\n  bool hasDefinition() const { return DefinitionData || dataPtr(); }\n\n  static CXXRecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id,\n                               CXXRecordDecl *PrevDecl = nullptr,\n                               bool DelayTypeCreation = false);\n  static CXXRecordDecl *CreateLambda(const ASTContext &C, DeclContext *DC,\n                                     TypeSourceInfo *Info, SourceLocation Loc,\n                                     unsigned DependencyKind, bool IsGeneric,\n                                     LambdaCaptureDefault CaptureDefault);\n  static CXXRecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  bool isDynamicClass() const {\n    return data().Polymorphic || data().NumVBases != 0;\n  }\n\n  /// @returns true if class is dynamic or might be dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeDynamicClass() const {\n    return !hasDefinition() || isDynamicClass() || hasAnyDependentBases();\n  }\n\n  /// @returns true if class is non dynamic or might be non dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeNonDynamicClass() const {\n    return !hasDefinition() || !isDynamicClass() || hasAnyDependentBases();\n  }\n\n  void setIsParsingBaseSpecifiers() { data().IsParsingBaseSpecifiers = true; }\n\n  bool isParsingBaseSpecifiers() const {\n    return data().IsParsingBaseSpecifiers;\n  }\n\n  unsigned getODRHash() const;\n\n  /// Sets the base classes of this struct or class.\n  void setBases(CXXBaseSpecifier const * const *Bases, unsigned NumBases);\n\n  /// Retrieves the number of base classes of this class.\n  unsigned getNumBases() const { return data().NumBases; }\n\n  using base_class_range = llvm::iterator_range<base_class_iterator>;\n  using base_class_const_range =\n      llvm::iterator_range<base_class_const_iterator>;\n\n  base_class_range bases() {\n    return base_class_range(bases_begin(), bases_end());\n  }\n  base_class_const_range bases() const {\n    return base_class_const_range(bases_begin(), bases_end());\n  }\n\n  base_class_iterator bases_begin() { return data().getBases(); }\n  base_class_const_iterator bases_begin() const { return data().getBases(); }\n  base_class_iterator bases_end() { return bases_begin() + data().NumBases; }\n  base_class_const_iterator bases_end() const {\n    return bases_begin() + data().NumBases;\n  }\n\n  /// Retrieves the number of virtual base classes of this class.\n  unsigned getNumVBases() const { return data().NumVBases; }\n\n  base_class_range vbases() {\n    return base_class_range(vbases_begin(), vbases_end());\n  }\n  base_class_const_range vbases() const {\n    return base_class_const_range(vbases_begin(), vbases_end());\n  }\n\n  base_class_iterator vbases_begin() { return data().getVBases(); }\n  base_class_const_iterator vbases_begin() const { return data().getVBases(); }\n  base_class_iterator vbases_end() { return vbases_begin() + data().NumVBases; }\n  base_class_const_iterator vbases_end() const {\n    return vbases_begin() + data().NumVBases;\n  }\n\n  /// Determine whether this class has any dependent base classes which\n  /// are not the current instantiation.\n  bool hasAnyDependentBases() const;\n\n  /// Iterator access to method members.  The method iterator visits\n  /// all method members of the class, including non-instance methods,\n  /// special methods, etc.\n  using method_iterator = specific_decl_iterator<CXXMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<CXXMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(method_begin(), method_end());\n  }\n\n  /// Method begin iterator.  Iterates in the order the methods\n  /// were declared.\n  method_iterator method_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  /// Method past-the-end iterator.\n  method_iterator method_end() const {\n    return method_iterator(decls_end());\n  }\n\n  /// Iterator access to constructor members.\n  using ctor_iterator = specific_decl_iterator<CXXConstructorDecl>;\n  using ctor_range =\n      llvm::iterator_range<specific_decl_iterator<CXXConstructorDecl>>;\n\n  ctor_range ctors() const { return ctor_range(ctor_begin(), ctor_end()); }\n\n  ctor_iterator ctor_begin() const {\n    return ctor_iterator(decls_begin());\n  }\n\n  ctor_iterator ctor_end() const {\n    return ctor_iterator(decls_end());\n  }\n\n  /// An iterator over friend declarations.  All of these are defined\n  /// in DeclFriend.h.\n  class friend_iterator;\n  using friend_range = llvm::iterator_range<friend_iterator>;\n\n  friend_range friends() const;\n  friend_iterator friend_begin() const;\n  friend_iterator friend_end() const;\n  void pushFriendDecl(FriendDecl *FD);\n\n  /// Determines whether this record has any friends.\n  bool hasFriends() const {\n    return data().FirstFriend.isValid();\n  }\n\n  /// \\c true if a defaulted copy constructor for this class would be\n  /// deleted.\n  bool defaultedCopyConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForCopyConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_CopyConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted move constructor for this class would be\n  /// deleted.\n  bool defaultedMoveConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForMoveConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_MoveConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted destructor for this class would be deleted.\n  bool defaultedDestructorIsDeleted() const {\n    assert((!needsOverloadResolutionForDestructor() ||\n            (data().DeclaredSpecialMembers & SMF_Destructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedDestructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy constructor that is not deleted.\n  bool hasSimpleCopyConstructor() const {\n    return !hasUserDeclaredCopyConstructor() &&\n           !data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move constructor that is not deleted.\n  bool hasSimpleMoveConstructor() const {\n    return !hasUserDeclaredMoveConstructor() && hasMoveConstructor() &&\n           !data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy assignment operator that is not deleted.\n  bool hasSimpleCopyAssignment() const {\n    return !hasUserDeclaredCopyAssignment() &&\n           !data().DefaultedCopyAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move assignment operator that is not deleted.\n  bool hasSimpleMoveAssignment() const {\n    return !hasUserDeclaredMoveAssignment() && hasMoveAssignment() &&\n           !data().DefaultedMoveAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has an accessible\n  /// destructor that is not deleted.\n  bool hasSimpleDestructor() const {\n    return !hasUserDeclaredDestructor() &&\n           !data().DefaultedDestructorIsDeleted;\n  }\n\n  /// Determine whether this class has any default constructors.\n  bool hasDefaultConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_DefaultConstructor) ||\n           needsImplicitDefaultConstructor();\n  }\n\n  /// Determine if we need to declare a default constructor for\n  /// this class.\n  ///\n  /// This value is used for lazy creation of default constructors.\n  bool needsImplicitDefaultConstructor() const {\n    return (!data().UserDeclaredConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor) &&\n            (!isLambda() || lambdaIsDefaultConstructibleAndAssignable())) ||\n           // FIXME: Proposed fix to core wording issue: if a class inherits\n           // a default constructor and doesn't explicitly declare one, one\n           // is declared implicitly.\n           (data().HasInheritedDefaultConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has any user-declared constructors.\n  ///\n  /// When true, a default constructor will not be implicitly declared.\n  bool hasUserDeclaredConstructor() const {\n    return data().UserDeclaredConstructor;\n  }\n\n  /// Whether this class has a user-provided default constructor\n  /// per C++11.\n  bool hasUserProvidedDefaultConstructor() const {\n    return data().UserProvidedDefaultConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy constructor.\n  ///\n  /// When false, a copy constructor will be implicitly declared.\n  bool hasUserDeclaredCopyConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// constructor to be lazily declared.\n  bool needsImplicitCopyConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyConstructor);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// constructor for this class.\n  bool needsOverloadResolutionForCopyConstructor() const {\n    // C++17 [class.copy.ctor]p6:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy constructor is defined as\n    //   deleted.\n    // In MSVC mode, sometimes a declared move assignment does not delete an\n    // implicit copy constructor, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyConstructor;\n  }\n\n  /// Determine whether an implicit copy constructor for this type\n  /// would have a parameter with a const-qualified reference type.\n  bool implicitCopyConstructorHasConstParam() const {\n    return data().ImplicitCopyConstructorCanHaveConstParamForNonVBase &&\n           (isAbstract() ||\n            data().ImplicitCopyConstructorCanHaveConstParamForVBase);\n  }\n\n  /// Determine whether this class has a copy constructor with\n  /// a parameter type which is a reference to a const-qualified type.\n  bool hasCopyConstructorWithConstParam() const {\n    return data().HasDeclaredCopyConstructorWithConstParam ||\n           (needsImplicitCopyConstructor() &&\n            implicitCopyConstructorHasConstParam());\n  }\n\n  /// Whether this class has a user-declared move constructor or\n  /// assignment operator.\n  ///\n  /// When false, a move constructor and assignment operator may be\n  /// implicitly declared.\n  bool hasUserDeclaredMoveOperation() const {\n    return data().UserDeclaredSpecialMembers &\n             (SMF_MoveConstructor | SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has had a move constructor\n  /// declared by the user.\n  bool hasUserDeclaredMoveConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveConstructor;\n  }\n\n  /// Determine whether this class has a move constructor.\n  bool hasMoveConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveConstructor) ||\n           needsImplicitMoveConstructor();\n  }\n\n  /// Set that we attempted to declare an implicit copy\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitCopyConstructorIsDeleted() {\n    assert((data().DefaultedCopyConstructorIsDeleted ||\n            needsOverloadResolutionForCopyConstructor()) &&\n           \"Copy constructor should not be deleted\");\n    data().DefaultedCopyConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit move\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitMoveConstructorIsDeleted() {\n    assert((data().DefaultedMoveConstructorIsDeleted ||\n            needsOverloadResolutionForMoveConstructor()) &&\n           \"move constructor should not be deleted\");\n    data().DefaultedMoveConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit destructor,\n  /// but overload resolution failed so we deleted it.\n  void setImplicitDestructorIsDeleted() {\n    assert((data().DefaultedDestructorIsDeleted ||\n            needsOverloadResolutionForDestructor()) &&\n           \"destructor should not be deleted\");\n    data().DefaultedDestructorIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// constructor or if any existing special member function inhibits this.\n  bool needsImplicitMoveConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveConstructor) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveAssignment() &&\n           !hasUserDeclaredDestructor();\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted move\n  /// constructor for this class.\n  bool needsOverloadResolutionForMoveConstructor() const {\n    return data().NeedOverloadResolutionForMoveConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy assignment\n  /// operator.\n  ///\n  /// When false, a copy assignment operator will be implicitly declared.\n  bool hasUserDeclaredCopyAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Set that we attempted to declare an implicit copy assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitCopyAssignmentIsDeleted() {\n    assert((data().DefaultedCopyAssignmentIsDeleted ||\n            needsOverloadResolutionForCopyAssignment()) &&\n           \"copy assignment should not be deleted\");\n    data().DefaultedCopyAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// assignment operator to be lazily declared.\n  bool needsImplicitCopyAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyAssignment);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// assignment operator for this class.\n  bool needsOverloadResolutionForCopyAssignment() const {\n    // C++20 [class.copy.assign]p2:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy assignment operator is defined\n    //   as deleted.\n    // In MSVC mode, sometimes a declared move constructor does not delete an\n    // implicit copy assignment, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyAssignment;\n  }\n\n  /// Determine whether an implicit copy assignment operator for this\n  /// type would have a parameter with a const-qualified reference type.\n  bool implicitCopyAssignmentHasConstParam() const {\n    return data().ImplicitCopyAssignmentHasConstParam;\n  }\n\n  /// Determine whether this class has a copy assignment operator with\n  /// a parameter type which is a reference to a const-qualified type or is not\n  /// a reference.\n  bool hasCopyAssignmentWithConstParam() const {\n    return data().HasDeclaredCopyAssignmentWithConstParam ||\n           (needsImplicitCopyAssignment() &&\n            implicitCopyAssignmentHasConstParam());\n  }\n\n  /// Determine whether this class has had a move assignment\n  /// declared by the user.\n  bool hasUserDeclaredMoveAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveAssignment;\n  }\n\n  /// Determine whether this class has a move assignment operator.\n  bool hasMoveAssignment() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveAssignment) ||\n           needsImplicitMoveAssignment();\n  }\n\n  /// Set that we attempted to declare an implicit move assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitMoveAssignmentIsDeleted() {\n    assert((data().DefaultedMoveAssignmentIsDeleted ||\n            needsOverloadResolutionForMoveAssignment()) &&\n           \"move assignment should not be deleted\");\n    data().DefaultedMoveAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// assignment operator or if any existing special member function inhibits\n  /// this.\n  bool needsImplicitMoveAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveAssignment) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveConstructor() &&\n           !hasUserDeclaredDestructor() &&\n           (!isLambda() || lambdaIsDefaultConstructibleAndAssignable());\n  }\n\n  /// Determine whether we need to eagerly declare a move assignment\n  /// operator for this class.\n  bool needsOverloadResolutionForMoveAssignment() const {\n    return data().NeedOverloadResolutionForMoveAssignment;\n  }\n\n  /// Determine whether this class has a user-declared destructor.\n  ///\n  /// When false, a destructor will be implicitly declared.\n  bool hasUserDeclaredDestructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_Destructor;\n  }\n\n  /// Determine whether this class needs an implicit destructor to\n  /// be lazily declared.\n  bool needsImplicitDestructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_Destructor);\n  }\n\n  /// Determine whether we need to eagerly declare a destructor for this\n  /// class.\n  bool needsOverloadResolutionForDestructor() const {\n    return data().NeedOverloadResolutionForDestructor;\n  }\n\n  /// Determine whether this class describes a lambda function object.\n  bool isLambda() const {\n    // An update record can't turn a non-lambda into a lambda.\n    auto *DD = DefinitionData;\n    return DD && DD->IsLambda;\n  }\n\n  /// Determine whether this class describes a generic\n  /// lambda function object (i.e. function call operator is\n  /// a template).\n  bool isGenericLambda() const;\n\n  /// Determine whether this lambda should have an implicit default constructor\n  /// and copy and move assignment operators.\n  bool lambdaIsDefaultConstructibleAndAssignable() const;\n\n  /// Retrieve the lambda call operator of the closure type\n  /// if this is a closure type.\n  CXXMethodDecl *getLambdaCallOperator() const;\n\n  /// Retrieve the dependent lambda call operator of the closure type\n  /// if this is a templated closure type.\n  FunctionTemplateDecl *getDependentLambdaCallOperator() const;\n\n  /// Retrieve the lambda static invoker, the address of which\n  /// is returned by the conversion operator, and the body of which\n  /// is forwarded to the lambda call operator. The version that does not\n  /// take a calling convention uses the 'default' calling convention for free\n  /// functions if the Lambda's calling convention was not modified via\n  /// attribute. Otherwise, it will return the calling convention specified for\n  /// the lambda.\n  CXXMethodDecl *getLambdaStaticInvoker() const;\n  CXXMethodDecl *getLambdaStaticInvoker(CallingConv CC) const;\n\n  /// Retrieve the generic lambda's template parameter list.\n  /// Returns null if the class does not represent a lambda or a generic\n  /// lambda.\n  TemplateParameterList *getGenericLambdaTemplateParameterList() const;\n\n  /// Retrieve the lambda template parameters that were specified explicitly.\n  ArrayRef<NamedDecl *> getLambdaExplicitTemplateParameters() const;\n\n  LambdaCaptureDefault getLambdaCaptureDefault() const {\n    assert(isLambda());\n    return static_cast<LambdaCaptureDefault>(getLambdaData().CaptureDefault);\n  }\n\n  /// Set the captures for this lambda closure type.\n  void setCaptures(ASTContext &Context, ArrayRef<LambdaCapture> Captures);\n\n  /// For a closure type, retrieve the mapping from captured\n  /// variables and \\c this to the non-static data members that store the\n  /// values or references of the captures.\n  ///\n  /// \\param Captures Will be populated with the mapping from captured\n  /// variables to the corresponding fields.\n  ///\n  /// \\param ThisCapture Will be set to the field declaration for the\n  /// \\c this capture.\n  ///\n  /// \\note No entries will be added for init-captures, as they do not capture\n  /// variables.\n  ///\n  /// \\note If multiple versions of the lambda are merged together, they may\n  /// have different variable declarations corresponding to the same capture.\n  /// In that case, all of those variable declarations will be added to the\n  /// Captures list, so it may have more than one variable listed per field.\n  void\n  getCaptureFields(llvm::DenseMap<const ValueDecl *, FieldDecl *> &Captures,\n                   FieldDecl *&ThisCapture) const;\n\n  using capture_const_iterator = const LambdaCapture *;\n  using capture_const_range = llvm::iterator_range<capture_const_iterator>;\n\n  capture_const_range captures() const {\n    return capture_const_range(captures_begin(), captures_end());\n  }\n\n  capture_const_iterator captures_begin() const {\n    if (!isLambda()) return nullptr;\n    LambdaDefinitionData &LambdaData = getLambdaData();\n    return LambdaData.Captures.empty() ? nullptr : LambdaData.Captures.front();\n  }\n\n  capture_const_iterator captures_end() const {\n    return isLambda() ? captures_begin() + getLambdaData().NumCaptures\n                      : nullptr;\n  }\n\n  unsigned capture_size() const { return getLambdaData().NumCaptures; }\n\n  const LambdaCapture *getCapture(unsigned I) const {\n    assert(isLambda() && I < capture_size() && \"invalid index for capture\");\n    return captures_begin() + I;\n  }\n\n  using conversion_iterator = UnresolvedSetIterator;\n\n  conversion_iterator conversion_begin() const {\n    return data().Conversions.get(getASTContext()).begin();\n  }\n\n  conversion_iterator conversion_end() const {\n    return data().Conversions.get(getASTContext()).end();\n  }\n\n  /// Removes a conversion function from this class.  The conversion\n  /// function must currently be a member of this class.  Furthermore,\n  /// this class must currently be in the process of being defined.\n  void removeConversion(const NamedDecl *Old);\n\n  /// Get all conversion functions visible in current class,\n  /// including conversion function templates.\n  llvm::iterator_range<conversion_iterator>\n  getVisibleConversionFunctions() const;\n\n  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),\n  /// which is a class with no user-declared constructors, no private\n  /// or protected non-static data members, no base classes, and no virtual\n  /// functions (C++ [dcl.init.aggr]p1).\n  bool isAggregate() const { return data().Aggregate; }\n\n  /// Whether this class has any in-class initializers\n  /// for non-static data members (including those in anonymous unions or\n  /// structs).\n  bool hasInClassInitializer() const { return data().HasInClassInitializer; }\n\n  /// Whether this class or any of its subobjects has any members of\n  /// reference type which would make value-initialization ill-formed.\n  ///\n  /// Per C++03 [dcl.init]p5:\n  ///  - if T is a non-union class type without a user-declared constructor,\n  ///    then every non-static data member and base-class component of T is\n  ///    value-initialized [...] A program that calls for [...]\n  ///    value-initialization of an entity of reference type is ill-formed.\n  bool hasUninitializedReferenceMember() const {\n    return !isUnion() && !hasUserDeclaredConstructor() &&\n           data().HasUninitializedReferenceMember;\n  }\n\n  /// Whether this class is a POD-type (C++ [class]p4)\n  ///\n  /// For purposes of this function a class is POD if it is an aggregate\n  /// that has no non-static non-POD data members, no reference data\n  /// members, no user-defined copy assignment operator and no\n  /// user-defined destructor.\n  ///\n  /// Note that this is the C++ TR1 definition of POD.\n  bool isPOD() const { return data().PlainOldData; }\n\n  /// True if this class is C-like, without C++-specific features, e.g.\n  /// it contains only public fields, no bases, tag kind is not 'class', etc.\n  bool isCLike() const;\n\n  /// Determine whether this is an empty class in the sense of\n  /// (C++11 [meta.unary.prop]).\n  ///\n  /// The CXXRecordDecl is a class type, but not a union type,\n  /// with no non-static data members other than bit-fields of length 0,\n  /// no virtual member functions, no virtual base classes,\n  /// and no base class B for which is_empty<B>::value is false.\n  ///\n  /// \\note This does NOT include a check for union-ness.\n  bool isEmpty() const { return data().Empty; }\n  /// Marks this record as empty. This is used by DWARFASTParserClang\n  /// when parsing records with empty fields having [[no_unique_address]]\n  /// attribute\n  void markEmpty() { data().Empty = true; }\n\n  void setInitMethod(bool Val) { data().HasInitMethod = Val; }\n  bool hasInitMethod() const { return data().HasInitMethod; }\n\n  bool hasPrivateFields() const {\n    return data().HasPrivateFields;\n  }\n\n  bool hasProtectedFields() const {\n    return data().HasProtectedFields;\n  }\n\n  /// Determine whether this class has direct non-static data members.\n  bool hasDirectFields() const {\n    auto &D = data();\n    return D.HasPublicFields || D.HasProtectedFields || D.HasPrivateFields;\n  }\n\n  /// Whether this class is polymorphic (C++ [class.virtual]),\n  /// which means that the class contains or inherits a virtual function.\n  bool isPolymorphic() const { return data().Polymorphic; }\n\n  /// Determine whether this class has a pure virtual function.\n  ///\n  /// The class is abstract per (C++ [class.abstract]p2) if it declares\n  /// a pure virtual function or inherits a pure virtual function that is\n  /// not overridden.\n  bool isAbstract() const { return data().Abstract; }\n\n  /// Determine whether this class is standard-layout per\n  /// C++ [class]p7.\n  bool isStandardLayout() const { return data().IsStandardLayout; }\n\n  /// Determine whether this class was standard-layout per\n  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.\n  bool isCXX11StandardLayout() const { return data().IsCXX11StandardLayout; }\n\n  /// Determine whether this class, or any of its class subobjects,\n  /// contains a mutable field.\n  bool hasMutableFields() const { return data().HasMutableFields; }\n\n  /// Determine whether this class has any variant members.\n  bool hasVariantMembers() const { return data().HasVariantMembers; }\n\n  /// Determine whether this class has a trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasTrivialDefaultConstructor() const {\n    return hasDefaultConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_DefaultConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasNonTrivialDefaultConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_DefaultConstructor) ||\n           (needsImplicitDefaultConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has at least one constexpr constructor\n  /// other than the copy or move constructors.\n  bool hasConstexprNonCopyMoveConstructor() const {\n    return data().HasConstexprNonCopyMoveConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDefaultConstructorIsConstexpr() const {\n    return data().DefaultedDefaultConstructorIsConstexpr &&\n           (!isUnion() || hasInClassInitializer() || !hasVariantMembers() ||\n            getLangOpts().CPlusPlus20);\n  }\n\n  /// Determine whether this class has a constexpr default constructor.\n  bool hasConstexprDefaultConstructor() const {\n    return data().HasConstexprDefaultConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether this class has a trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasTrivialCopyConstructor() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyConstructor;\n  }\n\n  bool hasTrivialCopyConstructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class has a non-trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasNonTrivialCopyConstructor() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyConstructor ||\n           !hasTrivialCopyConstructor();\n  }\n\n  bool hasNonTrivialCopyConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_CopyConstructor) ||\n           !hasTrivialCopyConstructorForCall();\n  }\n\n  /// Determine whether this class has a trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasTrivialMoveConstructor() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveConstructor);\n  }\n\n  bool hasTrivialMoveConstructorForCall() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasNonTrivialMoveConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveConstructor));\n  }\n\n  bool hasNonTrivialMoveConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor));\n  }\n\n  /// Determine whether this class has a trivial copy assignment operator\n  /// (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasTrivialCopyAssignment() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Determine whether this class has a non-trivial copy assignment\n  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasNonTrivialCopyAssignment() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyAssignment ||\n           !hasTrivialCopyAssignment();\n  }\n\n  /// Determine whether this class has a trivial move assignment operator\n  /// (C++11 [class.copy]p25)\n  bool hasTrivialMoveAssignment() const {\n    return hasMoveAssignment() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has a non-trivial move assignment\n  /// operator (C++11 [class.copy]p25)\n  bool hasNonTrivialMoveAssignment() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveAssignment) ||\n           (needsImplicitMoveAssignment() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveAssignment));\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDestructorIsConstexpr() const {\n    return data().DefaultedDestructorIsConstexpr &&\n           getLangOpts().CPlusPlus20;\n  }\n\n  /// Determine whether this class has a constexpr destructor.\n  bool hasConstexprDestructor() const;\n\n  /// Determine whether this class has a trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasTrivialDestructor() const {\n    return data().HasTrivialSpecialMembers & SMF_Destructor;\n  }\n\n  bool hasTrivialDestructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_Destructor;\n  }\n\n  /// Determine whether this class has a non-trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasNonTrivialDestructor() const {\n    return !(data().HasTrivialSpecialMembers & SMF_Destructor);\n  }\n\n  bool hasNonTrivialDestructorForCall() const {\n    return !(data().HasTrivialSpecialMembersForCall & SMF_Destructor);\n  }\n\n  void setHasTrivialSpecialMemberForCall() {\n    data().HasTrivialSpecialMembersForCall =\n        (SMF_CopyConstructor | SMF_MoveConstructor | SMF_Destructor);\n  }\n\n  /// Determine whether declaring a const variable with this type is ok\n  /// per core issue 253.\n  bool allowConstDefaultInit() const {\n    return !data().HasUninitializedFields ||\n           !(data().HasDefaultedDefaultConstructor ||\n             needsImplicitDefaultConstructor());\n  }\n\n  /// Determine whether this class has a destructor which has no\n  /// semantic effect.\n  ///\n  /// Any such destructor will be trivial, public, defaulted and not deleted,\n  /// and will call only irrelevant destructors.\n  bool hasIrrelevantDestructor() const {\n    return data().HasIrrelevantDestructor;\n  }\n\n  /// Determine whether this class has a non-literal or/ volatile type\n  /// non-static data member or base class.\n  bool hasNonLiteralTypeFieldsOrBases() const {\n    return data().HasNonLiteralTypeFieldsOrBases;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a user-declared base class constructor.\n  bool hasInheritedConstructor() const {\n    return data().HasInheritedConstructor;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a base class assignment operator.\n  bool hasInheritedAssignment() const {\n    return data().HasInheritedAssignment;\n  }\n\n  /// Determine whether this class is considered trivially copyable per\n  /// (C++11 [class]p6).\n  bool isTriviallyCopyable() const;\n\n  /// Determine whether this class is considered trivial.\n  ///\n  /// C++11 [class]p6:\n  ///    \"A trivial class is a class that has a trivial default constructor and\n  ///    is trivially copyable.\"\n  bool isTrivial() const {\n    return isTriviallyCopyable() && hasTrivialDefaultConstructor();\n  }\n\n  /// Determine whether this class is a literal type.\n  ///\n  /// C++11 [basic.types]p10:\n  ///   A class type that has all the following properties:\n  ///     - it has a trivial destructor\n  ///     - every constructor call and full-expression in the\n  ///       brace-or-equal-intializers for non-static data members (if any) is\n  ///       a constant expression.\n  ///     - it is an aggregate type or has at least one constexpr constructor\n  ///       or constructor template that is not a copy or move constructor, and\n  ///     - all of its non-static data members and base classes are of literal\n  ///       types\n  ///\n  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by\n  /// treating types with trivial default constructors as literal types.\n  ///\n  /// Only in C++17 and beyond, are lambdas literal types.\n  bool isLiteral() const {\n    const LangOptions &LangOpts = getLangOpts();\n    return (LangOpts.CPlusPlus20 ? hasConstexprDestructor()\n                                          : hasTrivialDestructor()) &&\n           (!isLambda() || LangOpts.CPlusPlus17) &&\n           !hasNonLiteralTypeFieldsOrBases() &&\n           (isAggregate() || isLambda() ||\n            hasConstexprNonCopyMoveConstructor() ||\n            hasTrivialDefaultConstructor());\n  }\n\n  /// Determine whether this is a structural type.\n  bool isStructural() const {\n    return isLiteral() && data().StructuralIfLiteral;\n  }\n\n  /// Notify the class that this destructor is now selected.\n  ///\n  /// Important properties of the class depend on destructor properties. Since\n  /// C++20, it is possible to have multiple destructor declarations in a class\n  /// out of which one will be selected at the end.\n  /// This is called separately from addedMember because it has to be deferred\n  /// to the completion of the class.\n  void addedSelectedDestructor(CXXDestructorDecl *DD);\n\n  /// Notify the class that an eligible SMF has been added.\n  /// This updates triviality and destructor based properties of the class accordingly.\n  void addedEligibleSpecialMemberFunction(const CXXMethodDecl *MD, unsigned SMKind);\n\n  /// If this record is an instantiation of a member class,\n  /// retrieves the member class from which it was instantiated.\n  ///\n  /// This routine will return non-null for (non-templated) member\n  /// classes of class templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const { return data().IsAnyDestructorNoReturn; }\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Retrieve the index of this lambda within the context declaration returned\n  /// by getLambdaContextDecl().\n  unsigned getLambdaIndexInContext() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().IndexInContext;\n  }\n\n  /// Information about how a lambda is numbered within its context.\n  struct LambdaNumbering {\n    Decl *ContextDecl = nullptr;\n    unsigned IndexInContext = 0;\n    unsigned ManglingNumber = 0;\n    unsigned DeviceManglingNumber = 0;\n    bool HasKnownInternalLinkage = false;\n  };\n\n  /// Set the mangling numbers and context declaration for a lambda class.\n  void setLambdaNumbering(LambdaNumbering Numbering);\n\n  // Get the mangling numbers and context declaration for a lambda class.\n  LambdaNumbering getLambdaNumbering() const {\n    return {getLambdaContextDecl(), getLambdaIndexInContext(),\n            getLambdaManglingNumber(), getDeviceLambdaManglingNumber(),\n            hasKnownLambdaInternalLinkage()};\n  }\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().DependencyKind == LDK_AlwaysDependent;\n  }\n\n  bool isNeverDependentLambda() const {\n    return isLambda() && getLambdaData().DependencyKind == LDK_NeverDependent;\n  }\n\n  unsigned getLambdaDependencyKind() const {\n    if (!isLambda())\n      return LDK_Unknown;\n    return getLambdaData().DependencyKind;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  void setLambdaTypeInfo(TypeSourceInfo *TS) {\n    assert(DefinitionData && DefinitionData->IsLambda &&\n           \"setting lambda property of non-lambda class\");\n    auto &DL = static_cast<LambdaDefinitionData &>(*DefinitionData);\n    DL.MethodTyInfo = TS;\n  }\n\n  void setLambdaIsGeneric(bool IsGeneric) {\n    assert(DefinitionData && DefinitionData->IsLambda &&\n           \"setting lambda property of non-lambda class\");\n    auto &DL = static_cast<LambdaDefinitionData &>(*DefinitionData);\n    DL.IsGenericLambda = IsGeneric;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n  void markAbstract() { data().Abstract = true; }\n}",
  "id": "BLOCK-CPP-08700",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 254,
  "validation_status": "validated"
}