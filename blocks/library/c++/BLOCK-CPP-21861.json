{
  "code": "{\npublic:\n  struct Branch {\n    const Stmt *Terminator;\n    unsigned Output;\n  };\n\nprivate:\n  /// The expression which uses this variable.\n  const Expr *User;\n\n  /// Is this use uninitialized whenever the function is called?\n  bool UninitAfterCall = false;\n\n  /// Is this use uninitialized whenever the variable declaration is reached?\n  bool UninitAfterDecl = false;\n\n  /// Does this use always see an uninitialized value?\n  bool AlwaysUninit;\n\n  /// This use is always uninitialized if it occurs after any of these branches\n  /// is taken.\n  SmallVector<Branch, 2> UninitBranches;\n\npublic:\n  UninitUse(const Expr *User, bool AlwaysUninit)\n      : User(User), AlwaysUninit(AlwaysUninit) {}\n\n  void addUninitBranch(Branch B) {\n    UninitBranches.push_back(B);\n  }\n\n  void setUninitAfterCall() { UninitAfterCall = true; }\n  void setUninitAfterDecl() { UninitAfterDecl = true; }\n\n  /// Get the expression containing the uninitialized use.\n  const Expr *getUser() const { return User; }\n\n  /// The kind of uninitialized use.\n  enum Kind {\n    /// The use might be uninitialized.\n    Maybe,\n\n    /// The use is uninitialized whenever a certain branch is taken.\n    Sometimes,\n\n    /// The use is uninitialized the first time it is reached after we reach\n    /// the variable's declaration.\n    AfterDecl,\n\n    /// The use is uninitialized the first time it is reached after the function\n    /// is called.\n    AfterCall,\n\n    /// The use is always uninitialized.\n    Always\n  };\n\n  /// Get the kind of uninitialized use.\n  Kind getKind() const {\n    return AlwaysUninit ? Always :\n           UninitAfterCall ? AfterCall :\n           UninitAfterDecl ? AfterDecl :\n           !branch_empty() ? Sometimes : Maybe;\n  }\n\n  using branch_iterator = SmallVectorImpl<Branch>::const_iterator;\n\n  /// Branches which inevitably result in the variable being used uninitialized.\n  branch_iterator branch_begin() const { return UninitBranches.begin(); }\n  branch_iterator branch_end() const { return UninitBranches.end(); }\n  bool branch_empty() const { return UninitBranches.empty(); }\n}",
  "id": "BLOCK-CPP-21861",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/Analyses/UninitializedValues.h",
  "source_line": 30,
  "validation_status": "validated"
}