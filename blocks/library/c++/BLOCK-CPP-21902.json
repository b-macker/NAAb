{
  "code": "{\nclass Logger;\n\n/// Skip past nodes that the CFG does not emit. These nodes are invisible to\n/// flow-sensitive analysis, and should be ignored as they will effectively not\n/// exist.\n///\n///   * `ParenExpr` - The CFG takes the operator precedence into account, but\n///   otherwise omits the node afterwards.\n///\n///   * `ExprWithCleanups` - The CFG will generate the appropriate calls to\n///   destructors and then omit the node.\n///\nconst Expr &ignoreCFGOmittedNodes(const Expr &E);\nconst Stmt &ignoreCFGOmittedNodes(const Stmt &S);\n\n/// A set of `FieldDecl *`. Use `SmallSetVector` to guarantee deterministic\n/// iteration order.\nusing FieldSet = llvm::SmallSetVector<const FieldDecl *, 4>;\n\n/// Returns the set of all fields in the type.\nFieldSet getObjectFields(QualType Type);\n\nstruct ContextSensitiveOptions {\n  /// The maximum depth to analyze. A value of zero is equivalent to disabling\n  /// context-sensitive analysis entirely.\n  unsigned Depth = 2;\n};\n\n/// Owns objects that encompass the state of a program and stores context that\n/// is used during dataflow analysis.\nclass DataflowAnalysisContext {\npublic:\n  struct Options {\n    /// Options for analyzing function bodies when present in the translation\n    /// unit, or empty to disable context-sensitive analysis. Note that this is\n    /// fundamentally limited: some constructs, such as recursion, are\n    /// explicitly unsupported.\n    std::optional<ContextSensitiveOptions> ContextSensitiveOpts;\n\n    /// If provided, analysis details will be recorded here.\n    /// (This is always non-null within an AnalysisContext, the framework\n    /// provides a fallback no-op logger).\n    Logger *Log = nullptr;\n  };\n\n  /// Constructs a dataflow analysis context.\n  ///\n  /// Requirements:\n  ///\n  ///  `S` must not be null.\n  DataflowAnalysisContext(std::unique_ptr<Solver> S,\n                          Options Opts = Options{\n                              /*ContextSensitiveOpts=*/std::nullopt,\n                              /*Logger=*/nullptr});\n  ~DataflowAnalysisContext();\n\n  /// Returns a new storage location appropriate for `Type`.\n  ///\n  /// A null `Type` is interpreted as the pointee type of `std::nullptr_t`.\n  StorageLocation &createStorageLocation(QualType Type);\n\n  /// Returns a stable storage location for `D`.\n  StorageLocation &getStableStorageLocation(const VarDecl &D);\n\n  /// Returns a stable storage location for `E`.\n  StorageLocation &getStableStorageLocation(const Expr &E);\n\n  /// Assigns `Loc` as the storage location of `D`.\n  ///\n  /// Requirements:\n  ///\n  ///  `D` must not be assigned a storage location.\n  void setStorageLocation(const ValueDecl &D, StorageLocation &Loc) {\n    assert(!DeclToLoc.contains(&D));\n    DeclToLoc[&D] = &Loc;\n  }\n\n  /// Returns the storage location assigned to `D` or null if `D` has no\n  /// assigned storage location.\n  StorageLocation *getStorageLocation(const ValueDecl &D) const {\n    return DeclToLoc.lookup(&D);\n  }\n\n  /// Assigns `Loc` as the storage location of `E`.\n  ///\n  /// Requirements:\n  ///\n  ///  `E` must not be assigned a storage location.\n  void setStorageLocation(const Expr &E, StorageLocation &Loc) {\n    const Expr &CanonE = ignoreCFGOmittedNodes(E);\n    assert(!ExprToLoc.contains(&CanonE));\n    ExprToLoc[&CanonE] = &Loc;\n  }\n\n  /// Returns the storage location assigned to `E` or null if `E` has no\n  /// assigned storage location.\n  StorageLocation *getStorageLocation(const Expr &E) const {\n    return ExprToLoc.lookup(&ignoreCFGOmittedNodes(E));\n  }\n\n  /// Returns a pointer value that represents a null pointer. Calls with\n  /// `PointeeType` that are canonically equivalent will return the same result.\n  /// A null `PointeeType` can be used for the pointee of `std::nullptr_t`.\n  PointerValue &getOrCreateNullPointerValue(QualType PointeeType);\n\n  /// Adds `Constraint` to the flow condition identified by `Token`.\n  void addFlowConditionConstraint(Atom Token, const Formula &Constraint);\n\n  /// Creates a new flow condition with the same constraints as the flow\n  /// condition identified by `Token` and returns its token.\n  Atom forkFlowCondition(Atom Token);\n\n  /// Creates a new flow condition that represents the disjunction of the flow\n  /// conditions identified by `FirstToken` and `SecondToken`, and returns its\n  /// token.\n  Atom joinFlowConditions(Atom FirstToken, Atom SecondToken);\n\n  /// Returns true if and only if the constraints of the flow condition\n  /// identified by `Token` imply that `Val` is true.\n  bool flowConditionImplies(Atom Token, const Formula &);\n\n  /// Returns true if and only if the constraints of the flow condition\n  /// identified by `Token` are always true.\n  bool flowConditionIsTautology(Atom Token);\n\n  /// Returns true if `Val1` is equivalent to `Val2`.\n  /// Note: This function doesn't take into account constraints on `Val1` and\n  /// `Val2` imposed by the flow condition.\n  bool equivalentFormulas(const Formula &Val1, const Formula &Val2);\n\n  LLVM_DUMP_METHOD void dumpFlowCondition(Atom Token,\n                                          llvm::raw_ostream &OS = llvm::dbgs());\n\n  /// Returns the `ControlFlowContext` registered for `F`, if any. Otherwise,\n  /// returns null.\n  const ControlFlowContext *getControlFlowContext(const FunctionDecl *F);\n\n  const Options &getOptions() { return Opts; }\n\n  Arena &arena() { return *A; }\n\n  /// Returns the outcome of satisfiability checking on `Constraints`.\n  ///\n  /// Flow conditions are not incorporated, so they may need to be manually\n  /// included in `Constraints` to provide contextually-accurate results, e.g.\n  /// if any definitions or relationships of the values in `Constraints` have\n  /// been stored in flow conditions.\n  Solver::Result querySolver(llvm::SetVector<const Formula *> Constraints);\n\n  /// Returns the fields of `Type`, limited to the set of fields modeled by this\n  /// context.\n  FieldSet getModeledFields(QualType Type);\n\nprivate:\n  friend class Environment;\n\n  struct NullableQualTypeDenseMapInfo : private llvm::DenseMapInfo<QualType> {\n    static QualType getEmptyKey() {\n      // Allow a NULL `QualType` by using a different value as the empty key.\n      return QualType::getFromOpaquePtr(reinterpret_cast<Type *>(1));\n    }\n\n    using DenseMapInfo::getHashValue;\n    using DenseMapInfo::getTombstoneKey;\n    using DenseMapInfo::isEqual;\n  };\n\n  // Extends the set of modeled field declarations.\n  void addModeledFields(const FieldSet &Fields);\n\n  /// Adds all constraints of the flow condition identified by `Token` and all\n  /// of its transitive dependencies to `Constraints`. `VisitedTokens` is used\n  /// to track tokens of flow conditions that were already visited by recursive\n  /// calls.\n  void addTransitiveFlowConditionConstraints(\n      Atom Token, llvm::SetVector<const Formula *> &Constraints,\n      llvm::DenseSet<Atom> &VisitedTokens);\n\n  /// Returns true if the solver is able to prove that there is no satisfying\n  /// assignment for `Constraints`\n  bool isUnsatisfiable(llvm::SetVector<const Formula *> Constraints) {\n    return querySolver(std::move(Constraints)).getStatus() ==\n           Solver::Result::Status::Unsatisfiable;\n  }\n\n  std::unique_ptr<Solver> S;\n  std::unique_ptr<Arena> A;\n\n  // Maps from program declarations and statements to storage locations that are\n  // assigned to them. These assignments are global (aggregated across all basic\n  // blocks) and are used to produce stable storage locations when the same\n  // basic blocks are evaluated multiple times. The storage locations that are\n  // in scope for a particular basic block are stored in `Environment`.\n  llvm::DenseMap<const ValueDecl *, StorageLocation *> DeclToLoc;\n  llvm::DenseMap<const Expr *, StorageLocation *> ExprToLoc;\n\n  // Null pointer values, keyed by the canonical pointee type.\n  //\n  // FIXME: The pointer values are indexed by the pointee types which are\n  // required to initialize the `PointeeLoc` field in `PointerValue`. Consider\n  // creating a type-independent `NullPointerValue` without a `PointeeLoc`\n  // field.\n  llvm::DenseMap<QualType, PointerValue *, NullableQualTypeDenseMapInfo>\n      NullPointerVals;\n\n  Options Opts;\n\n  // Flow conditions are tracked symbolically: each unique flow condition is\n  // associated with a fresh symbolic variable (token), bound to the clause that\n  // defines the flow condition. Conceptually, each binding corresponds to an\n  // \"iff\" of the form `FC <=> (C1 ^ C2 ^ ...)` where `FC` is a flow condition\n  // token (an atomic boolean) and `Ci`s are the set of constraints in the flow\n  // flow condition clause. The set of constraints (C1 ^ C2 ^ ...) are stored in\n  // the `FlowConditionConstraints` map, keyed by the token of the flow\n  // condition.\n  //\n  // Flow conditions depend on other flow conditions if they are created using\n  // `forkFlowCondition` or `joinFlowConditions`. The graph of flow condition\n  // dependencies is stored in the `FlowConditionDeps` map.\n  llvm::DenseMap<Atom, llvm::DenseSet<Atom>> FlowConditionDeps;\n  llvm::DenseMap<Atom, const Formula *> FlowConditionConstraints;\n\n  llvm::DenseMap<const FunctionDecl *, ControlFlowContext> FunctionContexts;\n\n  // Fields modeled by environments covered by this context.\n  FieldSet ModeledFields;\n\n  std::unique_ptr<Logger> LogOwner; // If created via flags.\n};\n\n}",
  "id": "BLOCK-CPP-21902",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h",
  "source_line": 38,
  "validation_status": "validated"
}