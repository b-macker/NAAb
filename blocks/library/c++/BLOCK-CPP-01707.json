{
  "code": "{\n  // Value is either an argument suffix after `=` in \"--foo=<value>\"\n  // or separate argument in case of \"--foo\" \"<value>\".\n\n  // boolean flags have these forms:\n  //   --foo\n  //   --nofoo\n  //   --foo=true\n  //   --foo=false\n  //   --nofoo=<value> is not supported\n  //   --foo <value> is not supported\n\n  // non boolean flags have these forms:\n  // --foo=<value>\n  // --foo <value>\n  // --nofoo is not supported\n\n  if (flag.IsOfType<bool>()) {\n    if (value.empty()) {\n      if (is_empty_value) {\n        // \"--bool_flag=\" case\n        flags_internal::ReportUsageError(\n            absl::StrCat(\n                \"Missing the value after assignment for the boolean flag '\",\n                flag.Name(), \"'\"),\n            true);\n        return std::make_tuple(false, \"\");\n      }\n\n      // \"--bool_flag\" case\n      value = is_negative ? \"0\" : \"1\";\n    } else if (is_negative) {\n      // \"--nobool_flag=Y\" case\n      flags_internal::ReportUsageError(\n          absl::StrCat(\"Negative form with assignment is not valid for the \"\n                       \"boolean flag '\",\n                       flag.Name(), \"'\"),\n          true);\n      return std::make_tuple(false, \"\");\n    }\n  } else if (is_negative) {\n    // \"--noint_flag=1\" case\n    flags_internal::ReportUsageError(\n        absl::StrCat(\"Negative form is not valid for the flag '\", flag.Name(),\n                     \"'\"),\n        true);\n    return std::make_tuple(false, \"\");\n  } else if (value.empty() && (!is_empty_value)) {\n    if (curr_list->Size() == 1) {\n      // \"--int_flag\" case\n      flags_internal::ReportUsageError(\n          absl::StrCat(\"Missing the value for the flag '\", flag.Name(), \"'\"),\n          true);\n      return std::make_tuple(false, \"\");\n    }\n\n    // \"--int_flag\" \"10\" case\n    curr_list->PopFront();\n    value = curr_list->Front();\n\n    // Heuristic to detect the case where someone treats a string arg\n    // like a bool or just forgets to pass a value:\n    // --my_string_var --foo=bar\n    // We look for a flag of string type, whose value begins with a\n    // dash and corresponds to known flag or standalone --.\n    if (!value.empty() && value[0] == '-' && flag.IsOfType<std::string>()) {\n      auto maybe_flag_name = std::get<0>(SplitNameAndValue(value.substr(1)));\n\n      if (maybe_flag_name.empty() ||\n          std::get<0>(LocateFlag(maybe_flag_name)) != nullptr) {\n        // \"--string_flag\" \"--known_flag\" case\n        ABSL_INTERNAL_LOG(\n            WARNING,\n            absl::StrCat(\"Did you really mean to set flag '\", flag.Name(),\n                         \"' to the value '\", value, \"'?\"));\n      }\n    }\n  }\n\n  return std::make_tuple(true, value);\n}",
  "id": "BLOCK-CPP-01707",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/parse.cc",
  "source_line": 505,
  "validation_status": "validated"
}