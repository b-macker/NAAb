{
  "code": "{\nclass IdentifierInfo;\nclass ASTRecordWriter;\n\nclass AttributeCommonInfo {\npublic:\n  /// The style used to specify an attribute.\n  enum Syntax {\n    /// __attribute__((...))\n    AS_GNU = 1,\n\n    /// [[...]]\n    AS_CXX11,\n\n    /// [[...]]\n    AS_C2x,\n\n    /// __declspec(...)\n    AS_Declspec,\n\n    /// [uuid(\"...\")] class Foo\n    AS_Microsoft,\n\n    /// __ptr16, alignas(...), etc.\n    AS_Keyword,\n\n    /// #pragma ...\n    AS_Pragma,\n\n    // Note TableGen depends on the order above.  Do not add or change the order\n    // without adding related code to TableGen/ClangAttrEmitter.cpp.\n    /// Context-sensitive version of a keyword attribute.\n    AS_ContextSensitiveKeyword,\n\n    /// <vardecl> : <semantic>\n    AS_HLSLSemantic,\n\n    /// The attibute has no source code manifestation and is only created\n    /// implicitly.\n    AS_Implicit\n  };\n  enum Kind {\n#define PARSED_ATTR(NAME) AT_##NAME,\n#include \"clang/Sema/AttrParsedAttrList.inc\"\n#undef PARSED_ATTR\n    NoSemaHandlerAttribute,\n    IgnoredAttribute,\n    UnknownAttribute,\n  };\n\nprivate:\n  const IdentifierInfo *AttrName = nullptr;\n  const IdentifierInfo *ScopeName = nullptr;\n  SourceRange AttrRange;\n  const SourceLocation ScopeLoc;\n  // Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// Corresponds to the Syntax enum.\n  unsigned SyntaxUsed : 4;\n  unsigned SpellingIndex : 4;\n  unsigned IsAlignas : 1;\n  unsigned IsRegularKeywordAttribute : 1;\n\nprotected:\n  static constexpr unsigned SpellingNotCalculated = 0xf;\n\npublic:\n  /// Combines information about the source-code form of an attribute,\n  /// including its syntax and spelling.\n  class Form {\n  public:\n    constexpr Form(Syntax SyntaxUsed, unsigned SpellingIndex, bool IsAlignas,\n                   bool IsRegularKeywordAttribute)\n        : SyntaxUsed(SyntaxUsed), SpellingIndex(SpellingIndex),\n          IsAlignas(IsAlignas),\n          IsRegularKeywordAttribute(IsRegularKeywordAttribute) {}\n    constexpr Form(tok::TokenKind Tok)\n        : SyntaxUsed(AS_Keyword), SpellingIndex(SpellingNotCalculated),\n          IsAlignas(Tok == tok::kw_alignas),\n          IsRegularKeywordAttribute(tok::isRegularKeywordAttribute(Tok)) {}\n\n    Syntax getSyntax() const { return Syntax(SyntaxUsed); }\n    unsigned getSpellingIndex() const { return SpellingIndex; }\n    bool isAlignas() const { return IsAlignas; }\n    bool isRegularKeywordAttribute() const { return IsRegularKeywordAttribute; }\n\n    static Form GNU() { return AS_GNU; }\n    static Form CXX11() { return AS_CXX11; }\n    static Form C2x() { return AS_C2x; }\n    static Form Declspec() { return AS_Declspec; }\n    static Form Microsoft() { return AS_Microsoft; }\n    static Form Keyword(bool IsAlignas, bool IsRegularKeywordAttribute) {\n      return Form(AS_Keyword, SpellingNotCalculated, IsAlignas,\n                  IsRegularKeywordAttribute);\n    }\n    static Form Pragma() { return AS_Pragma; }\n    static Form ContextSensitiveKeyword() { return AS_ContextSensitiveKeyword; }\n    static Form HLSLSemantic() { return AS_HLSLSemantic; }\n    static Form Implicit() { return AS_Implicit; }\n\n  private:\n    constexpr Form(Syntax SyntaxUsed)\n        : SyntaxUsed(SyntaxUsed), SpellingIndex(SpellingNotCalculated),\n          IsAlignas(0), IsRegularKeywordAttribute(0) {}\n\n    unsigned SyntaxUsed : 4;\n    unsigned SpellingIndex : 4;\n    unsigned IsAlignas : 1;\n    unsigned IsRegularKeywordAttribute : 1;\n  };\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName,\n                      const IdentifierInfo *ScopeName, SourceRange AttrRange,\n                      SourceLocation ScopeLoc, Kind AttrKind, Form FormUsed)\n      : AttrName(AttrName), ScopeName(ScopeName), AttrRange(AttrRange),\n        ScopeLoc(ScopeLoc), AttrKind(AttrKind),\n        SyntaxUsed(FormUsed.getSyntax()),\n        SpellingIndex(FormUsed.getSpellingIndex()),\n        IsAlignas(FormUsed.isAlignas()),\n        IsRegularKeywordAttribute(FormUsed.isRegularKeywordAttribute()) {\n    assert(SyntaxUsed >= AS_GNU && SyntaxUsed <= AS_Implicit &&\n           \"Invalid syntax!\");\n  }\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName,\n                      const IdentifierInfo *ScopeName, SourceRange AttrRange,\n                      SourceLocation ScopeLoc, Form FormUsed)\n      : AttributeCommonInfo(\n            AttrName, ScopeName, AttrRange, ScopeLoc,\n            getParsedKind(AttrName, ScopeName, FormUsed.getSyntax()),\n            FormUsed) {}\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName, SourceRange AttrRange,\n                      Form FormUsed)\n      : AttributeCommonInfo(AttrName, nullptr, AttrRange, SourceLocation(),\n                            FormUsed) {}\n\n  AttributeCommonInfo(SourceRange AttrRange, Kind K, Form FormUsed)\n      : AttributeCommonInfo(nullptr, nullptr, AttrRange, SourceLocation(), K,\n                            FormUsed) {}\n\n  AttributeCommonInfo(AttributeCommonInfo &&) = default;\n  AttributeCommonInfo(const AttributeCommonInfo &) = default;\n\n  Kind getParsedKind() const { return Kind(AttrKind); }\n  Syntax getSyntax() const { return Syntax(SyntaxUsed); }\n  Form getForm() const {\n    return Form(getSyntax(), SpellingIndex, IsAlignas,\n                IsRegularKeywordAttribute);\n  }\n  const IdentifierInfo *getAttrName() const { return AttrName; }\n  SourceLocation getLoc() const { return AttrRange.getBegin(); }\n  SourceRange getRange() const { return AttrRange; }\n  void setRange(SourceRange R) { AttrRange = R; }\n\n  bool hasScope() const { return ScopeName; }\n  const IdentifierInfo *getScopeName() const { return ScopeName; }\n  SourceLocation getScopeLoc() const { return ScopeLoc; }\n\n  /// Gets the normalized full name, which consists of both scope and name and\n  /// with surrounding underscores removed as appropriate (e.g.\n  /// __gnu__::__attr__ will be normalized to gnu::attr).\n  std::string getNormalizedFullName() const;\n\n  bool isDeclspecAttribute() const { return SyntaxUsed == AS_Declspec; }\n  bool isMicrosoftAttribute() const { return SyntaxUsed == AS_Microsoft; }\n\n  bool isGNUScope() const;\n  bool isClangScope() const;\n\n  bool isCXX11Attribute() const { return SyntaxUsed == AS_CXX11 || IsAlignas; }\n\n  bool isC2xAttribute() const { return SyntaxUsed == AS_C2x; }\n\n  /// The attribute is spelled [[]] in either C or C++ mode, including standard\n  /// attributes spelled with a keyword, like alignas.\n  bool isStandardAttributeSyntax() const {\n    return isCXX11Attribute() || isC2xAttribute();\n  }\n\n  bool isGNUAttribute() const { return SyntaxUsed == AS_GNU; }\n\n  bool isKeywordAttribute() const {\n    return SyntaxUsed == AS_Keyword || SyntaxUsed == AS_ContextSensitiveKeyword;\n  }\n\n  bool isRegularKeywordAttribute() const { return IsRegularKeywordAttribute; }\n\n  bool isContextSensitiveKeywordAttribute() const {\n    return SyntaxUsed == AS_ContextSensitiveKeyword;\n  }\n\n  unsigned getAttributeSpellingListIndex() const {\n    assert((isAttributeSpellingListCalculated() || AttrName) &&\n           \"Spelling cannot be found\");\n    return isAttributeSpellingListCalculated()\n               ? SpellingIndex\n               : calculateAttributeSpellingListIndex();\n  }\n  void setAttributeSpellingListIndex(unsigned V) { SpellingIndex = V; }\n\n  static Kind getParsedKind(const IdentifierInfo *Name,\n                            const IdentifierInfo *Scope, Syntax SyntaxUsed);\n\nprivate:\n  /// Get an index into the attribute spelling list\n  /// defined in Attr.td. This index is used by an attribute\n  /// to pretty print itself.\n  unsigned calculateAttributeSpellingListIndex() const;\n\n  friend class clang::ASTRecordWriter;\n  // Used exclusively by ASTDeclWriter to get the raw spelling list state.\n  unsigned getAttributeSpellingListIndexRaw() const { return SpellingIndex; }\n\nprotected:\n  bool isAttributeSpellingListCalculated() const {\n    return SpellingIndex != SpellingNotCalculated;\n  }\n};\n}",
  "id": "BLOCK-CPP-16008",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/AttributeCommonInfo.h",
  "source_line": 19,
  "validation_status": "validated"
}