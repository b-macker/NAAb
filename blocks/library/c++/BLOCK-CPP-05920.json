{
  "code": "{\n  static_assert(std::is_same<typename Params::state_type,\n                             typename Mix::state_type>::value,\n                \"Class-template absl::pcg_engine must be parameterized by \"\n                \"Params and Mix with identical state_type\");\n\n  static_assert(std::is_unsigned<typename Mix::result_type>::value,\n                \"Class-template absl::pcg_engine must be parameterized by \"\n                \"an unsigned Mix::result_type\");\n\n  using params_type = Params;\n  using mix_type = Mix;\n  using state_type = typename Mix::state_type;\n\n public:\n  // C++11 URBG interface:\n  using result_type = typename Mix::result_type;\n\n  static constexpr result_type(min)() {\n    return (std::numeric_limits<result_type>::min)();\n  }\n\n  static constexpr result_type(max)() {\n    return (std::numeric_limits<result_type>::max)();\n  }\n\n  explicit pcg_engine(uint64_t seed_value = 0) { seed(seed_value); }\n\n  template <class SeedSequence,\n            typename = typename absl::enable_if_t<\n                !std::is_same<SeedSequence, pcg_engine>::value>>\n  explicit pcg_engine(SeedSequence&& seq) {\n    seed(seq);\n  }\n\n  pcg_engine(const pcg_engine&) = default;\n  pcg_engine& operator=(const pcg_engine&) = default;\n  pcg_engine(pcg_engine&&) = default;\n  pcg_engine& operator=(pcg_engine&&) = default;\n\n  result_type operator()() {\n    // Advance the LCG state, always using the new value to generate the output.\n    state_ = lcg(state_);\n    return Mix{}(state_);\n  }\n\n  void seed(uint64_t seed_value = 0) {\n    state_type tmp = seed_value;\n    state_ = lcg(tmp + Params::increment());\n  }\n\n  template <class SeedSequence>\n  typename absl::enable_if_t<\n      !std::is_convertible<SeedSequence, uint64_t>::value, void>\n  seed(SeedSequence&& seq) {\n    reseed(seq);\n  }\n\n  void discard(uint64_t count) { state_ = advance(state_, count); }\n\n  bool operator==(const pcg_engine& other) const {\n    return state_ == other.state_;\n  }\n\n  bool operator!=(const pcg_engine& other) const { return !(*this == other); }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) == 16),\n                                    std::basic_ostream<CharT, Traits>&>\n  operator<<(\n      std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n      const pcg_engine& engine) {\n    auto saver = random_internal::make_ostream_state_saver(os);\n    random_internal::stream_u128_helper<state_type> helper;\n    helper.write(pcg_engine::params_type::multiplier(), os);\n    os << os.fill();\n    helper.write(pcg_engine::params_type::increment(), os);\n    os << os.fill();\n    helper.write(engine.state_, os);\n    return os;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) <= 8),\n                                    std::basic_ostream<CharT, Traits>&>\n  operator<<(\n      std::basic_ostream<CharT, Traits>& os,  // NOLINT(runtime/references)\n      const pcg_engine& engine) {\n    auto saver = random_internal::make_ostream_state_saver(os);\n    os << pcg_engine::params_type::multiplier() << os.fill();\n    os << pcg_engine::params_type::increment() << os.fill();\n    os << engine.state_;\n    return os;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) == 16),\n                                    std::basic_istream<CharT, Traits>&>\n  operator>>(\n      std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n      pcg_engine& engine) {                   // NOLINT(runtime/references)\n    random_internal::stream_u128_helper<state_type> helper;\n    auto mult = helper.read(is);\n    auto inc = helper.read(is);\n    auto tmp = helper.read(is);\n    if (mult != pcg_engine::params_type::multiplier() ||\n        inc != pcg_engine::params_type::increment()) {\n      // signal failure by setting the failbit.\n      is.setstate(is.rdstate() | std::ios_base::failbit);\n    }\n    if (!is.fail()) {\n      engine.state_ = tmp;\n    }\n    return is;\n  }\n\n  template <class CharT, class Traits>\n  friend typename absl::enable_if_t<(sizeof(state_type) <= 8),\n                                    std::basic_istream<CharT, Traits>&>\n  operator>>(\n      std::basic_istream<CharT, Traits>& is,  // NOLINT(runtime/references)\n      pcg_engine& engine) {                   // NOLINT(runtime/references)\n    state_type mult{}, inc{}, tmp{};\n    is >> mult >> inc >> tmp;\n    if (mult != pcg_engine::params_type::multiplier() ||\n        inc != pcg_engine::params_type::increment()) {\n      // signal failure by setting the failbit.\n      is.setstate(is.rdstate() | std::ios_base::failbit);\n    }\n    if (!is.fail()) {\n      engine.state_ = tmp;\n    }\n    return is;\n  }\n\n private:\n  state_type state_;\n\n  // Returns the linear-congruential generator next state.\n  static inline constexpr state_type lcg(state_type s) {\n    return s * Params::multiplier() + Params::increment();\n  }\n\n  // Returns the linear-congruential arbitrary seek state.\n  inline state_type advance(state_type s, uint64_t n) const {\n    state_type mult = Params::multiplier();\n    state_type inc = Params::increment();\n    state_type m = 1;\n    state_type i = 0;\n    while (n > 0) {\n      if (n & 1) {\n        m *= mult;\n        i = i * mult + inc;\n      }\n      inc = (mult + 1) * inc;\n      mult *= mult;\n      n >>= 1;\n    }\n    return m * s + i;\n  }\n\n  template <class SeedSequence>\n  void reseed(SeedSequence& seq) {\n    using sequence_result_type = typename SeedSequence::result_type;\n    constexpr size_t kBufferSize =\n        sizeof(state_type) / sizeof(sequence_result_type);\n    sequence_result_type buffer[kBufferSize];\n    seq.generate(std::begin(buffer), std::end(buffer));\n    // Convert the seed output to a single state value.\n    state_type tmp = buffer[0];\n    for (size_t i = 1; i < kBufferSize; i++) {\n      tmp <<= (sizeof(sequence_result_type) * 8);\n      tmp |= buffer[i];\n    }\n    state_ = lcg(tmp + params_type::increment());\n  }\n}",
  "id": "BLOCK-CPP-05920",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/random/internal/pcg_engine.h",
  "source_line": 40,
  "validation_status": "validated"
}