{
  "code": "#include \"clang/AST/TemplateBase.h\"\n\nusing namespace clang;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-13409_execute() {\n    {\n\nnamespace templateargumentvisitor {\n\n/// A simple visitor class that helps create template argument visitors.\ntemplate <template <typename> class Ref, typename ImplClass,\n          typename RetTy = void, typename... ParamTys>\nclass Base {\npublic:\n#define REF(CLASS) typename Ref<CLASS>::type\n#define DISPATCH(NAME)                                                         \\\n  case TemplateArgument::NAME:                                                 \\\n    return static_cast<ImplClass *>(this)->Visit##NAME##TemplateArgument(      \\\n        TA, std::forward<ParamTys>(P)...)\n\n  RetTy Visit(REF(TemplateArgument) TA, ParamTys... P) {\n    switch (TA.getKind()) {\n      DISPATCH(Null);\n      DISPATCH(Type);\n      DISPATCH(Declaration);\n      DISPATCH(NullPtr);\n      DISPATCH(Integral);\n      DISPATCH(Template);\n      DISPATCH(TemplateExpansion);\n      DISPATCH(Expression);\n      DISPATCH(Pack);\n    }\n    llvm_unreachable(\"TemplateArgument is not covered in switch!\");\n  }\n\n  // If the implementation chooses not to implement a certain visit\n  // method, fall back to the parent.\n\n#define VISIT_METHOD(CATEGORY)                                                 \\\n  RetTy Visit##CATEGORY##TemplateArgument(REF(TemplateArgument) TA,            \\\n                                          ParamTys... P) {                     \\\n    return VisitTemplateArgument(TA, std::forward<ParamTys>(P)...);            \\\n  }\n\n  VISIT_METHOD(Null);\n  VISIT_METHOD(Type);\n  VISIT_METHOD(Declaration);\n  VISIT_METHOD(NullPtr);\n  VISIT_METHOD(Integral);\n  VISIT_METHOD(Template);\n  VISIT_METHOD(TemplateExpansion);\n  VISIT_METHOD(Expression);\n  VISIT_METHOD(Pack);\n\n  RetTy VisitTemplateArgument(REF(TemplateArgument), ParamTys...) {\n    return RetTy();\n  }\n\n#undef REF\n#undef DISPATCH\n#undef VISIT_METHOD\n};\n\n} // namespace templateargumentvisitor\n\n/// A simple visitor class that helps create template argument visitors.\n///\n/// This class does not preserve constness of TemplateArgument references (see\n/// also ConstTemplateArgumentVisitor).\ntemplate <typename ImplClass, typename RetTy = void, typename... ParamTys>\nclass TemplateArgumentVisitor\n    : public templateargumentvisitor::Base<std::add_lvalue_reference, ImplClass,\n                                           RetTy, ParamTys...> {};\n\n/// A simple visitor class that helps create template argument visitors.\n///\n/// This class preserves constness of TemplateArgument references (see also\n/// TemplateArgumentVisitor).\ntemplate <typename ImplClass, typename RetTy = void, typename... ParamTys>\nclass ConstTemplateArgumentVisitor\n    : public templateargumentvisitor::Base<llvm::make_const_ref, ImplClass,\n                                           RetTy, ParamTys...> {};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-13409",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TemplateArgumentVisitor.h",
  "source_line": 18,
  "validation_status": "validated"
}