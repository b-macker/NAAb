{
  "code": "{\n  class DiagnosticsEngine;\n  class SourceLocation;\n\n  // Import the diagnostic enums themselves.\n  namespace diag {\n    enum class Group;\n\n    // Size of each of the diagnostic categories.\n    enum {\n      DIAG_SIZE_COMMON        =  300,\n      DIAG_SIZE_DRIVER        =  300,\n      DIAG_SIZE_FRONTEND      =  150,\n      DIAG_SIZE_SERIALIZATION =  120,\n      DIAG_SIZE_LEX           =  400,\n      DIAG_SIZE_PARSE         =  700,\n      DIAG_SIZE_AST           =  300,\n      DIAG_SIZE_COMMENT       =  100,\n      DIAG_SIZE_CROSSTU       =  100,\n      DIAG_SIZE_SEMA          = 4500,\n      DIAG_SIZE_ANALYSIS      =  100,\n      DIAG_SIZE_REFACTORING   = 1000,\n    };\n    // Start position for diagnostics.\n    enum {\n      DIAG_START_COMMON        =                          0,\n      DIAG_START_DRIVER        = DIAG_START_COMMON        + static_cast<int>(DIAG_SIZE_COMMON),\n      DIAG_START_FRONTEND      = DIAG_START_DRIVER        + static_cast<int>(DIAG_SIZE_DRIVER),\n      DIAG_START_SERIALIZATION = DIAG_START_FRONTEND      + static_cast<int>(DIAG_SIZE_FRONTEND),\n      DIAG_START_LEX           = DIAG_START_SERIALIZATION + static_cast<int>(DIAG_SIZE_SERIALIZATION),\n      DIAG_START_PARSE         = DIAG_START_LEX           + static_cast<int>(DIAG_SIZE_LEX),\n      DIAG_START_AST           = DIAG_START_PARSE         + static_cast<int>(DIAG_SIZE_PARSE),\n      DIAG_START_COMMENT       = DIAG_START_AST           + static_cast<int>(DIAG_SIZE_AST),\n      DIAG_START_CROSSTU       = DIAG_START_COMMENT       + static_cast<int>(DIAG_SIZE_COMMENT),\n      DIAG_START_SEMA          = DIAG_START_CROSSTU       + static_cast<int>(DIAG_SIZE_CROSSTU),\n      DIAG_START_ANALYSIS      = DIAG_START_SEMA          + static_cast<int>(DIAG_SIZE_SEMA),\n      DIAG_START_REFACTORING   = DIAG_START_ANALYSIS      + static_cast<int>(DIAG_SIZE_ANALYSIS),\n      DIAG_UPPER_LIMIT         = DIAG_START_REFACTORING   + static_cast<int>(DIAG_SIZE_REFACTORING)\n    };\n\n    class CustomDiagInfo;\n\n    /// All of the diagnostics that can be emitted by the frontend.\n    typedef unsigned kind;\n\n    // Get typedefs for common diagnostics.\n    enum {\n#define DIAG(ENUM, FLAGS, DEFAULT_MAPPING, DESC, GROUP, SFINAE, CATEGORY,      \\\n             NOWERROR, SHOWINSYSHEADER, SHOWINSYSMACRO, DEFFERABLE)            \\\n  ENUM,\n#define COMMONSTART\n#include \"clang/Basic/DiagnosticCommonKinds.inc\"\n      NUM_BUILTIN_COMMON_DIAGNOSTICS\n#undef DIAG\n    };\n\n    /// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs\n    /// to either Ignore (nothing), Remark (emit a remark), Warning\n    /// (emit a warning) or Error (emit as an error).  It allows clients to\n    /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).\n    enum class Severity {\n      // NOTE: 0 means \"uncomputed\".\n      Ignored = 1, ///< Do not present this diagnostic, ignore it.\n      Remark = 2,  ///< Present this diagnostic as a remark.\n      Warning = 3, ///< Present this diagnostic as a warning.\n      Error = 4,   ///< Present this diagnostic as an error.\n      Fatal = 5    ///< Present this diagnostic as a fatal error.\n    };\n\n    /// Flavors of diagnostics we can emit. Used to filter for a particular\n    /// kind of diagnostic (for instance, for -W/-R flags).\n    enum class Flavor {\n      WarningOrError, ///< A diagnostic that indicates a problem or potential\n                      ///< problem. Can be made fatal by -Werror.\n      Remark          ///< A diagnostic that indicates normal progress through\n                      ///< compilation.\n    };\n  }\n\nclass DiagnosticMapping {\n  unsigned Severity : 3;\n  unsigned IsUser : 1;\n  unsigned IsPragma : 1;\n  unsigned HasNoWarningAsError : 1;\n  unsigned HasNoErrorAsFatal : 1;\n  unsigned WasUpgradedFromWarning : 1;\n\npublic:\n  static DiagnosticMapping Make(diag::Severity Severity, bool IsUser,\n                                bool IsPragma) {\n    DiagnosticMapping Result;\n    Result.Severity = (unsigned)Severity;\n    Result.IsUser = IsUser;\n    Result.IsPragma = IsPragma;\n    Result.HasNoWarningAsError = 0;\n    Result.HasNoErrorAsFatal = 0;\n    Result.WasUpgradedFromWarning = 0;\n    return Result;\n  }\n\n  diag::Severity getSeverity() const { return (diag::Severity)Severity; }\n  void setSeverity(diag::Severity Value) { Severity = (unsigned)Value; }\n\n  bool isUser() const { return IsUser; }\n  bool isPragma() const { return IsPragma; }\n\n  bool isErrorOrFatal() const {\n    return getSeverity() == diag::Severity::Error ||\n           getSeverity() == diag::Severity::Fatal;\n  }\n\n  bool hasNoWarningAsError() const { return HasNoWarningAsError; }\n  void setNoWarningAsError(bool Value) { HasNoWarningAsError = Value; }\n\n  bool hasNoErrorAsFatal() const { return HasNoErrorAsFatal; }\n  void setNoErrorAsFatal(bool Value) { HasNoErrorAsFatal = Value; }\n\n  /// Whether this mapping attempted to map the diagnostic to a warning, but\n  /// was overruled because the diagnostic was already mapped to an error or\n  /// fatal error.\n  bool wasUpgradedFromWarning() const { return WasUpgradedFromWarning; }\n  void setUpgradedFromWarning(bool Value) { WasUpgradedFromWarning = Value; }\n\n  /// Serialize this mapping as a raw integer.\n  unsigned serialize() const {\n    return (IsUser << 7) | (IsPragma << 6) | (HasNoWarningAsError << 5) |\n           (HasNoErrorAsFatal << 4) | (WasUpgradedFromWarning << 3) | Severity;\n  }\n  /// Deserialize a mapping.\n  static DiagnosticMapping deserialize(unsigned Bits) {\n    DiagnosticMapping Result;\n    Result.IsUser = (Bits >> 7) & 1;\n    Result.IsPragma = (Bits >> 6) & 1;\n    Result.HasNoWarningAsError = (Bits >> 5) & 1;\n    Result.HasNoErrorAsFatal = (Bits >> 4) & 1;\n    Result.WasUpgradedFromWarning = (Bits >> 3) & 1;\n    Result.Severity = Bits & 0x7;\n    return Result;\n  }\n\n  bool operator==(DiagnosticMapping Other) const {\n    return serialize() == Other.serialize();\n  }\n};\n\n/// Used for handling and querying diagnostic IDs.\n///\n/// Can be used and shared by multiple Diagnostics for multiple translation units.\nclass DiagnosticIDs : public RefCountedBase<DiagnosticIDs> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored, Note, Remark, Warning, Error, Fatal\n  };\n\nprivate:\n  /// Information for uniquing and looking up custom diags.\n  std::unique_ptr<diag::CustomDiagInfo> CustomDiagInfo;\n\npublic:\n  DiagnosticIDs();\n  ~DiagnosticIDs();\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n\n  // FIXME: Replace this function with a create-only facilty like\n  // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of\n  // writing, nearly all callers of this function were invalid.\n  unsigned getCustomDiagID(Level L, StringRef FormatString);\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic classification and reporting interfaces.\n  //\n\n  /// Given a diagnostic ID, return a description of the issue.\n  StringRef getDescription(unsigned DiagID) const;\n\n  /// Return true if the unmapped diagnostic levelof the specified\n  /// diagnostic ID is a Warning or Extension.\n  ///\n  /// This only works on builtin diagnostics, not custom ones, and is not\n  /// legal to call on NOTEs.\n  static bool isBuiltinWarningOrExtension(unsigned DiagID);\n\n  /// Return true if the specified diagnostic is mapped to errors by\n  /// default.\n  static bool isDefaultMappingAsError(unsigned DiagID);\n\n  /// Get the default mapping for this diagnostic.\n  static DiagnosticMapping getDefaultMapping(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is a Note.\n  static bool isBuiltinNote(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort.\n  static bool isBuiltinExtensionDiag(unsigned DiagID) {\n    bool ignored;\n    return isBuiltinExtensionDiag(DiagID, ignored);\n  }\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort, and whether it is enabled by default.\n  ///\n  /// This also returns EnabledByDefault, which is set to indicate whether the\n  /// diagnostic is ignored by default (in which case -pedantic enables it) or\n  /// treated as a warning/error by default.\n  ///\n  static bool isBuiltinExtensionDiag(unsigned DiagID, bool &EnabledByDefault);\n\n  /// Given a group ID, returns the flag that toggles the group.\n  /// For example, for Group::DeprecatedDeclarations, returns\n  /// \"deprecated-declarations\".\n  static StringRef getWarningOptionForGroup(diag::Group);\n\n  /// Given a diagnostic group ID, return its documentation.\n  static StringRef getWarningOptionDocumentation(diag::Group GroupID);\n\n  /// Given a group ID, returns the flag that toggles the group.\n  /// For example, for \"deprecated-declarations\", returns\n  /// Group::DeprecatedDeclarations.\n  static std::optional<diag::Group> getGroupForWarningOption(StringRef);\n\n  /// Return the lowest-level group that contains the specified diagnostic.\n  static std::optional<diag::Group> getGroupForDiag(unsigned DiagID);\n\n  /// Return the lowest-level warning option that enables the specified\n  /// diagnostic.\n  ///\n  /// If there is no -Wfoo flag that controls the diagnostic, this returns null.\n  static StringRef getWarningOptionForDiag(unsigned DiagID);\n\n  /// Return the category number that a specified \\p DiagID belongs to,\n  /// or 0 if no category.\n  static unsigned getCategoryNumberForDiag(unsigned DiagID);\n\n  /// Return the number of diagnostic categories.\n  static unsigned getNumberOfCategories();\n\n  /// Given a category ID, return the name of the category.\n  static StringRef getCategoryNameFromID(unsigned CategoryID);\n\n  /// Return true if a given diagnostic falls into an ARC diagnostic\n  /// category.\n  static bool isARCDiagnostic(unsigned DiagID);\n\n  /// Enumeration describing how the emission of a diagnostic should\n  /// be treated when it occurs during C++ template argument deduction.\n  enum SFINAEResponse {\n    /// The diagnostic should not be reported, but it should cause\n    /// template argument deduction to fail.\n    ///\n    /// The vast majority of errors that occur during template argument\n    /// deduction fall into this category.\n    SFINAE_SubstitutionFailure,\n\n    /// The diagnostic should be suppressed entirely.\n    ///\n    /// Warnings generally fall into this category.\n    SFINAE_Suppress,\n\n    /// The diagnostic should be reported.\n    ///\n    /// The diagnostic should be reported. Various fatal errors (e.g.,\n    /// template instantiation depth exceeded) fall into this category.\n    SFINAE_Report,\n\n    /// The diagnostic is an access-control diagnostic, which will be\n    /// substitution failures in some contexts and reported in others.\n    SFINAE_AccessControl\n  };\n\n  /// Determines whether the given built-in diagnostic ID is\n  /// for an error that is suppressed if it occurs during C++ template\n  /// argument deduction.\n  ///\n  /// When an error is suppressed due to SFINAE, the template argument\n  /// deduction fails but no diagnostic is emitted. Certain classes of\n  /// errors, such as those errors that involve C++ access control,\n  /// are not SFINAE errors.\n  static SFINAEResponse getDiagnosticSFINAEResponse(unsigned DiagID);\n\n  /// Whether the diagnostic message can be deferred.\n  ///\n  /// For single source offloading languages, a diagnostic message occurred\n  /// in a device host function may be deferred until the function is sure\n  /// to be emitted.\n  static bool isDeferrable(unsigned DiagID);\n\n  /// Get the string of all diagnostic flags.\n  ///\n  /// \\returns A list of all diagnostics flags as they would be written in a\n  /// command line invocation including their `no-` variants. For example:\n  /// `{\"-Wempty-body\", \"-Wno-empty-body\", ...}`\n  static std::vector<std::string> getDiagnosticFlags();\n\n  /// Get the set of all diagnostic IDs in the group with the given name.\n  ///\n  /// \\param[out] Diags - On return, the diagnostics in the group.\n  /// \\returns \\c true if the given group is unknown, \\c false otherwise.\n  bool getDiagnosticsInGroup(diag::Flavor Flavor, StringRef Group,\n                             SmallVectorImpl<diag::kind> &Diags) const;\n\n  /// Get the set of all diagnostic IDs.\n  static void getAllDiagnostics(diag::Flavor Flavor,\n                                std::vector<diag::kind> &Diags);\n\n  /// Get the diagnostic option with the closest edit distance to the\n  /// given group name.\n  static StringRef getNearestOption(diag::Flavor Flavor, StringRef Group);\n\nprivate:\n  /// Classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticClient.\n  ///\n  /// The classification is based on the way the client configured the\n  /// DiagnosticsEngine object.\n  ///\n  /// \\param Loc The source location for which we are interested in finding out\n  /// the diagnostic state. Can be null in order to query the latest state.\n  DiagnosticIDs::Level\n  getDiagnosticLevel(unsigned DiagID, SourceLocation Loc,\n                     const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  diag::Severity\n  getDiagnosticSeverity(unsigned DiagID, SourceLocation Loc,\n                        const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns \\c true if the diagnostic was emitted, \\c false if it was\n  /// suppressed.\n  bool ProcessDiag(DiagnosticsEngine &Diag) const;\n\n  /// Used to emit a diagnostic that is finally fully formed,\n  /// ignoring suppression.\n  void EmitDiag(DiagnosticsEngine &Diag, Level DiagLevel) const;\n\n  /// Whether the diagnostic may leave the AST in a state where some\n  /// invariants can break.\n  bool isUnrecoverable(unsigned DiagID) const;\n\n  friend class DiagnosticsEngine;\n};\n\n}",
  "id": "BLOCK-CPP-16298",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/DiagnosticIDs.h",
  "source_line": 23,
  "validation_status": "validated"
}