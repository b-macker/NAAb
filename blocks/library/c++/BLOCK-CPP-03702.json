{
  "code": "#include <cstddef>\n#include <functional>\n#include <type_traits>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n\nusing namespace absl;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\nusing namespace that;\nusing namespace swap_internal;\nusing namespace where;\nusing namespace swap_internal;\nusing namespace type_traits_internal;\nusing namespace type_traits_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03702_execute() {\n    {\n//   memcpy(new_location, old_location, sizeof(T));\n// } else {\n//   new(new_location) T(std::move(*old_location));\n//   old_location->~T();\n// }\n//\n// Upstream documentation:\n//\n// https://clang.llvm.org/docs/LanguageExtensions.html#:~:text=__is_trivially_relocatable\n\n// If the compiler offers a builtin that tells us the answer, we can use that.\n// This covers all of the cases in the fallback below, plus types that opt in\n// using e.g. [[clang::trivial_abi]].\n//\n// Clang on Windows has the builtin, but it falsely claims types with a\n// user-provided destructor are trivial (http://b/275003464). So we opt out\n// there.\n//\n// TODO(b/275003464): remove the opt-out once the bug is fixed.\n//\n// According to https://github.com/abseil/abseil-cpp/issues/1479, this does not\n// work with NVCC either.\n#if ABSL_HAVE_BUILTIN(__is_trivially_relocatable) &&                 \\\n    !(defined(__clang__) && (defined(_WIN32) || defined(_WIN64))) && \\\n    !defined(__NVCC__)\ntemplate <class T>\nstruct is_trivially_relocatable\n    : std::integral_constant<bool, __is_trivially_relocatable(T)> {};\n#else\n// Otherwise we use a fallback that detects only those types we can feasibly\n// detect. Any time that has trivial move-construction and destruction\n// operations is by definition trivially relocatable.\ntemplate <class T>\nstruct is_trivially_relocatable\n    : absl::conjunction<absl::is_trivially_move_constructible<T>,\n                        absl::is_trivially_destructible<T>> {};\n#endif\n\n// absl::is_constant_evaluated()\n//\n// Detects whether the function call occurs within a constant-evaluated context.\n// Returns true if the evaluation of the call occurs within the evaluation of an\n// expression or conversion that is manifestly constant-evaluated; otherwise\n// returns false.\n//\n// This function is implemented in terms of `std::is_constant_evaluated` for\n// c++20 and up. For older c++ versions, the function is implemented in terms\n// of `__builtin_is_constant_evaluated` if available, otherwise the function\n// will fail to compile.\n//\n// Applications can inspect `ABSL_HAVE_CONSTANT_EVALUATED` at compile time\n// to check if this function is supported.\n//\n// Example:\n//\n// constexpr MyClass::MyClass(int param) {\n// #ifdef ABSL_HAVE_CONSTANT_EVALUATED\n//   if (!absl::is_constant_evaluated()) {\n//     ABSL_LOG(INFO) << \"MyClass(\" << param << \")\";\n//   }\n// #endif  // ABSL_HAVE_CONSTANT_EVALUATED\n// }\n//\n// Upstream documentation:\n//\n// http://en.cppreference.com/w/cpp/types/is_constant_evaluated\n// http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#:~:text=__builtin_is_constant_evaluated\n//\n#if defined(ABSL_HAVE_CONSTANT_EVALUATED)\nconstexpr bool is_constant_evaluated() noexcept {\n#ifdef __cpp_lib_is_constant_evaluated\n  return std::is_constant_evaluated();\n#elif ABSL_HAVE_BUILTIN(__builtin_is_constant_evaluated)\n  return __builtin_is_constant_evaluated();\n#endif\n}\n#endif  // ABSL_HAVE_CONSTANT_EVALUATED\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03702",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/meta/type_traits.h",
  "source_line": 483,
  "validation_status": "validated"
}