{
  "code": "#include \"absl/base/config.h\"\n#include \"absl/time/internal/cctz/include/cctz/civil_time_detail.h\"\n\nusing namespace absl;\nusing namespace time_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06534_execute() {\n    {\nnamespace cctz {\n\n// The term \"civil time\" refers to the legally recognized human-scale time\n// that is represented by the six fields YYYY-MM-DD hh:mm:ss. Modern-day civil\n// time follows the Gregorian Calendar and is a time-zone-independent concept.\n// A \"date\" is perhaps the most common example of a civil time (represented in\n// this library as cctz::civil_day). This library provides six classes and a\n// handful of functions that help with rounding, iterating, and arithmetic on\n// civil times while avoiding complications like daylight-saving time (DST).\n//\n// The following six classes form the core of this civil-time library:\n//\n//   * civil_second\n//   * civil_minute\n//   * civil_hour\n//   * civil_day\n//   * civil_month\n//   * civil_year\n//\n// Each class is a simple value type with the same interface for construction\n// and the same six accessors for each of the civil fields (year, month, day,\n// hour, minute, and second, aka YMDHMS). These classes differ only in their\n// alignment, which is indicated by the type name and specifies the field on\n// which arithmetic operates.\n//\n// Each class can be constructed by passing up to six optional integer\n// arguments representing the YMDHMS fields (in that order) to the\n// constructor. Omitted fields are assigned their minimum valid value. Hours,\n// minutes, and seconds will be set to 0, month and day will be set to 1, and\n// since there is no minimum valid year, it will be set to 1970. So, a\n// default-constructed civil-time object will have YMDHMS fields representing\n// \"1970-01-01 00:00:00\". Fields that are out-of-range are normalized (e.g.,\n// October 32 -> November 1) so that all civil-time objects represent valid\n// values.\n//\n// Each civil-time class is aligned to the civil-time field indicated in the\n// class's name after normalization. Alignment is performed by setting all the\n// inferior fields to their minimum valid value (as described above). The\n// following are examples of how each of the six types would align the fields\n// representing November 22, 2015 at 12:34:56 in the afternoon. (Note: the\n// string format used here is not important; it's just a shorthand way of\n// showing the six YMDHMS fields.)\n//\n//   civil_second  2015-11-22 12:34:56\n//   civil_minute  2015-11-22 12:34:00\n//   civil_hour    2015-11-22 12:00:00\n//   civil_day     2015-11-22 00:00:00\n//   civil_month   2015-11-01 00:00:00\n//   civil_year    2015-01-01 00:00:00\n//\n// Each civil-time type performs arithmetic on the field to which it is\n// aligned. This means that adding 1 to a civil_day increments the day field\n// (normalizing as necessary), and subtracting 7 from a civil_month operates\n// on the month field (normalizing as necessary). All arithmetic produces a\n// valid civil time. Difference requires two similarly aligned civil-time\n// objects and returns the scalar answer in units of the objects' alignment.\n// For example, the difference between two civil_hour objects will give an\n// answer in units of civil hours.\n//\n// In addition to the six civil-time types just described, there are\n// a handful of helper functions and algorithms for performing common\n// calculations. These are described below.\n//\n// Note: In C++14 and later, this library is usable in a constexpr context.\n//\n// CONSTRUCTION:\n//\n// Each of the civil-time types can be constructed in two ways: by directly\n// passing to the constructor up to six (optional) integers representing the\n// YMDHMS fields, or by copying the YMDHMS fields from a differently aligned\n// civil-time type.\n//\n//   civil_day default_value;  // 1970-01-01 00:00:00\n//\n//   civil_day a(2015, 2, 3);           // 2015-02-03 00:00:00\n//   civil_day b(2015, 2, 3, 4, 5, 6);  // 2015-02-03 00:00:00\n//   civil_day c(2015);                 // 2015-01-01 00:00:00\n//\n//   civil_second ss(2015, 2, 3, 4, 5, 6);  // 2015-02-03 04:05:06\n//   civil_minute mm(ss);                   // 2015-02-03 04:05:00\n//   civil_hour hh(mm);                     // 2015-02-03 04:00:00\n//   civil_day d(hh);                       // 2015-02-03 00:00:00\n//   civil_month m(d);                      // 2015-02-01 00:00:00\n//   civil_year y(m);                       // 2015-01-01 00:00:00\n//\n//   m = civil_month(y);     // 2015-01-01 00:00:00\n//   d = civil_day(m);       // 2015-01-01 00:00:00\n//   hh = civil_hour(d);     // 2015-01-01 00:00:00\n//   mm = civil_minute(hh);  // 2015-01-01 00:00:00\n//   ss = civil_second(mm);  // 2015-01-01 00:00:00\n//\n// ALIGNMENT CONVERSION:\n//\n// The alignment of a civil-time object cannot change, but the object may be\n// used to construct a new object with a different alignment. This is referred\n// to as \"realigning\". When realigning to a type with the same or more\n// precision (e.g., civil_day -> civil_second), the conversion may be\n// performed implicitly since no information is lost. However, if information\n// could be discarded (e.g., civil_second -> civil_day), the conversion must\n// be explicit at the call site.\n//\n//   void fun(const civil_day& day);\n//\n//   civil_second cs;\n//   fun(cs);  // Won't compile because data may be discarded\n//   fun(civil_day(cs));  // OK: explicit conversion\n//\n//   civil_day cd;\n//   fun(cd);  // OK: no conversion needed\n//\n//   civil_month cm;\n//   fun(cm);  // OK: implicit conversion to civil_day\n//\n// NORMALIZATION:\n//\n// Integer arguments passed to the constructor may be out-of-range, in which\n// case they are normalized to produce a valid civil-time object. This enables\n// natural arithmetic on constructor arguments without worrying about the\n// field's range. Normalization guarantees that there are no invalid\n// civil-time objects.\n//\n//   civil_day d(2016, 10, 32);  // Out-of-range day; normalized to 2016-11-01\n//\n// Note: If normalization is undesired, you can signal an error by comparing\n// the constructor arguments to the normalized values returned by the YMDHMS\n// properties.\n//\n// PROPERTIES:\n//\n// All civil-time types have accessors for all six of the civil-time fields:\n// year, month, day, hour, minute, and second. Recall that fields inferior to\n// the type's alignment will be set to their minimum valid value.\n//\n//   civil_day d(2015, 6, 28);\n//   // d.year() == 2015\n//   // d.month() == 6\n//   // d.day() == 28\n//   // d.hour() == 0\n//   // d.minute() == 0\n//   // d.second() == 0\n//\n// COMPARISON:\n//\n// Comparison always considers all six YMDHMS fields, regardless of the type's\n// alignment. Comparison between differently aligned civil-time types is\n// allowed.\n//\n//   civil_day feb_3(2015, 2, 3);  // 2015-02-03 00:00:00\n//   civil_day mar_4(2015, 3, 4);  // 2015-03-04 00:00:00\n//   // feb_3 < mar_4\n//   // civil_year(feb_3) == civil_year(mar_4)\n//\n//   civil_second feb_3_noon(2015, 2, 3, 12, 0, 0);  // 2015-02-03 12:00:00\n//   // feb_3 < feb_3_noon\n//   // feb_3 == civil_day(feb_3_noon)\n//\n//   // Iterates all the days of February 2015.\n//   for (civil_day d(2015, 2, 1); d < civil_month(2015, 3); ++d) {\n//     // ...\n//   }\n//\n// STREAMING:\n//\n// Each civil-time type may be sent to an output stream using operator<<().\n// The output format follows the pattern \"YYYY-MM-DDThh:mm:ss\" where fields\n// inferior to the type's alignment are omitted.\n//\n//   civil_second cs(2015, 2, 3, 4, 5, 6);\n//   std::cout << cs << \"\\n\";  // Outputs: 2015-02-03T04:05:06\n//\n//   civil_day cd(cs);\n//   std::cout << cd << \"\\n\";  // Outputs: 2015-02-03\n//\n//   civil_year cy(cs);\n//   std::cout << cy << \"\\n\";  // Outputs: 2015\n//\n// ARITHMETIC:\n//\n// Civil-time types support natural arithmetic operators such as addition,\n// subtraction, and difference. Arithmetic operates on the civil-time field\n// indicated in the type's name. Difference requires arguments with the same\n// alignment and returns the answer in units of the alignment.\n//\n//   civil_day a(2015, 2, 3);\n//   ++a;                         // 2015-02-04 00:00:00\n//   --a;                         // 2015-02-03 00:00:00\n//   civil_day b = a + 1;         // 2015-02-04 00:00:00\n//   civil_day c = 1 + b;         // 2015-02-05 00:00:00\n//   int n = c - a;               // n = 2 (civil days)\n//   int m = c - civil_month(c);  // Won't compile: different types.\n//\n// EXAMPLE: Adding a month to January 31.\n//\n// One of the classic questions that arises when considering a civil-time\n// library (or a date library or a date/time library) is this: \"What happens\n// when you add a month to January 31?\" This is an interesting question\n// because there could be a number of possible answers:\n//\n//   1. March 3 (or 2 if a leap year). This may make sense if the operation\n//      wants the equivalent of February 31.\n//   2. February 28 (or 29 if a leap year). This may make sense if the operation\n//      wants the last day of January to go to the last day of February.\n//   3. Error. The caller may get some error, an exception, an invalid date\n//      object, or maybe false is returned. This may make sense because there is\n//      no single unambiguously correct answer to the question.\n//\n// Practically speaking, any answer that is not what the programmer intended\n// is the wrong answer.\n//\n// This civil-time library avoids the problem by making it impossible to ask\n// ambiguous questions. All civil-time objects are aligned to a particular\n// civil-field boundary (such as aligned to a year, month, day, hour, minute,\n// or second), and arithmetic operates on the field to which the object is\n// aligned. This means that in order to \"add a month\" the object must first be\n// aligned to a month boundary, which is equivalent to the first day of that\n// month.\n//\n// Of course, there are ways to compute an answer the question at hand using\n// this civil-time library, but they require the programmer to be explicit\n// about the answer they expect. To illustrate, let's see how to compute all\n// three of the above possible answers to the question of \"Jan 31 plus 1\n// month\":\n//\n//   const civil_day d(2015, 1, 31);\n//\n//   // Answer 1:\n//   // Add 1 to the month field in the constructor, and rely on normalization.\n//   const auto ans_normalized = civil_day(d.year(), d.month() + 1, d.day());\n//   // ans_normalized == 2015-03-03 (aka Feb 31)\n//\n//   // Answer 2:\n//   // Add 1 to month field, capping to the end of next month.\n//   const auto next_month = civil_month(d) + 1;\n//   const auto last_day_of_next_month = civil_day(next_month + 1) - 1;\n//   const auto ans_capped = std::min(ans_normalized, last_day_of_next_month);\n//   // ans_capped == 2015-02-28\n//\n//   // Answer 3:\n//   // Signal an error if the normalized answer is not in next month.\n//   if (civil_month(ans_normalized) != next_month) {\n//     // error, month overflow\n//   }\n//\nusing civil_year = detail::civil_year;\nusing civil_month = detail::civil_month;\nusing civil_day = detail::civil_day;\nusing civil_hour = detail::civil_hour;\nusing civil_minute = detail::civil_minute;\nusing civil_second = detail::civil_second;\n\n// An enum class with members monday, tuesday, wednesday, thursday, friday,\n// saturday, and sunday. These enum values may be sent to an output stream\n// using operator<<(). The result is the full weekday name in English with a\n// leading capital letter.\n//\n//   weekday wd = weekday::thursday;\n//   std::cout << wd << \"\\n\";  // Outputs: Thursday\n//\nusing detail::weekday;\n\n// Returns the weekday for the given civil-time value.\n//\n//   civil_day a(2015, 8, 13);\n//   weekday wd = get_weekday(a);  // wd == weekday::thursday\n//\nusing detail::get_weekday;\n\n// Returns the civil_day that strictly follows or precedes the given\n// civil_day, and that falls on the given weekday.\n//\n// For example, given:\n//\n//     August 2015\n// Su Mo Tu We Th Fr Sa\n//                    1\n//  2  3  4  5  6  7  8\n//  9 10 11 12 13 14 15\n// 16 17 18 19 20 21 22\n// 23 24 25 26 27 28 29\n// 30 31\n//\n//   civil_day a(2015, 8, 13);  // get_weekday(a) == weekday::thursday\n//   civil_day b = next_weekday(a, weekday::thursday);  // b = 2015-08-20\n//   civil_day c = prev_weekday(a, weekday::thursday);  // c = 2015-08-06\n//\n//   civil_day d = ...\n//   // Gets the following Thursday if d is not already Thursday\n//   civil_day thurs1 = next_weekday(d - 1, weekday::thursday);\n//   // Gets the previous Thursday if d is not already Thursday\n//   civil_day thurs2 = prev_weekday(d + 1, weekday::thursday);\n//\nusing detail::next_weekday;\nusing detail::prev_weekday;\n\n// Returns the day-of-year for the given civil-time value.\n//\n//   civil_day a(2015, 1, 1);\n//   int yd_jan_1 = get_yearday(a);   // yd_jan_1 = 1\n//   civil_day b(2015, 12, 31);\n//   int yd_dec_31 = get_yearday(b);  // yd_dec_31 = 365\n//\nusing detail::get_yearday;\n\n}  // namespace cctz\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06534",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/civil_time.h",
  "source_line": 23,
  "validation_status": "validated"
}