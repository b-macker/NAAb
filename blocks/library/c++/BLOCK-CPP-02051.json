{
  "code": "{\nABSL_NAMESPACE_BEGIN\nnamespace substitute_internal {\n\nvoid SubstituteAndAppendArray(\n    absl::Nonnull<std::string*> output, absl::string_view format,\n    absl::Nullable<const absl::string_view*> args_array, size_t num_args) {\n  // Determine total size needed.\n  size_t size = 0;\n  for (size_t i = 0; i < format.size(); i++) {\n    if (format[i] == '$') {\n      if (i + 1 >= format.size()) {\n#ifndef NDEBUG\n        ABSL_RAW_LOG(FATAL,\n                     \"Invalid absl::Substitute() format string: \\\"%s\\\".\",\n                     absl::CEscape(format).c_str());\n#endif\n        return;\n      } else if (absl::ascii_isdigit(\n                     static_cast<unsigned char>(format[i + 1]))) {\n        int index = format[i + 1] - '0';\n        if (static_cast<size_t>(index) >= num_args) {\n#ifndef NDEBUG\n          ABSL_RAW_LOG(\n              FATAL,\n              \"Invalid absl::Substitute() format string: asked for \\\"$\"\n              \"%d\\\", but only %d args were given.  Full format string was: \"\n              \"\\\"%s\\\".\",\n              index, static_cast<int>(num_args), absl::CEscape(format).c_str());\n#endif\n          return;\n        }\n        size += args_array[index].size();\n        ++i;  // Skip next char.\n      } else if (format[i + 1] == '$') {\n        ++size;\n        ++i;  // Skip next char.\n      } else {\n#ifndef NDEBUG\n        ABSL_RAW_LOG(FATAL,\n                     \"Invalid absl::Substitute() format string: \\\"%s\\\".\",\n                     absl::CEscape(format).c_str());\n#endif\n        return;\n      }\n    } else {\n      ++size;\n    }\n  }\n\n  if (size == 0) return;\n\n  // Build the string.\n  size_t original_size = output->size();\n  strings_internal::STLStringResizeUninitializedAmortized(output,\n                                                          original_size + size);\n  char* target = &(*output)[original_size];\n  for (size_t i = 0; i < format.size(); i++) {\n    if (format[i] == '$') {\n      if (absl::ascii_isdigit(static_cast<unsigned char>(format[i + 1]))) {\n        const absl::string_view src = args_array[format[i + 1] - '0'];\n        target = std::copy(src.begin(), src.end(), target);\n        ++i;  // Skip next char.\n      } else if (format[i + 1] == '$') {\n        *target++ = '$';\n        ++i;  // Skip next char.\n      }\n    } else {\n      *target++ = format[i];\n    }\n  }\n\n  assert(target == output->data() + output->size());\n}\n\nArg::Arg(absl::Nullable<const void*> value) {\n  static_assert(sizeof(scratch_) >= sizeof(value) * 2 + 2,\n                \"fix sizeof(scratch_)\");\n  if (value == nullptr) {\n    piece_ = \"NULL\";\n  } else {\n    char* ptr = scratch_ + sizeof(scratch_);\n    uintptr_t num = reinterpret_cast<uintptr_t>(value);\n    do {\n      *--ptr = absl::numbers_internal::kHexChar[num & 0xf];\n      num >>= 4;\n    } while (num != 0);\n    *--ptr = 'x';\n    *--ptr = '0';\n    piece_ = absl::string_view(\n        ptr, static_cast<size_t>(scratch_ + sizeof(scratch_) - ptr));\n  }\n}\n\n// TODO(jorg): Don't duplicate so much code between here and str_cat.cc\nArg::Arg(Hex hex) {\n  char* const end = &scratch_[numbers_internal::kFastToBufferSize];\n  char* writer = end;\n  uint64_t value = hex.value;\n  do {\n    *--writer = absl::numbers_internal::kHexChar[value & 0xF];\n    value >>= 4;\n  } while (value != 0);\n\n  char* beg;\n  if (end - writer < hex.width) {\n    beg = end - hex.width;\n    std::fill_n(beg, writer - beg, hex.fill);\n  } else {\n    beg = writer;\n  }\n\n  piece_ = absl::string_view(beg, static_cast<size_t>(end - beg));\n}\n\n// TODO(jorg): Don't duplicate so much code between here and str_cat.cc\nArg::Arg(Dec dec) {\n  assert(dec.width <= numbers_internal::kFastToBufferSize);\n  char* const end = &scratch_[numbers_internal::kFastToBufferSize];\n  char* const minfill = end - dec.width;\n  char* writer = end;\n  uint64_t value = dec.value;\n  bool neg = dec.neg;\n  while (value > 9) {\n    *--writer = '0' + (value % 10);\n    value /= 10;\n  }\n  *--writer = '0' + static_cast<char>(value);\n  if (neg) *--writer = '-';\n\n  ptrdiff_t fillers = writer - minfill;\n  if (fillers > 0) {\n    // Tricky: if the fill character is ' ', then it's <fill><+/-><digits>\n    // But...: if the fill character is '0', then it's <+/-><fill><digits>\n    bool add_sign_again = false;\n    if (neg && dec.fill == '0') {  // If filling with '0',\n      ++writer;                    // ignore the sign we just added\n      add_sign_again = true;       // and re-add the sign later.\n    }\n    writer -= fillers;\n    std::fill_n(writer, fillers, dec.fill);\n    if (add_sign_again) *--writer = '-';\n  }\n\n  piece_ = absl::string_view(writer, static_cast<size_t>(end - writer));\n}\n\n}  // namespace substitute_internal\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-02051",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/substitute.cc",
  "source_line": 33,
  "validation_status": "validated"
}