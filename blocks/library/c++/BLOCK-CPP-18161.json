{
  "code": "{\n    /// If ``true``, put space betwee control statement keywords\n    /// (for/if/while...) and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    if (...) {}                     vs.    if(...) {}\n    /// \\endcode\n    bool AfterControlStatements;\n    /// If ``true``, put space between foreach macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    FOREACH (...)                   vs.    FOREACH(...)\n    ///      <loop-body>                            <loop-body>\n    /// \\endcode\n    bool AfterForeachMacros;\n    /// If ``true``, put a space between function declaration name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f ();                      vs.    void f();\n    /// \\endcode\n    bool AfterFunctionDeclarationName;\n    /// If ``true``, put a space between function definition name and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f () {}                    vs.    void f() {}\n    /// \\endcode\n    bool AfterFunctionDefinitionName;\n    /// If ``true``, put space between if macros and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    IF (...)                        vs.    IF(...)\n    ///      <conditional-body>                     <conditional-body>\n    /// \\endcode\n    bool AfterIfMacros;\n    /// If ``true``, put a space between operator overloading and opening\n    /// parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    void operator++ (int a);        vs.    void operator++(int a);\n    ///    object.operator++ (10);                object.operator++(10);\n    /// \\endcode\n    bool AfterOverloadedOperator;\n    /// If ``true``, put space between requires keyword in a requires clause and\n    /// opening parentheses, if there is one.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    requires (A<T> && B<T>)                requires(A<T> && B<T>)\n    ///    ...                                    ...\n    /// \\endcode\n    bool AfterRequiresInClause;\n    /// If ``true``, put space between requires keyword in a requires expression\n    /// and opening parentheses.\n    /// \\code\n    ///    true:                                  false:\n    ///    template<typename T>            vs.    template<typename T>\n    ///    concept C = requires (T t) {           concept C = requires(T t) {\n    ///                  ...                                    ...\n    ///                }                                      }\n    /// \\endcode\n    bool AfterRequiresInExpression;\n    /// If ``true``, put a space before opening parentheses only if the\n    /// parentheses are not empty.\n    /// \\code\n    ///    true:                                  false:\n    ///    void f (int a);                 vs.    void f();\n    ///    f (a);                                 f();\n    /// \\endcode\n    bool BeforeNonEmptyParentheses;\n\n    SpaceBeforeParensCustom()\n        : AfterControlStatements(false), AfterForeachMacros(false),\n          AfterFunctionDeclarationName(false),\n          AfterFunctionDefinitionName(false), AfterIfMacros(false),\n          AfterOverloadedOperator(false), AfterRequiresInClause(false),\n          AfterRequiresInExpression(false), BeforeNonEmptyParentheses(false) {}\n\n    bool operator==(const SpaceBeforeParensCustom &Other) const {\n      return AfterControlStatements == Other.AfterControlStatements &&\n             AfterForeachMacros == Other.AfterForeachMacros &&\n             AfterFunctionDeclarationName ==\n                 Other.AfterFunctionDeclarationName &&\n             AfterFunctionDefinitionName == Other.AfterFunctionDefinitionName &&\n             AfterIfMacros == Other.AfterIfMacros &&\n             AfterOverloadedOperator == Other.AfterOverloadedOperator &&\n             AfterRequiresInClause == Other.AfterRequiresInClause &&\n             AfterRequiresInExpression == Other.AfterRequiresInExpression &&\n             BeforeNonEmptyParentheses == Other.BeforeNonEmptyParentheses;\n    }\n  }",
  "id": "BLOCK-CPP-18161",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Format/Format.h",
  "source_line": 4017,
  "validation_status": "validated"
}