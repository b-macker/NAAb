{
  "code": "{\n\nclass FileEntry;\nclass LangOptions;\nclass SourceManager;\nclass TextDiagnosticBuffer;\n\n/// VerifyDiagnosticConsumer - Create a diagnostic client which will use\n/// markers in the input source to check that all the emitted diagnostics match\n/// those expected.\n///\n/// INVOKING THE DIAGNOSTIC CHECKER:\n///\n/// VerifyDiagnosticConsumer is typically invoked via the \"-verify\" option to\n/// \"clang -cc1\".  \"-verify\" is equivalent to \"-verify=expected\", so all\n/// diagnostics are typically specified with the prefix \"expected\".  For\n/// example:\n///\n/// \\code\n///   int A = B; // expected-error {{use of undeclared identifier 'B'}}\n/// \\endcode\n///\n/// Custom prefixes can be specified as a comma-separated sequence.  Each\n/// prefix must start with a letter and contain only alphanumeric characters,\n/// hyphens, and underscores.  For example, given just \"-verify=foo,bar\",\n/// the above diagnostic would be ignored, but the following diagnostics would\n/// be recognized:\n///\n/// \\code\n///   int A = B; // foo-error {{use of undeclared identifier 'B'}}\n///   int C = D; // bar-error {{use of undeclared identifier 'D'}}\n/// \\endcode\n///\n/// Multiple occurrences accumulate prefixes.  For example,\n/// \"-verify -verify=foo,bar -verify=baz\" is equivalent to\n/// \"-verify=expected,foo,bar,baz\".\n///\n/// SPECIFYING DIAGNOSTICS:\n///\n/// Indicating that a line expects an error or a warning is simple. Put a\n/// comment on the line that has the diagnostic, use:\n///\n/// \\code\n///   expected-{error,warning,remark,note}\n/// \\endcode\n///\n/// to tag if it's an expected error, remark or warning, and place the expected\n/// text between {{ and }} markers. The full text doesn't have to be included,\n/// only enough to ensure that the correct diagnostic was emitted.\n///\n/// Here's an example:\n///\n/// \\code\n///   int A = B; // expected-error {{use of undeclared identifier 'B'}}\n/// \\endcode\n///\n/// You can place as many diagnostics on one line as you wish. To make the code\n/// more readable, you can use slash-newline to separate out the diagnostics.\n///\n/// Alternatively, it is possible to specify the line on which the diagnostic\n/// should appear by appending \"@<line>\" to \"expected-<type>\", for example:\n///\n/// \\code\n///   #warning some text\n///   // expected-warning@10 {{some text}}\n/// \\endcode\n///\n/// The line number may be absolute (as above), or relative to the current\n/// line by prefixing the number with either '+' or '-'.\n///\n/// If the diagnostic is generated in a separate file, for example in a shared\n/// header file, it may be beneficial to be able to declare the file in which\n/// the diagnostic will appear, rather than placing the expected-* directive in\n/// the actual file itself.  This can be done using the following syntax:\n///\n/// \\code\n///   // expected-error@path/include.h:15 {{error message}}\n/// \\endcode\n///\n/// The path can be absolute or relative and the same search paths will be used\n/// as for #include directives.  The line number in an external file may be\n/// substituted with '*' meaning that any line number will match (useful where\n/// the included file is, for example, a system header where the actual line\n/// number may change and is not critical).\n///\n/// As an alternative to specifying a fixed line number, the location of a\n/// diagnostic can instead be indicated by a marker of the form \"#<marker>\".\n/// Markers are specified by including them in a comment, and then referenced\n/// by appending the marker to the diagnostic with \"@#<marker>\":\n///\n/// \\code\n///   #warning some text  // #1\n///   // expected-warning@#1 {{some text}}\n/// \\endcode\n///\n/// The name of a marker used in a directive must be unique within the\n/// compilation.\n///\n/// The simple syntax above allows each specification to match exactly one\n/// error.  You can use the extended syntax to customize this. The extended\n/// syntax is \"expected-<type> <n> {{diag text}}\", where \\<type> is one of\n/// \"error\", \"warning\" or \"note\", and \\<n> is a positive integer. This allows\n/// the diagnostic to appear as many times as specified. Example:\n///\n/// \\code\n///   void f(); // expected-note 2 {{previous declaration is here}}\n/// \\endcode\n///\n/// Where the diagnostic is expected to occur a minimum number of times, this\n/// can be specified by appending a '+' to the number. Example:\n///\n/// \\code\n///   void f(); // expected-note 0+ {{previous declaration is here}}\n///   void g(); // expected-note 1+ {{previous declaration is here}}\n/// \\endcode\n///\n/// In the first example, the diagnostic becomes optional, i.e. it will be\n/// swallowed if it occurs, but will not generate an error if it does not\n/// occur.  In the second example, the diagnostic must occur at least once.\n/// As a short-hand, \"one or more\" can be specified simply by '+'. Example:\n///\n/// \\code\n///   void g(); // expected-note + {{previous declaration is here}}\n/// \\endcode\n///\n/// A range can also be specified by \"<n>-<m>\".  Example:\n///\n/// \\code\n///   void f(); // expected-note 0-1 {{previous declaration is here}}\n/// \\endcode\n///\n/// In this example, the diagnostic may appear only once, if at all.\n///\n/// Regex matching mode may be selected by appending '-re' to type and\n/// including regexes wrapped in double curly braces in the directive, such as:\n///\n/// \\code\n///   expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}\n/// \\endcode\n///\n/// Examples matching error: \"variable has incomplete type 'struct s'\"\n///\n/// \\code\n///   // expected-error {{variable has incomplete type 'struct s'}}\n///   // expected-error {{variable has incomplete type}}\n///\n///   // expected-error-re {{variable has type 'struct {{.}}'}}\n///   // expected-error-re {{variable has type 'struct {{.*}}'}}\n///   // expected-error-re {{variable has type 'struct {{(.*)}}'}}\n///   // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}\n/// \\endcode\n///\n/// VerifyDiagnosticConsumer expects at least one expected-* directive to\n/// be found inside the source code.  If no diagnostics are expected the\n/// following directive can be used to indicate this:\n///\n/// \\code\n///   // expected-no-diagnostics\n/// \\endcode\n///\nclass VerifyDiagnosticConsumer: public DiagnosticConsumer,\n                                public CommentHandler {\npublic:\n  /// Directive - Abstract class representing a parsed verify directive.\n  ///\n  class Directive {\n  public:\n    static std::unique_ptr<Directive>\n    create(bool RegexKind, SourceLocation DirectiveLoc,\n           SourceLocation DiagnosticLoc, bool MatchAnyFileAndLine,\n           bool MatchAnyLine, StringRef Text, unsigned Min, unsigned Max);\n\n  public:\n    /// Constant representing n or more matches.\n    static const unsigned MaxCount = std::numeric_limits<unsigned>::max();\n\n    SourceLocation DirectiveLoc;\n    SourceLocation DiagnosticLoc;\n    const std::string Text;\n    unsigned Min, Max;\n    bool MatchAnyLine;\n    bool MatchAnyFileAndLine; // `MatchAnyFileAndLine` implies `MatchAnyLine`.\n\n    Directive(const Directive &) = delete;\n    Directive &operator=(const Directive &) = delete;\n    virtual ~Directive() = default;\n\n    // Returns true if directive text is valid.\n    // Otherwise returns false and populates E.\n    virtual bool isValid(std::string &Error) = 0;\n\n    // Returns true on match.\n    virtual bool match(StringRef S) = 0;\n\n  protected:\n    Directive(SourceLocation DirectiveLoc, SourceLocation DiagnosticLoc,\n              bool MatchAnyFileAndLine, bool MatchAnyLine, StringRef Text,\n              unsigned Min, unsigned Max)\n        : DirectiveLoc(DirectiveLoc), DiagnosticLoc(DiagnosticLoc), Text(Text),\n          Min(Min), Max(Max), MatchAnyLine(MatchAnyLine || MatchAnyFileAndLine),\n          MatchAnyFileAndLine(MatchAnyFileAndLine) {\n      assert(!DirectiveLoc.isInvalid() && \"DirectiveLoc is invalid!\");\n      assert((!DiagnosticLoc.isInvalid() || MatchAnyLine) &&\n             \"DiagnosticLoc is invalid!\");\n    }\n  };\n\n  using DirectiveList = std::vector<std::unique_ptr<Directive>>;\n\n  /// ExpectedData - owns directive objects and deletes on destructor.\n  struct ExpectedData {\n    DirectiveList Errors;\n    DirectiveList Warnings;\n    DirectiveList Remarks;\n    DirectiveList Notes;\n\n    void Reset() {\n      Errors.clear();\n      Warnings.clear();\n      Remarks.clear();\n      Notes.clear();\n    }\n  };\n\n  enum DirectiveStatus {\n    HasNoDirectives,\n    HasNoDirectivesReported,\n    HasExpectedNoDiagnostics,\n    HasOtherExpectedDirectives\n  };\n\n  class MarkerTracker;\n\nprivate:\n  DiagnosticsEngine &Diags;\n  DiagnosticConsumer *PrimaryClient;\n  std::unique_ptr<DiagnosticConsumer> PrimaryClientOwner;\n  std::unique_ptr<TextDiagnosticBuffer> Buffer;\n  std::unique_ptr<MarkerTracker> Markers;\n  const Preprocessor *CurrentPreprocessor = nullptr;\n  const LangOptions *LangOpts = nullptr;\n  SourceManager *SrcManager = nullptr;\n  unsigned ActiveSourceFiles = 0;\n  DirectiveStatus Status;\n  ExpectedData ED;\n\n  void CheckDiagnostics();\n\n  void setSourceManager(SourceManager &SM) {\n    assert((!SrcManager || SrcManager == &SM) && \"SourceManager changed!\");\n    SrcManager = &SM;\n  }\n\n  // These facilities are used for validation in debug builds.\n  class UnparsedFileStatus {\n    llvm::PointerIntPair<const FileEntry *, 1, bool> Data;\n\n  public:\n    UnparsedFileStatus(const FileEntry *File, bool FoundDirectives)\n        : Data(File, FoundDirectives) {}\n\n    const FileEntry *getFile() const { return Data.getPointer(); }\n    bool foundDirectives() const { return Data.getInt(); }\n  };\n\n  using ParsedFilesMap = llvm::DenseMap<FileID, const FileEntry *>;\n  using UnparsedFilesMap = llvm::DenseMap<FileID, UnparsedFileStatus>;\n\n  ParsedFilesMap ParsedFiles;\n  UnparsedFilesMap UnparsedFiles;\n\npublic:\n  /// Create a new verifying diagnostic client, which will issue errors to\n  /// the currently-attached diagnostic client when a diagnostic does not match\n  /// what is expected (as indicated in the source file).\n  VerifyDiagnosticConsumer(DiagnosticsEngine &Diags);\n  ~VerifyDiagnosticConsumer() override;\n\n  void BeginSourceFile(const LangOptions &LangOpts,\n                       const Preprocessor *PP) override;\n\n  void EndSourceFile() override;\n\n  enum ParsedStatus {\n    /// File has been processed via HandleComment.\n    IsParsed,\n\n    /// File has diagnostics and may have directives.\n    IsUnparsed,\n\n    /// File has diagnostics but guaranteed no directives.\n    IsUnparsedNoDirectives\n  };\n\n  /// Update lists of parsed and unparsed files.\n  void UpdateParsedFileStatus(SourceManager &SM, FileID FID, ParsedStatus PS);\n\n  bool HandleComment(Preprocessor &PP, SourceRange Comment) override;\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override;\n};\n\n}",
  "id": "BLOCK-CPP-18454",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h",
  "source_line": 26,
  "validation_status": "validated"
}