{
  "code": "{\n public:\n  explicit CONSTEXPR_M civil_time(year_t y, diff_t m = 1, diff_t d = 1,\n                                  diff_t hh = 0, diff_t mm = 0,\n                                  diff_t ss = 0) noexcept\n      : civil_time(impl::n_sec(y, m, d, hh, mm, ss)) {}\n\n  CONSTEXPR_M civil_time() noexcept : f_{1970, 1, 1, 0, 0, 0} {}\n  civil_time(const civil_time&) = default;\n  civil_time& operator=(const civil_time&) = default;\n\n  // Conversion between civil times of different alignment. Conversion to\n  // a more precise alignment is allowed implicitly (e.g., day -> hour),\n  // but conversion where information is discarded must be explicit\n  // (e.g., second -> minute).\n  template <typename U, typename S>\n  using preserves_data =\n      typename std::enable_if<std::is_base_of<U, S>::value>::type;\n  template <typename U>\n  CONSTEXPR_M civil_time(const civil_time<U>& ct,\n                         preserves_data<T, U>* = nullptr) noexcept\n      : civil_time(ct.f_) {}\n  template <typename U>\n  explicit CONSTEXPR_M civil_time(const civil_time<U>& ct,\n                                  preserves_data<U, T>* = nullptr) noexcept\n      : civil_time(ct.f_) {}\n\n  // Factories for the maximum/minimum representable civil_time.\n  static CONSTEXPR_F auto(max)() -> civil_time {\n    const auto max_year = (std::numeric_limits<std::int_least64_t>::max)();\n    return civil_time(max_year, 12, 31, 23, 59, 59);\n  }\n  static CONSTEXPR_F auto(min)() -> civil_time {\n    const auto min_year = (std::numeric_limits<std::int_least64_t>::min)();\n    return civil_time(min_year, 1, 1, 0, 0, 0);\n  }\n\n  // Field accessors.  Note: All but year() return an int.\n  CONSTEXPR_M year_t year() const noexcept { return f_.y; }\n  CONSTEXPR_M int month() const noexcept { return f_.m; }\n  CONSTEXPR_M int day() const noexcept { return f_.d; }\n  CONSTEXPR_M int hour() const noexcept { return f_.hh; }\n  CONSTEXPR_M int minute() const noexcept { return f_.mm; }\n  CONSTEXPR_M int second() const noexcept { return f_.ss; }\n\n  // Assigning arithmetic.\n  CONSTEXPR_M civil_time& operator+=(diff_t n) noexcept {\n    return *this = *this + n;\n  }\n  CONSTEXPR_M civil_time& operator-=(diff_t n) noexcept {\n    return *this = *this - n;\n  }\n  CONSTEXPR_M civil_time& operator++() noexcept { return *this += 1; }\n  CONSTEXPR_M civil_time operator++(int) noexcept {\n    const civil_time a = *this;\n    ++*this;\n    return a;\n  }\n  CONSTEXPR_M civil_time& operator--() noexcept { return *this -= 1; }\n  CONSTEXPR_M civil_time operator--(int) noexcept {\n    const civil_time a = *this;\n    --*this;\n    return a;\n  }\n\n  // Binary arithmetic operators.\n  friend CONSTEXPR_F civil_time operator+(civil_time a, diff_t n) noexcept {\n    return civil_time(step(T{}, a.f_, n));\n  }\n  friend CONSTEXPR_F civil_time operator+(diff_t n, civil_time a) noexcept {\n    return a + n;\n  }\n  friend CONSTEXPR_F civil_time operator-(civil_time a, diff_t n) noexcept {\n    return n != (std::numeric_limits<diff_t>::min)()\n               ? civil_time(step(T{}, a.f_, -n))\n               : civil_time(step(T{}, step(T{}, a.f_, -(n + 1)), 1));\n  }\n  friend CONSTEXPR_F diff_t operator-(civil_time lhs, civil_time rhs) noexcept {\n    return difference(T{}, lhs.f_, rhs.f_);\n  }\n\n  template <typename H>\n  friend H AbslHashValue(H h, civil_time a) {\n    return impl::AbslHashValueImpl(T{}, std::move(h), a.f_);\n  }\n\n private:\n  // All instantiations of this template are allowed to call the following\n  // private constructor and access the private fields member.\n  template <typename U>\n  friend class civil_time;\n\n  // The designated constructor that all others eventually call.\n  explicit CONSTEXPR_M civil_time(fields f) noexcept : f_(align(T{}, f)) {}\n\n  fields f_;\n}",
  "id": "BLOCK-CPP-06588",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/time/internal/cctz/include/cctz/civil_time_detail.h",
  "source_line": 375,
  "validation_status": "validated"
}