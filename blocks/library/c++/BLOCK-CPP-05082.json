{
  "code": "#include <algorithm>\n#include <cstddef>\n#include <cstring>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/macros.h\"\n#include \"absl/container/internal/compressed_tuple.h\"\n#include \"absl/memory/memory.h\"\n#include \"absl/meta/type_traits.h\"\n#include \"absl/types/span.h\"\n\nusing namespace absl;\nusing namespace inlined_vector_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05082_execute() {\n    {\n    // Assumption check: it doesn't make sense to memcpy inlined elements unless\n    // we know the allocator doesn't do anything fancy, and one of the following\n    // holds:\n    //\n    //  *  The elements are trivially relocatable.\n    //\n    //  *  It's possible to trivially assign the elements and then destroy the\n    //     source.\n    //\n    //  *  It's possible to trivially copy construct/assign the elements.\n    //\n    {\n      using V = ValueType<A>;\n      ABSL_HARDENING_ASSERT(\n          other_storage.GetIsAllocated() ||\n          (std::is_same<A, std::allocator<V>>::value &&\n           (\n               // First case above\n               absl::is_trivially_relocatable<V>::value ||\n               // Second case above\n               (absl::is_trivially_move_assignable<V>::value &&\n                absl::is_trivially_destructible<V>::value) ||\n               // Third case above\n               (absl::is_trivially_copy_constructible<V>::value ||\n                absl::is_trivially_copy_assignable<V>::value))));\n    }\n\n    GetSizeAndIsAllocated() = other_storage.GetSizeAndIsAllocated();\n    data_ = other_storage.data_;\n  }\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05082",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/inlined_vector.h",
  "source_line": 503,
  "validation_status": "validated"
}