{
  "code": "#include <tuple>\n#include <type_traits>\n#include <utility>\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/internal/throw_delegate.h\"\n#include \"absl/container/internal/container_memory.h\"\n#include \"absl/container/internal/raw_hash_set.h\"  // IWYU pragma: export\n\nusing namespace absl;\nusing namespace container_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-05136_execute() {\n    {\n\ntemplate <class Policy, class Hash, class Eq, class Alloc>\nclass raw_hash_map : public raw_hash_set<Policy, Hash, Eq, Alloc> {\n  // P is Policy. It's passed as a template argument to support maps that have\n  // incomplete types as values, as in unordered_map<K, IncompleteType>.\n  // MappedReference<> may be a non-reference type.\n  template <class P>\n  using MappedReference = decltype(P::value(\n      std::addressof(std::declval<typename raw_hash_map::reference>())));\n\n  // MappedConstReference<> may be a non-reference type.\n  template <class P>\n  using MappedConstReference = decltype(P::value(\n      std::addressof(std::declval<typename raw_hash_map::const_reference>())));\n\n  using KeyArgImpl =\n      KeyArg<IsTransparent<Eq>::value && IsTransparent<Hash>::value>;\n\n public:\n  using key_type = typename Policy::key_type;\n  using mapped_type = typename Policy::mapped_type;\n  template <class K>\n  using key_arg = typename KeyArgImpl::template type<K, key_type>;\n\n  static_assert(!std::is_reference<key_type>::value, \"\");\n\n  // TODO(b/187807849): Evaluate whether to support reference mapped_type and\n  // remove this assertion if/when it is supported.\n  static_assert(!std::is_reference<mapped_type>::value, \"\");\n\n  using iterator = typename raw_hash_map::raw_hash_set::iterator;\n  using const_iterator = typename raw_hash_map::raw_hash_set::const_iterator;\n\n  raw_hash_map() {}\n  using raw_hash_map::raw_hash_set::raw_hash_set;\n\n  // The last two template parameters ensure that both arguments are rvalues\n  // (lvalue arguments are handled by the overloads below). This is necessary\n  // for supporting bitfield arguments.\n  //\n  //   union { int n : 1; };\n  //   flat_hash_map<int, int> m;\n  //   m.insert_or_assign(n, n);\n  template <class K = key_type, class V = mapped_type, K* = nullptr,\n            V* = nullptr>\n  std::pair<iterator, bool> insert_or_assign(key_arg<K>&& k, V&& v)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign_impl(std::forward<K>(k), std::forward<V>(v));\n  }\n\n  template <class K = key_type, class V = mapped_type, K* = nullptr>\n  std::pair<iterator, bool> insert_or_assign(key_arg<K>&& k, const V& v)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign_impl(std::forward<K>(k), v);\n  }\n\n  template <class K = key_type, class V = mapped_type, V* = nullptr>\n  std::pair<iterator, bool> insert_or_assign(const key_arg<K>& k, V&& v)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign_impl(k, std::forward<V>(v));\n  }\n\n  template <class K = key_type, class V = mapped_type>\n  std::pair<iterator, bool> insert_or_assign(const key_arg<K>& k, const V& v)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign_impl(k, v);\n  }\n\n  template <class K = key_type, class V = mapped_type, K* = nullptr,\n            V* = nullptr>\n  iterator insert_or_assign(const_iterator, key_arg<K>&& k,\n                            V&& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign(std::forward<K>(k), std::forward<V>(v)).first;\n  }\n\n  template <class K = key_type, class V = mapped_type, K* = nullptr>\n  iterator insert_or_assign(const_iterator, key_arg<K>&& k,\n                            const V& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign(std::forward<K>(k), v).first;\n  }\n\n  template <class K = key_type, class V = mapped_type, V* = nullptr>\n  iterator insert_or_assign(const_iterator, const key_arg<K>& k,\n                            V&& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign(k, std::forward<V>(v)).first;\n  }\n\n  template <class K = key_type, class V = mapped_type>\n  iterator insert_or_assign(const_iterator, const key_arg<K>& k,\n                            const V& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return insert_or_assign(k, v).first;\n  }\n\n  // All `try_emplace()` overloads make the same guarantees regarding rvalue\n  // arguments as `std::unordered_map::try_emplace()`, namely that these\n  // functions will not move from rvalue arguments if insertions do not happen.\n  template <class K = key_type, class... Args,\n            typename std::enable_if<\n                !std::is_convertible<K, const_iterator>::value, int>::type = 0,\n            K* = nullptr>\n  std::pair<iterator, bool> try_emplace(key_arg<K>&& k, Args&&... args)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return try_emplace_impl(std::forward<K>(k), std::forward<Args>(args)...);\n  }\n\n  template <class K = key_type, class... Args,\n            typename std::enable_if<\n                !std::is_convertible<K, const_iterator>::value, int>::type = 0>\n  std::pair<iterator, bool> try_emplace(const key_arg<K>& k, Args&&... args)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return try_emplace_impl(k, std::forward<Args>(args)...);\n  }\n\n  template <class K = key_type, class... Args, K* = nullptr>\n  iterator try_emplace(const_iterator, key_arg<K>&& k,\n                       Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return try_emplace(std::forward<K>(k), std::forward<Args>(args)...).first;\n  }\n\n  template <class K = key_type, class... Args>\n  iterator try_emplace(const_iterator, const key_arg<K>& k,\n                       Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    return try_emplace(k, std::forward<Args>(args)...).first;\n  }\n\n  template <class K = key_type, class P = Policy>\n  MappedReference<P> at(const key_arg<K>& key) ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    auto it = this->find(key);\n    if (it == this->end()) {\n      base_internal::ThrowStdOutOfRange(\n          \"absl::container_internal::raw_hash_map<>::at\");\n    }\n    return Policy::value(&*it);\n  }\n\n  template <class K = key_type, class P = Policy>\n  MappedConstReference<P> at(const key_arg<K>& key) const\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    auto it = this->find(key);\n    if (it == this->end()) {\n      base_internal::ThrowStdOutOfRange(\n          \"absl::container_internal::raw_hash_map<>::at\");\n    }\n    return Policy::value(&*it);\n  }\n\n  template <class K = key_type, class P = Policy, K* = nullptr>\n  MappedReference<P> operator[](key_arg<K>&& key)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    // It is safe to use unchecked_deref here because try_emplace\n    // will always return an iterator pointing to a valid item in the table,\n    // since it inserts if nothing is found for the given key.\n    return Policy::value(\n        &this->unchecked_deref(try_emplace(std::forward<K>(key)).first));\n  }\n\n  template <class K = key_type, class P = Policy>\n  MappedReference<P> operator[](const key_arg<K>& key)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    // It is safe to use unchecked_deref here because try_emplace\n    // will always return an iterator pointing to a valid item in the table,\n    // since it inserts if nothing is found for the given key.\n    return Policy::value(&this->unchecked_deref(try_emplace(key).first));\n  }\n\n private:\n  template <class K, class V>\n  std::pair<iterator, bool> insert_or_assign_impl(K&& k, V&& v)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    auto res = this->find_or_prepare_insert(k);\n    if (res.second)\n      this->emplace_at(res.first, std::forward<K>(k), std::forward<V>(v));\n    else\n      Policy::value(&*this->iterator_at(res.first)) = std::forward<V>(v);\n    return {this->iterator_at(res.first), res.second};\n  }\n\n  template <class K = key_type, class... Args>\n  std::pair<iterator, bool> try_emplace_impl(K&& k, Args&&... args)\n      ABSL_ATTRIBUTE_LIFETIME_BOUND {\n    auto res = this->find_or_prepare_insert(k);\n    if (res.second)\n      this->emplace_at(res.first, std::piecewise_construct,\n                       std::forward_as_tuple(std::forward<K>(k)),\n                       std::forward_as_tuple(std::forward<Args>(args)...));\n    return {this->iterator_at(res.first), res.second};\n  }\n};\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-05136",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/container/internal/raw_hash_map.h",
  "source_line": 30,
  "validation_status": "validated"
}