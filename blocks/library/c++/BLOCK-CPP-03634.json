{
  "code": "#include <cassert>\n#include <functional>\n#include <type_traits>\n#include \"absl/base/attributes.h\"\n#include \"absl/functional/internal/function_ref.h\"\n#include \"absl/meta/type_traits.h\"\n\nusing namespace absl;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-03634_execute() {\n    {\nABSL_NAMESPACE_BEGIN\n\n// FunctionRef\n//\n// Dummy class declaration to allow the partial specialization based on function\n// types below.\ntemplate <typename T>\nclass FunctionRef;\n\n// FunctionRef\n//\n// An `absl::FunctionRef` is a lightweight wrapper to any invocable object with\n// a compatible signature. Generally, an `absl::FunctionRef` should only be used\n// as an argument type and should be preferred as an argument over a const\n// reference to a `std::function`. `absl::FunctionRef` itself does not allocate,\n// although the wrapped invocable may.\n//\n// Example:\n//\n//   // The following function takes a function callback by const reference\n//   bool Visitor(const std::function<void(my_proto&,\n//                                         absl::string_view)>& callback);\n//\n//   // Assuming that the function is not stored or otherwise copied, it can be\n//   // replaced by an `absl::FunctionRef`:\n//   bool Visitor(absl::FunctionRef<void(my_proto&, absl::string_view)>\n//                  callback);\n//\n// Note: the assignment operator within an `absl::FunctionRef` is intentionally\n// deleted to prevent misuse; because the `absl::FunctionRef` does not own the\n// underlying type, assignment likely indicates misuse.\ntemplate <typename R, typename... Args>\nclass FunctionRef<R(Args...)> {\n private:\n  // Used to disable constructors for objects that are not compatible with the\n  // signature of this FunctionRef.\n  template <typename F,\n            typename FR = absl::base_internal::invoke_result_t<F, Args&&...>>\n  using EnableIfCompatible =\n      typename std::enable_if<std::is_void<R>::value ||\n                              std::is_convertible<FR, R>::value>::type;\n\n public:\n  // Constructs a FunctionRef from any invocable type.\n  template <typename F, typename = EnableIfCompatible<const F&>>\n  // NOLINTNEXTLINE(runtime/explicit)\n  FunctionRef(const F& f ABSL_ATTRIBUTE_LIFETIME_BOUND)\n      : invoker_(&absl::functional_internal::InvokeObject<F, R, Args...>) {\n    absl::functional_internal::AssertNonNull(f);\n    ptr_.obj = &f;\n  }\n\n  // Overload for function pointers. This eliminates a level of indirection that\n  // would happen if the above overload was used (it lets us store the pointer\n  // instead of a pointer to a pointer).\n  //\n  // This overload is also used for references to functions, since references to\n  // functions can decay to function pointers implicitly.\n  template <\n      typename F, typename = EnableIfCompatible<F*>,\n      absl::functional_internal::EnableIf<absl::is_function<F>::value> = 0>\n  FunctionRef(F* f)  // NOLINT(runtime/explicit)\n      : invoker_(&absl::functional_internal::InvokeFunction<F*, R, Args...>) {\n    assert(f != nullptr);\n    ptr_.fun = reinterpret_cast<decltype(ptr_.fun)>(f);\n  }\n\n  // To help prevent subtle lifetime bugs, FunctionRef is not assignable.\n  // Typically, it should only be used as an argument type.\n  FunctionRef& operator=(const FunctionRef& rhs) = delete;\n  FunctionRef(const FunctionRef& rhs) = default;\n\n  // Call the underlying object.\n  R operator()(Args... args) const {\n    return invoker_(ptr_, std::forward<Args>(args)...);\n  }\n\n private:\n  absl::functional_internal::VoidPtr ptr_;\n  absl::functional_internal::Invoker<R, Args...> invoker_;\n};\n\n// Allow const qualified function signatures. Since FunctionRef requires\n// constness anyway we can just make this a no-op.\ntemplate <typename R, typename... Args>\nclass FunctionRef<R(Args...) const> : public FunctionRef<R(Args...)> {\n public:\n  using FunctionRef<R(Args...)>::FunctionRef;\n};\n\nABSL_NAMESPACE_END\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-03634",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/functional/function_ref.h",
  "source_line": 57,
  "validation_status": "validated"
}