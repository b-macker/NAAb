{
  "code": "{\n\n// CRC32C implementation optimized for small inputs.\n// Either computes crc and return true, or if there is\n// no hardware support does nothing and returns false.\ninline bool ExtendCrc32cInline(uint32_t* crc, const char* p, size_t n) {\n#if defined(ABSL_CRC_INTERNAL_HAVE_ARM_SIMD) || \\\n    defined(ABSL_CRC_INTERNAL_HAVE_X86_SIMD)\n  constexpr uint32_t kCrc32Xor = 0xffffffffU;\n  *crc ^= kCrc32Xor;\n  if (n & 1) {\n    *crc = CRC32_u8(*crc, static_cast<uint8_t>(*p));\n    n--;\n    p++;\n  }\n  if (n & 2) {\n    *crc = CRC32_u16(*crc, absl::little_endian::Load16(p));\n    n -= 2;\n    p += 2;\n  }\n  if (n & 4) {\n    *crc = CRC32_u32(*crc, absl::little_endian::Load32(p));\n    n -= 4;\n    p += 4;\n  }\n  while (n) {\n    *crc = CRC32_u64(*crc, absl::little_endian::Load64(p));\n    n -= 8;\n    p += 8;\n  }\n  *crc ^= kCrc32Xor;\n  return true;\n#else\n  // No hardware support, signal the need to fallback.\n  static_cast<void>(crc);\n  static_cast<void>(p);\n  static_cast<void>(n);\n  return false;\n#endif  // defined(ABSL_CRC_INTERNAL_HAVE_ARM_SIMD) ||\n        // defined(ABSL_CRC_INTERNAL_HAVE_X86_SIMD)\n}\n\n}",
  "id": "BLOCK-CPP-05415",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/crc/internal/crc32c_inline.h",
  "source_line": 26,
  "validation_status": "validated"
}