{
  "code": "{\nABSL_NAMESPACE_BEGIN\n\n// CUnescape()\n//\n// Unescapes a `source` string and copies it into `dest`, rewriting C-style\n// escape sequences (https://en.cppreference.com/w/cpp/language/escape) into\n// their proper code point equivalents, returning `true` if successful.\n//\n// The following unescape sequences can be handled:\n//\n//   * ASCII escape sequences ('\\n','\\r','\\\\', etc.) to their ASCII equivalents\n//   * Octal escape sequences ('\\nnn') to byte nnn. The unescaped value must\n//     resolve to a single byte or an error will occur. E.g. values greater than\n//     0xff will produce an error.\n//   * Hexadecimal escape sequences ('\\xnn') to byte nn. While an arbitrary\n//     number of following digits are allowed, the unescaped value must resolve\n//     to a single byte or an error will occur. E.g. '\\x0045' is equivalent to\n//     '\\x45', but '\\x1234' will produce an error.\n//   * Unicode escape sequences ('\\unnnn' for exactly four hex digits or\n//     '\\Unnnnnnnn' for exactly eight hex digits, which will be encoded in\n//     UTF-8. (E.g., `\\u2019` unescapes to the three bytes 0xE2, 0x80, and\n//     0x99).\n//\n// If any errors are encountered, this function returns `false`, leaving the\n// `dest` output parameter in an unspecified state, and stores the first\n// encountered error in `error`. To disable error reporting, set `error` to\n// `nullptr` or use the overload with no error reporting below.\n//\n// Example:\n//\n//   std::string s = \"foo\\\\rbar\\\\nbaz\\\\t\";\n//   std::string unescaped_s;\n//   if (!absl::CUnescape(s, &unescaped_s) {\n//     ...\n//   }\n//   EXPECT_EQ(unescaped_s, \"foo\\rbar\\nbaz\\t\");\nbool CUnescape(absl::string_view source, std::string* dest, std::string* error);\n\n// Overload of `CUnescape()` with no error reporting.\ninline bool CUnescape(absl::string_view source, std::string* dest) {\n  return CUnescape(source, dest, nullptr);\n}\n\n// CEscape()\n//\n// Escapes a 'src' string using C-style escapes sequences\n// (https://en.cppreference.com/w/cpp/language/escape), escaping other\n// non-printable/non-whitespace bytes as octal sequences (e.g. \"\\377\").\n//\n// Example:\n//\n//   std::string s = \"foo\\rbar\\tbaz\\010\\011\\012\\013\\014\\x0d\\n\";\n//   std::string escaped_s = absl::CEscape(s);\n//   EXPECT_EQ(escaped_s, \"foo\\\\rbar\\\\tbaz\\\\010\\\\t\\\\n\\\\013\\\\014\\\\r\\\\n\");\nstd::string CEscape(absl::string_view src);\n\n// CHexEscape()\n//\n// Escapes a 'src' string using C-style escape sequences, escaping\n// other non-printable/non-whitespace bytes as hexadecimal sequences (e.g.\n// \"\\xFF\").\n//\n// Example:\n//\n//   std::string s = \"foo\\rbar\\tbaz\\010\\011\\012\\013\\014\\x0d\\n\";\n//   std::string escaped_s = absl::CHexEscape(s);\n//   EXPECT_EQ(escaped_s, \"foo\\\\rbar\\\\tbaz\\\\x08\\\\t\\\\n\\\\x0b\\\\x0c\\\\r\\\\n\");\nstd::string CHexEscape(absl::string_view src);\n\n// Utf8SafeCEscape()\n//\n// Escapes a 'src' string using C-style escape sequences, escaping bytes as\n// octal sequences, and passing through UTF-8 characters without conversion.\n// I.e., when encountering any bytes with their high bit set, this function\n// will not escape those values, whether or not they are valid UTF-8.\nstd::string Utf8SafeCEscape(absl::string_view src);\n\n// Utf8SafeCHexEscape()\n//\n// Escapes a 'src' string using C-style escape sequences, escaping bytes as\n// hexadecimal sequences, and passing through UTF-8 characters without\n// conversion.\nstd::string Utf8SafeCHexEscape(absl::string_view src);\n\n// Base64Escape()\n//\n// Encodes a `src` string into a base64-encoded 'dest' string with padding\n// characters. This function conforms with RFC 4648 section 4 (base64) and RFC\n// 2045.\nvoid Base64Escape(absl::string_view src, std::string* dest);\nstd::string Base64Escape(absl::string_view src);\n\n// WebSafeBase64Escape()\n//\n// Encodes a `src` string into a base64 string, like Base64Escape() does, but\n// outputs '-' instead of '+' and '_' instead of '/', and does not pad 'dest'.\n// This function conforms with RFC 4648 section 5 (base64url).\nvoid WebSafeBase64Escape(absl::string_view src, std::string* dest);\nstd::string WebSafeBase64Escape(absl::string_view src);\n\n// Base64Unescape()\n//\n// Converts a `src` string encoded in Base64 (RFC 4648 section 4) to its binary\n// equivalent, writing it to a `dest` buffer, returning `true` on success. If\n// `src` contains invalid characters, `dest` is cleared and returns `false`.\n// If padding is included (note that `Base64Escape()` does produce it), it must\n// be correct. In the padding, '=' and '.' are treated identically.\nbool Base64Unescape(absl::string_view src, std::string* dest);\n\n// WebSafeBase64Unescape()\n//\n// Converts a `src` string encoded in \"web safe\" Base64 (RFC 4648 section 5) to\n// its binary equivalent, writing it to a `dest` buffer. If `src` contains\n// invalid characters, `dest` is cleared and returns `false`. If padding is\n// included (note that `WebSafeBase64Escape()` does not produce it), it must be\n// correct. In the padding, '=' and '.' are treated identically.\nbool WebSafeBase64Unescape(absl::string_view src, std::string* dest);\n\n// HexStringToBytes()\n//\n// Converts an ASCII hex string into bytes, returning binary data of length\n// `from.size()/2`.\nstd::string HexStringToBytes(absl::string_view from);\n\n// BytesToHexString()\n//\n// Converts binary data into an ASCII text string, returning a string of size\n// `2*from.size()`.\nstd::string BytesToHexString(absl::string_view from);\n\nABSL_NAMESPACE_END\n}",
  "id": "BLOCK-CPP-04077",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/escaping.h",
  "source_line": 35,
  "validation_status": "validated"
}