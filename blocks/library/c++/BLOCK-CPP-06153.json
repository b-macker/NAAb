{
  "code": "#include <cassert>\n#include <cstdint>\n#include \"absl/base/config.h\"\n#include \"absl/base/optimization.h\"\n#include \"absl/crc/internal/crc_cord_state.h\"\n#include \"absl/strings/internal/cord_internal.h\"\n\nusing namespace absl;\nusing namespace cord_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-06153_execute() {\n    {\n\n// CordRepCrc is a CordRep node intended only to appear at the top level of a\n// cord tree.  It associates an \"expected CRC\" with the contained data, to allow\n// for easy passage of checksum data in Cord data flows.\n//\n// From Cord's perspective, the crc value has no semantics; any validation of\n// the contained checksum is the user's responsibility.\nstruct CordRepCrc : public CordRep {\n  CordRep* child;\n  absl::crc_internal::CrcCordState crc_cord_state;\n\n  // Consumes `child` and returns a CordRepCrc prefixed tree containing `child`.\n  // If the specified `child` is itself a CordRepCrc node, then this method\n  // either replaces the existing node, or directly updates the crc state in it\n  // depending on the node being shared or not, i.e.: refcount.IsOne().\n  // `child` must only be null if the Cord is empty. Never returns null.\n  static CordRepCrc* New(CordRep* child, crc_internal::CrcCordState state);\n\n  // Destroys (deletes) the provided node. `node` must not be null.\n  static void Destroy(CordRepCrc* node);\n};\n\n// Consumes `rep` and returns a CordRep* with any outer CordRepCrc wrapper\n// removed.  This is usually a no-op (returning `rep`), but this will remove and\n// unref an outer CordRepCrc node.\ninline CordRep* RemoveCrcNode(CordRep* rep) {\n  assert(rep != nullptr);\n  if (ABSL_PREDICT_FALSE(rep->IsCrc())) {\n    CordRep* child = rep->crc()->child;\n    if (rep->refcount.IsOne()) {\n      delete rep->crc();\n    } else {\n      CordRep::Ref(child);\n      CordRep::Unref(rep);\n    }\n    return child;\n  }\n  return rep;\n}\n\n// Returns `rep` if it is not a CordRepCrc node, or its child if it is.\n// Does not consume or create a reference on `rep` or the returned value.\ninline CordRep* SkipCrcNode(CordRep* rep) {\n  assert(rep != nullptr);\n  if (ABSL_PREDICT_FALSE(rep->IsCrc())) {\n    return rep->crc()->child;\n  } else {\n    return rep;\n  }\n}\n\ninline const CordRep* SkipCrcNode(const CordRep* rep) {\n  assert(rep != nullptr);\n  if (ABSL_PREDICT_FALSE(rep->IsCrc())) {\n    return rep->crc()->child;\n  } else {\n    return rep;\n  }\n}\n\ninline CordRepCrc* CordRep::crc() {\n  assert(IsCrc());\n  return static_cast<CordRepCrc*>(this);\n}\n\ninline const CordRepCrc* CordRep::crc() const {\n  assert(IsCrc());\n  return static_cast<const CordRepCrc*>(this);\n}\n\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-06153",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/strings/internal/cord_rep_crc.h",
  "source_line": 28,
  "validation_status": "validated"
}