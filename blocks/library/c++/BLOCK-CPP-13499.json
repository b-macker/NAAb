{
  "code": "{\n\nclass APValue;\n\nclass TextTreeStructure {\n  raw_ostream &OS;\n  const bool ShowColors;\n\n  /// Pending[i] is an action to dump an entity at level i.\n  llvm::SmallVector<std::function<void(bool IsLastChild)>, 32> Pending;\n\n  /// Indicates whether we're at the top level.\n  bool TopLevel = true;\n\n  /// Indicates if we're handling the first child after entering a new depth.\n  bool FirstChild = true;\n\n  /// Prefix for currently-being-dumped entity.\n  std::string Prefix;\n\npublic:\n  /// Add a child of the current node.  Calls DoAddChild without arguments\n  template <typename Fn> void AddChild(Fn DoAddChild) {\n    return AddChild(\"\", DoAddChild);\n  }\n\n  /// Add a child of the current node with an optional label.\n  /// Calls DoAddChild without arguments.\n  template <typename Fn> void AddChild(StringRef Label, Fn DoAddChild) {\n    // If we're at the top level, there's nothing interesting to do; just\n    // run the dumper.\n    if (TopLevel) {\n      TopLevel = false;\n      DoAddChild();\n      while (!Pending.empty()) {\n        Pending.back()(true);\n        Pending.pop_back();\n      }\n      Prefix.clear();\n      OS << \"\\n\";\n      TopLevel = true;\n      return;\n    }\n\n    auto DumpWithIndent = [this, DoAddChild,\n                           Label(Label.str())](bool IsLastChild) {\n      // Print out the appropriate tree structure and work out the prefix for\n      // children of this node. For instance:\n      //\n      //   A        Prefix = \"\"\n      //   |-B      Prefix = \"| \"\n      //   | `-C    Prefix = \"|   \"\n      //   `-D      Prefix = \"  \"\n      //     |-E    Prefix = \"  | \"\n      //     `-F    Prefix = \"    \"\n      //   G        Prefix = \"\"\n      //\n      // Note that the first level gets no prefix.\n      {\n        OS << '\\n';\n        ColorScope Color(OS, ShowColors, IndentColor);\n        OS << Prefix << (IsLastChild ? '`' : '|') << '-';\n        if (!Label.empty())\n          OS << Label << \": \";\n\n        this->Prefix.push_back(IsLastChild ? ' ' : '|');\n        this->Prefix.push_back(' ');\n      }\n\n      FirstChild = true;\n      unsigned Depth = Pending.size();\n\n      DoAddChild();\n\n      // If any children are left, they're the last at their nesting level.\n      // Dump those ones out now.\n      while (Depth < Pending.size()) {\n        Pending.back()(true);\n        this->Pending.pop_back();\n      }\n\n      // Restore the old prefix.\n      this->Prefix.resize(Prefix.size() - 2);\n    };\n\n    if (FirstChild) {\n      Pending.push_back(std::move(DumpWithIndent));\n    } else {\n      Pending.back()(false);\n      Pending.back() = std::move(DumpWithIndent);\n    }\n    FirstChild = false;\n  }\n\n  TextTreeStructure(raw_ostream &OS, bool ShowColors)\n      : OS(OS), ShowColors(ShowColors) {}\n};\n\nclass TextNodeDumper\n    : public TextTreeStructure,\n      public comments::ConstCommentVisitor<TextNodeDumper, void,\n                                           const comments::FullComment *>,\n      public ConstAttrVisitor<TextNodeDumper>,\n      public ConstTemplateArgumentVisitor<TextNodeDumper>,\n      public ConstStmtVisitor<TextNodeDumper>,\n      public TypeVisitor<TextNodeDumper>,\n      public ConstDeclVisitor<TextNodeDumper> {\n  raw_ostream &OS;\n  const bool ShowColors;\n\n  /// Keep track of the last location we print out so that we can\n  /// print out deltas from then on out.\n  const char *LastLocFilename = \"\";\n  unsigned LastLocLine = ~0U;\n\n  /// \\p Context, \\p SM, and \\p Traits can be null. This is because we want\n  /// to be able to call \\p dump() in a debugger without having to pass the\n  /// \\p ASTContext to \\p dump. Not all parts of the AST dump output will be\n  /// available without the \\p ASTContext.\n  const ASTContext *Context = nullptr;\n  const SourceManager *SM = nullptr;\n\n  /// The policy to use for printing; can be defaulted.\n  PrintingPolicy PrintPolicy = LangOptions();\n\n  const comments::CommandTraits *Traits = nullptr;\n\n  const char *getCommandName(unsigned CommandID);\n  void printFPOptions(FPOptionsOverride FPO);\n\n  void dumpAPValueChildren(const APValue &Value, QualType Ty,\n                           const APValue &(*IdxToChildFun)(const APValue &,\n                                                           unsigned),\n                           unsigned NumChildren, StringRef LabelSingular,\n                           StringRef LabelPlurial);\n\npublic:\n  TextNodeDumper(raw_ostream &OS, const ASTContext &Context, bool ShowColors);\n  TextNodeDumper(raw_ostream &OS, bool ShowColors);\n\n  void Visit(const comments::Comment *C, const comments::FullComment *FC);\n\n  void Visit(const Attr *A);\n\n  void Visit(const TemplateArgument &TA, SourceRange R,\n             const Decl *From = nullptr, StringRef Label = {});\n\n  void Visit(const Stmt *Node);\n\n  void Visit(const Type *T);\n\n  void Visit(QualType T);\n\n  void Visit(const Decl *D);\n\n  void Visit(const CXXCtorInitializer *Init);\n\n  void Visit(const OMPClause *C);\n\n  void Visit(const BlockDecl::Capture &C);\n\n  void Visit(const GenericSelectionExpr::ConstAssociation &A);\n\n  void Visit(const concepts::Requirement *R);\n\n  void Visit(const APValue &Value, QualType Ty);\n\n  void dumpPointer(const void *Ptr);\n  void dumpLocation(SourceLocation Loc);\n  void dumpSourceRange(SourceRange R);\n  void dumpBareType(QualType T, bool Desugar = true);\n  void dumpType(QualType T);\n  void dumpBareDeclRef(const Decl *D);\n  void dumpName(const NamedDecl *ND);\n  void dumpAccessSpecifier(AccessSpecifier AS);\n  void dumpCleanupObject(const ExprWithCleanups::CleanupObject &C);\n\n  void dumpDeclRef(const Decl *D, StringRef Label = {});\n\n  void visitTextComment(const comments::TextComment *C,\n                        const comments::FullComment *);\n  void visitInlineCommandComment(const comments::InlineCommandComment *C,\n                                 const comments::FullComment *);\n  void visitHTMLStartTagComment(const comments::HTMLStartTagComment *C,\n                                const comments::FullComment *);\n  void visitHTMLEndTagComment(const comments::HTMLEndTagComment *C,\n                              const comments::FullComment *);\n  void visitBlockCommandComment(const comments::BlockCommandComment *C,\n                                const comments::FullComment *);\n  void visitParamCommandComment(const comments::ParamCommandComment *C,\n                                const comments::FullComment *FC);\n  void visitTParamCommandComment(const comments::TParamCommandComment *C,\n                                 const comments::FullComment *FC);\n  void visitVerbatimBlockComment(const comments::VerbatimBlockComment *C,\n                                 const comments::FullComment *);\n  void\n  visitVerbatimBlockLineComment(const comments::VerbatimBlockLineComment *C,\n                                const comments::FullComment *);\n  void visitVerbatimLineComment(const comments::VerbatimLineComment *C,\n                                const comments::FullComment *);\n\n// Implements Visit methods for Attrs.\n#include \"clang/AST/AttrTextNodeDump.inc\"\n\n  void VisitNullTemplateArgument(const TemplateArgument &TA);\n  void VisitTypeTemplateArgument(const TemplateArgument &TA);\n  void VisitDeclarationTemplateArgument(const TemplateArgument &TA);\n  void VisitNullPtrTemplateArgument(const TemplateArgument &TA);\n  void VisitIntegralTemplateArgument(const TemplateArgument &TA);\n  void VisitTemplateTemplateArgument(const TemplateArgument &TA);\n  void VisitTemplateExpansionTemplateArgument(const TemplateArgument &TA);\n  void VisitExpressionTemplateArgument(const TemplateArgument &TA);\n  void VisitPackTemplateArgument(const TemplateArgument &TA);\n\n  void VisitIfStmt(const IfStmt *Node);\n  void VisitSwitchStmt(const SwitchStmt *Node);\n  void VisitWhileStmt(const WhileStmt *Node);\n  void VisitLabelStmt(const LabelStmt *Node);\n  void VisitGotoStmt(const GotoStmt *Node);\n  void VisitCaseStmt(const CaseStmt *Node);\n  void VisitCompoundStmt(const CompoundStmt *Node);\n  void VisitConstantExpr(const ConstantExpr *Node);\n  void VisitCallExpr(const CallExpr *Node);\n  void VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *Node);\n  void VisitCastExpr(const CastExpr *Node);\n  void VisitImplicitCastExpr(const ImplicitCastExpr *Node);\n  void VisitDeclRefExpr(const DeclRefExpr *Node);\n  void VisitSYCLUniqueStableNameExpr(const SYCLUniqueStableNameExpr *Node);\n  void VisitPredefinedExpr(const PredefinedExpr *Node);\n  void VisitCharacterLiteral(const CharacterLiteral *Node);\n  void VisitIntegerLiteral(const IntegerLiteral *Node);\n  void VisitFixedPointLiteral(const FixedPointLiteral *Node);\n  void VisitFloatingLiteral(const FloatingLiteral *Node);\n  void VisitStringLiteral(const StringLiteral *Str);\n  void VisitInitListExpr(const InitListExpr *ILE);\n  void VisitGenericSelectionExpr(const GenericSelectionExpr *E);\n  void VisitUnaryOperator(const UnaryOperator *Node);\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *Node);\n  void VisitMemberExpr(const MemberExpr *Node);\n  void VisitExtVectorElementExpr(const ExtVectorElementExpr *Node);\n  void VisitBinaryOperator(const BinaryOperator *Node);\n  void VisitCompoundAssignOperator(const CompoundAssignOperator *Node);\n  void VisitAddrLabelExpr(const AddrLabelExpr *Node);\n  void VisitCXXNamedCastExpr(const CXXNamedCastExpr *Node);\n  void VisitCXXBoolLiteralExpr(const CXXBoolLiteralExpr *Node);\n  void VisitCXXThisExpr(const CXXThisExpr *Node);\n  void VisitCXXFunctionalCastExpr(const CXXFunctionalCastExpr *Node);\n  void VisitCXXStaticCastExpr(const CXXStaticCastExpr *Node);\n  void VisitCXXUnresolvedConstructExpr(const CXXUnresolvedConstructExpr *Node);\n  void VisitCXXConstructExpr(const CXXConstructExpr *Node);\n  void VisitCXXBindTemporaryExpr(const CXXBindTemporaryExpr *Node);\n  void VisitCXXNewExpr(const CXXNewExpr *Node);\n  void VisitCXXDeleteExpr(const CXXDeleteExpr *Node);\n  void VisitTypeTraitExpr(const TypeTraitExpr *Node);\n  void VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *Node);\n  void VisitExpressionTraitExpr(const ExpressionTraitExpr *Node);\n  void VisitMaterializeTemporaryExpr(const MaterializeTemporaryExpr *Node);\n  void VisitExprWithCleanups(const ExprWithCleanups *Node);\n  void VisitUnresolvedLookupExpr(const UnresolvedLookupExpr *Node);\n  void VisitSizeOfPackExpr(const SizeOfPackExpr *Node);\n  void\n  VisitCXXDependentScopeMemberExpr(const CXXDependentScopeMemberExpr *Node);\n  void VisitObjCAtCatchStmt(const ObjCAtCatchStmt *Node);\n  void VisitObjCEncodeExpr(const ObjCEncodeExpr *Node);\n  void VisitObjCMessageExpr(const ObjCMessageExpr *Node);\n  void VisitObjCBoxedExpr(const ObjCBoxedExpr *Node);\n  void VisitObjCSelectorExpr(const ObjCSelectorExpr *Node);\n  void VisitObjCProtocolExpr(const ObjCProtocolExpr *Node);\n  void VisitObjCPropertyRefExpr(const ObjCPropertyRefExpr *Node);\n  void VisitObjCSubscriptRefExpr(const ObjCSubscriptRefExpr *Node);\n  void VisitObjCIvarRefExpr(const ObjCIvarRefExpr *Node);\n  void VisitObjCBoolLiteralExpr(const ObjCBoolLiteralExpr *Node);\n  void VisitOMPIteratorExpr(const OMPIteratorExpr *Node);\n  void VisitConceptSpecializationExpr(const ConceptSpecializationExpr *Node);\n  void VisitRequiresExpr(const RequiresExpr *Node);\n\n  void VisitRValueReferenceType(const ReferenceType *T);\n  void VisitArrayType(const ArrayType *T);\n  void VisitConstantArrayType(const ConstantArrayType *T);\n  void VisitVariableArrayType(const VariableArrayType *T);\n  void VisitDependentSizedArrayType(const DependentSizedArrayType *T);\n  void VisitDependentSizedExtVectorType(const DependentSizedExtVectorType *T);\n  void VisitVectorType(const VectorType *T);\n  void VisitFunctionType(const FunctionType *T);\n  void VisitFunctionProtoType(const FunctionProtoType *T);\n  void VisitUnresolvedUsingType(const UnresolvedUsingType *T);\n  void VisitUsingType(const UsingType *T);\n  void VisitTypedefType(const TypedefType *T);\n  void VisitUnaryTransformType(const UnaryTransformType *T);\n  void VisitTagType(const TagType *T);\n  void VisitTemplateTypeParmType(const TemplateTypeParmType *T);\n  void VisitSubstTemplateTypeParmType(const SubstTemplateTypeParmType *T);\n  void\n  VisitSubstTemplateTypeParmPackType(const SubstTemplateTypeParmPackType *T);\n  void VisitAutoType(const AutoType *T);\n  void VisitDeducedTemplateSpecializationType(\n      const DeducedTemplateSpecializationType *T);\n  void VisitTemplateSpecializationType(const TemplateSpecializationType *T);\n  void VisitInjectedClassNameType(const InjectedClassNameType *T);\n  void VisitObjCInterfaceType(const ObjCInterfaceType *T);\n  void VisitPackExpansionType(const PackExpansionType *T);\n\n  void VisitLabelDecl(const LabelDecl *D);\n  void VisitTypedefDecl(const TypedefDecl *D);\n  void VisitEnumDecl(const EnumDecl *D);\n  void VisitRecordDecl(const RecordDecl *D);\n  void VisitEnumConstantDecl(const EnumConstantDecl *D);\n  void VisitIndirectFieldDecl(const IndirectFieldDecl *D);\n  void VisitFunctionDecl(const FunctionDecl *D);\n  void VisitFieldDecl(const FieldDecl *D);\n  void VisitVarDecl(const VarDecl *D);\n  void VisitBindingDecl(const BindingDecl *D);\n  void VisitCapturedDecl(const CapturedDecl *D);\n  void VisitImportDecl(const ImportDecl *D);\n  void VisitPragmaCommentDecl(const PragmaCommentDecl *D);\n  void VisitPragmaDetectMismatchDecl(const PragmaDetectMismatchDecl *D);\n  void VisitOMPExecutableDirective(const OMPExecutableDirective *D);\n  void VisitOMPDeclareReductionDecl(const OMPDeclareReductionDecl *D);\n  void VisitOMPRequiresDecl(const OMPRequiresDecl *D);\n  void VisitOMPCapturedExprDecl(const OMPCapturedExprDecl *D);\n  void VisitNamespaceDecl(const NamespaceDecl *D);\n  void VisitUsingDirectiveDecl(const UsingDirectiveDecl *D);\n  void VisitNamespaceAliasDecl(const NamespaceAliasDecl *D);\n  void VisitTypeAliasDecl(const TypeAliasDecl *D);\n  void VisitTypeAliasTemplateDecl(const TypeAliasTemplateDecl *D);\n  void VisitCXXRecordDecl(const CXXRecordDecl *D);\n  void VisitFunctionTemplateDecl(const FunctionTemplateDecl *D);\n  void VisitClassTemplateDecl(const ClassTemplateDecl *D);\n  void VisitBuiltinTemplateDecl(const BuiltinTemplateDecl *D);\n  void VisitVarTemplateDecl(const VarTemplateDecl *D);\n  void VisitTemplateTypeParmDecl(const TemplateTypeParmDecl *D);\n  void VisitNonTypeTemplateParmDecl(const NonTypeTemplateParmDecl *D);\n  void VisitTemplateTemplateParmDecl(const TemplateTemplateParmDecl *D);\n  void VisitUsingDecl(const UsingDecl *D);\n  void VisitUnresolvedUsingTypenameDecl(const UnresolvedUsingTypenameDecl *D);\n  void VisitUnresolvedUsingValueDecl(const UnresolvedUsingValueDecl *D);\n  void VisitUsingEnumDecl(const UsingEnumDecl *D);\n  void VisitUsingShadowDecl(const UsingShadowDecl *D);\n  void VisitConstructorUsingShadowDecl(const ConstructorUsingShadowDecl *D);\n  void VisitLinkageSpecDecl(const LinkageSpecDecl *D);\n  void VisitAccessSpecDecl(const AccessSpecDecl *D);\n  void VisitFriendDecl(const FriendDecl *D);\n  void VisitObjCIvarDecl(const ObjCIvarDecl *D);\n  void VisitObjCMethodDecl(const ObjCMethodDecl *D);\n  void VisitObjCTypeParamDecl(const ObjCTypeParamDecl *D);\n  void VisitObjCCategoryDecl(const ObjCCategoryDecl *D);\n  void VisitObjCCategoryImplDecl(const ObjCCategoryImplDecl *D);\n  void VisitObjCProtocolDecl(const ObjCProtocolDecl *D);\n  void VisitObjCInterfaceDecl(const ObjCInterfaceDecl *D);\n  void VisitObjCImplementationDecl(const ObjCImplementationDecl *D);\n  void VisitObjCCompatibleAliasDecl(const ObjCCompatibleAliasDecl *D);\n  void VisitObjCPropertyDecl(const ObjCPropertyDecl *D);\n  void VisitObjCPropertyImplDecl(const ObjCPropertyImplDecl *D);\n  void VisitBlockDecl(const BlockDecl *D);\n  void VisitConceptDecl(const ConceptDecl *D);\n  void\n  VisitLifetimeExtendedTemporaryDecl(const LifetimeExtendedTemporaryDecl *D);\n  void VisitHLSLBufferDecl(const HLSLBufferDecl *D);\n};\n\n}",
  "id": "BLOCK-CPP-13499",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/TextNodeDumper.h",
  "source_line": 29,
  "validation_status": "validated"
}