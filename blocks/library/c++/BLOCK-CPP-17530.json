{
  "code": "#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/CodeGen/CGFunctionInfo.h\"\n#include \"llvm/IR/BasicBlock.h\"\n\nusing namespace llvm;\nusing namespace clang;\nusing namespace CodeGen;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-17530_execute() {\n    {\nclass CGFunctionInfo;\nclass CodeGenModule;\n\n/// Additional implicit arguments to add to a constructor argument list.\nstruct ImplicitCXXConstructorArgs {\n  /// Implicit arguments to add before the explicit arguments, but after the\n  /// `*this` argument (which always comes first).\n  SmallVector<llvm::Value *, 1> Prefix;\n\n  /// Implicit arguments to add after the explicit arguments.\n  SmallVector<llvm::Value *, 1> Suffix;\n};\n\nconst CGFunctionInfo &arrangeObjCMessageSendSignature(CodeGenModule &CGM,\n                                                      const ObjCMethodDecl *MD,\n                                                      QualType receiverType);\n\nconst CGFunctionInfo &arrangeFreeFunctionType(CodeGenModule &CGM,\n                                              CanQual<FunctionProtoType> Ty);\n\nconst CGFunctionInfo &arrangeFreeFunctionType(CodeGenModule &CGM,\n                                              CanQual<FunctionNoProtoType> Ty);\n\nconst CGFunctionInfo &arrangeCXXMethodType(CodeGenModule &CGM,\n                                           const CXXRecordDecl *RD,\n                                           const FunctionProtoType *FTP,\n                                           const CXXMethodDecl *MD);\n\nconst CGFunctionInfo &arrangeFreeFunctionCall(CodeGenModule &CGM,\n                                              CanQualType returnType,\n                                              ArrayRef<CanQualType> argTypes,\n                                              FunctionType::ExtInfo info,\n                                              RequiredArgs args);\n\n/// Returns the implicit arguments to add to a complete, non-delegating C++\n/// constructor call.\nImplicitCXXConstructorArgs\ngetImplicitCXXConstructorArgs(CodeGenModule &CGM, const CXXConstructorDecl *D);\n\nllvm::Value *\ngetCXXDestructorImplicitParam(CodeGenModule &CGM, llvm::BasicBlock *InsertBlock,\n                              llvm::BasicBlock::iterator InsertPoint,\n                              const CXXDestructorDecl *D, CXXDtorType Type,\n                              bool ForVirtualBase, bool Delegating);\n\n/// Returns null if the function type is incomplete and can't be lowered.\nllvm::FunctionType *convertFreeFunctionType(CodeGenModule &CGM,\n                                            const FunctionDecl *FD);\n\nllvm::Type *convertTypeForMemory(CodeGenModule &CGM, QualType T);\n\n/// Given a non-bitfield struct field, return its index within the elements of\n/// the struct's converted type.  The returned index refers to a field number in\n/// the complete object type which is returned by convertTypeForMemory.  FD must\n/// be a field in RD directly (i.e. not an inherited field).\nunsigned getLLVMFieldNumber(CodeGenModule &CGM,\n                            const RecordDecl *RD, const FieldDecl *FD);\n\n/// Given the language and code-generation options that Clang was configured\n/// with, set the default LLVM IR attributes for a function definition.\n/// The attributes set here are mostly global target-configuration and\n/// pipeline-configuration options like the target CPU, variant stack\n/// rules, whether to optimize for size, and so on.  This is useful for\n/// frontends (such as Swift) that generally intend to interoperate with\n/// C code and rely on Clang's target configuration logic.\n///\n/// As a general rule, this function assumes that meaningful attributes\n/// haven't already been added to the builder.  It won't intentionally\n/// displace any existing attributes, but it also won't check to avoid\n/// overwriting them.  Callers should generally apply customizations after\n/// making this call.\n///\n/// This function assumes that the caller is not defining a function that\n/// requires special no-builtin treatment.\nvoid addDefaultFunctionDefinitionAttributes(CodeGenModule &CGM,\n                                            llvm::AttrBuilder &attrs);\n\n/// Returns the default constructor for a C struct with non-trivially copyable\n/// fields, generating it if necessary. The returned function uses the `cdecl`\n/// calling convention, returns void, and takes a single argument that is a\n/// pointer to the address of the struct.\nllvm::Function *getNonTrivialCStructDefaultConstructor(CodeGenModule &GCM,\n                                                       CharUnits DstAlignment,\n                                                       bool IsVolatile,\n                                                       QualType QT);\n\n/// Returns the copy constructor for a C struct with non-trivially copyable\n/// fields, generating it if necessary. The returned function uses the `cdecl`\n/// calling convention, returns void, and takes two arguments: pointers to the\n/// addresses of the destination and source structs, respectively.\nllvm::Function *getNonTrivialCStructCopyConstructor(CodeGenModule &CGM,\n                                                    CharUnits DstAlignment,\n                                                    CharUnits SrcAlignment,\n                                                    bool IsVolatile,\n                                                    QualType QT);\n\n/// Returns the move constructor for a C struct with non-trivially copyable\n/// fields, generating it if necessary. The returned function uses the `cdecl`\n/// calling convention, returns void, and takes two arguments: pointers to the\n/// addresses of the destination and source structs, respectively.\nllvm::Function *getNonTrivialCStructMoveConstructor(CodeGenModule &CGM,\n                                                    CharUnits DstAlignment,\n                                                    CharUnits SrcAlignment,\n                                                    bool IsVolatile,\n                                                    QualType QT);\n\n/// Returns the copy assignment operator for a C struct with non-trivially\n/// copyable fields, generating it if necessary. The returned function uses the\n/// `cdecl` calling convention, returns void, and takes two arguments: pointers\n/// to the addresses of the destination and source structs, respectively.\nllvm::Function *getNonTrivialCStructCopyAssignmentOperator(\n    CodeGenModule &CGM, CharUnits DstAlignment, CharUnits SrcAlignment,\n    bool IsVolatile, QualType QT);\n\n/// Return the move assignment operator for a C struct with non-trivially\n/// copyable fields, generating it if necessary. The returned function uses the\n/// `cdecl` calling convention, returns void, and takes two arguments: pointers\n/// to the addresses of the destination and source structs, respectively.\nllvm::Function *getNonTrivialCStructMoveAssignmentOperator(\n    CodeGenModule &CGM, CharUnits DstAlignment, CharUnits SrcAlignment,\n    bool IsVolatile, QualType QT);\n\n/// Returns the destructor for a C struct with non-trivially copyable fields,\n/// generating it if necessary. The returned function uses the `cdecl` calling\n/// convention, returns void, and takes a single argument that is a pointer to\n/// the address of the struct.\nllvm::Function *getNonTrivialCStructDestructor(CodeGenModule &CGM,\n                                               CharUnits DstAlignment,\n                                               bool IsVolatile, QualType QT);\n\n/// Get a pointer to a protocol object for the given declaration, emitting it if\n/// it hasn't already been emitted in this translation unit. Note that the ABI\n/// for emitting a protocol reference in code (e.g. for a protocol expression)\n/// in most runtimes is not as simple as just materializing a pointer to this\n/// object.\nllvm::Constant *emitObjCProtocolObject(CodeGenModule &CGM,\n                                       const ObjCProtocolDecl *p);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-17530",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/CodeGenABITypes.h",
  "source_line": 48,
  "validation_status": "validated"
}