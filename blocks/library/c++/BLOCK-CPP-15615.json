{
  "code": "{\n\nclass CallGraphNode;\nclass Decl;\nclass DeclContext;\nclass Stmt;\n\n/// The AST-based call graph.\n///\n/// The call graph extends itself with the given declarations by implementing\n/// the recursive AST visitor, which constructs the graph by visiting the given\n/// declarations.\nclass CallGraph : public RecursiveASTVisitor<CallGraph> {\n  friend class CallGraphNode;\n\n  using FunctionMapTy =\n      llvm::DenseMap<const Decl *, std::unique_ptr<CallGraphNode>>;\n\n  /// FunctionMap owns all CallGraphNodes.\n  FunctionMapTy FunctionMap;\n\n  /// This is a virtual root node that has edges to all the functions.\n  CallGraphNode *Root;\n\npublic:\n  CallGraph();\n  ~CallGraph();\n\n  /// Populate the call graph with the functions in the given\n  /// declaration.\n  ///\n  /// Recursively walks the declaration to find all the dependent Decls as well.\n  void addToCallGraph(Decl *D) {\n    TraverseDecl(D);\n  }\n\n  /// Determine if a declaration should be included in the graph.\n  static bool includeInGraph(const Decl *D);\n\n  /// Determine if a declaration should be included in the graph for the\n  /// purposes of being a callee. This is similar to includeInGraph except\n  /// it permits declarations, not just definitions.\n  static bool includeCalleeInGraph(const Decl *D);\n\n  /// Lookup the node for the given declaration.\n  CallGraphNode *getNode(const Decl *) const;\n\n  /// Lookup the node for the given declaration. If none found, insert\n  /// one into the graph.\n  CallGraphNode *getOrInsertNode(Decl *);\n\n  using iterator = FunctionMapTy::iterator;\n  using const_iterator = FunctionMapTy::const_iterator;\n\n  /// Iterators through all the elements in the graph. Note, this gives\n  /// non-deterministic order.\n  iterator begin() { return FunctionMap.begin(); }\n  iterator end()   { return FunctionMap.end();   }\n  const_iterator begin() const { return FunctionMap.begin(); }\n  const_iterator end()   const { return FunctionMap.end();   }\n\n  /// Get the number of nodes in the graph.\n  unsigned size() const { return FunctionMap.size(); }\n\n  /// Get the virtual root of the graph, all the functions available externally\n  /// are represented as callees of the node.\n  CallGraphNode *getRoot() const { return Root; }\n\n  /// Iterators through all the nodes of the graph that have no parent. These\n  /// are the unreachable nodes, which are either unused or are due to us\n  /// failing to add a call edge due to the analysis imprecision.\n  using nodes_iterator = llvm::SetVector<CallGraphNode *>::iterator;\n  using const_nodes_iterator = llvm::SetVector<CallGraphNode *>::const_iterator;\n\n  void print(raw_ostream &os) const;\n  void dump() const;\n  void viewGraph() const;\n\n  void addNodesForBlocks(DeclContext *D);\n\n  /// Part of recursive declaration visitation. We recursively visit all the\n  /// declarations to collect the root functions.\n  bool VisitFunctionDecl(FunctionDecl *FD) {\n    // We skip function template definitions, as their semantics is\n    // only determined when they are instantiated.\n    if (includeInGraph(FD) && FD->isThisDeclarationADefinition()) {\n      // Add all blocks declared inside this function to the graph.\n      addNodesForBlocks(FD);\n      // If this function has external linkage, anything could call it.\n      // Note, we are not precise here. For example, the function could have\n      // its address taken.\n      addNodeForDecl(FD, FD->isGlobal());\n    }\n    return true;\n  }\n\n  /// Part of recursive declaration visitation.\n  bool VisitObjCMethodDecl(ObjCMethodDecl *MD) {\n    if (includeInGraph(MD)) {\n      addNodesForBlocks(MD);\n      addNodeForDecl(MD, true);\n    }\n    return true;\n  }\n\n  // We are only collecting the declarations, so do not step into the bodies.\n  bool TraverseStmt(Stmt *S) { return true; }\n\n  bool shouldWalkTypesOfTypeLocs() const { return false; }\n  bool shouldVisitTemplateInstantiations() const { return true; }\n  bool shouldVisitImplicitCode() const { return true; }\n\nprivate:\n  /// Add the given declaration to the call graph.\n  void addNodeForDecl(Decl *D, bool IsGlobal);\n};\n\nclass CallGraphNode {\npublic:\n  struct CallRecord {\n    CallGraphNode *Callee;\n    Expr *CallExpr;\n\n    CallRecord() = default;\n\n    CallRecord(CallGraphNode *Callee_, Expr *CallExpr_)\n        : Callee(Callee_), CallExpr(CallExpr_) {}\n\n    // The call destination is the only important data here,\n    // allow to transparently unwrap into it.\n    operator CallGraphNode *() const { return Callee; }\n  };\n\nprivate:\n  /// The function/method declaration.\n  Decl *FD;\n\n  /// The list of functions called from this node.\n  SmallVector<CallRecord, 5> CalledFunctions;\n\npublic:\n  CallGraphNode(Decl *D) : FD(D) {}\n\n  using iterator = SmallVectorImpl<CallRecord>::iterator;\n  using const_iterator = SmallVectorImpl<CallRecord>::const_iterator;\n\n  /// Iterators through all the callees/children of the node.\n  iterator begin() { return CalledFunctions.begin(); }\n  iterator end() { return CalledFunctions.end(); }\n  const_iterator begin() const { return CalledFunctions.begin(); }\n  const_iterator end() const { return CalledFunctions.end(); }\n\n  /// Iterator access to callees/children of the node.\n  llvm::iterator_range<iterator> callees() {\n    return llvm::make_range(begin(), end());\n  }\n  llvm::iterator_range<const_iterator> callees() const {\n    return llvm::make_range(begin(), end());\n  }\n\n  bool empty() const { return CalledFunctions.empty(); }\n  unsigned size() const { return CalledFunctions.size(); }\n\n  void addCallee(CallRecord Call) { CalledFunctions.push_back(Call); }\n\n  Decl *getDecl() const { return FD; }\n\n  FunctionDecl *getDefinition() const {\n    return getDecl()->getAsFunction()->getDefinition();\n  }\n\n  void print(raw_ostream &os) const;\n  void dump() const;\n};\n\n// NOTE: we are comparing based on the callee only. So different call records\n// (with different call expressions) to the same callee will compare equal!\ninline bool operator==(const CallGraphNode::CallRecord &LHS,\n                       const CallGraphNode::CallRecord &RHS) {\n  return LHS.Callee == RHS.Callee;\n}\n\n}",
  "id": "BLOCK-CPP-15615",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Analysis/CallGraph.h",
  "source_line": 30,
  "validation_status": "validated"
}