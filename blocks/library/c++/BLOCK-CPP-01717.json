{
  "code": "#include \"absl/flags/parse.h\"\n#include <stdlib.h>\n#include <algorithm>\n#include <cstdint>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n#include <windows.h>\n#include \"absl/algorithm/container.h\"\n#include \"absl/base/attributes.h\"\n#include \"absl/base/config.h\"\n#include \"absl/base/const_init.h\"\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/flags/commandlineflag.h\"\n#include \"absl/flags/config.h\"\n#include \"absl/flags/flag.h\"\n#include \"absl/flags/internal/commandlineflag.h\"\n#include \"absl/flags/internal/flag.h\"\n#include \"absl/flags/internal/parse.h\"\n#include \"absl/flags/internal/private_handle_accessor.h\"\n#include \"absl/flags/internal/program_name.h\"\n#include \"absl/flags/internal/usage.h\"\n#include \"absl/flags/reflection.h\"\n#include \"absl/flags/usage.h\"\n#include \"absl/flags/usage_config.h\"\n#include \"absl/strings/ascii.h\"\n#include \"absl/strings/internal/damerau_levenshtein_distance.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_join.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/strings/strip.h\"\n#include \"absl/synchronization/mutex.h\"\n\nusing namespace absl;\nusing namespace flags_internal;\nusing namespace flags_internal;\nusing namespace absl;\nusing namespace absl;\nusing namespace flags_internal;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-01717_execute() {\n    {\n  ABSL_INTERNAL_CHECK(argc > 0, \"Missing argv[0]\");\n\n  using flags_internal::ArgsList;\n  using flags_internal::specified_flags;\n\n  std::vector<std::string> flagfile_value;\n  std::vector<ArgsList> input_args;\n\n  // Once parsing has started we will not allow more flag registrations.\n  flags_internal::FinalizeRegistry();\n\n  // This routine does not return anything since we abort on failure.\n  flags_internal::CheckDefaultValuesParsingRoundtrip();\n\n  input_args.push_back(ArgsList(argc, argv));\n\n  // Set program invocation name if it is not set before.\n  if (flags_internal::ProgramInvocationName() == \"UNKNOWN\") {\n    flags_internal::SetProgramInvocationName(argv[0]);\n  }\n  positional_args.push_back(argv[0]);\n\n  absl::MutexLock l(&flags_internal::specified_flags_guard);\n  if (specified_flags == nullptr) {\n    specified_flags = new std::vector<const CommandLineFlag*>;\n  } else {\n    specified_flags->clear();\n  }\n\n  // Iterate through the list of the input arguments. First level are\n  // arguments originated from argc/argv. Following levels are arguments\n  // originated from recursive parsing of flagfile(s).\n  bool success = true;\n  while (!input_args.empty()) {\n    // First we process the built-in generator flags.\n    success &= flags_internal::HandleGeneratorFlags(input_args, flagfile_value);\n\n    // Select top-most (most recent) arguments list. If it is empty drop it\n    // and re-try.\n    ArgsList& curr_list = input_args.back();\n\n    // Every ArgsList starts with real or fake program name, so we can always\n    // start by skipping it.\n    curr_list.PopFront();\n\n    if (curr_list.Size() == 0) {\n      input_args.pop_back();\n      continue;\n    }\n\n    // Handle the next argument in the current list. If the stack of argument\n    // lists contains only one element - we are processing an argument from\n    // the original argv.\n    absl::string_view arg(curr_list.Front());\n    bool arg_from_argv = input_args.size() == 1;\n\n    // If argument does not start with '-' or is just \"-\" - this is\n    // positional argument.\n    if (!absl::ConsumePrefix(&arg, \"-\") || arg.empty()) {\n      ABSL_INTERNAL_CHECK(arg_from_argv,\n                          \"Flagfile cannot contain positional argument\");\n\n      positional_args.push_back(argv[curr_list.FrontIndex()]);\n      continue;\n    }\n\n    // Split the current argument on '=' to deduce the argument flag name and\n    // value. If flag name is empty it means we've got an \"--\" argument. Value\n    // can be empty either if there were no '=' in argument string at all or\n    // an argument looked like \"--foo=\". In a latter case is_empty_value is\n    // true.\n    absl::string_view flag_name;\n    absl::string_view value;\n    bool is_empty_value = false;\n\n    std::tie(flag_name, value, is_empty_value) =\n        flags_internal::SplitNameAndValue(arg);\n\n    // Standalone \"--\" argument indicates that the rest of the arguments are\n    // positional. We do not support positional arguments in flagfiles.\n    if (flag_name.empty()) {\n      ABSL_INTERNAL_CHECK(arg_from_argv,\n                          \"Flagfile cannot contain positional argument\");\n\n      curr_list.PopFront();\n      break;\n    }\n\n    // Locate the flag based on flag name. Handle both --foo and --nofoo.\n    CommandLineFlag* flag = nullptr;\n    bool is_negative = false;\n    std::tie(flag, is_negative) = flags_internal::LocateFlag(flag_name);\n\n    if (flag == nullptr) {\n      // Usage flags are not modeled as Abseil flags. Locate them separately.\n      if (flags_internal::DeduceUsageFlags(flag_name, value)) {\n        continue;\n      }\n      unrecognized_flags.emplace_back(arg_from_argv\n                                          ? UnrecognizedFlag::kFromArgv\n                                          : UnrecognizedFlag::kFromFlagfile,\n                                      flag_name);\n      continue;\n    }\n\n    // Deduce flag's value (from this or next argument).\n    bool value_success = true;\n    std::tie(value_success, value) = flags_internal::DeduceFlagValue(\n        *flag, value, is_negative, is_empty_value, &curr_list);\n    success &= value_success;\n\n    // Set the located flag to a new value, unless it is retired. Setting\n    // retired flag fails, but we ignoring it here while also reporting access\n    // to retired flag.\n    std::string error;\n    if (!flags_internal::PrivateHandleAccessor::ParseFrom(\n            *flag, value, flags_internal::SET_FLAGS_VALUE,\n            flags_internal::kCommandLine, error)) {\n      if (flag->IsRetired()) continue;\n\n      flags_internal::ReportUsageError(error, true);\n      success = false;\n    } else {\n      specified_flags->push_back(flag);\n    }\n  }\n\n  flags_internal::ResetGeneratorFlags(flagfile_value);\n\n  // All the remaining arguments are positional.\n  if (!input_args.empty()) {\n    for (size_t arg_index = input_args.back().FrontIndex();\n         arg_index < static_cast<size_t>(argc); ++arg_index) {\n      positional_args.push_back(argv[arg_index]);\n    }\n  }\n\n  // Trim and sort the vector.\n  specified_flags->shrink_to_fit();\n  std::sort(specified_flags->begin(), specified_flags->end(),\n            flags_internal::SpecifiedFlagsCompare{});\n\n  // Filter out unrecognized flags, which are ok to ignore.\n  std::vector<UnrecognizedFlag> filtered;\n  filtered.reserve(unrecognized_flags.size());\n  for (const auto& unrecognized : unrecognized_flags) {\n    if (flags_internal::CanIgnoreUndefinedFlag(unrecognized.flag_name))\n      continue;\n    filtered.push_back(unrecognized);\n  }\n\n  std::swap(unrecognized_flags, filtered);\n\n  if (!success) {\n#if ABSL_FLAGS_STRIP_NAMES\n    flags_internal::ReportUsageError(\n        \"NOTE: command line flags are disabled in this build\", true);\n#else\n    flags_internal::HandleUsageFlags(std::cerr, ProgramUsageMessage());\n#endif\n    return HelpMode::kFull;  // We just need to make sure the exit with\n                             // code 1.\n  }\n\n  return usage_flag_action == UsageFlagsAction::kHandleUsage\n             ? flags_internal::HandleUsageFlags(std::cout,\n                                                ProgramUsageMessage())\n             : HelpMode::kNone;\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-01717",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/flags/parse.cc",
  "source_line": 741,
  "validation_status": "validated"
}