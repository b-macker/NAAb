{
  "code": "#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <memory>\n#include <utility>\n\nusing namespace llvm;\nusing namespace clang;\nusing namespace serialization;\n\nextern \"C\" {\n\nvoid BLOCK-CPP-21010_execute() {\n    {\n  using ModuleFile = serialization::ModuleFile;\n\n  /// Buffer containing the index file, which is lazily accessed so long\n  /// as the global module index is live.\n  std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\n  /// The hash table.\n  ///\n  /// This pointer actually points to a IdentifierIndexTable object,\n  /// but that type is only accessible within the implementation of\n  /// GlobalModuleIndex.\n  void *IdentifierIndex;\n\n  /// Information about a given module file.\n  struct ModuleInfo {\n    ModuleInfo() : File(), Size(), ModTime() { }\n\n    /// The module file, once it has been resolved.\n    ModuleFile *File;\n\n    /// The module file name.\n    std::string FileName;\n\n    /// Size of the module file at the time the global index was built.\n    off_t Size;\n\n    /// Modification time of the module file at the time the global\n    /// index was built.\n    time_t ModTime;\n\n    /// The module IDs on which this module directly depends.\n    /// FIXME: We don't really need a vector here.\n    llvm::SmallVector<unsigned, 4> Dependencies;\n  };\n\n  /// A mapping from module IDs to information about each module.\n  ///\n  /// This vector may have gaps, if module files have been removed or have\n  /// been updated since the index was built. A gap is indicated by an empty\n  /// file name.\n  llvm::SmallVector<ModuleInfo, 16> Modules;\n\n  /// Lazily-populated mapping from module files to their\n  /// corresponding index into the \\c Modules vector.\n  llvm::DenseMap<ModuleFile *, unsigned> ModulesByFile;\n\n  /// The set of modules that have not yet been resolved.\n  ///\n  /// The string is just the name of the module itself, which maps to the\n  /// module ID.\n  llvm::StringMap<unsigned> UnresolvedModules;\n\n  /// The number of identifier lookups we performed.\n  unsigned NumIdentifierLookups;\n\n  /// The number of identifier lookup hits, where we recognize the\n  /// identifier.\n  unsigned NumIdentifierLookupHits;\n\n  /// Internal constructor. Use \\c readIndex() to read an index.\n  explicit GlobalModuleIndex(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n                             llvm::BitstreamCursor Cursor);\n\n  GlobalModuleIndex(const GlobalModuleIndex &) = delete;\n  GlobalModuleIndex &operator=(const GlobalModuleIndex &) = delete;\n\npublic:\n  ~GlobalModuleIndex();\n\n  /// Read a global index file for the given directory.\n  ///\n  /// \\param Path The path to the specific module cache where the module files\n  /// for the intended configuration reside.\n  ///\n  /// \\returns A pair containing the global module index (if it exists) and\n  /// the error.\n  static std::pair<GlobalModuleIndex *, llvm::Error>\n  readIndex(llvm::StringRef Path);\n\n  /// Returns an iterator for identifiers stored in the index table.\n  ///\n  /// The caller accepts ownership of the returned object.\n  IdentifierIterator *createIdentifierIterator() const;\n\n  /// Retrieve the set of module files on which the given module file\n  /// directly depends.\n  void getModuleDependencies(ModuleFile *File,\n                             llvm::SmallVectorImpl<ModuleFile *> &Dependencies);\n\n  /// A set of module files in which we found a result.\n  typedef llvm::SmallPtrSet<ModuleFile *, 4> HitSet;\n\n  /// Look for all of the module files with information about the given\n  /// identifier, e.g., a global function, variable, or type with that name.\n  ///\n  /// \\param Name The identifier to look for.\n  ///\n  /// \\param Hits Will be populated with the set of module files that have\n  /// information about this name.\n  ///\n  /// \\returns true if the identifier is known to the index, false otherwise.\n  bool lookupIdentifier(llvm::StringRef Name, HitSet &Hits);\n\n  /// Note that the given module file has been loaded.\n  ///\n  /// \\returns false if the global module index has information about this\n  /// module file, and true otherwise.\n  bool loadedModuleFile(ModuleFile *File);\n\n  /// Print statistics to standard error.\n  void printStats();\n\n  /// Print debugging view to standard error.\n  void dump();\n\n  /// Write a global index into the given\n  ///\n  /// \\param FileMgr The file manager to use to load module files.\n  /// \\param PCHContainerRdr - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  /// \\param Path The path to the directory containing module files, into\n  /// which the global index will be written.\n  static llvm::Error writeIndex(FileManager &FileMgr,\n                                const PCHContainerReader &PCHContainerRdr,\n                                llvm::StringRef Path);\n}\n}\n\n} // extern \"C\"\n",
  "id": "BLOCK-CPP-21010",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Serialization/GlobalModuleIndex.h",
  "source_line": 54,
  "validation_status": "validated"
}