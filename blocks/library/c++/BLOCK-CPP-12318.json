{
  "code": "{\npublic:\n  ParentMapContext(ASTContext &Ctx);\n\n  ~ParentMapContext();\n\n  /// Returns the parents of the given node (within the traversal scope).\n  ///\n  /// Note that this will lazily compute the parents of all nodes\n  /// and store them for later retrieval. Thus, the first call is O(n)\n  /// in the number of AST nodes.\n  ///\n  /// Caveats and FIXMEs:\n  /// Calculating the parent map over all AST nodes will need to load the\n  /// full AST. This can be undesirable in the case where the full AST is\n  /// expensive to create (for example, when using precompiled header\n  /// preambles). Thus, there are good opportunities for optimization here.\n  /// One idea is to walk the given node downwards, looking for references\n  /// to declaration contexts - once a declaration context is found, compute\n  /// the parent map for the declaration context; if that can satisfy the\n  /// request, loading the whole AST can be avoided. Note that this is made\n  /// more complex by statements in templates having multiple parents - those\n  /// problems can be solved by building closure over the templated parts of\n  /// the AST, which also avoids touching large parts of the AST.\n  /// Additionally, we will want to add an interface to already give a hint\n  /// where to search for the parents, for example when looking at a statement\n  /// inside a certain function.\n  ///\n  /// 'NodeT' can be one of Decl, Stmt, Type, TypeLoc,\n  /// NestedNameSpecifier or NestedNameSpecifierLoc.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  DynTypedNodeList getParents(const DynTypedNode &Node);\n\n  /// Clear parent maps.\n  void clear();\n\n  TraversalKind getTraversalKind() const { return Traversal; }\n  void setTraversalKind(TraversalKind TK) { Traversal = TK; }\n\n  const Expr *traverseIgnored(const Expr *E) const;\n  Expr *traverseIgnored(Expr *E) const;\n  DynTypedNode traverseIgnored(const DynTypedNode &N) const;\n\n  class ParentMap;\n\nprivate:\n  ASTContext &ASTCtx;\n  TraversalKind Traversal = TK_AsIs;\n  std::unique_ptr<ParentMap> Parents;\n}",
  "id": "BLOCK-CPP-12318",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/ParentMapContext.h",
  "source_line": 23,
  "validation_status": "validated"
}