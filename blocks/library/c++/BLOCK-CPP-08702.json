{
  "code": "{\n  void anchor() override;\n\nprivate:\n  CXXDeductionGuideDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                        ExplicitSpecifier ES,\n                        const DeclarationNameInfo &NameInfo, QualType T,\n                        TypeSourceInfo *TInfo, SourceLocation EndLocation,\n                        CXXConstructorDecl *Ctor, DeductionCandidate Kind)\n      : FunctionDecl(CXXDeductionGuide, C, DC, StartLoc, NameInfo, T, TInfo,\n                     SC_None, false, false, ConstexprSpecKind::Unspecified),\n        Ctor(Ctor), ExplicitSpec(ES) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n    setDeductionCandidateKind(Kind);\n  }\n\n  CXXConstructorDecl *Ctor;\n  ExplicitSpecifier ExplicitSpec;\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXDeductionGuideDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         ExplicitSpecifier ES, const DeclarationNameInfo &NameInfo, QualType T,\n         TypeSourceInfo *TInfo, SourceLocation EndLocation,\n         CXXConstructorDecl *Ctor = nullptr,\n         DeductionCandidate Kind = DeductionCandidate::Normal);\n\n  static CXXDeductionGuideDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() { return ExplicitSpec; }\n  const ExplicitSpecifier getExplicitSpecifier() const { return ExplicitSpec; }\n\n  /// Return true if the declaration is already resolved to be explicit.\n  bool isExplicit() const { return ExplicitSpec.isExplicit(); }\n\n  /// Get the template for which this guide performs deduction.\n  TemplateDecl *getDeducedTemplate() const {\n    return getDeclName().getCXXDeductionGuideTemplate();\n  }\n\n  /// Get the constructor from which this deduction guide was generated, if\n  /// this is an implicit deduction guide.\n  CXXConstructorDecl *getCorrespondingConstructor() const { return Ctor; }\n\n  void setDeductionCandidateKind(DeductionCandidate K) {\n    FunctionDeclBits.DeductionCandidateKind = static_cast<unsigned char>(K);\n  }\n\n  DeductionCandidate getDeductionCandidateKind() const {\n    return static_cast<DeductionCandidate>(\n        FunctionDeclBits.DeductionCandidateKind);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDeductionGuide; }\n}",
  "id": "BLOCK-CPP-08702",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/AST/DeclCXX.h",
  "source_line": 1937,
  "validation_status": "validated"
}