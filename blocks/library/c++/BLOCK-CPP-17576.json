{
  "code": "{\nprotected:\n  ConstantInitBuilderBase &Builder;\n  ConstantAggregateBuilderBase *Parent;\n  size_t Begin;\n  mutable size_t CachedOffsetEnd = 0;\n  bool Finished = false;\n  bool Frozen = false;\n  bool Packed = false;\n  mutable CharUnits CachedOffsetFromGlobal;\n\n  llvm::SmallVectorImpl<llvm::Constant*> &getBuffer() {\n    return Builder.Buffer;\n  }\n\n  const llvm::SmallVectorImpl<llvm::Constant*> &getBuffer() const {\n    return Builder.Buffer;\n  }\n\n  ConstantAggregateBuilderBase(ConstantInitBuilderBase &builder,\n                               ConstantAggregateBuilderBase *parent)\n      : Builder(builder), Parent(parent), Begin(builder.Buffer.size()) {\n    if (parent) {\n      assert(!parent->Frozen && \"parent already has child builder active\");\n      parent->Frozen = true;\n    } else {\n      assert(!builder.Frozen && \"builder already has child builder active\");\n      builder.Frozen = true;\n    }\n  }\n\n  ~ConstantAggregateBuilderBase() {\n    assert(Finished && \"didn't finish aggregate builder\");\n  }\n\n  void markFinished() {\n    assert(!Frozen && \"child builder still active\");\n    assert(!Finished && \"builder already finished\");\n    Finished = true;\n    if (Parent) {\n      assert(Parent->Frozen &&\n             \"parent not frozen while child builder active\");\n      Parent->Frozen = false;\n    } else {\n      assert(Builder.Frozen &&\n             \"builder not frozen while child builder active\");\n      Builder.Frozen = false;\n    }\n  }\n\npublic:\n  // Not copyable.\n  ConstantAggregateBuilderBase(const ConstantAggregateBuilderBase &) = delete;\n  ConstantAggregateBuilderBase &operator=(const ConstantAggregateBuilderBase &)\n    = delete;\n\n  // Movable, mostly to allow returning.  But we have to write this out\n  // properly to satisfy the assert in the destructor.\n  ConstantAggregateBuilderBase(ConstantAggregateBuilderBase &&other)\n    : Builder(other.Builder), Parent(other.Parent), Begin(other.Begin),\n      CachedOffsetEnd(other.CachedOffsetEnd),\n      Finished(other.Finished), Frozen(other.Frozen), Packed(other.Packed),\n      CachedOffsetFromGlobal(other.CachedOffsetFromGlobal) {\n    other.Finished = true;\n  }\n  ConstantAggregateBuilderBase &operator=(ConstantAggregateBuilderBase &&other)\n    = delete;\n\n  /// Return the number of elements that have been added to\n  /// this struct or array.\n  size_t size() const {\n    assert(!this->Finished && \"cannot query after finishing builder\");\n    assert(!this->Frozen && \"cannot query while sub-builder is active\");\n    assert(this->Begin <= this->getBuffer().size());\n    return this->getBuffer().size() - this->Begin;\n  }\n\n  /// Return true if no elements have yet been added to this struct or array.\n  bool empty() const {\n    return size() == 0;\n  }\n\n  /// Abandon this builder completely.\n  void abandon() {\n    markFinished();\n    Builder.abandon(Begin);\n  }\n\n  /// Add a new value to this initializer.\n  void add(llvm::Constant *value) {\n    assert(value && \"adding null value to constant initializer\");\n    assert(!Finished && \"cannot add more values after finishing builder\");\n    assert(!Frozen && \"cannot add values while subbuilder is active\");\n    Builder.Buffer.push_back(value);\n  }\n\n  /// Add an integer value of type size_t.\n  void addSize(CharUnits size);\n\n  /// Add an integer value of a specific type.\n  void addInt(llvm::IntegerType *intTy, uint64_t value,\n              bool isSigned = false) {\n    add(llvm::ConstantInt::get(intTy, value, isSigned));\n  }\n\n  /// Add a null pointer of a specific type.\n  void addNullPointer(llvm::PointerType *ptrTy) {\n    add(llvm::ConstantPointerNull::get(ptrTy));\n  }\n\n  /// Add a bitcast of a value to a specific type.\n  void addBitCast(llvm::Constant *value, llvm::Type *type) {\n    add(llvm::ConstantExpr::getBitCast(value, type));\n  }\n\n  /// Add a bunch of new values to this initializer.\n  void addAll(llvm::ArrayRef<llvm::Constant *> values) {\n    assert(!Finished && \"cannot add more values after finishing builder\");\n    assert(!Frozen && \"cannot add values while subbuilder is active\");\n    Builder.Buffer.append(values.begin(), values.end());\n  }\n\n  /// Add a relative offset to the given target address, i.e. the\n  /// static difference between the target address and the address\n  /// of the relative offset.  The target must be known to be defined\n  /// in the current linkage unit.  The offset will have the given\n  /// integer type, which must be no wider than intptr_t.  Some\n  /// targets may not fully support this operation.\n  void addRelativeOffset(llvm::IntegerType *type, llvm::Constant *target) {\n    add(getRelativeOffset(type, target));\n  }\n\n  /// Same as addRelativeOffset(), but instead relative to an element in this\n  /// aggregate, identified by its index.\n  void addRelativeOffsetToPosition(llvm::IntegerType *type,\n                                   llvm::Constant *target, size_t position) {\n    add(getRelativeOffsetToPosition(type, target, position));\n  }\n\n  /// Add a relative offset to the target address, plus a small\n  /// constant offset.  This is primarily useful when the relative\n  /// offset is known to be a multiple of (say) four and therefore\n  /// the tag can be used to express an extra two bits of information.\n  void addTaggedRelativeOffset(llvm::IntegerType *type,\n                               llvm::Constant *address,\n                               unsigned tag) {\n    llvm::Constant *offset = getRelativeOffset(type, address);\n    if (tag) {\n      offset = llvm::ConstantExpr::getAdd(offset,\n                                          llvm::ConstantInt::get(type, tag));\n    }\n    add(offset);\n  }\n\n  /// Return the offset from the start of the initializer to the\n  /// next position, assuming no padding is required prior to it.\n  ///\n  /// This operation will not succeed if any unsized placeholders are\n  /// currently in place in the initializer.\n  CharUnits getNextOffsetFromGlobal() const {\n    assert(!Finished && \"cannot add more values after finishing builder\");\n    assert(!Frozen && \"cannot add values while subbuilder is active\");\n    return getOffsetFromGlobalTo(Builder.Buffer.size());\n  }\n\n  /// An opaque class to hold the abstract position of a placeholder.\n  class PlaceholderPosition {\n    size_t Index;\n    friend class ConstantAggregateBuilderBase;\n    PlaceholderPosition(size_t index) : Index(index) {}\n  };\n\n  /// Add a placeholder value to the structure.  The returned position\n  /// can be used to set the value later; it will not be invalidated by\n  /// any intermediate operations except (1) filling the same position or\n  /// (2) finishing the entire builder.\n  ///\n  /// This is useful for emitting certain kinds of structure which\n  /// contain some sort of summary field, generally a count, before any\n  /// of the data.  By emitting a placeholder first, the structure can\n  /// be emitted eagerly.\n  PlaceholderPosition addPlaceholder() {\n    assert(!Finished && \"cannot add more values after finishing builder\");\n    assert(!Frozen && \"cannot add values while subbuilder is active\");\n    Builder.Buffer.push_back(nullptr);\n    return Builder.Buffer.size() - 1;\n  }\n\n  /// Add a placeholder, giving the expected type that will be filled in.\n  PlaceholderPosition addPlaceholderWithSize(llvm::Type *expectedType);\n\n  /// Fill a previously-added placeholder.\n  void fillPlaceholderWithInt(PlaceholderPosition position,\n                              llvm::IntegerType *type, uint64_t value,\n                              bool isSigned = false) {\n    fillPlaceholder(position, llvm::ConstantInt::get(type, value, isSigned));\n  }\n\n  /// Fill a previously-added placeholder.\n  void fillPlaceholder(PlaceholderPosition position, llvm::Constant *value) {\n    assert(!Finished && \"cannot change values after finishing builder\");\n    assert(!Frozen && \"cannot add values while subbuilder is active\");\n    llvm::Constant *&slot = Builder.Buffer[position.Index];\n    assert(slot == nullptr && \"placeholder already filled\");\n    slot = value;\n  }\n\n  /// Produce an address which will eventually point to the next\n  /// position to be filled.  This is computed with an indexed\n  /// getelementptr rather than by computing offsets.\n  ///\n  /// The returned pointer will have type T*, where T is the given type. This\n  /// type can differ from the type of the actual element.\n  llvm::Constant *getAddrOfCurrentPosition(llvm::Type *type);\n\n  /// Produce an address which points to a position in the aggregate being\n  /// constructed. This is computed with an indexed getelementptr rather than by\n  /// computing offsets.\n  ///\n  /// The returned pointer will have type T*, where T is the given type. This\n  /// type can differ from the type of the actual element.\n  llvm::Constant *getAddrOfPosition(llvm::Type *type, size_t position);\n\n  llvm::ArrayRef<llvm::Constant*> getGEPIndicesToCurrentPosition(\n                           llvm::SmallVectorImpl<llvm::Constant*> &indices) {\n    getGEPIndicesTo(indices, Builder.Buffer.size());\n    return indices;\n  }\n\nprotected:\n  llvm::Constant *finishArray(llvm::Type *eltTy);\n  llvm::Constant *finishStruct(llvm::StructType *structTy);\n\nprivate:\n  void getGEPIndicesTo(llvm::SmallVectorImpl<llvm::Constant*> &indices,\n                       size_t position) const;\n\n  llvm::Constant *getRelativeOffset(llvm::IntegerType *offsetType,\n                                    llvm::Constant *target);\n\n  llvm::Constant *getRelativeOffsetToPosition(llvm::IntegerType *offsetType,\n                                              llvm::Constant *target,\n                                              size_t position);\n\n  CharUnits getOffsetFromGlobalTo(size_t index) const;\n}",
  "id": "BLOCK-CPP-17576",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/CodeGen/ConstantInitBuilder.h",
  "source_line": 97,
  "validation_status": "validated"
}