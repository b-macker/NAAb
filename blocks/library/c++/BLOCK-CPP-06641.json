{
  "code": "{\n\n// This tag type is used as a constructor parameter type for `nullopt_t`.\nstruct init_t {\n  explicit init_t() = default;\n};\n\nstruct empty_struct {};\n\n// This class stores the data in optional<T>.\n// It is specialized based on whether T is trivially destructible.\n// This is the specialization for non trivially destructible type.\ntemplate <typename T, bool unused = std::is_trivially_destructible<T>::value>\nclass optional_data_dtor_base {\n  struct dummy_type {\n    static_assert(sizeof(T) % sizeof(empty_struct) == 0, \"\");\n    // Use an array to avoid GCC 6 placement-new warning.\n    empty_struct data[sizeof(T) / sizeof(empty_struct)];\n  };\n\n protected:\n  // Whether there is data or not.\n  bool engaged_;\n  // Data storage\n  union {\n    T data_;\n    dummy_type dummy_;\n  };\n\n  void destruct() noexcept {\n    if (engaged_) {\n      // `data_` must be initialized if `engaged_` is true.\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n      data_.~T();\n#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)\n#pragma GCC diagnostic pop\n#endif\n      engaged_ = false;\n    }\n  }\n\n  // dummy_ must be initialized for constexpr constructor.\n  constexpr optional_data_dtor_base() noexcept : engaged_(false), dummy_{{}} {}\n\n  template <typename... Args>\n  constexpr explicit optional_data_dtor_base(in_place_t, Args&&... args)\n      : engaged_(true), data_(absl::forward<Args>(args)...) {}\n\n  ~optional_data_dtor_base() { destruct(); }\n};\n\n// Specialization for trivially destructible type.\ntemplate <typename T>\nclass optional_data_dtor_base<T, true> {\n  struct dummy_type {\n    static_assert(sizeof(T) % sizeof(empty_struct) == 0, \"\");\n    // Use array to avoid GCC 6 placement-new warning.\n    empty_struct data[sizeof(T) / sizeof(empty_struct)];\n  };\n\n protected:\n  // Whether there is data or not.\n  bool engaged_;\n  // Data storage\n  union {\n    T data_;\n    dummy_type dummy_;\n  };\n  void destruct() noexcept { engaged_ = false; }\n\n  // dummy_ must be initialized for constexpr constructor.\n  constexpr optional_data_dtor_base() noexcept : engaged_(false), dummy_{{}} {}\n\n  template <typename... Args>\n  constexpr explicit optional_data_dtor_base(in_place_t, Args&&... args)\n      : engaged_(true), data_(absl::forward<Args>(args)...) {}\n};\n\ntemplate <typename T>\nclass optional_data_base : public optional_data_dtor_base<T> {\n protected:\n  using base = optional_data_dtor_base<T>;\n  using base::base;\n\n  template <typename... Args>\n  void construct(Args&&... args) {\n    // Use dummy_'s address to work around casting cv-qualified T* to void*.\n    ::new (static_cast<void*>(&this->dummy_)) T(std::forward<Args>(args)...);\n    this->engaged_ = true;\n  }\n\n  template <typename U>\n  void assign(U&& u) {\n    if (this->engaged_) {\n      this->data_ = std::forward<U>(u);\n    } else {\n      construct(std::forward<U>(u));\n    }\n  }\n};\n\n// TODO(absl-team): Add another class using\n// std::is_trivially_move_constructible trait when available to match\n// http://cplusplus.github.io/LWG/lwg-defects.html#2900, for types that\n// have trivial move but nontrivial copy.\n// Also, we should be checking is_trivially_copyable here, which is not\n// supported now, so we use is_trivially_* traits instead.\ntemplate <typename T,\n          bool unused = absl::is_trivially_copy_constructible<T>::value&&\n              absl::is_trivially_copy_assignable<typename std::remove_cv<\n                  T>::type>::value&& std::is_trivially_destructible<T>::value>\nclass optional_data;\n\n// Trivially copyable types\ntemplate <typename T>\nclass optional_data<T, true> : public optional_data_base<T> {\n protected:\n  using optional_data_base<T>::optional_data_base;\n};\n\ntemplate <typename T>\nclass optional_data<T, false> : public optional_data_base<T> {\n protected:\n  using optional_data_base<T>::optional_data_base;\n\n  optional_data() = default;\n\n  optional_data(const optional_data& rhs) : optional_data_base<T>() {\n    if (rhs.engaged_) {\n      this->construct(rhs.data_);\n    }\n  }\n\n  optional_data(optional_data&& rhs) noexcept(\n      absl::default_allocator_is_nothrow::value ||\n      std::is_nothrow_move_constructible<T>::value)\n      : optional_data_base<T>() {\n    if (rhs.engaged_) {\n      this->construct(std::move(rhs.data_));\n    }\n  }\n\n  optional_data& operator=(const optional_data& rhs) {\n    if (rhs.engaged_) {\n      this->assign(rhs.data_);\n    } else {\n      this->destruct();\n    }\n    return *this;\n  }\n\n  optional_data& operator=(optional_data&& rhs) noexcept(\n      std::is_nothrow_move_assignable<T>::value&&\n          std::is_nothrow_move_constructible<T>::value) {\n    if (rhs.engaged_) {\n      this->assign(std::move(rhs.data_));\n    } else {\n      this->destruct();\n    }\n    return *this;\n  }\n};\n\n// Ordered by level of restriction, from low to high.\n// Copyable implies movable.\nenum class copy_traits { copyable = 0, movable = 1, non_movable = 2 };\n\n// Base class for enabling/disabling copy/move constructor.\ntemplate <copy_traits>\nclass optional_ctor_base;\n\ntemplate <>\nclass optional_ctor_base<copy_traits::copyable> {\n public:\n  constexpr optional_ctor_base() = default;\n  optional_ctor_base(const optional_ctor_base&) = default;\n  optional_ctor_base(optional_ctor_base&&) = default;\n  optional_ctor_base& operator=(const optional_ctor_base&) = default;\n  optional_ctor_base& operator=(optional_ctor_base&&) = default;\n};\n\ntemplate <>\nclass optional_ctor_base<copy_traits::movable> {\n public:\n  constexpr optional_ctor_base() = default;\n  optional_ctor_base(const optional_ctor_base&) = delete;\n  optional_ctor_base(optional_ctor_base&&) = default;\n  optional_ctor_base& operator=(const optional_ctor_base&) = default;\n  optional_ctor_base& operator=(optional_ctor_base&&) = default;\n};\n\ntemplate <>\nclass optional_ctor_base<copy_traits::non_movable> {\n public:\n  constexpr optional_ctor_base() = default;\n  optional_ctor_base(const optional_ctor_base&) = delete;\n  optional_ctor_base(optional_ctor_base&&) = delete;\n  optional_ctor_base& operator=(const optional_ctor_base&) = default;\n  optional_ctor_base& operator=(optional_ctor_base&&) = default;\n};\n\n// Base class for enabling/disabling copy/move assignment.\ntemplate <copy_traits>\nclass optional_assign_base;\n\ntemplate <>\nclass optional_assign_base<copy_traits::copyable> {\n public:\n  constexpr optional_assign_base() = default;\n  optional_assign_base(const optional_assign_base&) = default;\n  optional_assign_base(optional_assign_base&&) = default;\n  optional_assign_base& operator=(const optional_assign_base&) = default;\n  optional_assign_base& operator=(optional_assign_base&&) = default;\n};\n\ntemplate <>\nclass optional_assign_base<copy_traits::movable> {\n public:\n  constexpr optional_assign_base() = default;\n  optional_assign_base(const optional_assign_base&) = default;\n  optional_assign_base(optional_assign_base&&) = default;\n  optional_assign_base& operator=(const optional_assign_base&) = delete;\n  optional_assign_base& operator=(optional_assign_base&&) = default;\n};\n\ntemplate <>\nclass optional_assign_base<copy_traits::non_movable> {\n public:\n  constexpr optional_assign_base() = default;\n  optional_assign_base(const optional_assign_base&) = default;\n  optional_assign_base(optional_assign_base&&) = default;\n  optional_assign_base& operator=(const optional_assign_base&) = delete;\n  optional_assign_base& operator=(optional_assign_base&&) = delete;\n};\n\ntemplate <typename T>\nstruct ctor_copy_traits {\n  static constexpr copy_traits traits =\n      std::is_copy_constructible<T>::value\n          ? copy_traits::copyable\n          : std::is_move_constructible<T>::value ? copy_traits::movable\n                                                 : copy_traits::non_movable;\n};\n\ntemplate <typename T>\nstruct assign_copy_traits {\n  static constexpr copy_traits traits =\n      absl::is_copy_assignable<T>::value && std::is_copy_constructible<T>::value\n          ? copy_traits::copyable\n          : absl::is_move_assignable<T>::value &&\n                    std::is_move_constructible<T>::value\n                ? copy_traits::movable\n                : copy_traits::non_movable;\n};\n\n// Whether T is constructible or convertible from optional<U>.\ntemplate <typename T, typename U>\nstruct is_constructible_convertible_from_optional\n    : std::integral_constant<\n          bool, std::is_constructible<T, optional<U>&>::value ||\n                    std::is_constructible<T, optional<U>&&>::value ||\n                    std::is_constructible<T, const optional<U>&>::value ||\n                    std::is_constructible<T, const optional<U>&&>::value ||\n                    std::is_convertible<optional<U>&, T>::value ||\n                    std::is_convertible<optional<U>&&, T>::value ||\n                    std::is_convertible<const optional<U>&, T>::value ||\n                    std::is_convertible<const optional<U>&&, T>::value> {};\n\n// Whether T is constructible or convertible or assignable from optional<U>.\ntemplate <typename T, typename U>\nstruct is_constructible_convertible_assignable_from_optional\n    : std::integral_constant<\n          bool, is_constructible_convertible_from_optional<T, U>::value ||\n                    std::is_assignable<T&, optional<U>&>::value ||\n                    std::is_assignable<T&, optional<U>&&>::value ||\n                    std::is_assignable<T&, const optional<U>&>::value ||\n                    std::is_assignable<T&, const optional<U>&&>::value> {};\n\n// Helper function used by [optional.relops], [optional.comp_with_t],\n// for checking whether an expression is convertible to bool.\nbool convertible_to_bool(bool);\n\n// Base class for std::hash<absl::optional<T>>:\n// If std::hash<std::remove_const_t<T>> is enabled, it provides operator() to\n// compute the hash; Otherwise, it is disabled.\n// Reference N4659 23.14.15 [unord.hash].\ntemplate <typename T, typename = size_t>\nstruct optional_hash_base {\n  optional_hash_base() = delete;\n  optional_hash_base(const optional_hash_base&) = delete;\n  optional_hash_base(optional_hash_base&&) = delete;\n  optional_hash_base& operator=(const optional_hash_base&) = delete;\n  optional_hash_base& operator=(optional_hash_base&&) = delete;\n};\n\ntemplate <typename T>\nstruct optional_hash_base<T, decltype(std::hash<absl::remove_const_t<T> >()(\n                                 std::declval<absl::remove_const_t<T> >()))> {\n  using argument_type = absl::optional<T>;\n  using result_type = size_t;\n  size_t operator()(const absl::optional<T>& opt) const {\n    absl::type_traits_internal::AssertHashEnabled<absl::remove_const_t<T>>();\n    if (opt) {\n      return std::hash<absl::remove_const_t<T> >()(*opt);\n    } else {\n      return static_cast<size_t>(0x297814aaad196e6dULL);\n    }\n  }\n};\n\n}",
  "id": "BLOCK-CPP-06641",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/types/internal/optional.h",
  "source_line": 35,
  "validation_status": "validated"
}