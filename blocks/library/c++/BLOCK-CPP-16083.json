{
  "code": "{\npublic:\n  enum InliningMethod {\n    NormalInlining,     // Use the standard function inlining pass.\n    OnlyHintInlining,   // Inline only (implicitly) hinted functions.\n    OnlyAlwaysInlining  // Only run the always inlining pass.\n  };\n\n  enum VectorLibrary {\n    NoLibrary,  // Don't use any vector library.\n    Accelerate, // Use the Accelerate framework.\n    LIBMVEC,    // GLIBC vector math library.\n    MASSV,      // IBM MASS vector library.\n    SVML,       // Intel short vector math library.\n    SLEEF,      // SLEEF SIMD Library for Evaluating Elementary Functions.\n    Darwin_libsystem_m, // Use Darwin's libsytem_m vector functions.\n    ArmPL               // Arm Performance Libraries.\n  };\n\n  enum ObjCDispatchMethodKind {\n    Legacy = 0,\n    NonLegacy = 1,\n    Mixed = 2\n  };\n\n  enum TLSModel {\n    GeneralDynamicTLSModel,\n    LocalDynamicTLSModel,\n    InitialExecTLSModel,\n    LocalExecTLSModel\n  };\n\n  enum StructReturnConventionKind {\n    SRCK_Default,  // No special option was passed.\n    SRCK_OnStack,  // Small structs on the stack (-fpcc-struct-return).\n    SRCK_InRegs    // Small structs in registers (-freg-struct-return).\n  };\n\n  enum ProfileInstrKind {\n    ProfileNone,       // Profile instrumentation is turned off.\n    ProfileClangInstr, // Clang instrumentation to generate execution counts\n                       // to use with PGO.\n    ProfileIRInstr,    // IR level PGO instrumentation in LLVM.\n    ProfileCSIRInstr, // IR level PGO context sensitive instrumentation in LLVM.\n  };\n\n  enum EmbedBitcodeKind {\n    Embed_Off,      // No embedded bitcode.\n    Embed_All,      // Embed both bitcode and commandline in the output.\n    Embed_Bitcode,  // Embed just the bitcode in the output.\n    Embed_Marker    // Embed a marker as a placeholder for bitcode.\n  };\n\n  enum InlineAsmDialectKind {\n    IAD_ATT,\n    IAD_Intel,\n  };\n\n  enum DebugSrcHashKind {\n    DSH_MD5,\n    DSH_SHA1,\n    DSH_SHA256,\n  };\n\n  // This field stores one of the allowed values for the option\n  // -fbasic-block-sections=.  The allowed values with this option are:\n  // {\"labels\", \"all\", \"list=<file>\", \"none\"}.\n  //\n  // \"labels\":      Only generate basic block symbols (labels) for all basic\n  //                blocks, do not generate unique sections for basic blocks.\n  //                Use the machine basic block id in the symbol name to\n  //                associate profile info from virtual address to machine\n  //                basic block.\n  // \"all\" :        Generate basic block sections for all basic blocks.\n  // \"list=<file>\": Generate basic block sections for a subset of basic blocks.\n  //                The functions and the machine basic block ids are specified\n  //                in the file.\n  // \"none\":        Disable sections/labels for basic blocks.\n  std::string BBSections;\n\n  // If set, override the default value of MCAsmInfo::BinutilsVersion. If\n  // DisableIntegratedAS is specified, the assembly output will consider GNU as\n  // support. \"none\" means that all ELF features can be used, regardless of\n  // binutils support.\n  std::string BinutilsVersion;\n\n  enum class FramePointerKind {\n    None,        // Omit all frame pointers.\n    NonLeaf,     // Keep non-leaf frame pointers.\n    All,         // Keep all frame pointers.\n  };\n\n  static StringRef getFramePointerKindName(FramePointerKind Kind) {\n    switch (Kind) {\n    case FramePointerKind::None:\n      return \"none\";\n    case FramePointerKind::NonLeaf:\n      return \"non-leaf\";\n    case FramePointerKind::All:\n      return \"all\";\n    }\n\n    llvm_unreachable(\"invalid FramePointerKind\");\n  }\n\n  enum class SwiftAsyncFramePointerKind {\n    Auto, // Choose Swift async extended frame info based on deployment target.\n    Always, // Unconditionally emit Swift async extended frame info.\n    Never,  // Don't emit Swift async extended frame info.\n    Default = Always,\n  };\n\n  enum FiniteLoopsKind {\n    Language, // Not specified, use language standard.\n    Always,   // All loops are assumed to be finite.\n    Never,    // No loop is assumed to be finite.\n  };\n\n  enum AssignmentTrackingOpts {\n    Disabled,\n    Enabled,\n    Forced,\n  };\n\n  /// The code model to use (-mcmodel).\n  std::string CodeModel;\n\n  /// The filename with path we use for coverage data files. The runtime\n  /// allows further manipulation with the GCOV_PREFIX and GCOV_PREFIX_STRIP\n  /// environment variables.\n  std::string CoverageDataFile;\n\n  /// The filename with path we use for coverage notes files.\n  std::string CoverageNotesFile;\n\n  /// Regexes separated by a semi-colon to filter the files to instrument.\n  std::string ProfileFilterFiles;\n\n  /// Regexes separated by a semi-colon to filter the files to not instrument.\n  std::string ProfileExcludeFiles;\n\n  /// The version string to put into coverage files.\n  char CoverageVersion[4];\n\n  /// Enable additional debugging information.\n  std::string DebugPass;\n\n  /// The string to embed in debug information as the current working directory.\n  std::string DebugCompilationDir;\n\n  /// The string to embed in coverage mapping as the current working directory.\n  std::string CoverageCompilationDir;\n\n  /// The string to embed in the debug information for the compile unit, if\n  /// non-empty.\n  std::string DwarfDebugFlags;\n\n  /// The string containing the commandline for the llvm.commandline metadata,\n  /// if non-empty.\n  std::string RecordCommandLine;\n\n  llvm::SmallVector<std::pair<std::string, std::string>, 0> DebugPrefixMap;\n\n  /// Prefix replacement map for source-based code coverage to remap source\n  /// file paths in coverage mapping.\n  llvm::SmallVector<std::pair<std::string, std::string>, 0> CoveragePrefixMap;\n\n  /// The ABI to use for passing floating point arguments.\n  std::string FloatABI;\n\n  /// The file to use for dumping bug report by `Debugify` for original\n  /// debug info.\n  std::string DIBugsReportFilePath;\n\n  /// The floating-point denormal mode to use.\n  llvm::DenormalMode FPDenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The floating-point denormal mode to use, for float.\n  llvm::DenormalMode FP32DenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The float precision limit to use, if non-empty.\n  std::string LimitFloatPrecision;\n\n  struct BitcodeFileToLink {\n    /// The filename of the bitcode file to link in.\n    std::string Filename;\n    /// If true, we set attributes functions in the bitcode library according to\n    /// our CodeGenOptions, much as we set attrs on functions that we generate\n    /// ourselves.\n    bool PropagateAttrs = false;\n    /// If true, we use LLVM module internalizer.\n    bool Internalize = false;\n    /// Bitwise combination of llvm::Linker::Flags, passed to the LLVM linker.\n    unsigned LinkFlags = 0;\n  };\n\n  /// The files specified here are linked in to the module before optimizations.\n  std::vector<BitcodeFileToLink> LinkBitcodeFiles;\n\n  /// The user provided name for the \"main file\", if non-empty. This is useful\n  /// in situations where the input file name does not match the original input\n  /// file, for example with -save-temps.\n  std::string MainFileName;\n\n  /// The name for the split debug info file used for the DW_AT_[GNU_]dwo_name\n  /// attribute in the skeleton CU.\n  std::string SplitDwarfFile;\n\n  /// Output filename for the split debug info, not used in the skeleton CU.\n  std::string SplitDwarfOutput;\n\n  /// Output filename used in the COFF debug information.\n  std::string ObjectFilenameForDebug;\n\n  /// The name of the relocation model to use.\n  llvm::Reloc::Model RelocationModel;\n\n  /// If not an empty string, trap intrinsics are lowered to calls to this\n  /// function instead of to trap instructions.\n  std::string TrapFuncName;\n\n  /// A list of dependent libraries.\n  std::vector<std::string> DependentLibraries;\n\n  /// A list of linker options to embed in the object file.\n  std::vector<std::string> LinkerOptions;\n\n  /// Name of the profile file to use as output for -fprofile-instr-generate,\n  /// -fprofile-generate, and -fcs-profile-generate.\n  std::string InstrProfileOutput;\n\n  /// Name of the profile file to use with -fprofile-sample-use.\n  std::string SampleProfileFile;\n\n  /// Name of the profile file to use as output for with -fmemory-profile.\n  std::string MemoryProfileOutput;\n\n  /// Name of the profile file to use as input for -fmemory-profile-use.\n  std::string MemoryProfileUsePath;\n\n  /// Name of the profile file to use as input for -fprofile-instr-use\n  std::string ProfileInstrumentUsePath;\n\n  /// Name of the profile remapping file to apply to the profile data supplied\n  /// by -fprofile-sample-use or -fprofile-instr-use.\n  std::string ProfileRemappingFile;\n\n  /// Name of the function summary index file to use for ThinLTO function\n  /// importing.\n  std::string ThinLTOIndexFile;\n\n  /// Name of a file that can optionally be written with minimized bitcode\n  /// to be used as input for the ThinLTO thin link step, which only needs\n  /// the summary and module symbol table (and not, e.g. any debug metadata).\n  std::string ThinLinkBitcodeFile;\n\n  /// Prefix to use for -save-temps output.\n  std::string SaveTempsFilePrefix;\n\n  /// Name of file passed with -fcuda-include-gpubinary option to forward to\n  /// CUDA runtime back-end for incorporating them into host-side object file.\n  std::string CudaGpuBinaryFileName;\n\n  /// List of filenames passed in using the -fembed-offload-object option. These\n  /// are offloading binaries containing device images and metadata.\n  std::vector<std::string> OffloadObjects;\n\n  /// The name of the file to which the backend should save YAML optimization\n  /// records.\n  std::string OptRecordFile;\n\n  /// The regex that filters the passes that should be saved to the optimization\n  /// records.\n  std::string OptRecordPasses;\n\n  /// The format used for serializing remarks (default: YAML)\n  std::string OptRecordFormat;\n\n  /// The name of the partition that symbols are assigned to, specified with\n  /// -fsymbol-partition (see https://lld.llvm.org/Partitions.html).\n  std::string SymbolPartition;\n\n  enum RemarkKind {\n    RK_Missing,            // Remark argument not present on the command line.\n    RK_Enabled,            // Remark enabled via '-Rgroup'.\n    RK_EnabledEverything,  // Remark enabled via '-Reverything'.\n    RK_Disabled,           // Remark disabled via '-Rno-group'.\n    RK_DisabledEverything, // Remark disabled via '-Rno-everything'.\n    RK_WithPattern,        // Remark pattern specified via '-Rgroup=regexp'.\n  };\n\n  /// Optimization remark with an optional regular expression pattern.\n  struct OptRemark {\n    RemarkKind Kind = RK_Missing;\n    std::string Pattern;\n    std::shared_ptr<llvm::Regex> Regex;\n\n    /// By default, optimization remark is missing.\n    OptRemark() = default;\n\n    /// Returns true iff the optimization remark holds a valid regular\n    /// expression.\n    bool hasValidPattern() const { return Regex != nullptr; }\n\n    /// Matches the given string against the regex, if there is some.\n    bool patternMatches(StringRef String) const {\n      return hasValidPattern() && Regex->match(String);\n    }\n  };\n\n  /// Selected optimizations for which we should enable optimization remarks.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they perform a transformation.\n  OptRemark OptimizationRemark;\n\n  /// Selected optimizations for which we should enable missed optimization\n  /// remarks. Transformation passes whose name matches the contained (optional)\n  /// regular expression (and support this feature), will emit a diagnostic\n  /// whenever they tried but failed to perform a transformation.\n  OptRemark OptimizationRemarkMissed;\n\n  /// Selected optimizations for which we should enable optimization analyses.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they want to explain why they decided to apply or not apply a given\n  /// transformation.\n  OptRemark OptimizationRemarkAnalysis;\n\n  /// Set of sanitizer checks that are non-fatal (i.e. execution should be\n  /// continued when possible).\n  SanitizerSet SanitizeRecover;\n\n  /// Set of sanitizer checks that trap rather than diagnose.\n  SanitizerSet SanitizeTrap;\n\n  /// List of backend command-line options for -fembed-bitcode.\n  std::vector<uint8_t> CmdArgs;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  std::vector<std::string> Reciprocals;\n\n  /// The preferred width for auto-vectorization transforms. This is intended to\n  /// override default transforms based on the width of the architected vector\n  /// registers.\n  std::string PreferVectorWidth;\n\n  /// Set of XRay instrumentation kinds to emit.\n  XRayInstrSet XRayInstrumentationBundle;\n\n  std::vector<std::string> DefaultFunctionAttrs;\n\n  /// List of dynamic shared object files to be loaded as pass plugins.\n  std::vector<std::string> PassPlugins;\n\n  /// Path to allowlist file specifying which objects\n  /// (files, functions) should exclusively be instrumented\n  /// by sanitizer coverage pass.\n  std::vector<std::string> SanitizeCoverageAllowlistFiles;\n\n  /// The guard style used for stack protector to get a initial value, this\n  /// value usually be gotten from TLS or get from __stack_chk_guard, or some\n  /// other styles we may implement in the future.\n  std::string StackProtectorGuard;\n\n  /// The TLS base register when StackProtectorGuard is \"tls\", or register used\n  /// to store the stack canary for \"sysreg\".\n  /// On x86 this can be \"fs\" or \"gs\".\n  /// On AArch64 this can only be \"sp_el0\".\n  std::string StackProtectorGuardReg;\n\n  /// Specify a symbol to be the guard value.\n  std::string StackProtectorGuardSymbol;\n\n  /// Path to ignorelist file specifying which objects\n  /// (files, functions) listed for instrumentation by sanitizer\n  /// coverage pass should actually not be instrumented.\n  std::vector<std::string> SanitizeCoverageIgnorelistFiles;\n\n  /// Path to ignorelist file specifying which objects\n  /// (files, functions) listed for instrumentation by sanitizer\n  /// binary metadata pass should not be instrumented.\n  std::vector<std::string> SanitizeMetadataIgnorelistFiles;\n\n  /// Name of the stack usage file (i.e., .su file) if user passes\n  /// -fstack-usage. If empty, it can be implied that -fstack-usage is not\n  /// passed on the command line.\n  std::string StackUsageOutput;\n\n  /// Executable and command-line used to create a given CompilerInvocation.\n  /// Most of the time this will be the full -cc1 command.\n  const char *Argv0 = nullptr;\n  std::vector<std::string> CommandLineArgs;\n\n  /// The minimum hotness value a diagnostic needs in order to be included in\n  /// optimization diagnostics.\n  ///\n  /// The threshold is an Optional value, which maps to one of the 3 states:\n  /// 1. 0            => threshold disabled. All remarks will be printed.\n  /// 2. positive int => manual threshold by user. Remarks with hotness exceed\n  ///                    threshold will be printed.\n  /// 3. None         => 'auto' threshold by user. The actual value is not\n  ///                    available at command line, but will be synced with\n  ///                    hotness threshold from profile summary during\n  ///                    compilation.\n  ///\n  /// If threshold option is not specified, it is disabled by default.\n  std::optional<uint64_t> DiagnosticsHotnessThreshold = 0;\n\n  /// The maximum percentage profiling weights can deviate from the expected\n  /// values in order to be included in misexpect diagnostics.\n  std::optional<uint32_t> DiagnosticsMisExpectTolerance = 0;\n\n  /// The name of a file to use with \\c .secure_log_unique directives.\n  std::string AsSecureLogFile;\n\npublic:\n  // Define accessors/mutators for code generation options of enumeration type.\n#define CODEGENOPT(Name, Bits, Default)\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/CodeGenOptions.def\"\n\n  CodeGenOptions();\n\n  const std::vector<std::string> &getNoBuiltinFuncs() const {\n    return NoBuiltinFuncs;\n  }\n\n  /// Check if Clang profile instrumenation is on.\n  bool hasProfileClangInstr() const {\n    return getProfileInstr() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile instrumentation is on.\n  bool hasProfileIRInstr() const {\n    return getProfileInstr() == ProfileIRInstr;\n  }\n\n  /// Check if CS IR level profile instrumentation is on.\n  bool hasProfileCSIRInstr() const {\n    return getProfileInstr() == ProfileCSIRInstr;\n  }\n\n  /// Check if Clang profile use is on.\n  bool hasProfileClangUse() const {\n    return getProfileUse() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile use is on.\n  bool hasProfileIRUse() const {\n    return getProfileUse() == ProfileIRInstr ||\n           getProfileUse() == ProfileCSIRInstr;\n  }\n\n  /// Check if CSIR profile use is on.\n  bool hasProfileCSIRUse() const { return getProfileUse() == ProfileCSIRInstr; }\n\n  /// Check if type and variable info should be emitted.\n  bool hasReducedDebugInfo() const {\n    return getDebugInfo() >= llvm::codegenoptions::DebugInfoConstructor;\n  }\n\n  /// Check if maybe unused type info should be emitted.\n  bool hasMaybeUnusedDebugInfo() const {\n    return getDebugInfo() >= llvm::codegenoptions::UnusedTypeInfo;\n  }\n\n  // Check if any one of SanitizeCoverage* is enabled.\n  bool hasSanitizeCoverage() const {\n    return SanitizeCoverageType || SanitizeCoverageIndirectCalls ||\n           SanitizeCoverageTraceCmp || SanitizeCoverageTraceLoads ||\n           SanitizeCoverageTraceStores || SanitizeCoverageControlFlow;\n  }\n\n  // Check if any one of SanitizeBinaryMetadata* is enabled.\n  bool hasSanitizeBinaryMetadata() const {\n    return SanitizeBinaryMetadataCovered || SanitizeBinaryMetadataAtomics ||\n           SanitizeBinaryMetadataUAR;\n  }\n}",
  "id": "BLOCK-CPP-16083",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/llvm/clang/include/clang/Basic/CodeGenOptions.h",
  "source_line": 49,
  "validation_status": "validated"
}