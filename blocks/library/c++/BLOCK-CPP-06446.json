{
  "code": "{\n public:\n  // Atomically check that `*v == val`, and if it is, then sleep until the until\n  // woken by `Wake()`.\n  static int Wait(std::atomic<int32_t>* v, int32_t val) {\n    return WaitAbsoluteTimeout(v, val, nullptr);\n  }\n\n  // Atomically check that `*v == val`, and if it is, then sleep until\n  // CLOCK_REALTIME reaches `*abs_timeout`, or until woken by `Wake()`.\n  static int WaitAbsoluteTimeout(std::atomic<int32_t>* v, int32_t val,\n                                 const struct timespec* abs_timeout) {\n    FutexTimespec ts;\n    // https://locklessinc.com/articles/futex_cheat_sheet/\n    // Unlike FUTEX_WAIT, FUTEX_WAIT_BITSET uses absolute time.\n    auto err = syscall(\n        SYS_futex, reinterpret_cast<int32_t*>(v),\n        FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME, val,\n        ToFutexTimespec(abs_timeout, &ts), nullptr, FUTEX_BITSET_MATCH_ANY);\n    if (err != 0) {\n      return -errno;\n    }\n    return 0;\n  }\n\n  // Atomically check that `*v == val`, and if it is, then sleep until\n  // `*rel_timeout` has elapsed, or until woken by `Wake()`.\n  static int WaitRelativeTimeout(std::atomic<int32_t>* v, int32_t val,\n                                 const struct timespec* rel_timeout) {\n    FutexTimespec ts;\n    // Atomically check that the futex value is still 0, and if it\n    // is, sleep until abs_timeout or until woken by FUTEX_WAKE.\n    auto err =\n        syscall(SYS_futex, reinterpret_cast<int32_t*>(v), FUTEX_PRIVATE_FLAG,\n                val, ToFutexTimespec(rel_timeout, &ts));\n    if (err != 0) {\n      return -errno;\n    }\n    return 0;\n  }\n\n  // Wakes at most `count` waiters that have entered the sleep state on `v`.\n  static int Wake(std::atomic<int32_t>* v, int32_t count) {\n    auto err = syscall(SYS_futex, reinterpret_cast<int32_t*>(v),\n                       FUTEX_WAKE | FUTEX_PRIVATE_FLAG, count);\n    if (ABSL_PREDICT_FALSE(err < 0)) {\n      return -errno;\n    }\n    return 0;\n  }\n\n private:\n  static FutexTimespec* ToFutexTimespec(const struct timespec* userspace_ts,\n                                        FutexTimespec* futex_ts) {\n    if (userspace_ts == nullptr) {\n      return nullptr;\n    }\n\n    using FutexSeconds = decltype(futex_ts->tv_sec);\n    using FutexNanoseconds = decltype(futex_ts->tv_nsec);\n\n    constexpr auto kMaxSeconds{(std::numeric_limits<FutexSeconds>::max)()};\n    if (userspace_ts->tv_sec > kMaxSeconds) {\n      futex_ts->tv_sec = kMaxSeconds;\n    } else {\n      futex_ts->tv_sec = static_cast<FutexSeconds>(userspace_ts->tv_sec);\n    }\n    futex_ts->tv_nsec = static_cast<FutexNanoseconds>(userspace_ts->tv_nsec);\n    return futex_ts;\n  }\n}",
  "id": "BLOCK-CPP-06446",
  "language": "c++",
  "source_file": "/storage/emulated/0/Download/cpp_codebases/abseil/absl/synchronization/internal/futex.h",
  "source_line": 97,
  "validation_status": "validated"
}