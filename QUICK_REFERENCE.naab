# NAAb Quick Reference - Syntax and Blocks Cheat Sheet

# ═══════════════════════════════════════════════════════════════
# BASIC SYNTAX
# ═══════════════════════════════════════════════════════════════

# Variables (type inference)
let name = "Alice"      # string
let age = 30            # int
let price = 99.99       # float
let active = true       # bool
let items = [1, 2, 3]   # list
let data = {"key": "value"}  # dict

# Array assignment (NEW!)
items[0] = 100
data["new_key"] = "new_value"

# Control flow
if age > 18 {
    print("Adult")
} else {
    print("Minor")
}

while age < 100 {
    age = age + 1
}

for item in items {
    print(item)
}

# Functions
fn add(a: int, b: int) -> int {
    return a + b
}

# Structs
struct Person {
    name: string,
    age: int
}

let person = new Person { name: "Bob", age: 25 }
print(person.name)

# ═══════════════════════════════════════════════════════════════
# POLYGLOT BLOCKS - Quick Examples
# ═══════════════════════════════════════════════════════════════

main {
    print("=== POLYGLOT BLOCKS QUICK REFERENCE ===")
    print("")

    # ─────────────────────────────────────────────────────────
    # 1. BASIC BLOCKS (no variables)
    # ─────────────────────────────────────────────────────────

    <<python
    print("Hello from Python!")
    >>

    <<javascript
    console.log("Hello from JavaScript!");
    >>

    <<bash
    echo "Hello from Bash!"
    >>

    # ─────────────────────────────────────────────────────────
    # 2. VARIABLE BINDING (pass NAAb vars to blocks)
    # ─────────────────────────────────────────────────────────

    let x = 42
    let y = "hello"

    # Syntax: <<language[var1, var2, ...] code >>
    <<python[x, y]
    print(f"x={x}, y={y}")
    >>

    <<javascript[x, y]
    console.log(`x=${x}, y=${y}`);
    >>

    # ─────────────────────────────────────────────────────────
    # 3. RETURN VALUES (get results from blocks)
    # ─────────────────────────────────────────────────────────

    # Last expression is returned
    let result = <<python
    2 + 2
    >>
    print("Python returned: ", result)  # 4

    let squared = <<python
    [x * x for x in range(1, 6)]
    >>
    print("Squares: ", squared)  # [1, 4, 9, 16, 25]

    let stats = <<python
    {"min": 1, "max": 100, "avg": 50.5}
    >>
    print("Stats: ", stats)  # dict

    # ─────────────────────────────────────────────────────────
    # 4. COMBINING BOTH (variables + return)
    # ─────────────────────────────────────────────────────────

    let numbers = [5, 2, 8, 1, 9]

    let sorted_nums = <<python[numbers]
    sorted(numbers)
    >>
    print("Sorted: ", sorted_nums)

    let doubled = <<javascript[numbers]
    numbers.map(x => x * 2)
    >>
    print("Doubled: ", doubled)

    # ─────────────────────────────────────────────────────────
    # 5. SUPPORTED LANGUAGES (8 total)
    # ─────────────────────────────────────────────────────────

    # Python
    <<python
    print("✓ Python")
    >>

    # JavaScript
    <<javascript
    console.log("✓ JavaScript");
    >>

    # Bash/Shell
    <<bash
    echo "✓ Bash"
    >>

    # C++ (compiled at runtime)
    <<cpp
    std::cout << "✓ C++" << std::endl;
    >>

    # Also: rust, ruby, go, csharp (may need installation)

    # ─────────────────────────────────────────────────────────
    # 6. REAL-WORLD EXAMPLES
    # ─────────────────────────────────────────────────────────

    # Data processing
    let data_list = [
        {"name": "Alice", "score": "95"},
        {"name": "Bob", "score": "87"}
    ]

    let processed = <<python[data_list]
    [{**item, "score": int(item["score"])} for item in data_list]
    >>
    print("Processed: ", processed)

    # Pandas analysis
    let analysis = <<python
    import pandas as pd
    df = pd.DataFrame({"sales": [100, 150, 80, 200]})
    {"total": int(df["sales"].sum()), "avg": float(df["sales"].mean())}
    >>
    print("Analysis: ", analysis)

    # File operations
    <<bash
    echo "Test" > /tmp/test.txt
    cat /tmp/test.txt
    rm /tmp/test.txt
    >>

    # ─────────────────────────────────────────────────────────
    # 7. USING NAAB STDLIB (faster than polyglot!)
    # ─────────────────────────────────────────────────────────

    use array
    use string
    use math
    use json

    let nums = [1, 2, 3, 4, 5]

    # Array operations (FAST - native C++)
    let len = array.length(nums)
    let doubled_native = array.map(nums, fn(x) { return x * 2 })
    let sum = array.reduce(nums, fn(acc, x) { return acc + x }, 0)
    print("Native sum: ", sum, " (10-100x faster!)")

    # String operations
    let text = "  hello world  "
    let trimmed = string.trim(text)
    let upper = string.upper(trimmed)
    print("Processed: ", upper)

    # Math operations
    let sqrt_val = math.sqrt(16.0)
    let pi = math.PI
    print("sqrt(16) = ", sqrt_val)

    # ─────────────────────────────────────────────────────────
    # 8. ERROR HANDLING
    # ─────────────────────────────────────────────────────────

    try {
        let risky = <<python
        1 / 0  # Will throw error
        >>
    } catch error {
        print("Caught error: ", error)
    } finally {
        print("Cleanup always runs")
    }

    # ─────────────────────────────────────────────────────────
    # 9. CHAINING LANGUAGES
    # ─────────────────────────────────────────────────────────

    let initial = [1, 2, 3]

    # NAAb -> Python
    let step1 = <<python[initial]
    [x + 5 for x in initial]
    >>

    # Python result -> JavaScript
    let step2 = <<javascript[step1]
    step1.map(x => x * 2)
    >>

    print("Chain: ", initial, " -> ", step1, " -> ", step2)

    # ─────────────────────────────────────────────────────────
    # 10. BEST PRACTICES
    # ─────────────────────────────────────────────────────────

    # ✓ DO: Use NAAb stdlib when possible (faster!)
    let fast = array.sort(nums)

    # ✗ AVOID: Polyglot for simple operations (slower)
    # let slow = <<python[nums]
    # sorted(nums)
    # >>

    # ✓ DO: Batch operations in single block
    let batched = <<python[nums]
    [x * 2 for x in nums]  # All in one block
    >>

    # ✗ AVOID: Multiple small blocks
    # for num in nums {
    #     let result = <<python[num]
    #     num * 2
    #     >>
    # }

    # ✓ DO: Use type inference
    let auto = 42  # Type inferred

    # ✓ DO: Handle errors
    try {
        # Risky code here
    } catch error {
        print("Error: ", error)
    }

    print("")
    print("=== END QUICK REFERENCE ===")
}

# ═══════════════════════════════════════════════════════════════
# SYNTAX SUMMARY
# ═══════════════════════════════════════════════════════════════

# Basic block:           <<language code >>
# With variables:        <<language[var1, var2] code >>
# With return:           let x = <<language code >>
# Combined:              let x = <<language[var] code >>

# Supported languages:   python, javascript, bash, cpp, rust, ruby, go, csharp

# Type conversions happen automatically:
# - NAAb int/float/string/bool -> Python/JS equivalent
# - NAAb list -> Python list / JS array
# - NAAb dict -> Python dict / JS object

# Return types supported:
# - int, float, string, bool, list, dict, void
