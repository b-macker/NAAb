// NAAb Arithmetic Overflow Security Tests
// Tests safe arithmetic operations to prevent integer overflow vulnerabilities

fn testAdditionOverflow() {
    print("Testing addition overflow detection...")

    // Should succeed
    let x = 1000 + 2000
    assert(x == 3000, "Normal addition should work")

    // Large numbers that should trigger overflow detection in C++ backend
    // (when using int64 max values)
    // Note: NAAb interpreter will catch these with safe_math
    try {
        let max_int = 9223372036854775807  // INT64_MAX
        let overflow = max_int + 1  // Should throw OverflowException
        assert(false, "Should have thrown overflow exception")
    } catch e {
        print("✓ Caught overflow: " + e)
    }
}

fn testSubtractionUnderflow() {
    print("Testing subtraction underflow detection...")

    // Should succeed
    let x = 5000 - 2000
    assert(x == 3000, "Normal subtraction should work")

    // Test underflow
    try {
        let min_int = -9223372036854775808  // INT64_MIN
        let underflow = min_int - 1  // Should throw UnderflowException
        assert(false, "Should have thrown underflow exception")
    } catch e {
        print("✓ Caught underflow: " + e)
    }
}

fn testMultiplicationOverflow() {
    print("Testing multiplication overflow detection...")

    // Should succeed
    let x = 100 * 50
    assert(x == 5000, "Normal multiplication should work")

    // Test overflow
    try {
        let large = 9223372036854775807  // INT64_MAX
        let overflow = large * 2  // Should throw OverflowException
        assert(false, "Should have thrown overflow exception")
    } catch e {
        print("✓ Caught overflow: " + e)
    }
}

fn testDivisionByZero() {
    print("Testing division by zero detection...")

    // Should succeed
    let x = 100 / 5
    assert(x == 20, "Normal division should work")

    // Test divide by zero
    try {
        let result = 100 / 0  // Should throw DivisionByZeroException
        assert(false, "Should have thrown division by zero exception")
    } catch e {
        print("✓ Caught division by zero: " + e)
    }
}

fn testModuloByZero() {
    print("Testing modulo by zero detection...")

    // Should succeed
    let x = 100 % 7
    assert(x == 2, "Normal modulo should work")

    // Test modulo by zero
    try {
        let result = 100 % 0  // Should throw DivisionByZeroException
        assert(false, "Should have thrown modulo by zero exception")
    } catch e {
        print("✓ Caught modulo by zero: " + e)
    }
}

fn testNegationOverflow() {
    print("Testing negation overflow detection...")

    // Should succeed
    let x = -1000
    let y = -x
    assert(y == 1000, "Normal negation should work")

    // Test INT_MIN negation overflow
    try {
        let min_int = -9223372036854775808  // INT64_MIN
        let overflow = -min_int  // Should throw OverflowException
        assert(false, "Should have thrown overflow exception")
    } catch e {
        print("✓ Caught negation overflow: " + e)
    }
}

fn testArrayBoundsChecking() {
    print("Testing array bounds checking...")

    let arr = [10, 20, 30, 40, 50]

    // Valid access
    assert(arr[0] == 10, "Index 0 should work")
    assert(arr[4] == 50, "Index 4 should work")

    // Out of bounds access
    try {
        let invalid = arr[10]  // Should throw out_of_range
        assert(false, "Should have thrown out of range exception")
    } catch e {
        print("✓ Caught out of bounds: " + e)
    }

    // Negative index
    try {
        let invalid = arr[-1]  // Should throw out_of_range
        assert(false, "Should have thrown negative index exception")
    } catch e {
        print("✓ Caught negative index: " + e)
    }
}

fn testSafeIntegerConversion() {
    print("Testing safe integer type conversion...")

    // Should succeed (within bounds)
    let x: int = 127  // Fits in int8

    // Test overflow in conversion (conceptual - depends on type system)
    try {
        // Attempting to fit large value in smaller type
        let large = 999999999
        // If NAAb had explicit int8 type:
        // let small: int8 = large  // Should throw OverflowException
        print("✓ Type conversion would be checked")
    } catch e {
        print("✓ Caught conversion overflow: " + e)
    }
}

fn runAllTests() {
    print("=== Arithmetic Overflow Security Tests ===\n")

    testAdditionOverflow()
    testSubtractionUnderflow()
    testMultiplicationOverflow()
    testDivisionByZero()
    testModuloByZero()
    testNegationOverflow()
    testArrayBoundsChecking()
    testSafeIntegerConversion()

    print("\n✅ All arithmetic overflow tests completed!")
}

// Run tests
runAllTests()
