// Phase 3.1: Result<T, E> Types
// Test file demonstrating Result type for error handling

// Import Result library (when module system is ready)
// use "../stdlib/result.naab"

// For now, inline the Result struct definition
struct Result<T, E> {
    is_ok: bool
    value: T | null
    error: E | null
}

function Ok<T, E>(value: T) -> Result<T, E> {
    return Result<T, E> {
        is_ok: true,
        value: value,
        error: null
    }
}

function Err<T, E>(error: E) -> Result<T, E> {
    return Result<T, E> {
        is_ok: false,
        value: null,
        error: error
    }
}

// Example 1: Parse integer with error handling
function parseInt(input: string) -> Result<int, string> {
    if (input == "42") {
        return Ok<int, string>(42)
    } else if (input == "100") {
        return Ok<int, string>(100)
    } else {
        return Err<int, string>("Invalid number: " + input)
    }
}

// Example 2: Divide with zero check
function divide(a: int, b: int) -> Result<float, string> {
    if (b == 0) {
        return Err<float, string>("Division by zero")
    } else {
        return Ok<float, string>(a / b)
    }
}

// Example 3: File operations (simulated)
function readFile(path: string) -> Result<string, string> {
    if (path == "data.txt") {
        return Ok<string, string>("file contents here")
    } else {
        return Err<string, string>("File not found: " + path)
    }
}

// Example 4: Chain results
function processFile(path: string) -> Result<int, string> {
    let file_result = readFile(path)

    if (!file_result.is_ok) {
        return Err<int, string>(file_result.error)
    }

    let content = file_result.value
    let parse_result = parseInt(content)

    return parse_result
}

// Example 5: Using Result with try/catch
function unsafeDivide(a: int, b: int) -> float {
    let result = divide(a, b)

    if (result.is_ok) {
        return result.value
    } else {
        throw result.error
    }
}

main {
    print("=== Phase 3.1: Testing Result<T, E> Types ===\n")

    // Test 1: Successful parsing
    print("\n[Test 1] Successful parseInt:")
    let result1 = parseInt("42")
    if (result1.is_ok) {
        print("Success: parsed value = " + result1.value)
    } else {
        print("Error: " + result1.error)
    }

    // Test 2: Failed parsing
    print("\n[Test 2] Failed parseInt:")
    let result2 = parseInt("invalid")
    if (result2.is_ok) {
        print("Success: parsed value = " + result2.value)
    } else {
        print("Error: " + result2.error)
    }

    // Test 3: Successful division
    print("\n[Test 3] Successful division:")
    let result3 = divide(10, 2)
    if (result3.is_ok) {
        print("Success: 10 / 2 = " + result3.value)
    } else {
        print("Error: " + result3.error)
    }

    // Test 4: Division by zero
    print("\n[Test 4] Division by zero:")
    let result4 = divide(10, 0)
    if (result4.is_ok) {
        print("Success: 10 / 0 = " + result4.value)
    } else {
        print("Error: " + result4.error)
    }

    // Test 5: Successful file read
    print("\n[Test 5] Successful file read:")
    let result5 = readFile("data.txt")
    if (result5.is_ok) {
        print("Success: file contents = " + result5.value)
    } else {
        print("Error: " + result5.error)
    }

    // Test 6: Failed file read
    print("\n[Test 6] Failed file read:")
    let result6 = readFile("missing.txt")
    if (result6.is_ok) {
        print("Success: file contents = " + result6.value)
    } else {
        print("Error: " + result6.error)
    }

    // Test 7: Chained operations
    print("\n[Test 7] Chained operations:")
    let result7 = processFile("data.txt")
    if (result7.is_ok) {
        print("Success: processed value = " + result7.value)
    } else {
        print("Error: " + result7.error)
    }

    // Test 8: Converting Result to exception
    print("\n[Test 8] Converting Result to exception:")
    try {
        let safe_result = unsafeDivide(10, 2)
        print("Unsafe divide succeeded: " + safe_result)
    } catch (e) {
        print("Caught exception: " + e)
    }

    try {
        let unsafe_result = unsafeDivide(10, 0)
        print("This should not print")
    } catch (e) {
        print("Caught division by zero: " + e)
    }

    // Test 9: Multiple error types
    print("\n[Test 9] Union error types:")
    // Result with union error type
    function multiError(flag: int) -> Result<int, string | int> {
        if (flag == 1) {
            return Ok<int, string | int>(100)
        } else if (flag == 2) {
            return Err<int, string | int>("String error")
        } else {
            return Err<int, string | int>(404)
        }
    }

    let r1 = multiError(1)
    let r2 = multiError(2)
    let r3 = multiError(3)

    print("multiError(1): " + (r1.is_ok ? "Ok" : "Err"))
    print("multiError(2): " + (r2.is_ok ? "Ok" : "Err"))
    print("multiError(3): " + (r3.is_ok ? "Ok" : "Err"))

    print("\n\n=== Phase 3.1: All tests completed ===")
}
