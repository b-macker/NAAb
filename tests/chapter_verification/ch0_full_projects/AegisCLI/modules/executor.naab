// AegisCLI/modules/executor.naab
// System command execution via Bash.
// Uses: <<bash>>, io, string

use io
use string

// ── Bash Block for Execution ────────────────────────────────────

fn bash_execute(cmd, dry_run) {
    if dry_run {
        io.write("  [Executor] DRY RUN: Would execute: '", cmd, "'\n")
        return {"stdout": "", "stderr": "", "exit_code": 0}
    }

    let result = <<bash[cmd]
    # Capture output and exit code
    stdout=$(eval "$cmd" 2>&1)
    exit_code=$?
    
    # Simple JSON encoding for return (fragile if output has quotes, 
    # but demonstrates the concept for a prototype)
    # Ideally use Python/Ruby/Node for safer JSON generation.
    # Here we just escape quotes.
    safe_out=$(echo "$stdout" | sed 's/"/\\"/g' | tr '\n' ' ')
    
    echo "{\"stdout\": \"$safe_out\", \"stderr\": \"\", \"exit_code\": $exit_code}"
    >>
    
    return json.parse(result)
}

fn bash_probe_system() {
    let sys_info = <<bash
    os=$(uname -s)
    arch=$(uname -m)
    distro="Unknown"
    if [ -f /etc/os-release ]; then
        distro=$(grep '^PRETTY_NAME=' /etc/os-release | cut -d= -f2 | tr -d '"')
    fi
    
    # Check common tools
    has_git=$(command -v git >/dev/null && echo "true" || echo "false")
    has_node=$(command -v node >/dev/null && echo "true" || echo "false")
    has_python=$(command -v python3 >/dev/null && echo "true" || echo "false")
    has_cargo=$(command -v cargo >/dev/null && echo "true" || echo "false")
    
    echo "{\"os\": \"$os\", \"arch\": \"$arch\", \"distro\": \"$distro\", \"tools\": {\"git\": $has_git, \"node\": $has_node, \"python\": $has_python, \"cargo\": $has_cargo}}"
    >>
    
    return json.parse(sys_info)
}

// ── Public Interface ────────────────────────────────────────────

export fn init(config) {
    // Probe system on init
    let info = bash_probe_system()
    io.write("  [Executor] System: ", info["distro"], " (", info["arch"], ")\n")
    io.write("  [Executor] Tools: ")
    if info["tools"]["git"] { io.write("git ") }
    if info["tools"]["node"] { io.write("node ") }
    if info["tools"]["python"] { io.write("python ") }
    if info["tools"]["cargo"] { io.write("cargo ") }
    io.write("\n")
    
    return {
        "system_info": info,
        "config": config
    }
}

export fn execute(cmd, context) {
    // Check safety mode
    let safe_mode = context["config"]["safe_mode"]
    
    // In a real CLI, we'd prompt user here:
    // io.write("  [Executor] Allow execution of: '", cmd, "'? [y/N] ")
    // let confirm = io.read_line()
    // if confirm != "y" { return ... }
    
    // For now, assume safe mode means dry run unless explicitly overridden
    let dry_run = safe_mode
    
    return bash_execute(cmd, dry_run)
}
