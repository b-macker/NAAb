// modules/analytics.naab
// Cross-source analytics using Python + JavaScript polyglot blocks
// Enhanced with risk matrix and multi-dimensional correlation
// Uses: func keyword alias, <<python>>, <<javascript>>

use io
use json
use array

// ── Python: Cross-Source Correlation Analysis ────────────────────
// Correlates weather severity with crypto volatility (showcase)

func cross_correlate(weather_data_json, crypto_data_json) {
    let result_json = <<python[weather_data_json, crypto_data_json]
import json

weather = json.loads(weather_data_json)
crypto = json.loads(crypto_data_json)

# Weather severity score: deviation from 22C ideal + humidity factor + wind
severity_scores = []
for w in weather:
    temp_dev = abs(w["temperature"] - 22.0) / 10.0
    humid_factor = w["humidity"] / 100.0
    wind_factor = w["wind_speed"] / 50.0
    severity = round(temp_dev * 0.5 + humid_factor * 0.3 + wind_factor * 0.2, 4)
    severity_scores.append(severity)

avg_severity = sum(severity_scores) / len(severity_scores) if severity_scores else 0

# Crypto volatility from 24h change
crypto_assets = crypto.get("assets", crypto) if isinstance(crypto, dict) else crypto
volatility_scores = []
for c in crypto_assets:
    vol = abs(c["change_24h"]) / 10.0
    volatility_scores.append(round(vol, 4))

avg_volatility = sum(volatility_scores) / len(volatility_scores) if volatility_scores else 0

# Simple correlation coefficient approximation
# (For showcase - real correlation would need paired time series)
n_pairs = min(len(severity_scores), len(volatility_scores))
correlation = 0.0
if n_pairs >= 2:
    sx = sum(severity_scores[:n_pairs])
    sy = sum(volatility_scores[:n_pairs])
    sxx = sum(s*s for s in severity_scores[:n_pairs])
    syy = sum(v*v for v in volatility_scores[:n_pairs])
    sxy = sum(severity_scores[i]*volatility_scores[i] for i in range(n_pairs))
    denom_sq = (n_pairs*sxx - sx*sx) * (n_pairs*syy - sy*sy)
    if denom_sq > 0:
        correlation = round((n_pairs*sxy - sx*sy) / (denom_sq ** 0.5), 4)

# Trend analysis
weather_trend = "stable"
if len(severity_scores) >= 3:
    first_half = sum(severity_scores[:len(severity_scores)//2])
    second_half = sum(severity_scores[len(severity_scores)//2:])
    if second_half > first_half * 1.1:
        weather_trend = "worsening"
    elif second_half < first_half * 0.9:
        weather_trend = "improving"

insight_dir = 'positively' if correlation > 0 else 'negatively'
insight_msg = f"Weather severity ({round(avg_severity,2)}) {insight_dir} correlates with crypto volatility ({round(avg_volatility,2)}) r={correlation}"
result = json.dumps({"avg_weather_severity": round(avg_severity, 4), "avg_crypto_volatility": round(avg_volatility, 4), "cross_correlation": correlation, "weather_trend": weather_trend, "severity_scores": severity_scores, "volatility_scores": volatility_scores, "n_pairs": n_pairs, "insight": insight_msg})
result
    >>

    return json.parse(result_json)
}

// ── JavaScript: Aggregate Dashboard Data (enhanced) ─────────────
// Combines all processed data including risk and validation into dashboard structure

func aggregate_dashboard_data(weather_json, crypto_json, currency_json, github_json, geo_json, correlation_json, risk_json, validation_json) {
    let dashboard_json = <<javascript[weather_json, crypto_json, currency_json, github_json, geo_json, correlation_json, risk_json, validation_json]
const weather = JSON.parse(weather_json);
const crypto = JSON.parse(crypto_json);
const currency = JSON.parse(currency_json);
const github = JSON.parse(github_json);
const geo = JSON.parse(geo_json);
const correlation = JSON.parse(correlation_json);
const risk = JSON.parse(risk_json);
const validation = JSON.parse(validation_json);

// Build summary counts
let liveCount = 0;
let totalCount = 0;

weather.forEach(w => { totalCount++; if (w.is_live) liveCount++; });
crypto.assets.forEach(c => { totalCount++; if (c.is_live) liveCount++; });
totalCount += 2; // currency + geo
if (currency.is_live) liveCount++;
if (geo.is_live) liveCount++;
github.repos.forEach(r => { totalCount++; if (r.is_live) liveCount++; });

// Weather summary cards with disruption
const weatherCards = weather.map(w => ({
    city: w.city,
    temp: w.temperature,
    feels: w.feels_like,
    humidity: w.humidity,
    wind: w.wind_speed,
    desc: w.description,
    status: w.temp_status,
    disruption: w.disruption_index || 0,
    disruption_level: w.disruption_level || "LOW",
    live: w.is_live
}));

// Crypto table rows
const cryptoRows = crypto.assets.map(c => ({
    name: c.name,
    price: c.price_usd,
    change: c.change_24h,
    mcap: c.market_cap,
    vol: c.volume_24h,
    zscore: c.z_score,
    volClass: c.volatility_class,
    live: c.is_live
}));

// Currency grid
const currencyGrid = currency.pairs.map(p => ({
    code: p.currency,
    rate: p.rate,
    inverse: p.inverse,
    strength: p.strength
}));

// GitHub comparison with recommendations
const githubBars = github.repos.map(r => ({
    name: r.full_name,
    stars: r.stars,
    forks: r.forks,
    issues: r.open_issues,
    pop: r.popularity_score,
    tier: r.tier,
    lang: r.language,
    recommendation: r.recommendation || "N/A",
    composite: r.composite_score || 0,
    live: r.is_live
}));

// Risk matrix: cross-reference weather x crypto x currency risk
const riskMatrix = {
    weather_risk: risk.composite_risk ? risk.composite_risk.components.weather_risk : 0,
    crypto_risk: risk.composite_risk ? risk.composite_risk.components.crypto_risk : 0,
    currency_risk: risk.composite_risk ? risk.composite_risk.components.currency_risk : 0,
    quality_risk: risk.composite_risk ? risk.composite_risk.components.quality_risk : 0,
    total: risk.risk_score || 0,
    alert_level: risk.alert_level || "GREEN",
    alert_message: risk.composite_risk ? risk.composite_risk.alert_message : "No data"
};

// Monte Carlo summary
const mcSummary = (risk.monte_carlo || []).map((mc, i) => ({
    asset: crypto.assets[i] ? crypto.assets[i].name : "Unknown",
    current: mc.current,
    low: mc.p5,
    median: mc.median,
    high: mc.p95,
    simulations: mc.simulations,
    horizon: mc.horizon_days
}));

// VaR data
const varData = crypto.var || {};

// Validation quality
const qualityData = {
    score: validation.overall_score || 0,
    grade: validation.quality_grade || "N/A",
    checks: validation.total_checks || 0,
    passed: validation.total_passed || 0,
    issues: validation.total_issues || 0,
    anomalies: validation.anomalies ? validation.anomalies.total_count : 0
};

// Arbitrage data
const arbData = currency.arbitrage || [];

const dashboard = {
    meta: {
        live_sources: liveCount,
        total_sources: totalCount,
        live_percent: Math.round(liveCount / totalCount * 100)
    },
    weather: weatherCards,
    crypto: cryptoRows,
    currency: currencyGrid,
    github: githubBars,
    geo: geo,
    correlation: {
        severity: correlation.avg_weather_severity,
        volatility: correlation.avg_crypto_volatility,
        r_value: correlation.cross_correlation,
        trend: correlation.weather_trend,
        insight: correlation.insight
    },
    risk: riskMatrix,
    monte_carlo: mcSummary,
    var: varData,
    quality: qualityData,
    arbitrage: arbData
};

JSON.stringify(dashboard);
    >>

    return json.parse(dashboard_json)
}

// ── Main Analytics Entry Point (enhanced) ───────────────────────

export func run_analytics(weather_enriched, crypto_analysis, currency_analysis, github_analysis, geo_data, risk_data, validation_data) {
    io.write("  [Analytics] Running cross-source analysis...\n")

    // Prepare JSON inputs for Python correlation
    let weather_json = json.stringify(weather_enriched)
    let crypto_json = json.stringify(crypto_analysis)

    // Python cross-correlation
    io.write("    [Python] Computing cross-source correlations...\n")
    let correlation = cross_correlate(weather_json, crypto_json)
    io.write("    Insight: ", correlation["insight"], "\n")

    // JavaScript aggregation (enhanced with risk + validation data)
    io.write("    [JavaScript] Aggregating dashboard data with risk matrix...\n")
    let currency_json = json.stringify(currency_analysis)
    let github_json = json.stringify(github_analysis)
    let geo_json = json.stringify(geo_data)
    let correlation_json = json.stringify(correlation)
    let risk_json = json.stringify(risk_data)
    let validation_json = json.stringify(validation_data)

    let dashboard_data = aggregate_dashboard_data(
        weather_json, crypto_json, currency_json,
        github_json, geo_json, correlation_json,
        risk_json, validation_json
    )

    io.write("    Live sources: ", dashboard_data["meta"]["live_sources"], "/", dashboard_data["meta"]["total_sources"])
    io.write(" (", dashboard_data["meta"]["live_percent"], "%)\n")

    return {
        "correlation": correlation,
        "dashboard": dashboard_data
    }
}
