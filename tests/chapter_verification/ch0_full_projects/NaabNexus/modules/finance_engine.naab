// modules/finance_engine.naab
// Crypto + Currency analytics via C++ statistical engine + VaR + Sharpe + Arbitrage
// Uses: function keyword alias, pipeline operator, <<cpp>> polyglot,
//       array.map_fn, array.filter_fn, array.reduce_fn, array.sort, array.reverse,
//       math.abs, math.sqrt, math.round, math.pow, math.min, math.max

use io
use json
use array
use math
use string

// ── C++ Statistical Engine ───────────────────────────────────────
// Computes standard deviation, z-scores, normalization across a set of values

function compute_statistics(values_json) {
    let stats_json = <<cpp[values_json]
    #include <vector>
    #include <cmath>
    #include <numeric>
    #include <sstream>
    #include <string>
    #include <iomanip>
    #include <algorithm>

    // Parse JSON array of numbers
    std::string input = values_json;
    if (input.front() == '[') input = input.substr(1);
    if (input.back() == ']') input = input.substr(0, input.size() - 1);

    std::vector<double> values;
    std::stringstream ss(input);
    std::string token;
    while (std::getline(ss, token, ',')) {
        try { values.push_back(std::stod(token)); } catch(...) {}
    }

    int n = values.size();
    double mean_val = 0.0;
    double stdev_val = 0.0;
    double min_val = 0.0;
    double max_val = 0.0;
    double range_val = 0.0;
    double median_val = 0.0;

    if (n > 0) {
        // Mean
        double sum = std::accumulate(values.begin(), values.end(), 0.0);
        mean_val = sum / n;

        // Std Deviation
        double sq_sum = 0.0;
        for (double v : values) {
            sq_sum += (v - mean_val) * (v - mean_val);
        }
        stdev_val = (n > 1) ? std::sqrt(sq_sum / (n - 1)) : 0.0;

        // Min/Max
        min_val = *std::min_element(values.begin(), values.end());
        max_val = *std::max_element(values.begin(), values.end());
        range_val = max_val - min_val;

        // Median
        std::vector<double> sorted = values;
        std::sort(sorted.begin(), sorted.end());
        if (n % 2 == 0) {
            median_val = (sorted[n/2 - 1] + sorted[n/2]) / 2.0;
        } else {
            median_val = sorted[n/2];
        }
    }

    // Z-scores
    std::stringstream zss;
    zss << "[";
    for (int i = 0; i < n; ++i) {
        if (i > 0) zss << ",";
        double z = (stdev_val > 0.0) ? (values[i] - mean_val) / stdev_val : 0.0;
        zss << std::fixed << std::setprecision(4) << z;
    }
    zss << "]";

    // Normalized (0-1)
    std::stringstream nss;
    nss << "[";
    for (int i = 0; i < n; ++i) {
        if (i > 0) nss << ",";
        double norm = (range_val > 0.0) ? (values[i] - min_val) / range_val : 0.0;
        nss << std::fixed << std::setprecision(4) << norm;
    }
    nss << "]";

    // Build result JSON
    std::stringstream result;
    result << std::fixed << std::setprecision(6);
    result << "{\"count\":" << n;
    result << ",\"mean\":" << mean_val;
    result << ",\"stdev\":" << stdev_val;
    result << ",\"min\":" << min_val;
    result << ",\"max\":" << max_val;
    result << ",\"range\":" << range_val;
    result << ",\"median\":" << median_val;
    result << ",\"z_scores\":" << zss.str();
    result << ",\"normalized\":" << nss.str();
    result << "}";

    std::string res = result.str();
    res
    >>

    return json.parse(stats_json)
}

// ── C++ Value-at-Risk (Historical VaR) ──────────────────────────
// Monte Carlo simulation for portfolio risk estimation

function compute_var(prices_json, changes_json, confidence_str) {
    let var_json = <<cpp[prices_json, changes_json, confidence_str]
    #include <vector>
    #include <cmath>
    #include <algorithm>
    #include <sstream>
    #include <string>
    #include <iomanip>
    #include <numeric>

    auto parse_array = [](const std::string& s) -> std::vector<double> {
        std::string input = s;
        if (!input.empty() && input.front() == '[') input = input.substr(1);
        if (!input.empty() && input.back() == ']') input = input.substr(0, input.size() - 1);
        std::vector<double> vals;
        std::stringstream ss(input);
        std::string token;
        while (std::getline(ss, token, ',')) {
            try { vals.push_back(std::stod(token)); } catch(...) {}
        }
        return vals;
    };

    std::vector<double> prices = parse_array(prices_json);
    std::vector<double> changes = parse_array(changes_json);
    double confidence = std::stod(confidence_str);

    int n = prices.size();
    double total_value = std::accumulate(prices.begin(), prices.end(), 0.0);

    // Sort changes for percentile calculation
    std::vector<double> sorted_changes = changes;
    std::sort(sorted_changes.begin(), sorted_changes.end());

    // VaR at confidence level (e.g., 95% -> take 5th percentile)
    double alpha = 1.0 - confidence;
    int var_index = std::max(0, (int)(alpha * sorted_changes.size()) - 1);
    double var_pct = (sorted_changes.size() > 0) ? sorted_changes[var_index] : 0.0;
    double var_dollar = total_value * std::abs(var_pct) / 100.0;

    // Expected Shortfall (CVaR) - average of losses beyond VaR
    double cvar_sum = 0.0;
    int cvar_count = 0;
    for (int i = 0; i <= var_index && i < (int)sorted_changes.size(); ++i) {
        cvar_sum += sorted_changes[i];
        cvar_count++;
    }
    double cvar_pct = (cvar_count > 0) ? cvar_sum / cvar_count : var_pct;
    double cvar_dollar = total_value * std::abs(cvar_pct) / 100.0;

    // Sharpe ratio approximation (using 24h returns, risk-free rate ~ 0 for crypto)
    double mean_change = 0.0;
    double stdev_change = 0.0;
    if (!changes.empty()) {
        mean_change = std::accumulate(changes.begin(), changes.end(), 0.0) / changes.size();
        double sq = 0.0;
        for (double c : changes) sq += (c - mean_change) * (c - mean_change);
        stdev_change = (changes.size() > 1) ? std::sqrt(sq / (changes.size() - 1)) : 1.0;
    }
    double sharpe = (stdev_change > 0.0) ? mean_change / stdev_change : 0.0;

    // Max drawdown from changes
    double peak = 100.0;
    double max_dd = 0.0;
    double cumulative = 100.0;
    for (double c : changes) {
        cumulative *= (1.0 + c / 100.0);
        if (cumulative > peak) peak = cumulative;
        double dd = (peak - cumulative) / peak * 100.0;
        if (dd > max_dd) max_dd = dd;
    }

    std::stringstream result;
    result << std::fixed << std::setprecision(4);
    result << "{\"portfolio_value\":" << total_value;
    result << ",\"var_pct\":" << std::abs(var_pct);
    result << ",\"var_dollar\":" << var_dollar;
    result << ",\"cvar_pct\":" << std::abs(cvar_pct);
    result << ",\"cvar_dollar\":" << cvar_dollar;
    result << ",\"sharpe_ratio\":" << sharpe;
    result << ",\"max_drawdown\":" << max_dd;
    result << ",\"confidence\":" << confidence;
    result << "}";

    std::string res = result.str();
    res
    >>

    return json.parse(var_json)
}

// ── Crypto Analytics (enhanced) ─────────────────────────────────

export function analyze_crypto(crypto_list) {
    io.write("  [FinanceEngine] Analyzing ", array.length(crypto_list), " cryptocurrencies...\n")

    // Extract prices for statistical analysis
    let prices = []
    let changes = []
    let i = 0
    while i < array.length(crypto_list) {
        array.push(prices, crypto_list[i].price_usd)
        array.push(changes, crypto_list[i].change_24h)
        i = i + 1
    }

    // Pipeline: build JSON string, compute stats
    let prices_json = json.stringify(prices)
    let price_stats = prices_json |> compute_statistics

    let changes_json = json.stringify(changes)
    let change_stats = changes_json |> compute_statistics

    // VaR computation via C++
    io.write("    [C++] Computing Value-at-Risk...\n")
    let confidence_str = "0.95"
    let var_result = compute_var(prices_json, changes_json, confidence_str)
    io.write("    VaR(95%): $", var_result["var_dollar"], " | Sharpe: ", var_result["sharpe_ratio"], "\n")

    // Build enriched analysis
    let analysis = []
    i = 0
    while i < array.length(crypto_list) {
        let c = crypto_list[i]
        let z_score = price_stats["z_scores"][i]
        let normalized = price_stats["normalized"][i]

        let volatility_class = if math.abs(c.change_24h) > 5.0 { "high" } else { if math.abs(c.change_24h) > 2.0 { "moderate" } else { "low" } }

        let entry = {
            "id": c.id,
            "name": c.name,
            "price_usd": c.price_usd,
            "change_24h": c.change_24h,
            "market_cap": c.market_cap,
            "volume_24h": c.volume_24h,
            "z_score": z_score,
            "normalized_price": normalized,
            "volatility_class": volatility_class,
            "is_live": c.is_live
        }
        array.push(analysis, entry)
        io.write("    ", c.name, ": $", c.price_usd, " (", c.change_24h, "%) z=", z_score, "\n")
        i = i + 1
    }

    return {
        "assets": analysis,
        "price_stats": price_stats,
        "change_stats": change_stats,
        "var": var_result
    }
}

// ── Currency Analytics (enhanced with arbitrage detection) ───────

export function analyze_currencies(currency_data) {
    io.write("  [FinanceEngine] Analyzing ", array.length(currency_data.rates), " currency pairs...\n")

    let rates_json = json.stringify(currency_data.rates)
    let rate_stats = rates_json |> compute_statistics

    // Purchasing Power Index (relative to USD)
    let ppi = []
    let i = 0
    while i < array.length(currency_data.rates) {
        let rate = currency_data.rates[i]
        let name = currency_data.rate_names[i]
        // Normalize: higher rate = weaker currency
        let strength = if rate < 1.0 { "stronger_than_usd" } else { if rate < 10.0 { "comparable_to_usd" } else { "weaker_than_usd" } }

        array.push(ppi, {
            "currency": name,
            "rate": rate,
            "inverse": math.round(1.0 / rate * 10000.0) / 10000.0,
            "strength": strength
        })
        io.write("    ", name, "/USD: ", rate, " (", strength, ")\n")
        i = i + 1
    }

    // Triangular arbitrage detection
    // Check EUR-GBP-USD triangle: buy EUR, convert to GBP, convert back to USD
    let arb_opportunities = []
    let eur_rate = 0.0
    let gbp_rate = 0.0
    let jpy_rate = 0.0
    i = 0
    while i < array.length(currency_data.rate_names) {
        let nm = currency_data.rate_names[i]
        if nm == "EUR" { eur_rate = currency_data.rates[i] }
        if nm == "GBP" { gbp_rate = currency_data.rates[i] }
        if nm == "JPY" { jpy_rate = currency_data.rates[i] }
        i = i + 1
    }

    if eur_rate > 0.0 {
        if gbp_rate > 0.0 {
            // USD -> EUR -> GBP -> USD
            let eur_amount = 1.0 * eur_rate
            let cross_rate = gbp_rate / eur_rate
            let back_to_usd = eur_amount / gbp_rate
            let arb_profit = (back_to_usd - 1.0) * 100.0
            let is_arb = if math.abs(arb_profit) > 0.01 { true } else { false }

            array.push(arb_opportunities, {
                "triangle": "USD->EUR->GBP->USD",
                "implied_rate": math.round(cross_rate * 10000.0) / 10000.0,
                "profit_pct": math.round(arb_profit * 10000.0) / 10000.0,
                "exploitable": is_arb
            })
        }
    }

    io.write("    Arbitrage opportunities checked: ", array.length(arb_opportunities), "\n")

    return {
        "base": currency_data.base,
        "pairs": ppi,
        "rate_stats": rate_stats,
        "arbitrage": arb_opportunities,
        "is_live": currency_data.is_live
    }
}
