// modules/tech_intel.naab
// GitHub repository analysis — pure NAAb with lambdas + investment recommendations
// Uses: def keyword alias, const, lambdas, for...in loops,
//       array.sort, array.reverse, array.first, array.last, array.slice,
//       array.find, array.contains, array.join, pipeline operator

use io
use array
use math
use string

// ── Scoring Functions (defined as regular functions) ─────────────

fn calc_popularity(stars, forks) {
    return math.round((stars * 0.7 + forks * 0.3) / 1000.0 * 100.0) / 100.0
}

fn calc_activity(issues, forks) {
    let ratio = 0.0
    if forks > 0 {
        ratio = issues * 1.0 / forks * 100.0
    }
    return math.round(ratio * 100.0) / 100.0
}

fn calc_health(stars, forks, issues) {
    let star_factor = math.min(stars / 10000.0, 10.0)
    let fork_factor = math.min(forks / 5000.0, 10.0)
    let issue_penalty = math.min(issues / 1000.0, 5.0)
    let score = (star_factor + fork_factor - issue_penalty) / 15.0 * 100.0
    return math.round(math.max(score, 0.0) * 100.0) / 100.0
}

// ── Investment Recommendation Engine ────────────────────────────
// Assigns "Strong Buy", "Buy", "Hold", "Watch" based on composite metrics

fn compute_recommendation(pop, health, stars_per_day, issue_ratio, tier) {
    // Composite investment score (0-100)
    let pop_score = math.min(pop / 2.0, 40.0)
    let health_score_adj = health * 0.3
    let growth_score = math.min(stars_per_day * 2.0, 20.0)
    let issue_penalty = math.min(issue_ratio * 0.5, 10.0)

    let composite = pop_score + health_score_adj + growth_score - issue_penalty
    composite = math.round(math.max(composite, 0.0) * 100.0) / 100.0

    let recommendation = if composite > 70.0 { "Strong Buy" } else { if composite > 50.0 { "Buy" } else { if composite > 30.0 { "Hold" } else { "Watch" } } }

    let rationale = if composite > 70.0 {
        "Exceptional community engagement, strong growth trajectory"
    } else {
        if composite > 50.0 {
            "Solid fundamentals with good community support"
        } else {
            if composite > 30.0 {
                "Stable project, moderate growth potential"
            } else {
                "Monitor for improvements before investing resources"
            }
        }
    }

    return {
        "composite_score": composite,
        "recommendation": recommendation,
        "rationale": rationale
    }
}

// ── Main Analysis Function (enhanced) ───────────────────────────

export def analyze_repos(repo_list) {
    io.write("  [TechIntel] Analyzing ", array.length(repo_list), " repositories...\n")

    // Constants inside function scope
    const DAYS_SINCE_LINUX_CREATION = 12500
    const DAYS_SINCE_VSCODE_CREATION = 3800
    const DAYS_SINCE_RUST_CREATION = 5400

    // Lambda scoring functions (showcase lambda syntax)
    let popularity_score = func(stars, forks) {
        return calc_popularity(stars, forks)
    }

    let activity_score = func(issues, forks) {
        return calc_activity(issues, forks)
    }

    let health_score = func(stars, forks, issues) {
        return calc_health(stars, forks, issues)
    }

    let days_map = {
        "torvalds/linux": DAYS_SINCE_LINUX_CREATION,
        "microsoft/vscode": DAYS_SINCE_VSCODE_CREATION,
        "rust-lang/rust": DAYS_SINCE_RUST_CREATION
    }

    let analysis = []
    let i = 0

    while i < array.length(repo_list) {
        let repo = repo_list[i]

        // Compute metrics using lambda scoring functions
        let pop = popularity_score(repo.stars, repo.forks)
        let act = activity_score(repo.open_issues, repo.forks)
        let hlth = health_score(repo.stars, repo.forks, repo.open_issues)

        // Stars per day estimate
        let age_days = 5000
        try {
            age_days = days_map[repo.full_name]
        } catch (e) {
            age_days = 5000
        }
        let stars_per_day = math.round(repo.stars * 1.0 / age_days * 100.0) / 100.0

        // Issue ratio
        let issue_ratio = 0.0
        if repo.stars > 0 {
            issue_ratio = math.round(repo.open_issues * 1000.0 / repo.stars) / 10.0
        }

        // Tier classification using if-expressions
        let tier = if pop > 100.0 { "S-Tier" } else { if pop > 50.0 { "A-Tier" } else { if pop > 20.0 { "B-Tier" } else { "C-Tier" } } }

        // Investment recommendation
        let rec = compute_recommendation(pop, hlth, stars_per_day, issue_ratio, tier)

        let entry = {
            "full_name": repo.full_name,
            "stars": repo.stars,
            "forks": repo.forks,
            "open_issues": repo.open_issues,
            "language": repo.language,
            "description": repo.description,
            "popularity_score": pop,
            "activity_score": act,
            "health_score": hlth,
            "stars_per_day": stars_per_day,
            "issue_ratio": issue_ratio,
            "tier": tier,
            "recommendation": rec["recommendation"],
            "composite_score": rec["composite_score"],
            "rationale": rec["rationale"],
            "is_live": repo.is_live
        }

        array.push(analysis, entry)

        io.write("    ", repo.full_name, " [", tier, "] -> ", rec["recommendation"], "\n")
        io.write("      Stars: ", repo.stars, " | Forks: ", repo.forks, " | Issues: ", repo.open_issues, "\n")
        io.write("      Pop: ", pop, " | Health: ", hlth, " | Composite: ", rec["composite_score"], "\n")
        io.write("      ", rec["rationale"], "\n")
        i = i + 1
    }

    // Find top repo by composite score
    let top_repo = ""
    let top_score = 0.0
    let top_rec = ""
    i = 0
    while i < array.length(analysis) {
        if analysis[i]["composite_score"] > top_score {
            top_score = analysis[i]["composite_score"]
            top_repo = analysis[i]["full_name"]
            top_rec = analysis[i]["recommendation"]
        }
        i = i + 1
    }

    // Count recommendations
    let strong_buy_count = 0
    let buy_count = 0
    let hold_count = 0
    let watch_count = 0
    i = 0
    while i < array.length(analysis) {
        let r = analysis[i]["recommendation"]
        if r == "Strong Buy" { strong_buy_count = strong_buy_count + 1 }
        if r == "Buy" { buy_count = buy_count + 1 }
        if r == "Hold" { hold_count = hold_count + 1 }
        if r == "Watch" { watch_count = watch_count + 1 }
        i = i + 1
    }

    return {
        "repos": analysis,
        "top_repo": top_repo,
        "top_score": top_score,
        "top_recommendation": top_rec,
        "repo_count": array.length(analysis),
        "recommendation_summary": {
            "strong_buy": strong_buy_count,
            "buy": buy_count,
            "hold": hold_count,
            "watch": watch_count
        }
    }
}
