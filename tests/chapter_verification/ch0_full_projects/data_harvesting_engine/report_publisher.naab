// report_publisher.naab - Module for generating various reports

// Import standard library modules
use io
use json
use string
use array
use file
use time

// Imports structs from other modules
use app_config
use data_transformer
use insight_generator

// Function to generate an HTML report using Jinja2 in Python
fn generate_html_report(
    analysis_results: insight_generator.AnalysisResults,
    processed_data: list<data_transformer.ProcessedItem>,
    report_config: app_config.ReportConfig
) -> string? {
    io.write("üìÑ Generating HTML report from template: ", report_config.template_path, "\n")

    let analysis_results_json = json.stringify(analysis_results)
    let processed_data_json = json.stringify(processed_data)
    let template_path = report_config.template_path
    let current_timestamp = time.now() // Get current NAAb timestamp
    let timestamp_str = json.stringify(current_timestamp)

    let report_content = <<python[analysis_results_json, processed_data_json, template_path, timestamp_str]
from jinja2 import Environment, FileSystemLoader
import json
import sys
import os
import io as pyio
import datetime

old_stdout = sys.stdout
old_stderr = sys.stderr
redirected_output = pyio.StringIO()
sys.stdout = redirected_output
sys.stderr = old_stderr

analysis_results = json.loads(analysis_results_json)
processed_data = json.loads(processed_data_json)
# template_path is already bound
naab_timestamp = float(timestamp_str)

generated_report_html = None
error_message = None

try:
    template_dir = os.path.dirname(template_path)
    if not template_dir: # If path is just a filename, assume current directory
        template_dir = "." 
    template_name = os.path.basename(template_path)

    # Setup Jinja2 environment
    env = Environment(loader=FileSystemLoader(template_dir))

    # Add float_to_datetime filter
    def float_to_datetime_filter(timestamp_float):
        if timestamp_float is None:
            return "N/A"
        return datetime.datetime.fromtimestamp(timestamp_float).strftime('%Y-%m-%d %H:%M:%S')

    env.filters['float_to_datetime'] = float_to_datetime_filter

    template = env.get_template(template_name)

    # For reporting, ensure processed_data has sentiment polarity if not explicitly calculated per item
    for item in processed_data:
        if 'sentiment_polarity' not in item:
            item['sentiment_polarity'] = 0.0 # Default if not analyzed per item

    # Override the analysis timestamp with a formatted current time
    analysis_results['timestamp'] = float_to_datetime_filter(naab_timestamp)

    # Render the template with the data
    generated_report_html = template.render(
        analysis=analysis_results,
        data=processed_data,
        timestamp_float=naab_timestamp # Pass float timestamp as well
    )

except Exception as e:
    error_message = f"Python Jinja2 Error: {e}"
    # Also capture any Python print specific error messages
    redirected_output.seek(0)
    python_log = redirected_output.read()
    if python_log:
        error_message += "\nPython Log: " + python_log

finally:
    sys.stdout = old_stdout
    sys.stderr = old_stderr

if error_message:
    _ = json.dumps({"error": error_message}) # Return error as JSON
else:
    _ = generated_report_html # Return the raw HTML string
    >>

    let python_output_str = report_content

    if str.starts_with(python_output_str, "{") && str.contains(python_output_str, "\"error\":") {
        let error_obj = json.parse(python_output_str)
        if error_obj["error"] != null {
            io.write_error("‚ùå HTML report generation failed: ", error_obj["error"], "\n")
            return null
        }
    }
    return python_output_str
}

// Function to export processed data to a CSV file using Python's csv module
fn export_to_csv(data: list<data_transformer.ProcessedItem>, filename: string) -> bool {
    io.write("üìä Exporting data to CSV: ", filename, "\n")

    let data_json = json.stringify(data)
    let result_status = <<python[data_json, filename]
import csv
import json
import sys
import os
import io as pyio

old_stdout = sys.stdout
old_stderr = sys.stderr
redirected_output = pyio.StringIO()
sys.stdout = redirected_output
sys.stderr = old_stderr

data_str = data_json
output_filename = filename

success = False
error_message = None

try:
    processed_data = json.loads(data_str)
    
    if not processed_data:
        # Create an empty file if no data, but write headers
        with open(output_filename, 'w', newline='', encoding='utf-8') as f:
            # If there's a schema, try to get headers from it
            if processed_data and processed_data[0]:
                fieldnames = list(processed_data[0].keys())
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
            # else: file will be empty
        success = True
    else:
        # Assuming all dicts have the same keys for headers
        fieldnames = list(processed_data[0].keys())
        
        with open(output_filename, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(processed_data)
        success = True

except Exception as e:
    error_message = f"Python CSV export error: {e}"
    # Also capture any Python print specific error messages
    redirected_output.seek(0)
    python_log = redirected_output.read()
    if python_log:
        error_message += "\nPython Log: " + python_log

finally:
    sys.stdout = old_stdout
    sys.stderr = old_stderr

if error_message:
    _ = json.dumps({"error": error_message}) # Return error as JSON
else:
    _ = "True" if success else "False" # Return success status as string
    >>

    let python_output_str = result_status

    if str.starts_with(python_output_str, "{") && str.contains(python_output_str, "\"error\":") {
        let error_obj = json.parse(python_output_str)
        if error_obj["error"] != null {
            io.write_error("‚ùå CSV export failed: ", error_obj["error"], "\n")
            return false
        }
    }

    return python_output_str == "True"
}
