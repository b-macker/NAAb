// asset_manager.naab - Module for managing data and report assets (storage, directories, archiving)

use io as io
use file as fs
use string as str
use array as arr
use time as time

// Imports ReportConfig from config.naab
use app_config

// Function to save content to a file
fn save_data(content: string, filename: string, append_mode: bool) -> bool {
    io.write("üíæ Saving data to file: ", filename, " (append=", append_mode, ")\n")
    try {
        if append_mode {
            fs.append(filename, content)
        } else {
            fs.write(filename, content)
        }
        io.write("‚úì Data saved successfully.\n")
        return true
    } catch (e) {
        io.write_error("‚ùå Failed to save data to file ", filename, ": ", e, "\n")
        return false
    }
}

// Function to ensure a directory exists, creating it if necessary using a Shell block
fn create_directory_if_not_exists(path: string) -> bool {
    io.write("üìÅ Ensuring directory exists: ", path, "\n")

    let result = <<sh[path]
mkdir -p "$path"
    >>

    if result.exit_code == 0 {
        io.write("‚úì Directory created/exists.\n")
        return true
    } else {
        io.write_error("‚ùå Failed to create directory '", path, "': ", result.stderr, "\n")
        return false
    }
}

// Function to archive old files in a directory using Shell commands (find, tar, mv)
fn archive_old_files(source_dir: string, archive_dir: string, retention_days: int) -> bool {
    io.write("üì¶ Archiving old files in '", source_dir, "' older than ", retention_days, " days...\n")

    if !create_directory_if_not_exists(archive_dir) {
        return false
    }

    // Find files older than retention_days
    let retention_str = json.stringify(retention_days)
    let find_result = <<sh[source_dir, retention_str]
find "$source_dir" -maxdepth 1 -type f -mtime +"$retention_str" 2>/dev/null
    >>

    if find_result.exit_code != 0 || str.trim(find_result.stdout) == "" {
        io.write("No old files to archive in '", source_dir, "'.\n")
        return true
    }

    let old_files_list = str.split(str.trim(find_result.stdout), "\n")

    if array.length(old_files_list) == 0 {
        io.write("No old files to archive in '", source_dir, "'.\n")
        return true
    }

    // Create archive with timestamp
    let timestamp_str = json.stringify(time.now())
    let archive_prefix = str.concat(archive_dir, "/archive-")
    let archive_name = str.concat(archive_prefix, str.concat(timestamp_str, ".tar.gz"))

    // Build tar command - Note: shell blocks don't support complex loops, so we use find -print0 | tar
    let tar_result = <<sh[source_dir, retention_str, archive_name]
find "$source_dir" -maxdepth 1 -type f -mtime +"$retention_str" -print0 | tar -czf "$archive_name" --null -T - 2>&1
    >>

    if tar_result.exit_code == 0 {
        io.write("‚úì Old files archived to ", archive_name, ".\n")

        // Remove original files
        let rm_result = <<sh[source_dir, retention_str]
find "$source_dir" -maxdepth 1 -type f -mtime +"$retention_str" -delete 2>&1
        >>

        if rm_result.exit_code == 0 {
            io.write("‚úì Original old files removed.\n")
            return true
        } else {
            io.write_error("‚ùå Failed to remove original old files: ", rm_result.stderr, "\n")
            return false
        }
    } else {
        io.write_error("‚ùå Failed to create archive: ", tar_result.stderr, "\n")
        return false
    }
}
