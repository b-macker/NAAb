// modules/logger.naab
// Centralized logging module for GEMRS.
// Refactored to adhere to NAAb's strict top-level declarations and use built-in functions directly.

// --- Factory Function: createLogger ---
// This function returns a map of logging functions that are "bound" to the provided config and global built-in functions.
export func createLogger(config: Map<String, Any>, sysIOFunctions: Map<String, Any>, sysTimeFunctions: Map<String, Any>): Map<String, Any> {

    // Define log levels as constants (now inside the factory function)
    let LOG_LEVEL_INFO = "INFO";
    let LOG_LEVEL_WARN = "WARN";
    let LOG_LEVEL_ERROR = "ERROR";
    let LOG_LEVEL_DEBUG = "DEBUG";

    let logFilePath = config.get("logging.file_path", "gemrs.log");
    let currentLogLevel = config.get("application.log_level", "INFO").toUpperCase();

    // NOTE: Built-in functions like 'print', 'error', 'exit', 'len', 'type', 'typeof',
    // 'int', 'float', 'string', 'bool' are assumed to be globally available without explicit import.
    // Dynamic access to filesystem (createDirectory, appendToFile, getParentDirectory)
    // and time (getCurrentTimestamp, sleep) will also be assumed to be globally available built-ins.
    // If these are not built-ins, they would need to be passed in from main().

    // --- Internal Function: getLogLevelValue ---
    // Helper to get numeric value of a log level for comparison.
    let getLogLevelValue = func(level) {
        if level == LOG_LEVEL_DEBUG {
            return 0;
        } else if level == LOG_LEVEL_INFO {
            return 1;
        } else if level == LOG_LEVEL_WARN {
            return 2;
        } else if level == LOG_LEVEL_ERROR {
            return 3;
        } else {
            return -1; // Unknown level
        }
    };

    // --- Internal Function: formatLogEntry ---
    // Formats a log message with timestamp and level, using the assumed global getCurrentTimestamp built-in.
    let formatLogEntry = func(level, message) {
        let getCurrentTimestamp = sysTimeFunctions.getCurrentTimestamp;
        let timestamp = getCurrentTimestamp();
        return "[${timestamp}] [${level}] ${message}";
    };

    // --- Internal Function: writeLog ---
    // Internal function to write a formatted message, using the assumed global print/error built-ins and appendToFile.
    let writeLog = func(level: String, message: String) {
        let formattedMessage = formatLogEntry(level, message);

        // Ensure log directory exists
        let getParentDirectory = sysIOFunctions.getParentDirectory;
        let createDirectory = sysIOFunctions.createDirectory;
        let appendToFile = sysIOFunctions.appendToFile;

        let logDir = getParentDirectory(logFilePath);
        createDirectory(logDir);
        appendToFile(logFilePath, formattedMessage + "\n");

        if level == LOG_LEVEL_ERROR || level == LOG_LEVEL_WARN {
            print(formattedMessage);
        } else {
            print(formattedMessage);
        }
    };

    // --- Public Logger Functions (returned as a map) ---
    let logInfoBound = func(message: String) {
        let logLevelCheck = getLogLevelValue("INFO") >= getLogLevelValue(currentLogLevel);
        if (logLevelCheck) { writeLog("INFO", message); }
    };
    let logWarnBound = func(message: String) {
        let logLevelCheck = getLogLevelValue("WARN") >= getLogLevelValue(currentLogLevel);
        if (logLevelCheck) { writeLog("WARN", message); }
    };
    let logErrorBound = func(message: String, errorDetails: String) {
        let logLevelCheck = getLogLevelValue("ERROR") >= getLogLevelValue(currentLogLevel);
        if (logLevelCheck) { writeLog("ERROR", "${message} Error details: ${errorDetails}"); }
    };
    let logDebugBound = func(message: String) {
        let logLevelCheck = getLogLevelValue("DEBUG") >= getLogLevelValue(currentLogLevel);
        if (logLevelCheck) { writeLog("DEBUG", message); }
    };

    // Direct access to global built-ins for external system functions (like timestamp, file ops)
    // These functions are assumed to be directly callable globally, not dynamically accessed via a map.
    let getCurrentTimestampBound = func(): String {
        return sysTimeFunctions.getCurrentTimestamp();
    };
    let createDirectoryBound = func(dirPath: String) {
        sysIOFunctions.createDirectory(dirPath);
    };
    let appendToFileBound = func(filePath: String, content: String) {
        sysIOFunctions.appendToFile(filePath, content);
    };

    return {
        "logInfo": logInfoBound,
        "logWarn": logWarnBound,
        "logError": logErrorBound,
        "logDebug": logDebugBound,
        "getCurrentTimestamp": getCurrentTimestampBound,
        "createDirectory": createDirectoryBound,
        "appendToFile": appendToFileBound
    };
}
