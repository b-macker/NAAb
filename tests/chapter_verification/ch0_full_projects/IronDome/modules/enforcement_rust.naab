// IronDome/modules/enforcement_rust.naab
// High-Speed Enforcement Engine using Rust
// Uses: <<rust>>, json, io

use io
use json
use array
use string

// ── Public Interface ────────────────────────────────────────────

export fn execute_gates(gates, files) {
    let g_json = json.stringify(gates)
    let f_json = json.stringify(files)
    
    let report_json = <<rust[g_json, f_json]

    use std::fmt::Write; // For fmt::format


    // Helper to escape strings for JSON output
    fn escape_json_string(s: &str) -> String {
        let mut escaped = String::new();
        for c in s.chars() {
            match c {
                '\\' => escaped.push_str("\\\\"), // Escape backslash itself
                '"' => escaped.push_str("\\\""), // Escape double quote
                '\n' => escaped.push_str("\\n"), // Escape newline
                '\r' => escaped.push_str("\\r"), // Escape carriage return
                '\t' => escaped.push_str("\\t"), // Escape tab
                _ => escaped.push(c),
            }
        }
        escaped
    }

    // Simplified manual JSON parsing functions (assuming flat structure and known keys)
    fn get_json_field<'a>(json_obj: &'a str, key: &str) -> Option<&'a str> {
        let search_key = format!("\"{}\":", key);
        if let Some(start_idx) = json_obj.find(&search_key) {
            let value_start = start_idx + search_key.len();
            let mut depth = 0;
            let mut in_string = false;
            for (i, c) in json_obj[value_start..].chars().enumerate() {
                if c == '"' && (i == 0 || json_obj[value_start..].chars().nth(i-1) != Some('\\')) {
                    in_string = !in_string;
                }
                if !in_string {
                    if c == '{' || c == '[' { depth += 1; }
                    else if c == '}' || c == ']' { depth -= 1; }
                    else if c == ',' && depth == 0 {
                        return Some(json_obj[value_start..value_start+i].trim());
                    }
                }
            }
            return Some(json_obj[value_start..].trim_end_matches('}').trim_end_matches(']').trim().trim_end_matches(',')); // Handle last field
        }
        None
    }

    fn parse_json_bool(s: &str) -> bool {
        s.trim().to_lowercase() == "true"
    }
    fn parse_json_u64(s: &str) -> Option<u64> {
        s.trim().parse::<u64>().ok()
    }
    fn parse_json_string<'a>(s: &'a str) -> &'a str {
        s.trim_matches('"').trim()
    }
    fn parse_json_array_of_strings<'a>(s: &'a str) -> Option<Vec<String>> {
        let trimmed = s.trim_matches(|c| c == '[' || c == ']').trim();
        if trimmed.is_empty() { return Some(Vec::new()); }
        Some(trimmed.split(',')
                     .map(|item| parse_json_string(item).to_string())
                     .collect())
    }


    struct Gate {
        id: String,
        name: String,
        severity: String,
        threshold_bytes: Option<u64>,
        patterns: Option<Vec<String>>,
        blocking: bool,
    }

    struct FileInfo {
        path: String,
        size: u64,
        permissions: String,
        executable: bool,
    }

    struct Violation {
        gate_id: String,
        file_path: String,
        message: String,
        severity: String,
        blocking: bool,
    }

    // Manual parsing of gates_json
    fn parse_gates_from_json(json_str: &str) -> Vec<Gate> {
        let mut gates = Vec::new();
        // This is a very simplified parser, assuming a specific, well-formed JSON array of objects
        // and no complex nesting other than arrays of strings.
        let mut current_pos = 0;
        while let Some(start_idx) = json_str[current_pos..].find('{') {
            let obj_start = current_pos + start_idx;
            if let Some(end_idx) = json_str[obj_start..].find('}') {
                let obj_end = obj_start + end_idx;
                let obj_str = &json_str[obj_start..obj_end+1];

                let id = get_json_field(obj_str, "id").map(parse_json_string).unwrap_or("").to_string();
                let name = get_json_field(obj_str, "name").map(parse_json_string).unwrap_or("").to_string();
                let severity = get_json_field(obj_str, "severity").map(parse_json_string).unwrap_or("").to_string();
                let threshold_bytes = get_json_field(obj_str, "threshold_bytes").and_then(parse_json_u64);
                let patterns = get_json_field(obj_str, "patterns").and_then(parse_json_array_of_strings);
                let blocking = get_json_field(obj_str, "blocking").map(parse_json_bool).unwrap_or(false);

                gates.push(Gate {
                    id,
                    name,
                    severity,
                    threshold_bytes,
                    patterns,
                    blocking
                });
                current_pos = obj_end + 1;
            } else {
                break; // Malformed JSON
            }
        }
        gates
    }
    
    // Manual parsing of files_json
    fn parse_files_from_json(json_str: &str) -> Vec<FileInfo> {
        let mut files = Vec::new();
        let mut current_pos = 0;
        while let Some(start_idx) = json_str[current_pos..].find('{') {
            let obj_start = current_pos + start_idx;
            if let Some(end_idx) = json_str[obj_start..].find('}') {
                let obj_end = obj_start + end_idx;
                let obj_str = &json_str[obj_start..obj_end+1];

                let path = get_json_field(obj_str, "path").map(parse_json_string).unwrap_or("").to_string();
                let size = get_json_field(obj_str, "size").and_then(parse_json_u64).unwrap_or(0);
                let permissions = get_json_field(obj_str, "permissions").map(parse_json_string).unwrap_or("").to_string();
                let executable = get_json_field(obj_str, "executable").map(parse_json_bool).unwrap_or(false);

                files.push(FileInfo {
                    path,
                    size,
                    permissions,
                    executable
                });
                current_pos = obj_end + 1;
            } else {
                break; // Malformed JSON
            }
        }
        files
    }

    let gates = parse_gates_from_json(&g_json);
    let files = parse_files_from_json(&f_json);

    let mut violations = Vec::new();
    let mut failed_gates_count = 0;
    let mut passed_gates_count = 0;

    for gate in &gates {
        let mut gate_failed_this_run = false; // Track if this specific gate failed any check
        
        // Gate: File Size Limit
        if gate.id == "gate_file_size" {
            if let Some(limit) = gate.threshold_bytes {
                for file in &files {
                    if file.size > limit {
                        violations.push(Violation {
                            gate_id: gate.id.clone(),
                            file_path: file.path.clone(),
                            message: format!("File size ({}) exceeds limit ({})", file.size, limit),
                            severity: gate.severity.clone(),
                            blocking: gate.blocking,
                        });
                        gate_failed_this_run = true;
                    }
                }
            }
        }

        // Gate: Secret Detection
        if gate.id == "gate_no_secrets" {
            if let Some(patterns) = &gate.patterns {
                for file in &files {
                    // This is a mock scanning. In real-world, would read file content.
                    for pat in patterns {
                        if file.path.contains(pat) {
                            violations.push(Violation {
                                gate_id: gate.id.clone(),
                                file_path: file.path.clone(),
                                message: format!("Potential secret pattern '{}' found in path", pat),
                                severity: gate.severity.clone(),
                                blocking: gate.blocking,
                            });
                            gate_failed_this_run = true;
                        }
                    }
                }
            }
        }
        
        // Gate: File Permissions Check
        if gate.id == "gate_file_permissions" {
            for file in &files {
                // Check for world-writable executable files (simplified)
                if file.executable && file.permissions.contains('w') && file.permissions.contains('x') { // 'x' for executable, 'w' for writable
                    violations.push(Violation {
                        gate_id: gate.id.clone(),
                        file_path: file.path.clone(),
                        message: format!("Executable file has suspicious world-writable permissions: {}", file.permissions),
                        severity: gate.severity.clone(),
                        blocking: gate.blocking,
                    });
                    gate_failed_this_run = true;
                }
            }
        }

        if gate_failed_this_run {
            failed_gates_count += 1;
        } else {
            passed_gates_count += 1;
        }
    }

    let blocking_count = violations.iter().filter(|v| v.blocking).count();

    // Manually serialize Report struct to JSON string
    let mut report_json_str = String::new();
    write!(&mut report_json_str, "{{\"total_gates\":{},\"passed\":{},\"failed\":{},\"blocking_violations\":{},\"violations\":[", 
        gates.len(), passed_gates_count, failed_gates_count, blocking_count).unwrap();
    for (i, v) in violations.iter().enumerate() {
        if i > 0 { write!(&mut report_json_str, ",").unwrap(); }
        write!(&mut report_json_str, "{{\"gate_id\":\"{}\",\"file_path\":\"{}\",\"message\":\"{}\",\"severity\":\"{}\",\"blocking\":{}}}", 
            escape_json_string(&v.gate_id), 
            escape_json_string(&v.file_path), 
            escape_json_string(&v.message), 
            escape_json_string(&v.severity), 
            v.blocking).unwrap();
    }
    write!(&mut report_json_str, "]}}").unwrap();
    
    report_json_str
    >>
    
    return json.parse(report_json)
}