// IronDome/modules/deep_scan_cpp.naab
// Deep File System Scanner using C++
// Uses: <<cpp>>, io, json

use io
use json

// ── C++ Scanner Logic ──────────────────────────────────────────

fn cpp_scanner(root_path, ignore_json) {
    let result = <<cpp[root_path, ignore_json]
    #include <string>
    #include <vector>
    #include <filesystem>
    #include <fstream>
    #include <sstream>
    #include <iostream>
    #include <set>
    #include <chrono>

    struct FileMeta {
        std::string path;
        uintmax_t size;
        std::string permissions;
        bool is_executable;
    };

    // Main execution logic starts here, with inlined helper logic
    std::string final_json_output = "{\"error\":\"Unknown C++ scanner error\"}"; // Default error output

    try {
        auto start = std::chrono::high_resolution_clock::now();
        std::string root = root_path;
        
        // Inlined parse_ignores_local logic
        std::set<std::string> ignores;
        std::string ignore_s = ignore_json;
        if (ignore_s.size() > 2) {
            ignore_s = ignore_s.substr(1, ignore_s.size() - 2); // remove []
            std::stringstream ss_ignore(ignore_s);
            std::string item;
            while (std::getline(ss_ignore, item, ',')) {
                size_t first = item.find('"');
                size_t last = item.rfind('"');
                if (first != std::string::npos && last != std::string::npos && last > first) {
                    ignores.insert(item.substr(first + 1, last - first - 1));
                }
            }
        }

        std::vector<FileMeta> files;
    
        if (std::filesystem::exists(root) && std::filesystem::is_directory(root)) {
            for (const auto& entry : std::filesystem::recursive_directory_iterator(root)) {
                if (entry.is_regular_file()) {
                    std::string filename = entry.path().filename().string();
                    bool ignored = false;
                    for (const auto& ig : ignores) {
                        if (filename == ig || entry.path().string().find(ig) != std::string::npos) {
                            ignored = true;
                            break;
                        }
                    }
                    if (ignored) continue;

                    FileMeta meta;
                    meta.path = entry.path().string();
                    meta.size = entry.file_size();
                    
                    auto perms = entry.status().permissions();
                    std::string p_str;
                    p_str += (perms & std::filesystem::perms::owner_read) != std::filesystem::perms::none ? "r" : "-";
                    p_str += (perms & std::filesystem::perms::owner_write) != std::filesystem::perms::none ? "w" : "-";
                    p_str += (perms & std::filesystem::perms::owner_exec) != std::filesystem::perms::none ? "x" : "-";
                    meta.permissions = p_str;
                    meta.is_executable = (perms & std::filesystem::perms::owner_exec) != std::filesystem::perms::none;

                    files.push_back(meta);
                }
            }
        }
    
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

        std::stringstream json_out;
        json_out << "{";
        json_out << "\"duration_ms\":" << duration << ",";
        json_out << "\"file_count\":" << files.size() << ",";
        json_out << "\"files\":[";
        for (size_t i = 0; i < files.size(); ++i) {
            if (i > 0) json_out << ",";
            json_out << "{";
            
            // Inlined escape_json_local logic
            std::string escaped_path;
            for (char c : files[i].path) {
                if (c == '"') escaped_path += "\\\"";
                else if (c == '\\') escaped_path += "\\\\";
                else if (c == '\b') escaped_path += "\\b";
                else if (c == '\f') escaped_path += "\\f";
                else if (c == '\n') escaped_path += "\\n";
                else if (c == '\r') escaped_path += "\\r";
                else if (c == '\t') escaped_path += "\\t";
                else escaped_path += c;
            }
            json_out << "\"path\":\"" << escaped_path << "\",";
            
            json_out << "\"size\":" << files[i].size << ",";
            json_out << "\"permissions\":\"" << files[i].permissions << "\",";
            json_out << "\"executable\":" << (files[i].is_executable ? "true" : "false");
            json_out << "}";
        }
        json_out << "]}";
        final_json_output = json_out.str(); // Assign successful output
    } catch (const std::exception& e) {
        // Inlined escape_json_local logic for error message
        std::string escaped_error;
        std::string error_what = e.what();
        for (char c : error_what) {
            if (c == '"') escaped_error += "\\\"";
            else if (c == '\\') escaped_error += "\\\\";
            else if (c == '\b') escaped_error += "\\b";
            else if (c == '\f') escaped_error += "\\f";
            else if (c == '\n') escaped_error += "\\n";
            else if (c == '\r') escaped_error += "\\r";
            else if (c == '\t') escaped_error += "\\t";
            else escaped_error += c;
        }
        final_json_output = "{\"error\":\"C++ scanner exception: " + escaped_error + "\"}";
    } catch (...) {
        final_json_output = "{\"error\":\"Unknown C++ scanner exception\"}";
    }
    
    std::cout << final_json_output; // Print to stdout for NAAb to capture
    return 0; // Explicitly return an integer for the C++ block
    >>
    
    return json.parse(result)
}

// ── Public Interface ────────────────────────────────────────────

export fn scan_workspace(root, config) {
    let ignore_list = config["ignore"]
    let ignore_json = json.stringify(ignore_list)
    
    // Call C++ scanner
    return cpp_scanner(root, ignore_json)
}
