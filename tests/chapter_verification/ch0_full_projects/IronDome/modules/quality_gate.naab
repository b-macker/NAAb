// IronDome/modules/quality_gate.naab
// Code Quality & Documentation Gate
// Uses: <<python>>, <<typescript>>, json, io

use io
use json

export fn check_quality(files) {
    let files_json = json.stringify(files)

    // Stage 1: Documentation Coverage (Python)
    let doc_json = <<python[files_json]
import json
import ast
import os

files = json.loads(files_json)
documented = 0
total_items = 0

for f in files:
    path = f["path"]
    if not path.endswith(".py"): continue
    if not os.path.exists(path): continue
    
    try:
        with open(path, "r") as src:
            tree = ast.parse(src.read())
            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Module)):
                    total_items += 1
                    if ast.get_docstring(node):
                        documented += 1
    except:
        pass

coverage = (documented / total_items * 100) if total_items > 0 else 100.0
res = {"doc_coverage": coverage, "documented": documented, "total_items": total_items}
json.dumps(res)
    >>
    let doc_data = json.parse(doc_json)

    // Stage 2: Structural Linting (TypeScript)
    let lint_json = <<typescript[files_json]
    const files = JSON.parse(files_json);
    let issues = 0;
    files.forEach(f => {
        if (f.path.includes("temp") || f.path.includes("test_copy")) {
            issues++;
        }
    });
    console.log(JSON.stringify({ lint_issues: issues, status: issues > 0 ? "WARNING" : "CLEAN" }));
    >>
    let lint_data = json.parse(lint_json)

    let bonus = if lint_data["status"] == "CLEAN" { 30 } else { 0 }
    let score = (doc_data["doc_coverage"] * 0.7) + bonus

    return {
        "documentation": doc_data,
        "lint": lint_data,
        "quality_score": score
    }
}
