// Integration Test: Block composition validation
// Tests: Type checking, adapter suggestions, error messages

use string
use array

fn process_string(str) {
    return string.upper(str)
}

fn count_length(str) {
    return string.length(str)
}

fn to_str(x) {
    return "" + x
}

fn create_range(n) {
    let result = []
    let i = 0
    while i < n {
        result = array.push(result, i + 1)
        i = i + 1
    }
    return result
}

fn sum_array(arr) {
    return array.reduce_fn(arr, fn(acc, x) { return acc + x }, 0)
}

main {
    print("Testing block composition validation workflow...")

    // Test 1: Compatible types should compose
    let result1 = "hello" |> process_string |> count_length
    if result1 != 5 {
        throw "FAIL: compatible composition should work, got " + result1
    }
    print("PASS: compatible type composition")

    // Test 2: Type transformation pipeline
    let str_42 = to_str(42)
    if str_42 != "42" {
        throw "FAIL: to_str should work, got " + str_42
    }
    print("PASS: type transformation in pipeline")

    // Test 3: Array transformation pipeline
    let nums = [1, 2, 3]
    let strs = array.map_fn(nums, fn(x) { return "" + x })
    let joined = array.join(strs, ",")
    if joined != "1,2,3" {
        throw "FAIL: array transformation pipeline failed, got " + joined
    }
    print("PASS: array type transformation pipeline")

    // Test 4: Complex data flow
    let result4 = 5 |> create_range |> sum_array
    if result4 != 15 {
        throw "FAIL: complex data flow failed, got " + result4
    }
    print("PASS: complex data flow composition")

    print("All composition validation tests passed")
}
