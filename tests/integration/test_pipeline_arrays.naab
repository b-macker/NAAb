// Integration Test: Pipeline with array higher-order functions
// Tests: |> with map, filter, reduce

use array

function double(x) {
    return x * 2
}

main {
    let numbers = [1, 2, 3, 4, 5]

    // Test 1: Pipeline with map
    let result1 = array.map_fn(numbers, fn(x) { return x * 2 })
    if array.length(result1) != 5 {
        throw "FAIL: map should return array of length 5"
    }
    print("PASS: array map")

    // Test 2: Pipeline with filter
    let result2 = array.filter_fn(numbers, fn(x) { return x % 2 == 0 })
    if array.length(result2) != 2 {
        throw "FAIL: filter should return 2 elements, got " + array.length(result2)
    }
    print("PASS: array filter")

    // Test 3: Chained map and filter
    let doubled = array.map_fn(numbers, fn(x) { return x * 2 })
    let result3 = array.filter_fn(doubled, fn(x) { return x > 5 })
    if array.length(result3) != 3 {
        throw "FAIL: chained map/filter should return 3 elements, got " + array.length(result3)
    }
    print("PASS: chained map and filter")

    // Test 4: Reduce
    let result4 = array.reduce_fn(numbers, fn(acc, x) { return acc + x }, 0)
    if result4 != 15 {
        throw "FAIL: reduce should return 15, got " + result4
    }
    print("PASS: array reduce")

    // Test 5: Complex pipeline: map -> filter -> reduce
    let squared = array.map_fn(numbers, fn(x) { return x * x })
    let big = array.filter_fn(squared, fn(x) { return x > 10 })
    let result5 = array.reduce_fn(big, fn(acc, x) { return acc + x }, 0)
    // [1,4,9,16,25] -> [16,25] -> 41
    if result5 != 41 {
        throw "FAIL: complex pipeline should return 41, got " + result5
    }
    print("PASS: complex map->filter->reduce pipeline")

    print("All array pipeline tests passed")
}
