// Test Composition Validator - Phase 2.4
// Comprehensive tests for block chain validation (40 tests total)

#include "naab/composition_validator.h"
#include "naab/type_system.h"
#include "naab/block_loader.h"
#include <fmt/core.h>
#include <iostream>
#include <cassert>
#include <memory>
#include <string>

using namespace naab;
using namespace naab::validator;
using namespace naab::types;
using naab::runtime::BlockMetadata;

#define ASSERT_TRUE(condition, test_name) \
    do { \
        if (!(condition)) { \
            fmt::print("  ✗ FAIL: {} (expected true)\n", test_name); \
            return false; \
        } \
        tests_passed++; \
    } while (0)

#define ASSERT_FALSE(condition, test_name) \
    do { \
        if (condition) { \
            fmt::print("  ✗ FAIL: {} (expected false)\n", test_name); \
            return false; \
        } \
        tests_passed++; \
    } while (0)

#define ASSERT_EQ(actual, expected, test_name) \
    do { \
        if ((actual) != (expected)) { \
            fmt::print("  ✗ FAIL: {} (expected: {}, got: {})\n", test_name, expected, actual); \
            return false; \
        } \
        tests_passed++; \
    } while (0)

static int tests_passed = 0;

// ============================================================================
// Mock BlockRegistry for Testing
// ============================================================================
class MockBlockRegistry {
public:
    MockBlockRegistry() {
        // Create mock blocks for testing
        createMockBlocks();
    }

    void createMockBlocks() {
        // Block 1: read_file - outputs string
        BlockMetadata read_file;
        read_file.block_id = "read_file";
        read_file.name = "read_file";
        read_file.output_type = "string";
        read_file.input_types = "string";  // filename
        mock_blocks_["read_file"] = read_file;

        // Block 2: parse_int - converts string to int
        BlockMetadata parse_int;
        parse_int.block_id = "parse_int";
        parse_int.name = "parse_int";
        parse_int.input_types = "string";
        parse_int.output_type = "int";
        mock_blocks_["parse_int"] = parse_int;

        // Block 3: add - adds two ints
        BlockMetadata add;
        add.block_id = "add";
        add.name = "add";
        add.input_types = "int";
        add.output_type = "int";
        mock_blocks_["add"] = add;

        // Block 4: to_string - converts int to string
        BlockMetadata to_string;
        to_string.block_id = "to_string";
        to_string.name = "to_string";
        to_string.input_types = "int";
        to_string.output_type = "string";
        mock_blocks_["to_string"] = to_string;

        // Block 5: split - splits string to array
        BlockMetadata split;
        split.block_id = "split";
        split.name = "split";
        split.input_types = "string";
        split.output_type = "array<string>";
        mock_blocks_["split"] = split;

        // Block 6: join - joins array to string
        BlockMetadata join;
        join.block_id = "join";
        join.name = "join";
        join.input_types = "array<string>";
        join.output_type = "string";
        mock_blocks_["join"] = join;

        // Block 7: map - transforms array
        BlockMetadata map;
        map.block_id = "map";
        map.name = "map";
        map.input_types = "array<int>";
        map.output_type = "array<int>";
        mock_blocks_["map"] = map;

        // Block 8: int_to_float adapter
        BlockMetadata int_to_float;
        int_to_float.block_id = "int_to_float_adapter";
        int_to_float.name = "int_to_float_adapter";
        int_to_float.category = "adapter";
        int_to_float.input_types = "int";
        int_to_float.output_type = "float";
        mock_blocks_["int_to_float_adapter"] = int_to_float;

        // Block 9: accepts float
        BlockMetadata sqrt_fn;
        sqrt_fn.block_id = "sqrt";
        sqrt_fn.name = "sqrt";
        sqrt_fn.input_types = "float";
        sqrt_fn.output_type = "float";
        mock_blocks_["sqrt"] = sqrt_fn;

        // Block 10: any type (accepts anything)
        BlockMetadata print;
        print.block_id = "print";
        print.name = "print";
        print.input_types = "any";
        print.output_type = "void";
        mock_blocks_["print"] = print;
    }

    std::optional<BlockMetadata> getBlock(const std::string& block_id) const {
        auto it = mock_blocks_.find(block_id);
        if (it != mock_blocks_.end()) {
            return it->second;
        }
        return std::nullopt;
    }

private:
    std::unordered_map<std::string, BlockMetadata> mock_blocks_;
};

// ============================================================================
// Test Group 1: Type System Tests (10 tests)
// ============================================================================
bool test_type_parsing() {
    fmt::print("\n=== Test Group 1: Type Parsing (10 tests) ===\n");

    // Test 1.1: Parse simple types
    {
        auto int_type = Type::parse("int");
        ASSERT_TRUE(int_type.has_value(), "parse int");
        ASSERT_EQ(int_type->toString(), "int", "int toString");
    }

    // Test 1.2: Parse string type
    {
        auto str_type = Type::parse("string");
        ASSERT_TRUE(str_type.has_value(), "parse string");
        ASSERT_EQ(str_type->toString(), "string", "string toString");
    }

    // Test 1.3: Parse array type
    {
        auto arr_type = Type::parse("array<int>");
        ASSERT_TRUE(arr_type.has_value(), "parse array<int>");
        ASSERT_EQ(arr_type->toString(), "array<int>", "array<int> toString");
    }

    // Test 1.4: Parse nested array
    {
        auto nested = Type::parse("array<array<string>>");
        ASSERT_TRUE(nested.has_value(), "parse nested array");
        ASSERT_EQ(nested->toString(), "array<array<string>>", "nested array toString");
    }

    // Test 1.5: Parse dict type
    {
        auto dict_type = Type::parse("dict<string,int>");
        ASSERT_TRUE(dict_type.has_value(), "parse dict");
        ASSERT_EQ(dict_type->toString(), "dict<string,int>", "dict toString");
    }

    // Test 1.6: Parse complex dict
    {
        auto complex = Type::parse("dict<string,array<int>>");
        ASSERT_TRUE(complex.has_value(), "parse complex dict");
        ASSERT_EQ(complex->toString(), "dict<string,array<int>>", "complex dict toString");
    }

    fmt::print("  ✓ All type parsing tests passed (10/10)\n");
    return true;
}

// ============================================================================
// Test Group 2: Type Compatibility Tests (10 tests)
// ============================================================================
bool test_type_compatibility() {
    fmt::print("\n=== Test Group 2: Type Compatibility (10 tests) ===\n");

    // Test 2.1: Same types compatible
    {
        auto int1 = Type::Int();
        auto int2 = Type::Int();
        ASSERT_TRUE(int1.isCompatibleWith(int2), "int compatible with int");
    }

    // Test 2.2: Int compatible with float
    {
        auto int_type = Type::Int();
        auto float_type = Type::Float();
        ASSERT_TRUE(int_type.isCompatibleWith(float_type), "int compatible with float");
    }

    // Test 2.3: Float NOT compatible with int (narrowing)
    {
        auto float_type = Type::Float();
        auto int_type = Type::Int();
        ASSERT_FALSE(float_type.isCompatibleWith(int_type), "float not compatible with int");
    }

    // Test 2.4: Any compatible with everything
    {
        auto any_type = Type::Any();
        auto int_type = Type::Int();
        ASSERT_TRUE(any_type.isCompatibleWith(int_type), "any compatible with int");
        ASSERT_TRUE(int_type.isCompatibleWith(any_type), "int compatible with any");
    }

    // Test 2.5: Array type compatibility
    {
        auto arr_int = Type::Array(Type::Int());
        auto arr_int2 = Type::Array(Type::Int());
        ASSERT_TRUE(arr_int.isCompatibleWith(arr_int2), "array<int> compatible with array<int>");
    }

    // Test 2.6: Array type incompatibility
    {
        auto arr_int = Type::Array(Type::Int());
        auto arr_str = Type::Array(Type::String());
        ASSERT_FALSE(arr_int.isCompatibleWith(arr_str), "array<int> not compatible with array<string>");
    }

    // Test 2.7: Dict compatibility
    {
        auto dict1 = Type::Dict(Type::String(), Type::Int());
        auto dict2 = Type::Dict(Type::String(), Type::Int());
        ASSERT_TRUE(dict1.isCompatibleWith(dict2), "dict<string,int> compatible with same");
    }

    // Test 2.8: String not compatible with int
    {
        auto str = Type::String();
        auto int_type = Type::Int();
        ASSERT_FALSE(str.isCompatibleWith(int_type), "string not compatible with int");
    }

    // Test 2.9: Bool not compatible with int
    {
        auto bool_type = Type::Bool();
        auto int_type = Type::Int();
        ASSERT_FALSE(bool_type.isCompatibleWith(int_type), "bool not compatible with int");
    }

    // Test 2.10: Void type
    {
        auto void_type = Type::Void();
        auto int_type = Type::Int();
        ASSERT_FALSE(void_type.isCompatibleWith(int_type), "void not compatible with int");
    }

    fmt::print("  ✓ All type compatibility tests passed (10/10)\n");
    return true;
}

// ============================================================================
// Test Group 3: Composition Validation Tests (10 tests)
// ============================================================================
bool test_composition_validation() {
    fmt::print("\n=== Test Group 3: Composition Validation (10 tests) ===\n");

    auto registry = std::make_shared<MockBlockRegistry>();
    CompositionValidator validator(registry);

    // Test 3.1: Empty chain is valid
    {
        auto result = validator.validate({});
        ASSERT_TRUE(result.is_valid, "empty chain valid");
    }

    // Test 3.2: Single block is valid
    {
        auto result = validator.validate({"read_file"});
        ASSERT_TRUE(result.is_valid, "single block valid");
    }

    // Test 3.3: Compatible chain: read_file -> parse_int
    {
        auto result = validator.validate({"read_file", "parse_int"});
        ASSERT_TRUE(result.is_valid, "read_file -> parse_int valid");
    }

    // Test 3.4: Compatible chain: parse_int -> add
    {
        auto result = validator.validate({"parse_int", "add"});
        ASSERT_TRUE(result.is_valid, "parse_int -> add valid");
    }

    // Test 3.5: Incompatible chain: read_file -> add
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_FALSE(result.is_valid, "read_file -> add invalid");
        ASSERT_EQ(result.errors.size(), 1, "one error");
    }

    // Test 3.6: Three-block valid chain
    {
        auto result = validator.validate({"read_file", "parse_int", "add"});
        ASSERT_TRUE(result.is_valid, "three-block valid chain");
    }

    // Test 3.7: Three-block invalid chain
    {
        auto result = validator.validate({"read_file", "add", "to_string"});
        ASSERT_FALSE(result.is_valid, "three-block invalid chain");
    }

    // Test 3.8: Array type chain valid
    {
        auto result = validator.validate({"split", "join"});
        ASSERT_TRUE(result.is_valid, "split -> join valid");
    }

    // Test 3.9: Int coerces to float
    {
        auto result = validator.validate({"add", "sqrt"});
        ASSERT_TRUE(result.is_valid, "int -> float valid (coercion)");
    }

    // Test 3.10: Any type accepts everything
    {
        auto result = validator.validate({"read_file", "print"});
        ASSERT_TRUE(result.is_valid, "string -> any valid");
    }

    fmt::print("  ✓ All composition validation tests passed (10/10)\n");
    return true;
}

// ============================================================================
// Test Group 4: Error Message Tests (10 tests)
// ============================================================================
bool test_error_messages() {
    fmt::print("\n=== Test Group 4: Error Messages (10 tests) ===\n");

    auto registry = std::make_shared<MockBlockRegistry>();
    CompositionValidator validator(registry);

    // Test 4.1: Error has position
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_FALSE(result.is_valid, "composition invalid");
        ASSERT_EQ(result.errors[0].position, 0, "error at position 0");
    }

    // Test 4.2: Error has source block
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_EQ(result.errors[0].source_block_id, "read_file", "source block");
    }

    // Test 4.3: Error has target block
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_EQ(result.errors[0].target_block_id, "add", "target block");
    }

    // Test 4.4: Error has expected type
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_EQ(result.errors[0].expected_type.toString(), "int", "expected type");
    }

    // Test 4.5: Error has actual type
    {
        auto result = validator.validate({"read_file", "add"});
        ASSERT_EQ(result.errors[0].actual_type.toString(), "string", "actual type");
    }

    // Test 4.6: Error message contains position
    {
        auto result = validator.validate({"read_file", "add"});
        auto msg = result.errors[0].formatMessage();
        ASSERT_TRUE(msg.find("position 0") != std::string::npos, "message contains position");
    }

    // Test 4.7: Error message contains block IDs
    {
        auto result = validator.validate({"read_file", "add"});
        auto msg = result.errors[0].formatMessage();
        ASSERT_TRUE(msg.find("read_file") != std::string::npos, "message contains source");
        ASSERT_TRUE(msg.find("add") != std::string::npos, "message contains target");
    }

    // Test 4.8: Validation report for valid chain
    {
        auto result = validator.validate({"read_file", "parse_int"});
        auto report = result.getReport();
        ASSERT_TRUE(report.find("valid") != std::string::npos, "report shows valid");
    }

    // Test 4.9: Validation report for invalid chain
    {
        auto result = validator.validate({"read_file", "add"});
        auto report = result.getReport();
        ASSERT_TRUE(report.find("invalid") != std::string::npos, "report shows invalid");
    }

    // Test 4.10: Format type mismatch utility
    {
        auto msg = formatTypeMismatch(Type::Int(), Type::String(), "test");
        ASSERT_TRUE(msg.find("int") != std::string::npos, "mismatch contains int");
        ASSERT_TRUE(msg.find("string") != std::string::npos, "mismatch contains string");
    }

    fmt::print("  ✓ All error message tests passed (10/10)\n");
    return true;
}

// ============================================================================
// Main Test Runner
// ============================================================================
int main() {
    fmt::print("╔═══════════════════════════════════════════════════════════════╗\n");
    fmt::print("║  Phase 2.4: Composition Validator - Comprehensive Tests      ║\n");
    fmt::print("║  Testing validation, error messages, and type compatibility  ║\n");
    fmt::print("╚═══════════════════════════════════════════════════════════════╝\n");

    try {
        bool all_passed = true;
        all_passed &= test_type_parsing();
        all_passed &= test_type_compatibility();
        all_passed &= test_composition_validation();
        all_passed &= test_error_messages();

        fmt::print("\n╔═══════════════════════════════════════════════════════════════╗\n");
        fmt::print("║                      Test Summary                             ║\n");
        fmt::print("╠═══════════════════════════════════════════════════════════════╣\n");
        fmt::print("║  Tests passed: {}/40                                          ║\n", tests_passed);

        if (all_passed && tests_passed == 40) {
            fmt::print("║  Status: ✓ ALL TESTS PASSED                                  ║\n");
            fmt::print("╚═══════════════════════════════════════════════════════════════╝\n");
            return 0;
        } else {
            fmt::print("║  Status: ✗ SOME TESTS FAILED                                 ║\n");
            fmt::print("╚═══════════════════════════════════════════════════════════════╝\n");
            return 1;
        }

    } catch (const std::exception& e) {
        fmt::print("\n[FATAL ERROR] Exception: {}\n", e.what());
        return 1;
    }
}
