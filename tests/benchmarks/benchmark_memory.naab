// Performance Benchmark: Memory Usage
// Tests: Large data structures, memory allocation patterns

use array
use string
use time

// Helper: Measure execution time
fn benchmark(name, func) {
    let start = time.now()
    func()
    let end_time = time.now()
    let elapsed = end_time - start

    print(name + ": " + elapsed + "ms")
    return elapsed
}

// Benchmark 1: Large array creation
fn bench_large_array() {
    let arr = []
    let i = 0
    while i < 10000 {
        arr = array.push(arr, i)
        i = i + 1
    }
    return array.length(arr)
}

// Benchmark 2: Large dict creation
fn bench_large_dict() {
    let dict = {}
    let i = 0
    while i < 5000 {
        dict["key_" + i] = "value_" + i
        i = i + 1
    }
    // Count keys by iterating
    let count = 0
    for key in dict {
        count = count + 1
    }
    return count
}

// Benchmark 3: Nested data structures
fn bench_nested_structures() {
    let data = []
    let i = 0
    while i < 100 {
        let record = {
            "id": i,
            "name": "Record " + i,
            "values": [i, i * 2, i * 3, i * 4, i * 5],
            "metadata": {
                "created": time.now(),
                "updated": time.now(),
                "status": "active"
            }
        }
        data = array.push(data, record)
        i = i + 1
    }
    return array.length(data)
}

// Benchmark 4: String concatenation
fn bench_string_concat() {
    let result = ""
    let i = 0
    while i < 1000 {
        result = result + "x"
        i = i + 1
    }
    return string.length(result)
}

// Benchmark 5: Array copying
fn bench_array_copy() {
    let original = []
    let i = 0
    while i < 1000 {
        original = array.push(original, i)
        i = i + 1
    }

    let iterations = 100
    i = 0
    while i < iterations {
        let copy = []
        for item in original {
            copy = array.push(copy, item)
        }
        i = i + 1
    }
}

// Benchmark 6: Memory churn (allocate and discard)
fn bench_memory_churn() {
    let iterations = 1000
    let i = 0
    while i < iterations {
        let temp = []
        let j = 0
        while j < 100 {
            temp = array.push(temp, j)
            j = j + 1
        }
        // temp goes out of scope and should be garbage collected
        i = i + 1
    }
}

main {
    print("========================================")
    print("  Memory Usage Benchmark")
    print("========================================")
    print("")

    let time1 = benchmark("Large array (10,000 elements)", bench_large_array)
    let time2 = benchmark("Large dict (5,000 entries)", bench_large_dict)
    let time3 = benchmark("Nested structures (100 records)", bench_nested_structures)
    let time4 = benchmark("String concatenation (1,000 chars)", bench_string_concat)
    let time5 = benchmark("Array copying (100x1000)", bench_array_copy)
    let time6 = benchmark("Memory churn (1000 iterations)", bench_memory_churn)

    // Summary
    print("")
    print("========================================")
    print("Summary:")
    let total = time1 + time2 + time3 + time4 + time5 + time6
    print("  Total execution time: " + total + "ms")
    print("  Average per benchmark: " + (total / 6) + "ms")
    print("")

    // Check for memory-related performance issues
    let all_pass = true
    if time1 > 5000 {
        print("  WARNING: Large array creation very slow (> 5s)")
        all_pass = false
    }
    if time2 > 5000 {
        print("  WARNING: Large dict creation very slow (> 5s)")
        all_pass = false
    }
    if time4 > 5000 {
        print("  WARNING: String concatenation very slow (> 5s)")
        all_pass = false
    }

    if all_pass {
        print("  Status: PASS (no major memory performance issues)")
    } else {
        print("  Status: WARNING (some memory operations are slow)")
    }

    print("")
    print("Note: Actual memory usage requires external profiling tools")
    print("========================================")
}
