// Performance Benchmark: Interpreter Execution
// Tests: Function calls, loops, array operations, recursion

use array
use string
use time

// Helper: Measure execution time
function benchmark(name, func) {
    let start = time.now()
    func()
    let end_time = time.now()
    let elapsed = end_time - start

    print(name + ": " + elapsed + "ms")
    return elapsed
}

// Benchmark 1: Function call overhead
function empty_function() {
    return 1
}

function bench_function_calls() {
    let i = 0
    let sum = 0
    while i < 10000 {
        sum = sum + empty_function()
        i = i + 1
    }
    return sum
}

// Benchmark 2: Loop performance
function bench_loops() {
    let sum = 0
    let i = 0
    while i < 40000 {
        sum = sum + i
        i = i + 1
    }
    return sum
}

// Benchmark 3: Array operations
function bench_array_ops() {
    let arr = []
    let i = 0
    while i < 1000 {
        arr = array.push(arr, i)
        i = i + 1
    }

    let sum = 0
    for item in arr {
        sum = sum + item
    }
    return sum
}

// Benchmark 4: Recursion
function fibonacci(n) {
    if n <= 1 {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

function bench_recursion() {
    return fibonacci(20)
}

// Benchmark 5: String operations
function bench_string_ops() {
    let str = "hello"
    let i = 0
    while i < 1000 {
        str = string.upper(str)
        str = string.lower(str)
        i = i + 1
    }
    return str
}

// Benchmark 6: Dict operations
function bench_dict_ops() {
    let dict = {}
    let i = 0
    while i < 1000 {
        dict["key" + i] = i
        i = i + 1
    }

    let sum = 0
    for key in dict {
        sum = sum + dict[key]
    }
    return sum
}

// Benchmark 7: Higher-order functions
function bench_higher_order() {
    let nums = []
    let i = 0
    while i < 100 {
        nums = array.push(nums, i)
        i = i + 1
    }

    let doubled = array.map_fn(nums, fn(x) { return x * 2 })
    let filtered = array.filter_fn(doubled, fn(x) { return x > 50 })
    let sum = array.reduce_fn(filtered, fn(acc, x) { return acc + x }, 0)

    return sum
}

main {
    print("========================================")
    print("  Interpreter Performance Benchmark")
    print("========================================")
    print("")

    let time1 = benchmark("Function calls (10,000)", bench_function_calls)
    let time2 = benchmark("While loop (40,000)", bench_loops)
    let time3 = benchmark("Array operations (1,000)", bench_array_ops)
    let time4 = benchmark("Recursion (fib 20)", bench_recursion)
    let time5 = benchmark("String operations (1,000)", bench_string_ops)
    let time6 = benchmark("Dict operations (1,000)", bench_dict_ops)
    let time7 = benchmark("Higher-order functions", bench_higher_order)

    // Summary
    print("")
    print("========================================")
    print("Summary:")
    let total = time1 + time2 + time3 + time4 + time5 + time6 + time7
    print("  Total execution time: " + total + "ms")
    print("  Average per benchmark: " + (total / 7) + "ms")
    print("")

    // Performance targets
    let all_pass = true
    if time1 > 1000 {
        print("  WARNING: Function calls slow (> 1s)")
        all_pass = false
    }
    if time2 > 1000 {
        print("  WARNING: Loops slow (> 1s)")
        all_pass = false
    }
    if time3 > 1000 {
        print("  WARNING: Array ops slow (> 1s)")
        all_pass = false
    }

    if all_pass {
        print("  Status: PASS (all benchmarks within targets)")
    } else {
        print("  Status: WARNING (some benchmarks exceeded targets)")
    }
    print("========================================")
}
